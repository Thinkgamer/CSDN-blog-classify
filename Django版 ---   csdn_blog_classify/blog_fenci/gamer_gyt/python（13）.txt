深刻理解Python中的元类(metaclass)


                                                                                   
                                                  


类也是对象

在理解元类之前，你需要先掌握Python中的类。Python中类的概念借鉴于Smalltalk，这显得有些奇特。在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。在Python中这一点仍然成立：







1

2

3

4

5

6




>>>
class

ObjectCreator(object):

…      
pass

…

>>>
 my_object =

ObjectCreator()

>>>
print

my_object

<__main__.ObjectCreator
object

at 0x8974f2c>








但是，Python中的类还远不止如此。类同样也是一种对象。是的，没错，就是对象。只要你使用关键字class，Python解释器在执行的时候就会创建一个对象。下面的代码段：







1

2

3




>>>
class

ObjectCreator(object):

…      
pass

…








将在内存中创建一个对象，名字就是ObjectCreator。这个对象（类）自身拥有创建对象（类实例）的能力，而这就是为什么它是一个类的原因。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：

1)   你可以将它赋值给一个变量

2)   你可以拷贝它

3)   你可以为它增加属性

4)   你可以将它作为函数参数进行传递

下面是示例：







1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17




>>>
print

ObjectCreator     #
 你可以打印一个类，因为它其实也是一个对象

<class

'__main__.ObjectCreator'>

>>>
def

echo(o):

…      
print

o

…

>>>
 echo(ObjectCreator)                 #
 你可以将类做为参数传给函数

<class

'__main__.ObjectCreator'>

>>>
print

hasattr(ObjectCreator,
'new_attribute')

Fasle

>>>
 ObjectCreator.new_attribute =

'foo' 
#  你可以为类增加属性

>>>
print

hasattr(ObjectCreator,
'new_attribute')

True

>>>
print

ObjectCreator.new_attribute

foo

>>>
 ObjectCreatorMirror =

ObjectCreator #
 你可以将类赋值给一个变量

>>>
print

ObjectCreatorMirror()

<__main__.ObjectCreator
object

at 0x8997b4c>








 

动态地创建类

因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用class关键字即可。







1

2

3

4

5

6

7

8

9

10

11

12

13

14

15




>>>
def

choose_class(name):

…      
if

name ==

'foo':

…          
class

Foo(object):

…              
pass

…          
return

Foo     #
 返回的是类，不是类的实例

…      
else:

…          
class

Bar(object):

…              
pass

…          
return

Bar

…

>>>
 MyClass =

choose_class('foo')

>>>
print

MyClass              #
 函数返回的是类，不是类的实例

<class

'__main__'.Foo>

>>>
print

MyClass()            #
 你可以通过这个类创建类实例，也就是对象

<__main__.Foo
object

at 0x89c6d4c>








但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。还记得内建函数type吗？这个古老但强大的函数能够让你知道一个对象的类型是什么，就像这样：







1

2

3

4

5

6

7

8




>>>
print

type(1)

<type

'int'>

>>>
print

type("1")

<type

'str'>

>>>
print

type(ObjectCreator)

<type

'type'>

>>>
print

type(ObjectCreator())

<class

'__main__.ObjectCreator'>








这里，type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类。（我知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）

type可以像这样工作：







1




type(类名,
 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)








比如下面的代码：







1

2




>>>
class

MyShinyClass(object):

…      
pass








可以手动像这样创建：







1

2

3

4

5




>>>
 MyShinyClass =

type('MyShinyClass',
 (), {})  #
 返回一个类对象

>>>
print

MyShinyClass

<class

'__main__.MyShinyClass'>

>>>
print

MyShinyClass()  # 
 创建一个该类的实例

<__main__.MyShinyClass
object

at 0x8997cec>








你会发现我们使用“MyShinyClass”作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。

type 接受一个字典来为类定义属性，因此







1

2




>>>
class

Foo(object):

…      
 bar =

True








可以翻译为：







1




>>>
 Foo =

type('Foo',
 (), {'bar':True})








并且可以将Foo当成一个普通的类一样使用：







1

2

3

4

5

6

7

8

9




>>>
print

Foo

<class

'__main__.Foo'>

>>>
print

Foo.bar

True

>>>
 f =

Foo()

>>>
print

f

<__main__.Foo
object

at 0x8a9b84c>

>>>
print

f.bar

True








当然，你可以向这个类继承，所以，如下的代码：







1

2




>>>
class

FooChild(Foo):

…      
pass








就可以写成：







1

2

3

4

5




>>>
 FooChild =

type('FooChild',
 (Foo,),{})

>>>
print

FooChild

<class

'__main__.FooChild'>

>>>
print

FooChild.bar   #
 bar属性是由Foo继承而来

True








最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。







1

2

3

4

5

6

7

8

9

10

11




>>>
def

echo_bar(self):

…      
print

self.bar

…

>>>
 FooChild =

type('FooChild',
 (Foo,), {'echo_bar':
 echo_bar})

>>>
hasattr(Foo,
'echo_bar')

False

>>>
hasattr(FooChild,
'echo_bar')

True

>>>
 my_foo =

FooChild()

>>>
 my_foo.echo_bar()

True








你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是当你使用关键字class时Python在幕后做的事情，而这就是通过元类来实现的。

 

到底什么是元类（终于到主题了）

元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解 为：







1

2




MyClass
=

MetaClass()

MyObject
=

MyClass()








你已经看到了type可以让你像这样做：







1




MyClass
=

type('MyClass',
 (), {})








这是因为函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。







1

2

3

4

5

6

7

8

9

10

11

12

13




>>>
 age =

35

>>>
 age.__class__

<type

'int'>

>>>
 name =

'bob'

>>>
 name.__class__

<type

'str'>

>>>
def

foo(): pass

>>>foo.__class__

<type

'function'>

>>>
class

Bar(object):
pass

>>>
 b =

Bar()

>>>
 b.__class__

<class

'__main__.Bar'>








现在，对于任何一个__class__的__class__属性又是什么呢？







1

2

3

4

5

6

7

8




>>>
 a.__class__.__class__

<type

'type'>

>>>
 age.__class__.__class__

<type

'type'>

>>>
 foo.__class__.__class__

<type

'type'>

>>>
 b.__class__.__class__

<type

'type'>








因此，元类就是创建类这种对象的东西。如果你喜欢的话，可以把元类称为“类工厂”（不要和工厂类搞混了:D） type就是Python的内建元类，当然了，你也可以创建自己的元类。

 

__metaclass__属性

你可以在写一个类的时候为其添加__metaclass__属性。







1

2

3




class

Foo(object):

    __metaclass__
=

something…

[…]








如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下class Foo(object)，但是类对象Foo还没有在内存中创建。Python会在类的定义中寻找__metaclass__属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的type来创建这个类。把下面这段话反复读几次。当你写如下代码时 :







1

2




class

Foo(Bar):

    pass








Python做了如下的操作：

Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到__metaclass__，它会继续在Bar（父类）中寻找__metaclass__属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。

现在的问题就是，你可以在__metaclass__中放置些什么代码呢？答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东东都可以。

 

自定义元类

元类的主要目的就是为了当创建类时能够自动地改变类。通常，你会为API做这样的事情，你希望可以创建符合当前上下文的类。假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定__metaclass__。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。

幸运的是，__metaclass__实际上可以被任意调用，它并不需要是一个正式的类（我知道，某些名字里带有‘class’的东西并不需要是一个class，画画图理解下，这很有帮助）。所以，我们这里就先以一个简单的函数作为例子开始。







1

2

3

4

5




#
 元类会自动将你通常传给‘type’的参数作为自己的参数传入

def

upper_attr(future_class_name, future_class_parents, future_class_attr):

    '''返回一个类对象，将属性都转为大写形式'''

    # 
 选择所有不以'__'开头的属性

    attrs
=

((name, value) for

name, value in

future_class_attr.items() if

not 
name.startswith('__'))














1

2

3

4

5

6

7

8

9

10

11




    #
 将它们转为大写形式

    uppercase_attr
=

dict((name.upper(),
 value) for

name, value in

attrs)

 

    #
 通过'type'来做类对象的创建

    return

type(future_class_name,
 future_class_parents, uppercase_attr)

 

__metaclass__
=

upper_attr  # 
 这会作用到这个模块中的所有类

 

class

Foo(object):

    #
 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中

    bar
=

'bip'














1

2

3

4

5

6

7

8




print

hasattr(Foo,
'bar')

#
 输出: False

print

hasattr(Foo,
'BAR')

#
 输出:True

 

f
=

Foo()

print

f.BAR

#
 输出:'bip'








现在让我们再做一次，这一次用一个真正的class来当做元类。







1

2

3

4

5

6

7

8

9

10

11

12

13

14




#
 请记住，'type'实际上是一个类，就像'str'和'int'一样

#
 所以，你可以从type继承

class

UpperAttrMetaClass(type):

    #
 __new__ 是在__init__之前被调用的特殊方法

    #
 __new__是用来创建对象并返回之的方法

    #
 而__init__只是用来将传入的参数初始化给对象

    #
 你很少用到__new__，除非你希望能够控制对象的创建

    #
 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__

    #
 如果你希望的话，你也可以在__init__中做些事情

    #
 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用

    def

__new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):

        attrs
=

((name, value) for

name, value in

future_class_attr.items() if

not 
name.startswith('__'))

        uppercase_attr
=

dict((name.upper(),
 value) for

name, value in

attrs)

        return

type(future_class_name,
 future_class_parents, uppercase_attr)








但是，这种方式其实不是OOP。我们直接调用了type，而且我们没有改写父类的__new__方法。现在让我们这样去处理:







1

2

3

4

5

6

7

8




class

UpperAttrMetaclass(type):

    def

__new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):

        attrs
=

((name, value) for

name, value in

future_class_attr.items() if

not 
name.startswith('__'))

        uppercase_attr
=

dict((name.upper(),
 value) for

name, value in

attrs)

 

        #
 复用type.__new__方法

        #
 这就是基本的OOP编程，没什么魔法

        return

type.__new__(upperattr_metaclass,
 future_class_name, future_class_parents, uppercase_attr)








你可能已经注意到了有个额外的参数upperattr_metaclass，这并没有什么特别的。类方法的第一个参数总是表示当前的实例，就像在普通的类方法中的self参数一样。当然了，为了清晰起见，这里的名字我起的比较长。但是就像self一样，所有的参数都有它们的传统名称。因此，在真实的产品代码中一个元类应该是像这样的：







1

2

3

4

5




class

UpperAttrMetaclass(type):

    def

__new__(cls,
 name, bases, dct):

        attrs
=

((name, value) for

name, value in

dct.items() if

not 
name.startswith('__')

        uppercase_attr 
=

dict((name.upper(),
 value) for

name, value in

attrs)

        return

type.__new__(cls,
 name, bases, uppercase_attr)








如果使用super方法的话，我们还可以使它变得更清晰一些，这会缓解继承（是的，你可以拥有元类，从元类继承，从type继承）







1

2

3

4

5




class

UpperAttrMetaclass(type):

    def

__new__(cls,
 name, bases, dct):

        attrs
=

((name, value) for

name, value in

dct.items() if

not 
name.startswith('__'))

        uppercase_attr
=

dict((name.upper(),
 value) for

name, value in

attrs)

        return

super(UpperAttrMetaclass,
cls).__new__(cls,
 name, bases, uppercase_attr)








就是这样，除此之外，关于元类真的没有别的可说的了。使用到元类的代码比较复杂，这背后的原因倒并不是因为元类本身，而是因为你通常会使用元类去做一些晦涩的事情，依赖于自省，控制继承等等。确实，用元类来搞些“黑暗魔法”是特别有用的，因而会搞出些复杂的东西来。但就元类本身而言，它们其实是很简单的：

1)   拦截类的创建

2)   修改类

3)   返回修改之后的类

 

为什么要用metaclass类而不是函数?

由于__metaclass__可以接受任何可调用的对象，那为何还要使用类呢，因为很显然使用类会更加复杂啊？这里有好几个原因：

1）  意图会更加清晰。当你读到UpperAttrMetaclass(type)时，你知道接下来要发生什么。

2） 你可以使用OOP编程。元类可以从元类中继承而来，改写父类的方法。元类甚至还可以使用元类。

3）  你可以把代码组织的更好。当你使用元类的时候肯定不会是像我上面举的这种简单场景，通常都是针对比较复杂的问题。将多个方法归总到一个类中会很有帮助，也会使得代码更容易阅读。

4） 你可以使用__new__, __init__以及__call__这样的特殊方法。它们能帮你处理不同的任务。就算通常你可以把所有的东西都在__new__里处理掉，有些人还是觉得用__init__更舒服些。

5） 哇哦，这东西的名字是metaclass，肯定非善类，我要小心！

 

究竟为什么要使用元类？

现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？好吧，一般来说，你根本就用不上它：

“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。”  —— Python界的领袖 Tim Peters

元类的主要用途是创建API。一个典型的例子是Django ORM。它允许你像这样定义：







1

2

3




class

Person(models.Model):

    name
=

models.CharField(max_length=30)

    age
=

models.IntegerField()








但是如果你像这样做的话：







1

2




guy 
=

Person(name='bob',
 age='35')

print

guy.age








这并不会返回一个IntegerField对象，而是会返回一个int，甚至可以直接从数据库中取出数据。这是有可能的，因为models.Model定义了__metaclass__， 并且使用了一些魔法能够将你刚刚定义的简单的Person类转变成对数据库的一个复杂hook。Django框架将这些看起来很复杂的东西通过暴露出一个简单的使用元类的API将其化简，通过这个API重新创建代码，在背后完成真正的工作。

 

结语

首先，你知道了类其实是能够创建出类实例的对象。好吧，事实上，类本身也是实例，当然，它们是元类的实例。







1

2

3




>>>class

Foo(object):
pass

>>>
id(Foo)

142630324








Python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。其次，元类是很复杂的。对于非常简单的类，你可能不希望通过使用元类来对类做修改。你可以通过其他两种技术来修改类：

1） Monkey patching

2)   class decorators

当你需要动态修改类时，99%的时间里你最好使用上面这两种技术。当然了，其实在99%的时间里你根本就不需要动态修改类 :D

Python 类属性的理解

一：类的属性包括
1：实例属性


2：类属性


3：私有属性


例子：

(1)：以双下划线开头标志的字符
class A:
    def __init__(self):
        self.__x = 1
    def info(self):
        print self.__x


a = A()
a.info()


a.__x = 2
a.info()
print a.__x



>>
1
1
2
(2)：以单下划线开头标志的字符


class A:
    def __init__(self):
        self._x = 1
    def info(self):
        print self._x


a = A()
a.info()


a._x = 2
a.info()
print a._x



>>
1
2
2

4：特殊属性


二：深入理解类的属性





关于Python多线程的理解

多线程和多进程是什么自行google补脑
　　对于python 多线程的理解，我花了很长时间，搜索的大部份文章都不够通俗易懂。所以，这里力图用简单的例子，让你对多线程有个初步的认识。
 
单线程
 
　　在好些年前的MS-DOS时代，操作系统处理问题都是单任务的，我想做听音乐和看电影两件事儿，那么一定要先排一下顺序。
（好吧！我们不纠结在DOS时代是否有听音乐和看影的应用。^_^）

from time import ctime,sleep

def music():
    for i in range(2):
        print "I was listening to music. %s" %ctime()
        sleep(1)

def move():
    for i in range(2):
        print "I was at the movies! %s" %ctime()
        sleep(5)

if __name__ == '__main__':
    music()
    move()
    print "all over %s" %ctime()

 　　我们先听了一首音乐，通过for循环来控制音乐的播放了两次，每首音乐播放需要1秒钟，sleep()来控制音乐播放的时长。接着我们又看了一场电影，
每一场电影需要5秒钟，因为太好看了，所以我也通过for循环看两遍。在整个休闲娱乐活动结束后，我通过
print "all over %s" %ctime()
看了一下当前时间，差不多该睡觉了。
运行结果：

>>=========================== RESTART ================================
>>> 
I was listening to music. Thu Apr 17 10:47:08 2014
I was listening to music. Thu Apr 17 10:47:09 2014
I was at the movies! Thu Apr 17 10:47:10 2014
I was at the movies! Thu Apr 17 10:47:15 2014
all over Thu Apr 17 10:47:20 2014

　　其实，music()和move()更应该被看作是音乐和视频播放器，至于要播放什么歌曲和视频应该由我们使用时决定。所以，我们对上面代码做了改造：

#coding=utf-8
import threading
from time import ctime,sleep

def music(func):
    for i in range(2):
        print "I was listening to %s. %s" %(func,ctime())
        sleep(1)

def move(func):
    for i in range(2):
        print "I was at the %s! %s" %(func,ctime())
        sleep(5)



if __name__ == '__main__':
    music(u'爱情买卖')
    move(u'阿凡达')

    print "all over %s" %ctime()

　　对music()和move()进行了传参处理。体验中国经典歌曲和欧美大片文化。
运行结果：

>>> ======================== RESTART ================================
>>> 
I was listening to 爱情买卖. Thu Apr 17 11:48:59 2014
I was listening to 爱情买卖. Thu Apr 17 11:49:00 2014
I was at the 阿凡达! Thu Apr 17 11:49:01 2014
I was at the 阿凡达! Thu Apr 17 11:49:06 2014
all over Thu Apr 17 11:49:11 2014

多线程
 
　　科技在发展，时代在进步，我们的CPU也越来越快，CPU抱怨，P大点事儿占了我一定的时间，其实我同时干多个活都没问题的；于是，操作系统就进入了多任务时代。我们听着音乐吃着火锅的不在是梦想。
　　python提供了两个模块来实现多线程thread 和threading ，thread 有一些缺点，在threading 得到了弥补，为了不浪费你和时间，所以我们直接学习threading 就可以了。
继续对上面的例子进行改造，引入threadring来同时播放音乐和视频：

#coding=utf-8
import threading
from time import ctime,sleep


def music(func):
    for i in range(2):
        print "I was listening to %s. %s" %(func,ctime())
        sleep(1)

def move(func):
    for i in range(2):
        print "I was at the %s! %s" %(func,ctime())
        sleep(5)

threads = []
t1 = threading.Thread(target=music,args=(u'爱情买卖',))
threads.append(t1)
t2 = threading.Thread(target=move,args=(u'阿凡达',))
threads.append(t2)

if __name__ == '__main__':
    for t in threads:
        t.setDaemon(True)
        t.start()

    print "all over %s" %ctime()

import threading
首先导入threading 模块，这是使用多线程的前提。
 
threads = []
t1 = threading.Thread(target=music,args=(u'爱情买卖',))
threads.append(t1)
　　创建了threads数组，创建线程t1,使用threading.Thread()方法，在这个方法中调用music方法target=music，args方法对music进行传参。 把创建好的线程t1装到threads数组中。
　　接着以同样的方式创建线程t2，并把t2也装到threads数组。
 
for t in threads:
　　t.setDaemon(True)
　　t.start()
最后通过for循环遍历数组。（数组被装载了t1和t2两个线程）
 
setDaemon()
　　setDaemon(True)将线程声明为守护线程，必须在start() 方法调用之前设置，如果不设置为守护线程程序会被无限挂起。子线程启动后，父线程也继续执行下去，当父线程执行完最后一条语句print "all over %s" %ctime()后，没有等待子线程，直接就退出了，同时子线程也一同结束。
 
start()
开始线程活动。
 
运行结果：

>>> ========================= RESTART ================================
>>> 
I was listening to 爱情买卖. Thu Apr 17 12:51:45 2014 I was at the 阿凡达! Thu Apr 17 12:51:45 2014  all over Thu Apr 17 12:51:45 2014

　　从执行结果来看，子线程（muisc 、move ）和主线程（print "all over %s" %ctime()）都是同一时间启动，但由于主线程执行完结束，所以导致子线程也终止。 
 
继续调整程序：

...
if __name__ == '__main__':
    for t in threads:
        t.setDaemon(True)
        t.start()
    
    t.join()

    print "all over %s" %ctime()

　　我们只对上面的程序加了个join()方法，用于等待线程终止。join（）的作用是，在子线程完成运行之前，这个子线程的父线程将一直被阻塞。
　　注意:  join()方法的位置是在for循环外的，也就是说必须等待for循环里的两个进程都结束后，才去执行主进程。
运行结果：

>>> ========================= RESTART ================================
>>> 
I was listening to 爱情买卖. Thu Apr 17 13:04:11 2014  I was at the 阿凡达! Thu Apr 17 13:04:11 2014

I was listening to 爱情买卖. Thu Apr 17 13:04:12 2014
I was at the 阿凡达! Thu Apr 17 13:04:16 2014
all over Thu Apr 17 13:04:21 2014

　　从执行结果可看到，music 和move 是同时启动的。
　　开始时间4分11秒，直到调用主进程为4分22秒，总耗时为10秒。从单线程时减少了2秒，我们可以把music的sleep()的时间调整为4秒。

...
def music(func):
    for i in range(2):
        print "I was listening to %s. %s" %(func,ctime())
        sleep(4)
...

执行结果：

>>> ====================== RESTART ================================
>>> 
I was listening to 爱情买卖. Thu Apr 17 13:11:27 2014I was at the 阿凡达! Thu Apr 17 13:11:27 2014

I was listening to 爱情买卖. Thu Apr 17 13:11:31 2014
I was at the 阿凡达! Thu Apr 17 13:11:32 2014
all over Thu Apr 17 13:11:37 2014

　　子线程启动11分27秒，主线程运行11分37秒。
　　虽然music每首歌曲从1秒延长到了4 ，但通多程线的方式运行脚本，总的时间没变化。
 
本文从感性上让你快速理解python多线程的使用，更详细的使用请参考其它文档或资料。
 ==========================================================
class threading.Thread()说明：
 
class threading.Thread(group=None, target=None, name=None, args=(), kwargs={})
This constructor should always be called with keyword arguments. Arguments are:
　　group should be None; reserved for future extension when a ThreadGroup class is implemented.
　　target is the callable object to be invoked by the run() method. Defaults to None, meaning nothing is called.
　　name is the thread name. By default, a unique name is constructed of the form “Thread-N” where N is a small decimal number.
　　args is the argument tuple for the target invocation. Defaults to ().
　　kwargs is a dictionary of keyword arguments for the target invocation. Defaults to {}.
If the subclass overrides the constructor, it must make sure to invoke the base class constructor (Thread.__init__()) before doing 
anything else to the thread.

Scikit Learn: 在python中机器学习


Warning 
警告：有些没能理解的句子，我以自己的理解意译。 


翻译自：Scikit Learn:Machine Learning in Python


作者: Fabian Pedregosa, Gael Varoquaux 

先决条件 


Numpy, Scipy IPython matplotlib scikit-learn


目录 





载入示例数据

一个改变数据集大小的示例：数码数据集(digits datasets)
学习和预测

分类

K最近邻(KNN)分类器

训练集和测试集

分类支持向量机(SVMs)

线性支持向量机
使用核


聚类：将观测值聚合

k均值聚类

应用到图像压缩


用主成分分析降维
将一切放在一起：人脸识别
线性模型：从回归到稀疏

稀疏模型

同一问题的不同算法


模型选择：选择估计器和它们的参数

格点搜索和交叉验证估计器

格点搜索
交叉验证估计器


Footnotes





警告：在0.9版中(2011年9月发行)，scikit-learn的导入路径从scikits.learn更改为sklearn



载入示例数据 

首先我们载入一些用来玩耍的数据。我们将使用的数据是非常简单的著名的花朵数据——安德森鸢尾花卉数据集。


我们有一百五十个鸢尾花的一些尺寸的观测值：萼片长度、宽度，花瓣长度和宽度。还有它们的亚属：山鸢尾（Iris setosa）、变色鸢尾（Iris versicolor）和维吉尼亚鸢尾（Iris virginica）


向python对象载入数据： 

In [1]: from sklearn import datasets
In [2]: iris = datasets.load_iris()

数据存储在.data项中，是一个(n_samples, n_features)数组。 


In [3]: iris.data.shape
Out[3]: (150, 4)

每个观察对象的种类存贮在数据集的.target属性中。这是一个长度为n_samples的整数一维数组:


In [5]: iris.target.shape
Out[5]: (150,)

In [6]: import numpy as np

In [7]: np.unique(iris.target)
Out[7]: array([0, 1, 2])

一个改变数据集大小的示例：数码数据集(digits datasets) 

数码数据集1包括1797个图像，每一个都是个代表手写数字的8x8像素图像


In [8]: digits = datasets.load_digits()

In [9]: digits.images.shape
Out[9]: (1797, 8, 8)

In [10]: import pylab as pl

In [11]: pl.imshow(digits.images[0], cmap=pl.cm.gray_r) 
Out[11]: <matplotlib.image.AxesImage at 0x3285b90>

In [13]: pl.show()

为了在scikit中使用这个数据集，我们把每个8x8图像转换成长度为64的矢量。(译者注：或者直接用digits.data)


In [12]: data = digits.images.reshape((digits.images.shape[0], -1))

学习和预测 

现在我们已经获得一些数据，我们想要从中学习和预测一个新的数据。在scikit-learn中，我们通过创建一个估计器(estimator)从已经存在的数据学习，并且调用它的fit(X,Y)方法。


In [14]: from sklearn import svm

In [15]: clf = svm.LinearSVC()

In [16]: clf.fit(iris.data, iris.target) # learn from the data 
Out[16]: 
LinearSVC(C=1.0, class_weight=None, dual=True, fit_intercept=True,
     intercept_scaling=1, loss='l2', multi_class='ovr', penalty='l2',
     tol=0.0001, verbose=0)

一旦我们已经从数据学习，我们可以使用我们的模型来预测未观测数据最可能的结果。 

In [17]: clf.predict([[ 5.0,  3.6,  1.3,  0.25]])
Out[17]: array([0], dtype=int32)

注意：我们可以通过它以下划线结束的属性存取模型的参数： 


In [18]: clf.coef_  
Out[18]: 
array([[ 0.18424352,  0.45122644, -0.8079467 , -0.45071302],
       [ 0.05190619, -0.89423619,  0.40519245, -0.93781587],
       [-0.85087844, -0.98667529,  1.38088883,  1.86538111]])

分类 

K最近邻(KNN)分类器 

最简单的可能的分类器是最近邻：给定一个新的观测值，将n维空间中最靠近它的训练样本标签给它。其中n是每个样本中特性(features)数。


k最近邻2分类器内部使用基于球树(ball tree)3来代表它训练的样本。


KNN分类示例： 

In [19]: # Create and fit a nearest-neighbor classifier

In [20]: from sklearn import neighbors

In [21]: knn = neighbors.KNeighborsClassifier()

In [22]: knn.fit(iris.data, iris.target) 
Out[22]: 
KNeighborsClassifier(algorithm='auto', leaf_size=30, n_neighbors=5, p=2,
           warn_on_equidistant=True, weights='uniform')

In [23]: knn.predict([[0.1, 0.2, 0.3, 0.4]])
Out[23]: array([0])

训练集和测试集 

当验证学习算法时，不要用一个用来拟合估计器的数据来验证估计器的预测非常重要。确实，通过kNN估计器，我们将总是获得关于训练集完美的预测。


In [24]: perm = np.random.permutation(iris.target.size)

In [25]: iris.data = iris.data[perm]

In [26]: iris.target = iris.target[perm]

In [27]: knn.fit(iris.data[:100], iris.target[:100]) 
Out[27]: 
KNeighborsClassifier(algorithm='auto', leaf_size=30, n_neighbors=5, p=2,
           warn_on_equidistant=True, weights='uniform')

In [28]: knn.score(iris.data[100:], iris.target[100:]) 
/usr/lib/python2.7/site-packages/sklearn/neighbors/classification.py:129: NeighborsWarning: kneighbors: neighbor k+1 and neighbor k have the same distance: results will be dependent on data order.
  neigh_dist, neigh_ind = self.kneighbors(X)
Out[28]: 0.95999999999999996

Bonus的问题：为什么我们使用随机的排列？ 

分类支持向量机(SVMs) 

线性支持向量机 

SVMs4尝试构建一个两个类别的最大间隔超平面。它选择输入的子集，调用支持向量即离分离的超平面最近的样本点。


In [60]: from sklearn import svm

In [61]: svc = svm.SVC(kernel='linear')

In [62]: svc.fit(iris.data, iris.target)
Out[62]: 
SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0, degree=3, gamma=0.0,
  kernel='linear', probability=False, shrinking=True, tol=0.001,
  verbose=False)

scikit-learn中有好几种支持向量机实现。最普遍使用的是svm.SVC，svm.NuSVC和svm.LinearSVC;“SVC”代表支持向量分类器(Support Vector Classifier)(也存在回归SVMs，在scikit-learn中叫作“SVR”)。


练习 

训练一个数字数据集的svm.SVC。省略最后10%并且检验观测值的预测表现。 

使用核 

类别不总是可以用超平面分离，所以人们指望有些可能是多项式或指数实例的非线性决策函数： 




线性核 
svc = svm.SVC(kernel=’linear’) 

多项式核 
svc = svm.SVC(kernel=’poly’, … degree=3) # degree: polynomial degree


RBF核(径向基函数)5

svc = svm.SVC(kernel=’rbf’) # gamma: inverse of size of # radial kernel



练习 

以上提到的哪些核对数字数据集有更好的预测性能？(译者：前两个) 

聚类：将观测值聚合 

给定鸢尾花数据集，如果我们知道这有三种鸢尾花，但是无法得到它们的标签，我们可以尝试非监督学习：我们可以通过某些标准聚类观测值到几个组别里。


k均值聚类 

最简答的聚类算法是k均值算法。这将一个数据分成k个集群，以最小化观测值(n维空间中)到聚类中心的均值来分配每个观测点到集群;然后均值重新被计算。这个操作递归运行直到聚类收敛，在max_iter回合内到最大值。6


(一个替代的k均值算法实现在scipy中的cluster包中。这个scikit-learn实现与之不同，通过提供对象API和几个额外的特性，包括智能初始化。)


In [82]: from sklearn import cluster, datasets

In [83]: iris = datasets.load_iris()

In [84]: k_means = cluster.KMeans(k=3)

In [85]: k_means.fit(iris.data) 
Out[85]: 
KMeans(copy_x=True, init='k-means++', k=3, max_iter=300, n_init=10, n_jobs=1,
    precompute_distances=True,
    random_state=<mtrand.RandomState object at 0x7f4d860642d0>, tol=0.0001,
    verbose=0)

In [86]: print k_means.labels_[::10]
[1 1 1 1 1 2 2 2 2 2 0 0 0 0 0]

In [87]: print iris.target[::10]
[0 0 0 0 0 1 1 1 1 1 2 2 2 2 2]

应用到图像压缩 

译者注：Lena是经典的图像处理实例图像, 8位灰度色深, 尺寸512 x 512 


聚类可以被看作是一种从信息中选择一小部分观测值。例如，这个可以被用来海报化一个图像(将连续变化的色调转换成更少几个色调)：


In [95]: from scipy import misc

In [96]: lena = misc.lena().astype(np.float32)

In [97]: X = lena.reshape((-1, 1)) # We need an (n_sample, n_feature) array

In [98]: k_means = cluster.KMeans(5)

In [99]: k_means.fit(X)
Out[99]: 
KMeans(copy_x=True, init='k-means++', k=5, max_iter=300, n_init=10, n_jobs=1,
    precompute_distances=True,
    random_state=<mtrand.RandomState object at 0x7f4d860642d0>, tol=0.0001,
    verbose=0)

In [100]: values = k_means.cluster_centers_.squeeze()

In [101]: labels = k_means.labels_

In [102]: lena_compressed = np.choose(labels, values)

In [103]: lena_compressed.shape = lena.shape

译者注：想看效果？ 

In [31]: import matplotlib.pyplot as plt

In [32]: plt.gray()

In [33]: plt.imshow(lena_compressed)
Out[33]: <matplotlib.image.AxesImage at 0x4b2c510>

In [34]: plt.show()

原图类似。 

![Image] 

用主成分分析降维 

以上根据观测值标记的点云在一个方向非常平坦，所以一个特性几乎可以用其它两个确切地计算。PCA发现哪个方向的数据不是平的并且它可以通过在一个子空间投影来降维。


警告：PCA将在模块decomposition或pca中，这取决于你scikit-learn的版本。


In [75]: from sklearn import decomposition

In [76]: pca = decomposition.PCA(n_components=2)

In [77]: pca.fit(iris.data)
Out[77]: PCA(copy=True, n_components=2, whiten=False)

In [78]: X = pca.transform(iris.data)

现在我们可以可视化(降维过的)鸢尾花数据集： 

In [79]: import pylab as pl

In [80]: pl.scatter(X[:, 0], X[:, 1], c=iris.target)
Out[80]: <matplotlib.collections.PathCollection at 0x4104310>

PCA不仅在可视化高维数据集时非常有用。它可以用来作为帮助加速对高维数据不那么有效率的监督方法7的预处理步骤。


将一切放在一起：人脸识别 

一个实例使用主成分分析来降维和支持向量机来分类进行人脸识别。 

译者注：让程序自动下载(确保联网，文件较大，要等待很久)或者手动下载数据并放到./scikit_learn_data/lfw_home/下。


"""
Stripped-down version of the face recognition example by Olivier Grisel

http://scikit-learn.org/dev/auto_examples/applications/face_recognition.html

## original shape of images: 50, 37
"""
import numpy as np
import pylab as pl
from sklearn import cross_val, datasets, decomposition, svm

# ..
# .. load data ..
lfw_people = datasets.fetch_lfw_people(min_faces_per_person=70, resize=0.4)
perm = np.random.permutation(lfw_people.target.size)
lfw_people.data = lfw_people.data[perm]
lfw_people.target = lfw_people.target[perm]
faces = np.reshape(lfw_people.data, (lfw_people.target.shape[0], -1))
train, test = iter(cross_val.StratifiedKFold(lfw_people.target, k=4)).next()
X_train, X_test = faces[train], faces[test]
y_train, y_test = lfw_people.target[train], lfw_people.target[test]

# ..
# .. dimension reduction ..
pca = decomposition.RandomizedPCA(n_components=150, whiten=True)
pca.fit(X_train)
X_train_pca = pca.transform(X_train)
X_test_pca = pca.transform(X_test)

# ..
# .. classification ..
clf = svm.SVC(C=5., gamma=0.001)
clf.fit(X_train_pca, y_train)

# ..
# .. predict on new images ..
for i in range(10):
    print lfw_people.target_names[clf.predict(X_test_pca[i])[0]]
    _ = pl.imshow(X_test[i].reshape(50, 37), cmap=pl.cm.gray)
    _ = raw_input()

全部代码：face.py


线性模型：从回归到稀疏 

糖尿病数据集 

糖尿病数据集包含442个病人的测量而得的10项生理指标(年龄，性别，体重，血压)，和一年后疾病进展的指示：


In [104]: diabetes = datasets.load_diabetes()

In [105]: diabetes_X_train = diabetes.data[:-20]

In [106]: diabetes_X_test  = diabetes.data[-20:]

In [107]: diabetes_y_train = diabetes.target[:-20]

In [108]: diabetes_y_test  = diabetes.target[-20:]

这个手头的任务是用来从生理指标预测疾病。 

稀疏模型 

为了改善问题的条件(无信息变量，减少维度的不利影响，作为一个特性(feature)选择的预处理，等等)，我们只关注有信息的特性将没有信息的特性设置为0.这个罚则函数法8,叫作套索(Lasso)9，可以将一些系数设置为0.这些方法叫作稀疏方法(sparse
 method)，稀疏化可以被视作奥卡姆剃刀：相对于复杂模型更倾向于简单的。 

In [109]: from sklearn import linear_model

In [110]: regr = linear_model.Lasso(alpha=.3)

In [111]: regr.fit(diabetes_X_train, diabetes_y_train)
Out[111]: 
Lasso(alpha=0.3, copy_X=True, fit_intercept=True, max_iter=1000,
   normalize=False, positive=False, precompute='auto', tol=0.0001,
   warm_start=False)

In [112]: regr.coef_ # very sparse coefficients
Out[112]: 
array([   0.        ,   -0.        ,  497.34075682,  199.17441034,
         -0.        ,   -0.        , -118.89291545,    0.        ,
        430.9379595 ,    0.        ])

In [113]: regr.score(diabetes_X_test, diabetes_y_test) 
Out[113]: 0.55108354530029791

这个分数和线性回归(最小二乘法)非常相似： 

In [114]: lin = linear_model.LinearRegression()

In [115]: lin.fit(diabetes_X_train, diabetes_y_train) 
Out[115]: LinearRegression(copy_X=True, fit_intercept=True, normalize=False)

In [116]: lin.score(diabetes_X_test, diabetes_y_test) 
Out[116]: 0.58507530226905713

同一问题的不同算法 

同一数学问题可以用不同算法解决。例如,sklearn中的Lasso对象使用坐标下降(coordinate descent)方法10解决套索回归，这在大数据集时非常有效率。然而，sklearn也提供了LassoLARS对象，使用LARS这种在解决权重向量估计非常稀疏，观测值很少的问题很有效率的方法。


模型选择：选择估计器和它们的参数 

格点搜索和交叉验证估计器 

格点搜索 

scikit-learn提供了一个对象，该对象给定数据，在拟合一个参数网格的估计器时计算分数，并且选择参数最大化交叉验证分数。这个对象在构建时采用一个估计器并且暴露一个估计器API：


In [117]: from sklearn import svm, grid_search

In [118]: gammas = np.logspace(-6, -1, 10)

In [119]: svc = svm.SVC()

In [120]: clf = grid_search.GridSearchCV(estimator=svc, param_grid=dict(gamma=gammas),n_jobs=-1)

In [121]: clf.fit(digits.data[:1000], digits.target[:1000]) 
Out[121]: 
GridSearchCV(cv=None,
       estimator=SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0, degree=3, gamma=0.0,
  kernel='rbf', probability=False, shrinking=True, tol=0.001,
  verbose=False),
       fit_params={}, iid=True, loss_func=None, n_jobs=-1,
       param_grid={'gamma': array([  1.00000e-06,   3.59381e-06,   1.29155e-05,   4.64159e-05,
         1.66810e-04,   5.99484e-04,   2.15443e-03,   7.74264e-03,
         2.78256e-02,   1.00000e-01])},
       pre_dispatch='2*n_jobs', refit=True, score_func=None, verbose=0)

In [122]: clf.best_score
/usr/lib/python2.7/site-packages/sklearn/utils/__init__.py:79: DeprecationWarning: Function best_score is deprecated; GridSearchCV.best_score is deprecated and will be removed in version 0.12. Please use ``GridSearchCV.best_score_`` instead.
  warnings.warn(msg, category=DeprecationWarning)
Out[122]: 0.98600097103091122

In [123]: clf.best_estimator.gamma
/usr/lib/python2.7/site-packages/sklearn/utils/__init__.py:79: DeprecationWarning: Function best_estimator is deprecated; GridSearchCV.best_estimator is deprecated and will be removed in version 0.12. Please use ``GridSearchCV.best_estimator_`` instead.
  warnings.warn(msg, category=DeprecationWarning)
Out[123]: 0.0021544346900318843

默认GridSearchCV使用三次(3-fold)交叉验证。然而，如果它探测到一个分类器被传递，而不是一个回归量，它使用分层的3次。


交叉验证估计器 

交叉验证在一个algorithm by algorithm基础上可以更有效地设定参数。这就是为何，对给定的估计器，scikit-learn使用“CV”估计器，通过交叉验证自动设定参数。


In [125]: from sklearn import linear_model, datasets

In [126]: lasso = linear_model.LassoCV()

In [127]: diabetes = datasets.load_diabetes()

In [128]: X_diabetes = diabetes.data

In [129]: y_diabetes = diabetes.target

In [130]: lasso.fit(X_diabetes, y_diabetes)
Out[130]: 
LassoCV(alphas=array([ 2.14804,  2.00327, ...,  0.0023 ,  0.00215]),
    copy_X=True, cv=None, eps=0.001, fit_intercept=True, max_iter=1000,
    n_alphas=100, normalize=False, precompute='auto', tol=0.0001,
    verbose=False)

In [131]: # The estimator chose automatically its lambda:

In [132]: lasso.alpha 
Out[132]: 0.013180196198701137

这些估计器是相似的，以‘CV’为它们名字的后缀。 

练习 

对糖尿病数据集，找到最优的正则化参数alpha。(0.016249161908773888) 


Python异常处理机制

Python和java相比，同样拥有强大的异常处理机制，下面让我们一起来看看Python是如何处理异常的
1，try...except....
eg1:
a,b=1,0

try:
    a/b
except:
    print "ERROR"

print “END”

output:
ERROR
END

解析：try测试里边的代码是否有错，若有错执行except语句，然后执行最后一行print语句，就是说Python的try，except不管怎样都会执行最后的print语句
2，try...except....else.....

eg2：
a,b=1,0

try:
    a/2
except:
    print "ERROR"

else:
    print "执行else"


output：执行else
解析如果try语句没有错误，会执行最后的else语句
3，try...except Exception as e....

eg3：
a,b=1,0

try:
    a/b
except Exception as e:
    print e
output：integer division or modulo by zero
解析：会打印出具体的异常信息
4，try.....finally....
具体参考此篇博客：http://blog.csdn.net/gamer_gyt/article/details/42439725
5，用raise引发异常，之后的代码将不能执行
用法：raise MyError
eg4：

try:
     s = None
     if s is None:
         print "s 是空对象"
         raise NameError     #如果引发NameError异常，后面的代码将不能执行
     print len(s)
except TypeError:
     print "空对象没有长度"

output：
s 是空对象

Traceback (most recent call last):
  File "E:\【代码】Python\StudyBasic\SomeProgram\异常.py", line 8, in <module>
    raise NameError     #如果引发NameError异常，后面的代码将不能执行
NameError




更多用法请参考：http://www.cnblogs.com/dkblog/archive/2011/06/24/2089026.html


Python分词模块推荐：jieba中文分词


一、结巴中文分词采用的算法


基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图（DAG)
采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合
对于未登录词，采用了基于汉字成词能力的HMM模型，使用了Viterbi算法

二、结巴中文分词支持的分词模式

目前结巴分词支持三种分词模式：


精确模式，试图将句子最精确地切开，适合文本分析；
全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；
搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。
<span style="font-size:14px;"><pre name="code" class="python"># -*- coding:utf-8 -*-
import jieba
text = '我来到北京清华大学'
default_mode =jieba.cut(text)
full_mode = jieba.cut(text,cut_all=True)
search_mode = jieba.cut_for_search(text)

print "精确模式:","/".join(default_mode)
print "全模式:","/".join(full_mode)
print "搜索引擎模式:","/".join(search_mode)

精确模式: 我/来到/北京/清华大学
全模式: 我/来到/北京/清华/清华大学/华大/大学
搜索引擎模式: 我/来到/北京/清华/华大/大学/清华大学</span>


上述代码解释：


jieba.cut方法接受两个输入参数: 1) 第一个参数为需要分词的字符串 2）cut_all参数用来控制是否采用全模式，默认不采用。
jieba.cut_for_search方法接受一个参数：需要分词的字符串,该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细
注意：待分词的字符串可以是gbk字符串、utf-8字符串或者unicode
jieba.cut以及jieba.cut_for_search返回的结构都是一个可迭代的generator，可以使用for循环来获得分词后得到的每一个词语(unicode)，也可以用list(jieba.cut(…))转化为list

三、结巴中文分词的其他功能

1、添加或管理自定义词典




结巴的所有字典内容存放在dict.txt，你可以不断的完善dict.txt中的内容。




2、关键词抽取




通过计算分词后的关键词的TF/IDF权重，来抽取重点关键词。


3.词性标注

对一句话进行切分后，对每个词进行词性标注，是名词还是动词


具体示例：


<span style="font-size:14px;"># -*- coding:utf-8 -*-
import jieba.analyse

text = "结巴中文分词模块是一个非常好的Python分词组件"
 
tags = jieba.analyse.extract_tags(text,2)
 
print "关键词抽取:","/".join(tags)
关键词抽取: 分词/Python</span>
<span style="font-size:14px;">#! /usr/bin/env python2.7
#coding:utf-8
import jieba
import jieba.posseg
print "Full Mode:","/".join(jieba.cut('始游泳'))
print "Full Mode:","/".join(jieba.cut('过郭美美'))
s=["我勒个去","费打电话","响全世界","线情人"]
for i in s:
    pos=[]
    seg=jieba.posseg.cut(i)
    for j in seg:
        print j.word,'/',j.flag,'#',
        pos.append([j.word,j.flag])
    print  
#----------------------------------
string="当我输给青雉的时候就在想，在以后的航海中再遇到像他那么强的对手的时候"
seg=jieba.posseg.cut(string)
pos=[]
for i in seg:
    pos.append([i.word,i.flag])
for i in pos:
    print i[0],'/',i[1],"#",</span>


输出结果：
<span style="font-size:14px;">Full Mode:Building prefix dict from E:\Python27\lib\site-packages\jieba\dict.txt ...
Loading model from cache c:\users\shifeng\appdata\local\temp\jieba.cache
Loading model cost 0.941999912262 seconds.
Prefix dict has been built succesfully.
 始/游泳
Full Mode: 过/郭美美
我 / r # 勒 / v # 个 / q # 去 / v #
费 / v # 打电话 / l #
响 / zg # 全世界 / n #
线 / n # 情人 / n #
当 / p # 我 / r # 输给 / v # 青雉 / n # 的 / uj # 时候 / n # 就 / d # 在 / p # 想 / v # ， / x # 在 / p # 以后 / f # 的 / uj # 航海 / n # 中 / f </span>

python 字典排序


引子
字典，形如 dic = {'a':1 , 'b':2 , 'c': 3},字典中的元素没有顺序，所以dic[0]是有语法错误的。并且不可以有重复的键值，所以 dic.add['c'] = 4后，字典变成 {'a':1 , 'b':2 , 'c': 4}.
待解决问题
如何根据需要可以根据“键”或“键值”进行不同顺序的排序？
函数原型
sorted(dic,value,reverse)

dic为比较函数，value 为排序的对象（这里指键或键值），reverse：注明升序还是降序，True--降序，False--升序（默认）
案例
dic = {'a':3 , 'b':2 , 'c': 1}
    

注意
排序之后原字典没有变,顺序依旧
     

两个函数
1.lambda
功能: 创建匿名函数
区别: 和def函数定义,以下两点区别

lambda会创建一个函数对象，但不会把这个函数对象赋给一个标识符;而def则会把函数对象赋值给一个变量lambda它只是一个表达式，而def则是一个语句
案例：
    

2.iteritems()
功能: iteritems()以迭代器对象返回字典键值对
区别: 和item相比:items以列表形式返回字典键值对
案例：
    
注释: 

1：在函数sorted(dic.iteritems(), key = lambda asd:asd[1])中，第一个参数传给第二个参数“键-键值”，第二个参数取出其中的键([0])或键值(1])
2：sort函数

一、基本形式
列表有自己的sort方法，其对列表进行原址排序，既然是原址排序，那显然元组不可能拥有这种方法，因为元组是不可修改的。







如果需要一个排序好的副本，同时保持原有列表不变，怎么实现呢







注意：y = x[:] 通过分片操作将列表x的元素全部拷贝给y，如果简单的把x赋值给y：y = x，y和x还是指向同一个列表，并没有产生新的副本。
另一种获取已排序的列表副本的方法是使用sorted函数：







sorted返回一个有序的副本，并且类型总是列表，如下：







二、可选参数
sort方法还有两个可选参数：key和reverse

1、key在使用时必须提供一个排序过程总调用的函数：







2、reverse实现降序排序，需要提供一个布尔值：



3：reversed()
这个很好理解，reversed英文意思就是：adj. 颠倒的；相反的；（判决等）撤销的




Python随机数生成方法

如果你对在Python生成随机数与random模块中最常用的几个函数的关系与不懂之处，下面的文章就是对Python生成随机数与random模块中最常用的几个函数的关系，希望你会有所收获，以下就是这篇文章的介绍。
random.random()用于生成
用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a > b，则生成随机数







1



n: a <=
n <= 
b。如果 a <b， 则 b <= n <=
a。

















1
2
3
4
5
6



print
random.uniform(10,
20)  
print
random.uniform(20,
10)  
#----

#18.7356606526 

#12.5798298022 

random.randint








用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，Python生成随机数









1
2
3



print
random.randint(12,
20) #生成的随机数n: 12 <= n <= 20

print
random.randint(20,
20) #结果永远是20

#print random.randint(20, 10) #该语句是错误的。









下限必须小于上限。
random.randrange
从指定范围内，按指定基数递增的集合中 ，这篇文章就是对python生成随机数的应用程序的部分介绍。
随机整数：
>>> import random
>>> random.randint(0,99)
21
随机选取0到100间的偶数：
>>> import random
>>> random.randrange(0, 101, 2)
42
随机浮点数：
>>> import random
>>> random.random() 
0.85415370477785668
>>> random.uniform(1, 10)
5.4221167969800881
随机字符：
>>> import random
>>> random.choice('abcdefg&#%^*f')
'd'
多个字符中选取特定数量的字符：
>>> import random
random.sample('abcdefghij',3) 
['a', 'd', 'b']
多个字符中选取特定数量的字符组成新字符串：
>>> import random
>>> import string
>>> string.join(random.sample(['a','b','c','d','e','f','g','h','i','j'], 3)).r
eplace(" ","")
'fih'
随机选取字符串：
>>> import random
>>> random.choice ( ['apple', 'pear', 'peach', 'orange', 'lemon'] )
'lemon'
洗牌：
>>> import random
>>> items = [1, 2, 3, 4, 5, 6]
>>> random.shuffle(items)
>>> items
[3, 2, 5, 6, 4, 1]

Python中的列表、元祖、字典

一、列表
一组有序项目的集合。可变的数据类型【可进行增删改查】
列表是以方括号“[]”包围的数据集合，不同成员以“,”分隔。
列表中可以包含任何数据类型，也可包含另一个列表
列表可通过序号访问其中成员
 
常用列表操作：
list.append()追加成员，成员数据
list.pop()删除成员,删除第i个成员
list.count(x)计算列表中参数x出现的次数
list.remove()删除列表中的成员，直接删除成员i
list.extend(L)向列表中追加另一个列表L
list.reverse()将列表中成员的顺序颠倒
list.index(x)获得参数x在列表中的位置
list.sort()将列表中的成员排序
list.insert()向列表中插入数据insert(a,b)向列表中插入数据
可通过
>>>help(list) 查看方法详情



二、元组
不可变序列
元组是以圆括号“()”包围的数据集合，不同成员以“,”分隔
与列表不同：元组中数据一旦确立就不能改变


通过下标进行访问
声明：
L=(1,2,3)
含0个元素的元组: L = ()
含1个元素的元组:L=(1,) 注意有逗号


三、字典
键值对的集合(map)
字典是以大括号“{}”包围的数据集合
与列表区别：字典是无序的，在字典中通过键来访问成员。
字典是可变的，可以包含任何其他类型
 
声明:
M={k1:v1,k2:v2}
访问 M[k1]将得到v1


常用字典操作：
dic.clear()清空字典
dic.keys()获得键的列表
dic.values()获得值的列表
dic.copy()复制字典
dic.pop(k)删除键k
dic.get(k)获得键k的值
dic.update()更新成员，若成员不存在，相当于加入
dic.items()获得由键和值组成的列表
dic.popitem
可以通过
>>>help(dict) 查看详情

四、序列的索引和切片
列表、元组和字符串都是序列
序列的两个主要特点是索引操作符和切片操作符。
索引操作符让我们可以从序列中抓取一个特定项目。即下标操作，用方括号和数字抓取某个位置的项目,L[0]抓取第一个元素，L[-1]抓取最后一个元素
切片操作符让我们能够获取序列的一个切片，即一部分序列。方括号加一对可选数字，切出某个子片L[1:3] 返回1-2的子片，L[2:]从2开始到最后，L[:]整个

Python编码问题

说起来Python编码问题确实是十分令人头疼的，Python功能无话可说，十分强大，但是一旦遇到编码问题就呵呵了
一、不从文件读取，如果我想创建一个中文文件夹
eg:
#coding=utf-8

import os
str="Thinkgamer博客"
os.mkdir(str)
print str
那么创建的文件夹中文部分则为乱码，打印出来的正常
解决办法：去掉coding=utf-8或者将utf-8改为gbk编码
二、从文件读取，创建一个文件夹
eg:
文件格式为utf-8
#coding=utf-8
import os

fp = open('thinkgamer.txt','r')
str=fp.readline()
print str
os.mkdir(str)

能正确打印结果，但是创建文件夹名字确实乱码
然而这并不是我们想要的，可是该怎么解决呢？
如下：只需将文件另存为ANSI格式即可


后续还会更新.......

MySQLdb的安装与使用

一、安装

安装已编译版本(此方法简便快捷):
http://www.codegood.com/downloads
根据自己系统下载，双击安装，搞定
然后import MySQLdb，查看是否成功
 
我的，win7,32位，2.7版本
MySQL-python-1.2.3.win-amd32-py2.7.exe
二、使用
#!/usr/bin/python
# encoding: utf-8
import time,MySQLdb
# 打开数据库连接
db = MySQLdb.connect("localhost","root","root","Python" )
# 使用cursor()方法获取操作游标
cursor = db.cursor()

#删除表
sql = "drop table if exists thinkgamer"
cursor.execute(sql)

#创建
sql = "create table if not exists thinkgamer(name varchar(128) primary key,created int(10))"
cursor.execute(sql)

#写入
sql = "insert into thinkgamer(name,created) values(%s,%s)"
param = ("aaa",int(time.time()))
n = cursor.execute(sql,param)
print 'insert',n

#写入多行
sql = "insert into thinkgamer(name,created) values(%s,%s)"
param = (("bbb",int(time.time())),("ccc",33),("ddd",44))
n = cursor.executemany(sql,param)
print "insertmany",n

#更新
sql= "update thinkgamer set name=%s where name='aaa'"
param = ("zzz")
n = cursor.execute(sql,param)
print "updata",n

#查询
n = cursor.execute("select * from thinkgamer")
for row in cursor.fetchall():
    print row
    for r in row:
        print r

#删除
sql = "delete from thinkgamer where name =%s"
param = ("bbb")
n = cursor.execute(sql,param)
print "delete",n

#查询
n = cursor.execute("select * from thinkgamer")
print cursor.fetchall()

cursor.close()

#提交
db.commit()
#关闭
db.close()

输出结果：
insert 1
insertmany 3
updata 1
('zzz', 1436067892L)
zzz
1436067892
('bbb', 1436067892L)
bbb
1436067892
('ccc', 33L)
ccc
33
('ddd', 44L)
ddd
44
delete 1
(('zzz', 1436067892L), ('ccc', 33L), ('ddd', 44L))


更多详情请戳：MySQLdb User's Guide

[置顶]
        Python开发安装的一些常用模块

更新：2015.05.31=====================================================================================

BeautifulSoup模块：
关于BeautifulSoup模块主要用于规范化网页源代码，利用其一些特定的解析标签函数来分析网页，的得到一些特定的内容，用起来方便简单容易入门，但仍然有一些弊端，比如说对于网页中含有js代码的就不能有效读取与分析，所以常结合正则表达式来进行使用，效率特别好
Scrapy + Selenium 模块：
这两个模块结合起来使用常用于解析javascript，安装与配置比较麻烦,具体安装过程及需要额外安装哪些文件自行百度

MySQLdb模块：
此模块用于连接MySQL数据库，没有他是万万不能连接的，有了他也不一定好使，常见错误便是好多人在导入这个包的时候，不注意大小写，以至于提示无此模块
Twisted模块：
具体此模块怎么用，小编不太清楚，大致是在网络编程的时候会用到
wxPython模块：
用于编写GUI程序，此模块常结合boa-constructor使用，具体使用方法自行百度
附;另外用于编写GUI程序的模块还有PyQt4,eric模块，还有一个PythonIDE winPython安装之后来进行Python代码的编写，里边集成的有Qt Designer来编写GUI，这个相对较为方便，类似于VC直接拉控件了


更新：2015.08.11======================================================================================

numpy模块：
用于科学计算，较为方便，博主最近在学习机器学习算法，算法的代码都是用Python实现的，所以看了看，参考教程http://old.sebug.net/paper/books/scipydoc/index.html
Matplotlib模块：

Matplotlib是一个Python的图形框架，类似于MATLAB和R语言。 Matplotlib的官网地址是http://matplotlib.org/ ，下载地址为http://matplotlib.org/downloads.html参考教程：http://wenku.baidu.com/link?url=U-hHHdrSQSP9p4zO2BmffN8rjt41UD_LwhgZNssnueavVtf7Il1rwsSAowPkaBoUajrqeFXckiHauonRk7Tf6PycX-uujWke9JpLJRli-bS


更新：2015.08.12===================================================================================

PyGame模块：
PyGame是一个Python的库，能够让你更容易的写出一个游戏。它提供的功能包括图片处理和声音重放的功能，并且它们能很容易的整合进你的游戏里

python-graph模块：
python-graph模块实现了很多图算法



更新：2015.08.28===================================================================================
Tkinter模块：
与上述wxPython模块相似，用于开发 python GUI界面
参考教程：点击打开链接
lpthw.web模块：
python 的web开发
smallseg模块：
python处理中文分词，下载地址：http://www.oschina.net/p/smallseg
安装方法：只需将下载的包中smallseg.py拷贝到Python安装目录的Lib文件夹中即可

jieba模块：

中文分词包，下载地址：https://pypi.python.org/pypi/jieba/

更新：2015.10.29===================================================================================

scikit-learning模块：
python 安装pip或者easy_install模块，然后使用命令行安装scikit-learning，前提条件是安装numpy，scipy，matplotlib这三个模块，同时需要注意的是版本问题，Python2.7使用的numpy是1.8版本的，否则会报错


注明：Python的模块很多，当你需要用到哪个的时候再去安装，但无论是安装哪一个模块，都要注意的是版本问题，因为不同版本之间不能完全兼容，以至于在安装模块的时候出现各种奇葩错误，但小伙伴们要耐得住性子，慢慢来，更多模块会在后继继续分享。博主这里有Python2.7的安装包和各种模块插件，有需要的留言发送。


python安装beautifulsoup

注明：python2.7版本貌似只支持beautifulsoup4.4

正常情况下在dos命令下将beautifulsoup解压在python安装目录下
进入beautifulsoup文件夹 
使用python setup.py install安装

我在安装时遇到的问题是使用上述命令抛出错误

出现问题：
由于之前python文件我选择了由spyder打开，所以在此解压安装出现错误，追根揭底是 文件关联的问题
解决办法：
用WinPython Interpreter.exe打开执行setup.py install "..\..\WinPython Interpreter.exe" .\setup.py install

Python中的try...finally...的理解

       最近在跟着mooc学习Python，作为新手会遇到很多不懂的问题，例如在文件读写时所涉及到的文件打开正常与否的关闭问题就用到了try...finally...，经过查找资料，也算是理解了，接下来由小编谈谈自己的看法：
===============================
=== try...finally...使用格式：
       try:
           f = open('name.txt','r')
           while True:
                  程序...
       finally:
          f.close()
===============================
===下面来看一段具体的操作代码
       try:

           f = open('names.txt')
           while True: 
                line = f.read()
                if len(line)==0:
                       break
                print line
      finally:
           f.close()
===============================
在网上查资料的时候看到了time.sleep(t)模块，主要作用是延缓t秒输出，当然需要在程序开始的时候附加import time语句，try...finally...是异常处理文件的内容，保证了无论文件是否被正常打开，最后都能被close。
===============================
解释的不到位的地方希望大家一块探讨

