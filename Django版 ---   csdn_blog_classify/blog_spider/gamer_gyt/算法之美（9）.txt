动态规划算法

一、基本概念
    动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
二、基本思想与策略
    基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。
    由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。
    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
 

三、适用的情况
能采用动态规划求解的问题的一般要具有3个性质：
    (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
    (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
   （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）
 

四、求解的基本步骤
     
动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。
   初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态
                      图1 动态规划决策过程示意图
    (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
    (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
    (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
    (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。
    一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。
实际应用中可以按以下几个简化的步骤进行设计：
    （1）分析最优解的性质，并刻画其结构特征。
    （2）递归的定义最优解。
    （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
    （4）根据计算最优值时得到的信息，构造问题的最优解
 

五、算法实现的说明
    动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。
     使用动态规划求解问题，最重要的就是确定动态规划三要素：
    （1）问题的阶段 （2）每个阶段的状态
    （3）从前一个阶段转化到后一个阶段之间的递推关系。
     递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。
    确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。
          f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}
 


六、动态规划算法基本框架


代码

 1 for(j=1; j<=m; j=j+1) // 第一个阶段
 2    xn[j] = 初始值;
 3 
 4  for(i=n-1; i>=1; i=i-1)// 其他n-1个阶段
 5    for(j=1; j>=f(i); j=j+1)//f(i)与i有关的表达式
 6      xi[j]=j=max（或min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};
 8 
 9 t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案
10 
11 print(x1[j1]);
12 
13 for(i=2; i<=n-1; i=i+1）
15 {  
17      t = t-xi-1[ji];
18 
19      for(j=1; j>=f(i); j=j+1)
21         if(t=xi[ji])
23              break;
25 }

七、动态规划经典题目
1.最大连续子序列之和  解法1—O(N^2)解法  因为最大连续子序列和只可能从数组0到n-1中某个位置开始，我们可以遍历0到n-1个位置，计算由这个位置开始的所有连续子序列和中的最大值。最终求出最大值即可。  更详细的讲，就是计算从位置0开始的最大连续子序列和，从位置1开始的最大连续子序列和。。。直到从位置n-1开始的最大连续子序列和，最后求出所有这些连续子序列和中的最大值就是答案。  解法2—O（NlgN）解法  该问题还可以通过分治法来求解，最大连续子序列和要么出现在数组左半部分，要么出现在数组右半部分，要么横跨左右两半部分。因此求出这三种情况下的最大值就可以得到最大连续子序列和。  解法3—O（N）解法  还有一种更好的解法，只需要O（N）的时间。因为最大 连续子序列和只可能是以位置0～n-1中某个位置结尾。当遍历到第i个元素时，判断在它前面的连续子序列和是否大于0，如果大于0，则以位置i结尾的最大连续子序列和为元素i和前门的连续子序列和相加；否则，则以位置i结尾的最大连续子序列和为元素i。  2.数塔问题/* 数塔问题： 9 12 15 10 6 8 2 18 9 5 19 7 10 4 16 有形如图所示的数塔，从顶部出发，在每一结点可以选择向左走或是向右走， 一直走到底层，要求找出一条路径，使路径上的值最大。 这道题如果用枚举法，在数塔层数稍大的情况下（如40），则需要列举出的路径条数将是一个非常庞大的数目。 如果用贪心法又往往得不到最优解。 在用动态规划考虑数塔问题时可以自顶向下的分析，自底向上的计算。 从顶点出发时到底向左走还是向右走应取决于是从左走能取到最大值还是从右走能取到最大值， 只要左右两道路径上的最大值求出来了才能作出决策。 同样的道理下一层的走向又要取决于再下一层上的最大值是否已经求出才能决策。 这样一层一层推下去，直到倒数第二层时就非常明了。 如数字2，只要选择它下面较大值的结点19前进就可以了。 所以实际求解时，可从底层开始，层层递进，最后得到最大值。 总结：此题是最为基础的动态规划题目，阶段、状态的划分一目了然。       而决策的记录，充分体现了动态规划即“记忆化搜索”的本质。 */  
 3.背包问题
  

 更多参考：http://blog.csdn.net/zmazon/article/details/8247015




Dijkstra算法(戴克斯特拉算法)

十大算法之Dijkstra算法：

最短路径是图论算法中的经典问题。图分为有向图、无向图，路径权值有正值、负值，针对不同的情况需要分别选用不同的算法。在维基上面给出了各种不同的场景应用不同的算法的基本原则：最短路问题。
针对无向图，正权值路径，采取Dijkstra算法。


如上图，是求a到b的最短路径，这里并不限定b节点，修改为到任意节点的路径，问题是完全一样的。

首先需要记录每个点到原点的距离，这个距离会在每一轮遍历的过程中刷新。每一个节点到原点的最短路径是其上一个节点（前驱节点）到原点的最短路径加上前驱节点到该节点的距离。以这个原则，经过N轮计算就能得到每一个节点的最短距离。




第一轮，可以计算出，2、3、4、5、6到原点1的距离分别为：[7, 9, -1, -1, 14]。-1表示无穷大。取其中最小的，为7，即可以确定1的最短路径为0，2为下一轮的前驱节点。同时确定2节点的最短路径为7，路线：1->2。


第二轮，取2节点为前驱节点，按照前驱节点的最短距离加上该节点与前驱节点的距离计算新的最短距离，可以得到3，4，5，6节点到原点的距离为：[17, 22, -1, -1]，此时需要将这一轮得到的结果与上一轮的比较，3节点：17 > 9，最短路径仍然为9；4节点：22 < 无穷大，刷新4节点的最短路径为22；5节点：不变，仍然为无穷大；6节点：14 < 无穷大，取14，不变。则可以得到本轮的最短距离为：[9, 22, -1, 14]，取最短路径最小的节点，为3，作为下一轮的前驱节点。同时确定3节点的最短路径为9，路线：1->3。


第三轮，同上，以3为前驱节点，得到4，5，6的计算距离为：[20, -1, 11]，按照取最短路径的原则，与上一轮的进行比较，刷新为：[20, –1, 11]，选定6为下一轮的前驱节点。同时取定6的最短路径为11，路线：1->3->6。


第四轮，同上，以6为前驱节点，得到4和5的计算距离为[20, 20]，与上一轮进行比较，刷新后为[20, 20]，二者相等只剩下两个节点，并且二者想等，剩下的计算已经不需要了。则两个节点的最短路径都为20。整个计算结束。4的最短路径为20，路线：1->3->4。5的最短路径为20，路线：1->3->6->5。


如果二者不相等，则还需要进行第五轮，先确定二者中的一个的最短路径和路线，再取定剩下的。直到整个5次循环都完成。
代码如下：





深度优先搜索算法(DFS)


十大算法之广度优先遍历：


深度优先搜索遍历类似于树的先序遍历。假定给定图G的初态是所有顶点均未被访问过，在G中任选一个顶点i作为遍历的初始点，则深度优先搜索递归调用包含以下操作：
（1）访问搜索到的未被访问的邻接点；
（2）将此顶点的visited数组元素值置1；
（3）搜索该顶点的未被访问的邻接点，若该邻接点存在，则从此邻接点开始进行同样的访问和搜索。
深度优先搜索DFS可描述为：
（1）访问v0顶点；
（2）置 visited[v0]=1；
（3）搜索v0未被访问的邻接点w，若存在邻接点w，则DFS(w)。
遍历过程：     
 DFS在访问图中某一起始顶点 v后，由
 v 出发，访问它的任一邻接顶点 w1；再从 w1出发，访问与 w1邻接但还没有访问过的顶点
 w2；然后再从 w2出发，进行类似的访问，…如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u为止。
接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。如下图所示：

           
在此小编的代码主要是根据如下图编写个人代码：

         采用的是存放于邻接链表中
         
         0：代表两个结点没有关联；1：代表两个结点有关联
         思路：
        1、定义vet数组存放结点信息；array数组为邻接链表，初始值为0；ifvisit是判断结点是否被访问过，初始值为false
        2、从A开始遍历，找到第一个与之关联的结点，然后从关联的结点开始遍历，直到所有的结点都被访问过
       代码如下：







广度优先遍历算法(BFS)

十大算法之广度优先遍历：


本文以实例形式讲述了基于Java的图的广度优先遍历算法实现方法，具体方法如下：
用邻接矩阵存储图方法：
1.确定图的顶点个数和边的个数

2.输入顶点信息存储在一维数组vet中

3.初始化邻接矩阵；

4.依次输入每条边存储在邻接矩阵array中
输入边依附的两个顶点的序号i,j；
将邻接矩阵的第i行第j列的元素值置为1；
将邻接矩阵的第j行第i列的元素值置为1；
广度优先遍历实现：
1.初始化队列Q
2.访问顶点v；ifVisit[v]=1;顶点v入队Q;
3.while(队列Q非空)
v=队列Q的队头元素出队；
w=顶点v的第一个邻接点
while(w存在)
如果w未被访问，则访问顶点w;visited[w]=1;顶点w入队列Q
w=顶点v的下一个邻接点
如下代码参考此图完成：


实现代码如下：





堆排序算法


十大算法之堆排序：

堆的定义如下：
　　n个元素的序列{k0,k1,...,ki,…,k(n-1)}当且仅当满足下关系时，称之为堆。
　　" ki<=k2i,ki<=k2i+1;或ki>=k2i,ki>=k2i+1.（i=1,2,…,[n/2])"
　　若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，
　　则完全二叉树中每一个节点的值的都大于或等于任意一个字节的值（如果有的话），称之为大顶堆。
　　则完全二叉树中每一个节点的值的都小于或等于任意一个字节的值（如果有的话），称之为小顶堆。
　　由此，若序列{k0,k1,…,k(n-1)}是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。
　　倘若给堆中每一个节点都赋予一个整数值标签，根节点被标记为0，对于每一个标记为i的节点，其左子节点（若存在的话）被标记为2*i+1，其右子节点（若存在的话）被标记为2*i+2，对于一个标记为i的非根节点，其父节点被标记为（i-1）/2。使用这个标记，我们能够将堆存储在数组中，节点存储在数据中的位置就使其标签。




线性查找算法

十大算法之线性查找：


介绍： 
BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分 析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂 度，五位算法作者做了精妙的处理。

时间复杂度

O(N) 



算法步骤： 

1. 将n个元素每5个一组，分成n/5(上界)组。

2. 取出每一组的中位数，任意排序方法，比如插入排序。

3. 递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。

4. 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。

5. 若i==k，返回x；若i<k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。

终止条件：n=1时，返回的即是i小元素。


具体详情解析请点击：十大算法之线性查找算法



二分查找算法

十大算法之二分查找：

二分查找算法是在有序数组中用到的较为频繁的一种算法，在未接触二分查找算法时，最通用的一种做法是，对数组进行遍历，跟每个元素进行比较，其时间为O(n).但二分查找算法则更优，因为其查找时间为O(lgn)，譬如数组{1， 2， 3， 4， 5， 6， 7， 8， 9}，查找元素6，用二分查找的算法执行的话，其顺序为：
    1.第一步查找中间元素，即5，由于5<6，则6必然在5之后的数组元素中，那么就在{6， 7， 8， 9}中查找，
    2.寻找{6， 7， 8， 9}的中位数，为7，7>6，则6应该在7左边的数组元素中，那么只剩下6，即找到了。
    二分查找算法就是不断将数组进行对半分割，每次拿中间元素和goal进行比较。
代码如下：


快速排序算法

十大算法之快速排序：


方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。


首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j--），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。





现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：

6  1  2  5  9 3  4  7  10  8



到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：

6  1  2 5  4  3  9  7 10  8

第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：

3  1 2  5  4  6  9 7  10  8



到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。



OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1 2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。

左边的序列是“3  1  2 5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧



如果你模拟的没有错，调整完毕之后的序列的顺序应该是：





2  1  3  5  4

OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：
 




1  2  3 4  5  6 9  7  10  8


对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下



1  2  3 4  5  6  7  8 9  10


到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。














这是为什么呢？

快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下






归并排序算法

十大算法之归并排序：


算法步骤：
1、申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2、设定两个指针，最初位置分别为两个已经排好序列的起始位置
3、比较两个指针所指向的元素，选择相对小的元素到合并空间，并移动指针到下一位置
4、重复步骤3直到某一指针达到序列结尾
5、将另一序列下剩下的所有元素直接复制合并到序列结尾
归并排序用到了分治策略。
用分治策略解决问题分为三步：分解、解决、合并。也即：将原来的问题划分为n个规模较小而结构与原问题相似的子问题，递归解决这些小问题，然后再合并其结果，得到原来问题的解。 此处n=2。
代码如下（有待优化）：





1002答案杭电详解

 杭电1002答案详解：  
这道题的陷阱是无法用普通的int，long或double能完成的，涉及到了高精度的加法，关于具体的高精度问题，小编建议童鞋们拿出专门的时间把高精度问题整明白，小编在此给出这道题的解法
  具体的高精度加减乘除请参考小编整理的一个程序，请点击此链接链接
#include<stdio.h>
#include<string.h>
int shu(char a)
{
    return (a-'0');
}
int main(){
    char a[1000],b[1000];
    int num[1001];
    int n,i,j=1,al,bl,k,t;
    scanf("%d",&n);
    while(n--)
    {
        if(j!=1)
       printf("\n");
       scanf("%s",a);
       al=strlen(a);
       scanf("%s",b);
       bl=strlen(b);
       k=(al>bl)?al:bl;
       for(i=0;i<=k;i++)
       num[i]=0;
       t=k;
       for(k;al>0&&bl>0;k--)
       {
           num[k]+=shu(a[--al])+shu(b[--bl]);


           if(num[k]/10)
           {
               num[k-1]++;
               num[k]%=10;
           }
       }
       while(al>0)
       {
            num[k--]+=shu(a[--al]);
            if(num[k+1]/10)
           {
               num[k]++;
               num[k+1]%=10;
           }
       }
       while(bl>0)
       {
            num[k--]+=shu(b[--bl]);
            if(num[k+1]/10)
           {
               num[k]++;
               num[k+1]%=10;
           }
       }


       printf("Case %d:\n",j++);
       printf("%s + %s = ",a,b);
       for(i=0;i<=t;i++)
       {
           if(i==0&&num[i]==0)
           i++;
           printf("%d",num[i]);
       }
       printf("\n");
   }
   return 0;
}


