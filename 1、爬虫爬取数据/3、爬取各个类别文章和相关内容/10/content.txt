热门博文推荐

热门推荐

LNMP环境搭建——Nginx篇
在RHEL6.5中配置本地YUM源
Ubuntu下Zabbix安装及使用问题
MySQL双主热备问题处理
Rsync同步错误处理
Fix Elementary Boot Screen (plymouth)  After Installing Nvidia Drivers
LNMP环境搭建——MySQL篇
Shell Step by Step (3) —— Stdin & if
Shell Step by Step (4) —— Cron & Echo
LNMP环境搭建——PHP篇




            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载｜Copyright ©2011-2015, Kallen Ding, All Rights Reserved.

横论机器学习算法
摘要
主要是通过回归（discrimination learning model）来对机器学习算法建立横向连接，有助于对各类算法的理解和归类。
储备知识
从统计学角度来讲，一个信号基本上可以分为两个部分：系统性部分和随机分布，系统性部分在我看来是传达的某种规律性的信息，而随机成分就是用来对信号中不能通过规律性的东西进行把握的部分。所以，一般来讲都采用高斯分布进行建模。系统性的部分就是所谓的利用hypothesis建模得到的，而误差ee就是用来进行建模的基础，用公式化的描述为： 
y−h(x)=y−wTx：N(μ,σ)p(e)=12π−−√exp(−e22σ2)p(y|x;θ)=12π−−√exp(−（y−wTx）22σ2)
y-h(x)=y-w^Tx：N(\mu,\sigma)\\
p(e)=\frac 1 {\sqrt{2\pi}}exp(-\frac{e^2}{2\sigma^2})\\
p(y|x;\theta)=\frac 1 {\sqrt{2\pi}}exp(-\frac{{（y-w^Tx）}^2}{2\sigma^2})

上面的概率公式叫做，给定xx，以参数θ\theta的yy的概率分布。以上说明的是对一个数据集建模的部分和unmodeled effects，大部分的研究都可以从这个角度出发，通过假设建模误差的概率分布，从概率角度入手，以似然函数的最大化为目标，通过梯度下降或者牛顿方法进行迭代搜索最优。

补充：梯度下降与牛顿方法是两种非常常用的迭代优化方法，主要的思想就是通过迭代，一步一步地逼近最优解。梯度下降比较直观，沿着梯度的反方向进行搜索，属于典型的贪婪算法，迭代搜索的每一步都是当前最优的下降方向，但在全局看来可能并不是最优的下降曲线；而牛顿法则是通过分析极大和极小值处曲线的特性，通过求导，并使导数为0，构造典型的f(X)=0f(X)=0的优化形式，每一步都从该点处的切线位置与XX轴（或平面）相交的处的X作为下一次迭代的搜索位置的X坐标（对应的yy可以通过f(X)=0f(X)=0求得）。通常情况下牛顿法收敛速度比梯度下降方法要快。

对于线性回归分析，通常是利用平方误差最小化进行推导的，而它的另一种表达就是通过上面的概率解释。通过求解似然函数最大化问题，照样可以推导出平方误差函数来（cost function）。
关于“记忆”
这里主要参考从统计学角度来看深度学习（3）：记忆和核方法，有关内容只属于总结性质。 
人们通过对以往的经验或者数据的回忆来推断未来的事物，这样的过程可以用一个经常出现在最近文献中的词语——记忆来概括。机器学习模型都是由这样的‘记忆’组成的。根据机器学习模型的种类，可以分为两种主要的记忆机制，即参数型与非参数型\color{red}{参数型与非参数型}（还包括了介于两者之间的模型）。深度网络作为参数记忆型模型的代表，它将统计特性从所观察到的数据中以模型参数或者权重的方式提炼出来。而非参数模型中的典范则是核机器（以及最近邻），它们的记忆机制是存储所有数据。可以自然地认为，深度网络与核方法是两种原理不同的由数据推导结论的方法，但是实际上，我们研究出这些方法的过程却表明它们之间有着更加深远的联系以及更基本的相似性。参数型的“记忆”是通过模型的参数将数据用简洁的模型概括出来，这种形式的好处是：将数据的特性嵌入到一个hypothesis当中，扩展性良好。而非参数型的“记忆”是通过存储所有的数据来实现记忆的，比如最近邻方法，就是将观测数据存起来，当输入新的数据时，通过对比在“记忆”里与新数据的相似度，选择最相近的那个样本的输出作为其输出。 
因此“横论”主要包括两个方法：深度网络、核方法，但本质上却相互联系。
深度网络
线性模型与广义线性模型，实际上通过特征变化基函数，可以实现对特征的映射或者提取，而采用深度网络在最后一层采用线性模型，而前面的所有层可以采用非线性映射的激活函数，可以自适应的找到更好的特征，而不必进行人为地设计。即将输出层作为线性层与前面l−1l-1层分开，同时用映射函数ϕ(x;θ)\phi(x;\theta)来表示前面l−1l-1层的映射结果，同时赋予最后一层权重为ww，此模型参数空间为q={θ,w}q=\{\theta,w\}。 
利用前面预备知识中的概率模型，得到如下的表示： 
系统性部分：f=wTϕ(x;θ)　ｑ～Ｎ(0,σ2qI),随机性部分：y=f(x)+e　ｅ～N(0,σ2y)
系统性部分：f=w^T\phi(x;\theta)　ｑ～Ｎ(0,\sigma_q^2I),\\随机性部分：y=f(x)+e　ｅ～N(0,\sigma^2_y)
 
这样就可以设计似然概率，通过联合概率分布取对数后取负数得到，最小化这个负的似然函数，可以采用最大后验估计，通过BP算法获得模型参数。“记忆”就通过这个模型参数框架被保留下来。 
J(w)=12∑n=1m(yn−wTϕ(xn;θ))2+λ2wTw
J(w)={1\over2}\sum_{n=1}^m(y_n-w^T\phi(x_n;\theta))^2+{\lambda\over2}w^Tw

核方法
继续地，将上面那个目标函数，写成它的dual问题，通过对ww求导为0，得到它的对偶问题。 
w=1λ∑n=1m(yn−wTϕ(xn))ϕ(xn)w=∑n=1αnϕ(xn)=ΦTα    αn=−1λ(wTϕ(xn)−yn)
w={1\over\lambda}\sum_{n=1}^m(y_n-w^T\phi(x_n))\phi(x_n)\\
w=\sum_{n=1}\alpha_n\phi(x_n)=\Phi^T\alpha~~~~\alpha_n=-{1\over\lambda}(w^T\phi(x_n)-y_n)
 
将所有的观测值的基函数（特征）整合到了矩阵Φ(x)\Phi(x)中，将最后一层参数的解代入到损失函数中，我们就得到了由新参数α\alpha构成的对偶损失函数，以及涉及矩阵相乘的格拉姆矩阵（Gram Matrix）K=ΦΦTK=\Phi\Phi^T。重复之前的求导过程，解出对偶损失函数最小的优化参数α\alpha: 
α=(K+λIN)−1y
\alpha=(K+\lambda I_N)^{-1}y
 
这里是核方法与神经网络分道扬镳的地方，仅仅需要考虑特征ϕ(x)\phi(x)的内积K，而不是采用深度网络的非线性映射进行参数化地概括，所以可以采用核替代的方法，选择一个合适的核函数来进行计算。所以，深度网络与核方法具有很深的联系，实际上是互为对偶问题的。所以“记忆”的机制已经转变为非参数了，通过核矩阵显示地刻画了所有样本点。核方法的优势在于能更容易的获得具有我们期望性质的函数，例如具有p阶可微的函数或者周期函数，而这些性质是不太可能通过随机逼近得到的。测试数据x∗x^*的预测值也可以通过核函数的形式写出: 
f=wTMAPϕ(x∗)=αTΦ(x)ϕ(x∗)=∑nαnk(x∗,xn)=k(X,x∗)T(K+λI)−1y
f=w_{MAP}^T\phi(x^*)=\alpha^T\Phi(x)\phi(x^*)=\sum_n\alpha_nk(x^*,x_n)=k(X,x^*)^T(K+\lambda I)^{-1}y
 
这个等式是由表示定理（Representer theorem）得出的解。


2015-8-24 
艺少

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Andrew Ng机器学习课程7
回顾
通过定义训练集S={(x(i),y(i));i=1,2,...,m}S=\{(x^{(i)},y^{(i)});i=1,2,...,m\}与线性决策平面(w,b)(w,b)之间的function margin γ^\hat\gamma和geometric margin γ\gamma 、好的分类决策平面特点得到了一个最优化问题： 
max(γ,w,b)γ　s.t.　y(i)(wTx(i)+b)≥γ,　||w||=1
max_{(\gamma,w,b)}\gamma　s.t. 　 y^{(i)}(w^Tx^{(i)}+b)\geq\gamma, 　||w||=1
 
下面要介绍的就是如何解决这个最优化问题，一个思路就是将这个没有“现货”可以解决的优化问题，转变为off-the-shelf的最优化问题的形式，以便直接拿来使用。



最优化问题推导过程
约束条件中的||w||=1||w||=1是一个nasty(非凸)的目标，于是进行第一步的演变：

将最大化geometric margin转变为最大化function margin
max(γ^,w,b)γ^　s.t.　y(i)(wTx(i)+b)≥γ^,i=1,2,...,m
max_{(\hat\gamma,w,b)}\hat\gamma　s.t. 　 y^{(i)}(w^Tx^{(i)}+b)\geq\hat\gamma, i=1,2,...,m
 
虽然没有了||w||=1||w||=1的约束，但这个优化目标则变为了一个nasty（non-convex）函数，需要进行第二步的演变：
引入(w,b)(w,b)的尺度限制，使function margin γ^=1\hat\gamma=1 
考虑到最大化γ^/||w||=1/||w||\hat\gamma/||w||=1/||w||等效于最小化||w||2{||w||}^2，于是第二步演变后得到的优化问题为： 
max(γ,w,b)12||w||2　s.t.　y(i)(wTx(i)+b)≥1,i=1,2,...,m
max_{(\gamma,w,b)}\frac 1 2{||w||}^2　s.t. 　 y^{(i)}(w^Tx^{(i)}+b)\geq 1, i=1,2,...,m
 
经过两步的推导，问题转变为了一个典型的凸二次目标与线性约束的优化问题，这类问题可以通过成熟的software解决，不必深究。

虽然通过上面的推导过程能够解决并得到一个好的分类决策超平面，但是还得介绍一下Lagrange duality，通过上面优化问题的对偶形式，可以引入kernel trick得到在高维空间表现很好的optimal margin classifiers，另外，dual form将得到比上面解普通二次优化问题更加有效的方法。
Lagrange duality
1. Lagrange multiplier
考虑下面形式的优化问题： 
minw　f(w)　s.t.　hi(w)=0,　i=1,...,l.
min_w　f(w)　s.t.　h_i(w)=0, 　i=1,...,l.
 
解决方法之一就是Lagrange multipliers，定义Lagrangian为： 
L(w,β)=f(w)+sumli=1βihi(w)
L(w,\beta)=f(w)+sum_{i=1}^l\beta_ih_i(w)
 
βi\beta_i那一项叫做Lagrange multipliers。通过求解偏微分来得到对应的w、βw、\beta。

2. primal optimization problem
将如下形式的优化问题成为primal optimization问题： 
minw　f(w)　s.t.　gi(w)≤0,i=1,...,k　hi(w)=0,　i=1,...,l.
min_w　f(w)　s.t.　g_i(w)\leq 0,i=1,...,k　 h_i(w)=0, 　i=1,...,l.
 
为了解决这个问题，开始进行相关的推导：


generalized Lagrangian： 
L(w,α,β)=f(w)+sumki=1αigi(w)+sumli=1βihi(w)
L(w,\alpha,\beta)=f(w)+sum_{i=1}^k\alpha_ig_i(w)+sum_{i=1}^l\beta_ih_i(w)

objective θP(w)\theta_P(w)：

θP(w)=maxα,β:αi≥0L(w,α,β)=maxα,β:αi≥0　f(w)+sumki=1αigi(w)+sumli=1βihi(w)
\theta_P(w)=\max_{\alpha,\beta:\alpha_i\geq0}L(w,\alpha,\beta)\\
=max_{\alpha,\beta:\alpha_i\geq0}　f(w)+sum_{i=1}^k\alpha_ig_i(w)+sum_{i=1}^l\beta_ih_i(w)
 
讨论一下，如果gi(w)>0　or　hi(w)≠0g_i(w)>0 　or　h_i(w)\not=0 ，则objective就变为了无穷大，因此maximize就是为了使gi(w)、hi(w)g_i(w)、h_i(w)满足约束条件。当它们满足约束条件时，为了使objective就等于了f(w)f(w)。这里P的含义代表的是primal。


final optimization form：

minwθP(w)=minw　maxα,β:αi≥0L(w,α,β)
min_w\theta_P(w)=min_w　\max_{\alpha,\beta:\alpha_i\geq0}L(w,\alpha,\beta)


final optimal solution：

p∗=minwθP(w)
p^*=min_w\theta_P(w)

3. 对偶问题dual optimization problem

objective θD(α,β)\theta_D(\alpha,\beta)：

θD(α,β)=minwL(w,α,β)\theta_D(\alpha,\beta)=min_wL(w,\alpha,\beta) 
这里D代表的是dual。


dual optimization problem：

maxα,β:αi≥0θD(α,β)=maxα,β:αi≥0　minwL(w,α,β)max_{\alpha,\beta:\alpha_i\geq0}\theta_D(\alpha,\beta)=max_{\alpha,\beta:\alpha_i\geq0}　min_wL(w,\alpha,\beta)

dual solution：

d∗=maxα,β:αi≥0θD(w)
d^*=max_{\alpha,\beta:\alpha_i\geq0}\theta_D(w)

4. 耦合primal和dual问题
不加约束地，两者有如下形式的关系： 
d∗=maxα,β:αi≥0　minwL(w,α,β)≤minw　maxα,β:αi≥0L(w,α,β)=p∗
d^*=max_{\alpha,\beta:\alpha_i\geq0}　min_wL(w,\alpha,\beta)\leq min_w　\max_{\alpha,\beta:\alpha_i\geq0}L(w,\alpha,\beta)=p^*
 
我们期望是在满足某些条件时，令d∗=p∗d^*=p^*。而这个条件就是著名的KKT条件，这里不再详述，只是进行稍微的解释说明：f、gi(w)f、g_i(w)是凸函数，而hi(w)h_i(w)需为affine，即形如hi(w)=aTiw+bih_i(w)=a_i^Tw+b_i。同时，如果(w,α,β)(w,\alpha,\beta)满足KKT条件，它就是primal和dual问题的解。


KKT formulation

∂L(w∗,α∗,β∗)∂wi=0,i=1,...n∂L(w∗,α∗,β∗)∂βi=0,i=1,...lα∗gi(w∗)=0,i=1,...,kgi(w∗)≤0,i=1,...,kα∗≥0,i=1,.20年资深程序员编程经验分享
原文地址：http://www.devstore.cn/essay/essayInfo/1845.html


原文作者乔纳森·丹尼可(Jonathan Danylko)是一位自由职业的web架构师和程序员，编程经验已超过20年，涉足领域有电子商务、生物技术、房地产、医疗、保险和公用事业。

从11岁时，我就一直在编程，并且一直都很喜欢技术和编程。这些年来，我积累了一些艰难又容易的经验。作为一名程序员，你或许还没这些经验，但我会把它们献给那些想从中学到更多的朋友。






虽然我想我会持续更新这些经验，可能还会有更多的感想，但就我这20年来看，我想下面这个列表中基本不需要增添额外的东西了。下面就是我至今最难忘的经验：

1.估算解决问题所需要的时间。不要怕，承认吧!我曾见过一些程序员为了解决一个特殊问题而坐在显示器前面8小时。为自己定一个时间限制吧，1小时、30分钟或甚至15分钟。如果在这期间你不能解决问题，那就去寻求帮助，或到网上找答案，而不是尝试去做“超级堆码员”。

2.编程语言是一种语言，只是一种语言。随着时光推移，只要你理解了一种语言的原理，你会发现各种语言之间的相似之处 。你所选择的语言，你应该觉得“舒服”，并且能够写出有效(而且简洁)的代码。最重要的，让语言去适应项目，反之亦然。

3.不要过于注重程序的“设计模式”。有时候，写一个简单的算法，要比引入某种模式更容易。在多数情况下，程序代码应是简单易懂，甚至清洁工也能看懂。

4.经常备份代码。在我年轻时，我就有过因硬盘故障而丢了大量代码的经历，这经历很恐怖的。只要你一次没有备份，就应当像有着严格的期限，客户明天就需要。此时就该源码/版本控制软件大显身手了。

5. 承认自己并不是最顶尖的程序员 – 知不足。我常想，我对编程了解已足够多，但是总有其他人比你优秀。正所谓，“一山总比一山高”。所以，向他们看齐吧!

6.学习再学习。正如第5点所说，我经常会在手里拿一本计算机或编程相关的杂志或书(不信，可以问我的朋友)。诚然，总有很多你不知道的技术，你可以从中学习以保持不落后。如果你有一种灵巧的方式来获取你需要的新技术，那你每天都应该坚持学习。

7.永恒的变化。你对待技术/编程知识，就应像你对待股票一样：多样化。不要在某一特定技术上自我感觉良好。如果那种技术或语言已经没有足够支持，那你还不如现在就开始更新你的简历，并启动培训新计划。我能保持前行的主要原则是什么呢?至少了解两到三种语言，所以，如果某种语言过时了，你在学习新技术的时候还可以依靠另一种语言。

8.提携新人。协助并且培养初级/入门的开发人员学习优秀的编程方法和技巧。也许你还不知道，在帮助他们向更高一层前进时，你自己也在向更高一层提升，你会更加自信。

9.简化算法。代码如恶魔，在你完成编码后，应回头并且优化它。从长远来看，这里或那里一些的改进，会让后来的支持人员更加轻松。

10.编写文档。无论是Web服务的API，还是一个简单的类，你尽量编写相应文档。我曾经引以为豪的代码注释，因过度注释而有人指责。给三行代码加一行注释，只需要你几秒时间。如果那是一个比较难以理解的技术，千万别担心过多注释。如果你能很好做好自己的工作，大多数架构师、后备程序员、支持组都会感激你。

11.测试、测试再测试。我是一名黑盒测试粉丝。当你完成编码后，你“被认可”的时候就开始了。如果你们公司有QA部门，如果你的代码中有错误，那你得到的评论，会比项目经理还多。如果你不彻底测试自己的代码，那恐怕你开发的就不只是代码，可能还会声名狼藉。

12.庆祝每一次成功。我见过很多程序员在解决编程技术难题后，会和同伴握手、击掌或甚至手舞足蹈。每个人在生命中都会碰到“顿悟”。如果一个程序员高兴地跑来叫你去看他的非凡代码，也许你已经看过这样的代码100遍了，但你也应该为了这个家伙而庆祝第101次。(编者注：《庆祝成功的九种方式》。)

13.经常检查代码。在公司，你的代码要经常检查(包括自查和其他同事检查)。不要把别人的检查，看成是对代码风格的苛求。应该把它们看作是有建设性的批评。对个人来说，经常检查你的代码并且自问，“我怎样才能写得更好呢?”
 这会加速你的成长，让你成为一个更优秀的程序员。

14.回顾你的代码。在看到自己以前的代码时，通常会有两种方式：“难以至信，这代码是我写的”和“难以至信，这代码是我写的”。第一种往往是厌恶的语气，并在想如何改进它。你也许会惊叹，旧代码也能复活成为一种更好的程序，甚至是一个完整的产品。第二种通常带着惊奇和成就感。开发人员应该一到两个自己完成的项目成果，能让众人不禁而立并注目而观的项目。同样，基于你优越的编程能力，你可以把过去的程序或项目拿出来，把它们更新为更加优秀的产品或想法。

15.幽默是不可缺的。在我20年的开发生涯中，我还没有碰到哪位程序员是没有幽默感的。实际上，干我们这行，幽默是一项必备品。

16.谨防那些无所不知的程序员，不愿分享的程序员，还有经验不足的程序员。当你遇到这几种程序员时，你自己要谦虚。无所不知的程序员，更想当一个英雄而不是团队成员;保守的程序员则是在编写着他们独享的代码;而经验不足的程序员则会每十分钟就来问你一下，当代码完成后，代码已经是你的，而不是他们。

17.任何项目都不会那么简单。朋友、家人和同事曾请求我仓促做一些事情，仓促做一个程序或者网站。对于这样的事，应该从双方做计划，才能做出令双方都会满意的东西。如果某人起初只是需要一个使用
 Microsoft Access的、只有有3个页面的网站，但来就很可能变成一个有15个页面的网站，并使用SQL Server，有一个论坛，还有一个定制的CMS(内容管理系统)。

18.任何时候不要想当然。假如你承接一个简单的项目，你可能会认为某个部分可以轻松完成。千万别这样想!除非你有一个类、组件、或者一段已经写好的代码，并且在现有的项目已经测试通过。不要认为这将是很容易的。

19.从来没有已经做完的软件。曾经有一位程序员告诉我，没有软件是已经完成的，它只是“暂时完成了”。这是明智的忠告。如果客户还在使用你写的程序，并经受了时间的考验。如果有机会，你仍在更新它，这并不是什么坏事，这让你不断地前行。

20.耐心是一种美德。当客户、朋友或家庭成员用电脑的时候，他们也许会受挫，进而想砸电脑，或气冲冲地离开。我一直在告诉他们，“是你掌控电脑，不是电脑掌控你。”对于用作编程的电脑，你要有一定的耐心。一旦程序员知道问题所在后，他们就会站在电脑的角度看问题，并且说“哦，这就是为什么它是这样做。”


请问一下发博中出现的问题
利用cmd markdown编写的博文，粘贴到csdn markdown中，发博文时总是出现如下的错误信息，请问如何解决呢？



版权声明：本文为博主原创文章，未经博主允许不得转载。

程序员的三年创业之路
原文地址：http://www.devstore.cn/essay/essayInfo/511.html
在创业三年时间里作为联合创始人，虽然拿着大家均等的股份，我始终是没有什么话语权的，但是，这也给了我从旁观者的角度看清整个局面的机会。创业公司的成败绝大程度取决于技术大牛和公司 Leader，这两个人最好能在性格上形成互补，而遗憾的是我们公司是同一人。






关于决定是否创业

2012年4月，正好三年前整，在深圳能源正混的郁郁不得志的时候，大学的好兄弟找到我一起创业，他们有钱、有 idea，就是差人，当时的我还是技术菜鸟，本科学的也不是计算机，看着移动互联网蓬勃的发展羡慕不已。很快就答应了一起干，因为心里想着就算创业失败了，那也学到了技术，也不愁再去找工作。现在回想起来觉得太鲁莽了些，抱着这样的想法的程序员应该不止我一个，每个人的生活条件和家庭背景不同，对与错得由你自己来评判。

关于股份如何分配

成功的企业大多是相似的，而失败的初创公司最大可能是股权分配不合理，我们的核心团队成员最开始有四个人，Team Leader 在股份分配的问题上的意见是四人平均分，换取他掌握公司话语权。当时大家就都表示了异议，激烈的争吵了几天，谁也说服不了谁，最后不了了之，这也为后来的分崩离析埋下了伏笔。试想下，假如你确实牛逼，大家敬你服你不就完了吗，又何须用股份来换取决策权。大家能力不同，那么股份平分的缺点是什么呢?创业是一个漫长的过程，每个人付出的时间、精力和成本一定会有差异。如果不设立股权池浮动分配机制，那么问题就来了，拿着四分之一股份的
 Team Leader 觉得自己太累了，事必躬亲，心里不平衡就开始内斗了，因为我算是比较”听话和能干”，他先后挤走了所有的核心团队成员，唯独剩下了我。关于如何科学分配创始人团队间的股份，以及拿出多少股份期权池用来激励员工的问题，我这里不分析，我只讲我的经历，能不能学到什么，那就要看你了。

关于融资的问题

大多数的初创公司是很难拿到天使和风险投资的钱的，没钱该如何创业，自己出钱、众筹、做外包… 这是八仙过海各显神通的事情，我们公司算是比较幸运的，这点必须承认。Team Leader 在软件行业混了十几年，有一些人脉和资源，从创立初始就有天使和风投愿意提供大笔的启动资金，后来我从深圳回武汉，也带来了深创投的天使。可惜这些投资人通通被 Team Leader 拒绝了，理由是不缺钱。

没错，直到我现在离开了，公司也不缺钱，但是雪中送炭者少锦上添花者多，等到需要钱的时候再去找天使和风投就晚了，要么被迫签了城下之盟，要么被迫拿出了大量的股份。有了钱就能提供更好的办公环境、更好的待遇吸引优秀的员工等等好处无须赘述，而且投资人的能量往往大多远远不仅于此，他能站在不同的角度和高度看问题，他也是为你争取更大的风险资本加入的先行者和中介人。换个角度想，你拿天使和风投多一分钱，就等同于减少了潜在的竞争对手一分钱，所以在不需要钱的时候一定要多拿钱。不要舍不得出让一点你手中的股份，当创业不成功的时候，你拿着
 100% 的股份也是废纸。

关于产品是做到极致，还是快速迭代，还是同时做多个产品

第一款产品最初是做全平台的商业视频会议系统，是一款背离时代潮流的产品，我也不知道他为什么会有这样的决定。也许当时 Team Leader 是这么理解的，全国都在如火如荼的搞 App 开发，我们反其道而行之，这样就完全没有竞争对手。可是当快速产品原型出来以后，基本上没人搭理我们，无论是投资人还是客户，因为这玩意儿太扯淡了，而服务器端开发和运营成本高的惊人，根本就不是一般初创公司能够承受的了的，项目还未正式上线就搁浅了，没有认真的市场调研，没有进行技术和经济可行性的研究，甚至连潜在客户的需求都没有咨询过，就这样盲目的做了大半年开发，现在想来简直不可思议。

第二款产品是 Google Reader 宣布关闭后诞生的想法，可以理解为站在了互联网的风口，放眼全球几乎没什么大的竞争对手，因为 RSS 资讯和文献的受众用户相对小而精，有一批忠实的粉丝，但大公司又刚好瞧不上，正适合小公司一展所长，投资人也特别亲睐。这是一次极好的机会，天时地利人和，谁能尽快推出产品，就能如同秋风扫落叶般占领市场，结果由于 Team Leader 一直秉持的做到极致的做事态度，写第一代产品的代码，版本控制都已经设想到第五代如何更新和扩展了，一而再再而三的增加功能，他负责的开发客户端迟迟无法按时交付，最后产品倒是极致了，可是错过了上架的最好时机，又有什么用?

其实对于创业来说，哪一种模式都有成功的例子，但都是不可生搬硬套的，谁也不能够肯定自己的产品策略和切入点是正确的，这些都需要大量的探索和验证，当发现走了错路，必须要有壮士断腕的勇气，坚决砍掉错误功能或产品。我不是产品人，也没有花里胡哨、乱七八糟的想法，我只赞成最稳妥、最有概率成功的方式。专注于一款产品，尽快的推向市场，然后根据少部分用户的反馈，修改服务或增加功能，最后借助投资人的资金和人脉做大肆营销和推广，这就是我最认可的方式。

关于如何选择开发人员和技术

这是大多数创业者不会说的话，大家都爱说实现不成问题，说这话的人我特别反感，人类文明文化发展迄今已五千多年，如何快速、高效、经济和安全的实现一项工程是一门艺术，不是光有学问就可以的，今天的科学家们在工程实践项目上的研究停滞不前了吗?精益求精，实现恰恰是最大的问题。

我们的 Team Leader 算的上技术大牛，从美工出身后来转到 Adobe Flex 系列程序员，也懂服务器端的开发，算得上全栈程序员，精通软件设计与架构，这些都是优点。主要的缺点有两个，一是偏执，二是固步自封，也算是乔帮主极品粉丝的通病，我只是就是论事，并非要挑起帮主粉丝的骂战或者编程语言之间的战争，如有冒犯请原谅。Adobe 近年在程序界的一天比一天颓败，Flex 也早已过时了，结果 Team Leader 却坚持选用 Air 虚拟机 + AS3 + MXML + CSS 的模式开发客户端，理由是熟悉且跨平台。我承认转战其他平台学习需要成本，但早期的
 Air 虚拟机的性能简直惨不忍睹，就算是今天也是远不如 Java 虚拟机的，更不要说跟 Mono 或者 V8 引擎相比，更加不要说跟 Native App 的性能相比。最糟糕的不止如此，Adobe 不开源代码，扔个半死不活的 Air 虚拟机出来后，后续的优化和更新非常缓慢，稍微复杂一点的功能都要自己重写代码，大大加重了开发任务，再加上 Team Leader 对于产品的高标准严要求，更是使代码量成几何级数上涨，雪上加霜。

说到这里不得不举个例子，由于一直被客户端的开发拖着进度，我们服务器端的开发团队和设计师甚至抽空出来，做了好几个外包的 HTML5 网站和游戏。等到产品上架时，整个团队人心都涣散了。

总结

三年的创业时间说长不长、说短不短，一生能有这样一次经历也是可贵。现今的成功或者失败绝不仅仅只是一个人事，整个团队包括投资人都各有责任。最好不要让 Leader 一边做技术、一边做管理，人的能力是有限的，精力也是有限的。如果 Leader 找对了方向，而你坚持不懈的追随，那么你就走在了成功的路上。坚持学习，和投资人搞好关系，从上一个项目的失败中孕育下一个产品的成功，要运气，也要实力。

[置顶]
        Fighting Girl——那个IT女孩
            悄然回首，IT女孩已经走过了三年。依稀还记得三年前的我，迷茫，彷徨过，不知道我工作以后能干什么，觉得自己是一个走在大街上也不会有人注意的女孩，没有什么特长。后来在三年前的某一天突然在学校的某面墙上看到了挂在墙上的宣传，从那一天遇到了生命中最重要的一个人-米老师。
        

    想想这三年，从开始的敲着小小的demo，到现在做着越来越大，越来越跟着时代潮流的项目，从原先只会VB，到现在的Java，Android，甚至以后的IOS。想想，用我小伙伴儿的话来说，开心啊…
今年亦是我的转折点，因为工作了。。出去看了看外面的天空，外面的世界。在工作中不光是对项目的技术有了新的了解，也对为人处事有了更深的了解。。
    在学习上，这半年通过了自考毕业设计，又完成了一个PB版的系统。也意味着在不久的将来自考本科也将通过。。从最初的惧怕到现在的惊喜，IT女孩也在慢慢成长。。
    

    在计算机上，.net的基础系统让我成长，从最初对框架的懵懂到现在对框架的熟练，伴随着MVC，WCF，EF，AOP，分布式事务，反射。。。我们在一步一步的成长。。虽然还有好多欠缺，但是我们不怕，因为在缺陷中我们才能一步一步的改进，一步步的优化，一步步的成长。
    在工作中，从最开始的了解需求到熟悉框架，到现在的小娃娃逐渐长大，虽然现在还不完善，我相信在不久的将来将会降临在这个世界。
    
     因为，这里面有我们千挑万选的方案，有我们日日夜夜加班的汗水。晚上11点，小伙伴儿们还在奋战，说明我们对这个项目的重视和喜爱，因为我们从它降临一直照顾到现在。
    
    在生活上，因为出来实习了，更加感受到身边小伙伴儿对我的关照，不在我身边的朋友，给我寄来了一大堆好吃的，还有他们的嘘寒问暖。我回去的时候还热情的招待，从没有过这么温暖，出来一趟感觉值。
    
    在工作的地方，身边的小伙伴儿陪我吃遍了小馆的饭，陪我逛超市。虽然每天宿舍，吃饭，公司一条线，但是里面不乏有我们自己的温暖，在这里还认识了好多的小伙伴儿，他们非常热情，乐观，有趣，为我们的生活增添了不少趣味。有了他们在工作中也变得不平凡。

    
    外面的世界更让我们感觉到为人处事的重要性。不能顺着自己想干什么就干什么，在这里要变得成熟稳重。前段时间看到米老师在微信圈里发的“几个小技巧让我们说话充满魅力”，收益匪浅，虽然还没有完全做到，但是在尽力改变。
   （1）说话过程中保持两个基本原则，--观点对错不判断，--充分的尊重。
   （2）尽量不要使用否定性的词语。
   （3）换一个表达更易接受。
   （4）运用好你的肢体语言
   （5）情绪不好时少说话。
    这段时间学会了忍耐，即使很痛苦也要往好的方向改变，这样我们才更有魅力！
这一年出去工作了，这一年迎来了更大的蜕变。虽然过程很难受，但是我们的坚持，会迎来别人意想不到的收获。经过三年的洗礼，IT女孩慢慢成熟了。。。。
    


版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        《C程序员从校园到职场》带领大家从校园走向职场
七夕节刚过，就有好消息传来：本人新书《C程序员从校园到职场》正式出版并在各大电商平台上发售了！ 
下面，让我们一起来欣赏一下纸质书的“风采”吧。 
 
 
 
 
 
 
 

本书目录
第1章  概述
1.1  C语言的发展历史   
1.2  C语言的主要特点   
1.3  常用工具软件 
1.4  小结 
第2章  学校到职场  
2.1  认清自身不足 
2.2  破除错误观念 
2.3  工作所需软技能的培养 
2.4  小结 
第3章  程序的样式  
3.1  头文件    
3.2  源文件    
3.3  空格和空行  
3.4  大括号    
3.5  注释 
3.6  小结 
第4章  变量和函数  
4.1  数据类型   
4.2  变量及函数  
4.3  静态变量及其应用   
4.4  小结 
第5章  内存操作   
5.1  memset和memcpy  
5.2  strcat和strncat 
5.3  strcpy和strncpy 
5.4  strcmp和strncmp 
5.5  小结 
第6章  文件 
6.1  常用文件操作函数   
6.2  配置文件   
6.3  makefile文件 
6.4  小结 
第7章  指针和结构体 
7.1  简介 
7.2  示例流程   
7.3  示例程序   
7.4  程序详解和测试
7.5  小结 
第8章  算法和协议  
8.1  算法及其应用 
8.2  协议及其应用 
8.3  小结
第9章  程序重构   
9.1  重构原因   
9.2  重构原则   
9.3  重构流程   
9.4  重构示例   
9.5  小结 
第10章  SQL语句和Shell命令 
10.1  SQL语句 
10.2  Shell命令   
10.3  小结
第11章  程序问题排查    
11.1  日志    
11.2  配置项问题 
11.3  时序问题  
11.4  变量初始化问题   
11.5  数据表索引问题   
11.6  小结
参考资料    
附录A  同行评审   
附录B  我在南邮的3年

更多有关本书内容的介绍，请见我之前写的有关本书的宣传文章： 
(1)《C程序员：从校园到职场》出版预告(1)：从“高大上”到“柴米油盐” 
(2)《C程序员：从校园到职场》出版预告(2)：从“百花齐放”到“一枝独秀” 
(3)《C程序员：从校园到职场》出版预告(3)：从“阳春白雪”到“下里巴人” 
(4)《C程序员：从校园到职场》出版预告(4)：从“散兵游勇”到“正规部队” 
(5)《C程序员：从校园到职场》出版预告(5)：一种情怀，几分感悟
前辈评价
C语言的书虽然已经不少，但像本书这样，不拘泥于知识体系，而是从真实软件项目实践出发来组织内容的却一直空缺。这种身边过来人的经验之谈很多时候对不少人来说，可能比大师名作更有帮助。我相信本书会得到广大C语言程序员的欢迎，与很多从CSDN博客里走出来的著作一样，成为市场上的畅销书。
--- 刘江，CSDN总编

和作者在一家公司工作三年，却从未正式谋面，直到看了他在CSDN的博客文章，才惊感身边竟有一位“持续学习，诲人不倦”的优秀IT才俊，他不仅长期坚持通过博客分享自己的成长历程，更重要的是通过互动交流，专业问答等方式，介绍从“莘莘学子”到“IT码农”转变的技术心得，特别是结合IT行业对软件编程的实际要求，介绍软件编程规范、设计方案、管理流程等内容，对指导学生尽快进入企业，适应公司工作要求，有很好的参考价值。
互联网+时代已经到来，正如作者所说“互联网的精神就是开放，就是分享。通过互联网，我们可以认识更多的人，我们可以从他人身上学到很多东西”，也希望读者能够通过本书学有所获，顺利完成从学生到工程师的蜕变，从优秀走向卓越。
--- 罗圣美，中兴通讯首席架构师

和兆熊相识在CSDN博客。他有一种很强烈的责任感，也很善于总结，他以过来人的身份，为在校学生和职场新人送出了成长路上需要的营养。读他的技术博文，能明显感受到在工程实践中练就的严格、规范，以及对完整开发流程的重视。但他的博文，不同于一般职场人士只局限于在技术层面进行展示，他总能为学习者给出恰如其分的指导。欣闻他的积累即将成为正式的印刷品，有些迫不及待地想看到他要展现的由校园到职场的蜕变路线了。 
--- 贺利坚 ，烟台大学计算机学院副教授，《逆袭大学—传给IT学子的正能量》作者

在我所有接触过的朋友里，兆熊是无疑最适合做程序员的。黄易的小说被大家骂的狗血淋头，但其中有一句写浪翻云的话我是很认同：因为极于情，故能极于剑。从兆熊写过的这一系列文章里，抛开技术细节不论，我主要能看到的就是这种专注和执着。
--- 李智勇，《完美软件开发：方法与逻辑》作者

致谢 
自从我入职开始，我就在构思这样一本基于个人经验的技术书籍，如今，之前的这个小小的愿望得以实现了，我的内心的喜悦之情真的是无法用言语来表达。 
本书得以与广大的读者朋友们见面，我首先要感谢我的家人，是他们在背后不断地支持我、不断地鼓励我，他们为我免除了生活上的很多后顾之忧，让我能够全身心地投入到本书的写作中；其次，我要感谢人民邮电出版社的陈冀康老师和胡俊英编辑，在将博客文章整理成书的过程中，从章节标题的命名到文字的表情达意，他们都不厌其烦地给我以指导，让我能够及时地对本书的内容进行修改，让本书顺利地呈现在了读者的面前；再次，我要感谢CSDN社区，感谢阅读、评论及支持我的博客的每一个人，感谢通过各种方式与我交流的每一位朋友，你们的支持与鼓励是我坚持写作的动力！
作者联系方式 
科学技术日新月异，新的IT技术层出不穷，本书的出版只是我学习的又一个起点。 
IT行业发展到今天，软件种类繁多，不同种类的软件之间差别相当大，没有一种规范适用于所有的软件开发项目。而本书中的内容提炼于作者本人所从事的软件开发工作，因此必然会存在局限性。加之作者本人的水平有限，本书中的内容难免会有所纰漏，还请各位读者和同行海涵。对于大家针对本书提出的宝贵的意见，作者将洗耳恭听并尽量采纳。大家可以通过下面的任何一种方式表达你们的建议，作者保证会在及时给予回复。
微信公众号：zhouzxi
CSDN博客：http://blog.csdn.net/zhouzhaoxiong1227?viewmode=contents
独立博客：www.zhouzhaoxiong.com
邮箱：zhouzxi@126.com
QQ（微信）：245924426
微博：http://weibo.com/zhouzxi?topnav=1&wvr=5


本书试读章节下载

本书网购链接
京东 
亚马逊 
当当网 
china-pub 
异步社区 
文轩网
 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        沉默的阿福
前言：与其说是阿福的沉默，到不如说是我的沉默，其实我和阿福是一对好基友，作为一个26岁的程序猿，我知道阿福和我有一样的梦想，就是“改变世界！”，好像话说大了，不过管他呢，今天说的是阿福，并不是我。
我通过《喜马拉雅》电台听了一个节目，名称叫做“一个人的书房”，好像我已经不只一次的提起过这个节目，哦，我明白了，岂止一次，但是我依然乐此不疲，那证明这个节目确实做的不错！

沉默的大多数，作者 王小波，朗读者 小光。


太喜欢小光的朗读，以至于我到忘记了朗读的内容，不过既然讲到沉默，我知道，阿福肯定也是沉默的大多数中的一员，并且很贴切这个称呼，因为，每次想起阿福，他的表情就像我现在写博客一样，孜孜不倦的敲着26个英文字母，却不曾开口，并且面无表情，我想阿福的形象和我现在像极了！
阿福结婚了
记得在阿福结婚之前，别人问他，“啥时候结婚啊，阿福？”“明年吧，现在没钱结，应该说也不想结。”阿福回答。
我知道其中的缘由，拿阿福说的话来分析，很明显，“没钱”才是实情，至于说不想结，或者说明年吧，都是在搪塞自己的“穷”。
的确，阿福很穷，出生在一个务农的家庭，从小他就知道，未来都必须靠他的双手来赚取，作为农民，父母倾其所有，把能给他的都给他了。当然阿福是一个幸运的孩子，无论是之前在苏州，还是回到洛阳，似乎都能得到某一些人的赏识，日子过的并不算差，和朋友们的关系也还算融洽，虽然来往的少，这一点上，我和阿福也很像，很多时候，对于朋友们，阿福都保持沉默，因为“沉默是金”！
然而，结婚的事终究是来了，阿福在老家办了婚礼，在洛阳办了答谢宴，总算是一场事情过去了！
当然，对于结婚，阿福心怀愧疚，甚至说感到不孝，为了使阿福能够体面的结婚，父母花光了积蓄，作为农民，本来就没有多少钱，况且年初的时候还为阿福在洛阳买了房子，当然有阿福自己的积蓄，还有他的老婆！结婚、买房子都是大事，不借钱是不行的，前前后后，阿福和他老婆借了不少，阿福的父母也借了不少！
这，不至于让阿福觉得不孝，这件事，阿福不愿意多提及，但是我了解到，结婚当天，阿福的父母操碎了心，阿福的妈妈结婚前一天到结婚当天，一刻都没有休息。终究事情太多，有些事情没有操到心，而阿福竟然发起脾气，和她的妈妈吵了起来，当时看着妈妈委屈的流泪，阿福并没有良心发现。后来阿福告诉我，他觉得自己太对不起妈妈了，自己就是一个不肖子孙，阿福觉得自己做错了！
当然，对于这件事，阿福依然保持了沉默，他并没有当面向他的妈妈道歉。俗语说得好，百善孝为先，阿福记得这句话！
阿福的新事业
说是新事业，也可以说是新的工作，毕竟阿福依然是一个打工的，即使阿福挂着“总监”（总监这称号，说白了就是打杂的，程序员、扫地工、产品狗、行政 
╭︿︿︿╮  
{/ o  o /} 
 ( (oo) ) 
  ︶ ︶︶、人事猫等等都得干）的名号，但很多时候，话语权并不在阿福这里，这让他觉得想实现理想，束缚有太多太多！
老板是出钱的，而阿福名义上是出技术的。而如今，钱已经不值钱了，而技术似乎也更不值钱了！
就拿方维的众筹软件，同样一款软件，在方维官网上，起步价在9000左右，而在淘宝上，也就200左右！
我是做程序猿的，我能体会得到，同样是程序员的阿福，在这件事情上面，究竟是可怜呢，还是可怜呢？
阿福心里也曾这样打算过：找淘宝的店小二合伙，把自己的技术成果奉献出来，也卖他个百八十块钱。
但是过后，阿福告诉我，他觉得自己好下贱！
当时我沉默了，因为我也曾有阿福一样的心思，现在回想起来，苦逼的程序猿，究竟该拿什么来拯救你们！当技术从9000跌落到200，我真TMD无话可说，我能说什么呢？我自己还为了老板省钱，也去淘宝买了一份呢，买回来还辛辛苦苦的部署PHP环境，还着急火忙的修改源码，让程序尽量安稳的跑起来呢。
这样说来，我对阿福深表同情，我没敢把自己同样的经历告诉阿福，我怕，伤了他的心！阿福自认为，他的技术是他安身立命的根本，然而这样说起来，我和阿福同为天涯沦落人！
阿福的郁闷
在写这篇博客之前，我和阿福通了一次电话，阿福接到我的电话时，我吓了一跳，电话那边想起来激昂的歌声：

我已是满怀深情，归来时却空空荡荡，那故乡的云，那故乡的风，随我飘向远方！

我听过费翔唱过这首《故乡的云》，压根歌词就不是这样写的，NND，不过惊讶之余，我发现，阿福把这些乱七八糟的词组起来，再结合那深情幽怨的曲子，确实别有一番滋味在心头！
后来我了解到，阿福，对于他的出资人感到莫名的忧伤，阿福的出资人其实并不懂技术，在他眼里，技术似乎一文不值，虽然他也曾同意阿福说的“代码质量重要性”、“想要自己干出一番事业，必须是自己的原创代码，最好不要去复制别人的，虽然可以参考，但必须是我们自己开发的”等等，阿福觉得自己说的很对，出资人似乎也打心眼里认可自己，但每到一定阶段，出资人就会扰乱阿福的决定，说：“抓紧时间找别人一份代码，稍微改改，就能跑，省得自己瞎捉摸，我们自己要完整掌握这套业务，最起码要半年，然而拿别人的来参考，我觉得至少能省三月时间。。。。。。。”
这些话，阿福不想当面反驳出资人，阿福选择了沉默，阿福知道，作为中国人，沉默是一种习惯，也是一种完美的解决方案，任何问题，通过沉默，都能得到答案！
但是，在骑电动车回家的路上，阿福开始乱想了，当初自己跳槽和出资人合伙就是为了能够一展雄风，自己当家做主开发一个自己的软件，这些许日子过去，那些当初的梦想似乎都不太敢想象了！
但是阿福并没有向我吐露太多心声，在他看来，日子还得往前走，阿福希望有朝一日，洛阳也能够像“北上广”一样，有着更广阔的软件舞台。而我也知道，沉默的阿福心里面还藏有其他的想法，只是他不愿意告诉我了，当然我也不再去臆想了！
结语：人生在世，起起落落才会过得有滋有味。而阿福的沉默，也让我想起来了很多，事已至此，我也只有保持沉默！

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本站博客均为qing_gee原创文章，若您需要引用、转载，只需要注明来源及原文链接即可。

初级程序员学习网址搜集（持续更新）
下面是我在学习过程中搜集到的一些软件开发视频、编程语言、IT资讯等网址，希望能对跟我一样的初级程序猿能有所帮助。
1、视频类
    百度文库： http://wenku.baidu.com/course/list/512
    慕课网：http://www.imooc.com/course/list
    网易云课堂：http://study.163.com/find.htm#/courselist?ct=7
    51CTO学院：http://edu.51cto.com/
2、语言类
    Linux公社：http://www.linuxidc.com/
    C语言中文网：http://c.biancheng.net/cpp/
    YIGE.ORG：http://yige.org/cpp/
    Java开源网：http://javakaiyuan.com/
3、QT
    QT开源社区：http://www.qter.org/
    QT开发网：http://www.qtcn.org/bbs/i.php
    QT在线参考文档：http://www.kuqin.com/qtdocument/index.html
    QT讨论：http://www.yafeilinux.com/
    QT编程指南：https://lug.ustc.edu.cn/sites/qtguide/
4、数据库
    学习也休闲：http://www.studyofnet.com/news/list-8883.3-1-1.html
    NOSQL中文网：http://www.nosqldb.cn/
5、嵌入式
    深嵌论坛：http://www.arm8.net/forum.php?x=4309
6、资讯类
    鲜果网：http://xianguo.com/

    雷锋网：http://www.leiphone.com/
    36Kr : http://36kr.com/
    钛媒体：http://www.tmtpost.com/
    虎嗅网：http://www.huxiu.com/


7、软件类


    IT之家：http://www.ithome.com/
    异次元软件：http://www.iplaysoft.com/


8、综合类
    程序员专用导航：http://www.daocode.com/


    快客网：http://www.cricode.com/
    开源中国社区：http://www.oschina.net/

    
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

用FineReport报表系统构建资金监管平台
一、应用背景
计算机的应用已经渗透到日常工作的许多方面，无论是其自身还是所发挥的作用，计算机都标志着一种高科技，使工作高效率和高水平。为了能更方便，更轻松，更好的管理,信息化建设正在日益发展壮大，更加完善。2007年11月，财政部党组明确提出了“一体化建设”指导思想，要求做到管理一体化、业务一体化和技术一体化。近两年来，始终坚持贯彻落实一体化建设指导思想，不断加快建设步伐，信息化建设正逐步由“分散”走向“统一”，取得明显进展。
二、工具
资金监管系统采用PHP网站架构，iframe方式嵌入了，使用FinReport6.5.3版本报表软件，连接相关业务系统ORACLE数据库，制作出图形分析和报表分析，最终通过appserv访问资金监管系统。
三、数据源
资金监管系统来源数据来于相关多个业务系统ORACLE数据库。
（一）总体发放分析
FFDW表，是发放单位表，字段分为，单位代码和单位名称。



FFLX表，是发放类型表，字段分为，发放类型代码、发放类型名称、单位代码、备注。



FFXM表，是发放项目表，字段为，发放项目代码、发放项目名称、发放类型、发放单位代码、预警金额、备注、项目备注。



HM_AREA表，是单位表，字段分为，区域代码和区域名称。



HM_DATA表，是发生数据表，字段分为，ID号、部门代码、发放项目代码、身份证号、姓名、区域代码、账号、金额、日期、备注、发放日期。



RYXX表，是人员信息表，字段分为，身份证号、姓名、性别、联系地址、联系电话、状态、日期、单位代码。

（二）账务分析
Sjzw_dw表，是财务单位表，字段分为单位代码和单位名称。



Sjzw_dwkm表，是单位科目表，字段分为单位代码，科目代码，科目名称。





Sjzw_pz表，是凭证表，字段分为单位代码、凭证ID、凭证日期、凭证号、凭证类型、用途、科目代码、借方金额、贷方金额、审核员、财务主管、制单员、记账员，记账日期。 



四、需求分析
对全区资金进行资金监管，包括区、镇、街道财政和行政事业单位的所有资金收入和支出过程，银行账户资金变动状况进行实时监督、管理、分析，并通过各类图表等方式实时展示反映、预警控制和实时互动交流分析管理。
.         各类报表可以自由组合并预测
每张报表在特定的条件下可以由指定用户自由组合、定义组成相关的报表，并有多种查询方式，同时需要有预测分析功能。
.         各类报表需要有预警功能
.         每张报表都需要有预警功能，而预警值可以由用户自行定义，在预警范围内有数据为正常情况而无需做任何动作时，可以以打标记的方式让这条数据不出现在预警中。
.         各类报表的灵活性
.         每张报表的图形分析要直观明了，联动性强，数据报表需要逐层挖掘至最底层明细数据。报表的操作灵活性要强，需要可以如EXCEL一样可以随意指定对齐方式、文本数字格式、多列排序，便于所有业务管理人员操作。
（一）资金总体发放分析
资金总体发放图形分析分三块统计图，第一部分为部门发放比例，点击部委传参联动第二部分部门发放类型比例，点击发放类型传参联动第三部分部门发放类型的趋势。
资金总体发放报表分析也分为三块，第一部分是发放汇总总表，以交叉报表形式展现，横向为部门，纵向为区域，金额以部门和区域交叉显示。横向纵向每个金额都可以点击，传不同条件展现出不同数据报表。第二部分是定位查询，输入框输入信息点击查询，得到关于当前输入框内信息的报表。第三部分为预警分析报表，每张报表设置好预警值，可以查看预警信息。
（二）账务分析（资产负债表）
资产一般是按各种资产变化先后顺序逐一列在表的左方，反映单位所有的各项财产、物资、债权和权利；所有的负债和所有者权益则逐一列在表的右方。负债一般列于右上方分别反映各种长期和短期负债的项目，业主权益列在右下方，反映业主的资本和盈余。左右两方的数额相等。资产负债表在制作过程中分为2类：第一类为有规则资产负债表，取数据全部取每一个一级科目的金额，一个一个科目单列在资产负债表上；第二类为无规律资产负债表，取数据全部取每一个一级科目的金额，单个科目或多个科目相加列在资产负债表上。
五、数据分析
（一）资金总体发放分析
资金总体发放分析的内容：资金发放分析、资金发放对比分析、资金发放预警分析。
资金总体发放分析的目的：揭示单位发放每个发放类型的内涵、了解单位发放资金变动情况及变动原因、调整发放异常数据、为下一年预算做调整。
（二）账务分析(资产负债表)
资产负债表分析的内容：资产负债表水平分析、资产负债表垂直分析、资产负债表项目分析。
资产负债表分析的目的：揭示资产负债表及相关项目的内涵、了解单位财务状况的变动情况及变动原因、评价单位会计对单位收支状况的反映程度、评价单位的会计政策、修正资产负债表的数据。
六、报表制作
①传统的图形分析及报表制作方法
难点1、图形界面中无法制作中文字定位查询，输入中文字系统不识别。
难点2、图形界面中表格无法自定义合并单元格居左、居中、居右。
难点3、图形界面中统计图分析模块单独最大化，数据多时，数据紧凑无法看清楚数据。
难点4、报表中无法行列冻结显示，数据横向和纵向数据多时，向下向上无法知道当前单元格字段意思。
难点5、报表中定位查询无法在整张报表中定位查询，只能查询定位到当前页报表数据。
难点6、报表中无法屏蔽无意义数据，报表数据为零的条目屏蔽显示难；
难点7、报表中无法在线打印，只能导出EXCL再打印。
难点8、报表中数据无法自动刷新，每次只能人工手动刷新数据。
难点9、通过SQL语句查询出数据，无法再报表内自定义取数和排列，无法制作无规则报表（自定义报表）。
②利用FineReport报表工具
1、新建一个报表模板，模板内新建一个参数，在参数设计中，按钮控件事件中添加定位查询后报表超链接代码


连接FineReport报表JS脚本中添加代码：
var XM = this.options.form.getWidgetByName("XM").getValue();
window.open("/WorkSpace1/ReportServer?reportlet=[60e0][6c11]/[5d07][660e][53bf][60e0][6c11][8d44][91d1][603b][4f53][53d1][653e][5206][6790][ff08][4e2a][4eba][67e5][8be2][62a5][8868][ff09].cpt&xm="+FR.cjkEncode(XM));

如果连接第三方报表JS脚本可以修改编码转换方式。 


2、表格每一列可以任意合并单元格，居左、居中、居右，还可以调整不同格式。

3、图形分析界面模板中，每个模块都用网页框控件嵌入，如第一部分图形分析制作2份，一份嵌入在网页框控件中，另一份放大版通过超链接写在最大化图片上面。

4、报表冻结设置，文件—页面设置—其他中输入重复标题起始行和重复标题结束行，再冻结重复标题结束行打钩。

5、FineReport报表查询过滤，针对当前报表所有数据进行查询过滤，不存在无法查询过滤翻页数据。
6、报表中屏蔽无意义数据，在需要屏蔽无意义数据关键单元格中，右击条件属性，添加条件属性，增加行高属性，高度为0，输入屏蔽无意义数据条件。


7、FineReport报表含多种打印方式，其中FLASH打印模式操作最为方便简洁。



8、FineReport报表每次打开都是最新数据，打开FR报表时，实时刷新当前报表中数据集中的SQL语句，得到最新数据。
9、制作无规律资产负债表，资产负债表分2类数据资产类和负债类，新建2个数据集，一个为资产类科目借方减去贷的数据，另一个为负债科目贷方减去借方的数据。
数据集中唯一值取数用公式replace(UNIQUEARRAY(数据集名称select(字段名)),",","")如：月份、单位名称、单位负责人、财务主管、制单人、审核员都可以用此公式取数据。
资产负债表取无规律值通过用公式=MAP(符合条件的值, "数据集名称", "符合条件的列数","取值的列数")如：取科目“应收在院病人医药费”的年初数，公式输入=MAP(111,
 "科目1-5", "1", "3")，公式表示取数据集“科目1-5”中第一列值等于111对应的第三列的值。多个科目合计数可以使用公式=MAP(符合条件的值,
 "数据集名称","符合条件的列数", "取值的列数")+MAP(符合条件的值,
 "数据集名称","符合条件的列数", "取值的列数")，如：去科目“货币资金”的年初数，输入公式=MAP(101,
 "科目1-5","1", "3")+MAP(102, "科目1-5","1", "3")+MAP(109, "科目1-5","1",
 "3")，公式表示取数据集“科目1-5”第一列值等于101、102、109对应的第三列的值的合计数。

10、在报表页面设置，其他中报表设置居中对齐，设置冻结重复行，目前版本设置冻结后报表分页预览无法居中显示，通过在报表WEB属性中添加JS代码弥补此问题使用以下方法，但还存在缺陷，WEB预览报表时看不到上下滚动条和在数据量多网速慢的情况下，系统先刷新了数据在最大化，无法完成居中效果。



在报表WEB属性，分页预览报表中使用默认工具栏，添加“起始加载”在JS脚本中输入
setTimeout(‘top.moveTo(0,0)’,5);
setTimeout(‘top.resizeTo(screen.availWidth,screen.availHeight)’,5);
此脚本打开报表起最大化作用； 
再添加“加载结束”在JS脚本中输入 
varslmargin=($(‘.content-container’).width()-$(‘.pageContentDIVdiv:first-child’).width())/2
if (slmargin>0) $(‘.content-container’).css(‘margin-left’,slmargin);
此脚本弥补报表冻结后无法居中的缺陷。



七、成果展示
（一）资金总体发放图形分析

“资金总体发放分析”点击“点击查看明细表”得到“资金发放汇总表”，数据以部门横向扩展显示，以区域纵向扩展显示以交叉表形势汇总数据，横向纵向交叉金额数据可以点击，传相关条件可以得到更明细数据。

“资金发放汇总表”点击部门汇总合计金额，得到“部门资金发放汇总表”，数据以资金发放类型横向扩展显示，以区域纵向扩展显示以交叉表形势汇总数据，横向纵向交叉金额数据可以点击，传相关条件可以得到更明细数据。

“
部门资金发放汇总表”点击资金发放类型汇总合计金额，得到“资金发放类型资金发放明细表”，数据以月份横向扩展显示，区域、姓名、身份证、地址以列表纵向扩展显示以交叉表形势汇总数据。区域以分组显示，能方便查看某区域有多少人信息，报表添加了统计行数功能，能明确数量的多与少。

“资金总体发放分析”点击“10天内到期”得到符合当前报表条件报表。

“资金总体发放分析”点击“金额大于10万”得到符合当前报表条件报表。

“资金总体发放分析”点击“金额大于等于1万小于10万”得到符合当前报表条件报表。

“资金总体发放分析”点击“享受两项以上惠民政策”得到符合当前报表条件报表。


点击身份证，得到此身份证的详细明细发放数据。




（二）账务分析(资产负债表)
有规则资产负债表，同一张报表传不同单位，默认当前月日期显示数据。
有规则资产负债表单位1

有规则资产负债表单位2

无规则资产负债表（自定义报表），默认当前月日期显示数据。

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

人生重在修行
人在很多时候都是非常功利的，而这种功利心往往会使人失去耐心，被挡在浅浅的表层，而无法深入。
想每做一件事情，都能有所收获，正如期望每一天所进行的学习，都能卓有成效，能学到很多的知识技能。这实际上就是功利心在作祟。
实际上，有很多事情并不是能够在一时之间就能产生所谓的“收获”或者“功效”的，它不像你每天学会一种算法那样实在，它更像是一种内在的砥砺，一种修行，虽平淡无华，却影响深远。正如人们经常抱怨的一些没有意义的杂事一样，难道做这些所谓的“杂事儿”真的没有一点意义吗？不！我宁愿相信那是一种类似“苦其心志，劳其筋骨”的砥砺。只有经过了纷繁的杂事的洗礼，并保持耐性，心智丝毫不受到影响，依旧任劳任怨、尽力完成这些事情，这种不急不躁的性格将会影响人一辈子的发展！千万不要被所谓的“杂事”扰乱的心智而变得极度地功利化，对任何觉得对自己没有价值的事情都不乐于去做，即使去做了，还不断的发牢骚，说耽误自己的进步，反而养成了骄躁的性格，最终很可能变为高不成低不就的“志大才疏”之人。
切记！切记！
************************
2015-8-24
艺少



版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        技术人员如何提升自己的价值


        技术人员的价值被低估，这是我和朋友最近讨论比较多的一个话题。我们都认为，很多人的技术相当好，工作成果也很显著，但没有获得应有的回报。从同行的角度来看，这种现象确实很“不公平”。
但是，这种现象分明又在大量地发生着。同时，有很多技术不那么好的人，反而获得了不错的回报，所以更让人感觉“不公平”。
那么，问题到底出在哪里呢？或者说，技术人才要如何才能提升自己的价值呢？经过思考和讨论，我有了大概的结论。
如果你希望做技术的绝世高手，当然有机会获得足够好的回报，但前提是你必须成为绝世高手，同时能找到需要绝世高手的场合——这样的工作机会一般只有少数大公司才能提供。
如果你很热爱自己的工作，也乐于投入，但不奢望成为绝世高手，同样有机会创造足够多的价值，获得足够好的回报，前提是你需要注意以下几点：
第一，技术的底子要足够好。
作为技术人才，总是需要有一些硬功夫的，这是创造价值的基础所在。如果自己的技术不够好，遇到稍微困难一点的问题就束手无策。更重要的是，技术圈是讲硬功夫的，如果缺了它，很难服众，很难协调和调动其他技术人员，也就无从发挥团队的合力。如果自己的技术功底不够扎实，就更谈不上解决问题了。
第二，要能从业务的角度出发，发现技术的价值。
搞技术的人很容易陷入无谓的，绝对标准的争论里。比如哪个框架更先进，哪个算法更高效等等。这些知识当然没有错，但如果你的工作不是研究，多想想哪种技术能怎样创造更大的价值，意义往往更大一些。
比如好些年前，全文检索就不再是技术上的难题，但还没有成型的产品供大家直接使用，所以很多网站仍然使用数据库查询来实现全文检索。这时候，去研究优化检索效果所创造的价值，就不如为大家提供可用的全文检索。因为前者解决的是好和更好的问题，后者解决的是有与无的问题。
再比如，现在 NoSQL 非常热，但是 MongoDB 之类的产品仍然不够成熟，没有足够经验难以玩得转。如果单纯从软件质量考虑，采用 MongoDB 是有风险的。但是另一方面，随着电商的发展，产品的属性大大增加，这是传统的关系型数据库应对起来非常吃力的。而且，非订单数据对稳定性并没有那么高的要求。所以某些情况下，采用“不够稳定”的 NoSQL 所带来的好处是要远远大于坚守传统关系型数据库的。要发现、相信这个机会并采取行动，就需要能以业务的眼光来思考问题，挖掘出技术的价值。
第三，要重视表达。
实际上这是非常、非常重要的一点，做技术的人往往不太擅长表达，或者认为世界应该像程序一样按稳定的规矩和逻辑来运行。结果却常常出现两种情况：因为不善于表达，所以不能争取到足够多的资源和支持来做一些事情，导致出不了成绩；或者即便出了成绩，也因为不善于表达，成绩无法被其他人承认，或者被抢去了功劳。
如果大家都是做技术的，需要什么资源和支持，通常是有共识的，或者至少是容易沟通的。但如果资源的提供方不是做技术的，往往就很难理解一些“基本”问题：为什么要升级服务器，为什么要多招两个人，为什么延期一个月上线更好…… 对于这些“直觉就可以判断”的问题，外行并不能迅速理解，所以必须耐着性子，用对方能听懂的语言，以对方能接受的方式来讲解。否则，获取不到资源，最终受伤的还是自己。
当然，最可悲的是出了成绩却被埋没，或者被其他人抢去功劳的情况，这也是最普遍的让技术人才不爽的情况。大家往往会埋怨说：公司是不公平的，自己明明创造了价值，却不被认可，而其他很多公司都能公平地对待。真实的情况是，在技术驱动的公司，或者公司领导非常清楚技术的价值，这种可能“公平”会来得比较自然；而在在很多公司内，创造价值，和让人认识到自己创造了价值，二者其实是分离的。创造价值需要动脑和动手，让人知道自己创造的价值，除了需要动嘴，同样需要动脑和动手——在什么场合以什么样的方式把信息传递出来，让大家信服，这都不是单靠“嘴皮子”能解决的问题。


本文最初发表在 腾讯科技，文章内容属作者个人观点，不代表本站立场。


版权声明：本文为博主原创文章，未经博主允许不得转载。

阿里巴巴2016研发工程师笔试题

问题1：
如果下列的公式成立：78+78=123，则采用的是_______进制表示的。
本题实则考察进制转换，可以设为x进制，但是x进制有一个问题，即我们无法对x进制直接进行加减乘除，故转化为我们常见的10进制。
78=7*x+8，123=1*x2+2*x+3；然后解方程即可。答案为13进制。






问题2：

下列 java 程序输出结果为______。


int i=0;
Integer j = new Integer(0);
System.out.println(i==j);
System.out.println(j.equals(i));


本题考察的是装箱与拆箱，==比较的是值，同样equals也是比较值。故选择true,true。
equals源码如下：

    public boolean equals(Object obj) {
	if (obj instanceof Integer) {
	    return value == ((Integer)obj).intValue();
	}
	return false;
    }



输出的是：hello and cb




问题3
有关下述Java代码描述正确的选项是____。

public class TestClass {
   private static void testMethod(){
        System.out.println("testMethod");
   }
   public static void main(String[] args) {
        ((TestClass)null).testMethod();
   }
}


本题考察的是静态方法与 类&对象的关系，静态对象属于类，故不管对象是否为空，仍旧会正常运行，输出testMethod。
追问：若将方法static修饰符去掉，又是什么情况？
首先，不会是编译错误，因为符合Java对类型的检查，但是运行时会出现NullPointerException。





问题4
 袋子中分别一叠纸币，其中5元面值的纸币6张，10元面值的纸币5张，20元面值的纸币4张，从袋子中任意取4张纸币，则每种面值至少取到一张的概率为____。



一共的票数为：6+5+4=15张
总的情况数：15张选4 C(15,4)
每种面值至少取一张：可能有三种情况，5元、10元、20元是2+1+1、1+2+1、1+1+2这三种情况。
分析到这里，结果计算，得到结果为48/91




问题5


有一个扔骰子得返现的游戏：你扔一个骰子，扔到多少就可以得到和点数相同的返现。例如你扔到3，可以得到3元返现；扔到1，可以得到1元返现。当你扔完第一次骰子，看到点数后，你需要做出如下选择：




1、拿这个点数对应的返现，放弃扔第二次骰子；




2、再扔一次骰子，但此时你只能拿第二次扔的点数对应的返现。




那么，玩一轮这个游戏的期望收益是____元。




这道题实际上很简单，考察的是你扔筛子策略，点数集合为（1,2,3,4,5,6）；那么当我扔到（1,2,3）的时候证明手气较平均情况差一些，会再扔一遍，扔到（4,5,6）时证明手气较平均情况好一些，就不再扔。按照这个原则很容易求得是4.25。




问题6 
一个长度为100的循环链表，指针A和指针B都指向了链表中的同一个节点，A以步长为1向前移动，B以步长为3向前移动，一共需要同时移动多少步A和B才能再次指向同一个节点____。



本题实际上可以想象成在运动场跑道上，队员A速度是1，B为3，跑道一圈为100，则多长时间相遇一次，设为t，则：
下次相遇时，3t-t=100，t=50。


问题7


某操作系统采用分页存储管理方式，下图给出了进程A的页表结构。如果物理页的大小为512字节，那么进程A逻辑地址为0x0457（十六 进制）的变量存放在____号物理内存页中。




进程A页表：




逻辑页    物理页




0            9




1            2




2            4




3            6




4            5




5            8




0x0457写成2进制，为0000 0100 0101 0111,而512=2^9，则后9位存放页内地址，前7为为2，对应的物理页为4。


问题8
在一个100人的团队活动中，主持人小猿亮出了一幅裙子的照片，大喊：”看出蓝黑色的举手！“，团队中有45人举手，然后小猿又喊：”看出白金色的举手！“，团队中有40人举手。机灵的小猿发现，有人从未举过手，有人举手了两次，两轮举手分出的四类人的数目恰好构成一个等差数列。请问有____人既能看出蓝黑色又能看出白金色。



这题不用在纸上列公式，因为40与45都处于整数的等差数列中，相差为5（不可再分）；故公差就为5；举手两次的是考出白金色的子集，故小于40，只可能是30或者35；若为30，则均未举手的是35，单独蓝黑举手的是45-30=15，单独白金举手的是40-30=10，而30+35+15+10=90≠100；故两次都举手只可能35。




问题9
将1,2,3,......,99,100任意排列成一个圈，相邻两数的差的绝对值求和最多为____。



本题可以拿1,2,3,4做实验，发现最大的4必须和1,2相邻，最小的1必须和最大的3、4相邻。进而推广：
100必须和1,2相邻；1必须和99、100相邻；......
最后排布顺序是：1,100,2,99,3,98.......50,51。故结果为99+98+.......+1+(51-1)=5000




问题10
 已知二叉树中有45个叶节点，有25个度为1的节点，则二叉树的总结点数为____。



叶子节点45个，度为2的节点则为44个；结果等于45+25+44=114


问题11
某单链表有5个元素，设单链表的节点结构为(data,next)，5个元素的data依次为（1、2、3、4、5），已知指针q指向节点3，指针p指向节点4，那么下面操作能将链表变为data依次为（1、2、3、5）的是____。（其中temp为节点类型指针，默认指向NULL）



狸猫换太子，这题很简单，选择最后一个；将5节点的值传给需要4节点，然后在释放5节点就行；详情可参考编程之美。

问题12
 在1,2,3,.....1000中，有____个数各位乘积为0。



分为两段：
1-100，只有是10、20、.......100这10个数满足要求。
101-1000，可以分为9段，101-200、201-300........901-1000；每一段情况一样，故拿出101-200这一段，101、102、.......109这9个数满足，110、120、......200这10个数也满足。
故总数为10+9*（9+10）=181。




问题13

 A、B、C、D四人应聘一个程序员职位，此职务的要求条件是：Java熟练；懂数据库开发；会Web开发；有Ｃ++经验。谁满足的条件最多，谁就被雇用。（1）把上面四个要求条件两两组合，每个组合都恰有一人满足。同时已知（2）A和Bjava熟练（3）B和C会Web（4）C和D懂数据库（5）D有C++经验那么，被雇用的是____。
阿里经常会出这样的问题，只能大胆假设、小心求证了。
推测得：JAVA（A、B） 数据库（A、C、D） web（B、C） C++（B、D)
故选择B


问题14
 有一个单向链表队列中有一个A、B两个相邻元素，有一个指针p指向元素A，现将一个指针r指向的S元素要插入到A和B之间，该进行操作____。

r->next=p->next;p->next=r



插入节点非常简单，只需要注意先后顺序即可。




问题15

A为整数数组， N为A的数组长度，请问执行以下代码，最坏情况下的时间复杂度为____

void fun(int A[], int n) {                                                                       
    for (int i = n - 1; i >= 1; i--) {                                                          
        for (int j = 0; j < i; j++) {                                                            
            if (A[j] > A[j+1]) {                                                                
                int tmp = A[j + 1];                                                              
                A[j + 1] = A[j];
                A[j] = tmp;
         }
      }
   }
}

类似于冒泡，复杂度O(n2)




问题16
 将整数数组（7-6-3-5-4-1-2）按照堆排序的方式原地进行升序排列，请问在整个排序过程中，元素3的数组下标发生过____次改变。



考察堆排序的先后顺序，改变2次，画图分析即可。

















版权声明：本文为博主原创文章，未经博主允许不得转载。

【图像处理笔记】灰度变换
最近在学习冈萨雷斯的《数字图像处理》，想把整理的笔记和自己实现的小实验整理在博客上~


今天的主题是图像的灰度变换：
g（x，y）= T [ f（x，y）]
f（x，y）是输入图像，g（x，y）是处理后的图像，T是在点（x，y）邻域上定义的关于f 的一种算子。
T处理，从输入图像的左上角开始，以水平扫描的方式逐像素地处理。当该邻域的圆点位于图像的边界上时，部分邻域将位于图像的外部。此时，不是忽略外侧邻点，就是用0或者其他指定的灰度值填充图像的边缘。被填充的边界的厚度取决于邻域的大小。
以上的描述过程称为空间滤波，其中，邻域与预定义的操作一起称为空间滤波器（也称为空间掩模、核、模板或窗口）。


最小邻域的大小为1×1。在这种情况下，g 仅取决于点（x，y）处的灰度值f ，而T则成为一个形如下式的灰度（也称为灰度级或映射）变换函数：
S = T（r）
其中，为表达方便，另r和S分别表示变量，即g和f 在任意点（x，y）处的灰度。


例如，如果T（r）有如图所示的形式


对f 中每一个像素施以变换产生相应的g的像素的效果将比原图像有更高的对比度。这种技术被称为对比度拉伸。
极限情况下，会产生二级（二值）图


图像增强技术是面向问题的，没有通用的“理论”。


一些基本的灰度变换函数：
①图像反转
S = L - 1 - r
通俗的说，就是图像的黑边反转交换。
特别适用于增强嵌入在一幅图像的暗区域中的白色或灰色细节。
②对数变换
S = c*log（1+ r）


改变换将输入中范围较窄的低灰度值映射为输出中较宽范围的灰度值，对范围较宽的高输入灰度值映射为输出中较窄范围的灰度值。
我们一般使用这种类型的变换来扩展图像中的暗像素值，同时压缩更高灰度级的值。
反对数变换的作用与此正好相反。
对数函数的一般形状的任何曲线，都能完成图像的灰度级的扩展和压缩，但是一会介绍的幂律变换对于这个目的更为通用。
对数函数有个重要的特征，即它压缩像素值变换较大的图像的动态范围。这一特征一般被应用于傅里叶频谱中。
通常，频谱值的范围从0到10^6，甚至更高。尽管计算机能毫无疑问的处理这一范围的数字，但图像的显示系统通常不能如实地再现如此大范围的灰度值。因而，最终结果是许多重要的灰度细节在典型的傅里叶频谱的显示中丢失了。
如果我们先将这些频谱进行对数函数的对比度拉伸，再线性的缩放到新的值域，并在同一个8比特显示系统中显示频谱的结果。会看到很多丰富的细节。
③幂律（伽马）变换
S = c* r ^γ


习惯上，幂律方程中的指数被称为伽马
用于校正幂律响应现象的处理称为伽马校正
幂律变换与对数变换一样，也可以扩展和压缩一些灰度级，且应用的更为广泛。
④分段线性变换函数
优点：形式可以是任意复杂的。
缺点：技术说明要求用户输入。


上面就是关于灰度变换的一些总结。
下面我想做一个小实验，对一幅光照不均匀的图像，进行一下伽马变换的对比度拉伸，调整一下显示的亮度。
我是用VB.NET的Emgu来实现的。
这个是原图



'伽马变换的灰度拉伸
'处理光照不均匀的图像
Dim img As New Image(Of Gray, Byte)("C:\test.bmp")
Dim height As Integer = img.Height
Dim width As Integer = img.Width
Dim gama As Double = 0.4

Dim Sbigest As Integer = 0
Dim Sfewest As Integer = 255
For i = 0 To height - 1
    For j = 0 To width - 1
        If img.Data(i, j, 0) < Sfewest Then
            Sfewest = img.Data(i, j, 0)
        End If
        If img.Data(i, j, 0) > Sbigest Then
            Sbigest = img.Data(i, j, 0)
        End If
    Next
Next
For i = 0 To height - 1
    For j = 0 To width - 1
        img.Data(i, j, 0) = (img.Data(i, j, 0) ^ gama - Sfewest ^ gama) / (Sbigest ^ gama - Sfewest ^ gama) * 255
    Next
Next
img.Save("C:\test-result.bmp")

处理后的结果，其实效果还可以。只是不道为啥图片一粘贴到博客上，较深的背景就会变成绿色的了。












版权声明：本文为博主原创文章，未经博主允许不得转载。

漂亮的不像实力派--锤子新品“坚果手机”发布会
这是一篇罗永浩脑残粉的内心独白，慎点~！
一直是老罗得脑残粉，从10年高二听了他一次演讲开始，那时候他还是个英语老师，那时候的“相声”的名字都还叫“一个理想主义者的创业故事”，但从那时起便一发不可收拾的爱上了这个胖子，就再也没有落下他一场发布会、任何一条微博。
后来得知要出ROM，后来做了T1，我对便对锤子的每一个设计理念和想法赞不绝口、爱不释手。
今天出来坚果手机，面向年轻人的，虽然20号晚的谍照曝光的彻彻底底。但是对于锤粉、罗粉，老罗出来走走说两句，我们就十分安心。
发布会是8月25日，早在得知发布会时间的两周前，我便和老师说好，今晚给我放个假，今天傍晚前和小伙伴高效率的把事情做完，我说晚上任何事都不能抢占我看手机发布会的时间。
等了半多小时，老罗迟到了，期间的微信抢红包也因为罗粉的热情网站几次宕机，即时有些开玩笑似的在网上说，“老罗重新定义了7点半”等等一些玩笑话，但是对于脑残粉的我来说，这些，都不算什么。
发布会过程我就不阐述了，大家感兴趣可以去看回放视频。绝对精彩，绝对魅力四射。
在这个世界上，能让我在电脑面前振臂高呼，呐喊到热泪盈眶的，就只有老罗了。
心潮澎湃的感觉无以言表，但是我知道罗粉们都懂。
嗯嗯，老罗你发布会上说，我们都很好，是你欠我们一个成功。听到这话我差点感动到哭（妈啊太爱这个胖子了）。我！一路挺。
漂亮的不像实力派，我即将走出校园找工作，我的第一份工资，一定买你一个坚果手机。
夜深，太有感触，希望能不断强大自己，能有机会向你公司迈进！
最后老罗，还是那句老话！你负责认真，我们！帮你赢！
夜深，零碎几句，献给我的锤子和老罗，也献给最近因职业规划而导致有些迷茫的自己！哦！不再迷茫，即将彪悍。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。请多多指教~

Qt画圆
      大家知道Qt中有QGraphicsItem这个类，这是图形元素的基类。如果想实现自己的图形元素，那就要继承这个基类。


1.首先我们继承QGraphicsItem，画自己的圆。
 MyItem.h

class MyItem : public QGraphicsItem
{

public:
    MyItem(double radius, double Radius);
    ~MyItem();
    QRectF boundingRect() const;
    void paint(QPainter *painter,const QStyleOptionGraphicsItem *option,QWidget *widget);

protected:
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);//实现圆的拖拽效果
    void mouseDoubleClickEvent (QGraphicsSceneMouseEvent *event);//处理鼠标双击事件

private:
    double m_radius;
    double m_Radius;

    bool m_colorFlag;//true:red, flase:black

};
MyItem.cpp


MyItem::MyItem(double radius, double Radius)
{
    m_colorFlag = true;
    m_radius = radius;
    m_Radius = Radius;
    setFlags(ItemIsSelectable | ItemIsMovable);
}

MyItem::~MyItem()
{

}

QRectF MyItem::boundingRect() const
{
    return QRectF(-m_radius, -m_radius,
                  2*m_radius, 2*m_radius);
}

void MyItem::paint(QPainter *painter,const QStyleOptionGraphicsItem *option,QWidget *widget)
{
    if(m_colorFlag)
        painter->setBrush(Qt::blue);
    else
        painter->setBrush(Qt::red);

    painter->drawEllipse(QPointF(0, 0), m_radius, m_radius);

}

void MyItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    qreal x = pos().x();
    qreal y = pos().y();
    double D = m_Radius - m_radius - 2;

    // limit circle position
    if(x*x + y*y >D*D)
    {
        double tmpX = x*D/sqrt(x*x + y*y);
        double tmpY = y*D/sqrt(x*x + y*y);

        setPos(tmpX, tmpY);
    }

    QGraphicsItem::mouseReleaseEvent(event);
}

void MyItem::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event)
{
    m_colorFlag = !m_colorFlag;
    QGraphicsItem::mouseDoubleClickEvent(event);
    update();
}

2.创建一个画布，在画布上添加圆，最后用一个View来管理画布。
MainWindow.cpp

#define RADIUS 100

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    //m_scene = new QGraphicsScene();
    //m_scene = new QGraphicsScene(-50, -50, 100, 100);
    m_scene = new QGraphicsScene(-100, -100, 200, 200);

    m_scene->addEllipse(-100, -100, 200, 200);

    m_steelNum = ui->spinBox->value();

    MyItem* item = new MyItem(25, RADIUS);
    item->setPos(0, 0);
    m_scene->addItem(item);
    QGraphicsView *view = new QGraphicsView(m_scene);

    view->show();

    ui->verticalLayout->addWidget(view);

}

MainWindow::~MainWindow()
{
    delete ui;
}
附上效果图（小圆双击会变颜色）：



源码下载地址1：https://github.com/RobinsonSir/QtDrawCircle.git 

源码下载地址2：http://download.csdn.net/detail/zbc415766331/9043567














Qt坐标系参考文献：http://doc.qt.io/qt-4.8/graphicsview.html#the-graphics-view-coordinate-system

版权声明：本文为博主原创文章，未经博主允许不得转载。

Hadoop(二)——分布式集群搭建
   前两天和一个朋友在聊天的时候说，很多自学Hadoop的朋友80%都会夭折在集群环境的搭建上，原因吗无在乎：1，没有很好的电脑配置，不能像机房一样用多台电脑搭建起集群；2，对linux的不熟悉，各种小黑窗，linux命令……；3，环境搭建的反锁步骤，需要耐心+细心+认真等等吧。不过吗，我觉的，只要敢于坚持，敢于付出都是会成功的。下边讲述一下我的Hadoop集群搭建过程，由于条件有限，也是在虚拟机中进行的。    一，准备资料：    1，一台笔记本：I5的CPU，4G内存，500硬盘（内存有些小，运行的时候比较卡）；    2，虚拟机一台：VMware-workstation-full-11.1.2.61471.1437365244.exe 在百度一搜即可；    3，linux系统软件：我用的是ubuntu-12.04.4-server-amd64.iso，是server版本的，初学者也可以也可以下载Desktoop版本，有类似Windows的界面，更容易操作。可到ubuntu官网上下载：http://www.ubuntu.com/download/server    4，Hadoop软件：hadoop-1.2.1-bin.tar.gz  可以到官网上进行下载：http://hadoop.apache.org/    5，JDK软件：jdk-8u51-linux-x64.tar.gz 这个相对来说比较简单，我用的是版本8的。其实JDK，Hadoop还有用到的其它软件，我们可以通过linux命令：apt-get update   apt-get 软件的下载路劲，直接在linux上进行下载。     二，搭建步骤：先看一张总体要完成工作的步骤图：    1，安装虚拟机VmWare：百度一下下载下来，很容易安装，不再赘述。VmWare为我们提供了一个虚拟的平台，我们可以在这个平台上安装多个不同的系统，进行学习实验。              2，在VmWare上安装三台相同的linux系统，我安装的ubuntu，过程不再赘述，大家可以根据这个教程进行安装：http://jingyan.baidu.com/article/0320e2c1ef9f6c1b87507bf6.html。这里需要注意的是，a:大家在网络选择的时候，用桥接模式，更加方便，会自动分配ip，如下图；b:系统名字可以根据自己的习惯进行起名，例如：master,slaveone,slavetwo等。好，开是下边的四个步骤：    2.1，设置SSH连接：    我这里是通过SecureCRTPortable.exe和SecureFXPortable.exe两个软件进行连接的。当然还有Putty等其它软件。有时候linux没有安装ssh服务，需要我们进行安装一下：安装ssh-serversudo apt-get updatesudoapt-get install openssh-server安装ssh-clientsudoapt-get install openssh-client查看ssh是否安装好，下边及已经安装。    然后就可以通过SecureCRTPortable.exe进行连接linux，很简单，看这个图文教程：http://jingyan.baidu.com/article/17bd8e523cfb9285aa2bb872.html     2.2，配置hosts文件，其实就是为了方便，我们平时输入www.baidu.com，进入百度，其实是映射了一个具体的地址，这里配置hosts文件，就是将各个节点机器的ip与一个名字映射起来，我们连接时直接使用名字即可，利用VI命令修改host文件（VI编辑命令：http://blog.csdn.net/liujiahan629629/article/details/47803261）：     vi   /etc/hosts    2.3，建立Hadoop账户，三台节点的账户都建成一样的，方便后边的免密码登录：sudogroupadd hadoop    //设置hadoop用户组sudo useradd –s /bin/bash –d /home/ljh –m ljh –g hadoop –Groot   //添加一个ljh用户，此用户属于hadoop用户组，且具有root权限。sudo passwd ljh  //设置用户ljh登录密码su ljh   //切换到ljh用户中     2.4，设置免密码登录，其实就是一种算法RSA，将彼此的公钥放在要放在要访问的电脑上，自己保存私钥，保存好不用再进行输入密码验证。说通俗一点就是将本电脑的信息和密码已经保存到要访问的电脑上，直接访问即可。    a,在每台电脑上进行SSH公钥私钥的生成：id_rsa为私钥，id_rsa.pub为公钥    b,分发公钥，将公钥分发到每一个节点上，包括自己本身,我的authorized_keys包括三个节点的公钥。通过下边命令：    scp ./id_rsa.publjh@slaveone02:/home/ljh/.ssh/authorized_keys    每台电脑都这样操作，这样我们三个节点就可以相互之间进行免密码登录了。     3，JDK安装：这个相对来说比较简单：看这个链接即可：http://www.cnblogs.com/plinx/archive/2013/06/01/3113106.html     4，Hadoop安装，其实这里就简单多了，主要是配置文件配置：    4.1下载安装，将下载好的hadoop，进行tar解压即可，放到/home/ljh/下边即可。    4.2配置Hadoop-env.sh文件，即环境文件，可以这样理解，主要配置JDK的home路径，配置文件都放在conf文件中：   4,3配置masters,slaves 文件：     masters文件：     slaves文件：   4.4，配置namenode,修改各种site文件：      core-site.xml文件：     hdfs-site.xml文件：     Mapred-site.xml文件：    这样基本配置就算结束了，可以向各个节点进行hadoop的copy了。    4.5向各个节点复制Hadoop,各个节点的linux配置要是一样的，利用linux命令进行复制：       Scp -r ./hadoop-1.2.1  slaveone02:/home/ljh     4.6,格式化namenode:        ./bin/hadoopnamenode -format     4.7启动Hadoop:利用bin下的star-all.sh即可    4.8，用Jvm的Jps进行进行的检查：     master中的进程：     slave中的进程：     最后我们可以通过浏览器输入网页进行查看Hadoop的启动状态：    至此，Hadoop三个节点的集群环境正式搭建完毕，从这个基础上不断学习Hadoop吧。感觉搭建Hadoop的重点是对linux的操作熟练与否，所以还得不断的熟练linux。

版权声明：本文为博主原创文章，未经博主允许不得转载。

2015-8-25股市大跌
当15年第一次A股下跌6%的时候，我看了07年的那波，发现，单日跌这样不可怕，可怕的是单日跌幅这么大后的两个星期内，又有跌幅达4％的单日跌幅。
不幸言中，当然，对于我自己来说，关键的是，我有这样的想法，就要贯彻某些现象出现后，坚决执行纪律，开始减仓和清仓。在股市中，有纪律才能有可能说得上是投资而非赌博。
到今天为止，沪深两市都跌破15年的数值，沪市跌穿3000心理支撑位，甚至跌穿的时候都没有挣扎一下；创业板指跌穿2000点。真系牛转熊的时候不要碰创业板，不要碰B类基金，跌得非常恐怖。
我是看空后市的，为什么呢？


哇塞，这个这么不靠谱的分析都能 出来，其实还是有点靠谱的，因为从人性的角度出发，从我自己身边看到的例子归纳而来的。不过，样本容量太少而且分布不均匀。
－－－－－－－－－－－－－－－－－－
仅用来纪念A股跌得如此之惨烈！

版权声明：本文为博主原创文章，未经博主允许不得转载。

黎明前的黑暗-->屋漏偏逢连夜雨
  1，          大奇迹日 --> 日K线分析 低开100个点，收盘跌300个点，千股跌停，大盘指数9%跌幅，创历史记录。各种破线：攻击线向下穿越，破操盘线攻击线向下穿越，破生命线攻击线向下穿越，破决策线攻击线向下穿越，破趋势线攻击线向下穿越，破年线啥都破了，一破到底…… 攻击线 都破了，熊市无下限，被套的持股持币观望吧，割也割不动了。  2，从GDP经济总量和530分析，给我们的希望2008年 GDP为316752亿元, 牛市转到熊市最后大跌到1664点，2014年 GDP为636463亿元，是08年gdp的2倍，所以大盘最终会跌倒应该是08年的2倍左右，应该是3200左右。这是根据技术分析以及市场经济总量估算出来的，因为已经跌无可跌了，再跌跌不下去了，所以大家不用担心的啊，接下来就是震荡震荡，然后熊市横盘了。  当然这里除非国家队蓝筹股故意砸盘砸到2000多点不然正常再跌也没有办法去跌了。从08年到14年，gdp疯狂增长，但是股市一直处于价值低点，这很不正常 。 按照以往经济总量gdp和熊市最低点的技术线条分析一看，3200是正常的最低点了，除非国家经济大滑坡，像日本那样，gdp倒退引发股市动荡，不然差不多了这个最低价了，这是我们的底线了。 拿天津港来说，今天的成交量大于前2天，而且买盘多余卖盘，表明今天很多人抄底天津港，所以大家对天津港还是很有信心的。 我相信我的判断，股市无神迹，股市无股神，一切的分析判断都要以事实作为依据，明天会在3100到3200之间横盘 只是亲们，你们还有子弹吗？你们还有仓位补仓吗？你们还有可用资金抄底吗？   3，30分钟线给我们最后的希望MACD线：绿柱子越来短，表明看空的趋势越来越弱，市场往有利方向发展。 KDJ线：尾盘J线在地板上调头往往上攻，接近KD线，三线纠缠在一起，表明前期趋势不明朗。  DMI线，di1线在50以下弱势区域往上接近di2线，看空趋势慢慢变弱，而adx和adxr也从50以上的高位往下突破接近50线上，表明多空双方慢慢持平了。 MTMTM：MTM在0下面的弱势区域往上攻破MTMTM，看空的力量在减弱。 MAVOL线：MAVOL5慢慢往上攻，而MAVOL10线持平往前水平发展，表明成交量持续放大，但是还处于弱势当中，后期趋势慢慢好转中。 总结：5大技术指标中，基本表示行情从狂跌中慢慢恢复过来，明天大盘走势低开横盘中，可能收一根小阳线或者十字星或者小阴线，如果国家队蓝筹股出手的话或许会收一根大阳线也说不准呢。   4，      自己操作总结今天在跌停板补仓天津港和新赛股份，天津港是准备做长线的，新赛股份是赌国企改革的，今天大奇迹日我补仓是因为我预测分析已经基本到这个波段的低点了，可以补仓了。 到目前为止，已经算是重仓了。 股市的第一操作原则：保住本金，不全仓。 股市的第二操作原则：别人恐惧我贪婪，别人贪婪我恐惧。今天大奇迹日，大家恐惧割肉的时候，你敢逆流而上补仓吗？

版权声明：本文为博主原创文章，未经博主允许不得转载。

P1193扫雷 (DP状态压缩)

P1193扫雷
Accepted


标签：[显示标签]













描述

相信大家都玩过扫雷的游戏。那是在一个n*n的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了，“余”任过流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字表示和他8连通的格子里面雷的数目。现在棋盘是n*2的，第一列里某些格子是雷，而第二列没有雷，如：
o 1
* 2
* 3
* 2
o 2
* 2
* 2 ('*'代表有雷，'o'代表无雷)
由于第一类的雷有可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息求第一列雷有多少中摆放方案。




格式

输入格式

第一行为N，第二行有N个数，依次为第二列的格子中的数。（1<=N<=10000）

输出格式

一个数，即第一列中雷的摆放方案数。





样例1

样例输入1[复制]




2
1 1

样例输出1[复制]




2





限制

1s




来源

NOIP2006夏令营
设置DP[i][j]表示第几个数他所覆盖的三个格子（j的二进制中的1代表放了雷）
所以dp[n][i] = dp[n - 1][j] {(i
 &3)  == ((j & 6) >> 1)}
注意一下，一定要把包给去掉，否则会WA得很惨
（提示：状态压缩的题目一般会转换为二进制进行处理，当然可以直接加长数组，但是却是不方便）


//package ds;

import java.util.*;
import java.math.*;
import java.io.*;

public class Main{
	static Scanner cin;
	static PrintStream cout;
	static int MAXN = (int)1E4 + 5; 
	static int [] mp = new int[MAXN];
	static int [][] dp = new int[MAXN][10];
	static int Bit_Count(int val){
		int ret = 0;
		while(val > 0){
			val &= (val - 1);
			ret ++;
		}
		return ret;
	}
	public static void main(String [] agrs)
	throws IOException
	{
		cin = new Scanner(new BufferedInputStream(System.in));
		cout = new PrintStream(System.out);
		while(cin.hasNext()){
			int N = cin.nextInt();
			for(int i = 1;i <= N; i ++){
				mp[i] = cin.nextInt();
			}
			for(int i = 0;i <= N + 1;i ++){
				Arrays.fill(dp[i], 0);
			}
			if(mp[1] == 0){
				dp[1][0] = 1;
			}
			else if(mp[1] == 1){
				dp[1][2 << 1] = 1;
				dp[1][1 << 1] = 1;
			}
			else if(mp[1] == 2){
				dp[1][3 << 1] = 1;
			}
			for(int i = 2;i <= N ;i ++){
				for(int j = 0;j <= 7;j ++){
					for(int k = 0;k <= 7;k ++){
						int c = (j & 3);
						if(c == (k >> 1) && Bit_Count(j) == mp[i]){
							dp[i][j]  += dp[i - 1][k];
						}
					}
				}
			}
			int ans = 0;
			for(int k = 0;k <= 3;k ++){
				if(Bit_Count(k) == mp[N])
				ans += dp[N][k];
			}
			cout.println(ans);
		}
	}
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

Win  10免费升级正在进行中（+ing)

          7月29日，微软CEO纳德拉果断地按下免费升级到Win10的启动按钮，从此，全球进入漫长的Win10升级的征途之中（...ing）。现在的情况如何？用户欢迎吗？喜欢什么特性？



近日，成立于2005年的英国社交媒体研究公司BrandWatch公布了一份调查报告，发现广大的计算机用户喜欢Win10操作系统，其中特别“love”系统捆绑的个人助理Cortana。请见文章：Windows
 10 users “love” Cortana and Edge browser: study。



该文说得很明，绝大部分的用户都说Cortana的”好话“，说”坏话“的人不多。这是升级Win10长久的推动力，不管你自己愿意不愿意。



微软新一代CEO纳德拉笃信人工智能产品（比如Cortana），借此提高全球个人生产力。我们目前正处在这一历史大变革之中，只是”浑然不觉“而已。



老实说，Win10新一代操作系统正在把我们带入到人造智慧的世界之中。在日常生活与工作中，我们有事问问Cortana“小帮手”（相关个人隐私数据都存储在用户的本地硬盘之中,，这是可选项），这有什么不好的呢？为什么要禁止Win10？根本没有道理！



袁萌8月25日




版权声明：本文为博主原创文章，未经博主允许不得转载。

微软笑了
          8月24日，微软个人助理Cortana悄悄地爬到安卓肩膀上（在美国境内进行公测），此事有何意义？



根据市场调研公司Gartner的数据，在今年第二季度，微软智能手机在全球市场上只占2.5%的市场份额，微不足道也。而安卓手机占有82%的市场份额，苹果手机占有14.6%市场份额。微软此举的意义，由此可见。



大家知道，安卓系统的内核就是Linux，准确地说，是GNU/Linux。在某种意义上说，在全球移动市场上，现在是GNU/Linux的天下，微软输的很惨。



实现微软的“视窗即服务”的战略，“Cortana帮助人类拯救世界”，微软必须把个人助理Cortana移植到GNU/Linux内核之上。我们由此不难想象，微软借助巨大无比的云计算数据中心（Azure中心）向全球计算机用户不断推出“个性化”服务“（即Cortana）的情景。Cortana个人助理是微软纳德拉的宠儿。



实际情况是，这次微软个人助理安卓版的发布，在美国业内引起很大的轰动，而在我国业界，一切都很平静，似乎这是无所谓的事情。



微软此举（战略行动）表明了公司对”服务为王“的业务转型必胜的自信心，当然值得一笑了。



袁萌 8月27日




版权声明：本文为博主原创文章，未经博主允许不得转载。

unity Kinect v2 with MS-SDK20绿屏抠像shader修改 透明背景
用的是kinect2.0

 Kinect v2 with MS-SDK20插件
例子中的默认greenscreen里面是绿色的,要求改成透明的,下面直接上代码
改完后放背景看看吧 是不是透明了

Shader "DX11/GreenScreenShader" {
 SubShader {
 //透明就需要这个
  Blend SrcAlpha OneMinusSrcAlpha
 Tags {"Queue"="AlphaTest" }
 
 
 Pass {
 
 CGPROGRAM
 #pragma target 5.0
 
 #pragma vertex vert
 #pragma fragment frag
 
 #include "UnityCG.cginc"
 
 Texture2D _MainTex;
 
 sampler SampleType;
 
 struct vs_input {
     float4 pos : POSITION;
     float2 tex : TEXCOORD0;
 };
 
 StructuredBuffer<float2> depthCoordinates;
 StructuredBuffer<float> bodyIndexBuffer;
 
 struct ps_input {
     float4 pos : SV_POSITION;
     float2 tex : TEXCOORD0;
 };
 
 ps_input vert (vs_input v)
 {
     ps_input o;
     o.pos = mul (UNITY_MATRIX_MVP, v.pos);
     o.tex = v.tex;
     // Flip x texture coordinate to mimic mirror.
     o.tex.x = 1 - v.tex.x;
     return o;
 }
 
 float4 frag (ps_input i, in uint id : SV_InstanceID) :COLOR
 {
     float4 o;
     
     int colorWidth = (int)(i.tex.x * (float)1920);
     int colorHeight = (int)(i.tex.y * (float)1080);
     int colorIndex = (int)(colorWidth + colorHeight * (float)1920);
     
     o = float4(0, 0, 0, 0);  //<-- Here I set alpha to zero in my version 
                              // to feed into Transparent/cutout/diffuse
     
     if ((!isinf(depthCoordinates[colorIndex].x) && !isnan(depthCoordinates[colorIndex].x) && depthCoordinates[colorIndex].x != 0) || 
         !isinf(depthCoordinates[colorIndex].y) && !isnan(depthCoordinates[colorIndex].y) && depthCoordinates[colorIndex].y != 0)
     {
         // We have valid depth data coordinates from our coordinate mapper.  Find player mask from corresponding depth points.
         float player = bodyIndexBuffer[(int)depthCoordinates[colorIndex].x + (int)(depthCoordinates[colorIndex].y * 512)];
         if (player != 255)
         {
             o = _MainTex.Sample(SampleType, i.tex);
         }else o.a = o.rgb; 
     }
      
      
//    float4 sampler2[9];
//    float4 minValue = float4(255,255,255,255);
//    for (int i = 0; i < 9; ++i)
//    {
        //sampler2[i] = texture2D(SampleType, gl_TexCoord[0].st + tc_offset[i]);
        //minValue = min(minValue, sampler2[i]);
//    }
     return o;
 }

 ENDCG
 
 }
 }
 
 Fallback Off
} 


版权声明：本文为博主原创文章，未经博主允许不得转载。

跳格子问题——阿里笔试
有1,2,3,......无穷个格子，你从1号格子出发，每次1/2概率向前跳一格，1/2概率向前跳两格，走到格子编号为4的倍数时结束，结束时期望走的步数为____。


2
12/5
14/5
16/5
18/5
4


这个问题，很显然考察的是递归问题：
定义step(i,j)为第i号格子带第j号格子的期望值；
step(1,4)为从第一格跳到第四格的期望，要到第四格，则只能先到第二格（期望0.5*（step(1,2)+1)）或者是第三格（期望0.5*（step(1,3)+1)）；其中1表示到达第2格或者第3个之后，跳到第4格还需要1步。
故有
step(1,4)=0.5*（step(1,2)+1)+0.5*（step(1,3)+1)=1+0.5*(step(1,2)+step(1,3))
同理有
step(1,3)=1+0.5*step(1,1)+0.5*step(1,2)
step(1,2)=1+0.5*step(1,1)+0.5*step(1,4)
step(1,1)=0
联立方程，得到
step(1,4)期望为18/5，选E。


也可以用计算机求概率，如：
/**
 *  项目名称：
 *  文件说明：
 *  主要特点：
 *  版本号：1.0
 *  制作人：lcx
 *  创建时间：2015-8-25
 **/

/**
 * @author lcx
 *
 */
public class PaceTest {
	
	static Random rand=new Random();
	public static int pace()
	{
		return (int) (rand.nextDouble()*2+1);
	}

	public static void main(String[] args) {
		double sum=0;
		int times=10000;//实验10000次
		for(int i=0;i<times;i++)
		{
			int index=1;
			int pace=0;
			while(index%4!=0)
			{
				index+=pace();
				pace++;
			}
			sum+=pace;
		}
		System.out.println("期望值为: "+sum/times);
	}
}

追问1，若本题是从2开始，则期望多少？

同样的方法：
step(2,4)=1+0.5*step(3,4)
step(2,3)=0.5+0.5*(1+step(2,1))
step(2,1)=1+0.5*step(2,3)+0.5*step(2,4)
step(2,2)=0
最终求出
step(2,4)=12/5


追问2，若本题是3的倍数就停止，则期望为多少？
同样方法计算，期望值为2。


本题归根到底是利用递归思想。类似的题目还有青蛙跳问题、摆瓷砖问题（编程之美）等。







版权声明：本文为博主原创文章，未经博主允许不得转载。

php动态调用函数方法&&非关系数据库的优势

php动态调用函数方法，第一反应就是魔术函数带下划线的函数，__autoload,__struct,__get,__set等函数。
        其实php提供call_user_func()call_user_func_array()， 可以动态的调用函数。在实现MVC机制的时候，当路由器完成动态路由之后，就会解析后动态的调用对应的Controller方法。call_user_func 跟call_user_func_array差不多，只是array函数，是将函数的参数作为数组传递进来。而call_user_func是在调用的函数后面，直接将参数给带进去。
     检查一个ip地址的合法性，第一反映就是，根据ip地址，利用explode函数将ip进行分割，拿到第一个元素与255进行大小比较，判断是否是是ip的合法地址。
     其实合理的判断方法，应该是利用ip2long这个函数进行判断。因为ip2long如果解析到错误的ip地址，会返回false。同理类推，可以将得到的ini类型的ip地址，给定的ip范围作对比，从而进行ip地址限制。
      当线上一张表数据量巨大的时候，同时需要对这张表进行字段更新时候。有什么好的办法？
      第一反应，启用备份数据表。然后对数据表进行更新，再将数据导入更新好的数据表结构的表中。
      这个暂时没有想到关系型数据库，mysql特别好的实现方法，不过启用非关系型数据库nosql，mongodb甚至是redis的话，就没有表结构限制这个概念。自然对表字段进行更新，不需要停止线上应用。而redis本身就是key-value类型，没有表这个概念的话，对字段的增删改都不会影响线上应用的使用。

版权声明：本文为博主原创文章，未经博主允许不得转载。

第1篇，移动互联网究竟是何方神圣还是一个妖魔鬼怪？
移动互联网成为当今最热门的一个话题。但也经常有人说：我又不是互联企业，移动互联网与我有多大关系呢？



如果你穿越到中国最繁荣的唐朝，无论你问李世民还是魏征，或者随便问一个山村野夫：电，你用吗？
他们一定会问：电是啥玩意？我要那干什么？


如果今天问你：你用电吗？


移动互联网就是我们所说的“电”，在过去也许可有可无，但今天，我们讨论的不是移动互联网与我们有没有关系，而是有多大的关系？


它与你已经息息相关，密不可分！




如果你错过了，可能错过的不是一个商业机会，而是一个时代！

Nokia、Inter、Microsoft、HP、柯达……，他们，还不够吗？


小结:
对传统商业的守旧者来说就是妖魔鬼怪，对想提升客户体验的改革者来说就是神圣。不过从00后的人开始，移动互联已经是最基本社会生活方式，像空气一样容易被忽略但非常非常重要。


序言、微信营销
第2篇，到底什么是互联网思维？

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

EF学习和使用（四）解析EF的核心-EDM
通过前三篇博客的介绍，相信大家都已经学会EF的基本使用了。但是这仅仅是第一步，咱们还需要深入了解EF的核心机制，将来还会做EF的性能优化等等。今天就来刨根究底一下，EF的核心EDM； 

EDM的全称为Entity Data Model（实体数据模型），大家可能不明白他是个什么东西，其实咱们在使用DBFirst和ModelFirst的时候都接触过EDM。EDM模式在项目中的表现形式就是扩展名为.edmx的文件。这个包含EDM的文件可以使用Visual Studio中的EDM设计器来设计， 
如下图： 



EDM由三个概念组成 

(1) 概念层：负责向上的对象与属性显露与访问，说白了就是咱们建立的实体类；由概念架构定义语言文件 (.csdl)定义 

(2) 对应层：将上方的概念层和底下的储存层的数据结构对应在一起，起一个映射的作用；由映射规范语言文件 (.msl)定义 

(3) 存储层：依不同数据库与数据结构，而显露出实体的数据结构体，和 Provider 一起，负责实际对数据库的访问和 SQL 的产生；由存储架构定义语言文件 (.ssdl)定义 

这三者合在一起就是EDM模式。由于这个文件本质是一个xml文件，可以手工编辑此文件来自定义CSDL、MSL与SSDL这三部分。下面详细分析一下这个xml文件及三个其重要组成部分： 



EDM之CSDL 

  CSDL定义了EDM或者说是整个程序的灵魂部分 – 概念模型。通俗地讲就是实体类。实体类是面向对象设计中一个最根本的组成部分，其体现了现实世界中对象作为一种计算中可以表示的对象设计方法。而EDM的CSDL就是要达到这样一个目的。 

 

 这部分XML文档，Schema是CSDL的根元素，其中定义的Namespace是用于ObjectContext与EntityClass的命名空间，Alias-别名为此命名空间Namespace指定一个易记的名称，在定义Alias之后，在此Schema内的Element均可用该Alias作为Namespace的别名。

EDM之SSDL 

 这个文件中描述了表、列、关系、主键及索引等数据库中存在的概念。文档的结构与CSDL很相似，只是其中EntityType等使用数据库的概念进行描述。其中有一个节点需要了解：DefiningQuery，他定义通过实体数据模型 (EDM) 内的客户端投影映射到数据存储视图的查询，就是下面文件中的查询语句。
  <!-- SSDL content -->
    <edmx:StorageModels>
      <Schema Namespace="EFTestModel.Store" Provider="System.Data.SqlClient" ProviderManifestToken="2008" Alias="Self" xmlns:store="http://schemas.microsoft.com/ado/2007/12/edm/EntityStoreSchemaGenerator" xmlns:customannotation="http://schemas.microsoft.com/ado/2013/11/edm/customannotation" xmlns="http://schemas.microsoft.com/ado/2009/11/edm/ssdl">
        <!--生成过程中发现错误:
警告 6002: 表/视图“EFTest.dbo.User”未定义主键。已推断出该键，并将定义创建为只读的表/视图。-->
        <EntityType Name="User">
          <Key>
            <PropertyRef Name="ID" />
          </Key>
          <Property Name="ID" Type="varchar" MaxLength="50" Nullable="false" />
          <Property Name="Name" Type="varchar" MaxLength="50" />
          <Property Name="Sex" Type="varchar" MaxLength="50" />
          <Property Name="deptment" Type="varchar" MaxLength="50" />
        </EntityType>
        <EntityContainer Name="EFTestModelStoreContainer">
          <EntitySet Name="User" EntityType="Self.User" store:Type="Tables" store:Schema="dbo">
            <DefiningQuery>SELECT 
[User].[ID] AS [ID], 
[User].[Name] AS [Name], 
[User].[Sex] AS [Sex], 
[User].[deptment] AS [deptment]
FROM [dbo].[User] AS [User]</DefiningQuery>
          </EntitySet>
        </EntityContainer>
      </Schema>
    </edmx:StorageModels>


EDM之MSL 

MSL文件的作用就是管理 CSDL与SSDL之间的对应关系了。建立实体类与数据库结构的一一映射
    <!-- C-S mapping content -->
    <edmx:Mappings>
      <Mapping Space="C-S" xmlns="http://schemas.microsoft.com/ado/2009/11/mapping/cs">
        <EntityContainerMapping StorageEntityContainer="EFTestModelStoreContainer" CdmEntityContainer="EFTestEntities">
          <EntitySetMapping Name="User">
            <EntityTypeMapping TypeName="EFTestModel.User">
              <MappingFragment StoreEntitySet="User">
                <ScalarProperty Name="ID" ColumnName="ID" />
                <ScalarProperty Name="Name" ColumnName="Name" />
                <ScalarProperty Name="Sex" ColumnName="Sex" />
                <ScalarProperty Name="deptment" ColumnName="deptment" />
              </MappingFragment>
            </EntityTypeMapping>
          </EntitySetMapping>
        </EntityContainerMapping>
      </Mapping>
    </edmx:Mappings>


如上代码所示，MSL的根节点为Mapping，其中可以包含多个EntityContainerMapping，每一个EntityContainerMapping对应着两个分别来自CSDL与SSDL的EntityContainer。这个EntityContainerMapping就是描述这两个EntityContainer间的对应。

EDM与ORM

看完上面对EDM的详细介绍后，大家脑子里肯定浮现了出了一个名词ORM。没错EF作为实现了ORM思想的框架，其核心EDM的概念与ORM的概念是非常一致的，EDM的三层非别对应了ORM思想实体，关系，映射。 



关于EDM的介绍就说到这里，更加详细的解说请看：http://www.cnblogs.com/lsxqw2004/archive/2009/05/31/1495240.html#_Toc228672768 

后续博客将陆续推出EF在具体项目中应用的问题，以及性能优化，敬请关注。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1162 Eddy's picture
最小生成树裸题，没有初始化都能AC，看来测试数据只有一组
#include<iostream>
#include<vector>
#include<cmath>
#include<cstdio> 
#define inf 1<<30
#define maxn 105
using namespace std;
struct stu
{
	double x,y;
};
stu mapp[maxn];
int n; 
vector<int>root[maxn];
double vaule[maxn][maxn];
int visit[maxn];
void prim()
{
	double d[maxn];
	fill(d,d+maxn,inf);
	fill(visit,visit+maxn,0);
	double re=0;
	d[0]=0;
	while(1)
	{
		int v=-1;
		for(int i=0;i<n;i++)
		{
			if(!visit[i]&&(v==-1||d[i]<d[v])) v=i;
		}
		if(v==-1) break;
		re+=sqrt(d[v]);
		visit[v]=1;
		for(int i=0;i<root[v].size();i++)
		{
			int x=root[v][i];
			d[x]=min(d[x],vaule[v][x]);
		}
	}
	printf("%.2lf\n",re);
}
int main()
{

	while(cin>>n)
	{
		for(int i=0;i<maxn;i++) root[i].clear();
		for(int i=0;i<n;i++)
		{
			cin>>mapp[i].x>>mapp[i].y;
			for(int j=0;j<i;j++)
			{
				int l=pow(mapp[i].x-mapp[j].x,2)+pow(mapp[i].y-mapp[j].y,2);
				root[i].push_back(j);
				root[j].push_back(i);
				vaule[i][j]=l;
				vaule[j][i]=l;
			}
			
		}
		prim();
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream 1420 High Speed Trains（容斥原理+大数）


High Speed Trains

Time Limit: 2000/1000MS (Java/Others) Memory Limit: 128000/64000KB (Java/Others)

Submit Statistic Next
 Problem

Problem Description

      The kingdom of Flatland has n cities. Recently the king of Flatland visited Japan and was amazed by high speed trains Shinkansens going all around the country. Therefore he decided to build the system of high
 speed trains in Flatland.
      Each high speed train line will be bidirectional and connect exactly two different cities of Flatland. Although there is actually no need of high speed trains in Flatland, the king ordered that there must be at
 least one high speed train line from each city of Flatland.
      The minister of transportation told the king that there are several train system satisfying his requirements. The king was amazed by the fact and asked the minister to count the number of possible systems.
      Help the minister to calculate the number of train systems.


Input

      The input file contains one integer number n (2 ≤ n ≤ 100)

Output

      Output one integer number — the number of different train systems that can be arranged in Flatland.

Sample Input

4



Sample Output

41



题目大意：
n个点，每个点至少连一条边，求方案数。
图可以不连通，如当n=4时，最少2条边。



解题思路：
昨天的专题简直就是java专场。


n最多100，可以先求出所以答案，再进行O(1)的查询。
首先i个点最多有(i-1)*i+1条边，每条边有存在与不存在2种状态，所以一共有tmp=2^((i-1)*i+1)-1种方案（减去的1指的是所有边全部不存在的情况）。

由于直接不好计算，所以我们可以考虑对立面。题目要求i个点全部有边相连，那么考虑至少有一个点没有一条边与它相连，即仅有2、3、4……i-1个点有边连接（没有1是因为一条边会连接2个点，不可能出现只有一个点有边的情况），这时发现这些数已经在计算ans[i]前计算出来了，所以只需要ans[i]=tmp-ans[2]*C[i][2]-ans[3]*C[i][3]-......ans[i-1]*C[i][i-1],出现组合数是因为每次要从i个点中挑出m个使这m个点有边连接，其余i-m个点无边连接，每次从i个点中挑出m个点的方案数是C[i][m]。
感谢某人给我提供的java方面的帮助！

参考代码：

/*
* this code is made by Noooooorth
* Problem: 1420
* Verdict: Accepted
* Submission Date: 2015-08-25 22:13:25
* Time: 480MS
* Memory: 97148KB
*/
import java.util.*;
import java.math.*;

public class Main {	
	public static BigInteger C(int n,int m){
		BigInteger re=BigInteger.ONE;
		for(int i=1;i<=n;i++){
			re=re.multiply(BigInteger.valueOf(m-i+1)).divide(BigInteger.valueOf(i));
		}
		return re;
	}
	
	public static void main(String[] args) {
		BigInteger one=BigInteger.ONE;
		BigInteger two=BigInteger.valueOf(2);
		BigInteger ans[]=new BigInteger[105];
		ans[2]=one;
		for(int i=3;i<=100;i++){
			ans[i]=two.pow(i*(i-1)/2).subtract(one);
			for(int j=2;j<i;j++){
				ans[i]=ans[i].subtract(C(j,i).multiply(ans[j]));
			}
		}
		Scanner cin=new Scanner(System.in);
		while(cin.hasNext()){
			int n=cin.nextInt();
			System.out.println(ans[n]);
		}
	}
}
 还有一种炸天的方法（vj限制了代码长度，所有只能在ACdream上提交）


/*
* this code is made by Noooooorth
* Problem: 1420
* Verdict: Accepted
* Submission Date: 2015-08-25 22:11:33
* Time: 0MS
* Memory: 1732KB
*/
#include<bits/stdc++.h>
using namespace std;
string ans[105]=
{
    "-1",
    "-1",
    "1",
    "4",
    "41",
    "768",
    "27449",
    "1887284",
    "252522481",
    "66376424160",
    "34509011894545",
    "35645504882731588",
    "73356937912127722841",
    "301275024444053951967648",
    "2471655539737552842139838345",
    "40527712706903544101000417059892",
    "1328579255614092968399503598175745633",
    "87089694570964435671324844104521079746880",
    "11416413723839697400250507510852029840275473569",
    "2992938426499310900182770181410138818740061901947908",
    "1569215572908922308521995363961205592532386450494198274313",
    "1645471603165642700870123365352805341961877233365177453588005824",
    "3450836972657518843027307566308067339158750625752078009405689318211161",
    "14473931784997846210304793419064065231590568813586460830279677624521460536244",
    "121416458388792792649252647241600388956012443221106391448273002005554602042419577681",
    "2037032940918684178976184250818659345229517524662717388401435022357882783074342940728628000",
    "68351532186573198364243409327908758411752176373314636529587924648035548600802556000407708465724081",
    "4586995386488058986827880103080301055617470443300409663038804211130157172728628324791249533476741513190724",
    "615656218382767079140368523314666378067041110344327052442105313805257595292939851923944285549664502097869724318521",
    "165263974343529954317356861238565609447053351468551388266539403120010283263766600344094664895724527842711947319337103313248",
    "88725425253946577390137004665051099743341013053515477065967572044226981871352297413475235807042088670409886790198227401288743591849",
    "95268202520385526637986233936974667779805651033713707832000011893132709619843981574455460272576770474359430072502475845354724234793418238644",
    "204586909944926342215675757969328192615286275819478574751095918111085516479096593307895964518951913249145374978627151534646279971682839257270066349761",
    "878694093745349965033502594315633305831423348168716781855034808738594839478577490869993152277274474817150979968169377045130588455045403174167695472738397130880",
    "7547924819767483402367953301648843595390850857342001106183928279485100098009487488552358319055148904957428817509422944135401518398501749811772404830062788893611734127425",
    "129672361263353660738827839539965860638709352728998026184923084317268299008524142375422677379906565367543537959354092070023571030666511295683917950909129886198952449595855251572228",
    "4455508410978470007968344716866498138642471184517168554854220039545069131008871716588278712394969053537768722884017200452235232138712153670987234426768225423566577718431736193815342682614761",
    "306180206751230091016675467132732806798893016603488469464382061254229783345539134329714822285147261802483054650144190994569515229757634617032445053176772359567346044769376774208907346959234954879521408",
    "42081087200752140198248953190395581117582323875265366140515558020393583255681409821156659619010324997388625658087808979809018720113551029230344354336438422656082580309258109794130916057214438400291617976939494265",
    "11567161173227696466447336816695066165039763519419555325259691334406585295325501537840310316159938782586079387881820215182328454588950369084606665947871968713213238833370983458031060036209724293067527109814799128876919650612",
    "6359114105601017351408288878064905263866658953806880823736641946347481055240545062113184060591626390730626377931209552501152405879660090297634327028610988015692766860902956702142624812738029600777591216485670473359344000395925558440113",
    "6991919901710702396958427887737098476406123145888448373972832082249174478729219805232073913086288870815458196525696206975101995571932314828183977812556110313301933794619422590926799631826141146325928960207139220874195380742478976206248566268213600",
    "15375394465098365435103606262485648813731689610764786731485421737822834797273152493893303478414423892247122990573254606060877987088283776435111024652309468957224924480750725955516859522327151543381910863340521046671074079879177037242451769004747348970400726609",
    "67621699984704009571093949051933347323033942723591971420961654694361729000009453943349417050066498697168532312968847634399282360173446924966572411488673484835582936072259136005436901175709074663388020859582070981538504865993521127291316066926565506226402674272692246842948",
    "594806763388137870319883477715668014639530226250221334439268225572611604793566033353499885570285056724495531871328329408565766271788910680343753781709753839466974109279174360882895375331986271974503645690239888199740350163963394852863451796823258444580819828987043240094569439178005273",
    "10463951242026625501784430220079200349620190959855944731114436849579329218873388723507825365480181681240069956520124773793045889232629285007229542711667079762168429587695506277386530539600960138203196658268021421070060073719880333248021378799564961694860246572138977899599116168278661336912704319264",
    "368167554019320956145827862675510073905644855221586522560433473265572483507080939079705212086728437288829821510686303041329965427669398698246709510271765350093805510437355320602416018403182506754415616449810066582716483225352237188042691892487281620512135576613182207165052584133161253329646175586643485523247561",
    "25907488423318455274080484983551268752370543099016841024117675414780399983983209938035137269259009674371204242508318891176098687435253584276757950255770132597038125086011764201848182377132306683838545920270033915231978097219579884958727620755064828166606815073051027843939073260544912155301615352784234112764304811523137670964",
    "3646154850293767810262811310292554298146565645867019354649585770004790633021626678757507253398244149898549184370988858690576347186473540946746323736037745650406421052832928165645966739998963516104746895198985455779234103654245359809834943004622380945022596140552216033662342758507318222391391091643172310652637299863290964708434648345424161",
    "1026301351570055077911629003334248563530371464014961160148619401207592660556077047093700278584812110511775503329505399525951272382879961842580388109766172185903445721080425066638767951023848346841383603393314410107638111227747234949014648614460507172283080648297239358958028751902379298960588029789253841807791801792272754750610497088659279402182443687360",
    "577756298062641319815321289100079552694029634663057875273943785430800384531476038109893895203528476169905479147990463891771969343302575438598105099018502424124922191666372843671990452528625848668354820659455100781798687574206844095861604418887897443012027810311504846313068170762845168681143809596401125443319579565431920928673429699359335691054904647627111458615258081",
    "650495762166495477049126324444410541525813630884897301380979707413679252867035654462271627698395461114214289022287899099038885330170369042401480942772062910670199337987248234699021555821747253111028515923539884193597708437710312776309910996429530362900660431406155850610173052290433543360921808095902473644145899362436027878169512233262308200140510593081281143119604723908380068185604",
    "1464786236049590434905743465920939449363508612723489733275085975271232721338429531138219065841302235916567783054374294379287733653218841081671921098700170514558378605530384489817663192379350125532435243792130071255314573037817334501406125128647680690733402114935447084764720152787970257228537134579283995767379494435753562434054820219725742354492634229012108340533817520857573820496809319023469721801",
    "6596810746850441581553741639333517038709585890364844858548292276866814935193603264502336243986689091798809506276103112808369454137540768409834360859088738465923804221580878951022935129231629315382958142689553240242818792813478886053564867108158417175038867724664809956107279132606082421193307933740445718316354198850963406276459700920142990260995375238662007665213674472311961765183537934747223463590949116578344768",
    "59418788842699007286030480484133660884873844970657116918672826052315575217873342407759073593388395868718631808826436996552918251489892863712708047464715584987953212870952381722251151630665825871817437404434940589277400592674849493518878205551854127413417273257072439525856730376348151662087524441257956944276113234081656955166759524007873827433382019207030381963972246993045156494510638693753585551476537129107374280888803464454809",
    "1070393741163144887106615725527983485123900327163113842327624473615019139490344817603117153858127197758222925711459724942607537356486960154106879151377124831554692131055540711435791826303525544435084503709686020620657806411239135434299652837652142334413357256722319414659283292220894140424217290182597906316368285988028905279181116684203912641912268506780276438686727310659002549938410585160603678477185432073780892588038226378024952743251982695604",
    "38564998830736461475232360560247842901295105745971775440696135010899885298362813845775680945520056068016359115318259858323400609083322760694240259239549568463780365174038285822257695909831049614979140376577861300198438360978883338147260016684985389436901589778117101913784241058455624626480715343998372139233079163492506057596659507988170740507862889097554357289743888084670790016382465053400438597926206668478686421788457495335150862751345259046904921688545736721",
    "2778901029818375590546117527114822833083253841903153663407293202330682354893910801678157678683711016787917227096257185870640193093070699753834558725956305747107538616630061275380656515610680186080503365311822964203277178367599567092774529887880237981396131583384921472464642874362720103516571575280501129842510328680140775471366955314487966622218587227833476993001362183521295649903852714271677911744100104628235240052844338319226284973732527589283770792408791230834380038791712160",
    "400481844556464920523193301963612210459645292252115579284594784683638498620830533586843353519737678332246322681450974227135732826222781447054824568948285848784503939831712503444206649814564507709464166035933585822620726771882633974912135897915246868072599793241390944610202413878391697051983068345048030409259348173432029130486385964525127264545916431882632575945486108917185125511354370729736139766065701983316942507385259834815241449856185970712583942074007615935592080232876443265428056629447665",
    "115431032698441259178673461431544571503868580018940277924794614711362891394725324650883486562381578285858228647728394726167590461972195281383015292686312477206278430985089289897799375265169457211616699579674677676069197471602915238481146867940935761265218364843432447486642018075182372077479720231505523288056632903537651643918165537976430062690283601150336033705604323159124279613568308518389215883616118655031313112374969090985045403397061125218680704695227858031756178800640459740642742756744225156507810909338948",
    "66541459948504530753768001471968667858284135409681724401529211759996954518451120032531139614225451493238231251532753733701055189842109413048439370020510522092871615726466341176313330049692126142040077571310209189414710653397070543707621702209667438403619575777366609708276569345859176432200644796894842211071811365074132417536370239768267097010140225383394752233663251770436883502726797657416433192243804494366548997794367254174820384247578803880348969810547890908371517261893224212909243055022533467235254803689765401001895961163001",
    "76717080122566093821769685096126559772123311624029237723465232813219038058215332768726502296650001326838250510587004733662016375013492953191451633671991930832662056467300994500426063088119178442252586999548057321448534212734353042686006343703170884180509130855894984348299125158647025644349686247733683852902217528484006343325456330531420273730411859784694088131519640808353993255350982185668474147182920966679606123864658043773526365017771144077862125855846520085396629984612009718749120108147731334597235208266539721603244154875732409825161040372448",
    "176897542887905871219682320710977180066096412507148130144398800591993075904013117980881355032801406588134609369694981641848153852976363677785544097092613770281818364124632009850706004125819990850402116952706073403325294541662034606811830123773348405095759708577893534599222004405949196660971716404021307415506077181991282349212625416976352338009103939503132620599547081657135972295238300924743231563343455499431523445127628582086163262928195106997271651640503572591551555564786896642694309499816136037740155827815220465607273333199955313101978017147630703180462437846505",
    "815795925230314728472279878236737235107487487375679658828359306005781952327011641385077044577339321765600913052762660294769820791770837231468099155402135727408487804724759410651567753149801583823491121663182746671004121828366325996683495336048610111103062424489029445610286346390600153775216536500430336286066264078744202103042898403387079868256073409579258273301091098732895412193763509971007357027650773056769253639107048750886569923068217313381516689017541924361807462712584927376426402065014205999079298496517051180385541771619470554470392299140576693851946130187364895826304018436532",
    "7524389324549354397801356452497913671637302623239050243751095468094073323336858804077729632349788033524157183679764253462806786929408221296937761659704126588516687374381386849405003977412109162567517683326594397687478205453084880131365490951409870797616769248976328676388931788505415601925973590645938499268262541049426638074456046768014363619822950195610040630933201569329368868610871434945858863279507025923260734426290801693454566867552748230899663807535422195912509514823638633361081868354837922529056986074315862782194950537772187870823640874737638254152056104507072694881589284940537679773850977072513",
    "138800484180914219712302326702802179854054812711075261937158556233721310371465055845617816558287345197144834244412133030562502074358385172099790842157457098300290240620772321168774924367197137494373750720538430011100673474275257245459737980714253280751787852562489002753282904223588010757292363201789356166325963714199767590418631057996650918561431174151900925134507597012978503880446863326377786858774360003890780369138234670418407251000511351628293581577299348828942273852930081493093998334121878456629837227377524106120944104925125633020408961756192040925542629667073721808448062405693069524542931864314469989248726628358400",
    "5120834017984591508986196650065047875839302139690230205242731029048153165740958537724634691687902033081125674592419026458254627254495852937279629517113718862446297002364410605932538889575185387110403381392921897463896843880158994290370834895206784595764683077936530808005034896226190751678430723486097603413102566255405706590724427432839018811520524940915908941925941616441799147043105996059579581399762915510170502608458555685663792846861422948709937177633644526902247207455022159988595345687209029887264778214048887740257014381728590310929870503185189600524464264715439643030705301414713636766758142946557851849981598413774984564875893507018369",
    "377850858294830139838638168215802093086925887126931914612239873126836129796244799562758422809309603708215849432524255419354025814001205626509561108151321750366199545761303757397664868124520798866672006744344646633049759244954763944237261894295515947951872937978674631714166544336378239483772494537238407645007249726340757921345521719083300199288008132309643236387222275304797366657103508197721167962220845749586684108873865711290056515696959158068615301851039665494059268870959118844400920356175705157687380966720889833894243511423508135705787528561412107022305915895881489894906873510821612024136018439545297419340176162703185408054988474237545125776204554493625348",
    "55760944647969803670700104936214276715083423719964045844661261136735339428078824319189106889614681158954898596838282568639485048074403495380558796018868074077602263361899920421103748234913182376058217018138234907077472583680834554738582056506298354692633634463392531299779656748976674976371384999803212355062625627460199754811512752517519048756770758692097190528272227779398068312803465029944309981139772352453094629307707229567901268616831948968968861245140912561275319789356810069135581018372862940328245978111483249017920767891515202190649900368623894983165821800561237218954689794504655471024308339716120035480157636932094372754055666489367370857400174607664955323372432165991628713",
    "16457726003670133055417812568315364738874776204650829760446867379357100901998596163189085053011218554661644549803269856525188792881047184595210714352756578973527862632628635450448100320792765888834206529527729660796488455867210791450395977508040516535191832862845015654569350215454316955118222039806597866354046383808847585182860266607616032250727426655837519195150481857532035866993409781517191410369191200376841697867377706846839050865662218445357651122690044498843915087410627989921449147376211725165424119880416167530131222904526850926162389557454850937419590150984345357942390933379521293123703350217335856872011409015949731998936109284855296846553605248986483467838110639430039905702935311346728425984",
    "9714926707998003497718782308204867881391995522576166179966726639015271734322741879515888403999270633009456307795063575324200608254150961625977536212788672358155695862400743508802658747371648724305762715776510644184132781329815716389636841942054042750187968040558731142347912905856633517520416975414903353968386986895884319388343436738813313758188795172338370156881453176133576008505649914226540367740759685387036950379555032218800307164595235996995809883572745402667053885984438870804633299529582341664408861351121721896556865893632820313720292304173565796111051950884073273595925948160869627687226894060248037636990997764710602326971142383930132194687099865887079304120122599822733051879032943082681473611650427389770073879481",
    "11469361067346228139061290587410929131617912017229616968931879358352712132692730670017732582915701188470440682798421241570649369669817366523857208399300981386889556940425121763013214087628547485306494656730035115891260512544628932970281367776688502903385877572327379171148354222095807317297941530351533647839570093829501575960261035292986369272018255979790767333074665187640092150108236079579445516397459018527194007478060544915760943720131722244888462270667390075178367774793424587459442844723497217956347252093999239384037316641861051085362381919864487699185619546779427201751377735016624998377592182535142708053692202371925948790251266234067409521984320697646766468453266999174807844568415371206966554740279907484434123667863994620867616295788084",
    "27081263142182923705501438690346729644391000994556618097884319997594440546275851690598581293011138241498216941263742768887386257721755417044788688804259686456777523551258934629081827946316506330744983439694378434274048288668616002057123700504248726599111005137073460939636100761717496712707021962566676510027297461544395209039183697769569007803026573638424565301229537767692312612739034823349449787414239341835961675930115358575277917407475478220113334514860405650606357677866220699585205914327814939292945788337768927337605491630645113053275649354853796409368920413885365648787908857425533690712373002664477203262730983426254139703971283462560168028899012842115614571845988010635474336692947735667902932669267724448985499785309811331912260886166969814393907986968451441",
    "127887649376417730093987279874959223434751978727177317678468933940178567670089011059835936855306476314055820022674203070882272006866498235564667897847245117382089387654340603395902770656741171358357134677847354180571420601614467393550918623550656945327872955722554669944877200644357783679461224972489656883740547441427281305618936723790808824641823096775897200607765224286457542213298094697818489613158537646920523503894561336356839674546741819864479496248510271493441660572431259840084209777665340391240652659473135136097045446883084078105707212339046189421949100941421327954128430953596884962081660467610278091053569098997728342746233647698373992913337394239908249503007665059415775830744926085621771276480324115145743453585347720689738234722350020203302166294597477629009148270254213517280",
    "1207864697976360344004012227247920888639870556218869352974080691964898302127728276964021939301689941990362937010553438022125875474910413432901169640664817522687207823455334075586484183617965390674062328517488830061205194043831855389128743458972541515267370102123660769648254278386638983308451584920187102324892012358662087067501815490945102835113347456386876024256245857607525525014392450842298842561085780480862959189074434916476731722039062425413389048213999283360212407096664775268828195424825259795196195694131392781507276727799638935813848554201384990724788235266234388995002182790184912720977359491307710775394369694037827284801803282839402462375626865570762358932992624686869050034093558722018928029072089221073685366742978097470229376622034123034422099304422319858140479626988138175771537761521969831437201",
    "22815919062260124281152347745317946282499934366452617323776006107241264602795533469570884875918350525205216474758129727531208112701840870980155345011181027773422852933990746300522293714126974985638485168039689385550418024968764272990769098223201120182551977096018093416278368986411387333742287512369414451842816251894030991394790236106628455873678591550918383296249145880035684864657299507214594004867992875785013148350540591071451041583313849078768261208274925233825428798625787521636329116996915481986406679365161465772333710190212707072662455444363658664104434867526067652111712295388244910679090994077323162834865184640479709762721421015631534282503359877627737619631152784447957572390295086881759199902021817549109735688232413009794162499788571838410692862747576101632805470237935435435032457070958135841741709577989566454148901444",
    "861961051643870695033992674309167199578108591679622987837512302052086356621039331592328102938527944006969148281855423551800084990342049021803998916166188572168974831943359972509780724136928175759383402721841125760716459294947775610490628574824900125739041644401488932325733698598889639802475128199627729041020774307057592344233262829078520106490200228690324177346863380651577401635338558708627761575924115623526976698616904374330016894420538755305978253349030126215039569927166132767152587499208884052990255565244775397790866949052785309330648586993446378470043418560247499529666716748099487358255406740919234377397521228466466667052177224150783607653016434502074074229063589803728318964580759649227631056344754826948147040633057356514591967427146922114501946293995982078942839207023798874794106072681931833541348794644712344619868391140591142198044497086681",
    "65127935677153380382865185934274607003810026843261289749028099882035397266927298241817812280663338302874592484963605382191929029517815698833222693542915607070266553275714496391381464772501142599806860926746646513618971592205716364184090200021765814487181840031669361985427896069354939545049469719264201514996021534340706619059408974513793777729755417309701092583457478222165086342915655696255169286054185482239523506595790508483403449664980481049058030357857517104250573057167895059024670228186104251358420028115457281328396885572060594550832075624058360805811294013609359993110765379657396709253579376411328711107823334484055480885887566502155982684909630057066748521164378750164702530401246959481173856699170629438199765921810222285786020184993912596568984417599237209783727547207010554117928212476081712087104049595278383972168871182521185128394733742058868355331729347802375328",
    "9841855377288937415447390527231202153455845092922758220238949862370951215307357850537312032339475860155968712408016460823626898669634734193056782471951119477621234174959245787176440645022541201418433927999381226748012716854141806994113738623687074026055728022039803451441963420176933414863295653601443369040100621994128949157016855602235530478271371783778599964837999796410821452366579975122909460158599665128397516750457000925545284188367509819818312672614995954226597473669410881768891599589399459286861164368425111556443211981154769056006631128654366273403403984396497518667786872761458174165192077384987013707714579844814595258260258601581922276564774352923437301971046177035365677451317202062195855147979906365571614210834242853829168695680618629448477461066172682431866417173537080652678408631229103898584370370340075955219926311960485681584387269950648473511141490698746368654708733477789568107529",
    "2974518269629418528183287790477136251735910745786981274890992938532906530868111729107068657934012028612480976341594884107864010384448541500490865233582795689734439936042424683138897599808168879614334000309507721052838815584185291954320514397429056701324964285255443219553751274822794079044766838240890836117682480710918223130904823198643091909734853753891122345761054756585255911176288018728174195207349536313414834673080480696218828470267131454399908112971840743103995767114209129238335593662867811594910126306838824574019819901335442368728398853720994383348716610307856340835297745530580152133622334220617813359080146607310450851945847134504252094656702933493785736495664926424878653684302180250888370122424378099420182931197150733885239575633998226054640324499639221170970571837196500782703006071322551989504100597618920993323538961606009303770296476041906405386457368270312607818831683956052475175065456853992908617662362164",
    "1797985968535216664944496004358374343509215681442061471412191560717902567100922783048272325884204171542595289833292525444657649015706240748603258905587228070218364321463272748372578381297752753873677472254922355241777152285815968419478586580462607181532633401390493324158696274873236811462980002924358959014961523858527582932580094707941486443910926176542073077556968436127272895058310597583607027726718736469175668307253909021323053371430188118304785898711275203434771737000724872573886880637420519724444463284443388727630283664666528052367541776313661585262983733024993681478681073098831498512514689575760815626512236554172414169581755726459092026691025970210757809328265617410698278014699792075882575574349505687630013946351950460669539772156003437151693004013771313802959350891175251984857136050528938291210156109810918641191927163139067163195482729770659833966232718210585298243545222708068057806276615307574921733035321516850527615134840300065761",
    "2173631660667039668984700210504885053440928940865456162564402194450192737785944354406149109588819094440916452691813792137523989079778661039306847441699924537987002272505065952351909044938639225469091991072478833137223773687819006461621204772108114730273468906452573994630256815525563890925741644279532588225042277283047107377981352812637499200674264712422200295447343469452316702920081857866102776356345497901140695696487346008725214312749099478128927072045696712743735290203702331838221557958853932643074387803640656981902709445151878662166871673497432912381776428661932724129079887279917188148015902271804477794216825082799097380785838031970555158952484840972551708876895207352306354118139601108599277331544048236856217944241990869613748482221644530115368470558860568500649731583579095495114437368621422163669980345062271985618577262359687190320419363115863720006906825698877493420984150753814464314638128629424645115860653443638386537575945993390222090061534723636118094400",
    "5255518873824416903687803876194048725247752904679834476906123160247588754923499095648962836677062896389080005777353515615519961786082157218832055572888104161960813075858753993204338524520606093657672316129670165486135854273027257869117232701486901401258470698179259741025577761242213513209255265386075016326500704930422917303642525563809742371542797071777422414107565426108275731906962485919752927196293165342548870477021478900400538967825706071178259031122562772885630649405409703367063847618824225741404842134016281294348855334227280096144669219910062498461347541103272529637968942509749127923247417152771655159689179823920310384408639369149430628041096138741557302442746205743962009461817743363439735661682176474418558478862493717371110180296141956513429423626802848160777461681081887783450338143596074005845010139812966205263949945983128662552765106808342325556201688032318423379767219146736065666134076960075878713420750787264139595997890269239370766654408997014349998493737638227676461278296865",
    "25414129848153344382239046897534255136864521425032321543198987907463603636933218550392121025284493890288476740344333852568984204912221236407759201838250043094916016054157811039050384830313802498917327099332219522477253430173032775561934636758466788137834217723144145907968824485104472731993407547905898541493120018409937613134760376879698500643884583858993728483460548847954890948247194125123156095375672980555831310674187654944817851083192404508910514298921974869820865701713490326851897813303945393428361416466185302188624486782702454447009759360043318904833610708468456173638563883609569148643382336489258542516560724062016770966626698695797368159233954281229324666488409424257496778134935043856989449536834116057893033303353457507584758178817698103932612119380289030912912789724315249931641899025952354394580439332837701160863679710871325897824748698596768252502179281396647786052611765866061115109191865934621489011713077601312587981937799725560613800545479627509110349431680140666459693678259767085645658970194741100548",
    "245790382051771145194669866894836910650556797257914829803716473420465193642074785106013428431872514878990588535214089805784162788716268545507631394966483389377824251794209196910779810599768510817296027140745794488967813649665678439902611015372568414560564837386564200026316322622469702182920141771993480749946980462955772899543665221584443658493203555840320515400734302189586986967099083114722544095624065532036164098694032656680024111959698488163186022307196914667272912493407206499660416052003049943320670154037880892156250480987107149816211161309922836295087659300508618824687956884820016773631401885196243741354255718836847763174171150793705155907540422343384981698066781375095240480990134676009769488251998070721441392253598523307683210522244865434657081035251703124064234955174647593539899199148117815649511423125305933498893595052867200393735244911155718851795088319566226103141215126650756014289469963426812014573525508734437947623293924381772567170842571420648049323329611314031206248968085637730764688978260892710185319163536688673706573961",
    "4754277425205284348419700021630306277819594231324229673831987127244063117828729566892466780545292931445751064132598220796049422574876174732216148557133667232462191164441022107679344784650946278308912307973277903956268576892515252911927587831450116803526252393895586426372864009992966115390852936394750781294322737294890737473525184307578815480810982000203467714611503183864749503859311439369828005557164015199013783918013720233618456348774481774753112051446414232930710030976119808826827308506073570808339673267387683023496924539170243992317384631547146462700227014797996075472403243782366190785050806379793489498063712874504188420861004661215505120695733479355193038519224515551902148437215911727990794886093643859520777829262246056577527709508106166200880046179677051280042398448534373860209884970034305287546941954518543200553070165755934934900741326454179854858073793789736601021130950282124624297415724072975890792908593463306606956627920901394037442868832942735746785658082329107022810561107464556051920197082345018451191779962866090671709877436527340920295983873675968",
    "183922199454132071495017823964418310581035406573285867942387118971767980194298669452496073046095672741192994977719446859167499481046047920511152967992507131104635352501375605724763061219686028605852686640493918295524511367033919258002837197314997473688054582719049983607925090921272907361139565610799991114899860297072476759703865254675754657490246508692183159765565344723487303603711859961323554140489731309462898309371578604489888860463103749708952933574490718753656978018783870841450820562082130138165145045826221457571999110137620197476711946929133441974930103211731301956168120310220844903461586897667281194654495842901516450393315112333639568531819418816253828855234056983083196351960519615249446261569123498616879523185925932176605436673682846349231630482429190760052935392649605114676503780181299909265803328884149516749748572347513130356923240327932454233077107245936592487285276866022784349661331916838631589627289467131249951961851344505496562865374963461086582225094977839064589597294458058553953404775061775900220028771982319110946073668250745512731634162047449025039426111927211803995865",
    "14230290926106362696122823080900243390433637603755791732106949911824080136101173014143184178281755137808174552832237606682518767799638672778692076547632370358005439458077144738842032396845315267717610617294892822173762145193043842974224805316879277778315687814683522725399979743956595259503780055472684548890238961768208807160567892770726623877644184431548999114967406368888173098282968909370845628866148259403677260385850025509467281073406163010562422645627803366939821304123828533395816659998533443169695576043444647330295513146708544008976157838105505451978776436391695567727588348599603773574802620015774104832871364395667041616614771686179713187532904193505988616414335011854214967302674800073176611175881450630432052774052983125556779718330138080292800433952456054032604266822488600945337656930977422163042584040081079715202559559706680427810729697183093076120375394553687406871735569061378091451887615270980769227439468566974482812207090169807970800161198806613558092139707938986543418066573554895535952384507580101084436098279822868443311979821043798055570372960278226673257921008509744193100971730800730506925391420852",
    "2202030863513312636321648671199054913516907653916821955870583657901629880180606920851316146337288935118727861622032224661459238388205429018685752611395723406547479819229390443492545797504661380773345416129726716459455265974513051084690663766875895512050711716295351874305222446226840039100506198384816983956044033910816772108323723191473352471490019766445555662599260829041365254451095404874525393854860088562237603696867168580981335357752085057807386342652570530409889131280895083102139900612595618883305485831671937515851727719366610960217159502965547519571213326430461021613875516598906241231892421791060695873939955883202566120966832952262431203975372419316838357685148234821833871554807736150971283740236329234471508343336380545366101483504448683820543739518493001750765645016927908145867820020571328279082021459731553008180730370556274578694992229443829530749361758523455102029960626188230296817428523359972347630927768572449727408126679518786334760290210092809432835028737236803500857663167783510149001301787146724001281345165332421763856992048047543805345657733242445022058712346111512565047505577553789906861865019392002473375004108968822887633",
    "681495543421322523798250098264197076688919625958924143870524623324155523045800434813476592642445682226654826184802698943122317776841833338092598992418663147746456667907249402037063519379241181043394719183934990602150909864499962853943798954546734361672671887789880268590454809802177762074811062436474536759599355302791778103928706524933039831760341656418460923310333097321422326655790770169714069442364061933201925383010658648887985020090047082828195983869248452906413448963793515736293648149917464339086854764215956144973338915366660813493543853568390289459916851571145319967573474741211934156923900710615862681647275208971707741861066631108678884356786881992035776409585052947098823119556147809480886651331093987482201967479673551047442695482802245485679248334227599583694833975961971137625665050598038462511431613775355717783643905026226773388597214461766172451210480389402020021519566392811355446826404040065412029215892009880106600517771803896912132143410644117696845783765338037373047653977544986212864680486485686451440775977975877670315582767354407568891763463570492892025606839060365502598578069682386408871277926851695621031183293644067480988939694506298063480784437280",
    "421825309897901792033244672821110328299858989707329623198351831257487412488334150494408358062816384341037383890227832980404741461220678261412609915977393831066701003877756508821161903070536068208635131114822767581994507882764742445246380739342818553182547915925155331364115528691522809563388981168206941607225330065103786153108176871916311445120706067211302704874795861931390169225107799497180298591712826442003609441599723740839388961730892111082517697449982498960324638396980281855454578237057403020373939942229603634141735998842082388658838322719796042537746864579992961289849549899511001649278962723352024945085436276706265598724392341910421392033971774916402350499971029677793340329156126649226991019553199138630763430518378475497218698611778946297639717590578711188776811067824689067051439712055550135303082230848037754890247653172514796418849183696052210614129285622581470276315491615583097616508138593473795306651270631441602744073414304619140211197342049963231681092472420677397706114111303040207460507387010163534918325843816587622873753721872270323771780566351683928591957477943840000397869341322941208638899271633527130479967565880350857995127838763198875305079831427134009943609689889511097649",
    "522194440706576253345876316972208990580919049498423872746826556039073936784363111767913805624652405410814719732081241372453259899769610465953650998544985761570588885297388228027224024031605389917645712482238686849850374382696024940068487090601971453157602797885922894140742111912574290384622150023438566954059414609674378500664586843661758940944355389537736955008473536688538309046200611172778929700401064225043636279276379216513660776584651486685869128560911836477979733407945587275638184736643835546830706430899815879027964494708699156615327858162669162070550631973721381397788011408835912083069923381578402765996750824350788845053399061457299376594796115026308840853616135265592537464404465489383421079888172068087880540593531143179902480849252020994692799211507956931239581512094421396636115959264040566880273454550352038397869100839214271729011388765517219855378834014619284797588465809415709001101673998496791922662152269476771965727632789007992832670675888715975905568976697604879351897631215007274284947678568308245009394733712372795492633801227226263715657397043380945358953683193593708067947501622311488022101103980147119126363144499126201376612047565500853066145133686913998486810958359950877917878445430245851063764112708",
    "1292890812885812375326210375759313154211806521142433468922887162821869801398939483488753092582940244169895415615723529137693835999168909478836520004604853756327496887791785853190175935817969787613007017072802027259003595402186993800697661464568400528012281699139347495744991446527255046611529092871296674138998156347554634956380096911385722878825122306943446316918546919191642923691382707085034138734478154231047435426838095551350329882938333268204120983684263739781589379189335962296601804776669491246984049532240711845685491900530145868474661623354280206787303545194909034204882470344686919202399217705521889202822539656812734560692344890265720007935961860978634043066823754462315724586622906572368322076593078378573258706724878413227664591775285315452095921649733003420985540281224033161079571949877521419543198682221165913014564673144326729330474079791327266883866797006364248513928735630452023998712316883707497819926672175727274797214392355511094024173454333194990105008660589406039840231914887962856846223883741599628656488592860277915422435916707302055221333097465915078656577855576505991212547407099889092520973802232030014149824651964729064239775448265753456660102258918124410545437419318058981826073574997007258786857900425313073864419946319752386233",
    "6402085214782279240215667419755299131524078858723657506895862975289688072387184202724942636448865634845362376411290892852401212244654001278874518493614983067502747915241546050757364309424213614103351721121771576319817771208871899572878663307343584498970392022461500167705150596412713025498564145875784471053079814704350338683535811375085030027987750061241476586128602964527699150059431494402589221308951443361874895410104973416993861615687357815981573643523196453166411262322669063652215755817554138450872251934892065788022574397869211263348099194622475935309330150491581437524740673066131732470626645053686294065523193267056502243594603060514277453776404649471843338432761398643420303447447392526544300501360143620577982837160675633127966355026411086588671293729638229729527350884124362822005799132185856140189806022064400645129879239247356832489836113046877006982810044078806260652871255547861936278616735457447659757370549778589309877052296555146453306216569925238186184545948010760776752863577696731293552105858614736089212602430508775892091472061274860877107264744000321017801220672792377067808866767300805984534049748959074423828986257168568315123767970931003629505434577614169221291986898163677106670280470593719009386913071875497337924524806796105577346298856278393890738258162784",
    "63403180978367415821309274946297067883877259318587871831770935303759143784889889554522281287382451910266246973649165784240949940375905696313673544571183835877544775102679330229623874187057627911328491498254666556244752237079714799807242032998034747080435083421456527343310504382222663803588392283156708348347965214509324334142435805184488402884030067350763759088085634521688221048465923014812288980135659107429338721366072771902177317331209923787647162401068528268815851417366526556579473672902061731413545507655314171848610980208852889160305234255729107360455608917522003043309019763102004826290162656178132172956263924922033921614947970445348142630509045583712683443705086720483929437220048017791473564742657116947722369162920514495227315803152463784553568865429940343244212964576831905347290417216185020746795931559459120847247675498498645959053033467354700504808682133866202321576777637699610952306621070917464876005469622251525837775124034592239768060539773673166287745392457359899369480756958601924929019139335622884917647427295587394319350269985046868723313791210440878676771219005721179901592011590792480857752380663805202941662193742633066453665435034412070612728436972875281797488541114694801898068329538488106826579312099461616252171158117928691489532617400613334275405971783862885461084050077409650222121",
    "1255829381618851745843939813162800704298382133625846842809887027840806114425442788432951756305688105625584320996766594288880648101661897268608898452842853091871430074406261051662977763444204040314446476827739540629381287732437511633979044797505653703284996755495471110325074108823829327334259719315788979865719699690209168910499796869022853983119683378442687424694484609213994214644163117423375679859361851874945135010607663312467547242079980837107518240180188095688088909845141420363857254970317996733152619312732883288975490464846158346252555673689825095381867952755172907391545035014962182630853114989372864228346210416643412819423178788931952792154650291126173981426167299265765005270386003626839058749496592516028453586356025315751374536212082378005765647052554860956305529504456848719889829131591134692949475732263074524238685056826908312615917743835792479291456258400769089722777027421482409406480004366856000575782773865389481476351927472137339199231525462720414838670174631594474762428516604475752406824356251742288326276053780533711530333448036790994099494770997810524004481984180613685777525270718904747092973861419430124617929024551387957508938994689846266901328969945717228032731721753647174747569406785196315734493280834094651426888584314870928280758447438711805507030796978914317257131734775655380315040374088457949709060323406004",
    "49748527168543236721217601181701787859412164184544981903139637413886823689926173009749595037785920888633489850813311481605150725200942772634385682961800537019407409724231335116010495734338239882288762420223511165095744676851614269111505060030202830914772171809254625804466991379578455279964765634194370893040321253131199955632614113995024839503107268683185453271511624877149186009028794740942374257976152320827283520702289642476092612689568215013410083893734947192085489303230326130694863051813599777312450947911799058630623513657322246356493268404069120290302244596009483727832254028256065346921203368387650764228811482869930619107508177823648111897705607039465400644420066304018366753528088567820681968865756929464873024598946240847282494784399930562460085398856729811420238208811850152651752608761853500956135953577192613531210110557768247940689634727322516185398423564950440789415406724110084003199382659633831856061317507339280206724017482266643331562198723476036919833153010102898515959713302712103086460575098566090065346768841886435182884860726130992566744349211440812240394669086569857277041615226621471919889719942355211112724178382788743327932844461909626480388458981536750884717896387957959548038505816970559996687017319313065634235402982764880377455013166189744092614648163441208002870528662152392858393457349994719547165568356833336692922592930108791093677121",
    "3941484395354638233538289175687367867592105475775706538454175082747236251603368256462784997091649148455366946998809240665068740057549963238341047848965838679076296559705812982932441135448614811939712643600113860470148341970566591826053013430213246554265101598505600371638196644174796391761347969938354273001501795107299950001230143854604149208783763671243543735195629086089987748497905953018321544810568341805606110449823245162286537979367516716974126102699995194153499320667076775730515741694091291363363682309356069378836394722968454458735596153575297675695696088976822315210976745126120449922477193462168610427107696654610352015863159528105808129843836325761309056043876921835464986748372647510317779813642129035884208182031129078568808486881146600901776816955427541739053504361753306065451140142565454704216189959009236952696539497194827933267863379467728084352141393853139101876405122893238481606303337295813230196517170933317260070226922872001550955906816786991421540780708064328571709273638037787506948065794383692674853711719550829095546351939467091650471946989466206787800253144476849912130133366764530496950237700273883783788535467810581022979050449183133839425991501245570487876063446858799665498721662612781183640249557225878758778467886082088153927340352344903586316649617911766321104499360124893158441628797397964835750827782235928721599081063011966538703959912871409201370874889689061760",
    "624553132445188374261017074910616651175684707033259989622425326240358320144011542099208148038451167451431700514902647991182094612618628783981105574369472406739428009809007136714553058225921794962678647770150062712169329741340380492986255026656442518371429178409580000334862736571441990986674246140792865699335750126142560573125811689357910538278846141003743210489968268151600041570954178853940648725882749987134406665272696932943861533879101499278995846852072231402899570043771700965384670432978304499197045909670750037546387967323149538975400711173599891145620098346488677369454411866360324340222789777152970538711484395999079545411339044327158327807169400718180636168954580274173073611891648389467932152813336674925480579727329789015150165985854407797204268053125510428920822155959407359562263600196189006309280656043497172517256395758191960803404150452638207990202239030220188321980089926698546009343176018217675542346175086759754685132342655920763271569764066995516289503374534409608908130909767943108219586731390753754077468746438635363230450837182856443925219852571666620481530300587151495003881755883253412188552627194665184018012770900376333616085976619651152539728779641256071708047933190779151063104030363960740539021321172497331784128697081763427053027679387359203428662165168474568024150340706402354835515387514875001532800708245730649453853973146662913949573677315948284445794972769726235954550989088166038327194939841",
    "197928788304640974341464850666479258600695049180808534143893236720551086957316991561782895711903503838312659617199847655131761668521022449864555989012015631874446585754589747562518909260670023259069319536958471520198465354731842048373873023222171792722582192051964725990900955954401448459366549745758080863086574922147403139565206738378168498096710925062068906793484169946458816934858602016140384846517427368813953275650810141982449881467020943433944463398288043606587087462038102278279333061255778743656962220698369395031741439052192865217459034931482198772374534020251547470047498884015412872036286365339241113916226197259801652689494146413056304416560197135553255323166738579115783454917663175807744664963181478476800002199479859854322683267486665302827350607612789848121755768629588114023076112282852388119573593615140664063262861889606326372759176465087547005139960226174015127321160586440204286047417005663168199250591318525255630866093314040686043735008459820241181974789900146460102681276064452613697252784678683017712816191077024853514258747314826689315347249165716727109722988882720409288376223286292825416120602544160894331904255524723403560007404728082208342668783153489098310289106335749629363553158441700848515546966661090972068991700585522607404575709118157718817843518523261561387231271221919956023896017106863850408710227866272943561453555233934401941520039173466108588491694374886570252807355915262126068581462067538865007618041416239337699844",
    "125452273648412141401139200773089339811437122262323352219553824706338070079923557409066217434882229680595996502151644090630971486259294285183183633129649272779309737174395404430149152101788835053861027104571637543627522891316511380301059965231787142333009147358563841204157993106127746328358011951843945908682559568647269686844782515956183293678683885808384414357761866799607762827058739727381391422081530702944284229892077009503570529836320239926968983078178452050828544077942799110265473616548265593766770014485779543167936514534071393018643375473912199117711676289909272033306873945015052404415032999637682634276912805986388447581835931757690057967491778984101821758663878487208247496763635588487359668638346174665417154052574051497006316330964451571627090453129541171720163384048314990787373764160610201262022979099263676893729850702083728532270947109288584340749241139094735237019397845680629336068461824057317607692281274743450322416416273792937253238782600748928299383580612411844775355999477318876111254457008444448966213113526192151409811100006061719887712487378731078450058249337327652615636078868903439786623915180978846847634714364490430396779734368064214773976667385763118747304181925067171954039707710176623935170213676028808676899130160613535644211234205271658535891310751900409184176834728722957024409233397336875992174922881569367577841678674683131358772093085604064212778055519080477496486004191899852688298187675392154348091119909214236284341881435549211816258307298573161",
};

int main()
{
    int n;
    while(scanf("%d",&n)!=EOF)
        cout<<ans[n]<<endl;
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

热门博文推荐

热门推荐

LNMP环境搭建——Nginx篇
在RHEL6.5中配置本地YUM源
Ubuntu下Zabbix安装及使用问题
MySQL双主热备问题处理
Rsync同步错误处理
Fix Elementary Boot Screen (plymouth)  After Installing Nvidia Drivers
LNMP环境搭建——MySQL篇
Shell Step by Step (3) —— Stdin & if
Shell Step by Step (4) —— Cron & Echo
LNMP环境搭建——PHP篇




            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载｜Copyright ©2011-2015, Kallen Ding, All Rights Reserved.

横论机器学习算法
摘要
主要是通过回归（discrimination learning model）来对机器学习算法建立横向连接，有助于对各类算法的理解和归类。
储备知识
从统计学角度来讲，一个信号基本上可以分为两个部分：系统性部分和随机分布，系统性部分在我看来是传达的某种规律性的信息，而随机成分就是用来对信号中不能通过规律性的东西进行把握的部分。所以，一般来讲都采用高斯分布进行建模。系统性的部分就是所谓的利用hypothesis建模得到的，而误差ee就是用来进行建模的基础，用公式化的描述为： 
y−h(x)=y−wTx：N(μ,σ)p(e)=12π−−√exp(−e22σ2)p(y|x;θ)=12π−−√exp(−（y−wTx）22σ2)
y-h(x)=y-w^Tx：N(\mu,\sigma)\\
p(e)=\frac 1 {\sqrt{2\pi}}exp(-\frac{e^2}{2\sigma^2})\\
p(y|x;\theta)=\frac 1 {\sqrt{2\pi}}exp(-\frac{{（y-w^Tx）}^2}{2\sigma^2})

上面的概率公式叫做，给定xx，以参数θ\theta的yy的概率分布。以上说明的是对一个数据集建模的部分和unmodeled effects，大部分的研究都可以从这个角度出发，通过假设建模误差的概率分布，从概率角度入手，以似然函数的最大化为目标，通过梯度下降或者牛顿方法进行迭代搜索最优。

补充：梯度下降与牛顿方法是两种非常常用的迭代优化方法，主要的思想就是通过迭代，一步一步地逼近最优解。梯度下降比较直观，沿着梯度的反方向进行搜索，属于典型的贪婪算法，迭代搜索的每一步都是当前最优的下降方向，但在全局看来可能并不是最优的下降曲线；而牛顿法则是通过分析极大和极小值处曲线的特性，通过求导，并使导数为0，构造典型的f(X)=0f(X)=0的优化形式，每一步都从该点处的切线位置与XX轴（或平面）相交的处的X作为下一次迭代的搜索位置的X坐标（对应的yy可以通过f(X)=0f(X)=0求得）。通常情况下牛顿法收敛速度比梯度下降方法要快。

对于线性回归分析，通常是利用平方误差最小化进行推导的，而它的另一种表达就是通过上面的概率解释。通过求解似然函数最大化问题，照样可以推导出平方误差函数来（cost function）。
关于“记忆”
这里主要参考从统计学角度来看深度学习（3）：记忆和核方法，有关内容只属于总结性质。 
人们通过对以往的经验或者数据的回忆来推断未来的事物，这样的过程可以用一个经常出现在最近文献中的词语——记忆来概括。机器学习模型都是由这样的‘记忆’组成的。根据机器学习模型的种类，可以分为两种主要的记忆机制，即参数型与非参数型\color{red}{参数型与非参数型}（还包括了介于两者之间的模型）。深度网络作为参数记忆型模型的代表，它将统计特性从所观察到的数据中以模型参数或者权重的方式提炼出来。而非参数模型中的典范则是核机器（以及最近邻），它们的记忆机制是存储所有数据。可以自然地认为，深度网络与核方法是两种原理不同的由数据推导结论的方法，但是实际上，我们研究出这些方法的过程却表明它们之间有着更加深远的联系以及更基本的相似性。参数型的“记忆”是通过模型的参数将数据用简洁的模型概括出来，这种形式的好处是：将数据的特性嵌入到一个hypothesis当中，扩展性良好。而非参数型的“记忆”是通过存储所有的数据来实现记忆的，比如最近邻方法，就是将观测数据存起来，当输入新的数据时，通过对比在“记忆”里与新数据的相似度，选择最相近的那个样本的输出作为其输出。 
因此“横论”主要包括两个方法：深度网络、核方法，但本质上却相互联系。
深度网络
线性模型与广义线性模型，实际上通过特征变化基函数，可以实现对特征的映射或者提取，而采用深度网络在最后一层采用线性模型，而前面的所有层可以采用非线性映射的激活函数，可以自适应的找到更好的特征，而不必进行人为地设计。即将输出层作为线性层与前面l−1l-1层分开，同时用映射函数ϕ(x;θ)\phi(x;\theta)来表示前面l−1l-1层的映射结果，同时赋予最后一层权重为ww，此模型参数空间为q={θ,w}q=\{\theta,w\}。 
利用前面预备知识中的概率模型，得到如下的表示： 
系统性部分：f=wTϕ(x;θ)　ｑ～Ｎ(0,σ2qI),随机性部分：y=f(x)+e　ｅ～N(0,σ2y)
系统性部分：f=w^T\phi(x;\theta)　ｑ～Ｎ(0,\sigma_q^2I),\\随机性部分：y=f(x)+e　ｅ～N(0,\sigma^2_y)
 
这样就可以设计似然概率，通过联合概率分布取对数后取负数得到，最小化这个负的似然函数，可以采用最大后验估计，通过BP算法获得模型参数。“记忆”就通过这个模型参数框架被保留下来。 
J(w)=12∑n=1m(yn−wTϕ(xn;θ))2+λ2wTw
J(w)={1\over2}\sum_{n=1}^m(y_n-w^T\phi(x_n;\theta))^2+{\lambda\over2}w^Tw

核方法
继续地，将上面那个目标函数，写成它的dual问题，通过对ww求导为0，得到它的对偶问题。 
w=1λ∑n=1m(yn−wTϕ(xn))ϕ(xn)w=∑n=1αnϕ(xn)=ΦTα    αn=−1λ(wTϕ(xn)−yn)
w={1\over\lambda}\sum_{n=1}^m(y_n-w^T\phi(x_n))\phi(x_n)\\
w=\sum_{n=1}\alpha_n\phi(x_n)=\Phi^T\alpha~~~~\alpha_n=-{1\over\lambda}(w^T\phi(x_n)-y_n)
 
将所有的观测值的基函数（特征）整合到了矩阵Φ(x)\Phi(x)中，将最后一层参数的解代入到损失函数中，我们就得到了由新参数α\alpha构成的对偶损失函数，以及涉及矩阵相乘的格拉姆矩阵（Gram Matrix）K=ΦΦTK=\Phi\Phi^T。重复之前的求导过程，解出对偶损失函数最小的优化参数α\alpha: 
α=(K+λIN)−1y
\alpha=(K+\lambda I_N)^{-1}y
 
这里是核方法与神经网络分道扬镳的地方，仅仅需要考虑特征ϕ(x)\phi(x)的内积K，而不是采用深度网络的非线性映射进行参数化地概括，所以可以采用核替代的方法，选择一个合适的核函数来进行计算。所以，深度网络与核方法具有很深的联系，实际上是互为对偶问题的。所以“记忆”的机制已经转变为非参数了，通过核矩阵显示地刻画了所有样本点。核方法的优势在于能更容易的获得具有我们期望性质的函数，例如具有p阶可微的函数或者周期函数，而这些性质是不太可能通过随机逼近得到的。测试数据x∗x^*的预测值也可以通过核函数的形式写出: 
f=wTMAPϕ(x∗)=αTΦ(x)ϕ(x∗)=∑nαnk(x∗,xn)=k(X,x∗)T(K+λI)−1y
f=w_{MAP}^T\phi(x^*)=\alpha^T\Phi(x)\phi(x^*)=\sum_n\alpha_nk(x^*,x_n)=k(X,x^*)^T(K+\lambda I)^{-1}y
 
这个等式是由表示定理（Representer theorem）得出的解。


2015-8-24 
艺少

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Andrew Ng机器学习课程7
回顾
通过定义训练集S={(x(i),y(i));i=1,2,...,m}S=\{(x^{(i)},y^{(i)});i=1,2,...,m\}与线性决策平面(w,b)(w,b)之间的function margin γ^\hat\gamma和geometric margin γ\gamma 、好的分类决策平面特点得到了一个最优化问题： 
max(γ,w,b)γ　s.t.　y(i)(wTx(i)+b)≥γ,　||w||=1
max_{(\gamma,w,b)}\gamma　s.t. 　 y^{(i)}(w^Tx^{(i)}+b)\geq\gamma, 　||w||=1
 
下面要介绍的就是如何解决这个最优化问题，一个思路就是将这个没有“现货”可以解决的优化问题，转变为off-the-shelf的最优化问题的形式，以便直接拿来使用。



最优化问题推导过程
约束条件中的||w||=1||w||=1是一个nasty(非凸)的目标，于是进行第一步的演变：

将最大化geometric margin转变为最大化function margin
max(γ^,w,b)γ^　s.t.　y(i)(wTx(i)+b)≥γ^,i=1,2,...,m
max_{(\hat\gamma,w,b)}\hat\gamma　s.t. 　 y^{(i)}(w^Tx^{(i)}+b)\geq\hat\gamma, i=1,2,...,m
 
虽然没有了||w||=1||w||=1的约束，但这个优化目标则变为了一个nasty（non-convex）函数，需要进行第二步的演变：
引入(w,b)(w,b)的尺度限制，使function margin γ^=1\hat\gamma=1 
考虑到最大化γ^/||w||=1/||w||\hat\gamma/||w||=1/||w||等效于最小化||w||2{||w||}^2，于是第二步演变后得到的优化问题为： 
max(γ,w,b)12||w||2　s.t.　y(i)(wTx(i)+b)≥1,i=1,2,...,m
max_{(\gamma,w,b)}\frac 1 2{||w||}^2　s.t. 　 y^{(i)}(w^Tx^{(i)}+b)\geq 1, i=1,2,...,m
 
经过两步的推导，问题转变为了一个典型的凸二次目标与线性约束的优化问题，这类问题可以通过成熟的software解决，不必深究。

虽然通过上面的推导过程能够解决并得到一个好的分类决策超平面，但是还得介绍一下Lagrange duality，通过上面优化问题的对偶形式，可以引入kernel trick得到在高维空间表现很好的optimal margin classifiers，另外，dual form将得到比上面解普通二次优化问题更加有效的方法。
Lagrange duality
1. Lagrange multiplier
考虑下面形式的优化问题： 
minw　f(w)　s.t.　hi(w)=0,　i=1,...,l.
min_w　f(w)　s.t.　h_i(w)=0, 　i=1,...,l.
 
解决方法之一就是Lagrange multipliers，定义Lagrangian为： 
L(w,β)=f(w)+sumli=1βihi(w)
L(w,\beta)=f(w)+sum_{i=1}^l\beta_ih_i(w)
 
βi\beta_i那一项叫做Lagrange multipliers。通过求解偏微分来得到对应的w、βw、\beta。

2. primal optimization problem
将如下形式的优化问题成为primal optimization问题： 
minw　f(w)　s.t.　gi(w)≤0,i=1,...,k　hi(w)=0,　i=1,...,l.
min_w　f(w)　s.t.　g_i(w)\leq 0,i=1,...,k　 h_i(w)=0, 　i=1,...,l.
 
为了解决这个问题，开始进行相关的推导：


generalized Lagrangian： 
L(w,α,β)=f(w)+sumki=1αigi(w)+sumli=1βihi(w)
L(w,\alpha,\beta)=f(w)+sum_{i=1}^k\alpha_ig_i(w)+sum_{i=1}^l\beta_ih_i(w)

objective θP(w)\theta_P(w)：

θP(w)=maxα,β:αi≥0L(w,α,β)=maxα,β:αi≥0　f(w)+sumki=1αigi(w)+sumli=1βihi(w)
\theta_P(w)=\max_{\alpha,\beta:\alpha_i\geq0}L(w,\alpha,\beta)\\
=max_{\alpha,\beta:\alpha_i\geq0}　f(w)+sum_{i=1}^k\alpha_ig_i(w)+sum_{i=1}^l\beta_ih_i(w)
 
讨论一下，如果gi(w)>0　or　hi(w)≠0g_i(w)>0 　or　h_i(w)\not=0 ，则objective就变为了无穷大，因此maximize就是为了使gi(w)、hi(w)g_i(w)、h_i(w)满足约束条件。当它们满足约束条件时，为了使objective就等于了f(w)f(w)。这里P的含义代表的是primal。


final optimization form：

minwθP(w)=minw　maxα,β:αi≥0L(w,α,β)
min_w\theta_P(w)=min_w　\max_{\alpha,\beta:\alpha_i\geq0}L(w,\alpha,\beta)


final optimal solution：

p∗=minwθP(w)
p^*=min_w\theta_P(w)

3. 对偶问题dual optimization problem

objective θD(α,β)\theta_D(\alpha,\beta)：

θD(α,β)=minwL(w,α,β)\theta_D(\alpha,\beta)=min_wL(w,\alpha,\beta) 
这里D代表的是dual。


dual optimization problem：

maxα,β:αi≥0θD(α,β)=maxα,β:αi≥0　minwL(w,α,β)max_{\alpha,\beta:\alpha_i\geq0}\theta_D(\alpha,\beta)=max_{\alpha,\beta:\alpha_i\geq0}　min_wL(w,\alpha,\beta)

dual solution：

d∗=maxα,β:αi≥0θD(w)
d^*=max_{\alpha,\beta:\alpha_i\geq0}\theta_D(w)

4. 耦合primal和dual问题
不加约束地，两者有如下形式的关系： 
d∗=maxα,β:αi≥0　minwL(w,α,β)≤minw　maxα,β:αi≥0L(w,α,β)=p∗
d^*=max_{\alpha,\beta:\alpha_i\geq0}　min_wL(w,\alpha,\beta)\leq min_w　\max_{\alpha,\beta:\alpha_i\geq0}L(w,\alpha,\beta)=p^*
 
我们期望是在满足某些条件时，令d∗=p∗d^*=p^*。而这个条件就是著名的KKT条件，这里不再详述，只是进行稍微的解释说明：f、gi(w)f、g_i(w)是凸函数，而hi(w)h_i(w)需为affine，即形如hi(w)=aTiw+bih_i(w)=a_i^Tw+b_i。同时，如果(w,α,β)(w,\alpha,\beta)满足KKT条件，它就是primal和dual问题的解。


KKT formulation

∂L(w∗,α∗,β∗)∂wi=0,i=1,...n∂L(w∗,α∗,β∗)∂βi=0,i=1,...lα∗gi(w∗)=0,i=1,...,kgi(w∗)≤0,i=1,...,kα∗≥0,i=1,.20年资深程序员编程经验分享
原文地址：http://www.devstore.cn/essay/essayInfo/1845.html


原文作者乔纳森·丹尼可(Jonathan Danylko)是一位自由职业的web架构师和程序员，编程经验已超过20年，涉足领域有电子商务、生物技术、房地产、医疗、保险和公用事业。

从11岁时，我就一直在编程，并且一直都很喜欢技术和编程。这些年来，我积累了一些艰难又容易的经验。作为一名程序员，你或许还没这些经验，但我会把它们献给那些想从中学到更多的朋友。






虽然我想我会持续更新这些经验，可能还会有更多的感想，但就我这20年来看，我想下面这个列表中基本不需要增添额外的东西了。下面就是我至今最难忘的经验：

1.估算解决问题所需要的时间。不要怕，承认吧!我曾见过一些程序员为了解决一个特殊问题而坐在显示器前面8小时。为自己定一个时间限制吧，1小时、30分钟或甚至15分钟。如果在这期间你不能解决问题，那就去寻求帮助，或到网上找答案，而不是尝试去做“超级堆码员”。

2.编程语言是一种语言，只是一种语言。随着时光推移，只要你理解了一种语言的原理，你会发现各种语言之间的相似之处 。你所选择的语言，你应该觉得“舒服”，并且能够写出有效(而且简洁)的代码。最重要的，让语言去适应项目，反之亦然。

3.不要过于注重程序的“设计模式”。有时候，写一个简单的算法，要比引入某种模式更容易。在多数情况下，程序代码应是简单易懂，甚至清洁工也能看懂。

4.经常备份代码。在我年轻时，我就有过因硬盘故障而丢了大量代码的经历，这经历很恐怖的。只要你一次没有备份，就应当像有着严格的期限，客户明天就需要。此时就该源码/版本控制软件大显身手了。

5. 承认自己并不是最顶尖的程序员 – 知不足。我常想，我对编程了解已足够多，但是总有其他人比你优秀。正所谓，“一山总比一山高”。所以，向他们看齐吧!

6.学习再学习。正如第5点所说，我经常会在手里拿一本计算机或编程相关的杂志或书(不信，可以问我的朋友)。诚然，总有很多你不知道的技术，你可以从中学习以保持不落后。如果你有一种灵巧的方式来获取你需要的新技术，那你每天都应该坚持学习。

7.永恒的变化。你对待技术/编程知识，就应像你对待股票一样：多样化。不要在某一特定技术上自我感觉良好。如果那种技术或语言已经没有足够支持，那你还不如现在就开始更新你的简历，并启动培训新计划。我能保持前行的主要原则是什么呢?至少了解两到三种语言，所以，如果某种语言过时了，你在学习新技术的时候还可以依靠另一种语言。

8.提携新人。协助并且培养初级/入门的开发人员学习优秀的编程方法和技巧。也许你还不知道，在帮助他们向更高一层前进时，你自己也在向更高一层提升，你会更加自信。

9.简化算法。代码如恶魔，在你完成编码后，应回头并且优化它。从长远来看，这里或那里一些的改进，会让后来的支持人员更加轻松。

10.编写文档。无论是Web服务的API，还是一个简单的类，你尽量编写相应文档。我曾经引以为豪的代码注释，因过度注释而有人指责。给三行代码加一行注释，只需要你几秒时间。如果那是一个比较难以理解的技术，千万别担心过多注释。如果你能很好做好自己的工作，大多数架构师、后备程序员、支持组都会感激你。

11.测试、测试再测试。我是一名黑盒测试粉丝。当你完成编码后，你“被认可”的时候就开始了。如果你们公司有QA部门，如果你的代码中有错误，那你得到的评论，会比项目经理还多。如果你不彻底测试自己的代码，那恐怕你开发的就不只是代码，可能还会声名狼藉。

12.庆祝每一次成功。我见过很多程序员在解决编程技术难题后，会和同伴握手、击掌或甚至手舞足蹈。每个人在生命中都会碰到“顿悟”。如果一个程序员高兴地跑来叫你去看他的非凡代码，也许你已经看过这样的代码100遍了，但你也应该为了这个家伙而庆祝第101次。(编者注：《庆祝成功的九种方式》。)

13.经常检查代码。在公司，你的代码要经常检查(包括自查和其他同事检查)。不要把别人的检查，看成是对代码风格的苛求。应该把它们看作是有建设性的批评。对个人来说，经常检查你的代码并且自问，“我怎样才能写得更好呢?”
 这会加速你的成长，让你成为一个更优秀的程序员。

14.回顾你的代码。在看到自己以前的代码时，通常会有两种方式：“难以至信，这代码是我写的”和“难以至信，这代码是我写的”。第一种往往是厌恶的语气，并在想如何改进它。你也许会惊叹，旧代码也能复活成为一种更好的程序，甚至是一个完整的产品。第二种通常带着惊奇和成就感。开发人员应该一到两个自己完成的项目成果，能让众人不禁而立并注目而观的项目。同样，基于你优越的编程能力，你可以把过去的程序或项目拿出来，把它们更新为更加优秀的产品或想法。

15.幽默是不可缺的。在我20年的开发生涯中，我还没有碰到哪位程序员是没有幽默感的。实际上，干我们这行，幽默是一项必备品。

16.谨防那些无所不知的程序员，不愿分享的程序员，还有经验不足的程序员。当你遇到这几种程序员时，你自己要谦虚。无所不知的程序员，更想当一个英雄而不是团队成员;保守的程序员则是在编写着他们独享的代码;而经验不足的程序员则会每十分钟就来问你一下，当代码完成后，代码已经是你的，而不是他们。

17.任何项目都不会那么简单。朋友、家人和同事曾请求我仓促做一些事情，仓促做一个程序或者网站。对于这样的事，应该从双方做计划，才能做出令双方都会满意的东西。如果某人起初只是需要一个使用
 Microsoft Access的、只有有3个页面的网站，但来就很可能变成一个有15个页面的网站，并使用SQL Server，有一个论坛，还有一个定制的CMS(内容管理系统)。

18.任何时候不要想当然。假如你承接一个简单的项目，你可能会认为某个部分可以轻松完成。千万别这样想!除非你有一个类、组件、或者一段已经写好的代码，并且在现有的项目已经测试通过。不要认为这将是很容易的。

19.从来没有已经做完的软件。曾经有一位程序员告诉我，没有软件是已经完成的，它只是“暂时完成了”。这是明智的忠告。如果客户还在使用你写的程序，并经受了时间的考验。如果有机会，你仍在更新它，这并不是什么坏事，这让你不断地前行。

20.耐心是一种美德。当客户、朋友或家庭成员用电脑的时候，他们也许会受挫，进而想砸电脑，或气冲冲地离开。我一直在告诉他们，“是你掌控电脑，不是电脑掌控你。”对于用作编程的电脑，你要有一定的耐心。一旦程序员知道问题所在后，他们就会站在电脑的角度看问题，并且说“哦，这就是为什么它是这样做。”


请问一下发博中出现的问题
利用cmd markdown编写的博文，粘贴到csdn markdown中，发博文时总是出现如下的错误信息，请问如何解决呢？



版权声明：本文为博主原创文章，未经博主允许不得转载。

程序员的三年创业之路
原文地址：http://www.devstore.cn/essay/essayInfo/511.html
在创业三年时间里作为联合创始人，虽然拿着大家均等的股份，我始终是没有什么话语权的，但是，这也给了我从旁观者的角度看清整个局面的机会。创业公司的成败绝大程度取决于技术大牛和公司 Leader，这两个人最好能在性格上形成互补，而遗憾的是我们公司是同一人。






关于决定是否创业

2012年4月，正好三年前整，在深圳能源正混的郁郁不得志的时候，大学的好兄弟找到我一起创业，他们有钱、有 idea，就是差人，当时的我还是技术菜鸟，本科学的也不是计算机，看着移动互联网蓬勃的发展羡慕不已。很快就答应了一起干，因为心里想着就算创业失败了，那也学到了技术，也不愁再去找工作。现在回想起来觉得太鲁莽了些，抱着这样的想法的程序员应该不止我一个，每个人的生活条件和家庭背景不同，对与错得由你自己来评判。

关于股份如何分配

成功的企业大多是相似的，而失败的初创公司最大可能是股权分配不合理，我们的核心团队成员最开始有四个人，Team Leader 在股份分配的问题上的意见是四人平均分，换取他掌握公司话语权。当时大家就都表示了异议，激烈的争吵了几天，谁也说服不了谁，最后不了了之，这也为后来的分崩离析埋下了伏笔。试想下，假如你确实牛逼，大家敬你服你不就完了吗，又何须用股份来换取决策权。大家能力不同，那么股份平分的缺点是什么呢?创业是一个漫长的过程，每个人付出的时间、精力和成本一定会有差异。如果不设立股权池浮动分配机制，那么问题就来了，拿着四分之一股份的
 Team Leader 觉得自己太累了，事必躬亲，心里不平衡就开始内斗了，因为我算是比较”听话和能干”，他先后挤走了所有的核心团队成员，唯独剩下了我。关于如何科学分配创始人团队间的股份，以及拿出多少股份期权池用来激励员工的问题，我这里不分析，我只讲我的经历，能不能学到什么，那就要看你了。

关于融资的问题

大多数的初创公司是很难拿到天使和风险投资的钱的，没钱该如何创业，自己出钱、众筹、做外包… 这是八仙过海各显神通的事情，我们公司算是比较幸运的，这点必须承认。Team Leader 在软件行业混了十几年，有一些人脉和资源，从创立初始就有天使和风投愿意提供大笔的启动资金，后来我从深圳回武汉，也带来了深创投的天使。可惜这些投资人通通被 Team Leader 拒绝了，理由是不缺钱。

没错，直到我现在离开了，公司也不缺钱，但是雪中送炭者少锦上添花者多，等到需要钱的时候再去找天使和风投就晚了，要么被迫签了城下之盟，要么被迫拿出了大量的股份。有了钱就能提供更好的办公环境、更好的待遇吸引优秀的员工等等好处无须赘述，而且投资人的能量往往大多远远不仅于此，他能站在不同的角度和高度看问题，他也是为你争取更大的风险资本加入的先行者和中介人。换个角度想，你拿天使和风投多一分钱，就等同于减少了潜在的竞争对手一分钱，所以在不需要钱的时候一定要多拿钱。不要舍不得出让一点你手中的股份，当创业不成功的时候，你拿着
 100% 的股份也是废纸。

关于产品是做到极致，还是快速迭代，还是同时做多个产品

第一款产品最初是做全平台的商业视频会议系统，是一款背离时代潮流的产品，我也不知道他为什么会有这样的决定。也许当时 Team Leader 是这么理解的，全国都在如火如荼的搞 App 开发，我们反其道而行之，这样就完全没有竞争对手。可是当快速产品原型出来以后，基本上没人搭理我们，无论是投资人还是客户，因为这玩意儿太扯淡了，而服务器端开发和运营成本高的惊人，根本就不是一般初创公司能够承受的了的，项目还未正式上线就搁浅了，没有认真的市场调研，没有进行技术和经济可行性的研究，甚至连潜在客户的需求都没有咨询过，就这样盲目的做了大半年开发，现在想来简直不可思议。

第二款产品是 Google Reader 宣布关闭后诞生的想法，可以理解为站在了互联网的风口，放眼全球几乎没什么大的竞争对手，因为 RSS 资讯和文献的受众用户相对小而精，有一批忠实的粉丝，但大公司又刚好瞧不上，正适合小公司一展所长，投资人也特别亲睐。这是一次极好的机会，天时地利人和，谁能尽快推出产品，就能如同秋风扫落叶般占领市场，结果由于 Team Leader 一直秉持的做到极致的做事态度，写第一代产品的代码，版本控制都已经设想到第五代如何更新和扩展了，一而再再而三的增加功能，他负责的开发客户端迟迟无法按时交付，最后产品倒是极致了，可是错过了上架的最好时机，又有什么用?

其实对于创业来说，哪一种模式都有成功的例子，但都是不可生搬硬套的，谁也不能够肯定自己的产品策略和切入点是正确的，这些都需要大量的探索和验证，当发现走了错路，必须要有壮士断腕的勇气，坚决砍掉错误功能或产品。我不是产品人，也没有花里胡哨、乱七八糟的想法，我只赞成最稳妥、最有概率成功的方式。专注于一款产品，尽快的推向市场，然后根据少部分用户的反馈，修改服务或增加功能，最后借助投资人的资金和人脉做大肆营销和推广，这就是我最认可的方式。

关于如何选择开发人员和技术

这是大多数创业者不会说的话，大家都爱说实现不成问题，说这话的人我特别反感，人类文明文化发展迄今已五千多年，如何快速、高效、经济和安全的实现一项工程是一门艺术，不是光有学问就可以的，今天的科学家们在工程实践项目上的研究停滞不前了吗?精益求精，实现恰恰是最大的问题。

我们的 Team Leader 算的上技术大牛，从美工出身后来转到 Adobe Flex 系列程序员，也懂服务器端的开发，算得上全栈程序员，精通软件设计与架构，这些都是优点。主要的缺点有两个，一是偏执，二是固步自封，也算是乔帮主极品粉丝的通病，我只是就是论事，并非要挑起帮主粉丝的骂战或者编程语言之间的战争，如有冒犯请原谅。Adobe 近年在程序界的一天比一天颓败，Flex 也早已过时了，结果 Team Leader 却坚持选用 Air 虚拟机 + AS3 + MXML + CSS 的模式开发客户端，理由是熟悉且跨平台。我承认转战其他平台学习需要成本，但早期的
 Air 虚拟机的性能简直惨不忍睹，就算是今天也是远不如 Java 虚拟机的，更不要说跟 Mono 或者 V8 引擎相比，更加不要说跟 Native App 的性能相比。最糟糕的不止如此，Adobe 不开源代码，扔个半死不活的 Air 虚拟机出来后，后续的优化和更新非常缓慢，稍微复杂一点的功能都要自己重写代码，大大加重了开发任务，再加上 Team Leader 对于产品的高标准严要求，更是使代码量成几何级数上涨，雪上加霜。

说到这里不得不举个例子，由于一直被客户端的开发拖着进度，我们服务器端的开发团队和设计师甚至抽空出来，做了好几个外包的 HTML5 网站和游戏。等到产品上架时，整个团队人心都涣散了。

总结

三年的创业时间说长不长、说短不短，一生能有这样一次经历也是可贵。现今的成功或者失败绝不仅仅只是一个人事，整个团队包括投资人都各有责任。最好不要让 Leader 一边做技术、一边做管理，人的能力是有限的，精力也是有限的。如果 Leader 找对了方向，而你坚持不懈的追随，那么你就走在了成功的路上。坚持学习，和投资人搞好关系，从上一个项目的失败中孕育下一个产品的成功，要运气，也要实力。

[置顶]
        Fighting Girl——那个IT女孩
            悄然回首，IT女孩已经走过了三年。依稀还记得三年前的我，迷茫，彷徨过，不知道我工作以后能干什么，觉得自己是一个走在大街上也不会有人注意的女孩，没有什么特长。后来在三年前的某一天突然在学校的某面墙上看到了挂在墙上的宣传，从那一天遇到了生命中最重要的一个人-米老师。
        

    想想这三年，从开始的敲着小小的demo，到现在做着越来越大，越来越跟着时代潮流的项目，从原先只会VB，到现在的Java，Android，甚至以后的IOS。想想，用我小伙伴儿的话来说，开心啊…
今年亦是我的转折点，因为工作了。。出去看了看外面的天空，外面的世界。在工作中不光是对项目的技术有了新的了解，也对为人处事有了更深的了解。。
    在学习上，这半年通过了自考毕业设计，又完成了一个PB版的系统。也意味着在不久的将来自考本科也将通过。。从最初的惧怕到现在的惊喜，IT女孩也在慢慢成长。。
    

    在计算机上，.net的基础系统让我成长，从最初对框架的懵懂到现在对框架的熟练，伴随着MVC，WCF，EF，AOP，分布式事务，反射。。。我们在一步一步的成长。。虽然还有好多欠缺，但是我们不怕，因为在缺陷中我们才能一步一步的改进，一步步的优化，一步步的成长。
    在工作中，从最开始的了解需求到熟悉框架，到现在的小娃娃逐渐长大，虽然现在还不完善，我相信在不久的将来将会降临在这个世界。
    
     因为，这里面有我们千挑万选的方案，有我们日日夜夜加班的汗水。晚上11点，小伙伴儿们还在奋战，说明我们对这个项目的重视和喜爱，因为我们从它降临一直照顾到现在。
    
    在生活上，因为出来实习了，更加感受到身边小伙伴儿对我的关照，不在我身边的朋友，给我寄来了一大堆好吃的，还有他们的嘘寒问暖。我回去的时候还热情的招待，从没有过这么温暖，出来一趟感觉值。
    
    在工作的地方，身边的小伙伴儿陪我吃遍了小馆的饭，陪我逛超市。虽然每天宿舍，吃饭，公司一条线，但是里面不乏有我们自己的温暖，在这里还认识了好多的小伙伴儿，他们非常热情，乐观，有趣，为我们的生活增添了不少趣味。有了他们在工作中也变得不平凡。

    
    外面的世界更让我们感觉到为人处事的重要性。不能顺着自己想干什么就干什么，在这里要变得成熟稳重。前段时间看到米老师在微信圈里发的“几个小技巧让我们说话充满魅力”，收益匪浅，虽然还没有完全做到，但是在尽力改变。
   （1）说话过程中保持两个基本原则，--观点对错不判断，--充分的尊重。
   （2）尽量不要使用否定性的词语。
   （3）换一个表达更易接受。
   （4）运用好你的肢体语言
   （5）情绪不好时少说话。
    这段时间学会了忍耐，即使很痛苦也要往好的方向改变，这样我们才更有魅力！
这一年出去工作了，这一年迎来了更大的蜕变。虽然过程很难受，但是我们的坚持，会迎来别人意想不到的收获。经过三年的洗礼，IT女孩慢慢成熟了。。。。
    


版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        《C程序员从校园到职场》带领大家从校园走向职场
七夕节刚过，就有好消息传来：本人新书《C程序员从校园到职场》正式出版并在各大电商平台上发售了！ 
下面，让我们一起来欣赏一下纸质书的“风采”吧。 
 
 
 
 
 
 
 

本书目录
第1章  概述
1.1  C语言的发展历史   
1.2  C语言的主要特点   
1.3  常用工具软件 
1.4  小结 
第2章  学校到职场  
2.1  认清自身不足 
2.2  破除错误观念 
2.3  工作所需软技能的培养 
2.4  小结 
第3章  程序的样式  
3.1  头文件    
3.2  源文件    
3.3  空格和空行  
3.4  大括号    
3.5  注释 
3.6  小结 
第4章  变量和函数  
4.1  数据类型   
4.2  变量及函数  
4.3  静态变量及其应用   
4.4  小结 
第5章  内存操作   
5.1  memset和memcpy  
5.2  strcat和strncat 
5.3  strcpy和strncpy 
5.4  strcmp和strncmp 
5.5  小结 
第6章  文件 
6.1  常用文件操作函数   
6.2  配置文件   
6.3  makefile文件 
6.4  小结 
第7章  指针和结构体 
7.1  简介 
7.2  示例流程   
7.3  示例程序   
7.4  程序详解和测试
7.5  小结 
第8章  算法和协议  
8.1  算法及其应用 
8.2  协议及其应用 
8.3  小结
第9章  程序重构   
9.1  重构原因   
9.2  重构原则   
9.3  重构流程   
9.4  重构示例   
9.5  小结 
第10章  SQL语句和Shell命令 
10.1  SQL语句 
10.2  Shell命令   
10.3  小结
第11章  程序问题排查    
11.1  日志    
11.2  配置项问题 
11.3  时序问题  
11.4  变量初始化问题   
11.5  数据表索引问题   
11.6  小结
参考资料    
附录A  同行评审   
附录B  我在南邮的3年

更多有关本书内容的介绍，请见我之前写的有关本书的宣传文章： 
(1)《C程序员：从校园到职场》出版预告(1)：从“高大上”到“柴米油盐” 
(2)《C程序员：从校园到职场》出版预告(2)：从“百花齐放”到“一枝独秀” 
(3)《C程序员：从校园到职场》出版预告(3)：从“阳春白雪”到“下里巴人” 
(4)《C程序员：从校园到职场》出版预告(4)：从“散兵游勇”到“正规部队” 
(5)《C程序员：从校园到职场》出版预告(5)：一种情怀，几分感悟
前辈评价
C语言的书虽然已经不少，但像本书这样，不拘泥于知识体系，而是从真实软件项目实践出发来组织内容的却一直空缺。这种身边过来人的经验之谈很多时候对不少人来说，可能比大师名作更有帮助。我相信本书会得到广大C语言程序员的欢迎，与很多从CSDN博客里走出来的著作一样，成为市场上的畅销书。
--- 刘江，CSDN总编

和作者在一家公司工作三年，却从未正式谋面，直到看了他在CSDN的博客文章，才惊感身边竟有一位“持续学习，诲人不倦”的优秀IT才俊，他不仅长期坚持通过博客分享自己的成长历程，更重要的是通过互动交流，专业问答等方式，介绍从“莘莘学子”到“IT码农”转变的技术心得，特别是结合IT行业对软件编程的实际要求，介绍软件编程规范、设计方案、管理流程等内容，对指导学生尽快进入企业，适应公司工作要求，有很好的参考价值。
互联网+时代已经到来，正如作者所说“互联网的精神就是开放，就是分享。通过互联网，我们可以认识更多的人，我们可以从他人身上学到很多东西”，也希望读者能够通过本书学有所获，顺利完成从学生到工程师的蜕变，从优秀走向卓越。
--- 罗圣美，中兴通讯首席架构师

和兆熊相识在CSDN博客。他有一种很强烈的责任感，也很善于总结，他以过来人的身份，为在校学生和职场新人送出了成长路上需要的营养。读他的技术博文，能明显感受到在工程实践中练就的严格、规范，以及对完整开发流程的重视。但他的博文，不同于一般职场人士只局限于在技术层面进行展示，他总能为学习者给出恰如其分的指导。欣闻他的积累即将成为正式的印刷品，有些迫不及待地想看到他要展现的由校园到职场的蜕变路线了。 
--- 贺利坚 ，烟台大学计算机学院副教授，《逆袭大学—传给IT学子的正能量》作者

在我所有接触过的朋友里，兆熊是无疑最适合做程序员的。黄易的小说被大家骂的狗血淋头，但其中有一句写浪翻云的话我是很认同：因为极于情，故能极于剑。从兆熊写过的这一系列文章里，抛开技术细节不论，我主要能看到的就是这种专注和执着。
--- 李智勇，《完美软件开发：方法与逻辑》作者

致谢 
自从我入职开始，我就在构思这样一本基于个人经验的技术书籍，如今，之前的这个小小的愿望得以实现了，我的内心的喜悦之情真的是无法用言语来表达。 
本书得以与广大的读者朋友们见面，我首先要感谢我的家人，是他们在背后不断地支持我、不断地鼓励我，他们为我免除了生活上的很多后顾之忧，让我能够全身心地投入到本书的写作中；其次，我要感谢人民邮电出版社的陈冀康老师和胡俊英编辑，在将博客文章整理成书的过程中，从章节标题的命名到文字的表情达意，他们都不厌其烦地给我以指导，让我能够及时地对本书的内容进行修改，让本书顺利地呈现在了读者的面前；再次，我要感谢CSDN社区，感谢阅读、评论及支持我的博客的每一个人，感谢通过各种方式与我交流的每一位朋友，你们的支持与鼓励是我坚持写作的动力！
作者联系方式 
科学技术日新月异，新的IT技术层出不穷，本书的出版只是我学习的又一个起点。 
IT行业发展到今天，软件种类繁多，不同种类的软件之间差别相当大，没有一种规范适用于所有的软件开发项目。而本书中的内容提炼于作者本人所从事的软件开发工作，因此必然会存在局限性。加之作者本人的水平有限，本书中的内容难免会有所纰漏，还请各位读者和同行海涵。对于大家针对本书提出的宝贵的意见，作者将洗耳恭听并尽量采纳。大家可以通过下面的任何一种方式表达你们的建议，作者保证会在及时给予回复。
微信公众号：zhouzxi
CSDN博客：http://blog.csdn.net/zhouzhaoxiong1227?viewmode=contents
独立博客：www.zhouzhaoxiong.com
邮箱：zhouzxi@126.com
QQ（微信）：245924426
微博：http://weibo.com/zhouzxi?topnav=1&wvr=5


本书试读章节下载

本书网购链接
京东 
亚马逊 
当当网 
china-pub 
异步社区 
文轩网
 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        沉默的阿福
前言：与其说是阿福的沉默，到不如说是我的沉默，其实我和阿福是一对好基友，作为一个26岁的程序猿，我知道阿福和我有一样的梦想，就是“改变世界！”，好像话说大了，不过管他呢，今天说的是阿福，并不是我。
我通过《喜马拉雅》电台听了一个节目，名称叫做“一个人的书房”，好像我已经不只一次的提起过这个节目，哦，我明白了，岂止一次，但是我依然乐此不疲，那证明这个节目确实做的不错！

沉默的大多数，作者 王小波，朗读者 小光。


太喜欢小光的朗读，以至于我到忘记了朗读的内容，不过既然讲到沉默，我知道，阿福肯定也是沉默的大多数中的一员，并且很贴切这个称呼，因为，每次想起阿福，他的表情就像我现在写博客一样，孜孜不倦的敲着26个英文字母，却不曾开口，并且面无表情，我想阿福的形象和我现在像极了！
阿福结婚了
记得在阿福结婚之前，别人问他，“啥时候结婚啊，阿福？”“明年吧，现在没钱结，应该说也不想结。”阿福回答。
我知道其中的缘由，拿阿福说的话来分析，很明显，“没钱”才是实情，至于说不想结，或者说明年吧，都是在搪塞自己的“穷”。
的确，阿福很穷，出生在一个务农的家庭，从小他就知道，未来都必须靠他的双手来赚取，作为农民，父母倾其所有，把能给他的都给他了。当然阿福是一个幸运的孩子，无论是之前在苏州，还是回到洛阳，似乎都能得到某一些人的赏识，日子过的并不算差，和朋友们的关系也还算融洽，虽然来往的少，这一点上，我和阿福也很像，很多时候，对于朋友们，阿福都保持沉默，因为“沉默是金”！
然而，结婚的事终究是来了，阿福在老家办了婚礼，在洛阳办了答谢宴，总算是一场事情过去了！
当然，对于结婚，阿福心怀愧疚，甚至说感到不孝，为了使阿福能够体面的结婚，父母花光了积蓄，作为农民，本来就没有多少钱，况且年初的时候还为阿福在洛阳买了房子，当然有阿福自己的积蓄，还有他的老婆！结婚、买房子都是大事，不借钱是不行的，前前后后，阿福和他老婆借了不少，阿福的父母也借了不少！
这，不至于让阿福觉得不孝，这件事，阿福不愿意多提及，但是我了解到，结婚当天，阿福的父母操碎了心，阿福的妈妈结婚前一天到结婚当天，一刻都没有休息。终究事情太多，有些事情没有操到心，而阿福竟然发起脾气，和她的妈妈吵了起来，当时看着妈妈委屈的流泪，阿福并没有良心发现。后来阿福告诉我，他觉得自己太对不起妈妈了，自己就是一个不肖子孙，阿福觉得自己做错了！
当然，对于这件事，阿福依然保持了沉默，他并没有当面向他的妈妈道歉。俗语说得好，百善孝为先，阿福记得这句话！
阿福的新事业
说是新事业，也可以说是新的工作，毕竟阿福依然是一个打工的，即使阿福挂着“总监”（总监这称号，说白了就是打杂的，程序员、扫地工、产品狗、行政 
╭︿︿︿╮  
{/ o  o /} 
 ( (oo) ) 
  ︶ ︶︶、人事猫等等都得干）的名号，但很多时候，话语权并不在阿福这里，这让他觉得想实现理想，束缚有太多太多！
老板是出钱的，而阿福名义上是出技术的。而如今，钱已经不值钱了，而技术似乎也更不值钱了！
就拿方维的众筹软件，同样一款软件，在方维官网上，起步价在9000左右，而在淘宝上，也就200左右！
我是做程序猿的，我能体会得到，同样是程序员的阿福，在这件事情上面，究竟是可怜呢，还是可怜呢？
阿福心里也曾这样打算过：找淘宝的店小二合伙，把自己的技术成果奉献出来，也卖他个百八十块钱。
但是过后，阿福告诉我，他觉得自己好下贱！
当时我沉默了，因为我也曾有阿福一样的心思，现在回想起来，苦逼的程序猿，究竟该拿什么来拯救你们！当技术从9000跌落到200，我真TMD无话可说，我能说什么呢？我自己还为了老板省钱，也去淘宝买了一份呢，买回来还辛辛苦苦的部署PHP环境，还着急火忙的修改源码，让程序尽量安稳的跑起来呢。
这样说来，我对阿福深表同情，我没敢把自己同样的经历告诉阿福，我怕，伤了他的心！阿福自认为，他的技术是他安身立命的根本，然而这样说起来，我和阿福同为天涯沦落人！
阿福的郁闷
在写这篇博客之前，我和阿福通了一次电话，阿福接到我的电话时，我吓了一跳，电话那边想起来激昂的歌声：

我已是满怀深情，归来时却空空荡荡，那故乡的云，那故乡的风，随我飘向远方！

我听过费翔唱过这首《故乡的云》，压根歌词就不是这样写的，NND，不过惊讶之余，我发现，阿福把这些乱七八糟的词组起来，再结合那深情幽怨的曲子，确实别有一番滋味在心头！
后来我了解到，阿福，对于他的出资人感到莫名的忧伤，阿福的出资人其实并不懂技术，在他眼里，技术似乎一文不值，虽然他也曾同意阿福说的“代码质量重要性”、“想要自己干出一番事业，必须是自己的原创代码，最好不要去复制别人的，虽然可以参考，但必须是我们自己开发的”等等，阿福觉得自己说的很对，出资人似乎也打心眼里认可自己，但每到一定阶段，出资人就会扰乱阿福的决定，说：“抓紧时间找别人一份代码，稍微改改，就能跑，省得自己瞎捉摸，我们自己要完整掌握这套业务，最起码要半年，然而拿别人的来参考，我觉得至少能省三月时间。。。。。。。”
这些话，阿福不想当面反驳出资人，阿福选择了沉默，阿福知道，作为中国人，沉默是一种习惯，也是一种完美的解决方案，任何问题，通过沉默，都能得到答案！
但是，在骑电动车回家的路上，阿福开始乱想了，当初自己跳槽和出资人合伙就是为了能够一展雄风，自己当家做主开发一个自己的软件，这些许日子过去，那些当初的梦想似乎都不太敢想象了！
但是阿福并没有向我吐露太多心声，在他看来，日子还得往前走，阿福希望有朝一日，洛阳也能够像“北上广”一样，有着更广阔的软件舞台。而我也知道，沉默的阿福心里面还藏有其他的想法，只是他不愿意告诉我了，当然我也不再去臆想了！
结语：人生在世，起起落落才会过得有滋有味。而阿福的沉默，也让我想起来了很多，事已至此，我也只有保持沉默！

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本站博客均为qing_gee原创文章，若您需要引用、转载，只需要注明来源及原文链接即可。

初级程序员学习网址搜集（持续更新）
下面是我在学习过程中搜集到的一些软件开发视频、编程语言、IT资讯等网址，希望能对跟我一样的初级程序猿能有所帮助。
1、视频类
    百度文库： http://wenku.baidu.com/course/list/512
    慕课网：http://www.imooc.com/course/list
    网易云课堂：http://study.163.com/find.htm#/courselist?ct=7
    51CTO学院：http://edu.51cto.com/
2、语言类
    Linux公社：http://www.linuxidc.com/
    C语言中文网：http://c.biancheng.net/cpp/
    YIGE.ORG：http://yige.org/cpp/
    Java开源网：http://javakaiyuan.com/
3、QT
    QT开源社区：http://www.qter.org/
    QT开发网：http://www.qtcn.org/bbs/i.php
    QT在线参考文档：http://www.kuqin.com/qtdocument/index.html
    QT讨论：http://www.yafeilinux.com/
    QT编程指南：https://lug.ustc.edu.cn/sites/qtguide/
4、数据库
    学习也休闲：http://www.studyofnet.com/news/list-8883.3-1-1.html
    NOSQL中文网：http://www.nosqldb.cn/
5、嵌入式
    深嵌论坛：http://www.arm8.net/forum.php?x=4309
6、资讯类
    鲜果网：http://xianguo.com/

    雷锋网：http://www.leiphone.com/
    36Kr : http://36kr.com/
    钛媒体：http://www.tmtpost.com/
    虎嗅网：http://www.huxiu.com/


7、软件类


    IT之家：http://www.ithome.com/
    异次元软件：http://www.iplaysoft.com/


8、综合类
    程序员专用导航：http://www.daocode.com/


    快客网：http://www.cricode.com/
    开源中国社区：http://www.oschina.net/

    
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

用FineReport报表系统构建资金监管平台
一、应用背景
计算机的应用已经渗透到日常工作的许多方面，无论是其自身还是所发挥的作用，计算机都标志着一种高科技，使工作高效率和高水平。为了能更方便，更轻松，更好的管理,信息化建设正在日益发展壮大，更加完善。2007年11月，财政部党组明确提出了“一体化建设”指导思想，要求做到管理一体化、业务一体化和技术一体化。近两年来，始终坚持贯彻落实一体化建设指导思想，不断加快建设步伐，信息化建设正逐步由“分散”走向“统一”，取得明显进展。
二、工具
资金监管系统采用PHP网站架构，iframe方式嵌入了，使用FinReport6.5.3版本报表软件，连接相关业务系统ORACLE数据库，制作出图形分析和报表分析，最终通过appserv访问资金监管系统。
三、数据源
资金监管系统来源数据来于相关多个业务系统ORACLE数据库。
（一）总体发放分析
FFDW表，是发放单位表，字段分为，单位代码和单位名称。



FFLX表，是发放类型表，字段分为，发放类型代码、发放类型名称、单位代码、备注。



FFXM表，是发放项目表，字段为，发放项目代码、发放项目名称、发放类型、发放单位代码、预警金额、备注、项目备注。



HM_AREA表，是单位表，字段分为，区域代码和区域名称。



HM_DATA表，是发生数据表，字段分为，ID号、部门代码、发放项目代码、身份证号、姓名、区域代码、账号、金额、日期、备注、发放日期。



RYXX表，是人员信息表，字段分为，身份证号、姓名、性别、联系地址、联系电话、状态、日期、单位代码。

（二）账务分析
Sjzw_dw表，是财务单位表，字段分为单位代码和单位名称。



Sjzw_dwkm表，是单位科目表，字段分为单位代码，科目代码，科目名称。





Sjzw_pz表，是凭证表，字段分为单位代码、凭证ID、凭证日期、凭证号、凭证类型、用途、科目代码、借方金额、贷方金额、审核员、财务主管、制单员、记账员，记账日期。 



四、需求分析
对全区资金进行资金监管，包括区、镇、街道财政和行政事业单位的所有资金收入和支出过程，银行账户资金变动状况进行实时监督、管理、分析，并通过各类图表等方式实时展示反映、预警控制和实时互动交流分析管理。
.         各类报表可以自由组合并预测
每张报表在特定的条件下可以由指定用户自由组合、定义组成相关的报表，并有多种查询方式，同时需要有预测分析功能。
.         各类报表需要有预警功能
.         每张报表都需要有预警功能，而预警值可以由用户自行定义，在预警范围内有数据为正常情况而无需做任何动作时，可以以打标记的方式让这条数据不出现在预警中。
.         各类报表的灵活性
.         每张报表的图形分析要直观明了，联动性强，数据报表需要逐层挖掘至最底层明细数据。报表的操作灵活性要强，需要可以如EXCEL一样可以随意指定对齐方式、文本数字格式、多列排序，便于所有业务管理人员操作。
（一）资金总体发放分析
资金总体发放图形分析分三块统计图，第一部分为部门发放比例，点击部委传参联动第二部分部门发放类型比例，点击发放类型传参联动第三部分部门发放类型的趋势。
资金总体发放报表分析也分为三块，第一部分是发放汇总总表，以交叉报表形式展现，横向为部门，纵向为区域，金额以部门和区域交叉显示。横向纵向每个金额都可以点击，传不同条件展现出不同数据报表。第二部分是定位查询，输入框输入信息点击查询，得到关于当前输入框内信息的报表。第三部分为预警分析报表，每张报表设置好预警值，可以查看预警信息。
（二）账务分析（资产负债表）
资产一般是按各种资产变化先后顺序逐一列在表的左方，反映单位所有的各项财产、物资、债权和权利；所有的负债和所有者权益则逐一列在表的右方。负债一般列于右上方分别反映各种长期和短期负债的项目，业主权益列在右下方，反映业主的资本和盈余。左右两方的数额相等。资产负债表在制作过程中分为2类：第一类为有规则资产负债表，取数据全部取每一个一级科目的金额，一个一个科目单列在资产负债表上；第二类为无规律资产负债表，取数据全部取每一个一级科目的金额，单个科目或多个科目相加列在资产负债表上。
五、数据分析
（一）资金总体发放分析
资金总体发放分析的内容：资金发放分析、资金发放对比分析、资金发放预警分析。
资金总体发放分析的目的：揭示单位发放每个发放类型的内涵、了解单位发放资金变动情况及变动原因、调整发放异常数据、为下一年预算做调整。
（二）账务分析(资产负债表)
资产负债表分析的内容：资产负债表水平分析、资产负债表垂直分析、资产负债表项目分析。
资产负债表分析的目的：揭示资产负债表及相关项目的内涵、了解单位财务状况的变动情况及变动原因、评价单位会计对单位收支状况的反映程度、评价单位的会计政策、修正资产负债表的数据。
六、报表制作
①传统的图形分析及报表制作方法
难点1、图形界面中无法制作中文字定位查询，输入中文字系统不识别。
难点2、图形界面中表格无法自定义合并单元格居左、居中、居右。
难点3、图形界面中统计图分析模块单独最大化，数据多时，数据紧凑无法看清楚数据。
难点4、报表中无法行列冻结显示，数据横向和纵向数据多时，向下向上无法知道当前单元格字段意思。
难点5、报表中定位查询无法在整张报表中定位查询，只能查询定位到当前页报表数据。
难点6、报表中无法屏蔽无意义数据，报表数据为零的条目屏蔽显示难；
难点7、报表中无法在线打印，只能导出EXCL再打印。
难点8、报表中数据无法自动刷新，每次只能人工手动刷新数据。
难点9、通过SQL语句查询出数据，无法再报表内自定义取数和排列，无法制作无规则报表（自定义报表）。
②利用FineReport报表工具
1、新建一个报表模板，模板内新建一个参数，在参数设计中，按钮控件事件中添加定位查询后报表超链接代码


连接FineReport报表JS脚本中添加代码：
var XM = this.options.form.getWidgetByName("XM").getValue();
window.open("/WorkSpace1/ReportServer?reportlet=[60e0][6c11]/[5d07][660e][53bf][60e0][6c11][8d44][91d1][603b][4f53][53d1][653e][5206][6790][ff08][4e2a][4eba][67e5][8be2][62a5][8868][ff09].cpt&xm="+FR.cjkEncode(XM));

如果连接第三方报表JS脚本可以修改编码转换方式。 


2、表格每一列可以任意合并单元格，居左、居中、居右，还可以调整不同格式。

3、图形分析界面模板中，每个模块都用网页框控件嵌入，如第一部分图形分析制作2份，一份嵌入在网页框控件中，另一份放大版通过超链接写在最大化图片上面。

4、报表冻结设置，文件—页面设置—其他中输入重复标题起始行和重复标题结束行，再冻结重复标题结束行打钩。

5、FineReport报表查询过滤，针对当前报表所有数据进行查询过滤，不存在无法查询过滤翻页数据。
6、报表中屏蔽无意义数据，在需要屏蔽无意义数据关键单元格中，右击条件属性，添加条件属性，增加行高属性，高度为0，输入屏蔽无意义数据条件。


7、FineReport报表含多种打印方式，其中FLASH打印模式操作最为方便简洁。



8、FineReport报表每次打开都是最新数据，打开FR报表时，实时刷新当前报表中数据集中的SQL语句，得到最新数据。
9、制作无规律资产负债表，资产负债表分2类数据资产类和负债类，新建2个数据集，一个为资产类科目借方减去贷的数据，另一个为负债科目贷方减去借方的数据。
数据集中唯一值取数用公式replace(UNIQUEARRAY(数据集名称select(字段名)),",","")如：月份、单位名称、单位负责人、财务主管、制单人、审核员都可以用此公式取数据。
资产负债表取无规律值通过用公式=MAP(符合条件的值, "数据集名称", "符合条件的列数","取值的列数")如：取科目“应收在院病人医药费”的年初数，公式输入=MAP(111,
 "科目1-5", "1", "3")，公式表示取数据集“科目1-5”中第一列值等于111对应的第三列的值。多个科目合计数可以使用公式=MAP(符合条件的值,
 "数据集名称","符合条件的列数", "取值的列数")+MAP(符合条件的值,
 "数据集名称","符合条件的列数", "取值的列数")，如：去科目“货币资金”的年初数，输入公式=MAP(101,
 "科目1-5","1", "3")+MAP(102, "科目1-5","1", "3")+MAP(109, "科目1-5","1",
 "3")，公式表示取数据集“科目1-5”第一列值等于101、102、109对应的第三列的值的合计数。

10、在报表页面设置，其他中报表设置居中对齐，设置冻结重复行，目前版本设置冻结后报表分页预览无法居中显示，通过在报表WEB属性中添加JS代码弥补此问题使用以下方法，但还存在缺陷，WEB预览报表时看不到上下滚动条和在数据量多网速慢的情况下，系统先刷新了数据在最大化，无法完成居中效果。



在报表WEB属性，分页预览报表中使用默认工具栏，添加“起始加载”在JS脚本中输入
setTimeout(‘top.moveTo(0,0)’,5);
setTimeout(‘top.resizeTo(screen.availWidth,screen.availHeight)’,5);
此脚本打开报表起最大化作用； 
再添加“加载结束”在JS脚本中输入 
varslmargin=($(‘.content-container’).width()-$(‘.pageContentDIVdiv:first-child’).width())/2
if (slmargin>0) $(‘.content-container’).css(‘margin-left’,slmargin);
此脚本弥补报表冻结后无法居中的缺陷。



七、成果展示
（一）资金总体发放图形分析

“资金总体发放分析”点击“点击查看明细表”得到“资金发放汇总表”，数据以部门横向扩展显示，以区域纵向扩展显示以交叉表形势汇总数据，横向纵向交叉金额数据可以点击，传相关条件可以得到更明细数据。

“资金发放汇总表”点击部门汇总合计金额，得到“部门资金发放汇总表”，数据以资金发放类型横向扩展显示，以区域纵向扩展显示以交叉表形势汇总数据，横向纵向交叉金额数据可以点击，传相关条件可以得到更明细数据。

“
部门资金发放汇总表”点击资金发放类型汇总合计金额，得到“资金发放类型资金发放明细表”，数据以月份横向扩展显示，区域、姓名、身份证、地址以列表纵向扩展显示以交叉表形势汇总数据。区域以分组显示，能方便查看某区域有多少人信息，报表添加了统计行数功能，能明确数量的多与少。

“资金总体发放分析”点击“10天内到期”得到符合当前报表条件报表。

“资金总体发放分析”点击“金额大于10万”得到符合当前报表条件报表。

“资金总体发放分析”点击“金额大于等于1万小于10万”得到符合当前报表条件报表。

“资金总体发放分析”点击“享受两项以上惠民政策”得到符合当前报表条件报表。


点击身份证，得到此身份证的详细明细发放数据。




（二）账务分析(资产负债表)
有规则资产负债表，同一张报表传不同单位，默认当前月日期显示数据。
有规则资产负债表单位1

有规则资产负债表单位2

无规则资产负债表（自定义报表），默认当前月日期显示数据。

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

人生重在修行
人在很多时候都是非常功利的，而这种功利心往往会使人失去耐心，被挡在浅浅的表层，而无法深入。
想每做一件事情，都能有所收获，正如期望每一天所进行的学习，都能卓有成效，能学到很多的知识技能。这实际上就是功利心在作祟。
实际上，有很多事情并不是能够在一时之间就能产生所谓的“收获”或者“功效”的，它不像你每天学会一种算法那样实在，它更像是一种内在的砥砺，一种修行，虽平淡无华，却影响深远。正如人们经常抱怨的一些没有意义的杂事一样，难道做这些所谓的“杂事儿”真的没有一点意义吗？不！我宁愿相信那是一种类似“苦其心志，劳其筋骨”的砥砺。只有经过了纷繁的杂事的洗礼，并保持耐性，心智丝毫不受到影响，依旧任劳任怨、尽力完成这些事情，这种不急不躁的性格将会影响人一辈子的发展！千万不要被所谓的“杂事”扰乱的心智而变得极度地功利化，对任何觉得对自己没有价值的事情都不乐于去做，即使去做了，还不断的发牢骚，说耽误自己的进步，反而养成了骄躁的性格，最终很可能变为高不成低不就的“志大才疏”之人。
切记！切记！
************************
2015-8-24
艺少



版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        技术人员如何提升自己的价值


        技术人员的价值被低估，这是我和朋友最近讨论比较多的一个话题。我们都认为，很多人的技术相当好，工作成果也很显著，但没有获得应有的回报。从同行的角度来看，这种现象确实很“不公平”。
但是，这种现象分明又在大量地发生着。同时，有很多技术不那么好的人，反而获得了不错的回报，所以更让人感觉“不公平”。
那么，问题到底出在哪里呢？或者说，技术人才要如何才能提升自己的价值呢？经过思考和讨论，我有了大概的结论。
如果你希望做技术的绝世高手，当然有机会获得足够好的回报，但前提是你必须成为绝世高手，同时能找到需要绝世高手的场合——这样的工作机会一般只有少数大公司才能提供。
如果你很热爱自己的工作，也乐于投入，但不奢望成为绝世高手，同样有机会创造足够多的价值，获得足够好的回报，前提是你需要注意以下几点：
第一，技术的底子要足够好。
作为技术人才，总是需要有一些硬功夫的，这是创造价值的基础所在。如果自己的技术不够好，遇到稍微困难一点的问题就束手无策。更重要的是，技术圈是讲硬功夫的，如果缺了它，很难服众，很难协调和调动其他技术人员，也就无从发挥团队的合力。如果自己的技术功底不够扎实，就更谈不上解决问题了。
第二，要能从业务的角度出发，发现技术的价值。
搞技术的人很容易陷入无谓的，绝对标准的争论里。比如哪个框架更先进，哪个算法更高效等等。这些知识当然没有错，但如果你的工作不是研究，多想想哪种技术能怎样创造更大的价值，意义往往更大一些。
比如好些年前，全文检索就不再是技术上的难题，但还没有成型的产品供大家直接使用，所以很多网站仍然使用数据库查询来实现全文检索。这时候，去研究优化检索效果所创造的价值，就不如为大家提供可用的全文检索。因为前者解决的是好和更好的问题，后者解决的是有与无的问题。
再比如，现在 NoSQL 非常热，但是 MongoDB 之类的产品仍然不够成熟，没有足够经验难以玩得转。如果单纯从软件质量考虑，采用 MongoDB 是有风险的。但是另一方面，随着电商的发展，产品的属性大大增加，这是传统的关系型数据库应对起来非常吃力的。而且，非订单数据对稳定性并没有那么高的要求。所以某些情况下，采用“不够稳定”的 NoSQL 所带来的好处是要远远大于坚守传统关系型数据库的。要发现、相信这个机会并采取行动，就需要能以业务的眼光来思考问题，挖掘出技术的价值。
第三，要重视表达。
实际上这是非常、非常重要的一点，做技术的人往往不太擅长表达，或者认为世界应该像程序一样按稳定的规矩和逻辑来运行。结果却常常出现两种情况：因为不善于表达，所以不能争取到足够多的资源和支持来做一些事情，导致出不了成绩；或者即便出了成绩，也因为不善于表达，成绩无法被其他人承认，或者被抢去了功劳。
如果大家都是做技术的，需要什么资源和支持，通常是有共识的，或者至少是容易沟通的。但如果资源的提供方不是做技术的，往往就很难理解一些“基本”问题：为什么要升级服务器，为什么要多招两个人，为什么延期一个月上线更好…… 对于这些“直觉就可以判断”的问题，外行并不能迅速理解，所以必须耐着性子，用对方能听懂的语言，以对方能接受的方式来讲解。否则，获取不到资源，最终受伤的还是自己。
当然，最可悲的是出了成绩却被埋没，或者被其他人抢去功劳的情况，这也是最普遍的让技术人才不爽的情况。大家往往会埋怨说：公司是不公平的，自己明明创造了价值，却不被认可，而其他很多公司都能公平地对待。真实的情况是，在技术驱动的公司，或者公司领导非常清楚技术的价值，这种可能“公平”会来得比较自然；而在在很多公司内，创造价值，和让人认识到自己创造了价值，二者其实是分离的。创造价值需要动脑和动手，让人知道自己创造的价值，除了需要动嘴，同样需要动脑和动手——在什么场合以什么样的方式把信息传递出来，让大家信服，这都不是单靠“嘴皮子”能解决的问题。


本文最初发表在 腾讯科技，文章内容属作者个人观点，不代表本站立场。


版权声明：本文为博主原创文章，未经博主允许不得转载。

阿里巴巴2016研发工程师笔试题

问题1：
如果下列的公式成立：78+78=123，则采用的是_______进制表示的。
本题实则考察进制转换，可以设为x进制，但是x进制有一个问题，即我们无法对x进制直接进行加减乘除，故转化为我们常见的10进制。
78=7*x+8，123=1*x2+2*x+3；然后解方程即可。答案为13进制。






问题2：

下列 java 程序输出结果为______。


int i=0;
Integer j = new Integer(0);
System.out.println(i==j);
System.out.println(j.equals(i));


本题考察的是装箱与拆箱，==比较的是值，同样equals也是比较值。故选择true,true。
equals源码如下：

    public boolean equals(Object obj) {
	if (obj instanceof Integer) {
	    return value == ((Integer)obj).intValue();
	}
	return false;
    }



输出的是：hello and cb




问题3
有关下述Java代码描述正确的选项是____。

public class TestClass {
   private static void testMethod(){
        System.out.println("testMethod");
   }
   public static void main(String[] args) {
        ((TestClass)null).testMethod();
   }
}


本题考察的是静态方法与 类&对象的关系，静态对象属于类，故不管对象是否为空，仍旧会正常运行，输出testMethod。
追问：若将方法static修饰符去掉，又是什么情况？
首先，不会是编译错误，因为符合Java对类型的检查，但是运行时会出现NullPointerException。





问题4
 袋子中分别一叠纸币，其中5元面值的纸币6张，10元面值的纸币5张，20元面值的纸币4张，从袋子中任意取4张纸币，则每种面值至少取到一张的概率为____。



一共的票数为：6+5+4=15张
总的情况数：15张选4 C(15,4)
每种面值至少取一张：可能有三种情况，5元、10元、20元是2+1+1、1+2+1、1+1+2这三种情况。
分析到这里，结果计算，得到结果为48/91




问题5


有一个扔骰子得返现的游戏：你扔一个骰子，扔到多少就可以得到和点数相同的返现。例如你扔到3，可以得到3元返现；扔到1，可以得到1元返现。当你扔完第一次骰子，看到点数后，你需要做出如下选择：




1、拿这个点数对应的返现，放弃扔第二次骰子；




2、再扔一次骰子，但此时你只能拿第二次扔的点数对应的返现。




那么，玩一轮这个游戏的期望收益是____元。




这道题实际上很简单，考察的是你扔筛子策略，点数集合为（1,2,3,4,5,6）；那么当我扔到（1,2,3）的时候证明手气较平均情况差一些，会再扔一遍，扔到（4,5,6）时证明手气较平均情况好一些，就不再扔。按照这个原则很容易求得是4.25。




问题6 
一个长度为100的循环链表，指针A和指针B都指向了链表中的同一个节点，A以步长为1向前移动，B以步长为3向前移动，一共需要同时移动多少步A和B才能再次指向同一个节点____。



本题实际上可以想象成在运动场跑道上，队员A速度是1，B为3，跑道一圈为100，则多长时间相遇一次，设为t，则：
下次相遇时，3t-t=100，t=50。


问题7


某操作系统采用分页存储管理方式，下图给出了进程A的页表结构。如果物理页的大小为512字节，那么进程A逻辑地址为0x0457（十六 进制）的变量存放在____号物理内存页中。




进程A页表：




逻辑页    物理页




0            9




1            2




2            4




3            6




4            5




5            8




0x0457写成2进制，为0000 0100 0101 0111,而512=2^9，则后9位存放页内地址，前7为为2，对应的物理页为4。


问题8
在一个100人的团队活动中，主持人小猿亮出了一幅裙子的照片，大喊：”看出蓝黑色的举手！“，团队中有45人举手，然后小猿又喊：”看出白金色的举手！“，团队中有40人举手。机灵的小猿发现，有人从未举过手，有人举手了两次，两轮举手分出的四类人的数目恰好构成一个等差数列。请问有____人既能看出蓝黑色又能看出白金色。



这题不用在纸上列公式，因为40与45都处于整数的等差数列中，相差为5（不可再分）；故公差就为5；举手两次的是考出白金色的子集，故小于40，只可能是30或者35；若为30，则均未举手的是35，单独蓝黑举手的是45-30=15，单独白金举手的是40-30=10，而30+35+15+10=90≠100；故两次都举手只可能35。




问题9
将1,2,3,......,99,100任意排列成一个圈，相邻两数的差的绝对值求和最多为____。



本题可以拿1,2,3,4做实验，发现最大的4必须和1,2相邻，最小的1必须和最大的3、4相邻。进而推广：
100必须和1,2相邻；1必须和99、100相邻；......
最后排布顺序是：1,100,2,99,3,98.......50,51。故结果为99+98+.......+1+(51-1)=5000




问题10
 已知二叉树中有45个叶节点，有25个度为1的节点，则二叉树的总结点数为____。



叶子节点45个，度为2的节点则为44个；结果等于45+25+44=114


问题11
某单链表有5个元素，设单链表的节点结构为(data,next)，5个元素的data依次为（1、2、3、4、5），已知指针q指向节点3，指针p指向节点4，那么下面操作能将链表变为data依次为（1、2、3、5）的是____。（其中temp为节点类型指针，默认指向NULL）



狸猫换太子，这题很简单，选择最后一个；将5节点的值传给需要4节点，然后在释放5节点就行；详情可参考编程之美。

问题12
 在1,2,3,.....1000中，有____个数各位乘积为0。



分为两段：
1-100，只有是10、20、.......100这10个数满足要求。
101-1000，可以分为9段，101-200、201-300........901-1000；每一段情况一样，故拿出101-200这一段，101、102、.......109这9个数满足，110、120、......200这10个数也满足。
故总数为10+9*（9+10）=181。




问题13

 A、B、C、D四人应聘一个程序员职位，此职务的要求条件是：Java熟练；懂数据库开发；会Web开发；有Ｃ++经验。谁满足的条件最多，谁就被雇用。（1）把上面四个要求条件两两组合，每个组合都恰有一人满足。同时已知（2）A和Bjava熟练（3）B和C会Web（4）C和D懂数据库（5）D有C++经验那么，被雇用的是____。
阿里经常会出这样的问题，只能大胆假设、小心求证了。
推测得：JAVA（A、B） 数据库（A、C、D） web（B、C） C++（B、D)
故选择B


问题14
 有一个单向链表队列中有一个A、B两个相邻元素，有一个指针p指向元素A，现将一个指针r指向的S元素要插入到A和B之间，该进行操作____。

r->next=p->next;p->next=r



插入节点非常简单，只需要注意先后顺序即可。




问题15

A为整数数组， N为A的数组长度，请问执行以下代码，最坏情况下的时间复杂度为____

void fun(int A[], int n) {                                                                       
    for (int i = n - 1; i >= 1; i--) {                                                          
        for (int j = 0; j < i; j++) {                                                            
            if (A[j] > A[j+1]) {                                                                
                int tmp = A[j + 1];                                                              
                A[j + 1] = A[j];
                A[j] = tmp;
         }
      }
   }
}

类似于冒泡，复杂度O(n2)




问题16
 将整数数组（7-6-3-5-4-1-2）按照堆排序的方式原地进行升序排列，请问在整个排序过程中，元素3的数组下标发生过____次改变。



考察堆排序的先后顺序，改变2次，画图分析即可。

















版权声明：本文为博主原创文章，未经博主允许不得转载。

【图像处理笔记】灰度变换
最近在学习冈萨雷斯的《数字图像处理》，想把整理的笔记和自己实现的小实验整理在博客上~


今天的主题是图像的灰度变换：
g（x，y）= T [ f（x，y）]
f（x，y）是输入图像，g（x，y）是处理后的图像，T是在点（x，y）邻域上定义的关于f 的一种算子。
T处理，从输入图像的左上角开始，以水平扫描的方式逐像素地处理。当该邻域的圆点位于图像的边界上时，部分邻域将位于图像的外部。此时，不是忽略外侧邻点，就是用0或者其他指定的灰度值填充图像的边缘。被填充的边界的厚度取决于邻域的大小。
以上的描述过程称为空间滤波，其中，邻域与预定义的操作一起称为空间滤波器（也称为空间掩模、核、模板或窗口）。


最小邻域的大小为1×1。在这种情况下，g 仅取决于点（x，y）处的灰度值f ，而T则成为一个形如下式的灰度（也称为灰度级或映射）变换函数：
S = T（r）
其中，为表达方便，另r和S分别表示变量，即g和f 在任意点（x，y）处的灰度。


例如，如果T（r）有如图所示的形式


对f 中每一个像素施以变换产生相应的g的像素的效果将比原图像有更高的对比度。这种技术被称为对比度拉伸。
极限情况下，会产生二级（二值）图


图像增强技术是面向问题的，没有通用的“理论”。


一些基本的灰度变换函数：
①图像反转
S = L - 1 - r
通俗的说，就是图像的黑边反转交换。
特别适用于增强嵌入在一幅图像的暗区域中的白色或灰色细节。
②对数变换
S = c*log（1+ r）


改变换将输入中范围较窄的低灰度值映射为输出中较宽范围的灰度值，对范围较宽的高输入灰度值映射为输出中较窄范围的灰度值。
我们一般使用这种类型的变换来扩展图像中的暗像素值，同时压缩更高灰度级的值。
反对数变换的作用与此正好相反。
对数函数的一般形状的任何曲线，都能完成图像的灰度级的扩展和压缩，但是一会介绍的幂律变换对于这个目的更为通用。
对数函数有个重要的特征，即它压缩像素值变换较大的图像的动态范围。这一特征一般被应用于傅里叶频谱中。
通常，频谱值的范围从0到10^6，甚至更高。尽管计算机能毫无疑问的处理这一范围的数字，但图像的显示系统通常不能如实地再现如此大范围的灰度值。因而，最终结果是许多重要的灰度细节在典型的傅里叶频谱的显示中丢失了。
如果我们先将这些频谱进行对数函数的对比度拉伸，再线性的缩放到新的值域，并在同一个8比特显示系统中显示频谱的结果。会看到很多丰富的细节。
③幂律（伽马）变换
S = c* r ^γ


习惯上，幂律方程中的指数被称为伽马
用于校正幂律响应现象的处理称为伽马校正
幂律变换与对数变换一样，也可以扩展和压缩一些灰度级，且应用的更为广泛。
④分段线性变换函数
优点：形式可以是任意复杂的。
缺点：技术说明要求用户输入。


上面就是关于灰度变换的一些总结。
下面我想做一个小实验，对一幅光照不均匀的图像，进行一下伽马变换的对比度拉伸，调整一下显示的亮度。
我是用VB.NET的Emgu来实现的。
这个是原图



'伽马变换的灰度拉伸
'处理光照不均匀的图像
Dim img As New Image(Of Gray, Byte)("C:\test.bmp")
Dim height As Integer = img.Height
Dim width As Integer = img.Width
Dim gama As Double = 0.4

Dim Sbigest As Integer = 0
Dim Sfewest As Integer = 255
For i = 0 To height - 1
    For j = 0 To width - 1
        If img.Data(i, j, 0) < Sfewest Then
            Sfewest = img.Data(i, j, 0)
        End If
        If img.Data(i, j, 0) > Sbigest Then
            Sbigest = img.Data(i, j, 0)
        End If
    Next
Next
For i = 0 To height - 1
    For j = 0 To width - 1
        img.Data(i, j, 0) = (img.Data(i, j, 0) ^ gama - Sfewest ^ gama) / (Sbigest ^ gama - Sfewest ^ gama) * 255
    Next
Next
img.Save("C:\test-result.bmp")

处理后的结果，其实效果还可以。只是不道为啥图片一粘贴到博客上，较深的背景就会变成绿色的了。












版权声明：本文为博主原创文章，未经博主允许不得转载。

漂亮的不像实力派--锤子新品“坚果手机”发布会
这是一篇罗永浩脑残粉的内心独白，慎点~！
一直是老罗得脑残粉，从10年高二听了他一次演讲开始，那时候他还是个英语老师，那时候的“相声”的名字都还叫“一个理想主义者的创业故事”，但从那时起便一发不可收拾的爱上了这个胖子，就再也没有落下他一场发布会、任何一条微博。
后来得知要出ROM，后来做了T1，我对便对锤子的每一个设计理念和想法赞不绝口、爱不释手。
今天出来坚果手机，面向年轻人的，虽然20号晚的谍照曝光的彻彻底底。但是对于锤粉、罗粉，老罗出来走走说两句，我们就十分安心。
发布会是8月25日，早在得知发布会时间的两周前，我便和老师说好，今晚给我放个假，今天傍晚前和小伙伴高效率的把事情做完，我说晚上任何事都不能抢占我看手机发布会的时间。
等了半多小时，老罗迟到了，期间的微信抢红包也因为罗粉的热情网站几次宕机，即时有些开玩笑似的在网上说，“老罗重新定义了7点半”等等一些玩笑话，但是对于脑残粉的我来说，这些，都不算什么。
发布会过程我就不阐述了，大家感兴趣可以去看回放视频。绝对精彩，绝对魅力四射。
在这个世界上，能让我在电脑面前振臂高呼，呐喊到热泪盈眶的，就只有老罗了。
心潮澎湃的感觉无以言表，但是我知道罗粉们都懂。
嗯嗯，老罗你发布会上说，我们都很好，是你欠我们一个成功。听到这话我差点感动到哭（妈啊太爱这个胖子了）。我！一路挺。
漂亮的不像实力派，我即将走出校园找工作，我的第一份工资，一定买你一个坚果手机。
夜深，太有感触，希望能不断强大自己，能有机会向你公司迈进！
最后老罗，还是那句老话！你负责认真，我们！帮你赢！
夜深，零碎几句，献给我的锤子和老罗，也献给最近因职业规划而导致有些迷茫的自己！哦！不再迷茫，即将彪悍。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。请多多指教~

Qt画圆
      大家知道Qt中有QGraphicsItem这个类，这是图形元素的基类。如果想实现自己的图形元素，那就要继承这个基类。


1.首先我们继承QGraphicsItem，画自己的圆。
 MyItem.h

class MyItem : public QGraphicsItem
{

public:
    MyItem(double radius, double Radius);
    ~MyItem();
    QRectF boundingRect() const;
    void paint(QPainter *painter,const QStyleOptionGraphicsItem *option,QWidget *widget);

protected:
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);//实现圆的拖拽效果
    void mouseDoubleClickEvent (QGraphicsSceneMouseEvent *event);//处理鼠标双击事件

private:
    double m_radius;
    double m_Radius;

    bool m_colorFlag;//true:red, flase:black

};
MyItem.cpp


MyItem::MyItem(double radius, double Radius)
{
    m_colorFlag = true;
    m_radius = radius;
    m_Radius = Radius;
    setFlags(ItemIsSelectable | ItemIsMovable);
}

MyItem::~MyItem()
{

}

QRectF MyItem::boundingRect() const
{
    return QRectF(-m_radius, -m_radius,
                  2*m_radius, 2*m_radius);
}

void MyItem::paint(QPainter *painter,const QStyleOptionGraphicsItem *option,QWidget *widget)
{
    if(m_colorFlag)
        painter->setBrush(Qt::blue);
    else
        painter->setBrush(Qt::red);

    painter->drawEllipse(QPointF(0, 0), m_radius, m_radius);

}

void MyItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    qreal x = pos().x();
    qreal y = pos().y();
    double D = m_Radius - m_radius - 2;

    // limit circle position
    if(x*x + y*y >D*D)
    {
        double tmpX = x*D/sqrt(x*x + y*y);
        double tmpY = y*D/sqrt(x*x + y*y);

        setPos(tmpX, tmpY);
    }

    QGraphicsItem::mouseReleaseEvent(event);
}

void MyItem::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event)
{
    m_colorFlag = !m_colorFlag;
    QGraphicsItem::mouseDoubleClickEvent(event);
    update();
}

2.创建一个画布，在画布上添加圆，最后用一个View来管理画布。
MainWindow.cpp

#define RADIUS 100

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    //m_scene = new QGraphicsScene();
    //m_scene = new QGraphicsScene(-50, -50, 100, 100);
    m_scene = new QGraphicsScene(-100, -100, 200, 200);

    m_scene->addEllipse(-100, -100, 200, 200);

    m_steelNum = ui->spinBox->value();

    MyItem* item = new MyItem(25, RADIUS);
    item->setPos(0, 0);
    m_scene->addItem(item);
    QGraphicsView *view = new QGraphicsView(m_scene);

    view->show();

    ui->verticalLayout->addWidget(view);

}

MainWindow::~MainWindow()
{
    delete ui;
}
附上效果图（小圆双击会变颜色）：



源码下载地址1：https://github.com/RobinsonSir/QtDrawCircle.git 

源码下载地址2：http://download.csdn.net/detail/zbc415766331/9043567














Qt坐标系参考文献：http://doc.qt.io/qt-4.8/graphicsview.html#the-graphics-view-coordinate-system

版权声明：本文为博主原创文章，未经博主允许不得转载。

Hadoop(二)——分布式集群搭建
   前两天和一个朋友在聊天的时候说，很多自学Hadoop的朋友80%都会夭折在集群环境的搭建上，原因吗无在乎：1，没有很好的电脑配置，不能像机房一样用多台电脑搭建起集群；2，对linux的不熟悉，各种小黑窗，linux命令……；3，环境搭建的反锁步骤，需要耐心+细心+认真等等吧。不过吗，我觉的，只要敢于坚持，敢于付出都是会成功的。下边讲述一下我的Hadoop集群搭建过程，由于条件有限，也是在虚拟机中进行的。    一，准备资料：    1，一台笔记本：I5的CPU，4G内存，500硬盘（内存有些小，运行的时候比较卡）；    2，虚拟机一台：VMware-workstation-full-11.1.2.61471.1437365244.exe 在百度一搜即可；    3，linux系统软件：我用的是ubuntu-12.04.4-server-amd64.iso，是server版本的，初学者也可以也可以下载Desktoop版本，有类似Windows的界面，更容易操作。可到ubuntu官网上下载：http://www.ubuntu.com/download/server    4，Hadoop软件：hadoop-1.2.1-bin.tar.gz  可以到官网上进行下载：http://hadoop.apache.org/    5，JDK软件：jdk-8u51-linux-x64.tar.gz 这个相对来说比较简单，我用的是版本8的。其实JDK，Hadoop还有用到的其它软件，我们可以通过linux命令：apt-get update   apt-get 软件的下载路劲，直接在linux上进行下载。     二，搭建步骤：先看一张总体要完成工作的步骤图：    1，安装虚拟机VmWare：百度一下下载下来，很容易安装，不再赘述。VmWare为我们提供了一个虚拟的平台，我们可以在这个平台上安装多个不同的系统，进行学习实验。              2，在VmWare上安装三台相同的linux系统，我安装的ubuntu，过程不再赘述，大家可以根据这个教程进行安装：http://jingyan.baidu.com/article/0320e2c1ef9f6c1b87507bf6.html。这里需要注意的是，a:大家在网络选择的时候，用桥接模式，更加方便，会自动分配ip，如下图；b:系统名字可以根据自己的习惯进行起名，例如：master,slaveone,slavetwo等。好，开是下边的四个步骤：    2.1，设置SSH连接：    我这里是通过SecureCRTPortable.exe和SecureFXPortable.exe两个软件进行连接的。当然还有Putty等其它软件。有时候linux没有安装ssh服务，需要我们进行安装一下：安装ssh-serversudo apt-get updatesudoapt-get install openssh-server安装ssh-clientsudoapt-get install openssh-client查看ssh是否安装好，下边及已经安装。    然后就可以通过SecureCRTPortable.exe进行连接linux，很简单，看这个图文教程：http://jingyan.baidu.com/article/17bd8e523cfb9285aa2bb872.html     2.2，配置hosts文件，其实就是为了方便，我们平时输入www.baidu.com，进入百度，其实是映射了一个具体的地址，这里配置hosts文件，就是将各个节点机器的ip与一个名字映射起来，我们连接时直接使用名字即可，利用VI命令修改host文件（VI编辑命令：http://blog.csdn.net/liujiahan629629/article/details/47803261）：     vi   /etc/hosts    2.3，建立Hadoop账户，三台节点的账户都建成一样的，方便后边的免密码登录：sudogroupadd hadoop    //设置hadoop用户组sudo useradd –s /bin/bash –d /home/ljh –m ljh –g hadoop –Groot   //添加一个ljh用户，此用户属于hadoop用户组，且具有root权限。sudo passwd ljh  //设置用户ljh登录密码su ljh   //切换到ljh用户中     2.4，设置免密码登录，其实就是一种算法RSA，将彼此的公钥放在要放在要访问的电脑上，自己保存私钥，保存好不用再进行输入密码验证。说通俗一点就是将本电脑的信息和密码已经保存到要访问的电脑上，直接访问即可。    a,在每台电脑上进行SSH公钥私钥的生成：id_rsa为私钥，id_rsa.pub为公钥    b,分发公钥，将公钥分发到每一个节点上，包括自己本身,我的authorized_keys包括三个节点的公钥。通过下边命令：    scp ./id_rsa.publjh@slaveone02:/home/ljh/.ssh/authorized_keys    每台电脑都这样操作，这样我们三个节点就可以相互之间进行免密码登录了。     3，JDK安装：这个相对来说比较简单：看这个链接即可：http://www.cnblogs.com/plinx/archive/2013/06/01/3113106.html     4，Hadoop安装，其实这里就简单多了，主要是配置文件配置：    4.1下载安装，将下载好的hadoop，进行tar解压即可，放到/home/ljh/下边即可。    4.2配置Hadoop-env.sh文件，即环境文件，可以这样理解，主要配置JDK的home路径，配置文件都放在conf文件中：   4,3配置masters,slaves 文件：     masters文件：     slaves文件：   4.4，配置namenode,修改各种site文件：      core-site.xml文件：     hdfs-site.xml文件：     Mapred-site.xml文件：    这样基本配置就算结束了，可以向各个节点进行hadoop的copy了。    4.5向各个节点复制Hadoop,各个节点的linux配置要是一样的，利用linux命令进行复制：       Scp -r ./hadoop-1.2.1  slaveone02:/home/ljh     4.6,格式化namenode:        ./bin/hadoopnamenode -format     4.7启动Hadoop:利用bin下的star-all.sh即可    4.8，用Jvm的Jps进行进行的检查：     master中的进程：     slave中的进程：     最后我们可以通过浏览器输入网页进行查看Hadoop的启动状态：    至此，Hadoop三个节点的集群环境正式搭建完毕，从这个基础上不断学习Hadoop吧。感觉搭建Hadoop的重点是对linux的操作熟练与否，所以还得不断的熟练linux。

版权声明：本文为博主原创文章，未经博主允许不得转载。

2015-8-25股市大跌
当15年第一次A股下跌6%的时候，我看了07年的那波，发现，单日跌这样不可怕，可怕的是单日跌幅这么大后的两个星期内，又有跌幅达4％的单日跌幅。
不幸言中，当然，对于我自己来说，关键的是，我有这样的想法，就要贯彻某些现象出现后，坚决执行纪律，开始减仓和清仓。在股市中，有纪律才能有可能说得上是投资而非赌博。
到今天为止，沪深两市都跌破15年的数值，沪市跌穿3000心理支撑位，甚至跌穿的时候都没有挣扎一下；创业板指跌穿2000点。真系牛转熊的时候不要碰创业板，不要碰B类基金，跌得非常恐怖。
我是看空后市的，为什么呢？


哇塞，这个这么不靠谱的分析都能 出来，其实还是有点靠谱的，因为从人性的角度出发，从我自己身边看到的例子归纳而来的。不过，样本容量太少而且分布不均匀。
－－－－－－－－－－－－－－－－－－
仅用来纪念A股跌得如此之惨烈！

版权声明：本文为博主原创文章，未经博主允许不得转载。

黎明前的黑暗-->屋漏偏逢连夜雨
  1，          大奇迹日 --> 日K线分析 低开100个点，收盘跌300个点，千股跌停，大盘指数9%跌幅，创历史记录。各种破线：攻击线向下穿越，破操盘线攻击线向下穿越，破生命线攻击线向下穿越，破决策线攻击线向下穿越，破趋势线攻击线向下穿越，破年线啥都破了，一破到底…… 攻击线 都破了，熊市无下限，被套的持股持币观望吧，割也割不动了。  2，从GDP经济总量和530分析，给我们的希望2008年 GDP为316752亿元, 牛市转到熊市最后大跌到1664点，2014年 GDP为636463亿元，是08年gdp的2倍，所以大盘最终会跌倒应该是08年的2倍左右，应该是3200左右。这是根据技术分析以及市场经济总量估算出来的，因为已经跌无可跌了，再跌跌不下去了，所以大家不用担心的啊，接下来就是震荡震荡，然后熊市横盘了。  当然这里除非国家队蓝筹股故意砸盘砸到2000多点不然正常再跌也没有办法去跌了。从08年到14年，gdp疯狂增长，但是股市一直处于价值低点，这很不正常 。 按照以往经济总量gdp和熊市最低点的技术线条分析一看，3200是正常的最低点了，除非国家经济大滑坡，像日本那样，gdp倒退引发股市动荡，不然差不多了这个最低价了，这是我们的底线了。 拿天津港来说，今天的成交量大于前2天，而且买盘多余卖盘，表明今天很多人抄底天津港，所以大家对天津港还是很有信心的。 我相信我的判断，股市无神迹，股市无股神，一切的分析判断都要以事实作为依据，明天会在3100到3200之间横盘 只是亲们，你们还有子弹吗？你们还有仓位补仓吗？你们还有可用资金抄底吗？   3，30分钟线给我们最后的希望MACD线：绿柱子越来短，表明看空的趋势越来越弱，市场往有利方向发展。 KDJ线：尾盘J线在地板上调头往往上攻，接近KD线，三线纠缠在一起，表明前期趋势不明朗。  DMI线，di1线在50以下弱势区域往上接近di2线，看空趋势慢慢变弱，而adx和adxr也从50以上的高位往下突破接近50线上，表明多空双方慢慢持平了。 MTMTM：MTM在0下面的弱势区域往上攻破MTMTM，看空的力量在减弱。 MAVOL线：MAVOL5慢慢往上攻，而MAVOL10线持平往前水平发展，表明成交量持续放大，但是还处于弱势当中，后期趋势慢慢好转中。 总结：5大技术指标中，基本表示行情从狂跌中慢慢恢复过来，明天大盘走势低开横盘中，可能收一根小阳线或者十字星或者小阴线，如果国家队蓝筹股出手的话或许会收一根大阳线也说不准呢。   4，      自己操作总结今天在跌停板补仓天津港和新赛股份，天津港是准备做长线的，新赛股份是赌国企改革的，今天大奇迹日我补仓是因为我预测分析已经基本到这个波段的低点了，可以补仓了。 到目前为止，已经算是重仓了。 股市的第一操作原则：保住本金，不全仓。 股市的第二操作原则：别人恐惧我贪婪，别人贪婪我恐惧。今天大奇迹日，大家恐惧割肉的时候，你敢逆流而上补仓吗？

版权声明：本文为博主原创文章，未经博主允许不得转载。

P1193扫雷 (DP状态压缩)

P1193扫雷
Accepted


标签：[显示标签]













描述

相信大家都玩过扫雷的游戏。那是在一个n*n的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了，“余”任过流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字表示和他8连通的格子里面雷的数目。现在棋盘是n*2的，第一列里某些格子是雷，而第二列没有雷，如：
o 1
* 2
* 3
* 2
o 2
* 2
* 2 ('*'代表有雷，'o'代表无雷)
由于第一类的雷有可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息求第一列雷有多少中摆放方案。




格式

输入格式

第一行为N，第二行有N个数，依次为第二列的格子中的数。（1<=N<=10000）

输出格式

一个数，即第一列中雷的摆放方案数。





样例1

样例输入1[复制]




2
1 1

样例输出1[复制]




2





限制

1s




来源

NOIP2006夏令营
设置DP[i][j]表示第几个数他所覆盖的三个格子（j的二进制中的1代表放了雷）
所以dp[n][i] = dp[n - 1][j] {(i
 &3)  == ((j & 6) >> 1)}
注意一下，一定要把包给去掉，否则会WA得很惨
（提示：状态压缩的题目一般会转换为二进制进行处理，当然可以直接加长数组，但是却是不方便）


//package ds;

import java.util.*;
import java.math.*;
import java.io.*;

public class Main{
	static Scanner cin;
	static PrintStream cout;
	static int MAXN = (int)1E4 + 5; 
	static int [] mp = new int[MAXN];
	static int [][] dp = new int[MAXN][10];
	static int Bit_Count(int val){
		int ret = 0;
		while(val > 0){
			val &= (val - 1);
			ret ++;
		}
		return ret;
	}
	public static void main(String [] agrs)
	throws IOException
	{
		cin = new Scanner(new BufferedInputStream(System.in));
		cout = new PrintStream(System.out);
		while(cin.hasNext()){
			int N = cin.nextInt();
			for(int i = 1;i <= N; i ++){
				mp[i] = cin.nextInt();
			}
			for(int i = 0;i <= N + 1;i ++){
				Arrays.fill(dp[i], 0);
			}
			if(mp[1] == 0){
				dp[1][0] = 1;
			}
			else if(mp[1] == 1){
				dp[1][2 << 1] = 1;
				dp[1][1 << 1] = 1;
			}
			else if(mp[1] == 2){
				dp[1][3 << 1] = 1;
			}
			for(int i = 2;i <= N ;i ++){
				for(int j = 0;j <= 7;j ++){
					for(int k = 0;k <= 7;k ++){
						int c = (j & 3);
						if(c == (k >> 1) && Bit_Count(j) == mp[i]){
							dp[i][j]  += dp[i - 1][k];
						}
					}
				}
			}
			int ans = 0;
			for(int k = 0;k <= 3;k ++){
				if(Bit_Count(k) == mp[N])
				ans += dp[N][k];
			}
			cout.println(ans);
		}
	}
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

Win  10免费升级正在进行中（+ing)

          7月29日，微软CEO纳德拉果断地按下免费升级到Win10的启动按钮，从此，全球进入漫长的Win10升级的征途之中（...ing）。现在的情况如何？用户欢迎吗？喜欢什么特性？



近日，成立于2005年的英国社交媒体研究公司BrandWatch公布了一份调查报告，发现广大的计算机用户喜欢Win10操作系统，其中特别“love”系统捆绑的个人助理Cortana。请见文章：Windows
 10 users “love” Cortana and Edge browser: study。



该文说得很明，绝大部分的用户都说Cortana的”好话“，说”坏话“的人不多。这是升级Win10长久的推动力，不管你自己愿意不愿意。



微软新一代CEO纳德拉笃信人工智能产品（比如Cortana），借此提高全球个人生产力。我们目前正处在这一历史大变革之中，只是”浑然不觉“而已。



老实说，Win10新一代操作系统正在把我们带入到人造智慧的世界之中。在日常生活与工作中，我们有事问问Cortana“小帮手”（相关个人隐私数据都存储在用户的本地硬盘之中,，这是可选项），这有什么不好的呢？为什么要禁止Win10？根本没有道理！



袁萌8月25日




版权声明：本文为博主原创文章，未经博主允许不得转载。

微软笑了
          8月24日，微软个人助理Cortana悄悄地爬到安卓肩膀上（在美国境内进行公测），此事有何意义？



根据市场调研公司Gartner的数据，在今年第二季度，微软智能手机在全球市场上只占2.5%的市场份额，微不足道也。而安卓手机占有82%的市场份额，苹果手机占有14.6%市场份额。微软此举的意义，由此可见。



大家知道，安卓系统的内核就是Linux，准确地说，是GNU/Linux。在某种意义上说，在全球移动市场上，现在是GNU/Linux的天下，微软输的很惨。



实现微软的“视窗即服务”的战略，“Cortana帮助人类拯救世界”，微软必须把个人助理Cortana移植到GNU/Linux内核之上。我们由此不难想象，微软借助巨大无比的云计算数据中心（Azure中心）向全球计算机用户不断推出“个性化”服务“（即Cortana）的情景。Cortana个人助理是微软纳德拉的宠儿。



实际情况是，这次微软个人助理安卓版的发布，在美国业内引起很大的轰动，而在我国业界，一切都很平静，似乎这是无所谓的事情。



微软此举（战略行动）表明了公司对”服务为王“的业务转型必胜的自信心，当然值得一笑了。



袁萌 8月27日




版权声明：本文为博主原创文章，未经博主允许不得转载。

unity Kinect v2 with MS-SDK20绿屏抠像shader修改 透明背景
用的是kinect2.0

 Kinect v2 with MS-SDK20插件
例子中的默认greenscreen里面是绿色的,要求改成透明的,下面直接上代码
改完后放背景看看吧 是不是透明了

Shader "DX11/GreenScreenShader" {
 SubShader {
 //透明就需要这个
  Blend SrcAlpha OneMinusSrcAlpha
 Tags {"Queue"="AlphaTest" }
 
 
 Pass {
 
 CGPROGRAM
 #pragma target 5.0
 
 #pragma vertex vert
 #pragma fragment frag
 
 #include "UnityCG.cginc"
 
 Texture2D _MainTex;
 
 sampler SampleType;
 
 struct vs_input {
     float4 pos : POSITION;
     float2 tex : TEXCOORD0;
 };
 
 StructuredBuffer<float2> depthCoordinates;
 StructuredBuffer<float> bodyIndexBuffer;
 
 struct ps_input {
     float4 pos : SV_POSITION;
     float2 tex : TEXCOORD0;
 };
 
 ps_input vert (vs_input v)
 {
     ps_input o;
     o.pos = mul (UNITY_MATRIX_MVP, v.pos);
     o.tex = v.tex;
     // Flip x texture coordinate to mimic mirror.
     o.tex.x = 1 - v.tex.x;
     return o;
 }
 
 float4 frag (ps_input i, in uint id : SV_InstanceID) :COLOR
 {
     float4 o;
     
     int colorWidth = (int)(i.tex.x * (float)1920);
     int colorHeight = (int)(i.tex.y * (float)1080);
     int colorIndex = (int)(colorWidth + colorHeight * (float)1920);
     
     o = float4(0, 0, 0, 0);  //<-- Here I set alpha to zero in my version 
                              // to feed into Transparent/cutout/diffuse
     
     if ((!isinf(depthCoordinates[colorIndex].x) && !isnan(depthCoordinates[colorIndex].x) && depthCoordinates[colorIndex].x != 0) || 
         !isinf(depthCoordinates[colorIndex].y) && !isnan(depthCoordinates[colorIndex].y) && depthCoordinates[colorIndex].y != 0)
     {
         // We have valid depth data coordinates from our coordinate mapper.  Find player mask from corresponding depth points.
         float player = bodyIndexBuffer[(int)depthCoordinates[colorIndex].x + (int)(depthCoordinates[colorIndex].y * 512)];
         if (player != 255)
         {
             o = _MainTex.Sample(SampleType, i.tex);
         }else o.a = o.rgb; 
     }
      
      
//    float4 sampler2[9];
//    float4 minValue = float4(255,255,255,255);
//    for (int i = 0; i < 9; ++i)
//    {
        //sampler2[i] = texture2D(SampleType, gl_TexCoord[0].st + tc_offset[i]);
        //minValue = min(minValue, sampler2[i]);
//    }
     return o;
 }

 ENDCG
 
 }
 }
 
 Fallback Off
} 


版权声明：本文为博主原创文章，未经博主允许不得转载。

跳格子问题——阿里笔试
有1,2,3,......无穷个格子，你从1号格子出发，每次1/2概率向前跳一格，1/2概率向前跳两格，走到格子编号为4的倍数时结束，结束时期望走的步数为____。


2
12/5
14/5
16/5
18/5
4


这个问题，很显然考察的是递归问题：
定义step(i,j)为第i号格子带第j号格子的期望值；
step(1,4)为从第一格跳到第四格的期望，要到第四格，则只能先到第二格（期望0.5*（step(1,2)+1)）或者是第三格（期望0.5*（step(1,3)+1)）；其中1表示到达第2格或者第3个之后，跳到第4格还需要1步。
故有
step(1,4)=0.5*（step(1,2)+1)+0.5*（step(1,3)+1)=1+0.5*(step(1,2)+step(1,3))
同理有
step(1,3)=1+0.5*step(1,1)+0.5*step(1,2)
step(1,2)=1+0.5*step(1,1)+0.5*step(1,4)
step(1,1)=0
联立方程，得到
step(1,4)期望为18/5，选E。


也可以用计算机求概率，如：
/**
 *  项目名称：
 *  文件说明：
 *  主要特点：
 *  版本号：1.0
 *  制作人：lcx
 *  创建时间：2015-8-25
 **/

/**
 * @author lcx
 *
 */
public class PaceTest {
	
	static Random rand=new Random();
	public static int pace()
	{
		return (int) (rand.nextDouble()*2+1);
	}

	public static void main(String[] args) {
		double sum=0;
		int times=10000;//实验10000次
		for(int i=0;i<times;i++)
		{
			int index=1;
			int pace=0;
			while(index%4!=0)
			{
				index+=pace();
				pace++;
			}
			sum+=pace;
		}
		System.out.println("期望值为: "+sum/times);
	}
}

追问1，若本题是从2开始，则期望多少？

同样的方法：
step(2,4)=1+0.5*step(3,4)
step(2,3)=0.5+0.5*(1+step(2,1))
step(2,1)=1+0.5*step(2,3)+0.5*step(2,4)
step(2,2)=0
最终求出
step(2,4)=12/5


追问2，若本题是3的倍数就停止，则期望为多少？
同样方法计算，期望值为2。


本题归根到底是利用递归思想。类似的题目还有青蛙跳问题、摆瓷砖问题（编程之美）等。







版权声明：本文为博主原创文章，未经博主允许不得转载。

php动态调用函数方法&&非关系数据库的优势

php动态调用函数方法，第一反应就是魔术函数带下划线的函数，__autoload,__struct,__get,__set等函数。
        其实php提供call_user_func()call_user_func_array()， 可以动态的调用函数。在实现MVC机制的时候，当路由器完成动态路由之后，就会解析后动态的调用对应的Controller方法。call_user_func 跟call_user_func_array差不多，只是array函数，是将函数的参数作为数组传递进来。而call_user_func是在调用的函数后面，直接将参数给带进去。
     检查一个ip地址的合法性，第一反映就是，根据ip地址，利用explode函数将ip进行分割，拿到第一个元素与255进行大小比较，判断是否是是ip的合法地址。
     其实合理的判断方法，应该是利用ip2long这个函数进行判断。因为ip2long如果解析到错误的ip地址，会返回false。同理类推，可以将得到的ini类型的ip地址，给定的ip范围作对比，从而进行ip地址限制。
      当线上一张表数据量巨大的时候，同时需要对这张表进行字段更新时候。有什么好的办法？
      第一反应，启用备份数据表。然后对数据表进行更新，再将数据导入更新好的数据表结构的表中。
      这个暂时没有想到关系型数据库，mysql特别好的实现方法，不过启用非关系型数据库nosql，mongodb甚至是redis的话，就没有表结构限制这个概念。自然对表字段进行更新，不需要停止线上应用。而redis本身就是key-value类型，没有表这个概念的话，对字段的增删改都不会影响线上应用的使用。

版权声明：本文为博主原创文章，未经博主允许不得转载。

第1篇，移动互联网究竟是何方神圣还是一个妖魔鬼怪？
移动互联网成为当今最热门的一个话题。但也经常有人说：我又不是互联企业，移动互联网与我有多大关系呢？



如果你穿越到中国最繁荣的唐朝，无论你问李世民还是魏征，或者随便问一个山村野夫：电，你用吗？
他们一定会问：电是啥玩意？我要那干什么？


如果今天问你：你用电吗？


移动互联网就是我们所说的“电”，在过去也许可有可无，但今天，我们讨论的不是移动互联网与我们有没有关系，而是有多大的关系？


它与你已经息息相关，密不可分！




如果你错过了，可能错过的不是一个商业机会，而是一个时代！

Nokia、Inter、Microsoft、HP、柯达……，他们，还不够吗？


小结:
对传统商业的守旧者来说就是妖魔鬼怪，对想提升客户体验的改革者来说就是神圣。不过从00后的人开始，移动互联已经是最基本社会生活方式，像空气一样容易被忽略但非常非常重要。


序言、微信营销
第2篇，到底什么是互联网思维？

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

EF学习和使用（四）解析EF的核心-EDM
通过前三篇博客的介绍，相信大家都已经学会EF的基本使用了。但是这仅仅是第一步，咱们还需要深入了解EF的核心机制，将来还会做EF的性能优化等等。今天就来刨根究底一下，EF的核心EDM； 

EDM的全称为Entity Data Model（实体数据模型），大家可能不明白他是个什么东西，其实咱们在使用DBFirst和ModelFirst的时候都接触过EDM。EDM模式在项目中的表现形式就是扩展名为.edmx的文件。这个包含EDM的文件可以使用Visual Studio中的EDM设计器来设计， 
如下图： 



EDM由三个概念组成 

(1) 概念层：负责向上的对象与属性显露与访问，说白了就是咱们建立的实体类；由概念架构定义语言文件 (.csdl)定义 

(2) 对应层：将上方的概念层和底下的储存层的数据结构对应在一起，起一个映射的作用；由映射规范语言文件 (.msl)定义 

(3) 存储层：依不同数据库与数据结构，而显露出实体的数据结构体，和 Provider 一起，负责实际对数据库的访问和 SQL 的产生；由存储架构定义语言文件 (.ssdl)定义 

这三者合在一起就是EDM模式。由于这个文件本质是一个xml文件，可以手工编辑此文件来自定义CSDL、MSL与SSDL这三部分。下面详细分析一下这个xml文件及三个其重要组成部分： 



EDM之CSDL 

  CSDL定义了EDM或者说是整个程序的灵魂部分 – 概念模型。通俗地讲就是实体类。实体类是面向对象设计中一个最根本的组成部分，其体现了现实世界中对象作为一种计算中可以表示的对象设计方法。而EDM的CSDL就是要达到这样一个目的。 

 

 这部分XML文档，Schema是CSDL的根元素，其中定义的Namespace是用于ObjectContext与EntityClass的命名空间，Alias-别名为此命名空间Namespace指定一个易记的名称，在定义Alias之后，在此Schema内的Element均可用该Alias作为Namespace的别名。

EDM之SSDL 

 这个文件中描述了表、列、关系、主键及索引等数据库中存在的概念。文档的结构与CSDL很相似，只是其中EntityType等使用数据库的概念进行描述。其中有一个节点需要了解：DefiningQuery，他定义通过实体数据模型 (EDM) 内的客户端投影映射到数据存储视图的查询，就是下面文件中的查询语句。
  <!-- SSDL content -->
    <edmx:StorageModels>
      <Schema Namespace="EFTestModel.Store" Provider="System.Data.SqlClient" ProviderManifestToken="2008" Alias="Self" xmlns:store="http://schemas.microsoft.com/ado/2007/12/edm/EntityStoreSchemaGenerator" xmlns:customannotation="http://schemas.microsoft.com/ado/2013/11/edm/customannotation" xmlns="http://schemas.microsoft.com/ado/2009/11/edm/ssdl">
        <!--生成过程中发现错误:
警告 6002: 表/视图“EFTest.dbo.User”未定义主键。已推断出该键，并将定义创建为只读的表/视图。-->
        <EntityType Name="User">
          <Key>
            <PropertyRef Name="ID" />
          </Key>
          <Property Name="ID" Type="varchar" MaxLength="50" Nullable="false" />
          <Property Name="Name" Type="varchar" MaxLength="50" />
          <Property Name="Sex" Type="varchar" MaxLength="50" />
          <Property Name="deptment" Type="varchar" MaxLength="50" />
        </EntityType>
        <EntityContainer Name="EFTestModelStoreContainer">
          <EntitySet Name="User" EntityType="Self.User" store:Type="Tables" store:Schema="dbo">
            <DefiningQuery>SELECT 
[User].[ID] AS [ID], 
[User].[Name] AS [Name], 
[User].[Sex] AS [Sex], 
[User].[deptment] AS [deptment]
FROM [dbo].[User] AS [User]</DefiningQuery>
          </EntitySet>
        </EntityContainer>
      </Schema>
    </edmx:StorageModels>


EDM之MSL 

MSL文件的作用就是管理 CSDL与SSDL之间的对应关系了。建立实体类与数据库结构的一一映射
    <!-- C-S mapping content -->
    <edmx:Mappings>
      <Mapping Space="C-S" xmlns="http://schemas.microsoft.com/ado/2009/11/mapping/cs">
        <EntityContainerMapping StorageEntityContainer="EFTestModelStoreContainer" CdmEntityContainer="EFTestEntities">
          <EntitySetMapping Name="User">
            <EntityTypeMapping TypeName="EFTestModel.User">
              <MappingFragment StoreEntitySet="User">
                <ScalarProperty Name="ID" ColumnName="ID" />
                <ScalarProperty Name="Name" ColumnName="Name" />
                <ScalarProperty Name="Sex" ColumnName="Sex" />
                <ScalarProperty Name="deptment" ColumnName="deptment" />
              </MappingFragment>
            </EntityTypeMapping>
          </EntitySetMapping>
        </EntityContainerMapping>
      </Mapping>
    </edmx:Mappings>


如上代码所示，MSL的根节点为Mapping，其中可以包含多个EntityContainerMapping，每一个EntityContainerMapping对应着两个分别来自CSDL与SSDL的EntityContainer。这个EntityContainerMapping就是描述这两个EntityContainer间的对应。

EDM与ORM

看完上面对EDM的详细介绍后，大家脑子里肯定浮现了出了一个名词ORM。没错EF作为实现了ORM思想的框架，其核心EDM的概念与ORM的概念是非常一致的，EDM的三层非别对应了ORM思想实体，关系，映射。 



关于EDM的介绍就说到这里，更加详细的解说请看：http://www.cnblogs.com/lsxqw2004/archive/2009/05/31/1495240.html#_Toc228672768 

后续博客将陆续推出EF在具体项目中应用的问题，以及性能优化，敬请关注。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1162 Eddy's picture
最小生成树裸题，没有初始化都能AC，看来测试数据只有一组
#include<iostream>
#include<vector>
#include<cmath>
#include<cstdio> 
#define inf 1<<30
#define maxn 105
using namespace std;
struct stu
{
	double x,y;
};
stu mapp[maxn];
int n; 
vector<int>root[maxn];
double vaule[maxn][maxn];
int visit[maxn];
void prim()
{
	double d[maxn];
	fill(d,d+maxn,inf);
	fill(visit,visit+maxn,0);
	double re=0;
	d[0]=0;
	while(1)
	{
		int v=-1;
		for(int i=0;i<n;i++)
		{
			if(!visit[i]&&(v==-1||d[i]<d[v])) v=i;
		}
		if(v==-1) break;
		re+=sqrt(d[v]);
		visit[v]=1;
		for(int i=0;i<root[v].size();i++)
		{
			int x=root[v][i];
			d[x]=min(d[x],vaule[v][x]);
		}
	}
	printf("%.2lf\n",re);
}
int main()
{

	while(cin>>n)
	{
		for(int i=0;i<maxn;i++) root[i].clear();
		for(int i=0;i<n;i++)
		{
			cin>>mapp[i].x>>mapp[i].y;
			for(int j=0;j<i;j++)
			{
				int l=pow(mapp[i].x-mapp[j].x,2)+pow(mapp[i].y-mapp[j].y,2);
				root[i].push_back(j);
				root[j].push_back(i);
				vaule[i][j]=l;
				vaule[j][i]=l;
			}
			
		}
		prim();
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream 1420 High Speed Trains（容斥原理+大数）


High Speed Trains

Time Limit: 2000/1000MS (Java/Others) Memory Limit: 128000/64000KB (Java/Others)

Submit Statistic Next
 Problem

Problem Description

      The kingdom of Flatland has n cities. Recently the king of Flatland visited Japan and was amazed by high speed trains Shinkansens going all around the country. Therefore he decided to build the system of high
 speed trains in Flatland.
      Each high speed train line will be bidirectional and connect exactly two different cities of Flatland. Although there is actually no need of high speed trains in Flatland, the king ordered that there must be at
 least one high speed train line from each city of Flatland.
      The minister of transportation told the king that there are several train system satisfying his requirements. The king was amazed by the fact and asked the minister to count the number of possible systems.
      Help the minister to calculate the number of train systems.


Input

      The input file contains one integer number n (2 ≤ n ≤ 100)

Output

      Output one integer number — the number of different train systems that can be arranged in Flatland.

Sample Input

4



Sample Output

41



题目大意：
n个点，每个点至少连一条边，求方案数。
图可以不连通，如当n=4时，最少2条边。



解题思路：
昨天的专题简直就是java专场。


n最多100，可以先求出所以答案，再进行O(1)的查询。
首先i个点最多有(i-1)*i+1条边，每条边有存在与不存在2种状态，所以一共有tmp=2^((i-1)*i+1)-1种方案（减去的1指的是所有边全部不存在的情况）。

由于直接不好计算，所以我们可以考虑对立面。题目要求i个点全部有边相连，那么考虑至少有一个点没有一条边与它相连，即仅有2、3、4……i-1个点有边连接（没有1是因为一条边会连接2个点，不可能出现只有一个点有边的情况），这时发现这些数已经在计算ans[i]前计算出来了，所以只需要ans[i]=tmp-ans[2]*C[i][2]-ans[3]*C[i][3]-......ans[i-1]*C[i][i-1],出现组合数是因为每次要从i个点中挑出m个使这m个点有边连接，其余i-m个点无边连接，每次从i个点中挑出m个点的方案数是C[i][m]。
感谢某人给我提供的java方面的帮助！

参考代码：

/*
* this code is made by Noooooorth
* Problem: 1420
* Verdict: Accepted
* Submission Date: 2015-08-25 22:13:25
* Time: 480MS
* Memory: 97148KB
*/
import java.util.*;
import java.math.*;

public class Main {	
	public static BigInteger C(int n,int m){
		BigInteger re=BigInteger.ONE;
		for(int i=1;i<=n;i++){
			re=re.multiply(BigInteger.valueOf(m-i+1)).divide(BigInteger.valueOf(i));
		}
		return re;
	}
	
	public static void main(String[] args) {
		BigInteger one=BigInteger.ONE;
		BigInteger two=BigInteger.valueOf(2);
		BigInteger ans[]=new BigInteger[105];
		ans[2]=one;
		for(int i=3;i<=100;i++){
			ans[i]=two.pow(i*(i-1)/2).subtract(one);
			for(int j=2;j<i;j++){
				ans[i]=ans[i].subtract(C(j,i).multiply(ans[j]));
			}
		}
		Scanner cin=new Scanner(System.in);
		while(cin.hasNext()){
			int n=cin.nextInt();
			System.out.println(ans[n]);
		}
	}
}
 还有一种炸天的方法（vj限制了代码长度，所有只能在ACdream上提交）


/*
* this code is made by Noooooorth
* Problem: 1420
* Verdict: Accepted
* Submission Date: 2015-08-25 22:11:33
* Time: 0MS
* Memory: 1732KB
*/
#include<bits/stdc++.h>
using namespace std;
string ans[105]=
{
    "-1",
    "-1",
    "1",
    "4",
    "41",
    "768",
    "27449",
    "1887284",
    "252522481",
    "66376424160",
    "34509011894545",
    "35645504882731588",
    "73356937912127722841",
    "301275024444053951967648",
    "2471655539737552842139838345",
    "40527712706903544101000417059892",
    "1328579255614092968399503598175745633",
    "87089694570964435671324844104521079746880",
    "11416413723839697400250507510852029840275473569",
    "2992938426499310900182770181410138818740061901947908",
    "1569215572908922308521995363961205592532386450494198274313",
    "1645471603165642700870123365352805341961877233365177453588005824",
    "3450836972657518843027307566308067339158750625752078009405689318211161",
    "14473931784997846210304793419064065231590568813586460830279677624521460536244",
    "121416458388792792649252647241600388956012443221106391448273002005554602042419577681",
    "2037032940918684178976184250818659345229517524662717388401435022357882783074342940728628000",
    "68351532186573198364243409327908758411752176373314636529587924648035548600802556000407708465724081",
    "4586995386488058986827880103080301055617470443300409663038804211130157172728628324791249533476741513190724",
    "615656218382767079140368523314666378067041110344327052442105313805257595292939851923944285549664502097869724318521",
    "165263974343529954317356861238565609447053351468551388266539403120010283263766600344094664895724527842711947319337103313248",
    "88725425253946577390137004665051099743341013053515477065967572044226981871352297413475235807042088670409886790198227401288743591849",
    "95268202520385526637986233936974667779805651033713707832000011893132709619843981574455460272576770474359430072502475845354724234793418238644",
    "204586909944926342215675757969328192615286275819478574751095918111085516479096593307895964518951913249145374978627151534646279971682839257270066349761",
    "878694093745349965033502594315633305831423348168716781855034808738594839478577490869993152277274474817150979968169377045130588455045403174167695472738397130880",
    "7547924819767483402367953301648843595390850857342001106183928279485100098009487488552358319055148904957428817509422944135401518398501749811772404830062788893611734127425",
    "129672361263353660738827839539965860638709352728998026184923084317268299008524142375422677379906565367543537959354092070023571030666511295683917950909129886198952449595855251572228",
    "4455508410978470007968344716866498138642471184517168554854220039545069131008871716588278712394969053537768722884017200452235232138712153670987234426768225423566577718431736193815342682614761",
    "306180206751230091016675467132732806798893016603488469464382061254229783345539134329714822285147261802483054650144190994569515229757634617032445053176772359567346044769376774208907346959234954879521408",
    "42081087200752140198248953190395581117582323875265366140515558020393583255681409821156659619010324997388625658087808979809018720113551029230344354336438422656082580309258109794130916057214438400291617976939494265",
    "11567161173227696466447336816695066165039763519419555325259691334406585295325501537840310316159938782586079387881820215182328454588950369084606665947871968713213238833370983458031060036209724293067527109814799128876919650612",
    "6359114105601017351408288878064905263866658953806880823736641946347481055240545062113184060591626390730626377931209552501152405879660090297634327028610988015692766860902956702142624812738029600777591216485670473359344000395925558440113",
    "6991919901710702396958427887737098476406123145888448373972832082249174478729219805232073913086288870815458196525696206975101995571932314828183977812556110313301933794619422590926799631826141146325928960207139220874195380742478976206248566268213600",
    "15375394465098365435103606262485648813731689610764786731485421737822834797273152493893303478414423892247122990573254606060877987088283776435111024652309468957224924480750725955516859522327151543381910863340521046671074079879177037242451769004747348970400726609",
    "67621699984704009571093949051933347323033942723591971420961654694361729000009453943349417050066498697168532312968847634399282360173446924966572411488673484835582936072259136005436901175709074663388020859582070981538504865993521127291316066926565506226402674272692246842948",
    "594806763388137870319883477715668014639530226250221334439268225572611604793566033353499885570285056724495531871328329408565766271788910680343753781709753839466974109279174360882895375331986271974503645690239888199740350163963394852863451796823258444580819828987043240094569439178005273",
    "10463951242026625501784430220079200349620190959855944731114436849579329218873388723507825365480181681240069956520124773793045889232629285007229542711667079762168429587695506277386530539600960138203196658268021421070060073719880333248021378799564961694860246572138977899599116168278661336912704319264",
    "368167554019320956145827862675510073905644855221586522560433473265572483507080939079705212086728437288829821510686303041329965427669398698246709510271765350093805510437355320602416018403182506754415616449810066582716483225352237188042691892487281620512135576613182207165052584133161253329646175586643485523247561",
    "25907488423318455274080484983551268752370543099016841024117675414780399983983209938035137269259009674371204242508318891176098687435253584276757950255770132597038125086011764201848182377132306683838545920270033915231978097219579884958727620755064828166606815073051027843939073260544912155301615352784234112764304811523137670964",
    "3646154850293767810262811310292554298146565645867019354649585770004790633021626678757507253398244149898549184370988858690576347186473540946746323736037745650406421052832928165645966739998963516104746895198985455779234103654245359809834943004622380945022596140552216033662342758507318222391391091643172310652637299863290964708434648345424161",
    "1026301351570055077911629003334248563530371464014961160148619401207592660556077047093700278584812110511775503329505399525951272382879961842580388109766172185903445721080425066638767951023848346841383603393314410107638111227747234949014648614460507172283080648297239358958028751902379298960588029789253841807791801792272754750610497088659279402182443687360",
    "577756298062641319815321289100079552694029634663057875273943785430800384531476038109893895203528476169905479147990463891771969343302575438598105099018502424124922191666372843671990452528625848668354820659455100781798687574206844095861604418887897443012027810311504846313068170762845168681143809596401125443319579565431920928673429699359335691054904647627111458615258081",
    "650495762166495477049126324444410541525813630884897301380979707413679252867035654462271627698395461114214289022287899099038885330170369042401480942772062910670199337987248234699021555821747253111028515923539884193597708437710312776309910996429530362900660431406155850610173052290433543360921808095902473644145899362436027878169512233262308200140510593081281143119604723908380068185604",
    "1464786236049590434905743465920939449363508612723489733275085975271232721338429531138219065841302235916567783054374294379287733653218841081671921098700170514558378605530384489817663192379350125532435243792130071255314573037817334501406125128647680690733402114935447084764720152787970257228537134579283995767379494435753562434054820219725742354492634229012108340533817520857573820496809319023469721801",
    "6596810746850441581553741639333517038709585890364844858548292276866814935193603264502336243986689091798809506276103112808369454137540768409834360859088738465923804221580878951022935129231629315382958142689553240242818792813478886053564867108158417175038867724664809956107279132606082421193307933740445718316354198850963406276459700920142990260995375238662007665213674472311961765183537934747223463590949116578344768",
    "59418788842699007286030480484133660884873844970657116918672826052315575217873342407759073593388395868718631808826436996552918251489892863712708047464715584987953212870952381722251151630665825871817437404434940589277400592674849493518878205551854127413417273257072439525856730376348151662087524441257956944276113234081656955166759524007873827433382019207030381963972246993045156494510638693753585551476537129107374280888803464454809",
    "1070393741163144887106615725527983485123900327163113842327624473615019139490344817603117153858127197758222925711459724942607537356486960154106879151377124831554692131055540711435791826303525544435084503709686020620657806411239135434299652837652142334413357256722319414659283292220894140424217290182597906316368285988028905279181116684203912641912268506780276438686727310659002549938410585160603678477185432073780892588038226378024952743251982695604",
    "38564998830736461475232360560247842901295105745971775440696135010899885298362813845775680945520056068016359115318259858323400609083322760694240259239549568463780365174038285822257695909831049614979140376577861300198438360978883338147260016684985389436901589778117101913784241058455624626480715343998372139233079163492506057596659507988170740507862889097554357289743888084670790016382465053400438597926206668478686421788457495335150862751345259046904921688545736721",
    "2778901029818375590546117527114822833083253841903153663407293202330682354893910801678157678683711016787917227096257185870640193093070699753834558725956305747107538616630061275380656515610680186080503365311822964203277178367599567092774529887880237981396131583384921472464642874362720103516571575280501129842510328680140775471366955314487966622218587227833476993001362183521295649903852714271677911744100104628235240052844338319226284973732527589283770792408791230834380038791712160",
    "400481844556464920523193301963612210459645292252115579284594784683638498620830533586843353519737678332246322681450974227135732826222781447054824568948285848784503939831712503444206649814564507709464166035933585822620726771882633974912135897915246868072599793241390944610202413878391697051983068345048030409259348173432029130486385964525127264545916431882632575945486108917185125511354370729736139766065701983316942507385259834815241449856185970712583942074007615935592080232876443265428056629447665",
    "115431032698441259178673461431544571503868580018940277924794614711362891394725324650883486562381578285858228647728394726167590461972195281383015292686312477206278430985089289897799375265169457211616699579674677676069197471602915238481146867940935761265218364843432447486642018075182372077479720231505523288056632903537651643918165537976430062690283601150336033705604323159124279613568308518389215883616118655031313112374969090985045403397061125218680704695227858031756178800640459740642742756744225156507810909338948",
    "66541459948504530753768001471968667858284135409681724401529211759996954518451120032531139614225451493238231251532753733701055189842109413048439370020510522092871615726466341176313330049692126142040077571310209189414710653397070543707621702209667438403619575777366609708276569345859176432200644796894842211071811365074132417536370239768267097010140225383394752233663251770436883502726797657416433192243804494366548997794367254174820384247578803880348969810547890908371517261893224212909243055022533467235254803689765401001895961163001",
    "76717080122566093821769685096126559772123311624029237723465232813219038058215332768726502296650001326838250510587004733662016375013492953191451633671991930832662056467300994500426063088119178442252586999548057321448534212734353042686006343703170884180509130855894984348299125158647025644349686247733683852902217528484006343325456330531420273730411859784694088131519640808353993255350982185668474147182920966679606123864658043773526365017771144077862125855846520085396629984612009718749120108147731334597235208266539721603244154875732409825161040372448",
    "176897542887905871219682320710977180066096412507148130144398800591993075904013117980881355032801406588134609369694981641848153852976363677785544097092613770281818364124632009850706004125819990850402116952706073403325294541662034606811830123773348405095759708577893534599222004405949196660971716404021307415506077181991282349212625416976352338009103939503132620599547081657135972295238300924743231563343455499431523445127628582086163262928195106997271651640503572591551555564786896642694309499816136037740155827815220465607273333199955313101978017147630703180462437846505",
    "815795925230314728472279878236737235107487487375679658828359306005781952327011641385077044577339321765600913052762660294769820791770837231468099155402135727408487804724759410651567753149801583823491121663182746671004121828366325996683495336048610111103062424489029445610286346390600153775216536500430336286066264078744202103042898403387079868256073409579258273301091098732895412193763509971007357027650773056769253639107048750886569923068217313381516689017541924361807462712584927376426402065014205999079298496517051180385541771619470554470392299140576693851946130187364895826304018436532",
    "7524389324549354397801356452497913671637302623239050243751095468094073323336858804077729632349788033524157183679764253462806786929408221296937761659704126588516687374381386849405003977412109162567517683326594397687478205453084880131365490951409870797616769248976328676388931788505415601925973590645938499268262541049426638074456046768014363619822950195610040630933201569329368868610871434945858863279507025923260734426290801693454566867552748230899663807535422195912509514823638633361081868354837922529056986074315862782194950537772187870823640874737638254152056104507072694881589284940537679773850977072513",
    "138800484180914219712302326702802179854054812711075261937158556233721310371465055845617816558287345197144834244412133030562502074358385172099790842157457098300290240620772321168774924367197137494373750720538430011100673474275257245459737980714253280751787852562489002753282904223588010757292363201789356166325963714199767590418631057996650918561431174151900925134507597012978503880446863326377786858774360003890780369138234670418407251000511351628293581577299348828942273852930081493093998334121878456629837227377524106120944104925125633020408961756192040925542629667073721808448062405693069524542931864314469989248726628358400",
    "5120834017984591508986196650065047875839302139690230205242731029048153165740958537724634691687902033081125674592419026458254627254495852937279629517113718862446297002364410605932538889575185387110403381392921897463896843880158994290370834895206784595764683077936530808005034896226190751678430723486097603413102566255405706590724427432839018811520524940915908941925941616441799147043105996059579581399762915510170502608458555685663792846861422948709937177633644526902247207455022159988595345687209029887264778214048887740257014381728590310929870503185189600524464264715439643030705301414713636766758142946557851849981598413774984564875893507018369",
    "377850858294830139838638168215802093086925887126931914612239873126836129796244799562758422809309603708215849432524255419354025814001205626509561108151321750366199545761303757397664868124520798866672006744344646633049759244954763944237261894295515947951872937978674631714166544336378239483772494537238407645007249726340757921345521719083300199288008132309643236387222275304797366657103508197721167962220845749586684108873865711290056515696959158068615301851039665494059268870959118844400920356175705157687380966720889833894243511423508135705787528561412107022305915895881489894906873510821612024136018439545297419340176162703185408054988474237545125776204554493625348",
    "55760944647969803670700104936214276715083423719964045844661261136735339428078824319189106889614681158954898596838282568639485048074403495380558796018868074077602263361899920421103748234913182376058217018138234907077472583680834554738582056506298354692633634463392531299779656748976674976371384999803212355062625627460199754811512752517519048756770758692097190528272227779398068312803465029944309981139772352453094629307707229567901268616831948968968861245140912561275319789356810069135581018372862940328245978111483249017920767891515202190649900368623894983165821800561237218954689794504655471024308339716120035480157636932094372754055666489367370857400174607664955323372432165991628713",
    "16457726003670133055417812568315364738874776204650829760446867379357100901998596163189085053011218554661644549803269856525188792881047184595210714352756578973527862632628635450448100320792765888834206529527729660796488455867210791450395977508040516535191832862845015654569350215454316955118222039806597866354046383808847585182860266607616032250727426655837519195150481857532035866993409781517191410369191200376841697867377706846839050865662218445357651122690044498843915087410627989921449147376211725165424119880416167530131222904526850926162389557454850937419590150984345357942390933379521293123703350217335856872011409015949731998936109284855296846553605248986483467838110639430039905702935311346728425984",
    "9714926707998003497718782308204867881391995522576166179966726639015271734322741879515888403999270633009456307795063575324200608254150961625977536212788672358155695862400743508802658747371648724305762715776510644184132781329815716389636841942054042750187968040558731142347912905856633517520416975414903353968386986895884319388343436738813313758188795172338370156881453176133576008505649914226540367740759685387036950379555032218800307164595235996995809883572745402667053885984438870804633299529582341664408861351121721896556865893632820313720292304173565796111051950884073273595925948160869627687226894060248037636990997764710602326971142383930132194687099865887079304120122599822733051879032943082681473611650427389770073879481",
    "11469361067346228139061290587410929131617912017229616968931879358352712132692730670017732582915701188470440682798421241570649369669817366523857208399300981386889556940425121763013214087628547485306494656730035115891260512544628932970281367776688502903385877572327379171148354222095807317297941530351533647839570093829501575960261035292986369272018255979790767333074665187640092150108236079579445516397459018527194007478060544915760943720131722244888462270667390075178367774793424587459442844723497217956347252093999239384037316641861051085362381919864487699185619546779427201751377735016624998377592182535142708053692202371925948790251266234067409521984320697646766468453266999174807844568415371206966554740279907484434123667863994620867616295788084",
    "27081263142182923705501438690346729644391000994556618097884319997594440546275851690598581293011138241498216941263742768887386257721755417044788688804259686456777523551258934629081827946316506330744983439694378434274048288668616002057123700504248726599111005137073460939636100761717496712707021962566676510027297461544395209039183697769569007803026573638424565301229537767692312612739034823349449787414239341835961675930115358575277917407475478220113334514860405650606357677866220699585205914327814939292945788337768927337605491630645113053275649354853796409368920413885365648787908857425533690712373002664477203262730983426254139703971283462560168028899012842115614571845988010635474336692947735667902932669267724448985499785309811331912260886166969814393907986968451441",
    "127887649376417730093987279874959223434751978727177317678468933940178567670089011059835936855306476314055820022674203070882272006866498235564667897847245117382089387654340603395902770656741171358357134677847354180571420601614467393550918623550656945327872955722554669944877200644357783679461224972489656883740547441427281305618936723790808824641823096775897200607765224286457542213298094697818489613158537646920523503894561336356839674546741819864479496248510271493441660572431259840084209777665340391240652659473135136097045446883084078105707212339046189421949100941421327954128430953596884962081660467610278091053569098997728342746233647698373992913337394239908249503007665059415775830744926085621771276480324115145743453585347720689738234722350020203302166294597477629009148270254213517280",
    "1207864697976360344004012227247920888639870556218869352974080691964898302127728276964021939301689941990362937010553438022125875474910413432901169640664817522687207823455334075586484183617965390674062328517488830061205194043831855389128743458972541515267370102123660769648254278386638983308451584920187102324892012358662087067501815490945102835113347456386876024256245857607525525014392450842298842561085780480862959189074434916476731722039062425413389048213999283360212407096664775268828195424825259795196195694131392781507276727799638935813848554201384990724788235266234388995002182790184912720977359491307710775394369694037827284801803282839402462375626865570762358932992624686869050034093558722018928029072089221073685366742978097470229376622034123034422099304422319858140479626988138175771537761521969831437201",
    "22815919062260124281152347745317946282499934366452617323776006107241264602795533469570884875918350525205216474758129727531208112701840870980155345011181027773422852933990746300522293714126974985638485168039689385550418024968764272990769098223201120182551977096018093416278368986411387333742287512369414451842816251894030991394790236106628455873678591550918383296249145880035684864657299507214594004867992875785013148350540591071451041583313849078768261208274925233825428798625787521636329116996915481986406679365161465772333710190212707072662455444363658664104434867526067652111712295388244910679090994077323162834865184640479709762721421015631534282503359877627737619631152784447957572390295086881759199902021817549109735688232413009794162499788571838410692862747576101632805470237935435435032457070958135841741709577989566454148901444",
    "861961051643870695033992674309167199578108591679622987837512302052086356621039331592328102938527944006969148281855423551800084990342049021803998916166188572168974831943359972509780724136928175759383402721841125760716459294947775610490628574824900125739041644401488932325733698598889639802475128199627729041020774307057592344233262829078520106490200228690324177346863380651577401635338558708627761575924115623526976698616904374330016894420538755305978253349030126215039569927166132767152587499208884052990255565244775397790866949052785309330648586993446378470043418560247499529666716748099487358255406740919234377397521228466466667052177224150783607653016434502074074229063589803728318964580759649227631056344754826948147040633057356514591967427146922114501946293995982078942839207023798874794106072681931833541348794644712344619868391140591142198044497086681",
    "65127935677153380382865185934274607003810026843261289749028099882035397266927298241817812280663338302874592484963605382191929029517815698833222693542915607070266553275714496391381464772501142599806860926746646513618971592205716364184090200021765814487181840031669361985427896069354939545049469719264201514996021534340706619059408974513793777729755417309701092583457478222165086342915655696255169286054185482239523506595790508483403449664980481049058030357857517104250573057167895059024670228186104251358420028115457281328396885572060594550832075624058360805811294013609359993110765379657396709253579376411328711107823334484055480885887566502155982684909630057066748521164378750164702530401246959481173856699170629438199765921810222285786020184993912596568984417599237209783727547207010554117928212476081712087104049595278383972168871182521185128394733742058868355331729347802375328",
    "9841855377288937415447390527231202153455845092922758220238949862370951215307357850537312032339475860155968712408016460823626898669634734193056782471951119477621234174959245787176440645022541201418433927999381226748012716854141806994113738623687074026055728022039803451441963420176933414863295653601443369040100621994128949157016855602235530478271371783778599964837999796410821452366579975122909460158599665128397516750457000925545284188367509819818312672614995954226597473669410881768891599589399459286861164368425111556443211981154769056006631128654366273403403984396497518667786872761458174165192077384987013707714579844814595258260258601581922276564774352923437301971046177035365677451317202062195855147979906365571614210834242853829168695680618629448477461066172682431866417173537080652678408631229103898584370370340075955219926311960485681584387269950648473511141490698746368654708733477789568107529",
    "2974518269629418528183287790477136251735910745786981274890992938532906530868111729107068657934012028612480976341594884107864010384448541500490865233582795689734439936042424683138897599808168879614334000309507721052838815584185291954320514397429056701324964285255443219553751274822794079044766838240890836117682480710918223130904823198643091909734853753891122345761054756585255911176288018728174195207349536313414834673080480696218828470267131454399908112971840743103995767114209129238335593662867811594910126306838824574019819901335442368728398853720994383348716610307856340835297745530580152133622334220617813359080146607310450851945847134504252094656702933493785736495664926424878653684302180250888370122424378099420182931197150733885239575633998226054640324499639221170970571837196500782703006071322551989504100597618920993323538961606009303770296476041906405386457368270312607818831683956052475175065456853992908617662362164",
    "1797985968535216664944496004358374343509215681442061471412191560717902567100922783048272325884204171542595289833292525444657649015706240748603258905587228070218364321463272748372578381297752753873677472254922355241777152285815968419478586580462607181532633401390493324158696274873236811462980002924358959014961523858527582932580094707941486443910926176542073077556968436127272895058310597583607027726718736469175668307253909021323053371430188118304785898711275203434771737000724872573886880637420519724444463284443388727630283664666528052367541776313661585262983733024993681478681073098831498512514689575760815626512236554172414169581755726459092026691025970210757809328265617410698278014699792075882575574349505687630013946351950460669539772156003437151693004013771313802959350891175251984857136050528938291210156109810918641191927163139067163195482729770659833966232718210585298243545222708068057806276615307574921733035321516850527615134840300065761",
    "2173631660667039668984700210504885053440928940865456162564402194450192737785944354406149109588819094440916452691813792137523989079778661039306847441699924537987002272505065952351909044938639225469091991072478833137223773687819006461621204772108114730273468906452573994630256815525563890925741644279532588225042277283047107377981352812637499200674264712422200295447343469452316702920081857866102776356345497901140695696487346008725214312749099478128927072045696712743735290203702331838221557958853932643074387803640656981902709445151878662166871673497432912381776428661932724129079887279917188148015902271804477794216825082799097380785838031970555158952484840972551708876895207352306354118139601108599277331544048236856217944241990869613748482221644530115368470558860568500649731583579095495114437368621422163669980345062271985618577262359687190320419363115863720006906825698877493420984150753814464314638128629424645115860653443638386537575945993390222090061534723636118094400",
    "5255518873824416903687803876194048725247752904679834476906123160247588754923499095648962836677062896389080005777353515615519961786082157218832055572888104161960813075858753993204338524520606093657672316129670165486135854273027257869117232701486901401258470698179259741025577761242213513209255265386075016326500704930422917303642525563809742371542797071777422414107565426108275731906962485919752927196293165342548870477021478900400538967825706071178259031122562772885630649405409703367063847618824225741404842134016281294348855334227280096144669219910062498461347541103272529637968942509749127923247417152771655159689179823920310384408639369149430628041096138741557302442746205743962009461817743363439735661682176474418558478862493717371110180296141956513429423626802848160777461681081887783450338143596074005845010139812966205263949945983128662552765106808342325556201688032318423379767219146736065666134076960075878713420750787264139595997890269239370766654408997014349998493737638227676461278296865",
    "25414129848153344382239046897534255136864521425032321543198987907463603636933218550392121025284493890288476740344333852568984204912221236407759201838250043094916016054157811039050384830313802498917327099332219522477253430173032775561934636758466788137834217723144145907968824485104472731993407547905898541493120018409937613134760376879698500643884583858993728483460548847954890948247194125123156095375672980555831310674187654944817851083192404508910514298921974869820865701713490326851897813303945393428361416466185302188624486782702454447009759360043318904833610708468456173638563883609569148643382336489258542516560724062016770966626698695797368159233954281229324666488409424257496778134935043856989449536834116057893033303353457507584758178817698103932612119380289030912912789724315249931641899025952354394580439332837701160863679710871325897824748698596768252502179281396647786052611765866061115109191865934621489011713077601312587981937799725560613800545479627509110349431680140666459693678259767085645658970194741100548",
    "245790382051771145194669866894836910650556797257914829803716473420465193642074785106013428431872514878990588535214089805784162788716268545507631394966483389377824251794209196910779810599768510817296027140745794488967813649665678439902611015372568414560564837386564200026316322622469702182920141771993480749946980462955772899543665221584443658493203555840320515400734302189586986967099083114722544095624065532036164098694032656680024111959698488163186022307196914667272912493407206499660416052003049943320670154037880892156250480987107149816211161309922836295087659300508618824687956884820016773631401885196243741354255718836847763174171150793705155907540422343384981698066781375095240480990134676009769488251998070721441392253598523307683210522244865434657081035251703124064234955174647593539899199148117815649511423125305933498893595052867200393735244911155718851795088319566226103141215126650756014289469963426812014573525508734437947623293924381772567170842571420648049323329611314031206248968085637730764688978260892710185319163536688673706573961",
    "4754277425205284348419700021630306277819594231324229673831987127244063117828729566892466780545292931445751064132598220796049422574876174732216148557133667232462191164441022107679344784650946278308912307973277903956268576892515252911927587831450116803526252393895586426372864009992966115390852936394750781294322737294890737473525184307578815480810982000203467714611503183864749503859311439369828005557164015199013783918013720233618456348774481774753112051446414232930710030976119808826827308506073570808339673267387683023496924539170243992317384631547146462700227014797996075472403243782366190785050806379793489498063712874504188420861004661215505120695733479355193038519224515551902148437215911727990794886093643859520777829262246056577527709508106166200880046179677051280042398448534373860209884970034305287546941954518543200553070165755934934900741326454179854858073793789736601021130950282124624297415724072975890792908593463306606956627920901394037442868832942735746785658082329107022810561107464556051920197082345018451191779962866090671709877436527340920295983873675968",
    "183922199454132071495017823964418310581035406573285867942387118971767980194298669452496073046095672741192994977719446859167499481046047920511152967992507131104635352501375605724763061219686028605852686640493918295524511367033919258002837197314997473688054582719049983607925090921272907361139565610799991114899860297072476759703865254675754657490246508692183159765565344723487303603711859961323554140489731309462898309371578604489888860463103749708952933574490718753656978018783870841450820562082130138165145045826221457571999110137620197476711946929133441974930103211731301956168120310220844903461586897667281194654495842901516450393315112333639568531819418816253828855234056983083196351960519615249446261569123498616879523185925932176605436673682846349231630482429190760052935392649605114676503780181299909265803328884149516749748572347513130356923240327932454233077107245936592487285276866022784349661331916838631589627289467131249951961851344505496562865374963461086582225094977839064589597294458058553953404775061775900220028771982319110946073668250745512731634162047449025039426111927211803995865",
    "14230290926106362696122823080900243390433637603755791732106949911824080136101173014143184178281755137808174552832237606682518767799638672778692076547632370358005439458077144738842032396845315267717610617294892822173762145193043842974224805316879277778315687814683522725399979743956595259503780055472684548890238961768208807160567892770726623877644184431548999114967406368888173098282968909370845628866148259403677260385850025509467281073406163010562422645627803366939821304123828533395816659998533443169695576043444647330295513146708544008976157838105505451978776436391695567727588348599603773574802620015774104832871364395667041616614771686179713187532904193505988616414335011854214967302674800073176611175881450630432052774052983125556779718330138080292800433952456054032604266822488600945337656930977422163042584040081079715202559559706680427810729697183093076120375394553687406871735569061378091451887615270980769227439468566974482812207090169807970800161198806613558092139707938986543418066573554895535952384507580101084436098279822868443311979821043798055570372960278226673257921008509744193100971730800730506925391420852",
    "2202030863513312636321648671199054913516907653916821955870583657901629880180606920851316146337288935118727861622032224661459238388205429018685752611395723406547479819229390443492545797504661380773345416129726716459455265974513051084690663766875895512050711716295351874305222446226840039100506198384816983956044033910816772108323723191473352471490019766445555662599260829041365254451095404874525393854860088562237603696867168580981335357752085057807386342652570530409889131280895083102139900612595618883305485831671937515851727719366610960217159502965547519571213326430461021613875516598906241231892421791060695873939955883202566120966832952262431203975372419316838357685148234821833871554807736150971283740236329234471508343336380545366101483504448683820543739518493001750765645016927908145867820020571328279082021459731553008180730370556274578694992229443829530749361758523455102029960626188230296817428523359972347630927768572449727408126679518786334760290210092809432835028737236803500857663167783510149001301787146724001281345165332421763856992048047543805345657733242445022058712346111512565047505577553789906861865019392002473375004108968822887633",
    "681495543421322523798250098264197076688919625958924143870524623324155523045800434813476592642445682226654826184802698943122317776841833338092598992418663147746456667907249402037063519379241181043394719183934990602150909864499962853943798954546734361672671887789880268590454809802177762074811062436474536759599355302791778103928706524933039831760341656418460923310333097321422326655790770169714069442364061933201925383010658648887985020090047082828195983869248452906413448963793515736293648149917464339086854764215956144973338915366660813493543853568390289459916851571145319967573474741211934156923900710615862681647275208971707741861066631108678884356786881992035776409585052947098823119556147809480886651331093987482201967479673551047442695482802245485679248334227599583694833975961971137625665050598038462511431613775355717783643905026226773388597214461766172451210480389402020021519566392811355446826404040065412029215892009880106600517771803896912132143410644117696845783765338037373047653977544986212864680486485686451440775977975877670315582767354407568891763463570492892025606839060365502598578069682386408871277926851695621031183293644067480988939694506298063480784437280",
    "421825309897901792033244672821110328299858989707329623198351831257487412488334150494408358062816384341037383890227832980404741461220678261412609915977393831066701003877756508821161903070536068208635131114822767581994507882764742445246380739342818553182547915925155331364115528691522809563388981168206941607225330065103786153108176871916311445120706067211302704874795861931390169225107799497180298591712826442003609441599723740839388961730892111082517697449982498960324638396980281855454578237057403020373939942229603634141735998842082388658838322719796042537746864579992961289849549899511001649278962723352024945085436276706265598724392341910421392033971774916402350499971029677793340329156126649226991019553199138630763430518378475497218698611778946297639717590578711188776811067824689067051439712055550135303082230848037754890247653172514796418849183696052210614129285622581470276315491615583097616508138593473795306651270631441602744073414304619140211197342049963231681092472420677397706114111303040207460507387010163534918325843816587622873753721872270323771780566351683928591957477943840000397869341322941208638899271633527130479967565880350857995127838763198875305079831427134009943609689889511097649",
    "522194440706576253345876316972208990580919049498423872746826556039073936784363111767913805624652405410814719732081241372453259899769610465953650998544985761570588885297388228027224024031605389917645712482238686849850374382696024940068487090601971453157602797885922894140742111912574290384622150023438566954059414609674378500664586843661758940944355389537736955008473536688538309046200611172778929700401064225043636279276379216513660776584651486685869128560911836477979733407945587275638184736643835546830706430899815879027964494708699156615327858162669162070550631973721381397788011408835912083069923381578402765996750824350788845053399061457299376594796115026308840853616135265592537464404465489383421079888172068087880540593531143179902480849252020994692799211507956931239581512094421396636115959264040566880273454550352038397869100839214271729011388765517219855378834014619284797588465809415709001101673998496791922662152269476771965727632789007992832670675888715975905568976697604879351897631215007274284947678568308245009394733712372795492633801227226263715657397043380945358953683193593708067947501622311488022101103980147119126363144499126201376612047565500853066145133686913998486810958359950877917878445430245851063764112708",
    "1292890812885812375326210375759313154211806521142433468922887162821869801398939483488753092582940244169895415615723529137693835999168909478836520004604853756327496887791785853190175935817969787613007017072802027259003595402186993800697661464568400528012281699139347495744991446527255046611529092871296674138998156347554634956380096911385722878825122306943446316918546919191642923691382707085034138734478154231047435426838095551350329882938333268204120983684263739781589379189335962296601804776669491246984049532240711845685491900530145868474661623354280206787303545194909034204882470344686919202399217705521889202822539656812734560692344890265720007935961860978634043066823754462315724586622906572368322076593078378573258706724878413227664591775285315452095921649733003420985540281224033161079571949877521419543198682221165913014564673144326729330474079791327266883866797006364248513928735630452023998712316883707497819926672175727274797214392355511094024173454333194990105008660589406039840231914887962856846223883741599628656488592860277915422435916707302055221333097465915078656577855576505991212547407099889092520973802232030014149824651964729064239775448265753456660102258918124410545437419318058981826073574997007258786857900425313073864419946319752386233",
    "6402085214782279240215667419755299131524078858723657506895862975289688072387184202724942636448865634845362376411290892852401212244654001278874518493614983067502747915241546050757364309424213614103351721121771576319817771208871899572878663307343584498970392022461500167705150596412713025498564145875784471053079814704350338683535811375085030027987750061241476586128602964527699150059431494402589221308951443361874895410104973416993861615687357815981573643523196453166411262322669063652215755817554138450872251934892065788022574397869211263348099194622475935309330150491581437524740673066131732470626645053686294065523193267056502243594603060514277453776404649471843338432761398643420303447447392526544300501360143620577982837160675633127966355026411086588671293729638229729527350884124362822005799132185856140189806022064400645129879239247356832489836113046877006982810044078806260652871255547861936278616735457447659757370549778589309877052296555146453306216569925238186184545948010760776752863577696731293552105858614736089212602430508775892091472061274860877107264744000321017801220672792377067808866767300805984534049748959074423828986257168568315123767970931003629505434577614169221291986898163677106670280470593719009386913071875497337924524806796105577346298856278393890738258162784",
    "63403180978367415821309274946297067883877259318587871831770935303759143784889889554522281287382451910266246973649165784240949940375905696313673544571183835877544775102679330229623874187057627911328491498254666556244752237079714799807242032998034747080435083421456527343310504382222663803588392283156708348347965214509324334142435805184488402884030067350763759088085634521688221048465923014812288980135659107429338721366072771902177317331209923787647162401068528268815851417366526556579473672902061731413545507655314171848610980208852889160305234255729107360455608917522003043309019763102004826290162656178132172956263924922033921614947970445348142630509045583712683443705086720483929437220048017791473564742657116947722369162920514495227315803152463784553568865429940343244212964576831905347290417216185020746795931559459120847247675498498645959053033467354700504808682133866202321576777637699610952306621070917464876005469622251525837775124034592239768060539773673166287745392457359899369480756958601924929019139335622884917647427295587394319350269985046868723313791210440878676771219005721179901592011590792480857752380663805202941662193742633066453665435034412070612728436972875281797488541114694801898068329538488106826579312099461616252171158117928691489532617400613334275405971783862885461084050077409650222121",
    "1255829381618851745843939813162800704298382133625846842809887027840806114425442788432951756305688105625584320996766594288880648101661897268608898452842853091871430074406261051662977763444204040314446476827739540629381287732437511633979044797505653703284996755495471110325074108823829327334259719315788979865719699690209168910499796869022853983119683378442687424694484609213994214644163117423375679859361851874945135010607663312467547242079980837107518240180188095688088909845141420363857254970317996733152619312732883288975490464846158346252555673689825095381867952755172907391545035014962182630853114989372864228346210416643412819423178788931952792154650291126173981426167299265765005270386003626839058749496592516028453586356025315751374536212082378005765647052554860956305529504456848719889829131591134692949475732263074524238685056826908312615917743835792479291456258400769089722777027421482409406480004366856000575782773865389481476351927472137339199231525462720414838670174631594474762428516604475752406824356251742288326276053780533711530333448036790994099494770997810524004481984180613685777525270718904747092973861419430124617929024551387957508938994689846266901328969945717228032731721753647174747569406785196315734493280834094651426888584314870928280758447438711805507030796978914317257131734775655380315040374088457949709060323406004",
    "49748527168543236721217601181701787859412164184544981903139637413886823689926173009749595037785920888633489850813311481605150725200942772634385682961800537019407409724231335116010495734338239882288762420223511165095744676851614269111505060030202830914772171809254625804466991379578455279964765634194370893040321253131199955632614113995024839503107268683185453271511624877149186009028794740942374257976152320827283520702289642476092612689568215013410083893734947192085489303230326130694863051813599777312450947911799058630623513657322246356493268404069120290302244596009483727832254028256065346921203368387650764228811482869930619107508177823648111897705607039465400644420066304018366753528088567820681968865756929464873024598946240847282494784399930562460085398856729811420238208811850152651752608761853500956135953577192613531210110557768247940689634727322516185398423564950440789415406724110084003199382659633831856061317507339280206724017482266643331562198723476036919833153010102898515959713302712103086460575098566090065346768841886435182884860726130992566744349211440812240394669086569857277041615226621471919889719942355211112724178382788743327932844461909626480388458981536750884717896387957959548038505816970559996687017319313065634235402982764880377455013166189744092614648163441208002870528662152392858393457349994719547165568356833336692922592930108791093677121",
    "3941484395354638233538289175687367867592105475775706538454175082747236251603368256462784997091649148455366946998809240665068740057549963238341047848965838679076296559705812982932441135448614811939712643600113860470148341970566591826053013430213246554265101598505600371638196644174796391761347969938354273001501795107299950001230143854604149208783763671243543735195629086089987748497905953018321544810568341805606110449823245162286537979367516716974126102699995194153499320667076775730515741694091291363363682309356069378836394722968454458735596153575297675695696088976822315210976745126120449922477193462168610427107696654610352015863159528105808129843836325761309056043876921835464986748372647510317779813642129035884208182031129078568808486881146600901776816955427541739053504361753306065451140142565454704216189959009236952696539497194827933267863379467728084352141393853139101876405122893238481606303337295813230196517170933317260070226922872001550955906816786991421540780708064328571709273638037787506948065794383692674853711719550829095546351939467091650471946989466206787800253144476849912130133366764530496950237700273883783788535467810581022979050449183133839425991501245570487876063446858799665498721662612781183640249557225878758778467886082088153927340352344903586316649617911766321104499360124893158441628797397964835750827782235928721599081063011966538703959912871409201370874889689061760",
    "624553132445188374261017074910616651175684707033259989622425326240358320144011542099208148038451167451431700514902647991182094612618628783981105574369472406739428009809007136714553058225921794962678647770150062712169329741340380492986255026656442518371429178409580000334862736571441990986674246140792865699335750126142560573125811689357910538278846141003743210489968268151600041570954178853940648725882749987134406665272696932943861533879101499278995846852072231402899570043771700965384670432978304499197045909670750037546387967323149538975400711173599891145620098346488677369454411866360324340222789777152970538711484395999079545411339044327158327807169400718180636168954580274173073611891648389467932152813336674925480579727329789015150165985854407797204268053125510428920822155959407359562263600196189006309280656043497172517256395758191960803404150452638207990202239030220188321980089926698546009343176018217675542346175086759754685132342655920763271569764066995516289503374534409608908130909767943108219586731390753754077468746438635363230450837182856443925219852571666620481530300587151495003881755883253412188552627194665184018012770900376333616085976619651152539728779641256071708047933190779151063104030363960740539021321172497331784128697081763427053027679387359203428662165168474568024150340706402354835515387514875001532800708245730649453853973146662913949573677315948284445794972769726235954550989088166038327194939841",
    "197928788304640974341464850666479258600695049180808534143893236720551086957316991561782895711903503838312659617199847655131761668521022449864555989012015631874446585754589747562518909260670023259069319536958471520198465354731842048373873023222171792722582192051964725990900955954401448459366549745758080863086574922147403139565206738378168498096710925062068906793484169946458816934858602016140384846517427368813953275650810141982449881467020943433944463398288043606587087462038102278279333061255778743656962220698369395031741439052192865217459034931482198772374534020251547470047498884015412872036286365339241113916226197259801652689494146413056304416560197135553255323166738579115783454917663175807744664963181478476800002199479859854322683267486665302827350607612789848121755768629588114023076112282852388119573593615140664063262861889606326372759176465087547005139960226174015127321160586440204286047417005663168199250591318525255630866093314040686043735008459820241181974789900146460102681276064452613697252784678683017712816191077024853514258747314826689315347249165716727109722988882720409288376223286292825416120602544160894331904255524723403560007404728082208342668783153489098310289106335749629363553158441700848515546966661090972068991700585522607404575709118157718817843518523261561387231271221919956023896017106863850408710227866272943561453555233934401941520039173466108588491694374886570252807355915262126068581462067538865007618041416239337699844",
    "125452273648412141401139200773089339811437122262323352219553824706338070079923557409066217434882229680595996502151644090630971486259294285183183633129649272779309737174395404430149152101788835053861027104571637543627522891316511380301059965231787142333009147358563841204157993106127746328358011951843945908682559568647269686844782515956183293678683885808384414357761866799607762827058739727381391422081530702944284229892077009503570529836320239926968983078178452050828544077942799110265473616548265593766770014485779543167936514534071393018643375473912199117711676289909272033306873945015052404415032999637682634276912805986388447581835931757690057967491778984101821758663878487208247496763635588487359668638346174665417154052574051497006316330964451571627090453129541171720163384048314990787373764160610201262022979099263676893729850702083728532270947109288584340749241139094735237019397845680629336068461824057317607692281274743450322416416273792937253238782600748928299383580612411844775355999477318876111254457008444448966213113526192151409811100006061719887712487378731078450058249337327652615636078868903439786623915180978846847634714364490430396779734368064214773976667385763118747304181925067171954039707710176623935170213676028808676899130160613535644211234205271658535891310751900409184176834728722957024409233397336875992174922881569367577841678674683131358772093085604064212778055519080477496486004191899852688298187675392154348091119909214236284341881435549211816258307298573161",
};

int main()
{
    int n;
    while(scanf("%d",&n)!=EOF)
        cout<<ans[n]<<endl;
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

我来说说2015年8月25日锤子科技夏季手机发布会的内情
我来说说2015年8月25日锤子科技夏季手机发布会的内情, 虽然我也没去现场,我也不是锤子科技的,我跟锤子科技的人也不熟.那算什么内情啊?好吧,改一下,我来瞎说一下2015锤子科技夏季手机发布会的内情. 


我想大部分人到现场或者在网上看视频,目的都不是看手机,也不是看幻灯片，而是想乐一乐。从这一点来看，这次发布会是不算成功的，我看网上的视频几乎没乐。老罗演讲水准严重下降，还经常重复说车轱辘话。当然老罗可以继续吹牛说，我有让你乐的能力，但我没空陪你玩。但结果就在那里，大家都有判断。老罗的朋友路金波，他的书《我的奋斗》、《生命不息，折腾不止》的出版者也承认老罗的相声水准下降了。当然，我要说，老罗的演讲水平比第二天360奇酷手机的产品经理周泓祎要强，周泓祎就像照着稿念的感觉一样，虽然他没拿稿。我是两家产品的用户，我觉得我的评价做到了不偏不倚。


发布会开始晚了将近50分钟，幻灯片里面有低级错误，比如重复的页面，错别字等，而这些发生在一直宣传认真的人和公司身上，不得不让人猜测这背后的故事或事故。有传说公司网站遭遇了DDOS攻击，幻灯片最终版本丢失了不得不用草稿等。传得邪乎的说有三百多页幻灯片是边讲边做的。老罗的微博回应了网站受到DDOS攻击是真的，其余的传言是假的。许岑也在微博上贴了一个长微博，闪烁其词地说了下幻灯片的问题。老罗成为一个优秀的企业家后，微博的钥匙是上交出去了的，所以我们也不知道哪个是真哪个是假。DDOS攻击就不见得是真。所谓受到DDOS攻击就是网站遭受大规模的访问不能处理从而不能提供服务的一种情况。有时是很难区分这些访问是正常的用户的访问还是恶意的攻击的。所以把网站不能服务说成DDOS攻击可能是个冠冕堂皇的理由，真实情况也许是锤子科技作为初创公司的实力和技术不足以承受老罗上千万粉丝的热情。至于说，幻灯片是边讲边做的，我当然是不信的，毕竟幻灯片不是流媒体。许岑在微博也说了，他有过利用在演讲过程中放映视频的间隙来微调幻灯片的想法，但是后来没有实施。


既然很多故事与幻灯片有关，下面我就围绕幻灯片说一说。老罗以往的演讲的幻灯片都是有老罗英语时代开始的同事和朋友许岑参与帮助做的。有由于时间紧迫做得不太如意的地方，但总体质量上乘，为老罗的演讲添色不少。许岑在淘宝教育的《keynote幻灯片制作教程》是销量第一的，如果采用其中的理念、审美和做事方式确实不应该出现本次发布会中的幻灯片水准。幻灯片对于老罗和锤子科技也许是添彩，而对于许岑可是相当长一段时期的孩子的奶粉钱和房租来源。所以以我的推测幻灯片不是出自许岑的手笔。我只举一个例子。开始时有一页幻灯片是很多行密集的多颜色的很小的文字从右向左飘，有点像黑客帝国中Matrix的效果，这不是许老师的审美。许老师知道哪些幻灯片是给人看的，哪些是配合演讲的。要让他评价的话，我估计是，唉呀喂，真吓人。这甚至也不是老罗的审美。奉行乔布斯极简主义设计的老罗，我想不出理由他用这么花哨的东西。


关于幻灯片，真实情况我猜测是这样的。一年来，许岑名义上是锤子科技的员工，实际上没有在锤子领工资，而只是作为老罗的朋友挂个名而已。而许岑的真实谋生手段是靠幻灯片教程。老罗也很仗义地推荐许岑的幻灯片教程，帮助其取得不错销量和一定的微博粉丝。外界普遍会认为这次老罗的幻灯片也会是由许岑操刀。但是实际上本次的幻灯片肯定是团队合作做出来的，毕竟他涉及视频的录制、图片的处理等，工作量还是很大的。而许老师刚录完吉他教程仓促地到锤子科技上班，其实是没有参与幻灯片的制作的。很可能许老师是在到达上海后和老罗一起到现场演练时，才看到最终的砸招牌的幻灯片。但也已经晚了。许老师确实想边讲边修改幻灯片，利用放映视频的空当替换，但最终没有采用他的方案，锤子科技和老罗选择了更稳妥的方案。


为什么号称认真的公司和人会发生这样的事呢，我猜只能用墨非定律来解释，当一件坏事可能会发生，就一定会发生。现实可能是网站的瘫痪，现场信号不好，幻灯片放映幕布的长宽比，现场灯光的明暗，老罗没喝足水，在上海吃小龙虾拉稀等因素的组合都导致了这场不可乐的发布会。


网上有传言老罗和许老师打起来了，许岑一怒之下毁掉了幻灯片，这我是不相信的。我瞎想一下真实情况可能是这样的。


许老师（下面简写为在平坦的路面上区折前行的美貌大王代替）：你还记得当初我找你的梦想是什么吗？
老罗（下面简写为龙哥）：滚犊子。有话直说。
大王：我找你是为了拍电影。电影不拍了，但你总知道什么是电影级的幻灯片吧？
龙哥：我开始做企业家以来就学会了妥协。 
大王：把你的逐字稿拿出来我看看，我对应着修改下幻灯片。
龙哥：没有逐字稿。

大王：这可是你教我的？！

龙哥：我要陪投资人吃饭，陪设计师讨论方案，陪员工加班，我都成三陪了我。
大王：幻灯片做成这样不要说是我做的。

龙哥：好的，发布会后我会说是我们的团队做的。

大王：不要因为走得太远就忘了当初为什么出发。
。。。


以上是我的瞎想，不要当真。看发布会没乐，自娱自乐。





版权声明：本文为博主原创文章，未经博主允许不得转载。

微信营销之《序言》



上一个十年是互联网时代；

这个十年是移动互联时代；

你准备好了吗？





亲，你好！




感觉多么熟悉的一句问候语，无论你开不开淘宝店，一句亲，就是淘时代标准的淘宝语，拉近了你和我的距离！


而微信从诞生，到今天微信数亿用户的扎堆儿，有先知先觉的众企业大小老板似乎又看到了无限商机，朋友圈“成功案例”漫天飞，诸多微信营销培训机构卖力炒作的时候，老板们几千、数万的学费投进去，几天课程下来，要么感觉理论太高、大、上，却不接地气；要么就是热血沸腾，招兵买马，准备用江湖大师的捷径招式完成跑马圈地，一统江湖。




自动加粉利器、产品刷烂朋友圈，积赞……，所有的“下三滥”招数使出浑身解数，全然不顾用户的反感，结果要么被微信官方处罚或者停止运营；要么因为用户腻烦而被拉黑。




结果是企业或者个人微商虽然获得了短期回报，某些技巧或方法过期失效，大家又开始郁闷……




为什么会出现这种情况？




根源不完全是因为某些微信营销培训机构都是大忽悠，而是我们总期望短期找到“葵花宝典”之类的武林秘笈，打通任督二脉，成为武林高手。




无论远古农耕时代，还是拥有高科技的今天，我们都深知：冰冻三尺，非一日之寒！




为什么别人的文章能刷爆朋友圈？

——背后是文案训练与心理学的结果！




为什么骗子卖“骗人的东西”却比我们“对得起天地良心的东西“卖得还好？

——背后是心理学支撑！




买电脑找老李，买汽车找老张！

——背后是信任！还因为老李和老张是产品专家！




我没有24小时让你的文章被1000万人浏览的技巧！


我也没有让你一个月增长10万粉丝的方法！




我们这里有的是：战略的思考，战术的实践，没有忽悠的内容，只有真才实料的干货。




让你推广费用极少的预算情况下，获得200-300人/天的粉丝量的把握还是有的，吹个牛容易，但很多大忽悠自己都不运营公众号，你认为可信吗？




我会结合实际的公众号与你一道分享其中的运营酸甜苦辣！




即使你跟我学完了，微信营销并没有结束，而是刚刚开始！




第1篇、移动互联网究竟是何方神圣还是一个妖魔鬼怪？







 

 


版权声明：本文为博主原创文章，未经博主允许不得转载。

Linux 远程和本地的一些解决方案
 有的小伙伴想Linux 远程登录 两台机器同时root登录，其实可以同时多个用户的。

Linux是多用户的多任务系统，可以同时多个用户登录到系统，也可以一个用户通过不同终端登录到一个系统执行不同的操作：

root@Saiver:~# w
 22:42:31 up 32 days,  6:03,  1 user,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    222.x.x.x 19:55    0.00s  0.33s  0.00s w
root@Saiver:~# who
root     pts/0        2012-12-08 19:55 (222.173.249.242)
root@Saiver:~# whoami
root
root@Saiver:~# 
我的服务器系统的提示信息，你可以使用 w who whoami 以及 ps 命令进行查看~



如果不习惯linux习惯了WINDOWS的用户可以用一些工具来做，比如PUTTY，WINSCP等。

如果你用的是LINUX或者MAC就没有必要安装这些软件了，直接用命令就OK了

1，SSH连接到远程机器上

-》ssh romet_username@remote_pc_ip

回车输入密码，就可以像操作本地机器一样操作远程机器了




2，SCP命令拷贝本地文件到远程机器上

-》scp local_file romet_username@remote_pc_ip:remote_dir

回车输入密码，就可以把文件COPY到远程机器了



mount远程目录并让本地非root用户可读可写 



远程与本地是两台linux机器，要实现如题效果，传统的nfs的mount方式虽然简单方便却不行
nfs的方式：
sudo mount -t nfs  -o rw 192.168.0.xx:/path  /mnt/test
在本地你会发现/mnt/test下的文件用户为nobody，普通用户可以读，但是非root用户写不了(不用sudo不用su)，
有的人想通过改/etc/fstab 或者远程主机的/etc/exports来实现，
我告诉你趁早放弃，nfs没有这个功能，它无法指定uid gid 用户名，密码。


cifs可以解决这个问题，通俗点讲就是samba的方式
远程主机安装samba服务
部分/etc/samba/smb.conf 内容
[testuser]
    path = /home/testuser/share
    read only = no
;    browseable = yes
    valid users = testuser
共享目录/home/testuser/share，有效用户为testuser


本地操作如下
安装 cifs-utils       sudo apt-get install  cifs-utils 神马的
命令id得到本地用户localuser的id,gid     

比如得到uid=1000(localuser) gid=1000(localuser)   

修改/etc/fstab
//192.168.0.xx/testuser/  /mnt/test/   cifs    rw,noauto,defaults,username=testuser,password=testuserpassword,uid=1000,gid=1000    0       0
然后sudo mount /mnt/test就会挂载，此时localuser翻身做主人了,注意为了安全fstab中可以不写password=testuserpassword这段，然后在mount时手动输入密码，如果要开机自动挂载，可以把noauto改成auto,或者在启动脚本中mount






WINDOWS和LINUX那么挂载如何实现呢？
一、功能说明：
     在Windows操作系统之间，可以通过映射网络驱动器的方式，将某个共享目录映射成一个磁盘文件系统，在Linux下，可以通过smbmount命令来实现相似的功能，将Windows的某个共享目录挂载到Linux下的某个目录下。
     测试平台： Red Flag DC5.0 x86-sp2  
                   Windows xp sp2
     当前测试条件：
         1、Windows和Linux共处于同一个局域网中，可以互相ping通，都未设置防火墙
         2、Windows的IP地址：192.168.0.103
         3、Linux的IP地址：192.168.0.150
         4、Windows上当前有如下共享：c盘，share（everyone具有读取权限）
         5、Windows上的用户有administrator（管理员组用户帐号），guest（当前未启用），没有root帐号
         6、Linux上安装有相关的RPM包：samba-client，它是Samba客户端工具，安装后可以使用smbmount命令
二、smbmount
    基本测试过程如下：
       语法：smbmount //IP地址/共享名 挂载点 -o 选项1,选项2……
     1、挂载c共享：
       [root@redflag ~]# mkdir /mnt/share
       [root@redflag ~]#  smbmount //192.168.0.103/c /mnt/share -o username=administrator
       Password:
       [root@redflag ~]#  umount /mnt/share               //卸载挂载点
     2、挂载temp共享（启用guest帐户）
       [root@redflag ~]#  smbmount //192.168.60.188/temp  /mnt/share
        Password:
    此时，未指定帐号和密码，则使用环境变量USER为帐号，使用环境变量PASSWD作为密码，因为Windows已经启用guest帐号，且temp共享为允许任何人读取，所以此次命令运行成功。
       [root@redflag ~]#  umount /mnt/share    //卸载挂载点
     3、挂载temp共享（未启用guest帐户）
       [root@redflag ~]#  smbmount //192.168. 0.103/temp ./temp
        Password:
        Anonymous login successful
        2068: tree connect failed: ERRDOS - ERRnoaccess (Access denied.)
        SMB connection failed
        此时，guest帐号被停用，所以连接失败。
     4、实现开机自动挂载
       为了使机器在启动的时候自动挂载Samba共享，修改/etc/fstab添加一行:
        //server/share /mount/point smbfs username=[username],password=[password] 0 0
       server是Samba服务器的名称或者IP地址。 share是Samba的共享目录。 /mount/point是本机挂载的目录。 username和passoword是访问Samba服务器的用户名和密码。 
三、mount命令
    基本的测试环境是一样的只是在命令上mount多加了一些参数。这里只介绍挂载c盘。
     挂载c共享：
     [root@redflag ~]#  mkdir /mnt/share
     [root@redflag ~]#  mount –t smbfs //192.168.0.103/c /mnt/share -o username=administrator
      Password:
     [root@redflag ~]#  umount /mnt/share
四、新版本的smb服务
    对于红旗Asianux3.0以及redhat Enterprise 5版本的linux系统，系统已经将smbmount这样的命令了而且-t smbfs也消失。以前的smbfs是为了和Windows好识别。smbfs协议改为cifs了，cifs才是正式的官方协议。
    范例：
     [root@redflag ~]# mount.cifs //IP/share  /point -o username=administrator%123456
     [root@redflag ~]# mount.cifs //192.168.2.230/job /mnt/share -o username=administartor%123456 



常用的命令：sudo
 mount.cifs //192.168.0.2/x ./y/ -o rw,uid=1000,gid=1000,username=administrator%""










linux下挂载（mount）光盘镜像文件、移动硬盘、U盘、Windows和NFS网络共享


linux是一个优秀的开放源码的操作系统，可以运行在大到巨型小到掌上型各类计算机系统上，随着 linux系统的日渐成熟和稳定以及它开放源代码特有的优越性，linux在全世界得到了越来越广泛的应用。现在许多企业的计算机系统都是由UNIX系 统、Linux系统和Windows系统组成的混合系统，不同系统之间经常需要进行数据交换。下面我根据自己的实际工作经验介绍一下如何在linux系统 下挂接(mount)光盘镜像文件、移动硬盘、U盘以及Windows网络共享和UNIX NFS网络共享。 

　　挂接命令(mount)

　　首先，介绍一下挂接(mount)命令的使用方法，mount命令参数非常多，这里主要讲一下今天我们要用到的。

　　命令格式：

　　mount [-t vfstype] [-o options] device dir

　　其中：

　　1.-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：

　　光盘或光盘镜像：iso9660

　　DOS fat16文件系统：msdos

　　Windows 9x fat32文件系统：vfat

　　Windows NT ntfs文件系统：ntfs

　　Mount Windows文件网络共享：smbfs

　　UNIX(LINUX) 文件网络共享：nfs

　　2.-o options 主要用来描述设备或档案的挂接方式。常用的参数有：

　　loop：用来把一个文件当成硬盘分区挂接上系统

　　ro：采用只读方式挂接设备

　　rw：采用读写方式挂接设备

　　iocharset：指定访问文件系统所用字符集

　　3.device 要挂接(mount)的设备。

　　4.dir设备在系统上的挂接点(mount point)。

　　挂接光盘镜像文件

　　由于近年来磁盘技术的巨大进步，新的电脑系统都配备了大容量的磁盘系统，在Windows下许多人都习惯把软件和资料做成光盘镜像文件通过虚拟 光驱来使用。这样做有许多好处：一、减轻了光驱的磨损;二、现在硬盘容量巨大存放几十个光盘镜像文件不成问题，随用随调十分方便;三、硬盘的读取速度要远 远高于光盘的读取速度，CPU占用率大大降低。其实linux系统下制作和使用光盘镜像比Windows系统更方便，不必借用任何第三方软件包。

　　1、从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。

　　　#cp /dev/cdrom /home/sunky/mydisk.iso 或

　　　#dd if=/dev/cdrom of=/home/sunky/mydisk.iso

　　　注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/sunky/mydisk.iso

　　2、将文件和目录制作成光盘镜像文件，执行下面的命令。

　　　#mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir

　　　注：这条命令将/home/sunky/mydir目录下所有的目录和文件制作成光盘镜像文件/home/sunky/mydisk.iso，光盘卷标为：mydisk

　　3、光盘镜像文件的挂接(mount)

　　　#mkdir /mnt/vcdrom

　　　注：建立一个目录用来作挂接点(mount point)

　　　#mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom

　　　注：使用/mnt/vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。




　　挂接移动硬盘

　　对linux系统而言，USB接口的移动硬盘是当作SCSI设备对待的。插入移动硬盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。

　　[root at pldyrouter /]# fdisk -l

　　Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes

　　255 heads, 63 sectors/track, 8924 cylinders

　　Units = cylinders of 16065 * 512 = 8225280 bytes

　　Device Boot Start End Blocks Id System

　　/dev/sda1 1 4 32098+ de Dell Utility

　　/dev/sda2 * 5 2554 20482875 7 HPFS/NTFS

　　/dev/sda3 2555 7904 42973875 83 Linux

　　/dev/sda4 7905 8924 8193150 f Win95 Ext'd (LBA)

　　/dev/sda5 7905 8924 8193118+ 82 Linux swap

　　在这里可以清楚地看到系统有一块SCSI硬盘/dev/sda和它的四个磁盘分区/dev/sda1 -- /dev/sda4, /dev/sda5是分区/dev/sda4的逻辑分区。接好移动硬盘后，再用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况

　　[root at pldyrouter /]# fdisk -l

　　Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes

　　255 heads, 63 sectors/track, 8924 cylinders

　　Units = cylinders of 16065 * 512 = 8225280 bytes

　　Device Boot Start End Blocks Id System

　　/dev/sda1 1 4 32098+ de Dell Utility

　　/dev/sda2 * 5 2554 20482875 7 HPFS/NTFS

　　/dev/sda3 2555 7904 42973875 83 Linux

　　/dev/sda4 7905 8924 8193150 f Win95 Ext'd (LBA)

　　/dev/sda5 7905 8924 8193118+ 82 Linux swap

　　Disk /dev/sdc: 40.0 GB, 40007761920 bytes

　　255 heads, 63 sectors/track, 4864 cylinders

　　Units = cylinders of 16065 * 512 = 8225280 bytes

　　Device Boot Start End Blocks Id System

　　/dev/sdc1 1 510 4096543+ 7 HPFS/NTFS

　　/dev/sdc2 511 4864 34973505 f Win95 Ext'd (LBA)

　　/dev/sdc5 511 4864 34973473+ b Win95 FAT32

　　大家应该可以发现多了一个SCSI硬盘/dev/sdc和它的两个磁盘分区/dev/sdc1?、/dev/sdc2,其中/dev/sdc5是/dev/sdc2分区的逻辑分区。我们可以使用下面的命令挂接/dev/sdc1和/dev/sdc5。

　　　#mkdir -p /mnt/usbhd1

　　　#mkdir -p /mnt/usbhd2

　　　注：建立目录用来作挂接点(mount point)

　　　#mount -t ntfs /dev/sdc1 /mnt/usbhd1

　　　#mount -t vfat /dev/sdc5 /mnt/usbhd2

　　　注：对ntfs格式的磁盘分区应使用-t ntfs 参数，对fat32格式的磁盘分区应使用-t vfat参数。若汉字文件名显示为乱码或不显示，可以使用下面的命令格式。

　　　#mount -t ntfs -o iocharset=cp936 /dev/sdc1 /mnt/usbhd1

　　　#mount -t vfat -o iocharset=cp936 /dev/sdc5 /mnt/usbhd2

　　linux系统下使用fdisk分区命令和mkfs文件系统创建命令可以将移动硬盘的分区制作成linux系统所特有的ext2、ext3格式。这样，在linux下使用就更方便了。使用下面的命令直接挂接即可。

　　　#mount /dev/sdc1 /mnt/usbhd1




　　挂接U盘

　　和USB接口的移动硬盘一样对linux系统而言U盘也是当作SCSI设备对待的。使用方法和移动硬盘完全一样。插入U盘之前，应先用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。

　　[root at pldyrouter root]# fdisk -l

　　Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes

　　255 heads, 63 sectors/track, 8924 cylinders

　　Units = cylinders of 16065 * 512 = 8225280 bytes

　　Device Boot Start End Blocks Id System

　　/dev/sda1 1 4 32098+ de Dell Utility

　　/dev/sda2 * 5 2554 20482875 7 HPFS/NTFS

　　/dev/sda3 2555 7904 42973875 83 Linux

　　/dev/sda4 7905 8924 8193150 f Win95 Ext'd (LBA)

　　/dev/sda5 7905 8924 8193118+ 82 Linux swap

　　插入U盘后，再用fdisk –l 或 more /proc/partitions查看系统的硬盘和硬盘分区情况。

　　[root at pldyrouter root]# fdisk -l

　　Disk /dev/sda: 73 dot 4 GB, 73407820800 bytes

　　255 heads, 63 sectors/track, 8924 cylinders

　　Units = cylinders of 16065 * 512 = 8225280 bytes

　　Device Boot Start End Blocks Id System

　　/dev/sda1 1 4 32098+ de Dell Utility

　　/dev/sda2 * 5 2554 20482875 7 HPFS/NTFS

　　/dev/sda3 2555 7904 42973875 83 Linux

　　/dev/sda4 7905 8924 8193150 f Win95 Ext'd (LBA)

　　/dev/sda5 7905 8924 8193118+ 82 Linux swap

　　Disk /dev/sdd: 131 MB, 131072000 bytes

　　9 heads, 32 sectors/track, 888 cylinders

　　Units = cylinders of 288 * 512 = 147456 bytes

　　Device Boot Start End Blocks Id System

　　/dev/sdd1 * 1 889 127983+ b Win95 FAT32

　　Partition 1 has different physical/logical endings:

　　phys=(1000, 8, 32) logical=(888, 7, 31)

　　系统多了一个SCSI硬盘/dev/sdd和一个磁盘分区/dev/sdd1,/dev/sdd1就是我们要挂接的U盘。

　　#mkdir -p /mnt/usb

　　注：建立一个目录用来作挂接点(mount point)

　　#mount -t vfat /dev/sdd1 /mnt/usb

　　注：现在可以通过/mnt/usb来访问U盘了, 若汉字文件名显示为乱码或不显示，可以使用下面的命令。

　　#mount -t vfat -o iocharset=cp936 /dev/sdd1 /mnt/usb

　　挂接Windows文件共享

　　Windows网络共享的核心是SMB/CIFS，在linux下要挂接(mount)windows的磁盘共享，就必须安装和使用samba 软件包。现在流行的linux发行版绝大多数已经包含了samba软件包，如果安装linux系统时未安装samba请首先安装samba。当然也可以到 www.samba.org网站下载......新的版本是3.0.10版。

　　当windows系统共享设置好以后，就可以在linux客户端挂接(mount)了，具体操作如下：

　　# mkdir –p /mnt/samba

　　注：建立一个目录用来作挂接点(mount point)

　　# mount -t smbfs -o username=administrator,password=pldy123 //10.140.133.23/c$ /mnt/samba

　　注：administrator 和 pldy123 是ip地址为10.140.133.23 windows计算机的一个用户名和密码，c$是这台计算机的一个磁盘共享

　　如此就可以在linux系统上通过/mnt/samba来访问windows系统磁盘上的文件了。以上操作在redhat as server 3、redflag server 4.1、suse server 9以及windows NT 4.0、windows 2000、windows xp、windows 2003环境下测试通过。

　　挂接UNIX系统NFS文件共享

　　类似于windows的网络共享，UNIX(Linux)系统也有自己的网络共享，那就是NFS(网络文件系统)，下面我们就以SUN Solaris2.8和REDHAT as server 3 为例简单介绍一下在linux下如何mount nfs网络共享。

　　在linux客户端挂接(mount)NFS磁盘共享之前，必须先配置好NFS服务端。

　　1、Solaris系统NFS服务端配置方法如下：

　　　(1)修改 /etc/dfs/dfstab, 增加共享目录

　　　　　　share -F nfs -o rw /export/home/sunky

　　　(2)启动nfs服务

　　　　　　# /etc/init.d/nfs.server start

　　　(3)NFS服务启动以后，也可以使用下面的命令增加新的共享

　　　　　　# share /export/home/sunky1

　　　　　　# share /export/home/sunky2

　　　注：/export/home/sunky和/export/home/sunky1是准备共享的目录

　　2、linux系统NFS服务端配置方法如下：

　　　(1)修改 /etc/exports,增加共享目录

　　/export/home/sunky 10.140.133.23(rw)

　　/export/home/sunky1 *(rw)

　　/export/home/sunky2 linux-client(rw)

　　　注：/export/home/目录下的sunky、sunky1、sunky2是准备共享的目录，10.140.133.23、*、 linux-client是被允许挂接此共享linux客户机的IP地址或主机名。如果要使用主机名linux-client必须在服务端主机 /etc/hosts文件里增加linux-client主机ip定义。格式如下：

　　　10.140.133.23 linux-client

　　　(2)启动与停止NFS服务

　　　/etc/rc.d/init.d/portmap start (在REDHAT中PORTMAP是默认启动的)

　　　/etc/rc.d/init.d/nfs start 启动NFS服务

　　　/etc/rc.d/init.d/nfs stop 停止NFS服务

　　　注：若修改/etc/export文件增加新的共享，应先停止NFS服务，再启动NFS服务方能使新增加的共享起作用。使用命令exportfs -rv也可以达到同样的效果。

　　3、linux客户端挂接(mount)其他linux系统或UNIX系统的NFS共享

　　　# mkdir –p /mnt/nfs

　　　注：建立一个目录用来作挂接点(mount point)

　　　#mount -t nfs -o rw 10.140.133.9:/export/home/sunky /mnt/nfs

　　　注：这里我们假设10.140.133.9是NFS服务端的主机IP地址，当然这里也可以使用主机名，但必须在本机/etc/hosts文件里增加服务端ip定义。/export/home/sunky为服务端共享的目录。

　　如此就可以在linux客户端通过/mnt/nfs来访问其它linux系统或UNIX系统以NFS方式共享出来的文件了。以上操作在 redhat as server 3、redflag server4.1、suse server 9以及Solaris 7、Solaris 8、Solaris 9 for x86&sparc环境下测试通过。

权限问题：

假設 server 端的使用者 jack, user id 為 1818, gid 為 1818, client 端也有一個使用者 jack，但是 uid 及 gid 是 1818。client 端的 jack    希望能完全讀寫 server 端的 /home/jack 這個目錄。server 端的 /etc/exports 是

   這樣寫的：

      /home/jack *(rw,all_squash,anonuid=1818,anongid=1818)

   這個的設定檔的意思是，所有 client 端的使用者存取 server 端 /home/jack 這

   目錄時，都會 map 成 server 端的 jack (uid,gid=1818)。我 mount 的結果是

   1. client 端的 root 可以完全存取該目錄, 包括讀、寫、殺……等

   2. client 端的 jack (uid,gid=1818) 我可以做：

    rm -rf server_jack/*
    cp something server_jack/
    mkdir server_jack/a



转载出处：http://blog.csdn.net/djy1992/article/details/47972129


版权声明：本文为博主原创文章，未经博主允许不得转载。

开始新的征程
打工是一种状态，当老板也是一种状态，虽然打工在绝大多数情况下都比当老板轻松，但还是决定在自己熟悉的领域闯一闯。混了这么多年，算起来是比较失败的，唯一值得安慰的是我还是能追随自己的内心所想，做自己想做的事情。公司注册已经基本完成，9月1号正式运营，目标已经确定，剩下的就是去做。这个博客我还是会时常更新，但对于技术，该写的都写得差不多了，后面的文章会偏向于业务和市场，希望能对大家有用。也欢迎志同道合者一起合作共事。

版权声明：本文为博主原创文章，未经博主允许不得转载。

排列与组合的实现
排列与组合，递归实现
// Permutation and Combination.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include<vector>
#include<set>
#include<iostream>

using namespace std;

vector<vector<int>>aaa;
set<set<int>>solu;

void do_once(vector<int>&selected, vector<int>&remain)
{
	if (remain.empty())
	{
		aaa.push_back(selected);
		for (int i = 0; i < selected.size(); i++)
			cout << selected[i] << ",";
		cout << endl;
		return;
	}
	for (int i = 0; i < remain.size(); i++)
	{
		vector<int>se = selected,re=remain;
		se.push_back(re[i]);
		re.erase(re.begin()+i);
		do_once(se, re);
	}
}

void Permutation(int*input, int len)//全排列
{
	aaa.clear();
	vector<int>remain, selected;
	for (int i = 0; i < len; i++)
		remain.push_back(input[i]);
	do_once(selected, remain);
	cout << "共有"<<aaa.size()<<"种排列" << endl;
}




void select(set<int>&selected, vector<int>&remain, int toselect)
{
	if (selected.size()==toselect)
	{
		if (solu.find(selected) == solu.end())
		{
			solu.insert(selected);
			for (set<int>::iterator it = selected.begin(); it != selected.end(); it++)
				cout << *it << ",";
			cout << endl;
		}
		return;
	}
	for (int i = 0; i < remain.size(); i++)
	{
		vector<int> re = remain;
		set<int>se = selected ;
		se.insert(re[i]);
		re.erase(re.begin() + i);
		select(se, re,toselect);
	}
}
void Combination(int*input,int len,int toselect)//组合
{
	solu.clear();
	vector<int>remain;
	set<int>selected;
	for (int i = 0; i < len; i++)
		remain.push_back(input[i]);
	select(selected, remain, toselect);
	cout << "共有" << solu.size() << "种组合" << endl;
}

int _tmain(int argc, _TCHAR* argv[])
{
	int aa[5] = { 0, 1, 2 ,3,4};
	Permutation(aa, 5);

	//Combination(aa, 5, 2);

	system("pause");
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

TQ2440 学习笔记—— 7、NOR Flash 和 NAND Flash
非易失闪速存储器Flash 具有速度快、成本低、密度大的特点。
Flash 存储器主要有 NOR Flash 和 NAND Flash两种类型，总的来说， NOR 型比较适合存储程序代码，NAND 型则可用做大容量数据存储。


1、NOR 型 Flash 存储器
  NOR Flash 技术是由Intel 公司于1988年首先开发，它的出现彻底改变了原先由EPROM和EEPROM一统天下的局面。
NOR 的特点是芯片内执行（XIP，eXecute In Place），这样应用程序就可以直接在Flash 闪存内运行，不必再把代码读到系统的RAM中。NOR 的传输效率很高，但写入速度与擦除速度很低。NOR Flash 就是一个掉电后也不会丢失数据的SRAM。


2、NAND 型 Flash 存储器
NAND Flash 是当今市场上最主要的非易失大容量闪存。1989年，东芝公司发表了NAND flash结构，强调降低每比特的成本，更高的性能，并且象磁盘一样可以通过接口轻松升级。

NAND 结构能提供极高的存储密度，并且写入和擦除速度也很快。NAND Flash 具有非易失性、电可擦除性、可重复编程以及高密度、低功耗等特点。


3、NOR Flash 和 NAND Flash 的对比




NOR   Flash

 
NAND Flash  


接口时序同ＳＲＡＭ，易使用 
地址／数据线复用，数据位较窄


读取速度快
读取速度较慢


擦除速度慢，以６４～１２８ＫＢ的块为单位
擦除速度快，以８～３２ＫＢ的块为单位


写入速度慢（因为一般要先擦除）
写入速度快


随机存取速度较快，支持ＸＩＰ，适合代码存储。在嵌入式系统中，常用于存放引导程序＼根文件系统等
顺序读取速度快，随机存取速度慢，适用于数据存储。在嵌入式系统中，常用于存放文件系统等


单片容量较小，１～３２ＭＢ
单片容量较大８～１２８ＭＢ，提高了单元密度


最大擦写次数１０万次
最大擦写次数１００－１０００万次


 
 



如果需要在ＮＡＮＤ器件上运行代码，需要驱动程序的支持。在Ｌｉｎｕｘ下也就是内存技术驱动程序ＭＴＤ


４、TQ2440  NOR Flash 和 NAND Flash 启动
开发板在裸机的情况下就是相当于直接操作单片机，没有操作系统，变成操作系统需要分别烧入：引导程序bootloader、内核kernel、文件系统。
bootloader 是引导CPU从哪里开始运行的，它的启动过程分为两个阶段。


NOR Flash 启动过程
代码运行从0x0000 0000开始，从NOR Flash 启动时，0x0000
 0000这个地址就映射在 NOR Flash 上，所以CPU 可以直接从 NOR Flash 开始运行。一般bootloader 这段代码存放在NOR Flash 上。


NAND Flash 启动过程
NAND Flash 控制器自动把 NAND
 Flash 存储器前的 4K 载到Stepping stone (内部SRAM缓冲器)，并把0x0000 0000 设置为SRAM 的起始地址，CPU从内部ＳＲＡＭ　的0x0000
 0000开始启动，这个过程不需要程序干涉。

NANDFlash控制器

NANDFlash控制器自动把nandflash存储器的前4K载到Steppingstone（内部SRAM缓冲器），并把0x00000000S设置为内部SRAM的起始地址，cpu从内部SRAM的0x00000000开始启动，这个过程不需要程序干涉。程序员需要完成的工作就是将最核心的代码放在NAND
 Flash 的前4K 中。4K代码要完成S3C2440 的核心配置以及启动代码的剩余部分拷贝到SRAM中。

版权声明：本文为博主原创文章，未经博主允许不得转载。

c++下halcon配置
1.新建一个C++工程，这里命名为Hello
2.将安装程序HDevelop下的文件夹“bin”、“include”、“lib”全都拷贝到C++工程的Hello.sln所在的同一文件夹下。
3.配置C++工程的“配置属性”的“VC++目录”，“包含目录”为“..\include\cpp”。“库目录”为“..\include”。
4.“链接器” 下的“输入”的 “附加依赖项”  添加 “halconcpp.lib”
5.将“halcon.dll”和“halconcpp.dll”以及“license.dat”文件，拷贝到C++工程的“Dedug”文件夹下。
6.移植到另一台机器中的时候，要在另一台机器路径C:\Program Files\MVTec\Halcon\下加入本台机器安装的HDevelop的help文件夹。 
例如：我的机器C:\Program Files\MVTec\HALCON-10.0\help 
我在另一台机器下也按着这个路径建立相同文件夹的名字，把我的机器C:\Program Files\MVTec\HALCON-10.0\help下的所以文件拷贝到另一台机器中。
7.配置完成，运行。。。。。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

VMware11.0.0安装（图解）
一、下载
版本：VMware11.0.0 
百度云盘：链接：http://pan.baidu.com/s/1qW5jQiw 密码：01yz 
官网下载：http://www.vmware.com/products/workstation/workstation-evaluation 
序列号：  
   M50AC-J034J-08L8A-03ARM-3D14A  评估版
   1F04Z-6D111-7Z029-AV0Q4-3AEH8  永久版
二、安装
 
 
 
 
 
 
 
 
 
 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

自己花了一个星期用java写的网络题库程序
完整程序的下载地址：http://download.csdn.net/detail/m47838704/9043571

用的java的socket+多线程+mysql编程（如果连接数量大的话用java的NIO）
服务器端是java写的运行在unix上多线程，客户端也是用java写的也是多线程，中间的通信协议是通过传输序列化的对象来实现的，主要结构是“包头”+“包体”的结构，利用循环队列实现消息缓冲区。（后面写了一个App版本的，但是不要截图）
下面是客户端和服务器端的代码结构


下面是socket的序列化对象（包头+包体）


下面是服务器端程序截图



下面是客户端界面（客户端也是多线程——>这样客户端就不再是请求响应了，那样客户端就可以接受服务器端主动推送的消息了，在这个过程中要注意界面更新的问题，仔细去了解一下java的界面绘制线程安全方面的问题）









版权声明：本文为博主原创文章，未经博主允许不得转载。

LeetCode268——Missing Number

Given an array containing n distinct numbers taken from 0,
 1, 2, ..., n, find the one that is missing from the array.

For example,
Given nums = [0, 1, 3] return 2.

Note:
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?

Credits:
Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

实现：

class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = (1+nums.size())*nums.size()/2;
        for (int i = 0; i < nums.size(); i++) {
            n -= nums[i];
        }
        return n;
    }
};


版权声明：本文为博主原创文章，未经博主允许不得转载。

几个将汉字转换成拼音的在线工具
编程时，经常遇到由于汉字兼容性差带来的困扰。解决的方法之一就是使用汉语拼音来代替汉字，（使用英语翻译比较费时）。将汉语转换成拼音的方法有很多，可以通过编程实现，比如借助于pinyin package，也可以使用现在工具，直接将汉语转化为拼音。需要注意的是，在汉字转化成拼音时，需要注意尽量不要保留声调，因为声调的兼容性也比较差。
支持不带声调的汉字转化成拼音的在线工具如下：
http://www.atool.org/hanzi2pinyin.php

http://zhongwenzhuanpinyin.51240.com/

仅支持带声调的汉字转化成拼音的在线工具如下：
http://xh.5156edu.com/conversion.html

http://www.aies.cn/pinyin.htm


版权声明：本文为博主原创文章，未经博主允许不得转载。

Hadoop（一）理论体系
    随着人民生活水平的提高，随着各种各类数据指数级的增长，“大数据”、“互联网+”、“云时代”等等各种名词已经成为当今社会的潮流，各种数据分析建立在TB,PB,EB,甚至ZB和YB数量级上，以前看似遥不可及，现在已经屡见不鲜。而如何很好的利用好这些数据，使之为我们产生巨大的商业价值，已经是当今IT界的精英们不断突破的方向。而Hadoop则是如今处理这些问题，最基础，最主流，开源并不断改进的一款分布式系统基础架构。好，我也来凑凑热闹，这篇简单讲述Hadoop的理论方面。   一，Hadoop是什么？   Hadoop是一个由Apache基金会所提高的分布式系统基础架构，核心由HDFS(分布式文件系统，HadoopDistributed File System)和MapReduce(Map分组，Reduce合并，分而治之，并而统一)组成。简单称之为 “分布式文件系统+计算框架”。     二，Hadoop历史：    1，思想之源：来自于Google的低成本之道，通过利用普通的PC机的累加，来避免超级计算机的高成本支出，并且极易扩展。再加上Google的网页搜索大量的计算量，大量的数据量，由最初的Page Rankd，到后来的map-reduce分而治之的计算思想，而将大量的计算量分到每台PC机上，Google设计了HDFS的前身版GFS（Google FileSystem）。也就是由Google各种思想，各种设计方案的启发，Hadoop随之而诞生。    2，项目起源：    Hadoop由 Apache Software Foundation公司于2005年秋天作为Lucene的子项目Nutch的一部分正式引入。2006年3月份，Map/Reduce和 Nutch Distributed File System(NDFS) 分别被纳入称为 Hadoop 的项目中。而它的名字来源于Doug Cutting儿子的玩具大象。    3，目前：商业化    目前有很多公司开始提供基于Hadoop的商业软件、支持、服务以及培训。Cloudera是一家美国的企业软件公司，该公司在2008年开始提供基于Hadoop的软件和服务。GoGrid是一家云计算基础设施公司，在2012年，该公司与Cloudera合作加速了企业采纳基于Hadoop应用的步伐。Dataguise公司是一家数据安全公司，同样在2012年该公司推出了一款针对Hadoop的数据保护和风险评估。     三，优点：    1，高可靠性：因为它假设计算元素和存储会失败，因此它维护多个工作数据副本，确保能够针对失败的节点重新分布处理。    2，高扩展性：Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。    3，高效性：Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。    4，高容错性：Hadoop能够自动保存数据的多个副本，并且能够自动将失败的任务重新分配。    5，低成本：与一体机、商用数据仓库等相比，hadoop是开源的，项目的软件成本因此会大大降低，硬件只是需要普通的PC机即可达到，因此总成本大大降低。    此外：Hadoop带有用Java语言编写的框架，因此可以在linux生产平台上非常理想的运行。     四，整体架构：    Hadoop知识框架由底层的分布式文件结构做基础，NOSQL数据HBase做数据库，MapReduce做计算框架，还有Pig，Hive，Mahout各种工具。后边回一一进行介绍。    下边是Hadoop的linux集群架构图，可以不断进行扩展数据节点：    其实，Hadoop的思想就是“团结”。如今一直在强调合作，一个人的力量再大，智慧再高，精力再强，也不如一群人一起的力量大。更形象一点就像管理：对于公司由大领导（Master）进行分配任务，人员调配，每位员工（slave）努力完成自己负责的工作，小目标，整合起来就完成公司的大目标，使公司整体高效的向前前进。可见软件的演进越来越接近人类的思想。从面向过程——》面向对象——》面向服务,再到Hadoop这个具体例子……

版权声明：本文为博主原创文章，未经博主允许不得转载。

从恶意程序对LNK格式的利用方法看防护趋势
目录
1LNK文件简介
2LNK在恶意程序中的利用方式
2.1曾经的LNK漏洞
2.2隐藏链接真实对象
2.3辅助恶意程序运行
3博弈趋势
利用移动存储设备进行传播的恶意程序与杀软博弈趋势分析:

障眼法伪装文件夹.以及附加GUID到文件后.
逐渐脱离PE文件向脚本发展以期绕过安全软件的防护.
可能的其它利用,模拟键盘,鼠标.

正文
1LNK文件
文件快捷方式又称为Shell links,从Win95被微软引进.它是Windows资源管理器的扩展.用于链接到本地文件(夹)或者URL指向的网络内容. 
由于默认的注册表设置,即使“隐藏扩展名已知文件类型”未选中的文件类型选项，仍然不会显其扩展名. 
更多关于LNK的细节和历史变动你可以参看:

https://en.wikipedia.org/wiki/File_shortcut

文件格式请参看这里:

快捷方式文件格式详解中文版 
http://xcf007.blog.51cto.com/471707/367275/
LNK格式解析-恶意利用关键 
http://wenku.baidu.com/link?url=KD0Ua8LmtJx6NUqDv7eRgLMAOPD6U40Q4FmYxlANXR6WVr0grzLeM4v_j0EOOB5c_OOzQmQZysuuIvZQ3EnXIXjV6nHWuR0tnY_2Sx9IqLe

2LNK文件在恶意程序中的利用方式
2.1曾经的LNK漏洞
漏洞曝光: 
2010年7月16日，Windows快捷方式自动执行0day漏洞[CVE-2010-2568]（微软安全知识库编号:2286198）被披露，很快网上已经可以找到利用这个漏洞攻击的样本。利用Windows快捷方式自动执行0day漏洞可以做到：看一眼恶意软件就中毒，而根本不需要去执行它。
触发原理:

Shell32.dll在处理lnk文件的时候要把它的图标显示出来，对于一般文件应该是从Icon filename string里面解析，但对于文件后面没有Icon filename string结构的控制面板快捷方式，是直接从0x7A那里的iconindex来解析。当这个iconindex是0的时候，会去加载cpl文件，调用CPlApplet接口，这样就存在执行DLL中代码的问题.-LNK快捷方式漏洞利用方式 exp制作教程
当Shell32.dll解析到这串编码的时候,会认为这个“快捷方式”依赖一个系统控件(dll文件),于是将这个“系统控件”加载到内存中执行。如果这个“系统控件”是病毒,那么Windows在解析这个lnk(快捷方式)文件时,相当于把潜伏的病毒激活.-LNK快捷方式漏洞利用方式 exp制作教程

2.2隐藏链接真实对象
我见到这种方式是源自于一种游戏保护.通过构建自己的LNK文件达到实际指向目标与”打开文件位置”不同.以期望达到误导游戏破解者的目的.
这种方式最早被应用在病毒对LNK文件的修改.即使拥有一定计算机知识的用户也难以从快捷方式发现病毒的执行流程.通常此种病毒会在运行病毒体后,继续运行LNK所指向的原始文件,以达到掩人耳目的目的.
.lnk 文件格式 
               +—————————+ 
               | lnk file header              | 
               +—————————+ >——. 
               | Shell Item Id List         |               | 
               +—————————+         | 
               | File location info         |               | 
               +—————————+         | 
               | Description string         |         | 
               +—————————+        — 
               | Relative path string       |  | 
               +—————————+        — 
               | Working directory string   |         | 
               +—————————+         | 
               | Command line string        |         | 
               +—————————+         | 
               | Icon filename string       |         | 
               +—————————+ >——. 
               | Extra stuff                | 
               +—————————+ 
来自于:LNK文件格式解析
2.3辅助恶意程序运行
前段时间从友友的U盘中发现的样本.特点是: 
1. 原移动磁盘中的文件被隐藏.存在同名LNK文件. 
2. LNK文件运行后,被隐藏的文件被执行.
让我们看一下这个快捷方式是如何执行恶意程序和执行原文件的:


我们使用利器C32ASM观察该LNK文件的16进制形式,如图:

上面的内容等同于:
C:\windows\system32\cmd.exe /c start uzgbtymhqo.vbs&start OD-VM.zip&exit
我们看到,如果打开这个LNK会触发以下操作:

隐藏方式执行cmd
借助cmd执行名为:uzgbtymhqo.vbs的脚本文件.
打开被隐藏的原文件:OD-VM.zip
退出cmd.

按图索骥,移动硬盘下面的vbs脚本被翻找出来:

这真是令人纠结的事情,看着超长的函数名和变量名. 
让我们沉下心来不能中了恶意程序作者的圈套,大量形如”Jw==#PA==#”的字符串意味着恶意程序作者似乎使用了一种Base64加密的算法.
vbs文件后面的几个函数正是Base64标准解密的过程,通过将”#”相互隔离的字符放在数组中.循环对此数组进行解密并拼装.然后executeGlobal执行.
经过一番解密,我们得到了如下内容:

具有良好注释的脚本病毒已经被还原了出来,在这个463行代码的vbs中,可以看出脚本病毒的威力丝毫不逊于二进制恶意程序.
解密后全部的内容限于篇幅放在了样本包中.
本小节所涉及的所有样本文件已经被打包. 
下载链接: 
http://download.csdn.net/detail/dalerkd/9044907
密码:infected
3博弈趋势
利用移动存储设备进行传播的恶意程序与杀软博弈趋势分析:

障眼法伪装文件夹.以及附加GUID到文件后. 
通过以相同文件名等方式欺骗用户点击.
逐渐脱离PE文件向脚本发展以期绕过安全软件的防护. 
由于当今绝大多数安全软件对Autorun.inf启动方式的拦截.以及对由可移动磁盘发起的进程请求的严密监视.致使恶意程序开始利用其它低敏感程序和各种漏洞作为执行体的先头部队.来达到感染新机器的目的.
脚本恶意程序及其他建立在运行库上的高级语言程序在感染体的传播和伪装上有着传统PE恶意程序不具有优势.

作者希望看到您的留言,关于文章涉及技术的讨论和看法: 
您可以点顶对作者进行鼓励: 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，在注明作者和来源的情况下可自由转载。

关于const的底层实现
1. 对于直接已知值的int,long,short,char 类型以及其unsigned版本,即 const int a=1; 这
种,编译器编译程序之后,程序中所有a出现的地方,全部自动替换成1. 所以,就出现了对于
 *b=3 ,在 const int a=1;中不会修改a,而在 const int a=c; 中则会修改 a的情况.
int main()
{
const int a = 1;
int *b = (int *)&a;
*b = 3;
printf("%d %d\n", a, *b);

return 0;
}




2.对于字符串. 类似 const char *a="abc"; 这种,同样是不能修改的,不过原因就不再是上
面那个,而是因为这个 "abc" 在编译之后是放在程序的"常量段",这部分是执行文件的一部
分,运行期间不可修改,如果强制修改,就会出现 内存读写错误:0x000005不可写 这种错误.






3. 
*b=3 会修改const的限制,这个限制只是编译期间限制,运行期间不受影响.对于上面没
有提到的类型(包括float,double,以及自定义类型),都会作这种处理.


int main()
{
    int c = 2;
    const int a = c;
    int *b = (int *)&a;
    *b = 3;
    printf("%d %d\n", a, *b);
    return 0;
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

Win  10生态圈初现端倪

           8月26日，微软高级副总裁Yusuf
 Medhi（1992-1996，曾担任开发Win3.1和Won95的重要角色）又出来说话了。他指出，截止到8月26日，Win10实际装机量已经超过7,500万台，运行在9,000多种不同型号的硬件设备上，分布在全球192个国家。这是最权威的数字。



Medhi指出：平均而言，按照每台设备计算，Win10商店应用程序下载量是Win8的6倍，由此，吸引了更多的软件开发商参与Win10应用程序的开发。最有意思的是，在Win10发布后的一个月之内，个人助理Cortana表现非常活跃，一共讲了50万个笑话。



由此可见，在Win10发布之后的短短一个月内，一个不大不小的Win10生态圈研究形成，发展势头良好。回顾国内，国产操作系统整天瞎嚷嚷，十几年了，不见成效。



值得一提的是，微软个人助理Cortana很有“能耐”，会预测世界杯（World
 Cup）锦标赛的比赛名次。用历史数据检验，Cortana的预测从来不错！有意思。



在Win10生态圈中，个人助理Cortana是一个大明星，其知名度逐渐上升。这其中的奥秘就是微软公司多年来对人工智能（AI）技术潜心研究的丰硕成果。在我看来，Win10操作系统是普及人工智能知识的好教材。活生生的Cortana，会讲笑话，逗人快乐，这有什么不好呢？



袁萌 8月27日




版权声明：本文为博主原创文章，未经博主允许不得转载。

不求甚解与求甚解的阶段区分
前几日砍瓜切菜般搭建了一个简单的网站，之后便进入一段目标迷茫期，同时也深知自己立足未稳，基础未牢；往前走又有诸多岔路口，毫无疑问会分散自己本就不多的精力。
我是继续不求甚解地走下去：用同样的手法搞定CSS、JAVASCRIPT等等或是退回去，求甚解Python和Django？
其实不冲突，前提是你要知道自己内心惶恐的原因并且解决。
知此，你才能够明辨何时不求甚解，何时求甚解。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Contest Hunter - OVOO
题意：
给出一颗有根树，每次可以从树上取包括根节点的一个连通块；
定义连通块的权值为块内边的权值之和；
询问第k小的连通块的权值是多少；
n<=100000，k<=100000；
此题为CH弱省胡策#1T3；


题解：
PoPoQQQ大爷好神！
这道题也是利用A*搜索来求K大值，但是状态比较难以表示；
先考虑怎么搜索，对于一个已经选完了的点集，下一次可能再选的点有哪些？
可能是上一次选的点的儿子，也可能是回溯到上一层，选比上一层选的点大的下一个点；


注意第二个可能性，这个是维护了一个有序性，保证方案权值递增并且不会出现重复方案；


这是一个A*的过程，我说的似乎不太好理解。。
每一种状态加入优先队列来跑A*；
贴个图来演示一下：


所以每次是将这些边集中最小的边拿出来，那就要用到一个堆；
而如果对于每个状态搞一个堆妥妥MLE；
那就用可持久化左偏树来搞(可持久化数据结构get√)；
这样空间复杂度是O((n+k)logn)的(大概)；
当然，将一个结点的所有儿子加入堆不能暴力，对每个结点维护一个儿子可并堆就好了；


代码：



#include<queue>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#define N 110000
#define pr pair<ll,heap*>
using namespace std;
typedef long long ll;
struct heap
{
	heap *l, *r;
	int dis, no, val;
	heap();
}*null = new heap(), *root[N];
priority_queue<pr,vector<pr> ,greater<pr> >q;
heap::heap()
{
	l = null, r = null;
	dis = 0;
}
heap* Insert(heap *x, heap *y)
{
	if (x == null || y == null)
		return x == null ? y : x;
	if (x->val > y->val)
		swap(x, y);
	x->r = Insert(x->r, y);
	if (x->l->dis < x->r->dis)
		swap(x->l, x->r);
	x->dis = x->r->dis + 1;
	return x;
}
heap* merge(heap *x, heap *y)
{
	if (x == null || y == null)
		return x == null ? y : x;
	if (x->val > y->val)
		swap(x, y);
	heap *p = new heap();
	*p = *x;
	p->r = merge(p->r, y);
	if (p->l->dis < p->r->dis)
		swap(p->l, p->r);
	p->dis = p->r->dis + 1;
	return p;
}
int main()
{
	int n, m, i, j, k, x, y, v;
	ll ans;
	heap *p;
	null->l = null->r = null;
	null->no = null->val = 0;
	scanf("%d%d",&n,&k);
	for (i = 1; i <= n; i++)		root[i] = null;
	for (i = 1; i < n; i++)
	{
		scanf("%d%d", &x, &v);
		p = new heap();
		p->no = i+1, p->val = v;
		root[x]=Insert(root[x], p);
	}
	p = new heap();
	p->no = 1, p->val = 0;
	q.push(pr(0, p));
	for (i = 1, ans = 0; i <= k&&!q.empty(); i++)
	{
		pr now = q.top();
		q.pop();
		ans = now.first;
		p = now.second;
		x = p->no;
		v = p->val;
		p = merge(p->l, p->r);
		if(p!=null)
			q.push(pr(now.first - v + p->val, p));
		p = merge(p, root[x]);
		if(p!=null)
			q.push(pr(now.first + p->val, p));
	}
	printf("%d\n", ans % 998244353);
}




Wind River Linux Open Virtualization Profile 5.0.1.27
2692407267@qq.com，更多内容请关注http://user.qzone.qq.com/2692407267  
Wind River Linux Open Virtualization Profile 5.0.1.27  图也不贴了，后面有时间慢慢补，对不住大家了

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1301 Jungle Roads
最小生成树裸题，懒得写，直接模板

#include<iostream>
#include<vector>
#include<cmath>
#include<cstdio> 
#define inf 1<<30
#define maxn 30
using namespace std;
int n; 
vector<int>mapp[maxn];
int vaule[maxn][maxn];
int visit[maxn];
void prim()
{
	int d[maxn];
	fill(d,d+maxn,inf);
	fill(visit,visit+maxn,0);
	int re=0;
	d[0]=0;
	while(1)
	{
		int v=-1;
		for(int i=0;i<n;i++)
		{
			if(!visit[i]&&(v==-1||d[i]<d[v])) v=i;
		}
		if(v==-1) break;
		re+=d[v];
		visit[v]=1;
		for(int i=0;i<mapp[v].size();i++)
		{
			int x=mapp[v][i];
			d[x]=min(d[x],vaule[v][x]);
		}
	}
	cout<<re<<endl;
}
int main()
{
	while(cin>>n&&n)
	{
		char a,b;
		int m,x,z;
		for(int i=0;i<maxn;i++) mapp[i].clear();
		for(int i=0;i<n-1;i++)
		{
			cin>>a>>m;
			for(int i=0;i<m;i++)
			{
				cin>>b>>z;
				int x=a-'A',y=b-'A';
				mapp[x].push_back(y);
				mapp[y].push_back(x);
				vaule[x][y]=z;
				vaule[y][x]=z;
			}
		}
		prim();
	}
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

Wind River Linux Experimental Features Layer 5.0.1.27
2692407267@qq.com，更多内容请关注http://user.qzone.qq.com/2692407267   
Wind River Linux Experimental Features Layer 5.0.1.27  图也不贴了，后面有时间慢慢补，对不住大家了

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        服务器自动切换
   　古人云，能睡是福。最近终于感受到，晚上能在自己舒服的大床上睡一觉是多么幸福的一件事了，黑白颠倒的日子我这个纯正中国人还真是有点接受不了。不过，看着测试通过，心里美美哒，所有的劳累都烟消云散了。哈哈，不开玩笑了，言归正传。服务器切换。
说起服务器切换，我的脑袋里就想起了一个高大上的名词——热部署。
 
部署我们都知道是什么意思，那热部署是什么你清楚吗？不知道的话就去查查百度百科吧。


——就知道你懒得查，所以还是我来告诉你吧。
        所谓热部署，就是在应用正在运行的时候升级软件，却不需要重新启动应用。这最后一句很重要，也是把我难到的地方。





  　　眼下，我有一个项目，分别在服务器A和服务器B上进行发布，当服务器A因为机器损坏，或者断电等原因宕掉了，要自动切换到服务器B上，不用人工去修改配置文件的终结点，也不能够重启应用程序，就是完全无缝接的连接到服务器B。
用过很多种方法，苍天不负有心人，总算是成功了。
 
因为用的WCF，所以客户端连服务端，无非是通过终结点配置来完成的。起初以为，更改了配置文件的服务地址就自动切换过去了。哪知道还需要重启一下客户端才能够切换过去。
 
我使用的第一种方法，但是没有成功。
当服务器A宕掉，自动修改配置文件。注意：不是手动哦。
然后刷新配置文件，重新加载。也就是在去取配置文件的时候，加上了这句代码：

ConfigurationManager.RefreshSection("appSettings");// 刷新命名节，在下次检索它时将从磁盘重新读取它。

但是，没有切换成功，应该是有办法解决的，我没有成功，大家可以自己动手试试，成功了教教我。互相交流。
不成功的原因：

System.Configuration.ConfigurationSettings.AppSettings["ServerName"]

只能使用一次，不管你怎么修改config文件中的值，以后读出的结果始终等于第一次的结果。因为AppSettings["ServerName"]读一次后就写到内存中，而下一次读取就直接读内存中值。 
最终解决办法：
 
配置文件的终结点，将两台机器的服务器的终结点地址都配置上。
HostServer是主服务器，StandByServer是备服务器。
 <add key ="HostServer" value="servera"/>
 <add key ="StandByServer" value="serverb"/>


 <client>
  <endpoint address="http://servera:8080/Services.svc" binding="wsHttpBinding" bindingConfiguration="WSHttpBinding_WcfService" contract="ICT.RCS.Modules.Interface.IServices" name="ServiceA" />
<endpoint address="http://serverb:8080/Services.svc" binding="wsHttpBinding" bindingConfiguration="WSHttpBinding_WcfService" contract="ICT.RCS.Modules.Interface.IServices" name="ServiceB" />
 </client>

之前的工厂类是使用无参的，如下：
 public static IUserSevice GetUserService()
 {
      return GetUserService("Service");
 }

现在改成有参数的：

 public static IUserSevice GetUserService(string endpointName)
 {
     return GetServiceBusiness(endpointName);
 }


定义一个静态变量，初始值为空
 public static string strServiceEndpointName = "";
调用ServiceFactory的时候采用有参数的。

      ServiceFactory.GetUserService(CommonConstants.strServiceEndpointName).QueryUser();

登录的时候进行判断：
 public Login()
 {
     InitializeComponent();
		
<span style="white-space:pre">	</span>//如果当前servera是主服务器，那么调用ServiceA服务，如果当前serverb是主机，则调用ServiceB服务。
        if (ConfigurationManager.AppSettings["HostServer"].Equals("servera"))
        {
            CommonConstants.strServiceEndpointName = "ServiceA";
        }
        else
        {
            CommonConstants.strServiceEndpointName = "ServiceB";
        }
}

当,当前服务器出现问题时，执行下面代码，进行服务器切换。

  if (context.Message.S_HostWorkServer != null)
  {
        if (context.Message.S_HostWorkServer != ConfigurationManager.AppSettings["HostServer"])
        {
                if (context.Message.S_HostWorkServer.Equals("servera"))
                {
                          ConfigurationUtil.ChangeLocalConfig("HostServer", "servera");
                          ConfigurationUtil.ChangeLocalConfig("StandByServer", "serverb");
                          CommonConstants.strServiceEndpointName = "ServiceA";
                }
                else
                {
                          ConfigurationUtil.ChangeLocalConfig("HostServer", "serverb");
                          ConfigurationUtil.ChangeLocalConfig("StandByServer", "servera");
                          CommonConstants.strServiceEndpointName = "ServiceB";
                }         
                ConfigurationManager.RefreshSection("appSettings");
        }
  }

   总算是切换成功了，思路就是这么个思路，思路清晰了，自己也可以完成。代码不是很完整，仅供参考。你肯定有更好的办法，我们多多交流。互相学习。
   乏了，睡觉。O(∩_∩)O~






版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream  1213 Matrix Multiplication(矩阵相乘)

Matrix Multiplication

Time Limit: 2000/1000MS (Java/Others) Memory Limit: 128000/64000KB (Java/Others)

Submit Statistic Next
 Problem

Problem Description

      Let us consider undirected graph G = {V; E} which has N vertices and M edges. Incidence matrix of this graph is N × M matrix A = {ai,j}, such
 that ai,j is 1 if i-th vertex is one of the ends of j -th edge and 0 in the other case. Your task is to find the sum of all elements of the matrix
 ATA.

Input

      The first line of the input file contains two integer numbers — N and M (2 ≤ N ≤ 10 000, 1 ≤ M ≤100 000). Then 2*M integer numbers follow, forming M pairs, each pair describes one edge of the graph. All edges are different and there are no loops (i.e.
 edge ends are distinct).

Output

      Output the only number — the sum requested.

Sample Input

4 4
1 2
1 3
2 3
2 4


Sample Output

18
其实就是一个矩阵，自己乘自己，画图可以秒懂
java:
import java.util.*;
import java.io.*;
import java.math.*;

public class Main{
	static final int MAXN = 10000 + 5;
	static int [] mp = new int[MAXN];
	public static void main(String [] agrv)
	throws IOException
	{
		//System.setIn(new FileInputStream(new File("D:" + File.separator + "imput.txt")));
		Scanner cin = new Scanner(System.in);
		int N, M, u, v;
		while(cin.hasNext()){
			N = cin.nextInt();
			M = cin.nextInt();
			Arrays.fill(mp, 1, N + 1, 0);
			for(int i = 1;i <= M ;i ++){
				u = cin.nextInt();
				v = cin.nextInt();
				if(u == v) mp[v] ++;
				else {
					mp[v] ++;
					mp[u] ++;
				}
			}
			long ans = 0;
			for(int i = 1;i <= N;i ++){
				ans += (long)mp[i] * mp[i];
			}
			System.out.println(ans);
		}
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

快讯：微软安卓版个人助理（Cortana）在美国境内进行公测


              
8月24日，“Microsoft
 starts public test of Cortana app for Android smartphones”（此文8月24日发表），此事意义重
 大。

   这款新的Cortana for Android Beat公测版本，美国境内的安卓手机用户可以从GooglePlay
 Store应用商店下载，但是，其语音功能需要借助微软必应搜索来实现



微软个人助理Cortana移植到苹果手机用户的计划，在今年晚些时候安排。但是，苹果很有可能不允许第三方应用侵犯它的领地。



由于中国安卓手机用户数量很大的，微软个人助理Cortana何时来中国测试？这是中国广大安卓手机用户所关心的问题。这是迟早要发生的事情。



袁萌
8月25日




版权声明：本文为博主原创文章，未经博主允许不得转载。

问题解决：Spyder不支持OpenCV模块代码提示
最近使用 Python(x,y)+Spyder 进行Python相关开发，在测试一些基本模块时出现了一点小问题，这里记录下一种解决方式。Spyder是一款面向科学计算的Python交互开发环境。集成了pyflakes、pylint和IPython等工具，具备编辑、调试、命令交互、在线帮助文档、代码分析等功能，是Python(x,y)发行版推荐使用的开发工具之一。
在使用中遇到的问题是，Spyder的代码完成功能不支持某些编译模块（.pyd后缀），如OpenCV的Python模块cv/cv2，在编写脚本文件时，在已存在import cv&import cv2的前提下，输入cv. 无法弹出显示相关成员函数列表&代码完成提示。同样的操作在Spyder的Console窗口和IPython console窗口都能正常工作，如图一所示，在Spyder 的 Console窗口中cv2模块的代码完成提示。（事实上，大多数支持Python的编辑器都存在类似问题，这是因为多数编译器对编译模块的代码完成支持不理想。）

上网查找了一下，在Google Code将该问题记载在 Issue 1469:    Add support to get code completions for compiled modules (e.g. OpenCV)。8楼的给出了一个建议，大致的意思是把当前使用的代码完成库从Rope换成Jedi可以完美解决这个问题。而7楼则给出了另一个简单的解决方法，这也是我成功解决问题所用的方法。

尝试了一下，问题得到了解决，具体的操作如下：
1.找到 module_completion.py 文件，2.25及之前的版本位于Python目录/Lib/site-packages/spyderlib/utils/路径，2.25之后的版本位于Python目录/Lib/site-packages/spyderlib/utils/introspection/。将cv和cv2添加到 module_completion.py 文件第274行的 mods 变量中，保存文件：

2.修改后，删除同目录下的 module_completion.pyc 文件，使得修改后的 module_completion.py 文件生效。
3.进入用户目录下的Users/用户名/.spyder2/db，删除目录中的submodules文件。
4.重启Spyder，enjoy it。
通常情况下，若需要添加其他的编译模块，均可按照以上的方法进行添加，尽管该方法比较不人性化。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

C# PPT 为形状设置三维效果
在PPT中，形状是非常重要的元素。3-D形状，立体多元，给人耳目一新的感觉。在幻灯片中添加3-D效果形状，必然会为PPT的整体效果增色不少。为形状设置三维格式时，可设置棱台，轮廓线，表面效果等。
本篇文章，旨在介绍在使用免费的Spire.Presentation，独立创建Powerpoint文档，添加形状，并设置三维效果。感兴趣的朋友，可以从E-iceblue官网下载免费的Spire.Presentation。下载完成后，请将bin文件夹的.dll添加作为引用。友情提示：使用Spire.Presentation可独立创建powerpoint文档。
需要添加的命名空间：
using Spire.Presentation;
using Spire.Presentation.Drawing;
using System.Drawing;
步骤详叙：
步骤一：创建PPT文档。
Presentation presentation = new Presentation();
步骤二：添加形状，设置其位置，大小并填充颜色。
IAutoShape shape1 = presentation.Slides[0].Shapes.AppendShape(ShapeType.RightArrow, new RectangleF(150, 150, 150, 150));
shape1.Fill.FillType = FillFormatType.Solid;
shape1.Fill.SolidColor.KnownColor = KnownColors.RoyalBlue;
步骤三：为该形状设置三维效果。
ShapeThreeD Demo1 = shape1.ThreeD.ShapeThreeD;
//设置表面效果
Demo1.PresetMaterial = PresetMaterialType.Matte;
//设置棱台类型，高度和宽度
Demo1.TopBevel.PresetType = BevelPresetType.ArtDeco;
Demo1.TopBevel.Height = 4;
Demo1.TopBevel.Width = 12;
//设置轮廓线类型，颜色，宽度
Demo1.BevelColorMode = BevelColorType.Contour;
Demo1.ContourColor.KnownColor = KnownColors.LightBlue;
Demo1.ContourWidth = 3.5;
步骤四：再添加一个形状作为对照。
IAutoShape shape2 = presentation.Slides[0].Shapes.AppendShape(ShapeType.Pentagon, new RectangleF(400, 150, 150, 150));
shape2.Fill.FillType = FillFormatType.Solid;
shape2.Fill.SolidColor.KnownColor = KnownColors.LawnGreen;
ShapeThreeD Demo2 = shape2.ThreeD.ShapeThreeD;
Demo2.PresetMaterial = PresetMaterialType.SoftEdge;
Demo2.TopBevel.PresetType = BevelPresetType.SoftRound;
Demo2.TopBevel.Height = 12;
Demo2.TopBevel.Width = 12;
Demo2.BevelColorMode = BevelColorType.Contour;
Demo2.ContourColor.KnownColor = KnownColors.LawnGreen;
Demo2.ContourWidth = 5;
步骤五：保存文档为.pptx，启动查看效果。
presentation.SaveToFile("result.pptx", FileFormat.Pptx2010);
System.Diagnostics.Process.Start("result.pptx");
效果截图：

完整代码：
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Spire.Presentation;
using Spire.Presentation.Drawing;
using System.Drawing;

namespace test
{
    class Program
    {
        static void Main(string[] args)
        {

            Presentation presentation = new Presentation();
            IAutoShape shape1 = presentation.Slides[0].Shapes.AppendShape(ShapeType.RightArrow, new RectangleF(150, 150, 150, 150));
            shape1.Fill.FillType = FillFormatType.Solid;
            shape1.Fill.SolidColor.KnownColor = KnownColors.RoyalBlue;

            ShapeThreeD Demo1 = shape1.ThreeD.ShapeThreeD;
            Demo1.PresetMaterial = PresetMaterialType.Matte;
            Demo1.TopBevel.PresetType = BevelPresetType.ArtDeco;
            Demo1.TopBevel.Height = 4;
            Demo1.TopBevel.Width = 12;
            Demo1.BevelColorMode = BevelColorType.Contour;
            Demo1.ContourColor.KnownColor = KnownColors.LightBlue;
            Demo1.ContourWidth = 3.5;

            IAutoShape shape2 = presentation.Slides[0].Shapes.AppendShape(ShapeType.Pentagon, new RectangleF(400, 150, 150, 150));
            shape2.Fill.FillType = FillFormatType.Solid;
            shape2.Fill.SolidColor.KnownColor = KnownColors.LawnGreen;
            ShapeThreeD Demo2 = shape2.ThreeD.ShapeThreeD;
            Demo2.PresetMaterial = PresetMaterialType.SoftEdge;
            Demo2.TopBevel.PresetType = BevelPresetType.SoftRound;
            Demo2.TopBevel.Height = 12;
            Demo2.TopBevel.Width = 12;
            Demo2.BevelColorMode = BevelColorType.Contour;
            Demo2.ContourColor.KnownColor = KnownColors.LawnGreen;
            Demo2.ContourWidth = 5;

            presentation.SaveToFile("result.pptx", FileFormat.Pptx2010);
            System.Diagnostics.Process.Start("result.pptx");
        }
    }
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

云盘是怎么实现“秒传”的 ！？
背景：
    不知道大家在使用 * 云盘的时候，有没有发现，有时候不管你上传的东西多大，在短暂延迟之后，马上就会提示上传成功了。然而这是怎么回事呢？
原理：
    当我们上传文件的时候，软件会有短暂的延迟（提示“正在准备上传文件”），这段延迟就是先校验你的文件的MD5（详解见下文），然后再在该云盘的服务器中通过MD5查找服务器中是否有相同的文件，如果有的话，那么就是将服务器中的文件直接复制一份到你的云盘中，而不是将你的文件传到云盘。这样的话就有了“秒传”的功能。当然，如果服务器中没有相同的文件，那么必须经过一点点的上传才可以，这时候上传的时间就得看你上传文件的大小和网速了。
    如果大家没有这个经历的话，尝试一下通过别人的分享，然后直接保存到自己的网盘，这样可以很快的体验到“秒传”的快感！（一首歌，以供尝试http://yunpan.cn/cmAXa8tTmgzxS  访问密码 a615）


详解MD5：


什么是MD5？

    Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法，哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理。


就好比我们每个人都有一个特殊的指纹一样，MD5可以为任何文件（不管其大小，格式，数量）产生一个独一无二的“数字指纹”，不论任何人对文件进行任何改动，该文件的“数字指纹”就会改变。
MD5算法的简要叙述：

MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。
MD5算法特点：

1、压缩性：任意长度的数据，算出的MD5值长度都是固定的（把一个任意长度的字节串变换成一定长的十六进制数字串）。

2、容易计算：从原数据计算出MD5值很容易。

3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。

4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。

5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。






版权声明：本文为博主原创文章，未经博主允许不得转载。 如有不对，还请指教。

HelloX操作系统网络功能简介及使用和开发指南
HelloX网络功能简介及使用和开发指南HelloX网络功能简介作为物联网操作系统，网络功能是必备的核心功能之一。按照规划，HelloX实现了两个不同类型的TCP/IP协议栈，一个面向资源受限的嵌入式应用，移植了业界成熟使用的lwIP协议栈。该协议栈简洁明了，功能相对简单，同时专门面向嵌入式领域进行设计和优化，对硬件资源要求很低。另外一个协议栈来自BSD操作系统的协议栈，面向复杂的网络功能丰富的应用场景，比如家庭网关，物联网网关等。为了适应HelloX本身的机制，对BSD协议栈做了一些更改和优化，当然，这是在BSD License允许的范围之内。目前lwIP协议栈已经成熟稳定运行，面向复杂场景的BSD协议栈正在移植当中。不论采用哪个协议栈，都提供相同的，符合BSD规范的socket API，因此对应用程序来说，协议栈都是透明的。对网卡驱动来说，HelloX本身设计了一套网卡驱动机制，向上屏蔽了不同的IP协议栈之间的差异，因此不论安装的是lwIP协议栈还是BSD协议栈，网卡驱动也都是相同的。本文对HelloX的网络功能的使用和开发方法，进行简单描述。在虚拟机上使用网络功能HelloX V1.78实现了一个PCNet FastEthernet III的网卡驱动程序（对应的网卡控制芯片是AMD的AM79C973）。大部分虚拟机都支持这个网卡，因此有比较广泛的通用性。如果您想试验其它的网卡驱动程序，则需要手工编写一个网卡驱动了。以Virtual Box虚拟机为例，在虚拟机的“设置”界面中，选择“网络”，这时候会列举出四个网卡。选择“网卡1”，按下图所示进行配置： 注意，“连接方式”选择“桥接网卡”。如果选择其它连接类型，我没有试过，不知道行不行。选择桥接网卡的含义，就是把你的PC机的物理网卡，与虚拟机的“网卡1”，用二层的方式连接了起来。可以想象VirtualBox虚拟了一个以太网交换机，然后把你的电脑的物理网卡，以及虚拟机的网卡1，都连接在了这个虚拟的以太网交换机上。“界面名称”中，选择你的计算机的物理网卡名称。注意，这个网卡一定是可以用的网卡，最好是你当前上网用的网卡，如果有多个网卡的话。点开“高级”选项，“控制芯片”一行，按照上图所示进行选择。如果选择其它的控制芯片，就需要编写对应控制芯片的驱动程序了。这是一项很有意思的工作，只要拿到对应芯片的data sheet，基本很快就可以编写出来。如果你能够成功的编写一个网卡驱动，那么恭喜你，应聘任何一家通信类或者嵌入式开发类公司，保准可以通过。有兴趣的朋友可以试试。点击确定之后，用最新的HelloX版本启动虚拟机即可。注意，缺省情况下，HelloX是通过DHCP方式获取IP地址的，因此与HelloX虚拟机关联的物理网卡，也必须是通过DHCP方式获取IP地址。当然，如果不是DHCP获取IP地址，也可以手工配置，参考本文下面的network命令部分。启动虚拟机之后，就可以用network程序，来查看和诊断网络了。比如，可以用iflist命令，来查看获取到的IP地址，用ping命令，来试试网络连接是否正常。下面是在我的计算机上的运行结果：在这里，简单介绍一下用ping命令诊断网络连接是否正常的方法。这些方法，一般在《网络基础》课程里面都会涉及到。如果要考MCSE，CCNA等证书，这些内容是必考内容。首先，ping一下环回地址，即127.0.0.1。如果这个地址能ping通，说明TCP/IP协议栈已经正常工作了。如果ping不通，那么就是TCP/IP协议栈都没有起来；如果环回地址ping通了，再ping一下网络接口的本地地址，也就是网卡地址。在上图中，是10.129.73.4。如果这个地址能够ping通，说明网卡已经被TCP/IP协议栈成功识别和管理。如果这个地址都ping不通，那么说明网卡与IP协议栈没有关联起来；在本地地址ping通的情况下，再ping缺省网关，在上图中，就是10.129.73.1这个地址。如果这个地址能ping通，说明计算机与路由器之间的通信是正常的。后面如果有网络问题，基本上可以排除是本地计算机问题。如果ping不通，则说明本机与路由器没有正常通信，这时候需要检查网线等物理连接。在缺省网关ping通的情况下，就可以ping目标服务器了。这时候如果ping通了，就万事大吉了。如果ping不通，那么很可能就是目标服务器的问题，或者是目标服务器与本地路由器之间的问题了。HelloX的Network程序使用指南HelloX实现了一个network字符界面应用程序，可以对网络功能进行调试。同时实现了一个抽象的以太网管理框架（Ethernet Framework），实现了一套标准的网络驱动程序接口，屏蔽了不同网络驱动程序之间的差异。这样，不同的硬件，其驱动代码是不同的，但是只要遵循这一套标准的接口规范，就可以无缝挂接到HelloX内核中。下面简要介绍V1.78版的网络调试程序network，在此基础上，简要介绍一下HelloX的网络驱动程序编写方法。在字符shell模式下，输入network并回车，即可进入network应用程序。该程序提供了如下一些网络相关命令：scan命令该命令用于扫描所有可用的WiFi热点，前提是需要有WLAN硬件支持。该命令会列出所有扫描到的AP热点，如下：[network-view]scanAvailable WiFi list: ----------------------------- 00:BSSID = 20004E9C, RSSI = 76, SSID = 'HelloX_HGW_AP', channel = 1 01:BSSID = 2000508C, RSSI = 15, SSID = 'Celleden_Map1600', channel = 6 如果发现想要连接的热点不在上述列表中，可多执行几次scan命令，很多情况下，一次scan是无法扫描到所有热点的。注意，要使用scan命令，必须具备WLAN网卡，否则无效。 assoc命令assoc用于跟某个指定的WiFi热点相关联。Scan只是扫描出一些可用的热点，但是如果需要跟某个热点进行连接，则必须使用assoc命令。如下： [network-view]assoc HelloX_HGW_AP 上述命令用于连接到名字为“HelloX_HGW_AP”的WiFi热点。注意，该WiFi热点必须是开放的不加密热点，因为上述命令没有指定连接密码。如果是要连接一个加密的WiFi热点，则可以用/k参数指定连接的密码： [network-view]assoc HelloX_HGW_AP/k0123456789012 后面是密码。当前只支持WEP加密，因此密码必须是13个字节。再次说明一下，当前值支持开放不加密的WiFi热点，以及基于WEP加密的WiFi热点，尚不支持WPA加密热点，因此要希望连接成功，必须修改WiFi热点的配置，修改为开放不加密，或者使用WEP加密（密码要设置为13位数字）。 showint命令该命令用于显示出系统中所有网络接口的统计信息，比如接收报文个数，发送报文个数等。下列是一个简单的输出例子： [network_view]showint Statistics information for interface'Marvel_WLAN_Int':  Send frame #       : 17  Success send #     : 17  Send bytes size    : 2946  Receive frame #    : 14   Success recv #     : 14  Receive bytes size : 1778 各输出字段的含义是自解释的。 iflist命令能够则列举出系统中所有的网络接口，与其对应的IP地址等信息。与showint不同的是，iflist显示的是网络接口的静态信息（IP地址/掩码/缺省网关等），而showint显示的则是网络接口的动态信息。下面是iflist的一个输出例子： [network_view]iflist -------------------------------------- Inetface name : Ma    IPv4 address   : 192.168.43.173     IPv4 mask     : 255.255.255.0    IPv4 gateway   : 192.168.43.1    Interface MTU  : 1500 -------------------------------------- Inetface name : lo    IPv4 address   : 127.0.0.1    IPv4 mask      : 255.0.0.0    IPv4 gateway   : 127.0.0.1    Interface MTU  : 0 上面显示了两个网络接口，第一个是WLAN接口，名字只包含了起始的2个字节。 setif命令setif命令则用于修改接口的静态配置参数。比如，可以通过下列方式，为一个网络接口设置静态的IP地址： setif Marvel_WLAN_Int /a 192.168.0.100 /m255.255.255.0 /g 192.168.0.1 其中Marvel_WLAN_Int是接口的名字（showint命令可以显示），后面分别是该接口的IP地址/子网掩码/缺省网关。需要注意的是，缺省情况下，接口上是启动DHCP功能的，试图自动获取IP地址。一旦通过上述命令设置静态IP地址，则会同时把该接口上的DHCP功能关闭。如果要重新打开DHCP功能，则使用如下命令： setif Marvel_WLAN_Int /d enable 而下列命令，则用于重新启动接口上的DHCP功能： setif Marvel_WLAN_Int /d enable 重启DHCP功能的目的，是为了立即在接口上发出DHCP请求。缺省情况下，DHCP功能是以指数退避方式来发送DHCP请求报文的，即当接口刚刚使能的时候，会发送DHCP请求，如果没有收到响应，则会在2秒后再发一次，然后是4秒，然后是8秒…以此类推。如果想立即在接口上重新发出DHCP请求，则使用上述命令restart一下即可。 Ping命令这是最常用的诊断命令，后面直接跟IP地址即可。下面是一个简单的输出例子： [network_view]ping 192.168.43.1 Ping192.168.43.1 with 64 bytes packet: [0]Reply from 192.168.43.1,size = 64,time = 40(ms) [1]Reply from 192.168.43.1,size = 64,time = 180(ms) [2]Reply from 192.168.43.1,size = 64,time = 180(ms) pingstatistics: total send = 3,received = 3,0 loss. 如果希望改变缺省的ping报文长度，则可以增加一个参数： ping 192.168.43.1 /l 1024 上述命令以1024字节为ping报文长度。缺省情况下，会连续ping三个报文，然后结束。如果希望ping更多的报文，则使用下列命令： ping 192.168.43.1 /c 1000 上述命令可以ping1000个报文。当然，l参数和c参数可以一起使用。 HelloX网络驱动程序编写方法HelloX实现了一个基于线程轮询机制的以太网驱动程序框架，系统中有一个叫做eth_thread的线程，定时（每隔100ms）轮询网卡驱动程序，试图接收数据帧。如果有合适的数据帧到达，则eth_thread会把这个数据帧递交到IP层处理。因此，要实现一个以太网驱动程序，需要遵循HelloX的以太网驱动框架，具体来说，就是要实现下列函数： 初始化函数原型如下，这个函数在以太网驱动程序被加载的时候，会被HelloX调用，用于完成硬件的初始化功能。当然，如果不需要初始化，完全可以写成下列形式： static BOOLInt_Init(__ETHERNET_INTERFACE*pInt){       returnTRUE;} 硬件的初始化，还可以放在驱动程序的入口函数中，下面会提及。 报文发送函数原型如下： static BOOLSendFrame(__ETHERNET_INTERFACE*pInt); 在IP层试图发送报文的时候，以太网驱动框架会调用这个函数。所发送的数据帧已经在IP层面准备好（包括源MAC地址/目的MAC地址等），存放在pInt对象的一个缓冲区中（如下代码），驱动程序只需要发送即可。 typedef struct tag__ETHERNET_INTERFACE{      char                   ethName[MAX_ETH_NAME_LEN +1];      char                   ethMac[ETH_MAC_LEN];      char                   SendBuff[ETH_DEFAULT_MTU];//Sending buffer.      int                    buffSize;                       __ETH_INTERFACE_STATE  ifState;            LPVOID                 pL3Interface;       LPVOID                 pIntExtension; //Privateinformation.      ……}__ETHERNET_INTERFACE; 其中SendBuff是存放待发送数据帧的缓冲区，buffSize是数据帧的长度，必须小于ETH_DEFAULT_MTU（1500）。在SendFrame函数中，只需要操作硬件，把SendBuff中的内容送到物理网络上，然后返回即可。 数据帧接收函数该函数原型如下，会被HelloX的以太网管理框架周期性的调用，以判断是否有数据帧到达： static structpbuf*RecvFrame(__ETHERNET_INTERFACE* pInt); 在这个函数中，硬件判断有数据帧到达，则需要创建一个pbuf，把数据帧从硬件缓冲区中拷贝到pbuf里面，然后返回这个pbuf。比如下面的实例代码： static struct pbuf*Marvel_RecvFrame(__ETHERNET_INTERFACE*pInt){struct eth_packet  *rx_pkt   =&pgmarvel_priv->rx_pkt; struct pbuf         *p, *q; u16                 len        =0; int                 l          = 0; char                *buffer    = NULL;   p=NULL; /*Obtain the size of the packet and put it into the "len"variable. */ len= lbs_rev_pkt();      if(len > 0){              buffer= rx_pkt->data;              /*We allocate a pbuf chain ofpbufs from the pool. */              p= pbuf_alloc(PBUF_RAW, len,PBUF_POOL);              if(p != NULL){                     for(q = p; q != NULL; q =q->next){                           memcpy((u8_t*)q->payload,(u8_t*)&buffer[l], q->len);                            l= l + q->len;          }           }        else              {        }  } return p;} 如果硬件判断没有数据帧到达，则只需要返回NULL即可。 特定功能的控制函数原型如下： static BOOLEth_Ctrl(__ETHERNET_INTERFACE*pInt,DWORD dwOperation,LPVOID pData); 对于一些以太网的特定控制功能，比如设置MTU大小，修改速率，WiFi的扫描AP/附着AP等，通过这个函数实现。dwOperation指明了需要的操作。如果没有特殊需要，也可以不需要实现该函数。建议的实现方式是，实现一个只返回TRUE的空函数，比如： staticBOOLMarvel_Ctrl(__ETHERNET_INTERFACE* pInt,DWORD dwOperation,LPVOID pData){      returnTRUE;} 实现驱动程序入口函数实现完成上述函数之后，还需要实现一个以太网驱动程序的入口函数，这个入口函数会被HelloX的以太网管理框架调用，用于加载以太网驱动程序。在入口函数中，需要做系列工作：1． 初始化硬件；2． 调用AddEthernetInterface，向系统中注册以太网接口。下面是一个实现实例： BOOL Marvel_Initialize(LPVOID pData){      __ETHERNET_INTERFACE*pMarvelInt = NULL;      char                 mac[ETH_MAC_LEN];        //初始化硬件，获得硬件的MAC地址，存放在mac数组中。   //调用AddEthernetInterface，注册接口。      pMarvelInt= EthernetManager.AddEthernetInterface(        MARVEL_ETH_NAME,  //以太网的名字，任意字符串，不能包含空格。        &mac[0],               //MAC地址。NULL,                 //初始化函数的参数。Int_Init,               //接口初始化函数，对应上述Int_Init函数SendFrame,             //数据帧发送函数RecvFrame,             //数据帧接收函数Eth_Ctrl);               //控制函数。       if(NULL== pMarvelInt)      {              returnFALSE;      }      returnTRUE;} 调用AddEthernetInterface的时候，需要使用上面实现的四个操作函数作为参数。调用成功后，会返回一个以太网对象指针，可以保存起来，供后期卸载以太网接口的时候用。 在以太网驱动入口数组中增加一项最后一步，就是在以太网驱动程序入口函数数组中增加一项，告诉操作系统以太网驱动程序的存在。这样操作系统在初始化的时候，就会调用驱动程序入口函数，加载驱动程序。入口函数数组位于network/ethernet/ethentry.c文件中，下面是一个示例： __ETHERNET_DRIVER_ENTRYEthernetDriverEntry[]={#ifdef __CFG_NET_MARVELLAN       {Marvel_Initialize,NULL},#endif //Please add your ethernet driver's entryhere. {NULL,NULL}}; 其中Marvel_Initialize是驱动程序入口函数，NULL是入口函数的参数，可以是任意指针。注意，该数组中的第一个网络接口，会被系统自动设置为缺省网络接口，即缺省网关所在的接口，或者HelloX默认路由所在的接口。这样以太网驱动程序就编写完成了。建议把以太网驱动程序的代码，存放在driver/STM32目录下。重新编译HelloX，即可实现以太网驱动程序的加载。以太网驱动程序加载成功后，即可食用network程序，进行诊断和调试。如果命令级别的诊断无法发现问题，则可以启用代码级的调试。具体来说，在ethif.h文件中，打开以太网调试开关（__ETH_DEBUG），重新编译并加载运行，即可输出网络运行过程中的更加详细的信息。 HelloX V1.78的代码，可以从github上下载：github.com/hellox-project/HelloX_OS有任何问题，欢迎加入QQ群讨论：38467832 

版权声明：本文为博主原创文章，未经博主允许不得转载。

Git从远程的分支获取最新的版本到本地
有时候需要从远程git服务器获取某个远程分支的代码，命令是 git fetch origin  remote-branch:local-branch ，这个命令比较容易忘记，特别记录下。1. 查看远程仓库git remote -v
origin	http://git.dev.qianmi.com/elifeapp/weidian.git (fetch)
origin	http://git.dev.qianmi.com/elifeapp/weidian.git (push)2.从远程获取最新版本到本地git fetch origin master:temp 这句命令的意思是：从远程的origin仓库的master分支下载到本地并新建一个分支temp使用git pull也可以拉取远程分支的代码，相当于git fetch + merge， 使用git fetch更好理解，更安全，对于pull也可以更新代码到本地，相当于fetch+merge，多人写作的话不够安全。

版权声明：本文为博主原创文章，转载请保留出处http://blog.csdn.net/offbye

阅读laravel源代码有感
        由于公司一直使用的是yaf框架，至少有很多项目是基于yaf框架的。相信所有用过yaf的朋友们也能够清晰的感受到yaf的功能是在是太简洁了，基本上就提供了一个mvc模式、一个自动加载机制、一个路由机制，剩下的基本什么都没有。
       当然啦，作为一个C语言框架，就不要求它什么了，而且毕竟是一个人维护的，人的时间也是有限的，而且鸟哥也一直在维护自己的yaf框架，再次表示衷心的感谢。于是，本着统一的要求，于是就决定仔细看看各大主流框架的具体实现方式，然后从里面抽出一些东西来让自己使用。
       首先想到的框架就是laravel，不仅仅是因为它是一个比较优雅的框架，也不仅仅是因为它有着超高的市场占有率，而且就从其功能和性能上，都有着比较卓越的表现，但是一直没有怎么细心研究过其源码，不得不说是一个损失。
      研究一个框架，很重要的就是研究它的各种机制的实现流程，对于其提供的助手函数，倒在其次，毕竟我们本身写这些类库的效率也并不低。
      好啦，不说废话啦。今天只是大致的看了半小时左右的DB层的实现，而且自己也对其进行了适当修改，比如它的Database下面的Query里面还有两个文件夹，我们就直接把它放到一个文件夹中，而且我们还根据其自动加载方式进行了重命名，比如Connection会被重命名为DBX_Query_Connect，可能熟悉yaf和laravel的朋友们会知道我在library下面建立了一个DBX目录，然后其中有个Query子目录，然后里面放着Connect.php文件。
     不过感受最深的一点就是它的跳转真心厉害，就是一个简单的$conn->table("t_admin")->get()；就有不下二十处的跳转，核心就是三个地方，一个是Builder，一个是Processor，一个是Grammar，当然，我们发现还有一个Arr，它是在源代码的Support目录下的Arr.php文件，它被调用了一个方法。一般来说，执行一次查询，五到十次的跳转，这个复杂度我们都是喜闻乐见的，而且通常我们一般也会这么搞。但是十次到二十多次的跳转，未免就会让人思路不清晰了，也就决定了想要比较熟练的驾驭它，还是需要花费很大的功夫的。
      对了，这里说一下我看的代码版本是5.1.4，之后我会出一系列阅读源代码的资料的，一是因为工作上的需要，二是本身比较感兴趣，喜欢的朋友可以持续关注下奥。

版权声明：本文为博主原创文章，未经博主允许不得转载。

微信企业号登录授权-----Java Struts2 实现 获取员工userid
为了方便测试 。debug 建议大家搞个花生壳或者其他的可以映射公网IP的软件。
貌似涨价了8元一个。鄙人捡了个便宜1元买的。还是个二级域名

1.设置一个菜单调用授权接口的URL （https://open.weixin.qq.com/和这个网站的是不一样的东西）获取code

   
https://open.weixin.qq.com/connect/oauth2/authorize?appid=CORPID&redirect_uri=REDIRECTURI&response_type=code&scope=snsapi_base&state=STATE#wechat_redirect



2.写一个方法接收上图中reurl 获取code 与 access_token 

public String execute() throws Exception {
        HttpServletRequest request = ServletActionContext.getRequest();
        HttpServletResponse response = ServletActionContext.getResponse();
        request.setCharacterEncoding("UTF-8");
        response.setCharacterEncoding("UTF-8");
        String code = request.getParameter("code");
        if(!"authdeny".equals(code)){
            String access_token =  WeixinUtil.getAccessToken(您的企业号corpId,您的企业号secret).getToken();
            String UserID = oAuth2Service.getUserID(access_token, code, "2"); //第3步
            request.setAttribute("UserId", UserID);
        }
        request.getRequestDispatcher("/index.jsp").forward(request,response);
        return null;
    }
3.getUserID获取员工userid 这个id并不是用户openid


<span style="font-size:12px;">/**
* 获取员工信息的接口地址
**/
public  String CODE_TO_USERINFO = "https://qyapi.weixin.qq.com/cgi-bin/user/getuserinfo?access_token=ACCESS_TOKEN&code=CODE&agentid=AGENTID";
 
 
/**
     * 根据code获取成员信息
     * @param access_token 调用接口凭证
     * @param code   通过员工授权获取到的code，每次员工授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期
     * @param agentid   跳转链接时所在的企业应用ID 管理员须拥有agent的使用权限；agentid必须和跳转链接时所在的企业应用ID相同
     * */
    public  String getUserID(String access_token, String code, String agentid) {
        String UserId = "";
        CODE_TO_USERINFO = CODE_TO_USERINFO.replace("ACCESS_TOKEN", access_token).replace("CODE", code).replace("AGENTID", agentid);
        JSONObject jsonobject = WeixinUtil.httpRequest(CODE_TO_USERINFO, "GET", null);
        if (null != jsonobject) {
            UserId = jsonobject.getString("UserId");
            if (!"".equals(UserId)) {
                System.out.println("获取信息成功，o(∩_∩)o ————UserID:" + UserId);
            } else {
                int errorrcode = jsonobject.getInt("errcode");
                String errmsg = jsonobject.getString("errmsg");
                String error = "错误码：" + errorrcode + "————" + "错误信息：" + errmsg;
                log.error(error);
            }
        } else {
            log.error("获取授权失败了");
        }
        return UserId;
    }</span>


4.再根据第2步的转发 将获取的数据传递到页面 测试是否正确
4.1 首先点击微信企业号里面有授权菜单的应用 的菜单



4.2 走第2步的Action 获取code、 access_token换取userid 并转发到指定页面






版权声明：本文为博主原创文章，未经博主允许不得转载。

Wind River Linux Carrier Grade Profile 5.0.1.27
2692407267@qq.com，更多内容请关注http://user.qzone.qq.com/2692407267 
Wind River Linux Carrier Grade Profile 5.0.1.27 图也不贴了，后面有时间慢慢补


版权声明：本文为博主原创文章，未经博主允许不得转载。

权威发布：彻底搞清楚哪些笔记本和台式机主板可以支持42mm SATA M.2 NGFF(2242)接口的固态硬盘！！！
在京东，天猫上搜寻半天，致电联想客服以及各个固态盘的店小二，都搞不清楚兼容性问题。而且联想客服的回答明显错误，官网描述也错误，客服工程师也含糊不清说：要拆机试一试才知道是否兼容。我就不信这个邪了。以下是我的权威发布！！！保证没问题。请各位工程师、厂商、以及淘宝店主可以采纳！！！已知使用42mm SATA M.2 NGFF(2242)规格的设备：宏基 Chromebook: C720, C720 Core i3 (C720-3871)华硕 Chromebox华硕 ROG: G750JH, G750JX惠普 Chromebook 14惠普 EliteBook: 820 G1, 840 G1, 850 G1惠普 EliteBook Revolve: 810 G2惠普 ProBook: 430 G1, 430 G2, 450 G2, 640 G1, 650 G1惠普 ZBook 14联想: G410, G510, G710, V4400u联想 Essential: B5400, M5400联想 Flex, Flex 2, Flex 14, Flex 15联想 IdeaPad: L440, L540, U330, U410, U430, U530, Y410p, Y510p联想 ThinkPad: S431, S531, S540, T431s, T440, T440P, T440s, T540, T540p, W540, X240联想 ThinkPad Edge: E431, E440, E531, E540联想 ThinkPad Yoga联想 ThinkPad S3联想 K4450, K2450联想 X240S索尼 VAIO PRO 13 Series索尼 VAIO DUO 13 Series已知支持M.2 NGFF接口固态硬盘的台式机主板：技嘉 Z97X-UD5H（支持2242、2260、2280规格）技嘉 GA-Z97-D3H（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-Z97MX-Gaming 5（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-X99-Gaming G1 WIFI（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-X99-Gaming 7 WIFI（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-X99-SOC Force（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-X99-UD7 WIFI（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-X99-Gaming 5（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-X99-UD5 WIFI（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-X99-UD3（支持2242、2260、2280规格，支持PCIE/SATA协议）技嘉 GA-X99-UD4（支持2242、2260、2280规格，支持PCIE/SATA协议）华硕 X99-A（支持2242、2260、2280、22110规格，仅支持PCIE协议）华硕 X99-E WS（支持2260、2280规格，仅支持PCIE协议）华硕 X99-PRO（支持2242、2260、2280、22110规格，仅支持PCIE协议）华硕 X99-DELUXE（支持2242、2260、2280规格，仅支持PCIE协议）华硕 ROG RAMPAGE V EXTREME（支持2260、2280、22110规格，仅支持PCIE协议）华硕 Z97-C（支持2260、2280规格）华硕 Z97-K（支持2260、2280规格）华硕 Z97I-Plus（支持2260、2280规格）华硕 H97I-Plus（支持2260、2280规格）华硕 H97-PLUS（支持2260、2280规格）华硕 H97-PRO GAMER（支持2260、2280规格，支持PCIE/SATA协议）华硕 H97-PRO（支持2260、2280规格，支持PCIE/SATA协议）华硕 H97M-E（支持2260、2280规格，支持PCIE/SATA协议）华硕 H97M-PLUS（支持2260、2280规格，支持PCIE/SATA协议）华硕 ROG MAXIMUS VI GENE（支持2242规格，PCIE 2.0 X1 / SATA）华硕 Z97 PRO（支持2260、2280规格）华硕 Z97 DELUXE（支持2260、2280规格）华硕 ROG MAXIMUS VI IMPACT（支持2242、2260、2280、22110规格，PCIE 2.0 X1 / SATA）华硕 ROG MAXIMUS VI EXTREME（支持2242规格，PCIE 2.0 X1 / SATA）华硕 ROG MAXIMUS VI FORMULA（支持2242规格，PCIE 2.0 X1 / SATA）华硕 ROG MAXIMUS VII FORMULA（支持2260规格）华硕 ROG MAXIMUS VII IMPACT（支持2242、2260、280规格）华硕 ROG MAXIMUS VII HERO（支持2260、2280规格，PCIE协议）华硕 ROG MAXIMUS VII GENE（支持2260、2280规格，PCIE协议）华擎 Z97 超频方程式（支持2242、2260、2280、22110规格，支持PCIE/SATA协议）华擎 Z97 极限玩家 9（支持2242、2260、2280、22110规格，支持PCIE/SATA协议，2个插槽，其中一个支持PCIE 3.0 X4）华擎 Z97 极限玩家 6（支持2242、2260、2280、22110规格，支持PCIE/SATA协议，2个插槽，其中一个支持PCIE 3.0 X4）华擎 Z97 Pro4（支持2242、2260、2280、22110规格，支持PCIE/SATA协议）华擎 Z97 极限玩家 4（支持2242、2260、2280、22110规格，支持PCIE/SATA协议）华擎 玩家至尊 Z97 专业版（支持2242、2260、2280、22110规格，支持PCIE/SATA协议）华擎 玩家至尊 Z97X 杀手版（支持2242、2260、2280、22110规格，支持PCIE/SATA协议）华擎X99X杀手版（支持2242、2260、2280、22110规格，支持PCIE/SATA协议）华擎 玩家至尊 H97 杀手版（支持2242、2260、2280、22110规格，支持PCIE/SATA协议）微星9系主板的NGFF接口均支持PCIE/SATA协议，PCIE2.0 X2规格：微星 H97 GAMING 3（支持2242、2260、2280规格）微星 Z97 XPower AC（支持2242、2260、2280规格）微星 Z97 MPOWER Max AC（支持2242、2260、2280规格）微星 Z97 Gaming 7（支持2242、2260、2280规格）微星 Z97 Gaming 5（支持2242、2260、2280规格）微星 Z97 Gaming 3（支持2242、2260、2280规格）微星 Z97 GAMING 9 AC（支持2242、2260、2280规格）微星 Z97S SLI KRAIT EDITION（支持2242、2260、2280规格）微星 Z97 MPOWER MAX AC（支持2242、2260、2280规格，PCIE 2.0 X2 / SATA）微星 X99S GAMING 7（支持2242、2260、2280规格，PCIE3.0 X4/SATA）微星 X99S MPOWER（支持2242、2260、2280规格，PCIE3.0 X4/SATA）微星 X99S XPOWER AC（支持2242、2260、2280规格，PCIE3.0 X4/SATA）微星 X99S SLI PLUS（支持2242、2260、2280规格，PCIE3.0 X4/SATA）微星 X99S GAMING 9 AC（支持2242、2260、2280规格，PCIE3.0 X4/SATA）微星 X99S GAMING 9 ACK（支持2242、2260、2280规格，PCIE3.0 X4/SATA）

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1598 find the most comfortable road
并查集+枚举，深搜TLE，感觉广搜有有点戏，没心情试
#include<iostream>
#include<algorithm>
#define maxn 1010
using namespace std;
struct stu
{
	int a,b,l;
};
stu mapp[maxn];
int f[210];
int n,m;
bool cmp(stu x,stu y)
{
	return x.l<y.l;
}
int dfs(int x)
{
	if(f[x]!=x) f[x]=dfs(f[x]);
	return f[x];
}
void build(int x,int y)
{
	if(dfs(x)!=dfs(y)) 
	f[dfs(x)]=dfs(y);
}
int main()
{
	while(cin>>n>>m)
	{
		for(int i=0;i<m;i++) cin>>mapp[i].a>>mapp[i].b>>mapp[i].l;
		sort(mapp,mapp+m,cmp);
		int t;
		cin>>t;
		while(t--)
		{
			int re=1<<30;
			int x,y;
			cin>>x>>y;
			for(int i=0;i<m;i++)
			{
				for(int s=0;s<=n;s++) f[s]=s;
				for(int j=i;j<m;j++)
				{
					build(mapp[j].a,mapp[j].b);
					//cout<<dfs(x)<<"~"<<dfs(y)<<endl;
					if(dfs(x)==dfs(y))
					{
						re=min(mapp[j].l-mapp[i].l,re);
						break;
					}				
				}
			}
			if(re==1<<30) cout<<"-1"<<endl;
			else cout<<re<<endl;
		}
		
	}
	return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        论无解的阿里2016校园招聘题
以下代码是阿里2016级校园招聘比试题目：
//clang提示编译警告：multiple unsequenced modifications to v
#include <iostream>
using namespace std;


void __cdecl func(const int& v1, const int&v2){
         cout<<v1<<' '<<v2<<endl;
} 


int main(){
        int v = 0;
        func(++v, v++);
} 


然后有四个答案，其中有2 0和2 1，事实上，在微软的Visual Studio上测试结果是2 0，在Clang和XCode（后台使用Clang)上是2 1，那么问题来了，哪个对？


结果是没有一个对，也没有一个错，这个题目是没有答案的。
C(++)语言中有序列点的概念，序列点要求在序列点上，前面求值的所有副作用应该全部完成，比如，函数调用就是一个序列点，在函数调用实施前，参数的求值及其副作用应该被全部计算完成。C语言中规定，逗号运算符、三元运算符、逻辑与、逻辑或有序列点。


逗号运算符：（函数调用里面的那个逗号是参数分割号，而不是逗号运算符）
#include <Iostream>
using namespace std;


void f(const int& ref){
        cout<<ref<<' ';
}  


int main(){
    int val = 0;
    f(val++),f(val++);
}
以上代码显然输出0，1。因为逗号运算符是个序列点，左边的f调用及其副作用必须先计算再进行右边的f调用及副作用。




三元运算符，逻辑与，逻辑或等与此类似，不再详细描述。


在最开始的代码里面，惟一可以保证的是在func调用之前，两个参数v1,和v2均会被计算、副作用均已完成以及参数从右到左入stack，至于先计算v++还是++v及其副作用是无定义的，也就是说，编译器想怎么计算就怎么计算，保不准在某个编译器上输出1，1。



版权声明：本文为博主原创文章，未经博主允许不得转载。

atitit.薄伽梵歌overview  attilax 读后感
atitit.薄伽梵歌overview  attilax 读后感
 
1. 唯一一本记录神而不是神的代言人或者先知言论的经典
2
2. 篇章规模，字数
3
3. 内容摘要
3
4. 主要内容
3
4.1.1. 第一章（在库如雪查战场上阅兵）
3
4.1.2. 第二章（薄伽梵歌内容提要）
3
4.1.3. 第三章（行业瑜珈）
4
4.1.4. 第四章（超自然的知识）
4
4.1.5. 第五章（有为瑜伽——卡摩瑜伽）
4
4.1.6. 第六章（数论瑜伽）
4
4.1.7. 第七章（对真理的认识）
4
4.1.8. 第八章（秦达至尊）
5
4.1.9. 第九章（最机密的知识）
5
4.1.10. 第十章（表现瑜伽——至尊者的富裕）
5
4.1.11. 第十一章（宇宙形象）
5
4.1.12. 第十二章（奉献瑜伽）
6
4.1.13. 第十三章（自然、享受者、与知觉）
6
4.1.14. 第十四章（物质自然的三种属性）
6
4.1.15. 第十五章（至尊者的瑜伽）
6
4.1.16. 第十六章（圣洁及邪恶的本性）
7
4.1.17. 第十七章（信仰的分类）
7
4.1.18. 第十八章（结论——完美的弃绝）
7
5. attilax举得不错观点
8
5.1. 只有身体能被杀死，而永恒的自我是不朽的、
8
5.2. 行动比结果重要
8
5.3. 人除非弃绝物欲，否则不能够成为大师
8
5.4. 泛爱一切生物，必能接近我”。
8
5.5. 就是时间，世界最大的毁灭者。我到来要毁灭所有人。除了你们般度诸子，这里双方均将丧生
8
5.6. 了解如何皈依上天，就可到达永恒的国度
8
5.7. 依靠圣经行事才能正确行事
8
5.8. 举行祭祀、研习《吠陀经》、生活刻苦朴素 愤怒、贪婪俩大拦路石
8
5.9. 通过这种奉献，全然知觉上帝，就能进入神的国度……放弃一切，只要皈依会把从罪恶中拯救出来。
8
5.10. 灵魂不生不灭，形体世世毁亡。 灵魂万劫不灭，永是亘古长存。
8
5.11. 长歌中充满了哲学智慧，其中之一就是生死轮回。
9
5.12. 人的灵魂(Atman)与宇宙精神(梵，Brahman)本是一体，超越轮回。
9
6. attilax的心得
9
7. attilax的迷惑不解终于得到了答案
10
7.1. 为什么凡人们会贪生怕死？？
10
 
 
1. 唯一一本记录神而不是神的代言人或者先知言论的经典
 
。薄伽梵歌是印度教的重要经典与古印度瑜珈典籍，为古代印度的哲学教训诗，收载在印度两大史诗之一《摩诃婆罗多》中（位于Bhisma-Parva章节的23–40)，也简称为《歌（Gītā）》。它是唯一一本记录神而不是神的代言人或者先知言论的经典，共有700节诗句。成书于公元前五世纪到公元前二世纪，也有人译为“博伽梵歌”。
 
 
 
此诗原为大史诗《摩诃婆罗多》第六篇中的一部份。作者与成书年代均不详。学术界对此书的成书年代有甚多异说，而所推定的时间，大约是在西元前一千年，到西元后四世纪之间
 
体裁系采取对话方式，藉阿朱那（Arjuna）王子与黑天（Krişna）两人所作的问答，论述在既存的社会制度之中，必须毫无私心的各尽本分，以及应对唯一的神作绝对的归依与奉献。
 
其中所述及的道性与离欲解脱的光明，最 成为全印度教徒的福音书、信徒的座右铭
 

《薄伽梵歌》顾名思义是一段诗歌，一共有18章，主要解释了“真理”的五大概念：自在、存在、元素、职责和时间，宣扬无我的行为。

 
 《薄伽梵歌》虽是记述距今4500——4600年前的往事，但一直是以神话的形式流传。直至公元前500年左右， 。    在初次成书时，歌文较短，仅为现本的第一章，

 

作者:: 老哇的爪子 Attilax 艾龙，  EMAIL:1466519819@qq.com

转载请注明来源： http://blog.csdn.net/attilax
 
 
2. 篇章规模，字数
3. 内容摘要
4. 主要内容

《薄伽梵歌》顾名思义是一段诗歌，一共有18章，主要解释了“真理”的五大概念：自在、存在、元素、职责和时间，宣扬无我的行为。

4.1.1. 第一章（在库如雪查战场上阅兵）

第一章描述了阿朱那与黑天之间在俱卢之野战争前，在战场上的对话。当时的阿朱那看见许多亲戚朋友都在敌对阵营，感到难过而困惑，决定不再战斗。

4.1.2. 第二章（薄伽梵歌内容提要）

第二章讲阿朱那向正在充当他马车夫的黑天寻求指导。黑天对阿朱那的劝导采用了许多印度教基本的宗教信念与概念，黑天教育阿朱那只有身体能被杀死，而永恒的自我是不朽的，作为战士有义务通过战争获得达摩。

4.1.3. 第三章（行业瑜珈）

第三章里阿朱那问道如果知识比行动更重要的话为何还要战斗，黑天强调为了更大的善而恪守职责，行动比结果重要。黑天说：“不带罪业的阿朱那呀！我已解释了，这世上，觉悟我的人分两类。有些倾向于通过经验和哲学思辨了解我；另一些则倾向于通过奉献服务认识我。单终止活动，并不能远离业报；只靠弃绝，也无法达到完美。人皆无可奈何，被逼以物质自然形态的本能冲动活动。因此，谁也休想停止活动一刻。遏制活动的感官，心意却不离感官对象，是为自欺。谁如此，便称伪善者。相反，谁以心意控制感官，以活跃的感官从事奉献活动，而且没有依附，便崇高得多了。履行赋予给你的责任，因为行动比不行动好。不工作，甚至不能维持物质躯体……亲爱的阿朱那，不遵守《吠陀经》所赋定的祭祀牺牲制度生命必然充满罪业。耽于满足感官，虚耗生命而已。然而，在自我中找到快乐，在自我中找到启迪，而且，仅在自我中，便找到欣喜和满足--完全的满足：这样的人，再无责任”。

4.1.4. 第四章（超自然的知识）

黑天讲述他转世多次，为了保护虔诚者毁灭不敬者而传授瑜伽。黑天说：“当你如此得到了真知灼见，便会认识，一切生物不过是我的部分--他们全在我之中，而且属于我。即使你是恶中之恶，一旦登上超然知识之舟，便能渡过苦海。熊熊的火焰焚木成烬，阿朱那呀，知识的火焰也焚物质活动的业报成烬”。

4.1.5. 第五章（有为瑜伽——卡摩瑜伽）

阿朱那问道放弃抑或行动更好，黑天认为两种选择都可能有益，黑天说：：“抱着薄伽梵的意识练卡摩瑜伽，不再执着，那就高明多了”。

4.1.6. 第六章（数论瑜伽）

黑天传授了沉思的正确姿势和实现三昧途径。黑天说：“所谓弃绝，即是瑜伽--上接至尊。人除非弃绝感官快乐，否则不能够成为瑜伽师。对初习八重瑜伽的人，工作是手段；对已到达瑜伽境界的人，停止一切物质活动才是手段。弃绝一切物质欲望，活动而不为感官满足，不追求结果，可算到达瑜伽境界”。

4.1.7. 第七章（对真理的认识）

黑天传授了知识瑜伽。黑天说“全然知觉我，心意依附我于是彻底了解我一无疑惑……我是一切，但岿然独立。我不在物质自然的形态之中。整个世界被三种形态（善良、激情、愚昧）所蔽，对我一无所知。而我，超越这三种形态，并且，无穷无尽。物质自然的三种形态就是我的神圣能力，很难克服。皈依我的人，却轻而易举地超越了。恶徒显然愚昧，是人类的渣滓。知识被假象盗去，又带有邪魔的无神论本性，他们不会皈依我……无智慧者，不认识我，以为我至尊人格神奎师那以前是非人格的，现在才以这人格性的形体出现。由于知识浅薄，他们不认识我的高等本性--我不变和至高无上的本性。我永不向愚昧无智慧者展示自己。对于他们，我被自己的内在能量所蔽。因此，他们不认识我，尽管我无生，永不犯错。阿朱那呀！我是至尊人格首神，知道一切在过去发生的事情，知道一切现在正发生的事情，也知道一切未来会发生的事情。我认识一切生物，但谁也不认识我”。

4.1.8. 第八章（秦达至尊）

黑天定义了梵和业报等重要概念并解释了如何接近至尊上帝。黑天说：“不能毁灭的超然的生物称为梵。生物的永恒本性称为精神知识。跟发展物质身体有关的活动称为业报。体困生物中的俊杰呀，变化不止的物质自然称为不免一死的凡世；包括所有半神人如日月之神在内的主的宇宙形体称为上帝，而以超灵形式居于每一体困生物心中的至尊主称为祭祀之主。谁临死离开身体时，想着我，本性立即跟我相同。这是无可置疑的……上帝比一切伟大，可通过纯粹的奉献接近。他虽住在自己的居所中，却遍存万有，一切都在他之内”。

4.1.9. 第九章（最机密的知识）

黑天向阿朱那展现他与宇宙为一体的神身。黑天说“我以人的形体降临世上，愚人向我冷嘲热讽。他们不认识我的超然本性和超越一切存在的至高无上的领域。迷惑的人被邪恶和无神的观点吸引，受了蒙蔽，他们追求解脱，培养知识，进行业报活动，全是徒然的……我就是仪式、祭祀牺牲、供奉祖先的献品、治病的草药、超然的唱颂。我就是奶油、火、祭品……我是目标、维系者、主人、见证者、居所、庇所、最亲密的朋友。我是创造，也是毁灭。我是一切事物的基础，我是休止的地方，我是永恒的种子……即使人干了最可恶的事情，只要从事奉献活动，也可算圣洁，因为他的地位确当……心意恒想着我，顶拜崇奉我；全然专注于我，那么，你肯定到我这里来”。

4.1.10. 第十章（表现瑜伽——至尊者的富裕）

黑天描述了他是一切根源的表现。黑天说：“认识我无生、无始，是一切世界的上帝，那么，虽在众人之中，却不受蒙蔽，远离一切罪恶”。

4.1.11. 第十一章（宇宙形象）

黑天应阿朱那的请求展现了他的宇宙形体。黑天说：“我就是时间，世界最大的毁灭者。我到来要毁灭所有人。除了你们般度诸子，这里双方战士均将丧生……亲爱的阿朱那，为我作纯粹的奉献服务，远离以往活动的污染和心智推敲，泛爱一切生物，必能接近我”。

4.1.12. 第十二章（奉献瑜伽）

黑天讲述了奉献瑜伽。黑天说：“控制不同的感官，对生物一视同仁，努力为一切生物造福，以此全然崇拜非人格的绝对真理--未展示的、在感官知觉之外的、遍存万有的、不可思议的、固定不能移动的，如此，最后也能接近我……只要将你的心意专注于我--至尊人格神，将你一切的智慧奉献给我。如此，毫无怀疑，你常活在我之中”。

4.1.13. 第十三章（自然、享受者、与知觉）

黑天讲述了自然、享乐者和知觉。黑天说：“谦卑、不傲慢、不用暴力、容忍、真纯、接近真正的灵性导师、清洁、稳定、自制、弃绝感官享乐的对象、排除假我、认识生、老、病、死的不幸，不依附妻儿家庭等等，苦乐时皆心平气和、对我不断作纯粹奉献、常去幽寂的地方、远离一般大众、承认自觉的重要，对绝对真理作哲学研究--这一切我在此宣布为知识，与此相反的就是无知……据说，自然本性是一切物质活动和结果的原因，生物则是这个世界上各种不同苦乐的原因”。

4.1.14. 第十四章（物质自然的三种属性）

黑天讲述了物质自然的三种形态。黑天说：“物质的全体称为梵，是诞生的始源。我使梵受孕，一切生物始能诞生。琨缇之子呀！你须了解，各种各类的生物在这个物质自然中诞生，始能存在，而我就是撒下胚种的父亲。物质自然有三形态：善良、情欲、愚昧。生物跟自然接触，即受三形态的条件限制。无罪的人啊！善良形态比其他两形态纯粹，启蒙教化，使人远离一切罪恶业报。处于善良形态的人培养知识，但受快乐概念的条件限制……完全从事奉献服务，在任何情况都不会堕落，就立即超越物质自然的形态，并且到达梵的境界”。

4.1.15. 第十五章（至尊者的瑜伽）

黑天用植根天堂象征物质存在的树比喻。这棵树会被“脱离之斧”砍断，就不能前往黑天的永恒国度。黑天说：“有一棵榕树，根向上枝向下，叶就是吠陀颂歌。认识这棵树就认识吠陀经。这棵树的枝桠上下伸展，受物质自然三形态所滋养。小枝就是感官对象。这棵树也有向下生长的根，受人类社会的业报活动束缚。这棵树的真正形体在这个世界无法知觉。谁也不知道这棵树终于哪里、始于哪里、基础在哪里。然而，意志坚定就可以以脱离为武器，砍倒这棵树。如此一来，人就须找寻一个地方，到了就不用回来，而且可在那里皈依上帝。万物始于上帝，而且从太初以来，就依存于上帝。无错误的概念，不求虚荣，放弃虚假的关系，理解永恒，去除物质欲望，免于苦乐的相对，了解如何皈依上帝，就可到达永恒的国度”。

4.1.16. 第十六章（圣洁及邪恶的本性）

黑天描述了人类的神性和罪性。并讲到要放弃色欲、愤怒、贪婪和依靠圣经行事才能正确行事。黑天说：“无惧、净化存在、培养灵性知识、乐善好施、自我控制、举行祭祀、研习《吠陀经》、生活刻苦朴素、不用暴力、诚实、不嗔怒、弃绝、心境平和、不挑剔别人的错误、富同情心、不贪婪、慷慨、谦逊、决心坚定不移、有魄力、宽大、坚毅、洁净、无羡无妒、不贪慕虚荣——这些超然品质，巴茹阿特之后呀，属于天赋神圣本性的圣人。骄傲、自大、嗔怒、自负、苛刻、无知——这些品质属于邪恶本性，菩瑞塔之子呀！超然的品质带来解脱，邪恶的品质造成束缚。般度之子呀！不必忧心忡忡，因为你生下来就有神圣的品质……有三扇门导向地狱，就是色欲、愤怒、贪婪。每一个理智的人都要放弃之，因为这三个大敌只会引诱灵魂堕落……一个人应通过圣经的规范，了解什么是责任、什么不是责任。了解了这些规范和守则后，就得身体力行，逐渐提升自己。”

4.1.17. 第十七章（信仰的分类）

黑天讲述了信仰的三种类型。黑天说：“体困灵魂按照所处的三种不同的自然形态，信仰也划分三种：善良的、情欲的、愚昧的……在善良形态的人崇拜半神人；在情欲形态的人崇拜恶魔；在愚昧形态的人崇拜鬼魂和精灵……一切生物所吃的食物也根据物质自然之形态分为三类。祭祀牺牲、苦行、布施也如此……躯体的苦行包括：崇拜主、敬奉梵、灵性导师，尊敬象父母一样的尊长。洁净、朴素、独身、不用暴力也是躯体的苦行。言语苦行包括说真话，说有益的话，并且不说冒犯别人的话。一个人也该定时背诵《吠陀经》”。

4.1.18. 第十八章（结论——完美的弃绝）

黑天叫阿朱那舍弃一切达摩，仅仅听从黑天才是最完美的生命，最终成功说服阿朱那参战。黑天说：“祭祀牺牲、布施、赎罪苦修等活动不应放弃，反应进行。实际上，祭祀牺牲、布施、赎罪苦修甚至会净化伟大的灵魂。这一切活动进行时应不祈求结果。菩瑞塔之子呀！进行时应视之为责任。这就是我最后的意见……快乐来自感官与感官对象的接触，开始时好象甘露，最后却象毒药；这种快乐据说属于情欲形态……心意平和、自我控制、苦修、纯净无垢、容忍、诚实、智慧、知识、对宗教虔诚--这些都是梵赖以工作的品质……主是一切生物的源头，而且遍存万有。一面履行责任、一面崇拜主，就达到完美的境界……只有通过奉献服务，人才能真正认识上帝。通过这种奉献，全然知觉上帝，就能进入神的国度……放弃所有宗教，只要皈依我。我会把你从罪恶中拯救出来。不要害怕。”
5. attilax举得不错观点
5.1. 只有身体能被杀死，而永恒的自我是不朽的、
物体的表象可以变化，但是原则是不变的
正如一个人脱去己经穿破的衣服，重新穿上一件新的衣服。同样的，身体之内的居住者，抛弃了其老化的躯体，进住一个新体之中。死是对生的肯定，生又是对死的肯定。” 这被一些人用来解释DNA的自然复制和克隆。
 
5.2. 行动比结果重要
5.3. 人除非弃绝物欲，否则不能够成为大师
。对初习八重瑜伽的人，工作是手段；对已到达瑜伽境界的人，停止一切物质活动才是手段。弃绝一切物质欲望，活动而不为感官满足，不追求结果，可算到达瑜伽境界”。
 
 
只有苦行求梵，摆脱物欲，反观内心，才有希望超出轮回，得到解脱(涅磐，Nirvana)。怎么解脱呢？《薄伽梵歌》说：要尽本分，要苦修，还要笃信神灵。
 
5.4. 泛爱一切生物，必能接近我”。
5.5. 就是时间，世界最大的毁灭者。我到来要毁灭所有人。除了你们般度诸子，这里双方均将丧生
5.6. 了解如何皈依上天，就可到达永恒的国度
5.7. 依靠圣经行事才能正确行事
5.8. 举行祭祀、研习《吠陀经》、生活刻苦朴素 愤怒、贪婪俩大拦路石
5.9. 通过这种奉献，全然知觉上帝，就能进入神的国度……放弃一切，只要皈依会把从罪恶中拯救出来。 
5.10. 灵魂不生不灭，形体世世毁亡。 灵魂万劫不灭，永是亘古长存。
 
5.11. 长歌中充满了哲学智慧，其中之一就是生死轮回。
人和一切有情识的众生，在肉体死亡后，依业报有三道轮回：生前行善勤于修行者上升天界享天道，生前碌碌善大与恶者还生人世得祖道，生前行恶者入地狱受苦，然后转生为贱民或异类受恶道。“上而至于诸天，诸界皆有轮回。”
5.12. 　人的灵魂(Atman)与宇宙精神(梵，Brahman)本是一体，超越轮回。
但是因为“被世间万物迷了心窍”，不知“梵我合一”的道理，才会受轮回之苦。
 
 
6. attilax的心得
 

5千年前神的话语记录 ！讲述无限宇宙与流幻人生的终极真谛，使人获得心灵的宁静，重拾在纷繁琐乱中抉择的勇气！

 

 

面对宏伟的宇宙创造，自我只不过是沧海一栗，平日的自大太过可笑，唯有谦卑下来，与宇宙的创造者相连才是获得平安、吉祥的根本；

时而感到犹如站在喜马拉雅山之巅俯瞰世界，一切的真相尽收眼底，不禁为自己产生执著心、纷争心而感到汗颜，遗憾自己为什么浪费人生宝贵的时间去追求如昙花一现的短暂事物，而不为获得永恒而努力
 
 
7. attilax的迷惑不解终于得到了答案
7.1. 为什么凡人们会贪生怕死？？
灵魂不生不灭，形体世世毁亡。　　凡人不知此理，故而贪生怕死，　　圣者知灵永存，仅是旧换新裳。　　灵魂万劫不灭，永是亘古长存。　　人若明了此理，永无忧愁感伤，　　灵魂虽宿人体，却不会受杀伤。　　对于芸芸众生，不必忧愁悲怆，　　生死自有定数，只管勇猛前闯！”
 
 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

【图像处理笔记】比特平面分层
像素是由比特组成的数字。
例如，在256级的灰度图中，每个像素是由8比特（也就是1个字节）组成的。
代替突出灰度级范围，我们可以突出特定比特来为整个图像的外观做出贡献。


一幅8比特图像，可以认为是8个1比特的平面组成，其中平面1包含图像中所有像素的最低阶比特，而平面8包含图像中所有像素的最高阶比特。


显示一幅8比特图像的第8个比特平面并不困难，可对它进行二值化，0-127之间映射为0,128-255之间映射为1。
以下是vb.net实现的比特平面分层：


代码写的很丑陋/(ㄒoㄒ)/~~，见谅哈
'将一幅灰度图分为8个1比特的平面
Dim img As New Image(Of Gray, Byte)("C:\test3.bmp")
Dim height As Integer = img.Height
Dim width As Integer = img.Width
'初始化8个1比特的平面
Dim img1 As New Image(Of Gray, Byte)(width, height)
Dim img2 As New Image(Of Gray, Byte)(width, height)
Dim img3 As New Image(Of Gray, Byte)(width, height)
Dim img4 As New Image(Of Gray, Byte)(width, height)
Dim img5 As New Image(Of Gray, Byte)(width, height)
Dim img6 As New Image(Of Gray, Byte)(width, height)
Dim img7 As New Image(Of Gray, Byte)(width, height)
Dim img8 As New Image(Of Gray, Byte)(width, height)

For i = 0 To height - 1
    For j = 0 To width - 1
        '将像素值转化为二进制
        Dim binaryImgData As String = Val(Convert.ToString(img.Data(i, j, 0), 2)).ToString("00000000")
        img1.Data(i, j, 0) = Val(binaryImgData(7))
        If Val(binaryImgData(6)) = 0 Then
            img2.Data(i, j, 0) = 0
        Else
            img2.Data(i, j, 0) = 255
        End If
        If Val(binaryImgData(5)) = 0 Then
            img3.Data(i, j, 0) = 0
        Else
            img3.Data(i, j, 0) = 255
        End If
        If Val(binaryImgData(4)) = 0 Then
            img4.Data(i, j, 0) = 0
        Else
            img4.Data(i, j, 0) = 255
        End If
        If Val(binaryImgData(3)) = 0 Then
            img5.Data(i, j, 0) = 0
        Else
            img5.Data(i, j, 0) = 255
        End If
        If Val(binaryImgData(2)) = 0 Then
            img6.Data(i, j, 0) = 0
        Else
            img6.Data(i, j, 0) = 255
        End If
        If Val(binaryImgData(1)) = 0 Then
            img7.Data(i, j, 0) = 0
        Else
            img7.Data(i, j, 0) = 255
        End If
        If Val(binaryImgData(0)) = 0 Then
            img8.Data(i, j, 0) = 0
        Else
            img8.Data(i, j, 0) = 255
        End If
    Next
Next
img1.Save("C:\比特平面分层\img1.bmp")
img2.Save("C:\<span style="font-family: Arial, Helvetica, sans-serif;">比特平面分层\img2.bmp")</span>
img3.Save("C:\比特平面分层\img3.bmp")
img4.Save("C:\比特平面分层\img4.bmp")
img5.Save("C:\比特平面分层\img5.bmp")
img6.Save("C:\比特平面分层\img6.bmp")
img7.Save("C:\比特平面分层\img7.bmp")
img8.Save("C:\比特平面分层\img8.bmp")
以下是生成的比特平面1到8的图像
   
   

这8个1比特平面的显示很怪异。上面都是一个个光圈。。。
不知道是否跟光照有关。有想法的同学请不吝赐教~留言告诉我下，共同进步~


把一幅图像分解为比特平面，对于分析图像中的每个比特的相对重要性是很有用的，可以帮助我们确定用于量化该图像的比特数的充分性。
此外，这种类型的分解对于图像压缩也很有作用。在图像压缩中，重建一幅图像时，所用的平面要比全部平面少。
以下是用vb.net实现的比特平面重建：
For i = 0 To height - 1
    For j = 0 To width - 1
        '将像素值转化为二进制
        Dim binaryImgData As String = Val(Convert.ToString(img.Data(i, j, 0), 2)).ToString("00000000")
        img87reconstructed.Data(i, j, 0) = Val(binaryImgData(0)) * 2 ^ 7 + Val(binaryImgData(1)) * 2 ^ 6
        img876reconstructed.Data(i, j, 0) = Val(binaryImgData(0)) * 2 ^ 7 + Val(binaryImgData(1)) * 2 ^ 6 + Val(binaryImgData(2)) * 2 ^ 5
        img8765reconstructed.Data(i, j, 0) = Val(binaryImgData(0)) * 2 ^ 7 + Val(binaryImgData(1)) * 2 ^ 6 + Val(binaryImgData(2)) * 2 ^ 5 + Val(binaryImgData(3)) * 2 ^ 4
    Next
Next
img87reconstructed.Save("C:\比特平面分层\87重构.bmp")
img876reconstructed.Save("C:\比特平面分层\876重构.bmp")
img8765reconstructed.Save("C:\比特平面分层\8765重构.bmp")以下分别是用第8第7比特平面累加重构的图像、876、8765和原图像
   


在重构中，使用更多的平面对图像的外观不会有更大的贡献。
我们可以得出这样得结论：存储4个高比特平面所重建的图像，所损失的细节，是我们可以接受的。




博文中有不足之处，欢迎留言指教~











版权声明：本文为博主原创文章，未经博主允许不得转载。

想写一个网络游戏（PS：纯粹是为了好玩）
最近用java语言写了一个C/S的题库程序，这个程序设计的最初目的是为了方便那些即将毕业找工作，或者是准备找工作的人们来分享面试题的，用户提供题目和自己心目中的答案，其他用户可以评论，支持信息的推送...具体的细节就不在这里详谈了，在我上一篇文章中有提到。
这篇问题主要是想表述一下我这两周来一直准备的事情，我打算利用java+mysql+memcache+cocos2dx+lua+MMORPG的架构，来写一款网络游戏，游戏的具体内容未定，但是技术的解决方案我已经基本设计出来了，希望能找到有兴趣的童鞋一起做点好玩的事情。
我的大体思路是：
服务器端的设计：语言选择java开发效率高+socket编程+NIO（异步I/O同linux的select、poll、epoll差不多，目的是为了能处理更多的连接）+memcache（数据缓存，提高数据访问效率）+mysql+MMORPG（目的是为了更好的扩展性）
客户端的设计：游戏框架选择是cocos2dx，首先是利用C++在cocos2dx的基础上开发出游戏需要的相关UI组件、游戏特效、socket通信（C++和java的socket通信利用字节流来通信原理也是包头+包体的形式，当然其中少不了的还有加密）等；具体的UI界面的设计以及剧情的实现用lua脚本来编写，目的是为了便于游戏的更新（更新的方式在MMORPG中会提到），最后会将整个打包成为so文件，再在android上进行二次开发，最终发布成为app。


当然这只是大体上的思路，其中还有诸多细节需要考虑，在此后会不断的更新，当然也会伴随着源码，同时也希望感兴趣的童鞋能加入，一起做点好玩的事情。（感兴趣的童鞋可以留言）

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1054 Strategic Game（最小覆盖点-树形dp）
题目链接：点击打开链接
题意描述：给一棵树，找最少的点集能把树上的所有边覆盖掉？


解题思路：典型的最小覆盖点
树形dp即可
dp[i][0]:表示如果不选i点则dp[i][0]+=dp[t][1];///表示要选所有的儿子节点
dp[i][1]:表示如果选i点则dp[i][1]+=min(dp[t][0],dp[t][1]);///表示选择其儿子节点中较小的情况


代码：
#pragma comment(linker,"/STACK:1024000000,1024000000")
#include <cstdio>
#include <cstring>
#include <iostream>
#define MAXN 1510
using namespace std;
int head[MAXN],tol;
struct Edge{
    int v,next;
}edge[2*MAXN];
void addEdge(int u,int v){
    edge[tol].v=v;edge[tol].next=head[u];head[u]=tol++;
    edge[tol].v=u;edge[tol].next=head[v];head[v]=tol++;
}
int dp[MAXN][2];
void DP(int u,int p){
    dp[u][0]=0;
    dp[u][1]=1;
    int k,to;
    for(k=head[u];k!=-1;k=edge[k].next){
        to=edge[k].v;
        if(to==p) continue;
        DP(to,u);
        dp[u][0]+=dp[to][1];
        dp[u][1]+=min(dp[to][0],dp[to][1]);
    }
}
int n;
int main(){
    while(scanf("%d",&n)!=EOF){
        int u,v,num;
        tol=0;memset(head,-1,sizeof(head));
        for(int i=0;i<n;++i){ scanf("%d:(%d)",&u,&num);
            for(int j=0;j<num;++j){ scanf("%d",&v);addEdge(u,v);}
        }
        DP(0,0);
        printf("%d\n",min(dp[0][0],dp[1][1]));
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

matlab遇到问题-矩阵索引值超维问题
Index exceeds matrix dimensions.




Index exceeds matrix dimensions.


Error in igaPlateTensionxihua (line 281)
          dKdP(sctrB,sctrB,e)=
          dKdP(sctrB,sctrB,e)+eKdK(jacob,dPdy([leftlownode:leftlownode+2,leftlownode+19:leftlownode+21],[2*e-1:2*e]),dRdx,nn,C,J2,wt)


dKdP=zeros(24,24,6);  这是前面矩阵定义初始化的代码
而后面索引值超出。
遇到类似问题，应该看看前面矩阵定义的代码。看是否需要修改。
          ;
 


版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1879 继续畅通工程
如果已经建好，那就把vaule的值标记为0，然后模板走起，然后就没有然后了
数据量有点大，没关闭缓冲区TLE
#include<iostream>
#include<vector>
#define maxn 105
using namespace std;
int n;
const int inf=1<<31-1;
vector<int>mapp[maxn];
int vaule[maxn][maxn];
int visit[maxn];
void prim()//prim算法 
{
	int re=0;
	int d[maxn];
	fill(d,d+n+1,inf);
	fill(visit,visit+1+n,0);
	d[1]=0;
	while(1)
	{
		int v=-1;
		for(int i=1;i<=n;i++)
		{
			if(!visit[i]&&(v==-1||d[i]<d[v])) v=i;
		}
		if(v==-1||d[v]==inf) break;
		re+=d[v];
		visit[v]=1;
		for(int i=0;i<mapp[v].size();i++)
		{
			int x=mapp[v][i];
			if(!visit[x]&&vaule[v][x]<d[x]) d[x]=vaule[v][x];
		}
	}
	cout<<re<<endl;
}
int main()
{
	cin.sync_with_stdio(false);
	while(cin>>n&&n)
	{
		for(int i=1;i<=n;i++) mapp[i].clear();
		for(int i=0;i<n*(n-1)/2;i++)
		{
			int x,y,z,p;
			cin>>x>>y>>z>>p;
			if(x!=y)
			{
				mapp[x].push_back(y);
				mapp[y].push_back(x);
				if(p==1)
				{
					vaule[x][y]=0;
					vaule[y][x]=0;
				}
				else 
				{
					vaule[x][y]=z;
					vaule[y][x]=z;
				}	
			}
		}
		prim();
	}
	return 0;
} 


版权声明：本文为博主原创文章，未经博主允许不得转载。

数据平台之企业营销管理与分析平台建设
企业每天都在制造大量的经营数据，这些数据反映了企业生成、销售状况。营销分析是在广泛收集信息资料的基础上，运用各种定性和定量的方法，帮助管理层决策分析，更好的为开展营销工作服务。
一般而言营销管理分析系统包含以下几个基本要求：
①灵活弹性的报表设计，适应各个地区、情况的报表需求，能迎合企业需要快速反应企业状况；
②可视化的数据呈现方式，帮助企业领导层快速解读报表内容；
③多元化的数据分析维度，帮助企业发现数据隐含的意义。
建设企业营销管理和分析平台的背景
某公司的信息化建设主要借助SAP系统进行，缺陷是报表展现上不灵活，随着公司企业规模的扩大，对数据量和报表展现的要求也随之提高，SAP自带的数据处理和报表展现功能已无法满足公司现有业务需求，因此需要建设一个报表系统弥补数据处理、数据展现上的弱点，即满足从数据库中取数，生成报表，供领导检查和审阅，用于分析经营状况的需求。
营销和管理分析平台的模块规划
1、股份总公司销售指标
2 、成材率的多维度分析
3 、线体月产量综合分析
4 、期货到货的综合分析
5、期货订货的比例分析
6、  期货订货量统计分析
工具
SAP系统
报表开发工具：FineReport
 
成果展示：SAP系统中用finereport建成的营销管理和分析平台
1、股份总公司销售指标：数据图表结合的实时分析展现


2、材率的多级表单分析
 
3、线体月产量的综合分析表
 
4、期货到货情况分析汇总
 
5、期货订货比例分析
 

6、期货订货量分析表

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

白话空间统计十四：高/低值的聚类（上）
从上一篇讲零假设开始，大家就都知道又要进入各种神奇的统计学理论阶段了，但是因为吴道长的提醒，所以我尽量的不写成白皮书这种官方味道十足的东西。
 
今天我们来讲空间自相关的一个进阶衡量方法：高/低值的聚类。
 
以前都说了，空间数据的关系无非就三种可能——离散、随机、聚集，如下：


 
那么我们拿到数据之后，首先确定离散还是聚集，因为随机就没啥价值。只有确定了之后，才能绝对我们怎么去对付他，是清蒸还是红烧，或者是凉拌，都要看原料的。
 
至于如何确认，我们以前也讲了莫兰指数这个东东，当然，伴随着的肯定还有P值和Z得分神马的，有兴趣的同学，请查看以前文章。
 
那么拿到数据，确定由聚集的可能之后，又会发生什么事情呢？
 
我们继续看下面的例子：
 
继续来抛硬币：


一次性抛出16枚编好号的硬币，结果如上图。我把结果用红圈给圈出来了，大家就很容易的看见发生了聚集，而且这次试验的结果主要是反面发生了聚集。
 
所以，在我们发现了数据有聚类的可能性之后，我们还可以进一步的分析，到底是哪一类数据发生了聚集，这种能够判定是哪一类值产生了聚类的，就叫做“高/低值聚类”分析。
 
下面进入历史科普实践，这种用于判定高/值聚类的方法，最早是由美国乔治敦大学麦克多诺商学院(McDonough
 School of Business)的J. Keith Ord和圣地亚哥州立大学地理系的ArthurGetis两人提出，所以，这个算法通常由被称为：Getis-Ord General G分析。就是下面的两位帅哥（我一直对研究算法的人满怀敬意）：


 
与硬币只有两面不同，数据是可以划分为高值和低值的，如下图：
 
 
在前面衡量空间自相关的时候，用的参数是Moran'I（莫兰指数），那么在衡量搞低值聚类的时候，用的也是一个指数，这个指数叫做 General G 指数。
 
General G
指数与莫兰指数一样，皆是一种推论统计，即你把数据拿到之后的下一个步骤。比如你相亲时候，第一次把妹纸相片要到的时候，首先要做的自然就是看看是不是符合自己的审美观了，然后就是找找是否有PS的痕迹，通过小细节来想象一个下这个妹纸有哪些爱好性格啊之类；这种利用有限的数据来对整体情况的特征进行估计的过程，就是推论统计。
 
通过分析之后得到的结果，都会在零假设（以瞎猜为背景）的情况下进行解释。也就是说，你的计算出来的值，只是与瞎猜的结果相比较得出来的结论，并不代表真实的结果。
 
General G统计方法，认为零假设（瞎猜）是不存在聚类的。当你进行General G方法进行计算的时候，会得出一堆的值，如下：


 
Z的分和P值和方差是啥意思就不解释了，大家回头去看原来的文章，着重解释一下观察General
 G指数和期望General指数是什么东西。
 
首先，还是要看看数据是否有意义，因为P值代表了你这份数据是不是随机的，如下图所示：


 
P值就决定了你这份数据是否具有分析价值，如果我们能够进入下一步，那么Z值就变得重要起来。与空间相关性里面的Z值不同，在General
 G统计的计算中，Z值的正负符号是有意义的，如下：


 
看到这里就会有人跳出来了，你的观察General G指数和期望General
 G指数哪里去了？既然Z值都已经把你要高/低值聚类都标示出来了，这个两个指数还有啥用？
 
别急，继续往下看。
 
我们开始说了，General G方法，是用来探索高\值聚类的方法，那么这两种指数也是用来衡量到底是发生了高值聚类还是低值聚类的。
 
单独一个指数是没有什么意义的，既然他给了两个指数，是表示，让你来进行比较的。在算法上，只要Z得分是正数，那么一般来说观察指数就要大于期望指数，而如果Z得分是负数，那么期望指数就要大于观察指数，如下：


 
那么把两个图组合起来，就得到了如下结果：
 
Z得分为正——观察General G指数大于期望GeneralG指数——数据在高值区域聚类。
Z得分为负——期望General G指数大于观察GeneralG指数——数据在低值区域聚类。
 
但是，正如每个人小时候都被其他的熊长辈挑拨离间过——“你是喜欢粑粑还是麻麻？”往往把小孩弄得不知所措，而父母也会教小孩如何对付这些熊长辈“说‘都喜欢’”，然后皆大欢喜一样。一份数据如果同时在高值和低值区域都表现出了聚类，怎么办？
 
那么很容易出现的就是观察GeneralG指数和期望General
 G指数相等的情况，那么这种情况用官方的话说，就是“高值和低值同时聚类时，它们倾向于彼此相互抵消。”如下图：


 
遇上这种高低值全部都聚类情况，基本上就可以直接放弃使用这个工具了，改用空间自相关工具即可（Globe Moran' I）。
 
所以，很明显的看出，这个工具主要是去寻找高值或者低值有其中一方发生聚类的时候，才能发挥出他的价值。
 
（待续未完）


版权声明：本文为博主原创文章，未经博主允许不得转载。

CSU 残缺的棋盘 (BFS)
Description




Input


输入包含不超过10000 组数据。每组数据包含6个整数r1, c1, r2, c2, r3, c3 (1<=r1, c1, r2, c2, r3, c3<=8). 三个格子A, B, C保证各不相同。

Output


对于每组数据，输出测试点编号和最少步数。

Sample Input
<span class="sampledata">1 1 8 7 5 6
1 1 3 3 2 2</span>
Sample Output
<span class="sampledata">Case 1: 7
Case 2: 3</span><span class="sampledata"></span><pre name="code" class="html">#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int di,dj,r,c;
int m[9][9];
struct node
{
	int i,j,time;
};
queue<node>qq;
int x[8]={0,1,1,1,0,-1,-1,-1},y[8]={1,1,0,-1,-1,-1,0,1};

void bfs()
{
	while(!qq.empty()) {
		node temp=qq.front();
		node t=temp;
		qq.pop();
		if(t.i==r&&t.j==c) break;
		for(int i=0;i<8;i++) {
			t=temp;
			t.i+=x[i];
			t.j+=y[i];
			t.time+=1;
			if(t.i<1 || t.i>8 ||t.j<1 || t.j>8) continue;
			if(t.i==r && t.j==c) continue;
			if(t.time<m[t.i][t.j]) {
				m[t.i][t.j]=t.time;
				qq.push(t);
			}
		}
	}
}


int main()
{
	int si,sj,i,j,sigh;
	sigh=0;
	while(cin>>si>>sj>>di>>dj>>r>>c) {
		for(i=1;i<9;i++) {
			for(j=1;j<9;j++)
			m[i][j]=10000;
		}
		m[si][sj]=0;
		while(!qq.empty()) qq.pop();
		node temp={si,sj,0};
		qq.push(temp);
		bfs();
		printf("Case %d: %d\n",++sigh,m[di][dj]);
	}
}


<span class="sampledata">
</span>



版权声明：本文为博主原创文章，未经博主允许不得转载。

操作系统实践（8）——从Loader到内核
到目前为止，我们写的代码都是用汇编写的，汇编的缺点就是，第一遍写完了，回头再过来看，又忘了，晦涩难懂。其实我感觉，写汇编的好处，就是能让自己去多了解一下cpu还有其它硬件的结构。硬件的的架构，决定软件的实现方式，硬件就好比基因，软件就是一个个的动物个体。

本次实践涵盖的内容包括《orange’s一个操作系统的实现》书中的第三章末尾、第四章、第五章。因为这些东西比较紧凑。
捋一下思路： 
1. 中断与异常，在保护模式下是非常重要的一部分。 
        写过java代码的同学一定写过”try{}catch(Exception e)”进行异常捕获，也写过类似各种观察者模式类似”onEvent(event,handler)” 的代码。 中断与异常的处理，其实就是这种思想：a.用一个表格，注册一下各种事件发生的时候应该如何处理；2.当cpu执行时发生异常或者中断，就到这个表格中找到相应的处理程序进行处理。
2.用C语言写内核！ 
其实掌握了上面提到的异常与中断处理机制，接下去，要实现一个操作系统，完全可以用汇编接着写下去。但是，这实在让人崩溃，因为我们还有更好的方法，用C语言写！ 书中第四章和第五章，主要目标就是这个。 
        有了这个目标，接下来就需要解决几个问题： 
        a. 内核代码会越来越多，而512字节的引导区明显会不够用，怎么办？ 
        b. 如果使用C语言写代码，原有的汇编代码如何与C代码相互调用？ 
        c. 用gcc或者其它编译工具编译后的目标文件，格式与nasm直接编译的汇编代码文件格式不一样，而我们还要把这些编译后的代码加载到内存然后执行它呢！怎么办？ 
        d. 当我们的工程文件越来越多，怎么管理这么多文件？
书中提出的一种解决方案：
a.  引导区的512字节不够用，那就用这512字节的代码，把“Loader”加载到内存里，而“Loader”的任务就是，把“内核”加载到内存里，然后进入保护模式。我们的实践里，系统最后是刻录进一个1.44M的软盘里，所以书中简单介绍了一些FAT12文件系统的格式，重点的就是，如何把文件存进去，然后如何用代码把文件读出来。实践中，我们就把引导、Loader和内核的代码按照这种格式放入到软盘，然后按照文件系统的格式，把代码或者数据读入内存即可。
b. C代码与汇编代码相互调用的问题比较简单，这里推荐一本书《程序员的自我修养——链接与装载》。其实C代码编译后也是汇编代码，而这个问题跟链接的机制关系很大，了解链接器如何工作就能很好的理解这个问题。
c. 书中是以gcc编译器为例，编译后是ELF格式的文件，作者只讲了一些目前够用的ELF格式的知识，其实ELF格式还挺复杂的。
d. 管理工程文件，书中介绍了Makefile文件的一些基本用法，用make来管理工程中文件的各种复杂依赖关系。
这里看下最终的结果截图： 
已经进入内核阶段，并且监听键盘的中断。 


因为涉及的具体细节比较多，这里不打算拎出一堆代码，只记录本次实践中遇到的一些问题
1. lgdt 和 lidt 指令，载入的地址其实是一个线性地址，gdt表和idt表里面存的也是线性地址，
如果没注意这个的话，在进入保护模式，分页机制建立起来后，对于gdt表的访问可能会有些疑惑。

“LGDT and LIDT appear in operating system software; they are not used in application programs. They are the only instructions that directly load a linear address (i.e., not a segment relative address) in 80386 Protected Mode.”
2. FAT什么意思？

File Allocation Table ( 文件分配表) 
文件开始簇号，这里就限制了文件开始位置为某个扇区的起始位置，所以会有很多碎片，空间利用率不高。
3.文中提到，FAT12的数据区的第一个簇的簇号是2，而不是0或者1。为什么？

书中并没有详细解释，在这里找到了答案。FAT12文件系统 数据存储方式详解FAT表开始扇区的第1字节是存储介质，0f0h代表软盘，0f8代表硬盘；第2、3这两个字节都是0ffh，代表了FAT文件分配表标识符，从第四个字节开始与用户数据区所有的簇一一对应，应该注意的是，用户数据区的第一个簇的序号是002，而不是000，因为储存介质和标识符占用了这两个序号。
4. 如何挂载软驱，怎么把loader、kernel.bin文件拷贝到软盘里去?

书中的例子有点坑爹，因为下载下来的a.img,在freedos下，压根找不着那个edit.ext 工具。其实可以参考这个：【orange】OrangeS一个操作系统的实现：第四章实践方面遇到的一些问题,里面提到的方法，就是把软盘在freedos格式化为FAT12的格式，然后mount到系统的软驱，然后直接把loader和kernel文件拷贝进去即可。而引导部分的代码，已经设计为FAT12的格式，直接覆盖img的头部，这样就ok了。
5. 关于书中的"jmp     SELECTOR_KERNEL_CS:csinit" ; 这个跳转指令强制使用刚刚初始化的结构。    
在这之前已经初始化了gdt，并且已经开启了分页机制，而这里的csinit是kernel.asm文件中的标号，为什么能直接jmp?

这个问题我现在没有确定的答案，不过在进行代码跟踪的时候发现，csinit这个标号，编译的时候已经被编译为一个线性地址，而不是一个偏移量，猜想这一步变化是发生在链接的时候，也就是进行 “ld -Ttext …”的时候发生变化的。如果读者有更准确的解释，请留言，谢谢。
6.gcc编译书中的例子，链接的时候报错？

我是在Ubuntu 13.10 64位下进行实验的，所以在gcc 编译文件的时候需要加上 -m32参数，而链接的时候，需要加上 -m elf_i386参数。
7."klib.c:(.text+0xe6): undefined reference to `__stack_chk_fail'"

原因：函数里并没有对堆栈进行保护。答案参考这个：CodeDump : StackSmash,里面的解决办法是在gcc编译的时候临时加上 -fno-stack-protector 这个参数，而实际解决办法，应该从代码入手，像 
void func(){ 
                char array[10]; 
            gets(array); 
} 
这样的代码，有潜在的栈越界问题。
8.hlt指令

HLT 使 CPU 进入这么一个状态：既不取指令，也不读写数据，总线上“静悄悄”的。这条指令用的地方不多，一般用于等外部中断。
9.ud2指令

UD2是一种让CPU产生invalid opcode exception的软件指令.  内核发现CPU出现这个异常, 会立即停止运行。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5411 CRB and puzzle (Dp + 矩阵快速幂）

CRB and Puzzle
Time Limit: 2000/1000 MS (Java/Others)    Memory
 Limit: 65536/65536 K (Java/Others)
Total Submission(s): 483    Accepted Submission(s): 198



Problem Description

CRB is now playing Jigsaw Puzzle.
There are  kinds
 of pieces with infinite supply.
He can assemble one piece to the right side of the previously assembled one.
For each kind of pieces, only restricted kinds can be assembled with.
How many different patterns he can assemble with at most  pieces?
 (Two patterns  and  are
 considered different if their lengths are different or there exists an integer  such
 that -th
 piece of  is
 different from corresponding piece of .)


 


Input

There are multiple test cases. The first line of input contains an integer ,
 indicating the number of test cases. For each test case:
The first line contains two integers ,  denoting
 the number of kinds of pieces and the maximum number of moves.
Then  lines
 follow. -th
 line is described as following format.
k 
Here  is
 the number of kinds which can be assembled to the right of the -th
 kind. Next  integers
 represent each of them.
1 ≤  ≤
 20
1 ≤  ≤
 50
1 ≤  ≤ 
0 ≤  ≤ 
1 ≤  <  <
 … <  ≤
 N



 


Output

For each test case, output a single integer - number of different patterns modulo 2015.

 


Sample Input

1
3 2
1 2
1 3
0


 


Sample Output

6
Hintpossible patterns are ∅, 1, 2, 3, 1→2, 2→3 


 


Author

KUT（DPRK）




解题思路：
DP方程很容易想到 dp[i][j] = sum(dp[i-1][k] <k,j>连通） 构造矩阵用矩阵快速幂加速即可。

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <queue>
#include <set>
#include <map>
#include <algorithm>
#define LL long long
using namespace std;
const int MAXN = 55 + 10;
const int mod = 2015;
int n, m;
struct Matrix
{
    int m[MAXN][MAXN];
    Matrix(){memset(m, 0, sizeof(m));}
    Matrix operator * (const Matrix &b)const
    {
        Matrix res;
        for(int i=1;i<=n+1;i++)
        {
            for(int j=1;j<=n+1;j++)
            {
                for(int k=1;k<=n+1;k++)
                {
                    res.m[i][j] = (res.m[i][j] + m[i][k] * b.m[k][j]) % mod;
                }
            }
        }
        return res;
    }
};
Matrix pow_mod(Matrix a, int b)
{
    Matrix res;
    for(int i=1;i<=n+1;i++) res.m[i][i] = 1;
    while(b)
    {
        if(b & 1) res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}
int main()
{
    int T;
    scanf("%d", &T);
    while(T--)
    {
        Matrix a, b;
        scanf("%d%d", &n, &m);
        for(int i=1;i<=n+1;i++) a.m[i][n+1] = 1;
        for(int i=1;i<=n;i++)
        {
            int x, k;scanf("%d", &k);
            for(;k--;)
            {
                scanf("%d", &x);
                a.m[i][x] = 1;
            }
        }
        a = pow_mod(a, m);
        int ans = 0;
        for(int i=1;i<=n+1;i++) ans = (ans + a.m[i][n+1]) % mod;
        printf("%d\n", ans);
    }
    return 0;
}



 

版权声明：本文为博主原创文章，未经博主允许不得转载。

Windows下如何将cmd命令添加到右键菜单
Windows下如何将cmd命令添加到右键菜单
由于经常要使用到cmd命令，为了省去每次重新打开cmd窗口后层层寻找目标路径的麻烦，找了一个办法将cmd命令添加到右键菜单里，这样在目标路径下就可以直接右键进入，实现方法如下：

打开注册表 
win+R 快捷键打开“运行”窗口，输入regedit 点击“确定”即可打开注册表编辑器
添加注册项 
1、在左侧依次找到[HKEY_CLASSESS_ROOT\Folder\shell]子键，在其下新建“cmdPrompt”子项，在窗口右侧名称列上点击右键 - 修改，将数值数据改为“打开命令行”，确定，如下图: 
 
2、再在这个项下，新建名为“command”子项，同样修改数值数据修改为c:\windows\system32\cmd.exe cd “%1”，如下图： 

此时，找一文件夹右击可看到右键菜单中已出现“打开命令行”选项，使用即可。



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

每天5道面试题（二）java基础
说出Servlet的生命周期，并说出Servlet和CGI的区别
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。 
与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。
说出ArrayList,Vector, LinkedList的存储性能和特性
ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
HashMap和Hashtable的区别
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。

HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 
HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。  
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 
最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。  
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。
Collection 和 Collections的区别
　　Collection是集合类的上级接口，继承与他的接口主要有Set 和List. 
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
&和&&的区别
&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）。


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[UVA 11853]Paintball[DFS]
题目链接：[UVA 11853]Paintball[DFS]
题意分析：
在一个1000*1000的方块场地中，你需要从最左边开始一路避开敌人的攻击到达最右边。敌人有自己的坐标以及攻击范围，也就是一个圆形范围内你都不能碰到，问你能到达最右边吗？能的话输出左边进入的最大坐标（0，Ymax)， 右边出去的最大坐标（1000,Ymax)。
解题思路：
什么情况下不能到达目标呢？只有这种情况，也就是相邻的圆连接起来隔断了整个地图，否则都是可以到达的。这样的话，一个dfs直接判断就行了。剩下的是坐标怎么找到，首先默认最大坐标为(0,1000)和(1000,1000)，什么时候不能从这个点出发呢？以最左边的进入点为例：如下图


此时，最高点，只能是红色点。可以发现，仅有这种从入点到其最上方都被挡住的情况，才会使得进入点下移。这样我们在dfs判断是否被隔断的时候，就可以顺手判断最高点位置了。
个人感受：
嘛，好好写也不是太难啊这题。不过CE了好多发，说我定义的变量y1 y2被定义成了其它东西，最后只能改成ans1、ans2。也不知道为啥。
具体代码如下：

#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int INF = 0x7f7f7f7f, MAXN = 1111;
double ans1, ans2; //左边最大y值，右边最大y值
bool flag, vis[MAXN];
struct Circle{
    double x, y, r;
    void read()
    {
        scanf("%lf%lf%lf", &x, &y, &r);
    }
}circle[MAXN];

vector<int> G[MAXN];

double DIS(int a, int b) //圆心间距离
{
    double dx = circle[a].x - circle[b].x;
    double dy = circle[a].y - circle[b].y;
    return sqrt(dx * dx + dy * dy);
}

void dfs(int u)
{
    if (flag || vis[u]) return;
    vis[u] = 1;
    if (circle[u].y <= circle[u].r) //和下边界相交，无法到达
    {
        flag = 1; return;
    }
    //如果和最左边或者最右边相交，则更新
    if (circle[u].x <= circle[u].r) ans1 = min(ans1, circle[u].y - sqrt(circle[u].r*circle[u].r - circle[u].x*circle[u].x));
    if (circle[u].x + circle[u].r >= 1000) ans2 = min(ans2, circle[u].y - sqrt(circle[u].r*circle[u].r - (1000 - circle[u].x)*(1000 - circle[u].x)));
    for (int i = 0; i < G[u].size(); ++i)
    {
        dfs(G[u][i]);
    }
}

int main()
{
    int n;
    while (~scanf("%d", &n))
    {
        ans1 = ans2 = 1000.0;
        for (int i = 0; i < n; ++i)
        {
            circle[i].read();
            G[i].clear();
        }
        for (int i = 0; i < n; ++i) //预处理出圆与圆间的连接关系，方便dfs访问
        {
            for (int j = i + 1; j < n; ++j)
            {
                if (DIS(i, j) <= circle[i].r + circle[j].r)
                {
                    G[i].push_back(j);
                    G[j].push_back(i);
                }
            }
        }
        flag = 0;
        memset(vis, 0, sizeof vis);
        for (int i = 0; i < n; ++i)
        {
            if (circle[i].r + circle[i].y >= 1000)
                dfs(i);
        }
        if (flag) printf("IMPOSSIBLE\n");
        else printf("%.2f %.2f %.2f %.2f\n", 0.0, ans1, 1000.0, ans2);
    }
    return 0;
}




版权声明：欢迎转载(^ω^)~不过转载请注明原文出处：http://blog.csdn.net/catglory ლ(╹◡╹ლ)

面试前连这些也做不到，你还想成功？



　　接到面试通知后，有点迷茫：面试前到底该做些什么？怎样的准备才能让自己在面试时呈现最好的状态，提高面试成功率？以下是凝聚了众多求职过来人的经验，汇聚而成的面试准备精华。吸收了这些，面试时你也能做得更好！


公司方面： 

　　关于公司本身：了解对方公司的企业性质，规模，产品，所在行业，近年发展，员工评价、薪酬水平等基本信息。可以运用网络搜索引擎或者登录公司官网查看，还可以查看工商局和税务局网页上公司的注册信息来判断公司的可靠性。


　　关于应聘职位：熟读招聘启示，了解岗位要求，岗位职责。 

　　关于交通：必须至少提前一天查看好交通路线，尤其要关注下天气状况，估算好时间，预留找路和可能会拥堵的时间，避免面试迟到。 

　　关于面试官：如果知道面试官的名字，可以搜索他的背景和喜好，这一点在面试通知邮件或是电话里也许能得到一些线索。 

自身方面： 

　　面试必问：有些问题是可以明确知道会在面试时被询问到的，在面试前，一定要对此有所准备。 

  　①自我介绍：自我介绍突出与岗位匹配的自身亮点。 

　　②与岗位相关的经历：可以结合自己的专业和经验与岗位描述列举几个例子，表现自己在岗位上的经验与技能。 

　　③“还有什么疑问”：根据之前查阅的公司相关资料，预想好一些问题。 

　　面试必带：相片、个人简历、黑色水笔、工作证明、学历证明、相关证书等等。还要准备符合应聘企业风格的全套面试着装，比如商务型的企业可准备相对来说正式些的套装。 

　　面试必须：自信、愉快正面的心态、良好的精神面貌。（完）

版权声明：本文为博主原创文章，未经博主允许不得转载。

后缀数组（一）


o(︶︿︶)o 唉，也是为了应付知识储备太少，万一遇到了类似的题不知道用啥算法就蛋疼了，所以来恶补一下这些东西。
囤一发模板，详细讲解请见2009罗橞骞的论文《后缀数组--处理字符串的有力工具》,基本网上所有的讲解都是来自这篇文章，代码也是这篇论文上的，就不说啥了。

#include<bits/stdc++.h>
using namespace std;
#define MAXN 100010
char s[MAXN];
int A[MAXN];
//为了方便基数排序,我们把s中的字符转换成数字.s和A的下标使用统一0-n-1 
int sa[MAXN],rank[MAXN];//最后结果的rank和sa
int Count[MAXN];//基数排序计数器 
int l[MAXN],r[MAXN],tmp[MAXN];//基数排序共有两个关键字,r为第二关键字基数排序结果,l值即临时rank值. 
int n,maxn;//计数上界 
bool comp(int *A,int a,int b,int len)//字符串比较 
{
    return A[a]==A[b]&&A[a+len]==A[b+len];
}
int main()
{
    /*省略读入等奇怪的过程*/
    int i,j,k,*x=l,*y=r;//后面会整体交换l,r为了方便使用指针 
    for (i=0;i<maxn;i++)    Count[i]=0;
    for (i=0;i<n;i++)   Count[x[i]=A[i]]++;//第一次基数排序 
    for (i=1;i<maxn;i++)    Count[i]+=Count[i-1];
    for (i=n-1;i>=0;i--)    sa[--Count[x[i]]]=i;//初始的sa 
    for (k=1,i=1;i<n;k<<=1,maxn=i)
    {
        for (i=0,j=n-i;j<n;j++) y[i++]=i;//第二次基数排序
        for (j=0;j<n;j++)   if (sa[j]>=k)   y[i++]=sa[j]-k;
        for (j=0;j<n;j++)   tmp[j]=x[y[j]];
        for (j=0;j<maxn;j++)    Count[j]=0;
        for (j=0;j<n;j++)   Count[tmp[j]]++;
        for (j=1;j<maxn;j++)    Count[j]+=Count[j-1];
        for (j=n-1;j>=0;j--)    sa[--Count[tmp[j]]]=y[j];//更新sa 
        for (swap(x,y),i=1,x[sa[0]]=0,j=1;j<n;j++)  x[sa[j]]=comp(y,sa[j-1],sa[j],k)?i-1:i++;//更新rank
        //在更新过程中可能有两字符串rank值相同,此时比较两字符串是否完全相同来区分rank值
        //由于y数组在被用来更新sa后已经无用(下一次会重新求),节省空间使用y保存rank 
    }
}

o(︶︿︶)o 唉，也是为了应付知识储备太少，万一遇到了类似的题不知道用啥算法就蛋疼了，所以来恶补一下这些东西。

版权声明：本文为博主原创文章,转载请注明出处http://blog.csdn.net/hitwhacmer1

Vijos P1023Victoria的舞会3【贪心+DFS求强联通分量】

链接：Click
 Me！

P1023Victoria的舞会3
Accepted


标签：Victoria的舞会[显示标签]



描述

Victoria是一位颇有成就的艺术家，他因油画作品《我爱北京天安门》闻名于世界。现在，他为了报答帮助他的同行们，准备开一个舞会。
Victoria准备邀请n个已经确定的人，可是问题来了：
这n个人每一个人都有一个小花名册，名册里面写着他能够通知到的人的名字。比如说在A的人名单里写了B，那么表示A能够通知到B；但是B的名单里不见的有A，也就是说B不见得通知到A。
Victoria觉得需要确定自己需要通知多少个人m，能够实际将所有人n都通知到。并求出一种方案以确定m的最小值是多少。
注意：自己的名单里面不会有自己的名字。Victoria可以自身通知到所有n个人。




格式

输入格式

第一行一个数n。接下来n行，每i+1行表示编号为i的人的小花名册名单，名单以0结束。\
1<=n<=200。

输出格式

一个数，m。





样例1

样例输入1[复制]




18
0
11 0
0
0
0
16 0
14 0
0
0
0
2 13 0
0
11 0
7 0
0
6 0
0
0

样例输出1[复制]




14







题意：
给定N个顶点，每个顶点将于其他若干个点单向连通，求最少用几个顶点可以把这N个顶点构成一个单向连通图。
分析：
遍历每个顶点，如果这个顶点之前没有被标记，并且，它连接的节点全未被标记，那么可以将答案加1，然后将它可以到达的顶点ＤＦＳ标记；如果这个顶点之前没有被标记，并且，它连接的节点有一个被标记，那么因为它连接的节点既然被标记了，那么，先标记该节点，那么与它相连的其他节点自然会被标记，而且，得到的ans 不会比之前的大，【贪心策略】，，如果遍历的当前节点之前就被标记了，那么这个节点就直接跳过，此时考虑这个节点是没有意义的了。
代码实现:
#include <cmath>
#include <queue>
#include <vector>
#include <cstdio>
#include <string>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <algorithm>
using namespace std;
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#define FIN             freopen("input.txt","r",stdin)
#define FOUT            freopen("output.txt","w",stdout)
#define CASE(T)         for(scanf("%d",&T);T--;)
typedef long long LL;
const int maxn = 200 + 5;
const int INF = 0x3f3f3f3f;
int N, M, ans;
vector<int> G[maxn];
bool vis[maxn];
void init()
{
    memset(vis, false, sizeof(vis));
    for(int i = 1; i <= N; i++)
    {
        G[i].clear();
    }
}
void Mark(int cur)
{
    if(vis[cur]) return;
    vis[cur] = true;
    for(int i = 0; i < G[cur].size(); i++)
    {
        if(vis[G[cur][i]]) continue;
        Mark(G[cur][i]);
    }
}
inline bool judge(int x)
{
    for(int i = 0; i < G[x].size(); i++)
        if(vis[G[x][i]]) return false;
    return true;
}
int main()
{
    // FIN;
    int t;
    while(~scanf("%d", &N))
    {
        init();
        for(int i = 1; i <= N; i++)
        {
            while(1)
            {
                scanf("%d", &t);
                if(t == 0) break;
                G[i].push_back(t);
            }
        }
        ans = 0;
        for(int i = 1; i <= N; i++)
        {
            if(vis[i]) continue;
            if(judge(i)) ans++;
            Mark(i);
        }
        printf("%d\n", ans);
    }
    return 0;
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

IPV4理论知识








IPV4理论知识








 
前言
 
每次看见其他同学写的博客,感觉好高大上啊,好羡慕哦,而且好拥有自己的个人网站,搞得自己老炫酷了,羡慕中,学习中,奋斗中.本节内容主要围绕ipv4的一点小知识给大家说说.
 
 
定义
 
在TCP/IP协议族中,用于在IP层识别连接到因特网设备的标识符称为因特网地址或者IP地址,IPV4第是是一个32位的地址.
 
 
地址空间
 
想IPV4这种定义了地址的协议豆油一个地址空间.地址空间就是协议所使用的地址的总数.如果一个协议用b位来定义地址,那么这个协议的地址空间就是2^b.根据这个我们就能够知道IPv4的地址空间是2^32(超过了40亿).
 
 
IPv4地址的记法
 
IPv4地址的激发有下面三种方式:
 
1.    二进制记法
 
2.    点分十进制记法(我们最常见的)
 
3.    16进制记法
 
 
 
二进制记法
 
在二进制记法中,IPv4的地址表现为32位.为了使这个地址有更好的可读性,通常每88位之间加一个空格.下面是ipv4地址的二进制记法的一个案例:
11111111 00000000 11111111 10101010
 
 
 
点分十进制记法
 
我们看上面的二进制记法不怎么方便阅读,那现实生活中我们采用的就是点分十进制记法.因为1个字节表示的数字范围是0-255之间.那么我们采用10进制记法来记忆ipv4地址.就可以采用4个0-255的10进制数字来表示:
192.168.0.1
 
 
 
16进制记法
 
一个十六进制可以用来表示4位2进制数据,那么ipv4用16进制记忆就需要用8个16进制的数表示.将二进制记法的每4位转成16进制就是ipv4的16进制的记法.这种激发在ipv4中很少见.但是ipv6就是采用16进制的.(关于ipv6的内容后面说)
 
 
地址段
 
假设我们知道一段地址的首地址和末地址,那怎么知道这个地址段的地址个数呢?看看下面的做法:
 
问题:
假设一段地址的首地址位146.102.29.0,末地址位146.102.32.255,求这个地址段的地址个数.
 
解答:
我们可以使用基256计数法的减法运算,让末地址减去首地址.在基256计数法下得到的结果为0.0.3.255(就是一位对应着一位相减).为了算出这个地址段的地址数(以十进制表示),我们将这个数转换为基10计数法,结果再加上1:
 
地址的数目=(0*256^3+0*256^2+3*25661+155*256^0)+1=1024.
 
明白了吗?估计稍微懂一点计算机系统的人应该很快就能明白.
 
 
 
 



来

版权声明：本文为博主原创文章，未经博主允许不得转载。

博主的缺点
吾日三省吾身，我发觉人出了社会时间稍微长一点，没有了刚出学校的那种兴奋了，但是拼劲还是有的，毕竟也还很年轻，然而身上总会有一种淡淡的忧愁与哀伤。
人为什么会忧愁啦，一是不在乎和人相比，发现自己没有别人过得好，某某某又出国了，某某某又涨薪了，某某某又升职了。然而现在的我，早已学会不和别人攀比，只需要努力的去追逐梦想，慢慢的就有拥有你想要的东西。


二是生活中的琐事，这不刚出差了几天，发觉办公的地方很不习惯啊，每天和数据库打交道，导入导出数据，查询数据，甚感厌烦啊。


三是身体上的不安，为何会不安，放假待在家里头就有点闷，想去学点东西，注意力总是不集中，打了会游戏发现很HI，但是打完游戏，到了反思的时候，发觉自己又慌度了一天，内心焦躁不安。


好了三个小小的忧愁就可以看出我这个人的缺点了，
1.内心不够强大，会产生嫉妒心理。
2.梦想不够坚定，付出的与理想的总是差一些。
3.技术一般，不然就找一个好点的公司了，以后要恶补技术。
4.喜欢玩游戏，以后要少玩。
5.优柔寡断，做了的事情，就不要后悔。
最后鼓励下自己，以后要多努力，像王大锤一样，升职加薪 当上总经理 出任ceo 迎娶白富美，走上人生的巅峰，想想都有点小兴奋。

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5015 233Matrix （构造矩阵）

233 Matrix
Time Limit: 10000/5000 MS (Java/Others)    Memory
 Limit: 65536/65536 K (Java/Others)
Total Submission(s): 1399    Accepted Submission(s): 826



Problem Description

In our daily life we often use 233 to express our feelings. Actually, we may say 2333, 23333, or 233333 ... in the same meaning. And here is the question: Suppose we have a matrix called 233 matrix. In the first line, it would be 233, 2333, 23333... (it means
 a0,1 = 233,a0,2 = 2333,a0,3 = 23333...) Besides, in 233 matrix, we got ai,j = ai-1,j +ai,j-1( i,j ≠ 0). Now you have known a1,0,a2,0,...,an,0, could you tell
 me an,m in the 233 matrix?

 


Input

There are multiple test cases. Please process till EOF.

For each case, the first line contains two postive integers n,m(n ≤ 10,m ≤ 109). The second line contains n integers, a1,0,a2,0,...,an,0(0 ≤ ai,0 < 231).

 


Output

For each case, output an,m mod 10000007.

 


Sample Input

1 1
1
2 2
0 0
3 7
23 47 16


 


Sample Output

234
2799
72937#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <cmath>
#include <stack>
#define LL long long
using namespace std;
const long long MAXN = 15;
const long long mod = 10000007;
struct Matrix
{
    long long mat[MAXN][MAXN], n;
    Matrix(){memset(mat, 0, sizeof(mat));}
    Matrix operator * (Matrix & rhs)
    {
        Matrix res; res.n = n;
        for(long long i=1;i<=n;i++)
        {
            for(long long j=1;j<=n;j++)
            {
                for(long long k=1;k<=n;k++)
                {
                    (res.mat[i][j] += (mat[i][k] * rhs.mat[k][j]) % mod) %= mod;
                }
            }
        }
        return res;
    }
};
Matrix pow_mod(Matrix a, long long b)
{
    Matrix res; res.n = a.n;
    for(long long i=1;i<=a.n;i++) res.mat[i][i] = 1;
    while(b)
    {
        if(b & 1) res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}
long long a[MAXN], n, m;
int main()
{
    while(scanf("%I64d%I64d", &n, &m)!=EOF)
    {
        for(long long i=1;i<=n;i++) scanf("%I64d", &a[i]);
        Matrix ans; ans.n = n + 2;
        for(long long i=1;i<=n + 1;i++)
        {
            ans.mat[i][1] = 10;
            for(long long j=2;j<=i;j++)
            {
                ans.mat[i][j] = 1;
            }
        }
        for(long long i=1;i<=n+1;i++) ans.mat[n+2][i] = 0;
        for(long long i=1;i<=n+2;i++) ans.mat[i][n+2] = 1;
        ans = pow_mod(ans, m);
     /*   for(long long i=1;i<=n+2;i++)
        {
            for(long long j=1;j<=n+2;j++)
                cout << ans.mat[i][j] << ' ';
            cout <<endl;
        }*/
        a[0] = 23, a[n+1] = 3;
        long long rs = 0;
        for(long long i=1;i<=n+2;i++) (rs += a[i-1] * ans.mat[n+1][i]) %= mod;
        printf("%I64d\n", rs);
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream  1213  Matrix Multiplication【水题 、 找规律】


Matrix Multiplication

Time Limit: 2000/1000MS (Java/Others) Memory Limit: 128000/64000KB (Java/Others)
链接：http://acdream.info/problem?pid=1213

Problem Description

      Let us consider undirected graph G = {V; E} which has N vertices and M edges. Incidence matrix of this graph is N × M matrix A = {ai,j}, such
 that ai,j is 1 if i-th vertex is one of the ends of j -th edge and 0 in the other case. Your task is to find the sum of all elements of the matrix
 ATA.

Input

      The first line of the input file contains two integer numbers — N and M (2 ≤ N ≤ 10 000, 1 ≤ M ≤100 000). Then 2*M integer numbers follow, forming M pairs, each pair describes one edge of the graph. All edges are different and there are no loops (i.e.
 edge ends are distinct).

Output

      Output the only number — the sum requested.

Sample Input

4 4
1 2
1 3
2 3
2 4


Sample Output

18


水题。找规律，规律出来，题就解决了。
#include <cmath>
#include <queue>
#include <vector>
#include <cstdio>
#include <string>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <algorithm>
using namespace std;
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#define FIN             freopen("input.txt","r",stdin)
#define FOUT            freopen("output.txt","w",stdout)
#define CASE(T)         for(scanf("%d",&T);T--;)
typedef long long LL;
const int maxn = 10000 + 5;
int N, M, cnt[maxn];
int main()
{
//    FIN;
    int a, b;
    while(~scanf("%d %d", &N, &M))
    {
        memset(cnt, 0, sizeof(cnt));
        for(int i = 1; i <= M; i++)
        {
            scanf("%d %d", &a, &b);
            cnt[a]++, cnt[b]++;
        }
        LL ans = 0;
        for(int i = 1; i <= N; i++)
        {
            ans += (LL)(cnt[i] * (cnt[i] - 1) / 2);
        }
        ans *= 2;
        ans += 2 * M;
        printf("%lld\n", ans);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

简单原理来介绍java编程之反射
直接上代码，比较简单大家都应该能看懂：
package com.blueZhang.reflect;
/**
 * 创建USB接口
 * 鼠标键盘等都属于USB设备
 * */
public interface usb {
	//打开USB
	public void open();
	//关闭USB
	public void close();

}
/**
 * 
 */
package com.blueZhang.reflect;

/**
 * @author blueZhang
 *
 */
public class MousUSB implements usb{

	@Override
	public void open() {
		// 
		System.out.println("mouse open！");
	}

	@Override
	public void close() {
		// 
		System.out.println("mous close!");
	}
	
	

}

package com.blueZhang.reflect;
/**
 * @author blueZhang
 * 实现usb接口的类
 * */
public class KeyUSB implements usb{

	@Override
	public void open() {
		// 
		System.out.println("key open!");
		
	}

	@Override
	public void close() {
		// 
		System.out.println("key close!");
		
	}
	

}

/**
 * 
 */
package com.blueZhang.reflect;

/**
 * @author blueZhang
 *
 */
public class NotPead {
	//电脑运行
	public void run()
	{
		System.out.println("电脑运行");
	}
	//电脑使用USB
	public void use(usb usb)
	{
		if(usb!=null)
		{
			usb.open();
			//
			usb.close();
			//
			
		}
	}
	

}

/**
 * 
 */
package com.blueZhang.reflect;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Properties;

/**
 * @author Administrator
 * 
 */
public class Test {

	/**
	 * @param args
	 *            笔记本可以运行 笔记本可以使用鼠标 笔记本可以使用键盘
	 * @throws FileNotFoundException 
	 * @throws ClassNotFoundException 
	 * @throws IllegalAccessException 
	 * @throws InstantiationException 
	 * 
	 */
	public static void main(String[] args) throws FileNotFoundException, ClassNotFoundException, InstantiationException, IllegalAccessException {
		//
		NotPead not = new NotPead();
		// 调用自己的run方法
		not.run();
		//
		/*
		 * 按照我们的使用习惯那就是 先创建两个对象然后调用相应的方法
		 * 
		 * 
		 * KeyUSB keyUSB = new KeyUSB(); noteBook.use(keyUSB);
		 * 
		 * MouseUSB mouseUSB = new MouseUSB(); noteBook.use(mouseUSB);
		 * 
		 * 但是我们发现如果总是有新的设备那么总是需要新去创建一个新的对象
		 * 
		 * 然后调用这里面的方法这样使我们程序的可扩展性变得更加不好
		 * 
		 * 所以使用反射机制如果有新的设备加入那么只需要更改我们的配置文件不必改变我们的
		 * 
		 * Test代码。这样提高了我们的代码的可扩展性
		 */
		//创建Properties对象
		Properties properties = new Properties();
		//创建输入流
		FileInputStream fis = new FileInputStream("config\\config.properties");
		//导入inputstream
		for(int i= 0;i<properties.size();i++)
		{
			String value = properties.getProperty("usb"+i);
			//
			Class<?> claz = Class.forName(value);
			//
			Object obj = claz.newInstance();
			//
			usb usb = (usb)obj;
			//
			usb.open();
			//
			usb.close();
			
					
			//
			
		}
		
	}

}

在自己的工程中创建配置文件config.properties 里面存储的是键值对前面是对像后面是对应的包名类名


配置文件：
usb1=com.blueZhang.reflect.KeyUSB
usb2=com.blueZhang.reflectMousUSB



版权声明：本文为博主原创文章，未经博主允许不得转载。

记忆力

       上网一搜，能搜到无数个教你提高记忆力的方法，不过这些方法有一个共同特点：需要付出意志和努力。好的记忆力与好习惯有很大关系，许多有好记忆力的人，都有持之以恒的强记知识的习惯。马克思喜欢背诗歌。他从少年时代起，坚持用一种自己不太熟悉的外语去背诵诗歌，日久天长，他的记忆力越来越强。列夫·托尔斯泰有惊人的记忆力，别人问他原因是什么，他解释说是由于自己每天早晨都要强记忆一些单词或其他内容的知识。他说：“背诵是记忆力的体操”。



       背诵记忆训练


       朗读背诵训练具有巨大的潜在力量，可以将右脑的完全记忆能力开发出来，背诵记忆法是开启右脑记忆能力的最基础的训练方法。背诵本身蕴含着神奇的力量，反复背诵可以刺激大脑中的海马，开启右脑深层记忆的回路。
两个原则：精选；反复



 大声说出来
       小学生要记东西都会大声朗读，但是各位有所不知的是，大声说出来能够帮助我们记忆很多东西。比如，你是否会忘了煤气灶上在烧水，或者灯忘了关？甚至就是一转身就忘了你要干的事情？我们建议你把要干的事情，比如“我在烧水”“我要带上交通卡”等等大声说出来。这样做能够提高10%的记忆力。




 联想记忆训练

 我们平时读书常常会有这样的体验：那些附有插图、图表之类图文并茂的书报，学习起来记忆就特别深刻。反之，阅读那些没有插图或图表的书报的时候，同于只使用词语进行逻辑思维，即只命名用大脑左半球，而右半球闲着，因而记忆就不如同时使用大脑两半球深刻。这个道理告诉我们，在记忆时要改变只用词
 语进行逻辑思维的习惯，而按着所学的材料或事物的内容同时进行形象思维。其方法就是像放电影似地在头脑里映现出一幅幅图画，这样就能同时使大脑两半球进行思维。读起书来既轻松愉快，又增强记忆。这个道理告诉我们，在记忆时要改变只用词 语进行逻辑思维的习惯，而按着所学的材料或事物的内容同时进行形象思维。其方法就是像放电影似地在头脑里映现出一幅幅图画，这样就能同时使大脑两半球进行思维。读起书来既轻松愉快，又增强记忆。



   预测
       心理学家们发现，仅仅预测一下自己对某事的记忆能力就能神奇地提高你的记忆力。它既对已经发生过的事情有效，也对需要记住你未来要做的事情起作用。比如，你过一会要到邮局寄封信，你现在可以预测一下你有多大的可能会忘记这件事，因为这个预测可以帮助你不会忘记去邮局寄信。有研究表明，对于某些事情而言，这个方法能够提高几乎50%的记忆效果！



 减少大脑损伤

  保证营养、积极休息、进行体育锻炼等保养大脑的基础上，防止过度疲劳，保持积极乐观的情绪，能大大提高大脑的工作效率。这是提高记忆力的关键。

  最佳时间一般来说，上午9~11时，下午3~4时，晚上7~10时，为最佳记忆时间。利用上述时间记忆难记的学习材料，效果较好。

   巴赫、亨德尔等人的作品中的慢板乐章，能够消除大脑的紧张，使人进入冥想状态。他让学生们听着节奏缓慢的音乐，并且放松全身的肌肉，合着音乐的节拍读出需要记忆的材料。学习结束之后，再播放2分钟欢快的音乐，让大脑从记忆活动中恢复过来。很多试验过这种方法的学生都觉得记忆效果很好。

  做有氧运动可以改善人的长期记忆力





版权声明：欢迎转载，转载请注明出处： http://blog.csdn.net/ztf312/

安卓源码总体结构（2）基础知识汇总

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
packages/
|– apps (各种应用程序,如联系人、浏览器等)
|– experimental (一些实验性的项目,如错误报告)
|– inputmethods (输入法相关)
|– providers (各种数据源实现,如联系人数据、媒体库等信息)
|– wallpapers (各种壁纸程序)


Android Framework功能介绍
android.app :提供**的程序模型和基本的运行环境。
android.content :包含对各种设备上的数据进行访问和发布。
android.database :通过内容提供者浏览和操作数据库。
android.graphics :底层图形库,包含画布、点、矩形等,可以将其直接绘制到屏幕上。
android.location :定位和相关服务的类。
android.media :提供一些类管理多种音频、视频的媒体接口。
android.net :提供帮助网络访问的类,超过通常的 java.net.* 接口。
android.os :提供了系统服务、消息传输和 IPC 机制。
android.opengl :提供 OpenGL 的工具。
android.provider :提供访问 Android 内容提供者的类。
android.telephony :提供与拨打电话相关的 API 交互。
android.view :提供基础的用户界面接口框架。
android.util :涉及工具性的方法,例如时间日期的操作。
android.webkit :默认浏览器操作接口。
android.widget :包含各种 UI 元素(大部分是可见的)在应用程序的布局中使用
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
build/
|– buildspec.mk.default
|– cleanspec.mk
|– core (各种以mk为结尾的文件,它门是编译所需要的Makefile)
|– envsetup.sh
|– libs
|– target (包含board和product两个目录,为目标所需要文件)
|– tools (编译过程中主机所需要的工具,一些需要经过编译生成)
其中,core中的Makefile是整个Android编译所需要的真正的Makefile,它被顶层目录的Makefile引用
知识点小结，DEX (class.dex) 文件是Android系统中可以在Dalvik虚拟机上直接运行的文件格式。
Java源码通过ADT编译成smali语言这是一个优化的过程，
相对 于.class文件它体积小、运行效率高、被编译后可读性低；smali再到class.dex本身就是一个加壳保护的过程。
 DEX文件如果未做好保护， 黑客通过反编译可让源码完全暴露，可利用阅读源码来找到APP的设计流程，
通过对程序流程的了解将很容易对程序进行盗版、恶意篡改、恶意代码注入等危险行 为。
在此特别感谢爱加密提供的加密服务给我应用加固提供了保护。
http://www.ijiami.cn/AppProtect
 
PowerDesigner16 破解
　　最近开发项目，涉及到实体设计这块的时候，用的是PowerDesigner16，使用是挺方便的，但是存在一个问题，那就是PowerDesigner16存在一个试用期的问题，过期就打不开了。
　　之前好多同学都在抱怨，过期打不开，不愿意使用，但是又不得不使用，不是一次注册就可以永远使用，而是还得让你二次注册。
　　于是开始上网查找注册码，试了很多但是还是解决不了。
　　最有效的方法是：根据你安装的PowerDesigner版本从而查找相应的破解文件，我安装的是PowerDesigner16.1,，于是进行下面的操作：
　　1、  下载PowerDesigner16 破解文件包
　　2、  将下载的包进行解压后，会有一个dflm16.dll，用这个文件替换你当时安装PowerDesigner16目录中的那个文件。
　　文件的下载地址是：http://download.csdn.net/detail/u010955843/9044085

版权声明：本文为博主原创文章，未经博主允许不得转载。

矩阵快速幂模板
#define MOD 1000000007
typedef long long ll;
typedef struct matrixnod{
    ll m[2][2];
}matrix;
matrix mat(matrix a,matrix b){
    matrix c;
    int mod=MOD-1;
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++){
            c.m[i][j]=0;
            for(int k=0;k<2;k++){
               c.m[i][j]+=(a.m[i][k]*b.m[k][j]);
               c.m[i][j]%=mod;
            }
        }
    return c;
}
matrix doexpmat(matrix a,ll num){
    matrix t={
        1,0,
        0,1
    };
    while(num){
        if(num&1) t=mat(a,t);
        num=num>>1;
        a=mat(a,a);
    }
    return t;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

1090. Highest Price in Supply Chain (25) -计层的BFS改进
题目如下：



A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）-- everyone involved in moving a product from supplier to customer.

Starting from one root supplier, everyone on the chain buys products from one's supplier in a price P and sell or distribute them in a price that is r% higher than P. It is assumed that each member in the supply chain has exactly one supplier except the root
 supplier, and there is no supply cycle.

Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers.

Input Specification:

Each input file contains one test case. For each case, The first line contains three positive numbers: N (<=105), the total number of the members in the supply chain (and hence they are numbered from 0 to N-1); P, the price
 given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then the next line contains N numbers, each number Si is the index of the supplier for the i-th member. Sroot for
 the root supplier is defined to be -1. All the numbers in a line are separated by a space.

Output Specification:

For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the
 price will not exceed 1010.
Sample Input:
9 1.80 1.00
1 5 4 4 -1 4 5 3 6

Sample Output:
1.85 2








题目要求根据供应链条计算最深层的零售商的售价，实质是图的BFS，并且BFS要记录层级，这道题和之前的一道1079. Total Sales of Supply Chain (25)算法一致，这里不再赘述。唯一的不同是图的输入，并且根结点不再固定是0。
代码如下：
#include <iostream>
#include <vector>
#include <stdio.h>
#include <queue>
#include <math.h>

using namespace std;

int main()
{
    vector<vector<int> > graph;
    int N;
    double P,r;
    cin >> N >> P >> r;
    graph.resize(N);
    int num;
    int root;
    for(int i = 0; i < N; i++){
        scanf("%d",&num);
        if(num == -1){
            root = i;
            continue;
        }
        graph[num].push_back(i);
    }
    queue<int> q;
    q.push(root);
    int level = 0;
    int last,tail;
    last = tail = root;
    int maxLevel = 0;
    int cnt = 0;
    while(!q.empty()){
        int v = q.front();
        q.pop();
        if(level == maxLevel){
            cnt++;
        }else if(level > maxLevel){
            maxLevel = level;
            cnt = 1;
        }
        for(int i = 0; i < graph[v].size(); i++){
            int w = graph[v][i];
            q.push(w);
            tail = w;
        }
        //printf("(%d)->%d\n",level,v);
        if(v == last){
            last = tail;
            level++;
            if(level > 1) P*= (100+r)/100;
        }

    }
    printf("%.2lf %d\n",P,cnt);

    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA 10968 - KuPellaKeS 【BFS】
题目： 
In ancient times, many territories were under the control of a powerful king called Basm. Basm is 
well-known in history because of his strange works and as a result, there are many history-lovers who 
wish to know more about him. Koorosh is one of them and he has worked hard to find a way to know 
more about Basms works. 
Recently, he managed to invent a Time MachineTM and traveled to the past to Basm time in order 
to be able to see and study his weird works thoroughly. Unfortunately, he has been caught by royal 
guard soldiers of Basm and is now in his prison. Basm ordered him to solve a problem if he wants to stay 
alive. King Basm wants to change the structure of roads of his newly captured territory, KuPellaKes 
in such a way that each city has an even number of neighboring cities. Now, he wants to know the 
minimum number of roads that should be destroyed in order to satisfy this condition. Note that each 
city must have at least one neighbor city after the road destruction process. Also, It should be noted 
that in the given territory at most two cites of KuPellaKes have an odd number of neighboring cities 
and there is at most one road between two cities. Also, there is no road from a city to itself.
题意： 
给定一个图，要求把这个图删掉一些边后，使得他所以有点度数为不等于0的偶数，保证图一开始最多只有最多2个奇数度数结点。求最小删边数
解法：求奇数点间的距离。奇数点为 0 个，答案为0。
代码：
#include <iostream>
#include <cstring>
#include <stdio.h>
#include <math.h>
#include <algorithm>
#include <string>
#include <map>
#include <vector>
#include <queue>

using namespace std;

int n, m;
vector<int> g[1010];
int du[1010];
int cnt[1010];
int st, ed;

bool solve()
{
    st = ed = 0;
    for (int i = 1; i <= n; i++)
    {
        if (du[i] == 0 || du[i] == 1) return false;
        if (du[i] % 2 == 1)
        {
            if (st == 0) st = i;
            else ed = i;
        }
    }

    if (st == 0)
    {
        printf("0\n");
        return true;
    }

    memset(cnt, -1, sizeof(cnt));
    queue<int> q;
    while (!q.empty()) q.pop();
    q.push(st);
    cnt[st] = 0;

    while (!q.empty())
    {
        int tp = q.front();q.pop();
        if (tp == ed)
        {
            printf("%d\n",cnt[tp]);
            return true;
        }
        for (int i = 0; i < g[tp].size(); i++)
        {
            int tt = g[tp][i];
            if (du[tt] == 2) continue;
            if (cnt[tt] != -1) continue;
            cnt[tt] = cnt[tp] + 1;
            q.push(tt);
        }
    }
    return false;
}

int main()
{
    while (~scanf("%d%d", &n, &m) && n)
    {
        memset(du,0,sizeof(du));
        for (int i = 0; i <= n; i++) g[i].clear();
        int a, b;
        while (m--)
        {
            scanf("%d%d", &a, &b);
            du[a]++; du[b]++;
            g[a].push_back(b);
            g[b].push_back(a);
        }
        if (!solve()) printf("Poor Koorosh\n");
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：转载请注明出处。

写一个函数，求两个整数的之和，要求在函数体内不得使用＋、－、×、÷。
写一个函数用来求两个整数的和，要求在函数体内不能够使用+ 、- 、*  、÷符号。



解答：其实这个就是计算机实现加法的原理来实现的。所以我们可以通过二进制的位移来实现。



代码如下：








#include <iostream>
using namespace std;

int main()
{
	int num1,num2;
	int sum ,temp;

	cin>>num1 ;
	cin>>num2;

	while( num2!=0 )
	{
		sum = num1 ^ num2;
		temp = num1 & num2;
		num1 = sum;
		num2 = temp;
	}

	cout <<num1<<endl;
	return 0;
}有什么不对的地方，请个人指正。



相关的可以了解相应的乘法、除法在计算机内部是怎么实现的。








可以参考链接：http://blog.csdn.net/jamesjxin/article/details/6855662















版权声明：本文为博主原创文章，未经博主允许不得转载。

Mybatis + SpringMVC事务管理

SpringMVC支持声明式和编程式事务管理，这里我讲的是声明式事务，也即通过注解@Transactional来使用事务。
这里是我在这个工程中所使用的jar包：http://download.csdn.net/detail/liujan511536/9050079
这里是我这个工程的源码：http://download.csdn.net/detail/liujan511536/9050093
这是一个dynamic web project。


首先看配置文件web.xml，这个文件在WebContent/WEB-INF/目录下：
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0">
  <display-name>SpringMVC_Mybatis</display-name>
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>index.jsp</welcome-file>
    <welcome-file>default.html</welcome-file>
    <welcome-file>default.htm</welcome-file>
    <welcome-file>default.jsp</welcome-file>
  </welcome-file-list>
  
  <listener>
  	<listener-class>
  		org.springframework.web.context.ContextLoaderListener
  	</listener-class>
  </listener>
  
  <!-- 读取mybatis配置文件 -->
  <context-param>
	<param-name>contextConfigLocation</param-name>
	<param-value>classpath:mybatis-context.xml</param-value>
  </context-param>

  <servlet>
  	<servlet-name>springmvc</servlet-name>
  	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  	<init-param>
  		<!-- 加载springmvc的xml到spring的上下文容器中 -->
  		<param-name>contextConfigLocation</param-name>
  		<param-value>
  			<!-- /WEB-INF/classes/application-context.xml -->
  			classpath:application-context.xml
  		</param-value>
  	</init-param>
  	<load-on-startup>1</load-on-startup>
  </servlet>
  
  <servlet-mapping>
  	<servlet-name>springmvc</servlet-name>
  	<url-pattern>*.html</url-pattern>
  </servlet-mapping>
</web-app>


mybatix-context.xml （/WebContent/WEB-INF/classes/目录下）:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc" 
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd  
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
   
    <bean id="config" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
 		<property name="locations">
 			<list>
 				<value>classpath:db-config.properties</value>
 			</list>
 		</property>
 	</bean>
	<!-- 配置数据库dataSource -->
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
		<property name="driverClassName" value="${jdbc.driverClass}" />
		<property name="username" value="${jdbc.username}" />
		<property name="url" value="${jdbc.url}" />
	</bean>
	
	<bean id="transactionManager"
        class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <tx:annotation-driven transaction-manager="transactionManager" />
	
	
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<property name="typeAliasesPackage" value="com.liujan.entity" />
	</bean>
	
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="com.liujan.mapper" />
	</bean>
	
</beans>
application-context.xml （/WebContent/WEB-INF/classes/目录下）:

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd  
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-2.0.xsd">
        
	<context:component-scan base-package="com.liujan">
	</context:component-scan>
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
		p:prefix="/WEB-INF/page/" p:suffix=".jsp">
	</bean>
</beans>



 容器装配顺序造成的事务无法回滚
在加载这个web.xml这个文件时，Spring会去加载在这个文件中引入的其他文件，这里有mybatis-context.xml和application-context.xml这两个文件，两个文件都在/WebContent/WEB-INF/classes/目录下。
但是这里有个问题，就是这两个文件的加载是有先后顺序的。Spring会优先加载在context-param标签中引入的文件，也就是这里的mybatis-context.xml，然后再加载application-context.xml。在加载mybatis-context.xml时，Spring就会装配@Controlle和@Service的容器，并把他们放到Spring的容器中来；接着加载application-context.xml，这时Spring也会把@Service和@Controller注解的实例装配到Spring容器中，但是这时由于先前在加载mybatis-context.xml时已经装配过@Service和@Controller的容器，所以这时新装配的容器会覆盖掉先前的容器，所以Spring容器中就只剩下后来装配的容器了。
这种装配顺序就会引来一个问题，由于我的事务是在mybatis-context.xml文件中声明的，所以这个文件中的Service容器是带有事务能力的；但是这里装配的Service容器会被后来application-context.xml中的Service容器替换掉，而application-context.xml中的Service容器是没有事务能力的，所以最后造成在Spring容器中的Service是没有事务能力的。
这是很容易就陷入的一个陷阱；很多初学者在照着网上的教程配置好后，却发现无论如何都不能回滚或者其他事务的问题，很多时候就是由于这种情况造成的。
要解决这个问题，只需只在mybatis-context.xml中生成Service的带事务的容器，而在application-context.xml中就不生成Service容器了。又由于Service是Controller类中的一个属性，所以在装配Controller前要先装配好Service。
为了达到以上目的，由于是先加载myabtis-context.xml，后加载application-context.xml，所以我们只需在myabtis-context.xml装配Service，不装配Controller；然后在application-context.xml中装配Controller，不装配Service就可以了。这样就得修改mybatis-context.xml和application-context.xml这两个文件，修改后的文件
 如下：
mybatis-context.xml:


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc" 
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd  
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
    <!-- 不装配Controller -->
    <context:component-scan base-package="com.liujan">
    	<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    
    <bean id="config" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
 		<property name="locations">
 			<list>
 				<value>classpath:db-config.properties</value>
 			</list>
 		</property>
 	</bean>
	<!-- 配置数据库dataSource -->
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
		<property name="driverClassName" value="${jdbc.driverClass}" />
		<property name="username" value="${jdbc.username}" />
		<property name="url" value="${jdbc.url}" />
	</bean>
	
	<bean id="transactionManager"
        class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <tx:annotation-driven transaction-manager="transactionManager" />
	
	
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<property name="typeAliasesPackage" value="com.liujan.entity" />
	</bean>
	
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="com.liujan.mapper" />
	</bean>
	
</beans>

application-context.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd  
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-2.0.xsd">
    <!-- 装配Controller，不装配Service -->
	<context:component-scan base-package="com.liujan">
		<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
		<context:exclude-filter type="annotation" expression="org.springframework.stereotype.Service" />
	</context:component-scan>
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
		p:prefix="/WEB-INF/page/" p:suffix=".jsp">
	</bean>
</beans>
web.xml内容不变。


2. 我们把事务控制在Service层，当一个函数（假设函数名为funA）前加上@Transactional标签时，就表示这个函数具有事务能力。那么什么情况下事务会commit，什么情况下事务会rollback？
如果要事务回滚，则funA函数内必须得抛出一个uncheck异常（比如RuntimeException），而且这个异常不能在funA内被try...catch，比如，在UserService类里有一个函数叫saveUser，是用来往数据库中插入一条数据的：
@Transactional(propagation=Propagation.REQUIRED)
public void saveUser(User u) throws Exception{
	userMapper.insert(u);
	
	throw new RuntimeException("hehe");
}当运行这个函数时，是先往数据库中插入数据u，然后再抛出RuntimeException异常，而且这个异常没有被saveUser函数捕捉，所以这个异常会被Spring检测到，这时事务就会回滚，数据插入失败；
但是，如果这个异常被saveUser捕捉了，那么Spring就不会检测到这个异常，事务就不会回滚，数据就会插入成功，如下：
@Transactional(propagation=Propagation.REQUIRED, rollbackFor=Exception.class)
public void saveUser(User u) throws Exception{
	userMapper.insert(u);
	try {
		throw new RuntimeException("hehe");
	} catch (Exception e) {
		// TODO: handle exception
	}
		
}
但是，这个异常如果被调用saveUser的函数catch的话，事务也会回滚的，比如在UserController中有一个方法addUser，在这个方法里会调用userService的saveUser方法：
public void addUser(String name, int stuId) {
	User u = new User();
	u.setName(name);
	u.setStuid(stuId);
	try {
		userService.saveUser(u);
	} catch (Exception e) {
		// TODO: handle exception
		e.printStackTrace();
	}
		
}这时事务也会回滚。
综上所述，只要异常不在异常抛出的地方被catch，那么即使该异常在后面的函数中被catch，事务也会回滚。


这里又有一个问题，就是抛出的异常只能是uncheck类的，如果是check类的事务就不会回滚，如下：
@Transactional(propagation=Propagation.REQUIRED)
public void saveUser(User u) throws Exception{
	userMapper.insert(u);
	
	throw new Exception("hehe");
		
}这时事务是不会回滚的。
如果想在跑出check类异常时事务也会回滚，则可以在@Transactional中声明当遇上check类异常时回滚，如下：
@Transactional(propagation=Propagation.REQUIRED, rollbackFor=Exception.class)
public void saveUser(User u) throws Exception{
	userMapper.insert(u);
		
	throw new Exception("hehe");
		
}

最后讲下@Transactional标签中propagation的含义：

REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 
SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 
MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。 
REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 
NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 
NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 
NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。









版权声明：本文为博主原创文章，未经博主允许不得转载。

轻松python文本专题-单独处理字符串每个字符的方法汇总
场景：
用每次处理一个字符的方式处理字符串


方法：
1.使用list（str）
>>> a='abcdefg'
>>> list(a)
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> aList=list(a)
>>> for item in aList:
	print(item)#这里可以加入其他的操作，我们这里只是单纯使用print

	
a
b
c
d
e
f
g
>>> 

2.使用for遍历字符串
>>> a='abcdefg'
>>> for item in a :
	print(item)#这里可以加入其他的操作，我们这里只是单纯使用print

	
a
b
c
d
e
f
g
>>> 

3.使用for解析字符串到list里面
>>> a='abcdefg'
>>> result=[item for item in a]
>>> result
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> 

就说到这里，谢谢大家


------------------------------------------------------------------

点击跳转零基础学python-目录


版权声明：本文为博主原创文章，未经博主允许不得转载。

poj3659 Cell Phone Network（最小支配集-树形dp）
题目链接：点击打开链接
题目描述：给定一棵树，从中选取尽量少的点使每个点要么被选中，要么和被选中的点直接相连？
解题思路：树上的最小支配集，树形dp
dp[i][0]:选中i作为支配集
dp[i][1]:不选i作为支配集，但其子节点覆盖了i
dp[i][2]:不选i作为支配集，而且其子节点没有覆盖i


代码：

#pragma comment(linker,"/STACK:1024000000,1024000000")
#include <cstdio>
#include <cstring>
#include <iostream>
#define MAXN 10010
#define INF 1e9+7
using namespace std;
int head[MAXN],tol;
struct Edge{
    int v,next;
}edge[MAXN*2];
void addEdge(int u,int v){
    edge[tol].v=v;edge[tol].next=head[u];head[u]=tol++;
    edge[tol].v=u;edge[tol].next=head[v];head[v]=tol++;
}
int min(int a,int b){
    return a<b?a:b;
}
int dp[MAXN][3];
int n;
void DP(int u,int p){
    dp[u][2]=0;
    dp[u][0]=1;
    int sum=0,inc=INF;
    int k,to;
    bool s=false;
    for(k=head[u];k!=-1;k=edge[k].next){
        to=edge[k].v;
        if(to==p) continue;
        DP(to,u);
        dp[u][0]+=min(dp[to][0],min(dp[to][1],dp[to][2]));
        if(dp[to][0]<=dp[to][1]){
            sum+=dp[to][0];
            s=true;
        }
        else
        {
            sum+=dp[to][1];
            inc=min(inc,dp[to][0]-dp[to][1]);
        }
        if(dp[to][1]!=INF&&dp[u][2]!=INF) dp[u][2]+=dp[to][1];
        else dp[u][2]=INF;
    }
    if(inc==INF&&!s) dp[u][1]=INF;
    else{
        dp[u][1]=sum;
        if(!s) dp[u][1]+=inc;
    }
}
int main(){
    while(scanf("%d",&n)!=EOF){
        tol=0;memset(head,-1,sizeof(head));
        int u,v;
        for(int i=0;i<n-1;++i){scanf("%d%d",&u,&v);addEdge(u,v);}
        DP(1,1);
        printf("%d\n",min(min(dp[1][0],dp[1][1]),dp[1][2]+1));
    }
    return 0;
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

命名空间“HaiChuang.AMAC”中不存在类型或命名空间名称“WCFClient”。是否缺少程序集引用?
今天在Visual Studio 2010中编译文件的时候报出了以下错误：经过确认引用的dll没有问题，把引用重新添加过来，重启Visual Studio 2010都没有效果。错误一直都在，一直都在！！！后来发现该工程所引用的dll是net framework 4.0生成的。而该工程是.Net Framework 4.0 Client Profile生成的，如下：修改该工程的目标框架为net framework 4.0，再次编译，搞定。

版权声明：作者：jiankunking 出处：http://blog.csdn.net/jiankunking                本文版权归作者和CSDN共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接。

OpenGL开发资料黄页

研究OpenGL七八年了，上的最多的几个网站，帖出来跟大家分享下。

OpenGL源码下载

1. LightHouse3D

http://www.lighthouse3d.com/tutorials

点评：opengl，webgl，GLSL等技术讲解和资料下载。该网站一直有人维护更新。

2. codesampler

http://www.codesampler.com/

点评：用的最久，最靠谱的。里面的OpenGL代码偏老了，还有dx的源码下载，OpenGL的shader代码偏少。

3. OpenGL Modern Demo

http://es.g0dsoft.com/?page_id=236

点评：代码都在OpenGL3.0以上，opengl shader居多，打包下载所有demo研究。

4. OpenGL Modern Tutorial

http://ogldev.atspace.co.uk/

点评：课程多，讲解详细，OpenGL3.3以上，适合初学者，有代码下载。

5. OpenGL3.3+的例子

http://www.opengl-tutorial.org/

点评：讲解详细，源码下载。

 

OpenGL优质博客

1. NeHe

http://www.yakergong.net/nehe/

点评：内容详实有源码下载。但是OpenGL的内容和技术偏固定管线，shader的不多。

2. OpenGL

http://www.songho.ca/opengl/index.html

点评：作者是岛国的OpenGL技术大牛，讲解仔细全面。但是OpenGL版本偏旧，对传统的固定管线，矩阵变换，VBO，PBO，FBO等讲解。有代码下载。

3. Paul Project

http://www.paulsprojects.net/index.html

点评：OpenGL界的大牛paul的博客，2002-2007年的，opengl技术偏旧，但是讲解详细，有血有肉。有代码下载。

4. opengl博客

http://www.zwqxin.com/

 

其他途径

1. OpenGL官网，WIKI

https://www.opengl.org/ 获取最新的业界资讯。

https://www.opengl.org/wiki/Main_Page  上面最新的技术讲解，便于查阅。

2. OpenGL技术群，97111013

点评：共享里面有丰富的源码资料下载。

3. webgl版本的动画演示PPT

http://acko.net/files/fullfrontal/fullfrontal/webglmath/online.html

4. http://www.zwqxin.com/

5. 我的csdn博客

http://blog.csdn.net/ryfdizuo

-----------------------------------------------------------------------------------------

今天先写到这，后续持续优化吧。

版权声明：本文为博主原创文章，未经博主允许不得转载。

localhost与127.0.0.1的区别





localhost与127.0.0.1的区别





 
前言
 
今天起得挺早啊.感觉自己棒棒哒,保持住,哈哈哈,就是早晨不吃饭挺烦人啊,我起来的这个点正是没有卖饭的了....
 
 
定义
 
localhost也叫local,正确的解释是:本地服务.
 
127.0.0.1在windows等系统上的正确解释为:本机地址(本机服务器)
 
 
不同点
 
localhost(local)是不经过网卡传输的,它不受网络防火墙和网卡相关的限制.
 
127.0.0.1是通过网卡传输,依赖网卡,并受到网络防火前和网卡相关的限制.
 
一般设置程序时本地服务用localhost是最好的,localhost不会解析成ip,也不会占用网卡,网络资源.
 
有时候用localhost可以,但是用127.0.0.1就不可以的情况就在于此.
 
localhost访问时,系统带的是本机当前用户的权限去访问.
 
而用IP的时候,等于本机是通过网络再去访问本机,可能涉及到网络过用户的权限.
 
 
小小的结一下
 
本次的内容不多,但是却说到了平常容易混淆的两个地方,希望能够引起大家的注意.
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

引用和指针的差别？
1：非空区别，在任何情况下都不能使用指向空值的引用。一个引用必须总是指向某些对象。所以如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时应该将这个变量声明为指针，这样就可以给这个变量赋值；相反如果这个变量肯定指向一个对象，并且这个对象不允许为空，那么就应该声明为引用，引用的效率要高于指针效率；
2：合法性区别，我们在写代码的时候，对于指针通常要进行非空验证，if(p == NULL) return NULL  ,但引用是不需要的；
3：可修改性，指针是可以修改的，但是引用总是指向初始赋值的对象内容；


以上三条决定了它们各自的应用场景。


延伸：想想参数传递的三种情况1：传值   2：传指针   3：传引用

版权声明：本文为博主原创文章，未经博主允许不得转载。

js演示循环赛事日程表

附代码

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
 <HEAD>
  <TITLE> 循环赛事日程表  </TITLE>
  <META NAME="Generator" CONTENT="EditPlus">
  <META NAME="Author" CONTENT="">
  <META NAME="Keywords" CONTENT="">
  <META NAME="Description" CONTENT="">
  <script type="text/javascript" src="jquery-1.7.2.min.js"></script>
  <script type="text/javascript" src="json2.js"></script>
   <style>
  table,td{
    border:1px solid gray;
	text-align:center;
  }
  </style>
  <script>
      var arr=[];
	  var calc_num=0;
	  /*
      $(function(){
	    for(var i=0;i<8;i++){
		  arr.push(new Array());
		}
	    game(3,8);
		for(var i=0;i<arr.length;i++){
		   for(var j=0;j<arr[i].length;j++){
		       document.write(arr[i][j]+"  ");
		   }
		   document.write("<br/>");
		}
	  })*/

	  function init(){
	    arr=[];
		calc_num=0;
		var num=Math.pow(2,parseInt($("#txt_k").val()));
	    for(var i=0;i<num;i++){ 
		  arr.push(new Array());
		}
		for(var i=0;i<num;i++)
		    arr[0][i]=i+1;//设置日程表第一行
		initTable();
	  }

	   function initTable(){
	    $("#container").html('');
		var table=$("<table></table>");
		var num=Math.pow(2,parseInt($("#txt_k").val()));
		var width=document.body.clientWidth*0.4/num;
		//alert(num+":"+width);
		for(var i=0;i<num;i++){
		   var tr=$("<tr style='width:"+width*num+"px;height:"+width+"px;'></tr>");
		   for(var j=0;j<num;j++){
		     var td=$("<td style='width:"+width+"px;height:"+width+"px;'> </td>");
			 if(i==0)
			    td.text(j+1);
			 tr.append(td);
		   }
		   table.append(tr);
		}
		 $("#container").append(table);
	 }
      function calc(){
	      var num=parseInt($("#txt_k").val());
	      if(calc_num<num){
	         game(calc_num,Math.pow(2,num-calc_num-1));
			 calc_num++;
		   }
		  else
		     alert("计算完毕，请重新初始化");
	  }


	  function game(k,n){	     
	     var m=Math.pow(2,k);//填充起始位置
		 //for(var s=0;s<k;s++){
		    //n=parseInt(n/2);
			for(var t=0;t<n;t++){//控制次数
			  for(var i=m;i<m*2;i++){//i控制行
				 for(var j=m;j<m*2;j++){//j控制列 				   
				   alert("arr["+i+"]["+(j+t*m*2)+"]="+arr[i-m][j+t*m*2-m]);
			       arr[i][j+t*m*2]=arr[i-m][j+t*m*2-m];//右下角等于左上角
				   $("table tr").eq(i).find("td").eq(j+t*m*2).text(arr[i][j+t*m*2]);
				   alert("arr["+i+"]["+(j+t*m*2-m)+"]="+arr[i-m][j+t*m*2]);
				   arr[i][j+t*m*2-m]=arr[i-m][j+t*m*2];//左下角等于右上角
				     $("table tr").eq(i).find("td").eq(j+t*m*2-m).text(arr[i][j+t*m*2-m]);
			     }
			   }
			}
		 //m=m*2;
		 //}

        
	  }

	  
  </script>
 </HEAD>
 <BODY style="text-align:center">
      级数：
	<input type="text" name="arr1" id="txt_k" style="width:60px" value="3"/>
	<input type="button" value="初始化" onclick="init()"/>
	<input type="button" value="下一步" onclick="calc()"/>
	<br/>
	<div id="container" style="margin:0 auto;"></div>
 </BODY>
</HTML>

关于算法详细解说可参考博客

0008算法笔记——【分治法】循环赛事日程表


版权声明：本文为博主原创文章，未经博主允许不得转载。

接下班概率问题——阿里笔试题
牛客某程序猿小杨每天接老婆下班回家。小杨在6点准时下班从公司开车出发，由于路上可能存在的堵车情况，小杨到老婆公司门口的时间点均匀的分布在6点20到6点30之间。老婆根据小杨的下班时间做了估计，到公司门口的时间点均匀的分布在6点25到6点30之间，如果小杨比老婆晚到公司门口将会挨骂，那么小杨被骂的概率是____。


1/4
1/3
1/2
2/3
3/4
以上都不对
这个题目是概率分布问题，解决方法有两种。


解法1：
可以进行分析，比如小杨在6点20到6点25之间到的概率为0.5，那么老婆这个时候肯定没到，绝对不会挨骂；小杨在6点25到6点30之间到的概率为0.5，而老婆到公司门口的时间点均匀的分布在6点25到6点30之间，所以小杨在这个前提下，和老婆到的先后顺序是随机的。
所以被骂概率为0.5*0.5=0.25；前一个0.5指的是小杨在6点25到6点30之间到这种情况（前提）发生概率，后一个0.5指的是此前提下，小杨比老婆晚到的概率。


解法2：
面积方法，这个不用多少，见图





版权声明：本文为博主原创文章，未经博主允许不得转载。

游戏服务器主程白皮书-服务器稳定性把控
三、           服务器稳定性把控
软件产品的特性包括性能、稳定性、可扩展性、可维护性、安全性。我们做游戏服务器的时候这几个方面也是需要我们时刻进行权衡的，因为很多时候这些特性是存在矛盾的。比如可扩展性必定增加代码的复杂度，从而影响性能和可维护性；性能必定需要进行算法和数据结构上的定制，必然影响可扩展性和可维护性；安全必定增加中间步骤，必然影响流程性能和稳定性。
那么在做系统设计时最重要也是最基础的是什么呢？经过多次的讨论以及经验验证，我还是觉得稳定性是最重要的。因为游戏服务器只要稳定性一产生问题，那么就是批量的游戏玩家受到了影响，对于产品的影响必然是巨大的甚至致命的。因此服务器程序员的基本素质之一就是要再做研发的时候时刻提醒自己，我的每一行代码都是影响着千万玩家的体验，责任重大；写每一行代码都需要谨慎再谨慎。这个也是服务器程序员与客户端程序员之间一个巨大的不同，同样一个问题发生在服务器程序员身上会因为影响的用户量而被千万倍的放大。
游戏服务器只要保证了稳定性，就是达到了产品上线的门限，就是一款玩家可以稳定的体验游戏的产品。所有其他特性都需要给稳定性让步。
如何保障服务器的稳定性能。我觉得在实际的开发过程中需要在如下几点上进行关注，稳定性的隐患基本上会体现在这些问题上。
1.      运行稳定性：服务器能够支持7*24不间断的稳定运行，不会因为故障导致玩家游戏时间的间断。
2.      数据安全：这里说的数据安全并非是攻击导致的数据问题，而是服务器运行过程中数据的完整性，一致性的保证。
3.      故障的快速排查与恢复：虽然服务器第一特性需要达到7*24小时不间断运行。但是无论什么样的服务器都不能完全的避免问题的出现，即使0.01%的故障率也会对批量玩家产生影响。所以系统的设计上应该考虑到故障出现的时候如何快速排查与恢复的问题。
3.1 运行稳定性
服务器的运行稳定性的产品展现当然就是7*24小时，甚至更久的不间断运行的产品质量。通俗一点说，就是服务器在7*24小时运行时间内服务器不出现卡顿，不出现宕机。
对于C++来说，宕机的原因99.9%是因为内存问题，内存的直接操作是让C++程序员又爱又恨的东西。而卡顿的原因相对宕机就是复杂很多了，服务器CPU使用率高了会导致卡顿，CPU使用率低了也有可能导致卡顿，网络、硬盘问题可能导致卡顿，多线程可能导致卡顿，内存问题导致卡顿。现在我把宕机和卡顿问题归结到如下几点，每点都会详细分析细节并提出已经在使用的解决方案。

1.      可能导致CPU使用率过高的问题
2.      可能导致CPU使用率不足的问题
3.      内存使用稳定与安全问题
4.      除数为0


版权声明：本文为博主原创文章，未经博主允许不得转载。博主联系方式:skydog_forstore@hotmail.com。

poj 2686 Traveling by Stagecoach【状态压缩】
题目链接：http://poj.org/problem?id=2686
题意： 
一个人从某个城市要到另一个城市。然后有n个马车票，相邻的两个城市走的话要消耗掉一个马车票。花费的时间是马车票上有个速率值，用边/速率就是花的时间。 
问最后这个人花费的最短时间是多少
dp[i][j] 表示集合 i 车票 到 j 的最优解
代码：
#include <stdio.h>  
#include <ctime>  
#include <math.h>  
#include <limits.h>  
#include <complex>  
#include <string>  
#include <functional>  
#include <iterator>  
#include <algorithm>  
#include <vector>  
#include <stack>  
#include <queue>  
#include <set>  
#include <map>  
#include <list>  
#include <bitset>  
#include <sstream>  
#include <iomanip>  
#include <fstream>  
#include <iostream>  
#include <ctime>  
#include <cmath>  
#include <cstring>  
#include <cstdio>  
#include <time.h>  
#include <ctype.h>  
#include <string.h>  
#include <assert.h>  

using namespace std;

const int inf = 1e9;
int n, m, p, a, b;
int t[100];
int g[50][50];
double dp[(1<<15)][50];

int main()
{
    while (~scanf("%d%d%d%d%d", &n, &m, &p, &a, &b))
    {
        if (!n && !m && !p && !a && !b) break;
        for (int i = 0;i < n;i++) scanf("%d",&t[i]);
        for (int i = 1;i <= m;i++)
            for (int j = 1;j <= m;j++)
            {
                if (i == j) g[i][j] = 0;
                else g[i][j] = inf;
            }
        int u, v, w;
        while (p--)
        {
            scanf("%d%d%d",&u,&v,&w);
            g[u][v] = min(g[u][v], w);
            g[v][u] = min(g[v][u], w);
        }

        for (int i = 0;i < (1 << n);i++)
            for (int j = 0;j <= m;j++)
                dp[i][j] = inf;

        dp[0][a] = 0;
        double ans = inf;

        for (int i = 0;i < (1 << n);i++)
        {
            for (int u = 1;u <= m;u++)
                for (int j = 0;j < n;j++)
                    if (!(i & (1 << j)))
                    {
                        for (int v = 1;v <= m;v++)
                        {
                            if (g[u][v] != inf)
                                dp[i | (1 << j)][v] = min(dp[i | (1 << j)][v], dp[i][u] + (double)g[u][v] / t[j]);
                        }
                    }
            ans = min(ans,dp[i][b]);
        }
        if (ans == inf) puts("Impossible");
        else printf("%.3lf\n",ans);

    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：转载请注明出处。

Ubuntu中Atom编辑器显示中文乱码的处理方法
1.      安装文泉驿正黑等相关中文字体：$ apt-get install -y ttf-wqy-zenhei fonts-wqy-zenheittf-wqy-microhei 2.      查看系统中文字体：$ fc-list :lang=zh3.      打开Atom：(1)、Edit -> Open Your Config，删除原有内容，输入如下内容，保存："*":
  "exception-reporting":
    userId: "fe150ae1-7895-9104-88e4-51ddc09f54d7"
  welcome:
    showOnStartup: false
  core: {}
  editor:
    invisibles: {}
    fontFamily: "Ubuntu Mono, DejaVu Sans Mono, 文泉驿等宽正黑"
    fontSize: 15 (2)、Edit ->Open Your Stylesheet，删除原有内容，输入如下内容，保存：@mono-font-family:  "Ubuntu Mono", "文泉驿等宽正黑"; /* 等宽字体 */
@font-family: "Ubuntu", "文泉驿正黑"; /* 非等宽字体 */
html, body, ol, ul, li,	h1, h2, h3, h4, h5, h6, div, p, span, pre, section, input, textarea,
	table, .atom-panel, .status-bar, .tree-view, .title, .current-path, .tooltip {
  font-family: @font-family;
}

.autocomplete-plus span, code, .-tree-view-, .symbols-view /*,.editor*/ {
  font-family: @mono-font-family;
}

atom-text-editor.editor {
	font-family: @mono-font-family;
}

.-tree-view- {
	font-size: 14px;
}4. 关闭Atom，再次打开即可。

版权声明：本文为博主原创文章，未经博主允许不得转载。

【POJ 2031】 Building a Space Station (三维坐标求距离+最小生成树)
【POJ 2031】 Building a Space Station
n个空间球 可能存在包含或者覆盖的状况 想要让所有球都联通 每个球有坐标x,y,z和半径 问还需要搭建最少多长的路
存储所有需要搭建的路 跑一遍最小生成树即可 注意原本就重叠的球距离0直接加入


代码如下:
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define esp 1e-5

using namespace std;

typedef struct Point//三维坐标
{
    double x,y,z,r;
}Point;

typedef struct Edge//边
{
    int u,v;
    double w;
    bool operator <(const struct Edge a)const
    {
        return w - a.w < -esp;
    }
}Edge;

Point pt[100];//点
int pre[100];//Kruskal并查集
Edge eg[10000];
int tp;

void Init(int x)//初始化并查集
{
    for(int i = 0; i < x; ++i) pre[i] = i;
}

int Find(int x)
{
    return pre[x] == x? pre[x]: (pre[x] = Find(pre[x]));
}

int main()
{
    int n,i,j,k,r,cnt;
    double dis,sum;
    while(~scanf("%d",&n) && n)
    {
        Init(n);
        cnt = tp = 0;
        for(i = 0; i < n; ++i)
        {
            scanf("%lf %lf %lf %lf",&pt[i].x,&pt[i].y,&pt[i].z,&pt[i].r);
            for(j = 0; j < i; ++j)
            {
                dis = sqrt((pt[i].x-pt[j].x)*(pt[i].x-pt[j].x)+(pt[i].y-pt[j].y)*(pt[i].y-pt[j].y)+(pt[i].z-pt[j].z)*(pt[i].z-pt[j].z));//两点距离
                if(dis - pt[i].r - pt[j].r  > esp)//如果距离减两半径为正 则需要加边
                {
                    eg[tp].u = i;
                    eg[tp].v = j;
                    eg[tp++].w = dis - pt[i].r - pt[j].r;
                }
                else//否则距离零 直接加入一个集合
                {
                    k = Find(i);
                    r = Find(j);
                    if(k != r)
                    {
                        pre[k] = r;
                        cnt++;
                    }
                }
            }
        }
        sort(eg,eg+tp);

        sum = 0;
        for(i = 0; i < tp; ++i)//Kruskal
        {
            k = Find(eg[i].u);
            r = Find(eg[i].v);

            if(k != r)
            {
                pre[k] = r;
                sum += eg[i].w;
                cnt++;
            }

            if(cnt == n-1) break;
        }
        printf("%.3f\n",sum);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

c#下halcon配置
1.在halcon中写入算子，实现函数过程 
例如： 
read_image(Image,’D:/MyFile/halcon/数字识别/1.jpg’) 
decompose3(Image, ImageR, ImageG, ImageB) 
threshold (ImageG, Regions, 0, 183) 
connection (Regions, Connection) 
select_shape (Connection, SelectedRegions, ‘area’, ‘and’, 1987.72, 7500) 
read_ocr_class_mlp(‘Document_0-9.omc’,OCRHandle) 
do_ocr_multi_class_mlp(SelectedRegions,ImageG,OCRHandle, Class, Confidence)
2.通过halcon的IDE开发环境，导出C#代码
3.利用vs2013创建一个C#窗口程序，加一个按钮。
4.将HDevelop安装目录下的文件夹拷贝到刚创建的C#窗口程序目录下 
比如：我的C#工程名字叫Hello，我的HDevelop安装在C:\Program Files\MVTec中， 
我就把C:\Program Files\MVTec\Halcon\bin文件夹复制到Hello.sln所在位置的同一文件夹下。
5.在C#工程中，对“解决方案资源管理器” 的  “引用” 右击，选择 “添加引用” ，点击“浏览”，选择刚才加进C#工程的 “bin” 文件夹，接着选择“dotnet35”文件夹，最后选择“halcondotnet.dll”文件。点击”添加“。
6.在C#工程中，选择“视图”，选择“工具箱”，在“工具箱“中右击，选择”选择项“，点击”浏览“，选择刚才加进C#工程的 “bin” 文件夹，接着选择“dotnet35”文件夹，最后选择“halcondotnet.dll”文件。点击”打开“。
7.将第二步导出的c#代码中生成的类，加入”Program.cs“文件中，如下 
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks; 
using System.Windows.Forms;
using HalconDotNet;
namespace Hello 
{ 
    public partial class HDevelopExport 
    {
    public HDevelopExport()
    {
        // Default settings used in HDevelop 
        HOperatorSet.SetSystem("do_low_error", "false");
        action();
    }


    // Main procedure 
    public void action()
    {

        // Local iconic variables 

        HObject ho_Image;


        // Local control variables 

        HTuple hv_Width, hv_Height, hv_WindowHandle;

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);

        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }

        HOperatorSet.ReadImage(out ho_Image, "1.jpg");
        HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
        HOperatorSet.SetWindowAttr("background_color", "black");
        HOperatorSet.OpenWindow(0, 0, hv_Width, hv_Height, 0, "", "", out hv_WindowHandle);
        HDevWindowStack.Push(hv_WindowHandle);
        if (HDevWindowStack.IsOpen())
        {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
        }
        ho_Image.Dispose();

    }
}
static class Program
{
    /// <summary>
    /// 应用程序的主入口点。
    /// </summary>
    [STAThread]
    static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        Application.Run(new Form1());
    }
}

}
8.在C#工程的”Form1.cs“文件，按钮响应事件中加入代码，如下： 
using System; 
using System.Collections.Generic; 
using System.ComponentModel; 
using System.Data; 
using System.Drawing; 
using System.Linq; 
using System.Text; 
using System.Threading.Tasks; 
using System.Windows.Forms;
namespace Hello 
{ 
    public partial class Form1 : Form 
    { 
        public Form1() 
        { 
            InitializeComponent(); 
        }
    private void button1_Click(object sender, EventArgs e)
    {
        HDevelopExport HD = new HDevelopExport();
        HD.action();

    }
}

}
9.在C#工程”Debug“文件夹中加入”halcon.dll“、”halcondotnet.dll“、”license.dat“文件。
10.移植到另一台机器中的时候，要在另一台机器路径C:\Program Files\MVTec\Halcon\下加入本台机器安装的HDevelop的help文件夹。 
例如：我的机器C:\Program Files\MVTec\HALCON-10.0\help 
我在另一台机器下也按着这个路径建立相同文件夹的名字，把我的机器C:\Program Files\MVTec\HALCON-10.0\help下的所以文件拷贝到另一台机器中。
11.配置完成，运行。。。。。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

你应该认识的 12 位最有影响力的程序员

我们每天所玩的 app 或游戏，不是凭空生出来，而是有某些人在某些地方，呕心沥血，以一行一行程序写出来的。平台、网页、网络本身，都是起源于此。现在工程师写程序创造一个又一个便利的产品，也是站在巨人肩膀上的结晶。Business
 Insider列出 12位至今仍在世的重要工程师，让我们来认识这些程序界的大前辈吧！


自由操作系统 Linux 开发者 Linus Torvalds

1991 年在芬兰赫尔辛基大学的宿舍里，22 岁的 Linus
 Torvalds 开发了自由操作系统 Linux。今日，许许多多智能手机、邮件系统、欧洲核子研究组织和超过 95% 的超级电脑都靠 Linux 运行，遍布手机到证券交易领域。当然，还有一大批热情的死忠工程师，营造凝聚力紧密的社区，在众人协力之下，持续进化这个操作系统。Linus
 Torvalds 还发起了 Git 开源项目，并为主要开发者。



Linus Torvalds

Above: Linus Torvalds

Image Credit: Linux Foundation

不过 Linus Torvalds 也以脾气火爆著称，2012 年他公开抨击 Nvidia 是他接触过“最烂的公司”、“最麻烦的公司”，甚至当场对着镜头竖起中指痛骂“Nvidia，操你的！”还曾以“一群打手枪的猴子”形容 OpenBSD 团队2。

最近在一个公开场合中，一名成员就问他，你会不会觉得你的坏脾气让很多可能本来想要参与社区的人退却了。Linus Torvalds 可不因年纪渐长就收敛自己的个性，他只回了一句“我一点也不在乎你。”


WWW之父 Tim Berners-Lee

Tim Berners-Lee 爵士发明了 HyperText Transfer Protocol（HTTP），整个互联网就是建立在 HTTP 上面，《时代》周刊将Tim
 Berners-Lee评为了世纪最杰出的 100 位科学家之一，形容WWW几乎可以说是 Berners-Lee 的个人功劳。但他并未因此致富，而是无偿的把 WWW 构想推广到全世界。



Tim Berners-Lee

Above: Tim Berners-Lee

Image Credit: Campus Party Brasil/Flickr CC

即便名声鹊起，Tim Berners-Lee 不改其志，他后来加入了由 Google、Facebook、微软等公司赞助的非营利组织 Alliance
 for Affordable Internet，致力于让全世界每个人都能付担得起网络这个由联合国定义的公民权。


演算法分析之父 Donald Knuth

从 Facebook 令人又爱又恨的动态消息，到亚马逊精准的产品推荐，都拜 Donald Knuth 在电脑科学的学术成就之赐，他被尊称为“算法分析之父”。



Donald Knuth, the "father of the analysis of algorithms"

Above: Donald Knuth, the “father of the analysis of algorithms”

Image Credit: Knuth

今年 77 岁的他，依然写作不辍，编著《电脑科学的艺术》（The Art of Computer Programming）套书，最近一本于 2011 年出版。他也是史丹佛大学的荣誉教授，退休的原因是为了专心撰写 TAOCP，造福更多有志于写程序的学子。


JavaScript 开发者 Brendan Eich

Brendan Eich 于 1995 年任职于网景期间，为网景浏览器开发出 JavaScript，成为最广泛的网页应用标准。1998 年他协助成立Mozilla.org，也就是 Firefox 浏览器的开发组织。



Brendan Eich.

Above: Brendan Eich.

Image Credit: YouTube

不过去年他晋升为 Mozilla 执行长，却因曾经以个人名义捐助 1000 美金支持反同性恋婚姻的美国婚姻组织（National
 Organization of Marriage），遭到员工与同性恋组织强烈反弹，言明拒用 Firefox，随即黯然下台。


Docker 创造者 Solomon Hykes

Solomon Hykes 创造了 Docker，让众多开发者乐歪了的技术，因为 Docker 让他们只需要写一次程序，随时随地都能在任何地方执行。



Docker founder and CTO Solomon Hykes

Above: Docker founder and CTO Solomon Hykes

Image Credit: Docker

Docker 本来其实只是 dotCloud 的副项目（side
 project），但自从 Docker 成了工程师人见人爱的工具之后，现在整间公司的重心已移往新宠儿。曾有传闻指出，Docker 的价值约有 10 亿美金这么高。


Facebook 共同创办人 Mark Zuckerberg

这位，应该就不用特别解释了。在哈佛大学造出社区帝国 Facebook 的 Mark Zuckerberg，其渲染整间公司的座右铭“move
 fast and break things”也早已根植从硅谷起源的新创公司文化。



Facebook chief executive Mark Zuckerberg

Above: Facebook chief executive Mark Zuckerberg

Image Credit: Eduardo Munoz/Reuters


Ruby on Rails 设计者 David Heinemeier Hansson


Ruby 是由日本电脑科学家松本行弘设计的，以简洁优雅闻名，而来自丹麦的 David Heinemeier Hansson（DHH）为 Ruby 语言开发了框架（Rails），让 Ruby 在全球爆发性成长，成为最受欢迎的网站后端语言之一。2005 年被 Google 评选为“年度黑客”。



David Heinemeier Hansson

Above: David Heinemeier Hansson

Image Credit: Courtesy of David Heinemeier Hansson

有些台湾工程师会将 DHH 比为“欧洲林志颖”，因为他除了写程序，还是个赛车手，2012 年参加过 Le
 Mans 24 小时耐力赛，2014 年夺得冠军。DHH 也是项目软体开发公司 Basecamp（原名 37
 Signals）的合伙人。


自由软体运动精神领袖 Richard Stallman

Richard Stallman 是美国自由软体运动的精神领袖，坚定的自由软体倡导者。他所创造的 GNU 通用公共许可证是世界上最被广泛采用的自由软体许可证，他所推行的“Copyleft”的概念，确保软体被应用在公共领域。



Richard Stallman, software freedom fighter

Above: Richard Stallman, software freedom fighter

Image Credit: Wikimedia Commons


BitTorrent 发明者 Bram Cohen

2001 年 Bram Cohen 发明了 BitTorrent 让他声名大噪。相信读者多少都曾受过 BT 的“恩泽”，BT 将巨大的文件分割成可以同时下载的小型文件，让使用者享受奔驰下载的快感。



Bram Cohen, CEO and Founder of BitTorrent

Above: Bram Cohen, CEO and Founder of BitTorrent

Image Credit: Wikimedia Commons

据估计 BitTorrent 在全球拥有 10 亿使用者，尽管因散布盗版文件的形象曾被视为创作者的天敌，但去年英国乐团 Radiohead 主唱 Thom
 Yorke 直接在 BT 上独家发行新专辑。至今，BT 天然的匿名性与无与伦比的下载速度，依旧是网友交流盗版音乐、电影、游戏的天堂。


Java 发明者 James Gosling

全世界最热门的语言之一 Java，发明者是这位 James Gosling。



James Gosling, inventor of the Java programming language.

Above: James Gosling, inventor of the Java programming language.

Image Credit: Wikimedia Commons

他在SUN电脑工作时开发了这套语言。当时作为科技先锋的SUN于 2010 年被甲骨文收购，James Gosling 于并购案生效之后旋即离职，并且经常严厉批评甲骨文。后来他曾在 Google 短暂工作过五个月，接着又加入新创公司 Liquid
 Robotics。


C++ 发明者 Bjarne Stroustrup


“C++”应该是这世界最家喻户晓的程序语言了，这是由丹麦电脑科学家 Bjarne Stroustrup 在 1978 年于贝尔实验室所发明。奠基于已故 Dennis
 Ritchie 开发的 C 语言，加上诸多新特性，成为运用最广泛的语言之一。



Bjarne Stroustrup, inventor of C++

Above: Bjarne Stroustrup, inventor of C++

Image Credit: Wikimedia Commons

现在 Bjarne Stroustrup 任教于德州农工大学、哥伦比亚大学，同时也在摩根史坦利工作。


《毁灭战士》John Carmack

John Carmack 是 id Software 的共同创办人，他最知名的事迹是开发了《德军总部3D》（Wolfenstein
 3D）、《毁灭战士》（Doom）和《雷神之锤》（Quake）等游戏。他所引领的 3D 图像技术，如二元树分割技术、表面快取技术，历久弥新。



John Carmack

Above: John Carmack

Image Credit: Flickr

现在 John Carmack 在 Facebook 担任 Oculus
 VR 首席技术长，将他在图像的渊博知识，带向虚拟实境头盔。

（译文来自 INSIDE，进行了繁简体和用语转换）

版权声明：本文为博主原创文章，未经博主允许不得转载。

Emacs Color-theme and Multi-term Config
vim与emacs的谁好谁坏废话就不说了，只是觉得emacs用起来具备的功能更多，可扩展方便.
这里默认你已经安装了emacs，还有奉劝安装了emacs之后别作死的想着把它配置成
IDE，简直就是浪费时间，当然可以做为兴趣去玩；若真脱离不了IDE，大可以在WIN
 上用MS 的VS编码好后，然后再重编一次放linux上跑。用编辑器写代码的目的就是
为了让自己对于自己写出来的东西清晰、了如指掌；若觉得emacs不好用，建议用一周的VIM，再来用emacs
 
emacs配置：vim ~/.emacs
;;将~/.emacs.d/添加到加载路径
(add-to-list 'load-path "~/.emacs.d/")
(require 'color-theme)
(color-theme-initialize)
;;选择的主题，color-theme后面是主题名字，注意要小写
(color-theme-calm-forest)
;;自定义热键HOT KEY
(global-set-key [f1] 'shell)                                                       ;进入shell
(global-set-key [C-f9] 'gdb)                                                    ;调试
(setq compile-command "scons")                                                            ;编译
(global-set-key [f9] 'compile)
(global-set-key [f10] 'speedbar)                                                   ;启动/关闭speedbar
(global-set-key [C-/] 'comment-or-uncomment-region)               ;注释/取消注释
(global-set-key [f11] 'c-indent-line-or-region)                         ;格式化代码
(global-set-key [C-tab] 'other-window)                                              ;切换窗口
(global-set-key [M-return] 'delete-other-windows)              ;关闭其他窗口
(global-linum-mode t)                                                                               ;emacs设置行号
;;multi-term设置
(load-file (expand-file-name "/usr/share/emacs/site-lisp/multi-term.el"))
(require 'multi-term)
(setq multi-term-program "/bin/bash")
(setq multi-term-buffer-name "term")
(global-set-key "\C-x." 'multi-term)
(global-set-key "\C-x," 'multi-term-dedicated-open)
(setq multi-term-dedicated-select-after-open-p t)
 
一、emacs配置color-theme部分
◆下载color-theme包
http://download.savannah.gnu.org/releases/color-theme/
◆解压并copy到~/.emacs.d/中
tar zxf 
color-theme-6.6.0.tar.gz
cp -r themes color-theme.el ~/.emacs.d
◆vim ~/.emacs 添加
emacs配置：
;;将~/.emacs.d/添加到加载路径
(add-to-list 'load-path "~/.emacs.d/")
(require 'color-theme)
(color-theme-initialize)
;;选择的主题，color-theme后面是主题名字，注意要小写
(color-theme-calm-forest)
 
启动emacs查看，可M+X color-theme-select查询已有主题，并替换掉
(color-theme-calm-forest)中的calm-forest，注意小写
 
二、emacs mutli-term部分
 
◆安装mutli-term
参考http://www.emacswiki.org/emacs/MultiTerm
wget http://www.emacswiki.org/emacs/download/multi-term.el到/usr/share/emacs/site-lisp/目录中，然后在emacs的配置文件添加
(load-file (expand-file-name "/usr/share/emacs/site-lisp/multi-term.el"))
 
加载完文件之后，只要引用multi-term.el再配置相关热键即可
(require 'multi-term)
(setq multi-term-program "/bin/bash")
(setq multi-term-buffer-name "term")
(global-set-key "\C-x." 'multi-term)
(global-set-key "\C-x," 'multi-term-dedicated-open)
(setq multi-term-dedicated-select-after-open-p t)
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

sklearn特征选择和分类模型
sklearn特征选择和分类模型



数据格式：
这里，原始特征的输入文件的格式使用libsvm的格式，即每行是label index1:value1 index2:value2这种稀疏矩阵的格式。
 
sklearn中自带了很多种特征选择的算法。我们选用特征选择算法的依据是数据集和训练模型。
 
下面展示chi2的使用例。chi2，采用卡方校验的方法进行特征选择，比较适合0/1型特征和稀疏矩阵。
from sklearn.externals.joblib import Memory
from sklearn.datasets import load_svmlight_file
mem = Memory("./mycache")
@mem.cache
def get_data():
    data = load_svmlight_file("labeled_fea.txt")
    return data[0], data[1]
X, y = get_data()
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import chi2

data  = SelectKBest(chi2, k=10000).fit_transform(X, y)

from sklearn.datasets import dump_svmlight_file
dump_svmlight_file(data, y, "labeled_chi2_fea.txt",False)

sklearn中分类模型也很多，接口统一，非常方便使用。
分类之前，可以不进行特征选择，也可以先独立进行特征选择后再做分类，还可以通过pipeline的方式让特征选择和分类集成在一起。


from sklearn.externals.joblib import Memory
from sklearn.datasets import load_svmlight_file
mem = Memory("./mycache")
@mem.cache
def get_data():
    data = load_svmlight_file("labeled_fea.txt")
    return data[0], data[1]

X, y = get_data()

train_X = X[0:800000]
train_y = y[0:800000]
test_X = X[800000:]
test_y = y[800000:]
print(train_X.shape)
print(test_X.shape)

from sklearn.feature_selection import SelectKBest, chi2
from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import BernoulliNB, MultinomialNB
from sklearn.linear_model import RidgeClassifier
from sklearn.linear_model import Perceptron
from sklearn.neighbors import NearestCentroid
from sklearn.linear_model import SGDClassifier
from sklearn.svm import LinearSVC
from sklearn.ensemble import GradientBoostingClassifier
from sklearn import metrics
from time import time

#独立的特征选择
ch2 = SelectKBest(chi2, k=10000)
train_X = ch2.fit_transform(train_X, train_y)
test_X = ch2.transform(test_X)

#根据一个分类模型，训练模型后，进行测试
def benchmark(clf):
    print('_' * 80)
    print("Training: ")
    print(clf)
    t0 = time()
    clf.fit(train_X, train_y)
    train_time = time() - t0
    print("train time: %0.3fs" % train_time)
    t0 = time()
    pred = clf.predict(test_X)
    test_time = time() - t0
    print("test time:  %0.3fs" % test_time)
    score = metrics.accuracy_score(test_y, pred)
    print("accuracy:   %0.3f" % score)
    clf_descr = str(clf).split('(')[0]
    return clf_descr, score, train_time, test_time

clf = RandomForestClassifier(n_estimators=100)
#clf = RidgeClassifier(tol=1e-2, solver="lsqr")
#clf = Perceptron(n_iter=50)
#clf = LinearSVC()
#clf = GradientBoostingClassifier() 

#clf = SGDClassifier(alpha=.0001, n_iter=50,penalty="l1")
#clf = SGDClassifier(alpha=.0001, n_iter=50,penalty="elasticnet")

#clf = NearestCentroid()
#clf = MultinomialNB(alpha=.01)
#clf = BernoulliNB(alpha=.01)

#pipeline模型特征选择和分类模型结合在一起
#clf = Pipeline([ ('feature_selection', LinearSVC(penalty="l1", dual=False, tol=1e-3)), ('classification', LinearSVC())])

benchmark(clf)

 
值得注意的是，上面的程序训练和预测阶段都是在同一份程序执行。而实际应用中，训练和预测是分开的。因此，要使用python的对象序列化特征。每次训练完之后，序列化模型对象，保存模型的状态，预测时反序列化模型对象，还原模型的状态。
 
 
 
 
参考资料：
http://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_svmlight_file.html
http://scikit-learn.org/stable/modules/generated/sklearn.datasets.dump_svmlight_file.html
http://scikit-learn.org/stable/modules/feature_selection.html#feature-selection
http://scikit-learn.org/stable/auto_examples/text/document_classification_20newsgroups.html#example-text-document-classification-20newsgroups-py




本文作者：linger
本文链接：http://blog.csdn.net/lingerlanlan/article/details/47960127









版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream 1408 "Money, Money, Money"（找规律）


"Money, Money, Money"

Special Judge Time Limit: 2000/1000MS (Java/Others) Memory Limit: 128000/64000KB
 (Java/Others)

Submit Statistic Next
 Problem

Problem Description

      The government of Flatland has decided to carry out the money system reform. The purpose of the reform is to reduce the number of different banknotes denominations down to two. After the reform there will be two types of banknotes — a tupiks and b tupiks.
      The problem is that the president of Flatland doesn’t like the number x. Therefore the minister of finances was instructed to choose such a and b that it is impossible to pay exactly x tupiks without change. On the other hand it must be possible to pay
 all amounts larger than x.
      Now you are asked to help him — choose such a and b, or recommend the minister to retire, if it is impossible.

Input

      Input file contains one number x (1 ≤ x ≤ 1012).

Output

      Output two integer numbers a and b, such that it is impossible to pay x tupiks using banknotes of a and b tupiks without change, but it is possible to pay any larger sum. If it is impossible, output two zeroes to the output file.

Sample Input

3
4
5



Sample Output

2 5
0 0
3 4



题目大意：
给出一个数x，输出两个数a，b，要求任意个a与任意个b不能组合出x，但能组合出x之后的所有正整数（多种答案只要输出任意一种）。

解题思路：
题目看上去很难→_→。
当x是偶数时，找不到a和b满足题意；
当x是奇数时，我们要找到a和b使得它们能组成任何大于x的正整数。由于这些正整数中有奇数有偶数，所以一定要挑出一个2，因为2能组成所有的正偶数，然后再选出x+2即可，因为x是奇数，x+1一定是偶数，可以由2组成，x+2不能由2组成，所以必须挑出x+2。这样就可以使得x以后的所有偶数都由2组成，所有奇数的由x+2和若干个2组成。

参考代码：
#include <cstdio>
int main()
{
    long long x;
    while(~scanf("%lld",&x))
    {
        if(x&1) printf("2 %lld\n",x+2);
        else printf("0 0\n");
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Redis官网下载步骤（含windows版）
①.百度redis ，进入官网



②.进入官网后，点击下载









③.之后进入下载页面，选择stable（稳定） 下的最新版本






④.然后就会弹出一个下载框，选择下载位置，等待就行啦。（我用的是浏览器自带的下载工具）






⑤.其实上边方法下载的是linux版本的，初学者有时需要windows版本的，这就需要在第③步的时候往下拉页面，然后就会看到windows的字样，点击Learn
 more 就会进入GitHub（redis是开源的）






⑥.现在其实已经没在官网啦，在GutHub中继续往下拉页面，找到Redis on Windows






⑦.点击进入之后，不要选择Pre-release(测试版)，选择Latest Release(稳定版)





版权声明：本文为博主原创文章，未经博主允许不得转载。

hi3520d的DVR设计
hi3520d的DVR设计



版权声明：本文为博主原创文章，未经博主允许不得转载。

Aizu - 2306  Rabbit Party (DFS图论)

G. Rabbit Party

Time Limit: 5000ms
Case Time Limit: 5000ms
Memory Limit: 65536KB



64-bit integer IO format: %lld      Java class name: Main

Submit Status PID:
 39423

Font Size: 
+
 
-



Rabbit Party

A rabbit Taro decided to hold a party and invite some friends as guests. He has n rabbit friends, and m pairs of
 rabbits are also friends with each other. Friendliness of each pair is expressed with a positive integer. If two rabbits are not friends, their friendliness is assumed to be 0.

When a rabbit is invited to the party, his satisfaction score is defined as the minimal friendliness with any other guests. The satisfaction of the party itself is defined as the sum of satisfaction score for all the guests.

To maximize satisfaction scores for the party, who should Taro invite? Write a program to calculate the maximal possible satisfaction score for the party.

Input

The first line of the input contains two integers, n and m (1
 ¥leq n ¥leq 100, 0 ¥leq m ¥leq 100). The rabbits are numbered from 1to n.

Each of the following m lines has three integers, u, v and f. u and v (1
 ¥leq u, v ¥leq n, u ¥neq v, 1 ¥leq f ¥leq 1,000,000) stands for the rabbits' number, and f stands
 for their friendliness.

You may assume that the friendliness of a pair of rabbits will be given at most once.

Output

Output the maximal possible satisfaction score of the party in a line.

Sample Input 1
3 3
1 2 3
2 3 1
3 1 2


Output for the Sample Input 1
6


Sample Input 2
2 1
1 2 5


Output for the Sample Input 2
10


Sample Input 3
1 0


Output for the Sample Input 3
0


Sample Input 4
4 5
1 2 4
1 3 3
2 3 7
2 4 5
3 4 6


Output for the Sample Input 4
16
分析题目，由于给你的完全图（即一个顶点与其他的顶点都有边）
接着从题目可以分析的n * (n - 1) / 2 = m <= 100
（提示，如果一个点与其他点之间的友好值为0，那么可以去掉这个点，或者那个与它的边为0的点，大家可以思考一下，所以为零的可以直接去掉)
得知n <= 15所以，实际上只有15个数，那么我们可以DFS，得到这些数都是不会超时的


#include <map>
#include <set>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <vector>
#include <queue>
#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <algorithm>
using namespace std;


#define pb push_back
#define mp make_pair
#define fillchar(a, x) memset(a, x, sizeof(a))
#define copy(a, b) memcpy(a, b, sizeof(a))
#define S_queue<P> priority_queue<P, vector<P>,greater<P> >


typedef long long LL;
typedef pair<int, int > PII;
typedef unsigned long long uLL;
template<typename T>
void print(T* p, T* q, string Gap = " "){int d = p < q ? 1 : -1;while(p != q){cout << *p;p += d;if(p != q) cout << Gap; }cout << endl;}
template<typename T>
void print(const T &a, string bes = "") {int len = bes.length();if(len >= 2)cout << bes[0] << a << bes[1] << endl;else cout << a << endl;}

const int INF = 0x3f3f3f3f;
const int MAXM = 1e2 + 5;
const int MAXN = 1e2 + 5;
int Fig[MAXN][MAXN], Max;
int X[25], n, m;

void Deal(int s){
    int f , ans = 0;
    for(int i = 1;i <= s;i ++){
        f = INF;
        for(int j = 1;j <= s;j ++){
            if(i == j) continue;
            f = min(f, Fig[X[i]][X[j]]);
        }
    if(f != INF)
        ans += f;
    }
    Max = max(ans, Max);
}
void DFS(int u){
    Deal(u);
    int st = X[u] + 1;
    if(u == 0) st = 1;
    for(int i = st;i <= n;i ++){
        bool flag = true;
        for(int j = 1;j < u;j ++){
            if(Fig[i][X[j]] == 0) {
                flag = false;
                break;
            }
        }
        X[u + 1] = i;
        if(flag) DFS(u + 1);
    }
}

int main(){
    int u, v, d;
    while(cin >> n >> m){
        Max = 0;
        memset(Fig, 0, sizeof(Fig));
        for(int i = 1;i <= m;i ++){
            cin >> u >> v >> d;
            Fig[u][v] = Fig[v][u] = d;
            Max = max(Max, d * 2);
        }
        DFS(0);
        print(Max);
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Chisel Tutorial（八）——运行与测试
以下内容依据2015-7-10版的Chisel 2.2 Tutorial整理



前面我们已经定义了模块，本节讨论如何运行和测试一个电路。Chisel可以翻译得到C++或者Verilog。为了构建一个电路我们需要调用chiselMain，如下：
object tutorial{
  def main(args : Array[String]) = {
    chiselMain( args, () => Module(new Mux2()))
  }
}
测试是电路设计中很重要的一步，Chisel采用测试向量的机制来测试电路，测试向量所在的类是Tester的子类。
class Tester[T <: Module](val c: T,val isTrace: Boolean = true){
  var t: Int
  var ok: Boolean
  val rnd: Random
  def int(x: Boolean): BigInt
  def int(x: Int): BigInt
  def int(x: Bits):BigInt
  def reset(n: Int = 1)
  def step(n: Int): Int
  def pokeAt(data: Mem[T], index: Int, x: BigInt)
  def poke(data: Bits, x: BigInt)
  def poke(data: Aggregate, x: Array[BigInt])
  def peekAt(data: Mem[T], index: Int)
  def peek(data: Bits): BigInt
  def peek(data: Aggregate): Array[BigInt]
  def expect(good: Boolean, msg: String): Boolean
  def expect(data: Bits, target: BigInt): Boolean
}
测试类继承自Tester，然后连接到指定的模块，就可以向该模块输入测试向量了，具体来说，有如下方法：


 poke用来设置端口的值，和state的值 step用来表示执行一个时钟 peek用来读取端口的值，和state的值 expect用来判断读取的端口值是否是预期的值


用户使用如下对象连接待测试模块和测试类：

object chiselMainTest{
  def apply[T <: Module](args: Array[String], comp: ()=> T)(tester: T => Tester[T]): T
}
--test要作为一个参数传递给chiselMainTest。如下是一个测试类，用来测试2选1选择器。
class Mux2Tests(c: Mux2) extends Tester(c){
  val n = pow(2, 3).toInt
  for(s <- 0 until 2){
  for(i0 <- 0 until 2){
    for(i1 <- 0 until 2){
      poke(c.io.sel, s)
      poke(c.io.in1, i1)
      poke(c.io.in0, i0)
      step(1)
      expect(c.io.out, (if( s == 1) i1 else i0 ))
    }
  }
  }
}
上述测试类很简单，首先使用poke为Mux2的输入赋值，然后使用expect测试Mux2的输出是否是预期的值。最后，需要在chiselMainTest中使用该测试类，如下：
chiselMainTest(args + “--test”, () => Module(new Mux2())){
  c => new Mux2Tests(c)
}
args中可以加入其他参数，如下：


比如加入--backend v 就可以得到verilog代码。在之前的几篇博客“Chisel实验笔记”中已经用到过。



版权声明：本文为博主原创文章，未经博主允许不得转载。

Win8.1 64位操作系统 安装itunes出错问题解决办法
当我们安装itunes时，会提示各种权限或者是回滚事务出错问题，解决方案：当我们安装Itunes过程中，我们的电脑服务里的Device Install Service会关闭，所以需要手动打开，在电脑运行里输入services.msc会弹出服务程序，找到Device Install Service打开安装就可以了。如图所示：

版权声明：本文为博主原创文章，未经博主允许不得转载。

轻轻写书软件
作者：www.gudianxiaoshuo.com


有时候，想写点感悟，写点烦恼，写所见所感，写本自己的小说。
但一直没有找到适合自己的写书软件，
轻轻写书，提供了一个选择，轻轻的书写自己的书，静静的写自己的小说。
更有语音朗读、点评标注、字数统计等功能








版权声明：本文为博主原创文章，未经博主允许不得转载。

Wind River Linux 5.0.1.27
2692407267@qq.com，更多内容请关注http://user.qzone.qq.com/2692407267
Wind River Linux 5.0.1.27 

图就不贴了，后面有时间慢慢补


版权声明：本文为博主原创文章，未经博主允许不得转载。

libcurl库的使用(通过libcurl库下载url图像)
1.      从http://curl.haxx.se/download.html下载libcurl源码，解压缩；2.      通过CMake(cmake-gui)生成vs2013 x64位 CURL.sln；3.      打开CURL.sln，编译会生成libcurl.dll动态库；4.      在CURL.sln基础上，添加一个testlibcurl控制台工程；5.      testlibcurl.cpp：#include "stdafx.h"
#include <iostream>
#include <curl/curl.h>

size_t callbackfunction(void *ptr, size_t size, size_t nmemb, void* userdata)
{
    FILE* stream = (FILE*)userdata;
    if (!stream) {
        printf("!!! No stream\n");
        return 0;
    }

    size_t written = fwrite((FILE*)ptr, size, nmemb, stream);
    return written;
}

bool download_jpeg(char* url)
{
    FILE* fp = fopen("out.jpg", "wb");
    if (!fp) {
        printf("!!! Failed to create file on the disk\n");
        return false;
    }

    CURL* curlCtx = curl_easy_init();
    curl_easy_setopt(curlCtx, CURLOPT_URL, url);
    curl_easy_setopt(curlCtx, CURLOPT_WRITEDATA, fp);
    curl_easy_setopt(curlCtx, CURLOPT_WRITEFUNCTION, callbackfunction);
    curl_easy_setopt(curlCtx, CURLOPT_FOLLOWLOCATION, 1);

    CURLcode rc = curl_easy_perform(curlCtx);
    if (rc) {
        printf("!!! Failed to download: %s\n", url);
        return false;
    }

    long res_code = 0;
    curl_easy_getinfo(curlCtx, CURLINFO_RESPONSE_CODE, &res_code);
    if (!((res_code == 200 || res_code == 201) && rc != CURLE_ABORTED_BY_CALLBACK)) {
        printf("!!! Response code: %d\n", res_code);
        return false;
    }

    curl_easy_cleanup(curlCtx);
    fclose(fp);

    return true;
}

size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream)
{
    size_t written = fwrite(ptr, size, nmemb, stream);
    return written;
}

bool download_jpeg2(char* url)
{
    CURL *curl;
    FILE *fp;
    CURLcode res;
    char* outfilename = "out2.jpg";

    curl = curl_easy_init();
    if (curl) {
        fp = fopen(outfilename, "wb");
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
        res = curl_easy_perform(curl);
        /* always cleanup */
        curl_easy_cleanup(curl);
        fclose(fp);
    }
    else {
        printf("!!!curl init failed\n");
        return false;
    }

    return true;
}

int main(int argc, char* argv[])
{
    char* url = "http://f.hiphotos.baidu.com/image/pic/item/d043ad4bd11373f0671f5d95a60f4bfbfbed0493.jpg";

#if 1
    if (!download_jpeg(url)) {
        printf("!! Failed to download file: %s\n", url);
        return -1;
    }
#else
    if (!download_jpeg2(url)) {
        printf("!! Failed to download file: %s\n", url);
        return -1;
    }
#endif

    std::cout << "ok!" << std::endl;
	return 0;
}参考文献：1.      http://stackoverflow.com/questions/10112959/download-an-image-from-server-curl-however-taking-suggestions-c2.      http://stackoverflow.com/questions/1636333/download-file-using-libcurl-in-c-c3.      https://www.hackthissite.org/articles/read/10784.      http://curl.askapache.com/c/example.html

版权声明：本文为博主原创文章，未经博主允许不得转载。

bzoj-2006   超级钢琴
题意：
给出一个长度为n的序列，取序列中L<=长度<=R的子串；
问这样的子串前k大个的和是多少；


题解：
好像是很神的题。。
首先考虑一个子串的和是什么？比如[i,j]这个串，和就是sum[j]-sum[i-1]   (sum表示前缀和)；
那么对于每一个j的答案，应该是sum[i-1]比较小的i值；
怎么找到前k大，就用到了A*算法；
我们首先将每个j对应的最小的sum[i-1]求值，之后插入堆中；
每次拿出最大的；
因为这里每个j对应的i-1都相对自己最优，所以这里拿出的一定是最大的；
而拿出最大的之后，同时也要将这个j对应的下一个小的sum[i-1]插入；
这样的思想就是A*，预估值严格的A*算法经常可以用来解决这样的K大值问题吧；
查询区间第k大用主席树实现，我还去学了指针版的诸多姿势；
时间复杂度O(nlogn+klogn)；


代码：



#include<queue>
#include<vector>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#define N 510000
#define INF 500000000
using namespace std;
struct node
{
	node *l,*r;
	int sum;
	node ();
}*null=new node(),*root[N];
node:: node ()
{
	l=r=null,sum=0;
}
struct seg
{
	int val,R,k;
};
int sum[N];
bool operator <(seg a,seg b)
{
	return a.val<b.val;
}
priority_queue<seg>q;
void Insert(int l,int r,node* &p,int val)
{
	node *rt=new node();
	*rt=*p,p=rt;
	p->sum++;
	if(l==r)	return ;
	int mid=l+r>>1;
	if(val<=mid)	Insert(l,mid,rt->l,val);
	else			Insert(mid+1,r,rt->r,val);
}
int query(int l,int r,node *nol,node *nor,int k)
{
	if(l==r)
		return l;
	int mid=l+r>>1;
	if(k<=nor->l->sum-nol->l->sum)
		return query(l,mid,nol->l,nor->l,k);
	else
		return query(mid+1,r,nol->r,nor->r,k-nor->l->sum+nol->l->sum);
}
int main()
{
	int n,m,i,j,k,L,R,x,y;
	long long ans;
	scanf("%d%d%d%d",&n,&k,&L,&R);
	root[0]=null->l=null->r=null;
	null->sum=0;
	Insert(-INF,INF,root[0],0);
	for(i=1;i<=n;i++)
	{
		scanf("%d",&x);
		sum[i]=sum[i-1]+x;
		root[i]=root[i-1];
		Insert(-INF,INF,root[i],sum[i]);
	}
	seg now;
	for(i=L;i<=n;i++)
	{
		now.R=i,now.k=1;
		now.val=sum[i]-query(-INF,INF,i-R-1>=0?root[i-R-1]:null,root[i-L],1);
		q.push(now);
	}
	for(i=1,ans=0;i<=k;i++)
	{
		now=q.top(),q.pop();
		ans+=now.val;
		now.k++;
		if(L+now.k-1<=R&&now.k<=now.R)
		{
			now.val=sum[now.R]-query(-INF,INF,now.R-R-1>=0?root[now.R-R-1]:null,root[now.R-L],now.k);
			q.push(now);
		}
	}
	printf("%lld\n",ans);
	return 0;
}





简单演示Exploit SEH原理(未开启SafeSEH模块)
    前面写了不少SEH相关文章，这里来个复杂点的栈溢出SEH。文章不重复解释SEH运行原理，但对主要步骤加以调试和注释，另外本文参考考了雪上 Exploit 编写系列教程第三篇_基于SEH的Exploit 一文。一般来说Exploit重在溢出，不过本文旨在是演示Exploit SEH的原理，因此省略溢出过程直接在栈上修改。
程序源码(vc++6.0 Debug版本)如下:    
#include<windows.h>

int ExceptionHandler(void);
void Fake_Handler();
void FakeShellcode();

int main(int argc,char *argv[])
{
	__try
	{
		__asm
		{
		mov edx,ebp;
		sub edx,0x10;
		mov DWORD ptr [edx],0x909006EB;
		lea eax,Fake_Handler;
		mov DWORD ptr [edx+4],eax;
		mov BYTE ptr [edx+8],0xE9;
		lea ebx,[edx+8];
		lea ecx,FakeShellcode;
		sub ecx,5;
		mov eax,ecx;
		sub eax,ebx;
		mov DWORD ptr [edx+9],eax;
		}
		__asm
		{
		xor eax,eax;
		mov [eax],eax;
		}
	}
	__except(ExceptionHandler())
	{}
	return 0;
}

__declspec(naked) void Fake_Handler()
{
	__asm
	{
		pop edi;
		pop esi;
		ret;
	}
}

__declspec(naked) void FakeShellcode()
{
	MessageBox(NULL,"","",MB_OK);
}

int ExceptionHandler(void)
{
	return 0;
}
前面的博文"vc++6对windows SEH扩展分析"提到vc++对SEH机制做了扩展，在堆栈上扩展了一个结构


struct _EXCEPTION_REGISTRATION  
　　 {  
　　　　 struct _EXCEPTION_REGISTRATION *prev;  
　　　　 void (*handler)(PEXCEPTION_RECORD,  
　　　　　　　　　　 PEXCEPTION_REGISTRATION,  
　　　　　　　　　　 PCONTEXT,  
　　　　　　　　　　 PEXCEPTION_RECORD);  
　　　　 struct scopetable_entry *scopetable;  
　　　　 int trylevel;  
　　　　 int _ebp;  
　　　　 PEXCEPTION_POINTERS xpointers;  
　　 }; 代码L13,L14通过_EXCEPTION_REGISTRATION!_ebp的地址定位到_EXCEPTION_REGISTRATION!prev的地址，这同时是当前函数栈中的EXCEPTION_REGISTRATION异常处理结构的起始地址。后面的代码全是在这个结构上倒腾~

L16,L17将EXCEPTION_REGISTRATION!handler从__except_handler3修改为Fake_Handler
原生_EXCEPTION_REGISTRATION的内容,其中0x4012A0为__except_handler3:

0012FF38  EB 06 90 90 A0 12 40 00  ..悙..@.
0012FF40  20 F0 41 00 00 00 00 00   餉.....
0012FF48  88 FF 12 00 69 14 40 00mapfile内容:


 0001:00000291       __NLG_Dispatch             00401291 f   LIBCD:exsup.obj
 0001:000002a0       __except_handler3          004012a0 f   LIBCD:exsup3.obj
 0001:0000035d       __seh_longjmp_unwind@4     0040135d f   LIBCD:exsup3.obj

模拟handler覆盖后EXCEPTION_REGISTRATION内容:

0012FF38  EB 06 90 90 0F 10 40 00  ..悙..@.
0012FF40  20 F0 41 00 00 00 00 00   餉.....
0012FF48  88 FF 12 00 69 14 40 000x40100F是ILT增量连接表中跳转到Fake_Handler函数的地址

当异常发生，系统首先到fs:[0]队列中找最近节点的异常处理函数，如果处理不了，则通过该节点的prev域找次近节点处理。现在就假设出现一个异常，那得到执行的将是被覆盖了的Fake_Handler函数。我们跟着系统的节奏进入Fake_Handler函数。
Fake_Handler是个裸函数，进入该函数后，编译器并没有自作主张的生成函数帧，因此在执行L41前堆栈的布局如下:

[esp]:Fake_Handler
[esp+4]:<span><span>_EXCEPTION_RECO</span></span>
[esp+8]:<span><span>EXCEPTION_REGIST</span></span>
[esp+0x0C]:<span><span>_CONTEXT *pContex</span></span>
[esp+0x10]:<span><span>pDispatcherContext</span></span>
当然，你们可以质疑我是不是在大力乱神，我喜欢听反对声音，证明之：

进入该函数时堆栈布局：

0012FAFC  B9 72 F2 76 E4 FB 12 00  箁騰潲..
0012FB04  38 FF 12 00 00 FC 12 00  8.......
0012FB0C  B8 FB 12 00 0x76F272B8看着像是ntdll中的地址，

看下0x12FBE4处的内容，理应是_EXCEPTION_RECORD结构，里面至少包含了出错信息和出错指令地址:

0012FBE4  05 00 00 C0 00 00 00 00  ........
0012FBEC  00 00 00 00 99 10 40 00  ......@.其内容是0xC0000005,违例访存和0x401099:mov [eax],eax所在指令地址:


30:           xor eax,eax;
00401097   xor         eax,eax
31:           mov [eax],eax;
00401099   mov         dword ptr [eax],eax
32:           }
33:       }到这，可以确定堆栈上参数如上面假设那样。好，经过L41,L42的两个pop操作目前esp指向了EXCEPTION_REGIST结构，当前被展开的异常处理节点，这个节点的内容已经被溢出覆盖。当执行L43 ret指令时会发生什么？想象一下pop eip，将esp的内容传递给eip，之后eip去那取指令运行。

看看执行ret时，esp指向:

 ESI = 0012FBE4 EDI = 76F272B9
 EIP = 00401102 ESP = 0012FB04
...
0012FB04  38 FF 12 00 00 FC 12 00  8.......
0x12FB04处的内容是0x12FF38,跟过去看看：


0012FF38  EB 06 90 90 0F 10 40 00  ..悙..@.
0012FF40  E9 C0 10 2D 00 00 00 00  槔.-....
0012FF48  88 FF 12 00 69 14 40 00  ....i.@.如果一时记不起这块内存的内容，麻烦向上滚动一下鼠标滚轮，前面提到这是程序开始时，由编译器在函数堆栈上安置的EXCEPTION_REGIST异常处理节点!!

很明显了，eip将去堆栈上取指令运行，而且取出的指令来自EXCEPTION_REGIST!prev所在(已经被溢出覆盖)。
回到main函数L15处这里的指令mov DWORD ptr [edx],0x909006EB;将原本prev的内容改成一条跳转语句jmp 06和两个nop的opcode。这有个问题为什么是jmp 06?一般Exploit SEH溢出后内存布局是:buff+next SEH 的地址(被jmp 06；nop；nop代替)+SEH Handler 的地址(4字节地址，在本文被Fake_Handler覆盖)+shellcode。jmp
 06执行时，eip指向第一个nop指令，jmp 06执行后，eip跳过中间2B的nop填充指令和4B被覆盖的异常处理过程函数的地址，之后eip直接去shellcode中取指运行~
    main函数中在后面的内容已经没有解释的必要了，本篇完~

相关链接:
1.Exploit 编写系列教程第三篇_基于SEH的Exploit（+3b）
2.绕过SEHOP安全机制


版权声明：本文为博主原创文章，未经博主允许不得转载。

Win7 Chrome的缓存及用户数据位置修改
    查阅多处资料后，自己总结并整理了2种方法:使用命令参数、使用mklink命令创建符号链接。建议直接使用第2种方式。
    首先找到数据位置并分清楚目录的作用：
    C:\Users\XXX\AppData\Local\Google\Chrome\UserData    用户数据（这个目录在默认情况下包含了缓存，里面还包括各种配置信息，以及书签、扩展等内容)
    C:\Users\XXX\AppData\Local\Google\Chrome\UserData\Default\Cache   缓存
方案一：
    这是在快捷方式中设置命令参数的修改方式。右键——属性——快捷方式——目标：
 
    在目标(T)一栏chrome.exe"后面添加 --user-data-dir="X:\文件夹"：
    "C:\Users\XXX\AppData\Local\Google\Chrome\Application\chrome.exe" --user-data-dir="X:\文件夹"（注：英文状态标点，注意\chrome.exe”与空格)
【注意】快捷方式创建好后，只能从快捷健启动有效，要使外部调用生效，还要做如下修改：
    Win+R——regedit，打开注册表。分别找到[HKEY_CLASSES_ROOT]下的ChromeHTML、ftp、http、https，shell\open\command的右边数值上右键改“C:\Users\XXX\AppData\Local\Google\Chrome\Application\chrome.exe" --
 "%1\"的值。
       在 -- "%1\"的前面chrome.exe"的后面添加 --user-data-dir="X:\文件夹" (注意空格)
[HKEY_CLASSES_ROOT\ChromeHTML\shell\open\command]
修改后"C:\Users\XXX\AppData\Local\Google\Chrome\Application\chrome.exe"--user-data-dir="X:\文件夹" -- "%1\"
[HKEY_CLASSES_ROOT\ftp\shell\open\command]
修改后"C:\Users\XXX\AppData\Local\Google\Chrome\Application\chrome.exe" --user-data-dir="X:\文件夹" -- "%1\"
[HKEY_CLASSES_ROOT\http\shell\open\command]
修改后"C:\Users\XXX\AppData\Local\Google\Chrome\Application\chrome.exe" --user-data-dir="X:\文件夹" -- "%1\"
[HKEY_CLASSES_ROOT\https\shell\open\command]
修改后"C:\Users\XXX\AppData\Local\Google\Chrome\Application\chrome.exe" --user-data-dir="X:\文件夹" -- "%1\"
下面是常用的一些启动参数：
--user-data-dir=UserDataDir   自定义用户数据目录
--start-maximized                    启动就最大化
--no-sandbox                           取消沙盒模式
--single-process                       单进程运行
--process-per-tab                    每个标签使用单独进程
--process-per-site                    每个站点使用单独进程
--in-process-plugins                插件不启用单独进程
--disable-popup-blocking       禁用弹出拦截
--disable-javascript                  禁用JavaScript
--disable-java                           禁用Java
--disable-plugins                      禁用插件
--disable-images                      禁用图像 

=========================================================================
方案二：
    使用mklink命令是真正的改变路径方法。首先找到Chrome浏览器的缓存文件目录。如果你的Win7安装在C盘，你的用户名XXX，那么"C:\Users\XXX\AppData\Local\Google\Chrome\UserData\Default\Cache"就是你Chrome的缓存文件路径。下面是Win7下修改Chrome浏览器默认缓存目录的具体操作：
    1. 删除你Chrome的默认缓存文件夹，即"C:\Users\XXX\AppData\Local\Google\Chrome\UserData\Default目录下的”Cache”文件夹。
    2. 新建一个Chrome缓存文件夹，目录名随意。如在D盘下建立 "D: \Chrome\Cache”目录。
    3. 确认当前为管理员身份登录，单击开始菜单——所有程序——附件——命令提示符，从弹出的菜单中选择“以管理员身份运行”命令
mklink /D "C:\Users\XXX\AppData\Local\Google\Chrome\User Data\Default\Cache" "D:\Chrome\Cache"

版权声明：本文为博主原创文章，未经博主允许不得转载。

轻松python文本专题-字符与字符值转换
场景：
将字符转换成ascii或者unicode编码
在转换过程中，注意使用ord和chr方法
>>> print(ord('a'))
97
>>> print(chr(97))
a
>>> 
有时候需要反转过来使用：
>>> print(str(ord('a')))
97
>>> print(chr(ord('a')))
a
>>> 
这个时候需要注意str()与chr()之间的区别：str是把返回的对象直接转为字符串，而chr则是把返回的对象转换为对应的ascii码的字符串




就说到这里，谢谢大家


------------------------------------------------------------------

点击跳转零基础学python-目录


版权声明：本文为博主原创文章，未经博主允许不得转载。

java语言实现队列
什么是队列：
队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。

队列的基本操作：
enqueue(Object obj)：入队操作
dequeue()：出队操作
循环队列：
由于队列如果做成数组的形式，为了保证出队列的时间复杂度为O(1)，所以不能将数组中的元素进行移动（如果移动，时间复杂度就变为了O(n)）。因此前面出栈之后的元素空间就会被浪费。所以我们将数组的头尾进行相接，这样就形成了循环，我们称这样的队列为循环队列。结构图如下所示：

判断队列为空：front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样的front等于rear的时候，此时队列不是还剩下一个元素，而是为空队列。所以空队列的判断为front == rear。

判断队列为满：当队列为满时，我们修改其条件，保存一个元素空间。也就是说，队列为满时，数组中还有一个空闲单元。（这就是为什么后面的代码中数组的大小为5，却最多可以插入4个元素）所以满队列的判断为(rear+1)%QueueSize == front。
代码示例如下：
package queue;
/**
 * 数组中只存储数组大小-1个元素，
 * 保证rear转一圈之后不会和head相等，
 * 也就是队列满的时候，rear+1=head，
 * 中间刚好空一个元素。
 * 当rear=head的时候，一定是队列空了。
 *
 */
public class QueueArray {
	private Object[] objs;
	private int front;
	private int rear;
	public QueueArray(){
		this(10);
	}
	public QueueArray(int size){
		objs = new Object[size];
		front = 0;
		rear = 0;
	}
	public boolean enqueue(Object obj){
		//判断队列是否为满
		if((rear+1)%objs.length == front){
			return false;
		}
		objs[rear] = obj;
		rear = (rear+1)%objs.length;
		return  true;
	}
	public Object dequeue(){
		//判断队列是否为空
		if(rear == front){
			return null;
		}
		Object obj = objs[front];
		front = (front+1)%objs.length;
		return obj;
	}
	public void traverse(){
		while(front != rear){
			System.out.print(objs[front]+" ");
			front = ((front+1)%objs.length);
		}
	}
	public static void main(String[] args) {
		QueueArray q = new QueueArray(5);
		q.enqueue("A");
		q.enqueue("B");
		q.enqueue("C");
		System.out.println("删除的元素为:"+q.dequeue());
		q.enqueue("F");
		System.out.println("删除的元素为:"+q.dequeue());
		q.traverse();
	}
}队列的链式存储方式：
入队与出队结构图：
               
入队：将新节点作为原来节点的后继，再将新节点设置为尾节点。this.rear.next = newNode;    this.rear = newNode;
出队：将需要删除节点的后继直接赋值给头结点的后继即可。this.front.next = node.next;
具体代码示例如下：      

package queue;

public class LinkQueue<T> {
	private class Node{
		private T data;
		private Node next;
		
		public Node(){}
	}
	private Node front;
	private Node rear;
	private int count;//队列中元素的数量
	
	public LinkQueue(){
		Node p = new Node();
		p.data = null;
		p.next = null;
		front = rear = p;
	}
	//使用尾插法插入数据
	public void equeue(T item){
		Node newNode = new Node();
		newNode.data = item;
		newNode.next = null;
		this.rear.next = newNode;
		this.rear = newNode;
		count++;
	}
	public T dequeue() throws Exception{
		if(isEmpty()){
			throw new Exception("队列为空!");
		}
		T obj;
		Node node = this.front.next;
		obj = node.data;
		this.front.next = node.next;
		if(rear == node){
			rear = front;
		}
		count --;
		return obj;
	}
	public int size(){
		return count;
	}
	public boolean isEmpty(){
		return front == rear;
	}
	public void traverse(){
		Node current = front.next;
		while(current != null){
			System.out.println(current.data);
			current = current.next;
		}
	}
	public static void main(String[] args) throws Exception {
		LinkQueue<String> lq = new LinkQueue<String>();
		lq.equeue("A");
		lq.equeue("B");
		lq.equeue("C");
		lq.equeue("D");
		lq.traverse();
		System.out.println("队列的长度为:"+lq.size());
		System.out.println("删除的元素为:"+lq.dequeue());
		lq.traverse();
	}
}无论是循环队列还是链式队列，从时间上看基本都是常数的时间，即时间复杂度都为O(1)。不过循环队列是事先申请好了空间，使用期间不释放。而对于链式队列，每次申请或释放节点也会存在一定的开销，如果入队或出队频繁，则还是存在细微的差异，但是链式队列在空间上更加灵活。所以，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度，则使用链队列。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Maven实战 -- 目录


《Maven实战》，许晓斌（Juven Xu），国内社区公认的Maven技术专家、Maven中文用户组创始人、Maven技术的先驱和积极推动者。2011.1初版。


基础性的构建工具，做Java的都会，会的程度参差不一，系统性的看一遍书，很快就能看完，可能有出乎意料的收获


第1章 Maven简介


1.1 何为 Maven

何为构建
Maven 是优秀的构建工具
Maven 不仅仅是构建工具

1.2 为什么需要Maven

组装 PC 和品牌 PC
IDE 不是万能的
Make
Ant
不重复发明轮子

1.3 Maven 与极限编程
1.4 被误解的 Maven
1.5 小结


第2章 Maven 的安装和配置


2.1 在 Windows 上安装 Maven

检查 JDK 安装
下载 Maven
本地安装
升级 Maven

2.2 在基于UNIX 的系统上安装 Maven

下载和安装
升级 Maven

2.3 安装目录分析

M2_HOME
~/.m2

2.4 设置 HTTP 代理
2.5 安装m2eclipse
2.6 安装 NetBeans Maven 插件
2.7 Maven 安装最佳实践

设置 MAVEN_OPTS 环境变量
配置用户范围 settings.xml
不要使用 IDE 内嵌的 Maven

2.8 小结


第3章 Maven 使用入门


3.1 编写POM
3.2 编写主代码
3.3 编写测试代码
3.4 打包和运行
3.5 使用 Archetype 生成项目骨架
3.6 m2eclipse 简单使用

导入 Maven 项目
创建 Maven 项目
运行 mvn 命令

3.7 NetBean Maven 插件简单使用

打开 Maven 项目
创建 Maven 项目
运行 mvn 命令

3.8 小结


第4章 背景案例


4.1 简单的账号注册服务
4.2 需求阐述

需求用例
界面原型

4.3 简要设计

接口
模块结构

4.4 小结


第5章 坐标和依赖


5.1 何为 Maven 坐标
5.2 坐标详解
5.3 account-email

account-email 的POM
account-email 的主代码
account-email 的测试代码
构建 account-email

5.4 依赖的配置
5.5 依赖范围
5.5 传递性依赖

何为传递性依赖
传递性依赖和依赖范围

5.7 依赖调解
5.8 可选依赖
5.9 最佳实践

排除依赖
归类依赖
优化依赖

5.10 小结


第6章 仓库


6.1 何为 Maven 仓库
6.2 仓库的布局
6.3 仓库的分类

本地仓库
远程仓库
中央仓库
私服

6.4 远程仓库的配置

远程仓库的认证
部署至远程仓库

6.5 快照版本
6.6 从仓库解析依赖的机制
6.7 镜像
6.8 仓库搜索服务

Sonatype Nexus
Jarvana
MVNbrowser
MVNrepository
选择合适的仓库搜索服务

6.9 小结


第7章 生命周期和插件


7.1 何为生命周期
7.2 生命周期详解

三套生命周期
clean 生命周期
default 生命周期
site 生命周期
命令行与生命周期

7.3 插件目标
7.4 插件绑定

内置绑定
自定义绑定

7.5 插件配置

命令行插件配置
POM 中插件全局配置
POM 中插件任务配置

7.6 获取插件信息

在线插件信息
使用 maven-help-plugin 描述插件

7.7 从命令行调用插件
7.8 插件解析机制

插件仓库
插件的默认 groupId
解析插件版本
解析插件前缀

7.9 小结


第8章 聚合与继承


8.1 account-persist

account-persist 的POM
account-persist 的主代码
account-persist 的测试代码

8.2 聚合
8.3 继承


account-parent
可继承的 POM 元素
依赖管理
插件管理

8.4 聚合与继承的关系
8.5 约定优于配置
8.6 反应堆

反应堆的构建顺序
裁剪反应堆

8.7 小结


第9章 使用Nexus创建私服


9.1 Nexus简介
9.2 安装 Nexus

下载 Nexus
Bundle 方式安装 Nexus
WAR 方式安装 Nexus
登录 Nexus

9.3 Nexus 的仓库与仓库组

Nexus 内置的仓库
Nexus 仓库分类的概念
创建 Nexus 宿主仓库
创建 Nexus 代理仓库
创建 Nexus 仓库组

9.4 Nexus 的索引与构件搜索
9.5 配置 Maven 从 Nexus 下载构件
9.6 部署构件至 Nexus

使用 Maven 部署构件至 Nexus
手动部署第三方构件至 Nexus

9.7 Nexus 的权限管理

Nexus 的访问控制模型
为项目分配独立的仓库

9.8 Nexus 的调度任务
9.9 其他私服软件
9.10 小结


第10章 使用 Maven 进行测试


10.1 account-captcha

account-captcha 的POM
account-captcha 的主代码
account-captcha 的测试代码

10.2 maven-surefire-plugin 简介
10.3 跳过测试
10.4 动态指定要进行的测试用例
10.5 包含与排除测试用例
10.6 测试报告

基本的测试报告
测试覆盖率报告

10.7 运行 TestNG 测试
10.8 重用测试代码
10.9 小结


第11章 使用 Hudson 进行测试集成


11.1 持续集成的作用、过程和优势
11.2 Hudson 简介
11.3 安装 Hudson
11.4 准备 Subversion 仓库
11.5 Hudson 的基本系统设置
11.6 创建 Hudson 任务

Hudson 任务的基本配置
Hudson 任务的源码仓库配置
Hudson 任务的构建触发配置

11.7 监视 Hudson 任务状态

全局任务状态
自定义任务视图
单个任务状态
Maven 项目测试报告

11.8 Hudson 用户管理
11.9 邮件反馈
11.10 Hudson 工作目录
11.11 小结


第12章 使用 Maven 构建 Web 应用


12.1 Web项目的目录结构
12.2 account-service

account-service 的 POM
account-service 的主代码

12.3 account-web

account-web 的 POM
account-web 的主代码

12.4 使用 jetty-maven-plugin 进行测试
12.5 使用 Cargo 实现自动化部署

部署至本地 Web 容器
部署至远程 Web 容器



第13章 版本管理


13.1 何为版本管理
13.2 Maven 的版本号定义约定
13.3 主干、标签与分支
13.4 自动化版本发布
13.5 自动化创建分支
13.6 GPG签名

GPG 及其基本使用
Maven GPG Plugin

13.7 小结


第14章 灵活的构建


14.1 Maven 属性
14.2 构建环境的差异
14.3 资源过滤
14.4 Maven Profile

针对不同环境的 profile
激活 profile
profile 的种类

14.5 Web 资源过滤
14.6 在 profile 中激活集成测试
14.7 小结


第15章 生成项目站点


15.1 最简单的站点
15.2 丰富项目信息
15.3 项目报告插件

JavaDocs
Source Xref
CheckStyle
PMD
ChangeLog
Cobertura

15.4 自定义站点外观

站点描述符
头部内容及外观
皮肤
导航边栏

15.5 创建自定义页面
15.6 国际化
15.7 部署站点
15.8 小结


第16章 m2eclipse


16.1 m2eclipse简介
16.2 新建 Maven 项目
16.3 导入 Maven 项目

导入本地 Maven 项目
从 SCM 仓库导入 Maven 项目
m2eclipse 中 Maven 项目的结构

16.4 执行 mvn 命令
16.5 访问 Maven 仓库

Maven 仓库视图
搜索构件和 Java 类

16.6 管理项目依赖

添加依赖
分析依赖

16.7 其他实用功能

POM 编辑的代码提示
Effective POM
下载依赖源码

16.8 小结


第17章 编写 Maven 插件


17.1 编写 Maven 插件的一般步骤
17.2 案例：编写一个用于代码行统计的 Maven 插件
17.3 Mojo 标注
17.4 Mojo 参数
17.5 错误处理和日志
17.6 测试 Maven 插件
17.7 小结


第18章 Archetype


18.1 Archetype 使用再叙

Maven Archetype Plugin
使用 Archetype 的一般步骤
批处理方式使用 Archetype
常用 Archetype 介绍

18.2 编写 Archetype
18.3 Archetype Catalog

什么是 Archetype Catalog
Archetype Catalog 的来源
生成本地仓库的 Archetype Catalog
使用 nexus-archetype-plugin



附录A POM元素参考
附录B Settings 元素参考
附录C 常用插件列表

版权声明：本文为博主原创文章，未经博主允许不得转载。

IDEA 14创建Maven管理的Java Web项目（图解）
之前讲过用MyEclipse下用Maven整合SpringMVC+Spring+Hibernate 框架，以后项目会越来越多的迁移到IDEA上，所以在此介绍下在IDEA上创建maven项目

创建步骤
1、新建项目，选择Maven，如下图： 
 
注：第二步中怎么设置： 
这里的sdk也就是意义上的jdk。我在stackoverflow得到答案，如下： 
1) You need to have a jdk installed on the system. 
for instance in 
C:\Java\jdk1.7.0_99 
2) go to project structure under File menu  ctrl+alt+shift+S 
3) SDKs is located under Platform Settings. Select it. 
4) click the green + up the top of the window. 
5) select JDK (I have to use keyboard to select it do not know why). 
select the home directory for your jdk installation.
2、填写GroupId和ArtifactId。如下图： 

3、选择Maven。如下图： 
 
(1)系统默认是有Maven 3(3.0.5)，而且他也自己下载，但是下载缓慢，所以最好的就是设置本地的maven，当然这里要设置环境变量。 
(2)全局settings.xml文件，可以设置全局本地仓储和局域网仓储，很好的解决了外网下载不到的问题，对团队开发很有利，可以看我的博客使用Nexus创建本地Maven仓库 
(3)本地仓储的设置，默认在C盘，最好是设置到别的盘。
4、设置项目名称和目录，如下图： 

5、生成maven项目，但是发现没有src和web目录 
 
src目录很好建，就是New Directory。 
web目录创建，如下！ 
6、创建web目录，如下2图： 
在项目名称上右击，选择Add Framework Support… 
 
在Add Framework Support对话框中勾选Web Application，版本选择3.1并勾选Create web.xml。 
 
点击OK后，看到如下界面，项目中出现了web文件件，是不是很熟悉了，和MyEclipse中的项目结构类似。
之后的开发和MyEclipse一样了。下面介绍下使用Web服务器。
配置Tomcat并发布
下面配置Tomcat服务器，本例使用Tomcat7。 
1、选择Edit Configuration 

2、设置自己的tomcat home和路径 

3、设置快捷启动方式。如下图 

4、部署应用 
 
选择你要部署的artifact.
5、千万记得输入你的工程名 

如上配置和部署已经完成，剩下的就是编程和运行了。
附：项目例子。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hadoop常用的压缩算法总结和实验验证



压缩格式总表




压缩格式


工具


算法


扩展名


是否可切分




DEFLATE


N/A


DEFLATE


.deflate


No




gzip


gzip


DEFLATE


.gz


No




bzip2


bzip2


bzip2


.bz2


Yes




LZO


lzop


LZO


.lzo


No




LZ4


N/A


LZ4


.lz4


No




Snappy


N/A


Snappy


.snappy


No


























压缩算法的时间空间权衡

所有的压缩算法都是时间和空间的转换，更快的压缩时间还是更小的压缩比，可以通过参数来指定，-1意味着速度，-9意味着空间。例如：
Gzip -1  file
 
压缩算法的速度和压缩比例的特点




压缩算法


特点


速度和压缩比




DEFLATE


标准压缩算法，没有生成它的常用命令行工具，通常都是用Gzip格式，也就是在deflate格式上添加gzip的文件头和文件尾，.deflate扩展名是hadoop定义的


——




Gzip


DEFLATE为基础扩展出来的一种算法；
通用压缩工具，时间和空间消耗比较折中


折中




Bzip2


压缩效果最好，但是压缩和解压速度最慢；
本身的解压速度比压缩速度快


压缩效果最好，速度最慢




LZO


比gzip速度快，但是压缩效果不好


压缩效果不好，
速度快




LZ4


比gzip速度快，但是压缩效果不好；
解压比LZO快


压缩效果不好，
速度快




Snappy


压缩效果不好，
速度快




 
 
实验验证
下面是在某公司利用真实的交易数据进行的压缩测试。由于LZO没有安装相应组件未做测试。从真实的实验可以看出，snappy用时最短，bzip2用时最长。Deflate实际上采用了Gzip算法，所以用时和压缩率接近。由于实验仅仅做了一次，再加上测试时间不同，集群性能可能也会有差异，理论上LZ4应该比gzip快。
 




压缩算法


表名


压缩时间


total time


原大小


压缩后大小 


压缩比




Gzip


a


333.276 s


0 hours 
23 min 28 s


71.9G


8.1 G 


7.9%




b


321.246 s


229.7 G


9.4 G




c


281.316 s


109.9 G 


7.6 G




d


379.03 s


71.9 G


13.2 G 




e


73.333 s


5.8 G


276.0 M




 




bzip2


a


481.926 s


0 hours
 32 min 10 s


71.9G


6.3 G


6.6%




b


478.724 s


229.7 G


8.3 G




c


404.097 s


109.9 G 


6.4 G




d


424.537 s


71.9 G


11.0 G




e


125.326 s


5.8 G


217.6 M




 




deflate


a


250.34 s


0 hours
 20 min 52 s


71.9G


8.1 G 


7.9%




b


301.89 s


229.7 G


9.4 G




c


264.25 s


109.9 G 


7.6 G




d


337.296 s


71.9 G


13.2 G 




e


 73.91 s


5.8 G


275.9 M 




 




LZ4


a


459.488 s


0 hours
 30 min 27 s


71.9G


15.2 G


13.4%




b


478.385 s


229.7 G


16.1 G 




c


399.978 s


109.9 G 


12.5 G




d


412.668 s


71.9 G


21.2 G




e


60.985 s


5.8 G


509.6 M




 




Snappy


a


216.268 s


 0 hours 
19 min 6 s


71.9G


14.0 G


13%




b


281.972 s


229.7 G


16.0 G




c


241.483 s


109.9 G 


12.2 G




d


322.299 s


71.9 G


20.7 G




e


63.202 s


5.8 G


548.5 M




 
以上采用hive进行测试，每次新建一个rcfile格式的表，从原始数据insert overwrite select进行数据导入，在执行脚本之前设置压缩算法，压缩算法的设置如下：

set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;
set mapred.min.split.size=536870912;
set mapred.min.split.size.per.node=536870912;
set mapred.min.split.size.per.rack=536870912;
set mapred.output.compress=true;

--设置压缩功能开启
SET hive.exec.compress.output=true; 
--设置压缩编码
SET mapred.output.compression.codec=org.apache.hadoop.io.compress.SnappyCodec;
--SET mapred.output.compression.codec=com.hadoop.compression.lzo.LzopCodec;
--SET mapred.output.compression.codec=org.apache.hadoop.io.compress.Lz4Codec;
--SET mapred.output.compression.codec=org.apache.hadoop.io.compress.GzipCodec;
--SET mapred.output.compression.codec=org.apache.hadoop.io.compress.DefaultCodec;--deflate
--SET mapred.output.compression.codec=org.apache.hadoop.io.compress.BZip2Codec;
--设置压缩类型block  
SET mapred.output.compression.type=BLOCK;   
set hive.exec.dynamic.partition=true;
set hive.exec.dynamic.partition.mode=nonstrict;








 


版权声明：本文为博主原创文章，未经博主允许不得转载。

maven生成代码结构时XmlPullParserException异常

在使用maven eclipse:eclipse生成Eclipse项目代码结构时，遇到如下Warning提示信息：
[WARNING] could not read workspace project from:E:\JavaSpace\webapi-maven
org.codehaus.plexus.util.xml.pull.XmlPullParserException: only whitespace content allowed before start tag and not \u9518 (position: START_DOCUMENT seen \u9518... @1:1) 
at org.codehaus.plexus.util.xml.pull.MXParser.parseProlog(MXParser.java:1557)
at org.codehaus.plexus.util.xml.pull.MXParser.nextImpl(MXParser.java:1436)
at org.codehaus.plexus.util.xml.pull.MXParser.next(MXParser.java:1131)
at org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(Xpp3DomBuilder.java:186)
at org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(Xpp3DomBuilder.java:75)
at org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(Xpp3DomBuilder.java:40)





错误原因：是pom.xml文件的格式问题，需要将文件修改修改为UTF-8无BOM格式即可；

例如：只是UTF8编码格式也不行，可以使用文档编辑器(Notepad++、UltraEdit等)将格式修改为UTF8无BOM格式(utf-8 without BOM)就好了。




有些博客上说是什么工作空间被锁定，重新建一个工作空间就没有问题了，有种被误导的感觉~~(明明是Xml pareser exception)。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Neural Networks for Machine Learning by Geoffrey Hinton （5）




为什么物体识别很困难
获得视角不变性的方法
不变特征方法The invariant feature approach
合理归一化方法The judicious normalization approach
强制归一化方法The brute force normalization approach


用以手写体识别的卷积神经网络
复制特征方法The replicated feature approach
复制特征方法学习到了什么
复制特征提取器的池化Pooling


LeNet5 模型
如何评价两个模型的优劣
Alexs Net 的诸多设计






为什么物体识别很困难？

图像分割（Segmentation）：实际场景中总是掺杂着其他物体。
物体光照（Lighting）：像素的值被物体光照所显著影响。
图像变形（Deformation）：物体有时会变形成非仿射（non-affine）的形式。
情景支持（Affordances）：物体所属类别常常由他们的使用方式而定义。如各种能坐的物体都可以是算是椅子。
维度跳变（dimension-hopping）： 

  具体表现是：改变视角（viewpoint）可能导致机器学习方法失效，如图1。 
 
 
  图1 
 
  形象的比喻是：网络用来学习病人的各种体征，之前用来学习身高的神经元，现在忽然用来学习病人的年龄。

获得视角不变性的方法

使用充足冗余的不变性特征（redundant invariant features）。
在物体外侧画一个边框，然后对其进行归一化（Normalization）。
使用复制特征（replicated features）以及池化（pooling）技巧。

不变特征方法（The invariant feature approach）
提取一个巨大、冗余的特征集合，这个集合对于变换具有不变性。

例如：在红点周围的两根粗平行线。如图2。 
 
 
  图2 


当时对于识别任务而言，应当尽量避免不属于物体的部分的特征。
合理归一化方法（The judicious normalization approach）

在物体周围放置一个边框，并定位方向，从而进行归一化。如图3。
边框对相当多的变形具有不变性：如平移、旋转、放大、剪切以及拉伸。 
 
 
图3 


然而选取边框非常困难，因为：

分割错误、遮挡、反常定位。
因此我们需要识别出物体才能更好对边框进行定位——这变成了鸡与蛋的问题。

强制归一化方法（The brute force normalization approach）

训练识别器的时候用良好裁切，方向竖直向上、贴合边框的图片。
测试识别器的时候用各种位置和朝向的边框。
这种方法对检测未经裁切的竖直物体如脸部、门牌号码这些任务很有效。

用以手写体识别的卷积神经网络
复制特征方法（The replicated feature approach）

在不同的位置使用相同的特征提取器，如图4。
复制特征的方法显著降低了自由参数的数量。 
 
 
图4 


复制特征方法学习到了什么？

激活值等变化量

复制特征的方法并不能使神经元激活值不变，但是能够使激活值改变量相同，如图5。 
 
 
  图5 


知识不变量

如果在训练中某个特征在一些位置有效，那么在测试中，特征提取器应该在各个位置生效。


复制特征提取器的池化（Pooling）

池化就是把相邻的像素值均值化，作为下一层网络的单一输入。

这会降低输入到下一层的输入特征数，从而使得下一层实际能学到特征变多了。

存在的问题：经过若干层的池化，我们损失了 物体的精确位置信息。

这使得利用物体之间的精确空间位置关系来进行识别变得不可行。


LeNet5 模型
Yann LeCun 开发了一个多层卷积神经网络用于手写体识别，如图6:

LENET 
 
 
  图6 


如何评价两个模型的优劣？
McNemar 测试比单纯地比较两个模型的错误率要更加可观。




type
model 1 wrong
model 1 right



model 2 wrong
29
1


model 2 right
11
9959



说明模型2要显著好于模型1。




type
model 1 wrong
model 1 right



model 2 wrong
15
15


model 2 right
25
9949



并不能说明模型2要好于模型1。
Alex’s Net 的诸多设计

Krizhevsky, Alex, Ilya Sutskever, and Geoffrey E. Hinton. “Imagenet classification with deep convolutional neural networks.” Advances in neural information processing systems. 2012.


7层隐含层（不包括池化层）。
前面5层是卷积层，后面2层是全连接层。
激活函数使用的是ReLU函数。
归一化层用以抑制近邻神经元的强激活值。
随机裁切和水平镜像以扩大训练数据集。
丢弃层（Dropout）随机丢弃一半权重以防止过拟合。
双GPU（GTX 580）矩阵运算。


 
 
  图7 



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

政府贷款扭曲生产(第一篇)
　　政府拿钱出来”扶持”企业，有时和政府征敛民财一样可怕。扶持的形式通常是政府直接贷款，以及对私人贷款提供政府担保。 
　　政府信贷的问题往往是很复杂的，因为它涉及到通货膨胀的可能J陛。对于通货膨胀造成的各种影响，我们留待后面的章节再去分析。在这里，为了简单起见，我们假设所讨论的政府信贷不引起通货膨胀。我们以后会进一步讨论，通货膨胀虽然会使问题的分析过程复杂化，但不会从根本上改变这里讨论的政府信贷政策的后果。 
　　在美国，国会中最常见的政府信贷提案是增加对农民的贷款。在大多数国会议员的眼中，农民根本得不到足够的贷款，私人抵押贷款公司、保险公司或乡村银行提供的贷款从来谈不上“充足”。不管有多少的贷款机构就是国会刺激建立起来的，国会总是能不断挖掘出现有的贷款机构还没有满足的新缺口。农民可能获得的长期贷款和短期贷款已经够多了，而议员们又发现，”中期”贷款还不够多，或者利率太高，或者抱怨私人贷款只贷给了家道殷实及有可靠经验的农民。于是，这个立法机关中关于设立面向农民的新贷款机构和新贷款类别的提案层出不穷。 
　　不难发现，有两类短视行为导致人们对这些政策充满信任。一类是只从借钱的农民的立场来考虑问题，另一类则是只关心交易的前半部分。 
　　要知道，在诚信的借款人眼里，所有的贷款最终都是要偿还的，所有的信贷都是债务。国会提高信贷额度的提案不过是加重债务负担的提案的代称。要是我们习惯使用第二个名称，而不用第一个名称，那些提案就不会再那么受欢迎。 
　　我们不必在这里讨论私营机构提供给农民的常规贷款，其中包括抵押贷款，让农民用于购买汽车、电冰箱、电视机、拖拉机和其它农用机械的分期付款贷款，以及供农民在收获和销售谷物前用于资金周转的银行贷款。我们这里要讨论的只是政府机构提供给农民的直接贷款，以及由政府担保的贷款。 
　　这些政府贷款往往有两类用途。一类用以帮助农民把谷物囤积下来，暂不上市销售。这是一类特别有害的贷款，让我们留待后面讨论政府实施商品管制问题时再做具体分析。另一类贷款是为农民立业提供资金一一让他们买得起农场本身、或者一部小拖拉机、或者一辆大牵引车、或者所有这些东西。 
　　乍一看，这类政府贷款似乎很有必要。有人会站出来说，这里有个贫困家庭，缺乏谋生手段。让他们靠领取救济金生活是一种冷酷和浪费的解决办法。给他们买座农场、使其自力更生、让他们成为有自尊与自食其力的公民，让他们为国家的GDP尽一份力，并用自己的产出来偿还贷款。要不这里有位农民生活艰难，买不起拖拉机，还在使用原始落后的方式耕种土地。借钱给他买部拖拉机吧，让他提高生产力，他能够靠增产所赚来的钱还本付息。这样一来，既能让他靠劳动致富，又能增加产出，使整个社会更加富有。况且，这类贷款是“自偿性”的贷款，根本不需要政府和纳税人来负担成本。 
　　事实上，这正是私人信贷机构每天都在做的事情。倘若某人想买农场，手头的积蓄只够农场售价的一半或三分之一，储蓄银行或邻居们会以抵押贷款的方式借钱给他凑够买价。倘若某人想买拖拉机，农机公司或金融机构可以允许他首付三分之一的货款，其余的欠款靠产出的增加分期偿还即可。 
　　然而，在私人提供贷款与政府提供贷款之间存在着一个根本性的区别。每个私人放贷者都是在用自己的资金承担风险。(确实，银行家是利用别人委托给他的钱去冒险，但一旦有损失，也必须拿自己的钱去赔付，否则只有破产出局。)当人们拿自己的钱去冒险时，通常会严格审查借款人是否有足够的资产做抵押，审查其经营能力和诚信如何。 
　　倘若政府依照同样严格的标准来经营贷款业务，那政府根本没有必要涉足这一行。为什么要去做私人机构已经在做的事呢?不过，政府一向是以不同的标准来从事经营的。政府之所以涉足贷款业，就是要向那些从私人机构借不到钱的人提供资金。这其实是说，私人放贷者不肯拿自己的钱去冒的风险，政府放贷者却愿意拿别人(纳税人)的钱去冒险。事实上有时这种措施的辩护者也明确地承认政府放贷的坏账率高于民间放贷，但他们坚持认为，此种损失由增加的产出可以弥补，且有盈余，增加的产出来自那些有借有还的人，甚至大部分借了不还的人。 
　　我们若只注意那些拿到政府贷款的生产者，而忽略掉那些由于政府贷款计划而丧失了获得生产资本的人的时候，上述辩护才会显得有些道理。因为，政府真正借出去的并不是钱，而是资本，钱不过是交易的媒介。(前面已经提醒过，我们稍候再谈通货膨胀性信贷扩张而引发的复杂性问题)。政府真正借出去的是农场或拖拉机本身。农场的数目有限，拖拉机的产量也有限(只要不是牺牲其它产品去生产过乘」的拖拉机)，那么政府把农场或拖拉机借给某乙，就没办法再借给某甲。因此，真正的问题在于:到底是甲，还是乙，应该得到农场? 
　　这就要靠比较甲与乙各自的价值，各自对生产的贡献，或者有能力做什么贡献。假设政府不千预，甲会得到农场。当地的银行家和邻居都了解他，对他知根知底。他们希望自己手上的资金得到合理有效的利用。他们知道甲是诚实守信的人，值得在他身上冒险。也许因为勤劳、节俭、有远见，他已经积攒了购买农场所需资金的四分之一，他们借给了他其余的四分之三，这样他就得到这个农场。 
　　有一个奇怪的说法很流行，是所有造钱学派学者(即迷信通货膨胀的经济学者)的主张，说信用是银行赋予某个人的。事实恰恰相反，信用是人已经拥有的东西。一个人有信用，或许是因为他拥有资产折合成现金来计算，其价值大于他想取得的贷款。或许是因为个人品行与信用记录让他获得了信用。他带着本身具备的信用到银行去，银行家才愿意借钱给他。银行家绝不会随随便便地借钱给别人，他需要得到偿还的保证。银行只是把借款人的资产或信用从流动性较低的形式转换成流动性较高的形式而已。有时银行也难免失误，这样一来，不但银行家自己受损失，整个社会也会受损失，因为借款人没能创造出预期的价值，资源被浪费了。 
　　可以看出，具备信用的甲是银行愿意借钱的对象。但抱着施舍心态的政府更关怀乙的处境。缺乏信用的乙没办法从私人放贷者那里取得抵押贷款和其它贷款，他没有储蓄，没有信用记录支持他可以作为一个成功的农民，当时他还可能是靠领救济金生活。提倡扩大政府信用的人争辩说，为什么不借给他足够的钱，让他购买农场、小拖拉机、大牵引车，助其立业，使他成为有价值也有生产效益的社会成员呢? 
　　也许就个别的案例来说，这种愿望能够很好地得到实现。但整体而言，按政府的标准选定的信贷对象，风险显然高于按私人放贷标准选定的信贷对象。投给乙们的贷款越多，损失越大，他们中间失败的比例会高出很多。乙们的效率会比较低，更多的资源会被他们浪费掉。可是，获得政府贷款的人将买到农场和拖拉机，本来可望获得私人贷款的人就反而得不到。乙有了农场，甲就被剥夺了拥有这个农场的机会。甲被排挤出去，可能是因为政府信贷导致的利率提高，或因为农场的价格因之上涨，或因为邻近地区也没有剩余的农场可买了。这样一来，政府信贷所造成的净效果是减少而不是增加了当地所能创造财富，因为可用的实体资本(由实际的农场、拖拉机等构成)没有交给效率更高的、值得信赖的人，而是落到了低效率的借款人手里。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1712 ACboy needs your help
第一道分组背包，虽然自己不会做，但是看了别人的代码后立刻就明白了
#include<iostream>
#include<cstring>
using namespace std;
int a[105][105];
int dp[105];
int main()
{
	int n,m;
	while(cin>>n>>m&&(n&&m))
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				cin>>a[i][j];
			}
		}
		memset(dp,0,sizeof(dp));
		for(int i=1;i<=n;i++)
		{
			for(int j=m;j>=0;j--)
			{
				for(int k=1;k<=j;k++)
				{
					dp[j]=max(dp[j],dp[j-k]+a[i][k]);
				}
			}
		}
		cout<<dp[m]<<endl;
	}
	return 0;
} 


版权声明：本文为博主原创文章，未经博主允许不得转载。

一个池塘里漂浮着一只装有石块的木船，当把石块扔到池塘后，石块下沉，问池塘中的水面高度将如何变化？
今天群里有人抛出一个题目，估计是面试被问到还是笔试遇到了，然后群里砸开锅了。各种答案都有。以A和B答案偏多。


一个池塘里漂浮着一只装有石块的木船，当把石块扔到池塘后，石块下沉，问池塘中的水面高度将如何变化？

A、上升

B、下降

C、不变

D、无法判断 




我认为答案是B，下面是解释，如不正确欢迎拍砖。








石头在船上排出水的体积要大于石头本身的体积，把石头放入水中，水位应该是下降。


当然这里假设的前提条件是石头的密度要大于水的密度。
不排除存在密度小于水的石头（不属于正常世界的事物）。







版权声明：本文为博主原创文章，未经博主允许不得转载。

有假币
题目描述
居然有假币！！！ 
事情是这样的，现在猪肉涨了，但是农民的工资却不见涨啊，没钱怎么买猪肉啊。渊子这就去买猪肉，结果找来的零钱中有假币！！！可惜渊子一不小心把它混进了一堆真币里面去了。现在知道假币的重量比真币的质量要轻。给你一个天平，请用最快的时间把那个可恶的假币找出来。
输入
1≤n≤230,输入0结束程序。
输出
最少要称几次一定能把那个假币找出来。
示例输入

3
12
0

示例输出

1
3

提示
示例1中共有3枚硬币，所以任意取2个放天平上称量一下。 因为假币的重量比较轻。 如果天平不平衡，则较轻的那枚就是假币。 如果天平平衡，则说明这两枚硬币都是真的，而剩下那枚是假币。
#include<stdio.h>
#include<string.h>
#define N 10001
int main()
{
  int n,m,i,j;
  while(~scanf("%d",&n))
  {
    if(n==0)
    break;
    else
    {
     i=1;
     while(n>3)//n<3时都是称一次
     {
       n=n/3;//因为是最少次数，所以直接除3就行了
       i++;
     }
     printf("%d\n",i);
    }
  }
  return 0;
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream 1420 High Speed Trains(容斥原理)

High Speed Trains

Time Limit: 2000/1000MS (Java/Others) Memory Limit: 128000/64000KB (Java/Others)

Submit Statistic Next
 Problem

Problem Description

      The kingdom of Flatland has n cities. Recently the king of Flatland visited Japan and was amazed by high speed trains Shinkansens going all around the country. Therefore he decided to build the system of high
 speed trains in Flatland.
      Each high speed train line will be bidirectional and connect exactly two different cities of Flatland. Although there is actually no need of high speed trains in Flatland, the king ordered that there must be at
 least one high speed train line from each city of Flatland.
      The minister of transportation told the king that there are several train system satisfying his requirements. The king was amazed by the fact and asked the minister to count the number of possible systems.
      Help the minister to calculate the number of train systems.


Input

      The input file contains one integer number n (2 ≤ n ≤ 100)

Output

      Output one integer number — the number of different train systems that can be arranged in Flatland.

Sample Input

4



Sample Output


41

答案 = 所有的情况 - 一个独立的情况 - 两个独立的情况 - .....

D(n) = 2 ^ (n * (n - 1) / 2) - 1 - sum{C(n, k) * dp[n - k] (1 <= k <= n - 1)}





package ds;
/*
 *Author : 2486
 *Memory: 32300 KB		Time: 284 MS
 *Language: Java		Result: Accepted
 *Public:
*/
import java.util.*;
import java.math.*;
import java.io.*;

public class Main{
	static final int MAXN = 100 + 5;
	static final BigInteger Two = new BigInteger("2");
	static BigInteger [][] C = null;
	static BigInteger [] dp = null;
	static void Init(){
		C = new BigInteger[MAXN][MAXN];
		C[0][0] = BigInteger.ONE;
		for(int i = 1;i < MAXN ;i ++){
			C[i][0] = BigInteger.ONE;
			C[i][i] = BigInteger.ONE;
			for(int j = 1;j < i;j ++){
				C[i][j] = C[i - 1][j - 1].add(C[i - 1][j]);
			}
		}
		dp = new BigInteger[MAXN];
		dp[1] = new BigInteger("1");
		dp[2] = new BigInteger("1");
		for(int i = 3;i < MAXN;i ++){
			dp[i] = Two.pow(i * (i - 1) / 2).subtract(BigInteger.ONE);
			for(int k = i - 1;k >= 2;k --){
				dp[i] = dp[i].subtract(dp[k].multiply(C[i][i - k]));
			}
		}
	}
	public static void main(String [] agrv)
	throws IOException
	{
		//System.setIn(new FileInputStream(new File("D:" + File.separator + "imput.txt")));
		Scanner cin = new Scanner(System.in);
		Init();
		while(cin.hasNext()){
			int n = cin.nextInt();
			System.out.println(dp[n]);
		}
	}
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

清华梦的粉碎—写给清华大学的退学申请 /王垠




王垠,四川大学97级本科毕业，保送到清华大学计算机系直博。期间曾在清华大学计算机系软件所就读，主要

进行集成电路布线算法的研究。在此期间，他因《完全用GNU/Linux工作》一文和对TeX的推广等“非研究成果

的业余东西”而出名。 在只剩一年就要博士毕业的时候，他申请退学，并将1万7千余字的“退学申请书”（题为

清华梦的粉碎）公布在网上，引起舆论界一时对教育体制、理想主义等的热议。






　　王垠


　　性别：男


　　喜欢的东西： 番茄蛋汤


　　爱好和兴趣： 计算机，滑板


　　籍贯：四川省眉山


　　2004年左右发表《完全用linux工作》和《写给支持和反对<完全用Linux工作>的人们》的文章，在中国的计算机和linux阵营引起极大轰动效应，成为水木清华linuxapp版和中国多个linux社区的偶像级人物。


　　2005年，王垠为第一作者的论文参加IEEE/ACM Asia and South acific Design Automation Conference (ASP-DAC 2005)国际学术会议中获得Best Paper Award。这是自ASP-DAC会议举办以来大陆论文首次获奖。


　　查看《完全用linux工作》文章：http://news.163.com/05/0926/14/1UJ76MKO0001126S.html


　　附录：“清华梦的粉碎”


　　清华梦的粉碎—写给清华大学的退学申请 2005.9.22


　　清华梦的诞生


　　小时候，妈妈给我一个梦。她指着一个大哥哥的照片对我说，这是爸爸的学生，他考上了清华 大学，他是我们中学的骄傲。长大后，你也要进入清华大学读书，为我们家争光。我不知道清华是什么样子，但是我知道爱迪生和牛顿的故事。清华，大概就是可以把我造就成他们这种人的地方吧。我幼小的脑海里就想象出我能在清华做的事情……我的脸上浮现出笑容。我说我要实现这个“清华梦”。这就是清华梦的诞生。


　　小小科学家


　　我相信每个人在小时候都跟我差不多，对这个世界充满了好奇。


　　鲁迅有他的百草园，我也有我自己的"实验田"。如果说小时候的鲁迅是一个艺术家，那么小
 时候的我就是一个科学家。这么说可能有人要说我口气太大，张口闭口就是这家那家。然而在我的字典里，"艺术家"和"科学家"并不是什么了不起的人，它们只 是贴在人内心的一个标签。如果一个小孩专注于内心对世界的感觉，那么他就是一个艺术家。而我不是。我的大部分兴趣是在了解世界是怎样运转，甚至不惜代价。也许大部分男孩子都是这样。


　　我小时候住在父母执教的中学里。两间平房，门口有一小块地，妈妈在里面种了一些菜。我们一家三口虽然穷，但是过着宁静舒适的生活。我们在这个地方一直住到上初中的时候。这些房屋记录着一个年幼的科学家的探索和实验，直到它们被夷为平地。


　　妈妈拒绝让我养猫狗，她说凡是会拉屎的都不养---除了我。所以我小时候就喜欢与蚂蚁作伴。我总是试图用各种各样的办法去了解蚂蚁的生活习性。我可以一整天的观察我家屋檐下的蚂蚁来来去去。看见他们用触须碰一碰，然后各自分头走开，我就会想 它们到底说了什么。我在想，能不能用一种方法解开蚂蚁语言的密码。我从书中得知蚂蚁洞里有蚁后，她有很大的肚子。为了一睹芳容，我开始试图水漫金山，把水往蚂蚁洞里灌。我有时一个下午就干这种事情，却没有一次成功看到蚁后。后来才知道蚂蚁是如此精明的下水道工程师，水大部分都渗到地底下去了。可是我不甘
 心，我开始试用别的办法。比如在洞口放一块糖。可是蚁后架子太大，终究不肯出来，让别人帮她送饭进去。


　　有人说，这个世界最后不是毁在疯子手上，就是毁在科学家手上。世界上如果只有科学家是很 可怕的，比如他们会发明高效的杀人武器。我发现疏松的棉絮可以迅速的燃烧，就想出一种惨绝蚁寰的大屠杀实验。我先把糖水滴在地上，等蚂蚁把那个地方围个水泄不通的时候，铺上棉花，点火……现在想起那些勤劳的小黑头都变成灰烬，我仍然心惊肉跳。他们的灵魂会来找我报复吗？后来这个实验有一个升级的版本用的是浸泡过一种化学药品溶液的纸，文火燃烧，由于燃烧速度慢，杀伤力不大，这个实验可以测试蚂蚁的逃跑路线。我还用活蚂蚁进行过心理实验。首先用破袜子摩擦塑
 料尺产生静电，然后放在一只正在行走的蚂蚁身后不远处。蚂蚁走不动了，我就开始推测它在想什么，它感觉到什么。它可能会觉得有外星人？但是由于尺子拿开以后，它若无其事继续走，我猜它只是有点纳闷，而不惊慌。但是反反复复几次之后，它明显有罢工的意思，似乎忘了自己要去干什么。后来我又发现蚂蚁被吸到塑料 尺上之后会由于带上相同的电荷而被"发射"出去，就像人间大炮一样。注："人间大炮"是日本电视剧《恐龙特急克塞号》里的一种可以把人当作炮弹发射的威力很大的电磁装置。


　　一点微小的发现，就可以引发大量的探索和实验。这就是我在那个年代的特点。虽然妈妈也逼 着我练习书法，绘画，还多次获奖，但我不喜欢这些东西。我似乎生下来就是科学家，不是搞艺术的，不过也许只是妈妈的强迫让我反感了艺术而已。物理是我最喜欢的，因为它让我了解到世界的奥秘。我一般开学前几天就会把物理书上的实验都挑出来，费尽辛苦找到材料实践一番，心里美滋滋的。上学真是快乐！


　　失之交臂


　　上了高中，由于课业的压力，我的生活逐渐改变了。为了考上清华大学，我努力的学习。抛下 我的毛笔，抛下我用来做实验的蚂蚁，电池和线圈，抛下除了考试科目的一切。在老师眼里我是一个听话的好学生，在妈妈眼里我是一个听话的好孩子。每天早上按时起床，吃一大碗妈妈做的面（为了补充一上午学习需要的体力），然后冲进教室，按照预设的程序开始读书，做练习题。似乎一切都有条不紊，顺利进行。可 是……


　　忽然有一天我发现，我的一切活动都是在纸上进行的，看书，做习题。试卷和复习书让我变得 变得麻木。我想这样下去我就不再像爱迪生和牛顿了。于是我开始调皮起来。我不但要做考试的题目，还要做更难的题目。做了物理奥林匹克的题目，接着就想看大学的物理书，接着就想恢复我小时候的实验的爱好。老师辅导自习时经常被我缠住问一些不着边际的问题，那其实是我在实验中发现的问题。终于有一天，在我要求 他跟我合作制造一个磁悬浮陀螺的时候，他显示出了不耐烦：“王垠，你让我先回答别的同学的问题好不好？你的问题对考试没有好处。”
 我呆住了，启发我让我爱上物理的人，尽然对我说出这样的话。后来想一想，他也是无奈啊，不过我从此再也不想问他任何“超纲”的问题。


　　高二的时候妈妈就拿回一份前一届的高考题让我做，我随手一做就得了一个当时可以考上清华 的成绩。我的心里想，清华我来了。明年的这个时候，我就会拿到录取通知书了！从此我就不再把高考放在眼里。我开始钻研越来越难的题目，进行越来越离谱的实验。我想，清华里面应该都是我这样的学生吧，我会有很多志同道合的朋友，不用再跟这群只会做题的呆子在一起了。


　　可是我的行为总是受到老师的压制，他们要把我们变成考试的机器。他们告诉我，沉下心来做 习题，考试才能有把握。妈妈也帮着老师劝导我。看，一班的某某某这次模拟考试数学成绩比你高，多努力一下吧。我哪里听得进去，我才不在乎这点分数，我能解决更难的问题，老师都没法解决的问题。我开始有了逆反心理，开始早上懒床，装病请假不去上课。班主任，校长多次找我谈话，说我要沉下心来准备考试云云。但 是我根本就听不进去，我鄙视高考，觉得他们没有资格出题来考我。然后我就有了心理疾病，大概是强迫症。高考语文的时候我居然怀疑监考老师认为自己在作弊，接着好像真的怕被抓住了一样，手发抖，头冒汗。然后我又想要是考不好，以前的优秀会不会也被人怀疑？他们会不会以为我以前的成绩全都是作弊得来的？手就抖
 得更厉害了。这时候，监考老师可能发现了我的情况，真的走了过来，站在我身后。害得我好几分钟不敢写一个字，因为手已经完全不听使唤。不过他还是走开了，这可怕的高考终于结束了。


　　我们是考试前填的志愿，我根本不考虑其他学校就只填了清华。后来妈妈研究了一下，帮我添 了一个天津大学在第二志愿。以下的志愿全部空白。大家觉得我真够大胆，可是我的心理状态让我发挥完全失常，比清华的最低分数线还差两分。特别是语文，才
 96分。天津大学第一志愿收满不要我。昔日的好学生，居然到了落榜的下场。我真的那么好吗？我问自己。我太骄傲，才落到如此地步吧。我开始怀疑自己是否应该那样瞧不起高考。看着爸爸的愁眉苦脸，妈妈的唠唠叨叨，真是生不如死。复读吗？那会是噩梦的继续。我不能再在这个学校待下去。再面对题海，我的心理疾病 会让我自杀的。碰巧四川大学来招收高分落榜的学生，还给了我随便选择专业的机会。妈妈说，计算机现在很火热，出来好找工作。我虽然对工作不感兴趣，但是我比较喜欢写程序，于是就进了川大计算机系。


　　两度退学失败


　　不能不说进川大是个没有选择中的好选择。大学生活自由一些，我至少不会走上自杀的道路。可是我的毛病仍然在继续，我永远不满足学校里能学到的那么点东西。老师基本是照本宣科，我逐渐不再满足这种知识灌输式的教育。我觉得完全没必要上这个大学。


　　川大的环境我实在无法忍受。军训的时候受够了同学和教官的委屈，我就想退学。我们的军训 是在一个戒备森严的炮兵基地里，心里的苦向谁说啊！有一天我们正在路上齐步走的时候，我忽然看到一个女人挽着一个军官走了过来。那个军官的老婆怎么长的这么像我妈妈！要是妈妈来到我身边该多好！没想到回到营地，团长（原来是连长，我们来军训他就升一级做团长了）说有人来探访。我走过去，居然发现是妈妈！因 为听说我想退学，她急忙向学校打听了军训的地点，几经周折跑过来，是那个军官带着她混进来的。我想我妈妈要是转行当间谍一定是个好料子。她说已经帮我办了退学，学校同意了，回去好好复习，准备考上清华……
 “好好复习，好好复习”……我的脑海里又浮现出高三的情景，这次我要跟一群更没用的复读的人在一起。脑子一阵疼痛之后，我说：“妈妈，我不想退学了。”


　　可是军训回到学校，发现宿舍如此差劲，我又想退学。妈妈又来帮我办理手续，可是结果我还 是由于懦弱反悔了。害得学校办事的老师都骂我：“你这个人简直神经病！” 对啊，我确实是有病，不过我的是精神病，不是神经病。我恨我的高中，我恨我的大学，我恨高考，我恨中国的教育！是你们让我生病的。可是妈妈，她为了我已经费尽了辛苦。我不能再这样周折下去。我自己在学校里好好努力，准备考上清华的研究生吧。


　　学校住宿环境很差劲，又经过好多麻烦事，我终于决定在校外去租房子住。后来我开始玩滑板，它让我变得勇敢。我心里逐渐平静下来，可以用心看书了。大二以后，我的学习生活才逐渐进入正常，自信开始恢复。


　　梦的复苏


　　记得川大教Pascal语言的老师第一堂课就对我们说：“我们学校就是落后啊。外面公司 里都用C, C++了，我们还在教Pascal。你们以后要出去工作恐怕还是得学学VC什么的。”
 于是有的同学开始抱起一本本像“XXX圣经”之类的书开始学习，上数学课也在看这些东西。我当时自愧不如啊。自己就是小学的时候玩过一下学习机，可以说没 有任何计算机基础。辅导员也经常夸他们几个动手能力强，以后公司就需要这样的人。他们出口就是Bill Gates, 世界首富云云。军训的时候听着他们说什么DOS, 温95，我就只有张着嘴崇拜的份了。才想起我高中计算机竞赛的时候一道有关DOS命令的题没有做出来，现在听他们说才知道原来DOS是个“操作系统"。那操作系统又是什么，他们说每个电脑上都必须有一个操作系统……我真是愧不如人
 -_-!


　　正在我决定鼓起勇气后来跟上，准备拿起一本DOS大全从头啃起的时候，一次偶然的机会我接触到了Linux。后来又因为The Art of Computer Programming，接触到了Knuth。我才发现，课堂上讲的那些东西原来如此低级，有些东西学了就过时，学它干吗？我并不比别人落后多少。我一再的思考，什么是计算机科学？是什么让我们计算机系的人不同于其他系的。我有时候认为有了答案，但是后来答案又被我自己推翻。在思想的混乱中，我发现我逐渐
 摆脱了旁人的标准。我不再想像别人那样去考计算机等级考试，对微软的认证也不屑一顾。我自己学会了Linux，还会很多种当时别人听都没听说过的计算机语 言。我学会了LaTeX，还因为找出Knuth书里的错误得到两张支票和一些礼物。这并不是什么值得炫耀的，但是这给我对计算机的兴趣很大鼓舞，我从此更
 加认真的看书。上课要不就逃掉，背地里拿着大部头的“龙书”之类的原版英语书啃。要不就看我打印出来的GNU的一些资料，完全不听老师讲。期末划重点的时 候也不去，考试却总能考个八九十分。总有几个女生排名在我上面，不过我不在乎这点分数，考试和分数不再能评价我。同学们大概都觉得我是一个怪人，后来毕业了我才听他们说，他们管我叫“怪才”。我如此努力的学习着，对别的事情充耳不闻。我只有一个目的，就是毕业就离开这个鬼地方，进入清华大学上研究生。虽然大家不理解我在干什么，清华的老师应该挺在乎我学的东西吧。


　　我有点不高兴了。一个人说你的选择是错误的，你的反应是什么呢？反正我当时为我的“清华梦”作了一番辩护，说我进去自己好好研究，应该还是能够很好的，毕竟这是我从小的梦啊。可是没想到，他说的居然是对的，我现在开始感谢他了。


　　计算几何，创造力的复苏


　　清华还是一样的上课方式，大部分课也是很多人一起上，一起打瞌睡。老师也是照本宣科，我 居然发现他们其实跟川大的老师没什么区别。清华的不同之处就是，一到考试的时候原来进行的一切娱乐活动都不见了人影。原本每天晚上都有人一起玩轮滑，考试的时候就只剩下我孤零零的一个人。因为大家都怕考试，开始熬夜复习了。还有就是上课不容易逃课了，有些老师会突然点名，缺席会严重影响最后的成绩。


　　对于博士生，传说还有一个规定，那就是后10%淘汰。也就是说，不管你成绩如何，如果成绩排名在课程的后10%，那么就要重修。而如果两门功课重修，就会被开除。面对如此残酷的规定，很多同学都惶惶不可终日。我就是在隔壁同学的唠叨声中度过了第一期。不过我还是没有把考试当回事，所以我也没有去验证这个说法的官方真实性。我仍然不去听老师划重点，我仍然不觉得老师出的题目有什么好，我仍然讨
 厌有人让我们用手算矩阵。可能觉得太残酷，还是觉得要是开除了博士生谁来干活，这条规定后来改成了如果博士生上了80分就可以不重修。我也不知道为什么我 觉得考砸的科目也上的了80，故意放我过去的吗？


　　但是我的生命中出现了这样一门课程。它改变了我对老师的看法，让我觉得上课原来也可以如 此有趣。这就是计算几何。上课的人很少，只有十来个人。因为听说这门课很难，很多同学都没有选。但是我就是那种知难而进的人。老师上课的方式跟别的课程很不一样，大家坐在一个小教室里，老师有精美的幻灯片，有动画，不时还插入一段大科学家，大哲学家的名言。上课时老师会停下来很多次让学生提问题，下课大家 都积极踊跃的讨论新奇的问题。课程的评分方法也很特别，平时成绩占到30%的分量，作业分为几种分值，可以自己选择做不做，作业的总分数乘以30%，加上最后大作业的分数乘以70%，就是最后的得分。说真的，这门课太有趣了，我就只逃过一次课。但是还是有时候人数不到一半，因为其他课程压力太大，有人都去复习别的课程了。但是邓老师从来不点名，还对逃课的同学表示同情。还问我们在座的有没有其他课特别紧张的，下次课可以不来。真是让人感动。


　　我就是在这门课上认识了王益，我们亲密无间的合作，让我领略到了什么叫做研究。大作业的 时候我们在一个小组，其实是三人一组，但是那第三个人其实什么也没干。我和王益决定写一个3D的Voronoi图扫描算法演示程序。王益的3D图形编程能
 力很强，所以他做界面，由我负责算法生成数据作为后端。我们分别在自己的机器上编写程序，不时的打电话讨论接口的设计问题。我找到了Bell labs 的 Steven Fortune 的算法程序，决定看懂它，然后改造成演示需要的分部运行的算法。但是 Fortune 的程序几乎没有注释，而且使用了一种奇怪的数据结构，很难理解。Fortune
 还在程序里说到，这个算法虽然有效，但是对于程序员来说是一个挑战。所以我email请他给我一份算法论文的拷贝，他同意了。但是一个月之后，信才到我手里，那时我们已经完成了作业。因为我花了一个星期看懂了他的程序，还换掉了他的麻烦又低效的数据结构。随后成功的把后端与王益的前端设计好接口联合。等我 看到 Fortune 的论文，发现程序里面其实已经改进了论文的核心内容。其中的parabolic transformation其实完全没有必要实现。我深深体会到实践的重要性，也许先有了他的论文我反而会被误导，写不出实际可以运行的程序。


　　由于我们的团结努力，老师对我们的大作业非常满意，他给了我们最高的分数 100。由于我们两个都在课下超额完成作业，所以总的分数我们两个都是满分。这是我阔别已久的100分。只有在小学我才拿到过这种分数啊！对于一个对考试 成绩满不在乎的人，100 又意味着什么？如果是别的课程我会毫不在乎，就像我得了80分一样。可是这个100分是我们团结研究而来的，它包含了对我们的合作意识，对我们的友谊，对我们的热情的肯定。虽然我觉得我们的东西还有改进的余地，但是我接受这个100分！也只有这样的课程，我才可能得100分。


　　从此我感觉到了什么叫做研究。这跟我小时候干的那些事情没有什么两样。你在身边发现一个 问题，想知道为什么。然后你就想去获得解决这个问题的知识。你去看书，你去问专家，你上网去搜索。如果没有发现答案，那么好啦，你就可以自己试图去发现为什么，这是最有趣的部分。知道了为什么，就想让这个东西有用处，对人们的生活产生好处。这就是研究。


　　《完全用Linux工作》与TeX的推广


　　这么说来我还是对清华有些好感。遇到一个好老师让我从呆头呆脑的技术工人的状态恢复过 来，开始追求自己的梦想。可是第一年把所有的课程上完之后，我就发现原来清华所谓的“研究”是如此混沌。其实清华大部分人进行的所谓的“研究”是什么呢？ 其实就是写作，不是科学研究。这一点以后我会详细叙述。


　　远远看去外观华丽的有着先进的工作站的实验室，却没有可以安心看书的地方。机器挨着机器 人挨着人，书都没地方放。师兄师姐们都在忙着用word写论文，不时有两个人隔着几行机器大声谈话。实验室通风不好，还有一个大型工作站在嗡嗡作响，我进 去一会儿就觉得头晕，所以后来就不想去了。PC机以前都是公用的，每次都会用不同的机器，却没有我想用的软件，麻烦死了。好不容易实验室买了新机器分配给
 个人，装上一个 Linux 系统开始写程序，还在Sun工作站上安装了多达1G的GNU程序。却被一个师兄嘲笑说那种跟DOS一样落后的东西你居然也用。于是我写了一篇文章叫做《完 全用Linux工作》，放在主页上驳斥这种观点。矫枉过正，确实写的优点偏激，结果引起网上linux界轩然大波。后来我又发现几乎全校的论文都是 word排版的，那些公式质量太差，看起来头痛，才发现很多学生害怕数学的原因之一。所以又写了文章宣传 TeX，希望中国产生更多漂亮的数学书。这下子我出名了，真没想到，出名不是因为我的研究成果，而是因为这些业余的东西。我起初不希望我因此出名，但是看到旁边的人都用上了
 TeX，我觉得我还是做了一件好事，至少让论文看起来漂亮了一些。


　　可是论文的内容，却是我永远的痛！


　　培养计划


　　我在第一年就把功课全部上完了。本来我想多选几门课，比如法语，可是清华的博士要选课需 要提交一个“培养计划”给导师签字。导师同意之后才能修改。导师看到我选了法语，就说这个第二外语还是自己学学就行了吧，旁听也行啊，我主要是怕你课太多了考试不通过就麻烦了。我当时没有说什么，就把法语去掉了，只留下刚够学分的课程。其实我还想选很多的，体育，音乐什么的，都不好意思跟导师说。后来才知 道宿舍对门的硕士生选了钢琴课他们导师都不管。为什么我们就受到如此待遇？


　　可是没有把法语加到培养计划却成了我的遗憾。有一个新学期我去旁听了第一节法语课之后老 师就说，我知道很多同学是来旁听的，这样教室里人太多了，效果不好。这对自己对大家都不好，下次请旁听的同学不要来了。我脸皮薄，下次就没有去了。后来自己想自学却又没有老师教，看了十集reflet之后就此作罢。


　　后来我终于明白了，清华不需要全面发展的博士生，而其实导师还会在某种程度上削弱学生的 能力。导师并不是真的为我们好，而是不喜欢我们上课，因为上课不但会花掉研究（或者干活）的时间，而且让他们眼界太开阔，这样学生会很容易有别的选择而走掉。所有的活动：助教，实习，都必须有导师签字。而大部分导师就会找借口不让学生干这些事情。不给他们助教和实习的机会，让他们以后不好找工作，只能为自 己服务，或者为自己的熟人服务。甚至这次我去西藏，要办边境证都要有导师签字。办事的老师说，没有导师签字，你跑出去了不回来怎么办？大妈，我跑那种地方干吗？


　　除了这些，还有两大法宝就是博士学位和违约金。清华的博士学位有多值钱知道吗？不知道？ 那么博士退学要交几万块钱的违约金，这下大部分穷苦学生怕了吧。这就是你们的卖身契。清华就是这样把研究生牢牢地控制在自己的掌握之下。我对一个如此害怕学生跑掉的不自信的学校还能说些什么？如果你是好样的，就不会害怕我们跑掉！该跑掉的最后终究会跑掉。


　　我的自我培养


　　在学习上，我永远是个吃不饱的人。选不了课，我就去旁听。旁听后觉得老师讲的不好，我就 自学。在我有空的时候，我就会去图书馆借书看。在我本科的时候，我就已经发现自己的一个特点，我会很快发现新的东西，并且学会使用它。虽然这些东西并不是创新，但是它们丰富了我的技能，让我有更大的能力去进行创新。我经常顺藤摸瓜似的从一个问题搜索出一大串我想知道的东西。然后借一大堆书回来，每本看一点 点，只为找到我需要的答案。


　　计算几何课的一次作业，我为了写一个算法的演示程序，花了3天时间学了一点Java语 言，正好能够完成那个程序。我开始接触到TeX的底层细节，看完了The TeXbook，并且找出一道练习题答案的错误。开始移植gbkfonts程序，作为我的CWEB语言的练习。看完了几乎所有 Xlib 的手册，了解了 XWindow 的工作原理。我接触到 Scheme，并且做完了 SICP 的大部分习题，还自己想出好多问题用Scheme实现算法。后来花了好几个晚上，把MIT课程6.001的录像下载回来。我才发现教授上课可以如此搞笑有
 趣，上课时戴上巫师的帽子，做一些滑稽的表演。我终于明白，有的计算机科学家居然可以去好莱坞演电影 :) 这个课程让我领会到 LISP 的强大，改变了多年以来对这种古老语言的误解。它让我感觉到在看似纷繁复杂，不断更新的计算机语言的世界，还有那么一种永恒的美！接着我又学会了
 Common LISP，并且开始用它来设计研究计算几何的一个函数库。另外还找了一些希奇古怪的程序来玩，写了一些心得体会放在网上给别人看。


　　我意识到自己数学还不够强，甚至有些怕，就开始看一些数学方面的书。Concrete Mathemtatics, What is Mathematics?, Science and Hypothesis, Godel Escher Bach, ... 虽然每一本都没有看完，但是我逐渐相信自己的数学能力，发现数学原来如此有趣，并不是做习题那么枯燥，也不像一辈子就拼命证明一个定理那么清高。才发现国内很多数学书用难看的符号把学生吓倒了，其实想通了就是很直观的原理。


　　我看了电影 A Beautiful Mind 之后深受感动，就去买了一本原著的书，它是数学天才John Nash的传记。它描写了20世纪初的Princeton，一群科学家生活的情景。我眼前浮现出在一个房间里，一群人在喝茶聊天下棋讨论问题激烈争论。我 发现我从小内心向往的，就是那样的地方。我看到Nash是如何用“头脑暴力”解决一个他没有任何基础知识的问题。原来只要有了问题和探索的精神，就会有动力去获得解决它所需要的知识，最后将问题解决。发现有用的，重要的问题，而不只是寻找困难的问题，这样才会对人类有价值，才会有动力。我还看到一个真正的
 数学天才是怎样的喜欢恶作剧，又怎样因为过度的傲慢狂妄，想向世人证明自己的天才而发疯。我发现世界上有远比科学更宝贵的东西。我开始悔悟我高中时对待成绩不好的同学的态度。我不是一个天才，但是我要做一个好人。


　　但是我的研究却没有多少进展，至少我自己这么认为。我发现问题的根源，就是没有真正的讨论，没有真正的问题。


　　我们也有讨论，原来是这个样子


　　上完课，就该开始搞研究啦。可是研究什么呢？老师给我几篇论文看，意思是让我看看有没有什么想法。


　　我开始感觉没有头绪，就跟导师说能不能找师兄师姐跟我讨论讨论，还有别的人在做这个吗？ 他说，就你一个人做这个，每个人做一个题目，独立思考，这就是研究。我觉得是啊，我应该独立思考。可是过了一段时间发现不行啊，我想实现一个想法，但是我不知道是不是已经有人试过失败了。实验的时间开销会比较多，所以我想知道那么多厉害的人，为什么都不用这种明摆在那的方法？当我再次提出需要讨论的时候， 他似乎有点生气的说：”你为什么总是想有人跟你做一样的东西啊？你不是想抄袭别人的论文吧？”
 我不发话了。继续做我的实验，结果确实不理想。虽然自己实践很重要，可是要是能利用别人的经验，何乐而不为呢？这并不是偷懒。如果有人讨论，很多时候一个人提出一个问题，另外的人可能就会告诉他这个问题是不是有人做过，有什么重要性，凭直觉告诉他有什么难度。可是如果没有讨论，连问问“有没有人做过”的机 会都没有！


　　后来我就经常上网看看国外的大学怎么搞研究，发现他们都有 seminar，讨论组。A Beautiful Mind 描述的 Princeton 以前的天才们每天都在一个地方喝茶，讨论问题，争得面红耳赤，回家分头思考，做实验，第二天喝茶时再讨论。那就是我从小梦寐以求的生活啊！计算几何课已经让我爱上了与人合作和讨论的方式，现在却孤零零一个人了。我必须告诉导师，合作和讨论是非常重要的。在我据理陈述之后，他说：“好吧。反正师兄师姐各自有自己的事，你要讨论什么就跟我和你副导师讨论吧。”
 于是我就开始了跟他们两个星期一次的见面讨论。每次讨论都感觉他们不知道我在说什么，他们心里想的都只是这个能比别人的好多少呢？能不能投到这个会议呢？如此宏观。我觉得跟他们讨论完全是浪费时间。


　　后来课题逐渐有了新的同学加入，导师决定跟中科院数学所的人一起申请一个项目来研究。于 是我们每两个星期去中科院讨论。不过感觉他们那边也差不多。中科院的老师觉得他们的研究太理论，期望我们能给他们带去一点实际的东西。可是我们也没有什么实际的东西，所有的问题都是从别人的paper里看到的。副导师就开始跟他们说这个问题有多么多么重要…… 他们也借此机会开始研究以前放下的一些问题。总之讨论的感觉就是没有目的，没有主题。有时有人说他在想一个什么问题，说了一会儿就被否决了。有时候就是一个人看了一篇paper之后做一个感想。我坐在那里就在想，我们到底在干什么？我们甚至都不知道什么东西值得研究，还研究什么？后来师弟师妹们就开始考虑把问题变一变，看看能不能产生新的问题。他们的做法，我跟他们开玩笑说就是“有问题也要解决；没有问题，制造问题也要解决！”
 他们笑着点点头，“本来就是这样嘛。没办法啊。”


　　博士生论坛的时候，同学们都觉得有类似的问题，讨论不足，交流不足。所以我提议成立一个 类似国外大学的 Common Room，用来讨论问题。可是大部分老师说：“这样一个房间，天天都要有那么多人在里面待着。谁来出这个钱？” 是啊，老师自己的办公室都要钱，哪里可能有什么 Common Room？就算有了 Common Room，在里面讨论的无非还是文章发到哪里的问题。制度决定了行为，我的设想太理想化了。


　　分析一下，为什么老师不提倡讨论呢？因为问题是有限的。老师辛辛苦苦这么多年搞来搞去都 在搞这些问题，分配给你们每人一个，互不冲突。要是两个人都搞一个问题，这下好了。出了成果论文归谁？学校要求必须第一作者才算论文数。要是两个人都写论文，那么投到同一个会议肯定有一个要被reject。这样对集体发展不利嘛，大家不就是发几篇论文混毕业吗？何苦？


　　paper, paper, 还是paper


　　说到paper我就痛心。我的方向上我至今还没有看到几篇我觉得像样的文章。我主要进行集成电路布线算法的研究。看起来高深，其实是很简单的问题，一个平面上有一些点是电路里的电极，现在需要用铜线把它们连起来，怎么样让连线的长度或者时延 最短？这个问题跟几何上一个有名的问题 Steiner tree 问题有关系。我的导师就是以前写了一篇这样的paper发到IEEE transactions。


　　已经毕业的一个师兄就在他研究的基础上修改来修改去，发了好几篇paper。英文的不够还翻译成中文，投到国内的期刊。后来一个师姐又在这个师兄的基础上进行修改，又发了好多篇。可是在我看来，他们的论文纯粹就是炒冷饭，没有什么创新。一个 问题解决了，那么解决问题的人显示了他们的聪明，至于这个问题对人有什么用，他可以暂时不管（虽然我也严重反对这种做法）。后来又有人来搞这个问题，多半是被老师分配来的。他也小修改一下，修改想法其实不费工夫，主要是你怎样把你的
 Introduction 写好？可以让别人觉得你的工作有意义？这就是功夫。作家的功夫。我有一次面见INRIA的头目 Jean-Claude Paul 时，他就对我说：“Tsinghua students are all writers, not scientists.”


　　现在清华研究生做的事情无非就是，写好paper，然后找个地方投出去。SCI 的最好，EI的其次。偏僻的没人看的杂志也没关系，交钱也没关系。我就知道日本的一个SCI索引的期刊收1000美元的版面费。导师出钱，不投白不投，投了好毕业呵！


　　现在我也被“分配”来做这个问题。虽然说是一个有名的问题，但是这个有名的问题已经被研究了好几十年了。有很多挺厉害的人做出了很重要的贡献，但是我们为什么研究这个问题？我至今没有搞懂。


　　开头导师只是给了我两篇paper，据说是以前他一个得意门生写的，美国某大学的副教授。其中有一篇说是如何在不构造
 Delaunay triangulation的情况下生成 MST （最小生成树）。看到这篇文章开头说在 rectilinear metric下, Delaunay triangulation 就不能用来构造 MST 了，所以他设计了一个新的算法。这个算法比起 Leo Guibas 的算法更加简单。文章里还提到一次 Matroid，让初出茅庐的我觉得高深莫测。我还专门去借了一本《Matroid Theory》来看，其实他的论文剩下的部分跟Matroid没有任何关系。可是我对“Delaunay triangulation
 不能用来构造 RMST” 这个说法产生了怀疑。经过理论分析我觉得即使在 rectilinear metric下，Delaunay triangulation 也可以用来构造 MST 的。我觉得作者只是故意这么写，想为他设计算法的动机找一个借口。我决定实践我的想法，写一个程序从Delaunay triangulation 构造出一个 RMST。这本身不是什么创新的工作，可是我却在想，这样一个东西能不能用来构造 Steiner tree 呢？后来我真的就想出一个办法。实验表明我的算法比以前的算法要快几倍。


　　这是不是说我的算法是一个值得写paper的东西呢？导师说我应该写一篇，但是我认为我只是在挑别人的毛病时意外想出了一个改进的算法，并不会对将来的研究有什么启发。虽然程序快了一些，但是很少有那么大的线网需要这么快的算法，而且几倍的 提高在我眼里不算是一个理论上的改进，而且这个算法不能推广到其他距离空间，可扩展性很低。所以我内心觉得这个结果不令我兴奋，不想写论文。但是在老师的一再要求下，我居然把这个研究写成了两篇paper。按照他的说法：“应该分阶段总结你的成果。”
 起初投出去的时候评委总是说这个东西不实用，导师说这是评委的问题，他们觉得不实用我们就投到理论一点的会议。经过几次投稿，还是失败了。我终于忍不住了，对副导师说出我的想法，我说：“看一个作家的水平，是看他扔在垃圾筐里的纸。就让我把这篇paper永远藏在我的垃圾筐里吧。” 但是他不甘心，说你要相信自己的实力，然后把我的算法胡乱夸奖了一番。我说我不管了，随便你怎么办。我就开始研究我自己喜欢的东西去了。之后他居然真的投中一个欧洲的会议，是被
 LNCS 收录的，LNCS 是 SCI 索引的，所以我居然有了一篇 SCI 文章！我自己不喜欢的文章也是 SCI 了！


　　第二篇论文就更传奇了。几投不中，就其原因，评委说是没有和现在“最先进”的算法程序实 验比较。而我没有比较的程序，就是那个让我觉得发paper动机不纯的人的程序。没办法，求他给我代码。比了一下，确实比他快。不过我估计他程序写的有毛病，老是 core dump。而且从实验数据来看，运行时间增长的速度不符合他论文里声称的时间复杂度。但是没办法，他只给 binary，也不给源代码。程序快几倍，很有可能是实现上的问题，而不是算法更好。我的一个师兄以前就把他自己的算法戏称为“基于bug的优化”。我觉得这样比较对那个算法的作者不公平，完全没有发表的价值了。但是没办法，谁叫我们都是出来混的，没有人在乎这些。我还是记录下数据，添到论文上。一投就
 中，得了一个最佳论文奖。然后就有一篇校内新闻宣传：“我校王垠同学获得XXX会议最佳论文奖。这是大陆学者首次在如此高级别的会议上获得如此高的奖项。 ” 这个“高级别”的会议，在我看来就是个垃圾。美国人都把最差的论文投到这里，就是为了来旅游一圈而已。


　　我对自己的做法产生了深深的负罪感，觉得自己正在进入这团混沌，正在被同化。我决定换一 个题目研究。我就开始考虑zero skew tree. 找了20多篇paper来看，发现他们没有什么本质的改进。而且对于问题本身的价值，他们完全就不清楚。有的作者后来甚至说，其实以前他们考虑的问题是没有必要解决的，因为实际应用中不可能遇到，我们其实可以把问题变成这样……本来一句话就可以说清楚的事情，又写成了好几篇paper。我就是这样在 paper的海洋中，找不到目标。


　　我见过的这种低级别的会议，低质量的论文几乎都是从 IEEE 那里出来的。道理很简单，IEEE 会议多，会议论文集都像两大块砖头，还是双列小字排版，当然能容纳下这么多的垃圾了。所以我对 IEEE 也没有好感。


　　火山小规模爆发


　　第一篇投中了会议之后，副导师很高兴的说“代替我去开会”，到希腊Santorini岛玩了一圈。回来还跟我说希腊不好玩，好苦啊，幸好你没去。然后就继续要我为算法申请一个专利。


　　写这个论文我都已经焦头烂额了，一点都不感兴趣。现在还要写专利，“要像教小学生做这件事一样，一步一步的把算法写清楚，举出实例”。我觉得快不行了，再这样折腾下去，我到博士毕业也许也就只搞出这些小儿科东西吧！我终于小规模爆发了一次。我坦荡的告诉了副导师我的想法，我觉得做学问应该是什么样，我觉得这么点东西不值得申请专利。我还告诉他我对国内的研究环境很失望。


　　他慌了，可能以为我想要退学，赶忙找我谈谈。对我说，我知道你心中有很大抱负。所以这次 就不写专利了。我知道你想有更好的研究环境，但是不踏踏实实做好现在的工作，又怎么能有大的创造呢？然后就开始举爱因斯坦，居里夫人的例子……
 然后说，其实你在这里好好努力，将来出国的机会多的是，你想去Harvard也行，你想去Princeton，都行啊！


　　你说行就行？你去去给我看看？我们实验室从来就没有去这些地方的。继续这样做下去，以后哪个真正的科学家还会要我？


　　全面发展


　　在对清华的研究完全失望了之后。我就准备考GRE，TOEFL出国了。我去上了一个新东 方的班，没学到什么英语方面的东西，倒是接触了很多新的思想。老罗的言论特别有趣，虽然我不是完全赞同他的意见。写GRE作文特别培养思维能力。我为了写 GRE作文，常常为了一个不明白的问题到图书馆翻阅英文的哲学书籍，有关教育的书籍…… 对于很多问题我得到了完全不同的观点。大学的目的是什么？人的价值观是由理性决定的吗？等等等等。我读到了亚里士多德，柏拉图，康德等人的言论。甚至有个哲学家说
 "All Animals Are Equal". 我看了他的文章觉得有很多可以批驳的观点。我看到迪卡尔的文章，说“要掌握科学就要掌握它的全部”，这句话真合我心意，我就是想做一个懂很多东西的人啊。我想结合艺术与科学。虽然我这个观点得到一些人的批判，但是我仍然相信迪卡尔。


　　从这些互相矛盾的观点中，我有了自己的判断力。我开始能够揭开从小蒙在我眼睛上的有色眼 镜看问题。我开始检查我自己的思维，我以前的观点。看看它们是否是未经判断就盲目放进去的。我检查到很多很多的错误。我的待人接物，我对他人的理解上，都有不足之处。我还检查到妈妈传递给我的一些有色眼镜，小学课本给我们的有色眼镜。我开始学会用自己新的方式对待他人，看待事物。我不再盲目相信权威，哪怕 他是诺贝尔奖得主，图灵奖得主。我有了自己的自由思维。


　　在那段时间，我感觉我的心智大门被开启了。我开始尝试从来没有做过的事情，以及从来不认为我能做好的事情。我一次又一次的相信我能。我能学会画画，我能打好太极拳，我能理解古典音乐……
 世界还有那么多美好的事情等着我去学习去开发啊！


　　可是，我们却像囚犯一样被判了5年在清华。博士学位就是我们的枷锁。


　　醒悟，paper的奥秘


　　清华研究生谈论的重点是什么？是 paper。吃饭的时候谈，喝茶的时候谈，睡觉的时候也谈。隔壁的同学在进校第一年就为paper惶惶不可终日，说：“你知道吗，他们要求我们发SCI， 怎么办呢？我几个师兄都是因为没有paper延期毕业的。” 这恰好就是那个为后10%淘汰惶惶不可终日的同学。他的老师是个院士，可是他在手下就干一些写word文档之类的杂活还忙得要命，根本没有时间思考问题。


　　后来听说学校有规定，博士生必须发4篇paper才能毕业，其中必须有一篇是SCI索 引，或者两篇EI索引。看上去冠冕堂皇的SCI, EI，不就是跟 google 差不多的东西吗？被它索引了怎么样了？特别是对文章的篇数作要求，而对质量没有判断。我其实读了两年都还不知道学校是这样规定毕业标准的。当我知道的时候，已经有人告诉我SCI=Silly Chinese Index。真是让人啼笑皆非。


　　学校没有能力评价学生的水平，就拿文章数来衡量。这样的毕业标准造就的是怎样的学生，怎 样的实验室呢？难道导师真的没有能力判断paper的好坏吗？有些是，但是有些不是。即使他知道你的论文没什么价值，也会叫你发表。我发现paper数量 的背后，是某些人的如意算盘。想一想是怎么回事吧。国家看什么来拨款研究？看paper。看什么来评价一个学校的水平，也是paper。国家没有能力评价 你的能力，当然只有看你有多少paper。所以有了paper就有了钱。只要你能写paper，培不培养你，你将来的发展，关我们什么相干？你写的
 paper别人能不能看懂，能不能转化成生产力，管我们什么相干？怪不得有的院士想尽办法也要多收学生，宁愿自己帮学生出学费也要他进来。因为学生就是财源。paper可以带来基金，可以在美国买小车洋房，没有基金就让学生干活吧。一个月几百块钱吊着一条命在那里为你拼命，谁叫他们想要那个博士学位呢！


　　该清醒了，博士无产阶级！


　　告别清华的博士学位


　　现在我已经厌烦了国内所谓的“学术”。我准备放弃清华的博士学位，出国找个好老师，进行真正的研究。博士第4年了，做出这样的决定真是不容易。有人告诉我不要放弃，你知道有多少人正在羡慕你？你知道一个清华的博士学位有多么值钱吗？但是我不能这么沉默下去了！


　　博士学位，累坏了多少年轻的中国人！我不再为它浪费我的青春。我知道国外大部分研究也不 是那么好，如果国外也找不到好的老师，我就永远离开学术界，找一个简单的工作，和我心爱的人一起生活。有人说这是浪费人才？在清华混沌的过日子才是浪费呢！当一个侍者至少也让我感到对社会有贡献，看着顾客满意，我会露出笑容。可是做一个博士却没有。我感觉自己是个没用的人。


　　我已经完全看透了中国教育的失败。我高中的时候就受到它的伤害，这种伤害延续到现在。中国教育已经成为埋没人才的祸首。留在这个圈子里就是屈服，我不出声，大家都不出声，这个世界就会继续这样郁闷的运转下去。我今天要对这个系统大声地说一声“不！”


　　我离开了。可是中国永远也不缺少为清华拼命的人！因为他们的妈妈会告诉他们，清华是全中国最好的学校。你要考上清华，为我们光宗耀祖……


　　行动


　　2005年9月22日下午3点，我在东主楼导师的办公室里跟导师和副导师再次重申了我的 想法。包括以上的一切，和我准备退学，准备10月份考托福的打算。导师经过一番举例爱因斯坦，居里夫人，叫我踏踏实实的说教无效之后，严厉的批评了我只顾 自己，不顾及教研组为我付出的心血。然后说：“要是你不能再为实验室作研究，我们就不能支持你了，前两个月实验室发的钱我收回。你可以马上写退学申请，我 们实验室没有什么损失，我们有的是人干你的事情。不过我要告诉你，你一旦退学，连学校的住宿都要被收回！”


　　接着是副导师尖声的咆哮：“是啊，你瞧不起我们。我们是没有你聪明，可是我们勤勤恳恳……你知道你得的那个best paper award，我们付出了多少努力吗？你认为这么容易拿到吗？那是多少国外专家鉴定……”


　　我安静的等他说完。真像是一场闹剧，一场梦。他平息下来之后，我说了一声“再见”，然后默默地走出了办公室。


　　你们要退学申请？这里就是我的退学申请。


　　尾声


　　晚上收到副导师的email说：“还有一件事需要向你说一下：你在学校学习期间所取得的成绩包含你的努力、导师的指导帮助、同学们的帮助，还有学校和国家的支持。你作为博士生学习阶段取得的成果属于教研组、学校和国家。正如同我们作为职务发明的专利属于学校一样。


　　你在MST、SMT等方面取得了结果，它属于教研组、学校和国家。单位有责任进行合理的应用，为国家建设、国家荣誉服务。有责任进行进一步的整理丰富、向高水平的刊物投送。这里我们想说明一下上述的情况，同时，也告诉你一下：你若愿意将这些 成果进行进一步的整理、我们已经给你提出了具体的修改意见，欢迎你按照进行修改。你若放弃，我们将进行具体的改进、投递。我们将尊重你的意见。谢谢。”


　　最后还是没有忘了paper的剩余价值。进一步验证了我的判断，他们在乎我吗？不。他们只在乎paper。至于我流离失所，又有何相干？我不知道有多少无知的弟弟妹妹又会把他们的研究建立在我不屑一顾的paper之上。


　　后记：我写本文的目的


　　Repair what you can — but when you must fail, fail noisily and as soon as possible. —Basics of The UNIX Philosophy


　　修复你能修好的—但是如果你必须失败，那就尽快喧闹的退出。—UNIX基本哲学


　　我不是一个中国教育操作系统下优良的程序。我在系统里运行了将近20年，快到最后的时候才喧闹的退出，Dump出这么大一个core file。我知道有的程序很早就退出了，我自愧不如他们。但是有的程序一声不响就退出了，还有很多的程序成为了zombie，永远的驻留在系统中成了系统 的负担，在这一点上我又比他们好一些。至少我让程序员有机会用调试器检查core文件，调查这个程序运行中哪里出了问题。


　　“你退学就退学，干吗大惊小怪，牢骚满腹的？” 如果只是有牢骚，我就把隔壁同学拉过来一起发发牢骚就完事了。可是我虽然不是优秀的程序，我觉得应该为修复这个系统，修复自己做点什么。我希望国家的教育和研究环境好起来，这样大家就安心的生活，不用出国搞得奔波流离。有多少恋人由于一个人出国了而痛苦的分手，有多少父母在盼望海外游子的归来？我不能像很 多人那样申请了国外的学校，拍拍屁股就走人。我一年前就考GRE想出国，可是我总是自欺欺人的幻想国内的境况会好起来，有时我觉得看到希望，可是马上希望
 又破灭了。一个个大师来了，让我一次次燃起希望，可是发现他们对环境的作用也不大。一些大师不满意，又走了。我自己也想尽力改造环境，结果经过多次努力无效，自认能力不够，终于放弃了。


　　在发现大家都忙着发表paper而没有讨论时，我曾经建议设立一个清华的THU-Technical Report。我的想法是：最差的草稿扔在垃圾堆里；可能有用但是还不值得向所有人公开的东西发到THU-TR，供系内查阅；如果发现THU-TR的东西 会有用，再好好修改了转投会议或者期刊。系学术助理王磊很高兴的采纳了我的建议，并且自愿维护一个THU-TR的编号。可是根本没有人愿意把自己好不容易
 写出来的但是确实又不值得发表的东西投到这里，因为世界上总有地方可以把这个东西投出去，还是SCI和EI，而这个THU-TR连正式刊物都不算。后来有人告诉我，如果学生都把东西投到我们这里，不知道有多少导师会跟我们急。所以THU-TR的计划就这么告罢。


　　我一年前写信给Knuth，这个我相信是真正的大师。我说我想退学，想请他推荐一些真正的研究者给我做老师。他回信说“你先找精通中国文化 的长者谈谈”。我意识到他可能觉得这是一个文化的问题。我于是想知道中国的科技为什么搞不好，就开始看一些有关文化的东西。后来居然跑到中国社会科学院去听新竹清华大学人文学院的院长讲座，后来又在清华参加了人文学院的研讨会。会上一个老师说的好，当一个制度没法衡量学术水平本身，它就会用一个似乎等价的
 标准，比如paper数或者高考分数。但是一旦这个标准被确立，人们就会向着这个标准努力，而不是向学术水平本身。他们总会发现制度的很多问题，找出破绽，去达到这个标准，而不是提高自己的学术水平。最后，这个标准已经完全不能反映水平本身。我就在想，这个问题大了，这不仅是环境，制度，而且还是长久以 来的文化造成的。从新竹清华大学院长的讲座里，我发现英国人是怎样用科学技术打开了中国的大门，而乾隆皇帝是如何对科学不感兴趣。中国似乎从古到今就不重视科学技术的，中国有自己的优势，自己的文化。对啊，科学技术是个双刃剑，如果照美国那样发展下去也不知道会怎么样。我们中国的文化是瑰宝，但是它已经被
 外国的坚船大炮打得遍体鳞伤。这不是我们的错，但是我们要努力恢复自己的文化，不能总是怨天尤人。我就开始看道德经之类的东西，还去西麓学社参加古代文化讨论活动，后来又开始打太极拳。


　　我觉得再没有从实际出发的目标，我的研究就会完全变成纸张了，就像我高中感觉到的一样。所以后来我就自己设立了一个研究方向，我把自己称为“研 究博士生”，我要去了解博士生都是怎么样生活的。我就想知道有多少学生有跟我类似的困境。我跟很多朋友谈过，去了解他们的苦衷，研究生也有，本科的也有。我觉得我还应该了解更多的人，就试图到研究生通讯社做记者，心想挂一个记者证，就好跟人套磁问一些问题了。结果他们说我口才不好，所以做了一个秘书。后来 记者们告诉我，他们是由上级分配任务的，根本不可能让你去报道学生真正的想法。我为了多多接触外国文化，比较中西文化的不同，又加入了学生对外交流协会
 (ASIC)，我在ASIC有了很多好朋友。博士生论坛的时候也有很多同学跟我反映研究上的问题。讨论成立特别兴趣小组（SIGs）的时候，我就提议成立 一个Common Room，一个同学说她去 Stanford 的时候那里就有很好的 Common Room，很多人在一起讨论，这是国外大学斯通见惯的东西。我告诉Oxford的朋友我的想法，他很惊奇地说：“你们居然没有
 Common Room？” 后来吃饭时我又找一些老师谈话，发现他们也对这个事情无可奈何。老师自己的办公室都要自己出钱，谁还能支持你们有这么大一个房间？而且即使有了房间，谁来讨论？还不就是拿着别人的paper，试图找点可以改进的地方，或者就讨论哪个会议好发paper。Common Room只是一个形式，只要有人感兴趣，随便找个茶馆也能讨论。问题就在于没有人有精力有心情进行真正的讨论，制度决定一切。我们无能为力。我觉得自己一个学生力量太小，曾经试图找大师帮忙。我找到Andy Yao，述说我的苦衷。结果他对我说：“别试图去改造环境！你没有这个能力，连我都没有！改造好你自己就不错了。"
 改造好我自己，可是怎么改？所以我决定先换一个环境，到一个真正搞研究的地方去体会，去学习。


　　其实我不后悔进入川大，不后悔来到清华，珍惜一切的历史，因为没有它们，我也许就不是现在的我，有着自己想法的我。我也许就在安逸的生活中变得堕落。它们不完美甚至给我痛苦，但是我还是珍惜，珍惜这里的朋友，这里的一草一木。也许这就叫做爱。我会变得更好，我会挂念我的满目苍夷的祖国母亲。 我会回来告诉你我学到的一切，我会给你和其他儿女真正的幸福，一定的！




转自：http://blog.csdn.net/e6894853/article/details/7881102

版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream 1216 Beautiful People(二维上升子序列 O(nlogn))

Beautiful People

Special Judge Time Limit: 2000/1000MS (Java/Others) Memory Limit: 128000/64000KB
 (Java/Others)

Submit Statistic Next
 Problem

Problem Description

      The most prestigious sports club in one city has exactly N members. Each of its members is strong and beautiful. More precisely, i-th member of this club (members being numbered by the time they entered the
 club) has strength Si and beauty Bi. Since this is a very prestigious club, its members are very rich and therefore extraordinary people, so they often extremely hate each other. Strictly speaking, i-th member of the club Mr X hates j-th member of the club
 Mr Y if Si <= Sj and Bi >= Bj or if Si >= Sj and Bi <= Bj (if both properties of Mr X are greater then corresponding properties of Mr Y, he doesn't even notice him, on the other hand, if both of his properties are less, he respects Mr Y very much).
      To celebrate a new 2003 year, the administration of the club is planning to organize a party. However they are afraid that if two people who hate each other would simultaneouly attend the party, after a drink
 or two they would start a fight. So no two people who hate each other should be invited. On the other hand, to keep the club prestige at the apropriate level, administration wants to invite as many people as possible.
      Being the only one among administration who is not afraid of touching a computer, you are to write a program which would find out whom to invite to the party.


Input

      The first line of the input file contains integer N — the number of members of the club. (2 ≤ N ≤ 100 000). Next N lines contain two numbers each — Si and
 Bi respectively (1 ≤ Si, Bi ≤
 109).

Output

      On the first line of the output file print the maximum number of the people that can be invited to the party. On the second line output N integers — numbers of members to be invited in arbitrary order. If several solutions exist, output any one.

Sample Input

4
1 1
1 2
2 1
2 2


Sample Output

2
1 4
思考：不可以等于的时候，第一个升序，第二个降序，可以相等的时候，两个都是升序。(请自我思考，非常简单)
C++:


#include <map>
#include <set>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <vector>
#include <queue>
#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <algorithm>
using namespace std;


#define pb push_back
#define mp make_pair
#define fillchar(a, x) memset(a, x, sizeof(a))
#define copy(a, b) memcpy(a, b, sizeof(a))
#define S_queue<P> priority_queue<P, vector<P>,greater<P> >


typedef long long LL;
typedef pair<int, int > PII;
typedef unsigned long long uLL;
template<typename T>
void print(T* p, T* q, string Gap = " ") {
    int d = p < q ? 1 : -1;
    while(p != q) {
        cout << *p;
        p += d;
        if(p != q) cout << Gap;
    }
    cout << endl;
}
template<typename T>
void print(const T &a, string bes = "") {
    int len = bes.length();
    if(len >= 2)cout << bes[0] << a << bes[1] << endl;
    else cout << a << endl;
}

const int INF = 0x3f3f3f3f;
const int MAXM = 1e5;
const int MAXN = 1e5 + 5;
int n, dp[MAXN], ID[MAXN];
int Z[MAXN];

struct rect{
    int l, r, id;
    bool operator < (const rect & object) const{
        if(l == object.l) return r > object.r;
        return l < object.l;
    }
}rs[MAXN];

int main(){
    while(cin >> n){
        for(int i = 1;i <= n;i ++){
            cin >>rs[i].l >> rs[i].r;
            rs[i].id = i;
        }
        sort(rs + 1, rs + n + 1);
        fillchar(dp, 0x3f);
        fillchar(ID, 0);
        int ans = 0;
        for(int i = 1;i <= n;i ++){
            int tmp = lower_bound(dp + 1, dp + n + 1, rs[i].r) - dp ;
                dp[tmp] = rs[i].r;
                ID[i] = tmp;
                ans = max(ans, tmp);
        }
        cout << ans << endl;
        for(int i = n;i > 0;i --){
            if(ID[i] == ans){
                cout << rs[i].id;
                if(ans != 1) cout << " ";
                ans --;
            }
        }
        cout << endl;
    }
    return 0;
}

java:


import java.util.*;
import java.math.*;
import java.io.*;

public class Main{
	static final int MAXN = 100000 + 5;
	static int [] dp = new int[MAXN];
	static int [] ID = new int[MAXN];
	static final int INF = 0x3f3f3f3f;
	static class point implements Comparable<point> {
		public int l, r, id;
		@Override
		public int compareTo(point o) {
			// TODO Auto-generated method stub
			if (this.l == o.l) return o.r - this.r;
			return this.l - o.l;
		}
	}
	static point [] rs = new point[MAXN];
	public static int BS(int l, int r, int x){
		while(r >= l){
			int mid = (r + l) >> 1;
			if(dp[mid] == x) return mid;
			else if(dp[mid] > x) r = mid - 1;
			else l = mid + 1;
		}
		return l;
	}
	public static void main(String [] agrv)
	throws IOException
	{
		//System.setIn(new FileInputStream(new File("D:" + File.separator + "imput.txt")));
		Scanner cin = new Scanner(System.in);
		while(cin.hasNext()){
			int n = cin.nextInt();
			for(int i = 1;i <= n;i ++){
				point s = new point();
				s.l = cin.nextInt();
				s.r = cin.nextInt();
				s.id = i;
				rs[i] = s;
			}
			Arrays.fill(dp, INF);
			Arrays.sort(rs, 1, n + 1);
			int ans = 0,len = 1;
			for(int i = 1;i <= n;i ++){
				int tmp = BS(1, len, rs[i].r);
				if(tmp == len){
					len ++;
				}
				dp[tmp] = rs[i].r;
				ID[i] = tmp;
				ans = Math.max(tmp, ans);
			}
			System.out.println(ans);
			for(int i = n;i > 0;i --){
				if(ID[i] == ans){
					System.out.print(rs[i].id);
					if(ans != 1) System.out.print(" ");
					ans --;
				}
			}
			System.out.println();
		}
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

leetcode:Basic Calculator II
Basic Calculator II 
Implement a basic calculator to evaluate a simple expression string.The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.You may assume that the given expression is always valid.
Some examples: 
“3+2*2” = 7 
” 3/2 ” = 1 
” 3+5 / 2 ” = 5 
C++代码
int calculate(string s) {
    int sum = 0; 
    if(s.size() < 1) return sum; 
    int i = 0; 
    int last = 0, last_result = 1;  
    char last_operator = '+'; //Remember the last operator
    int sign = 1; 
    while(i <= s.size()){
        if(s[i] == ' '){++i; continue;}
        if(s[i] == '+' || s[i] == '-' || !s[i]){ //Check the end of the string
            sum += last_result * sign;
            sign = s[i++] == '+' ? 1 : -1; 
            last_result = 1;
            last_operator = '+'; 
        }
        else if(s[i] == '/' || s[i] == '*'){
            last_operator = s[i];
            ++i; 
        }
        if(isdigit(s[i])){
            last = 0; 
            while(i < s.size() && isdigit(s[i])){
                last =  last * 10 + s[i++] - '0'; 
            }

            if(last_operator == '*') last_result *= last;
            else if(last_operator == '/') last_result /= last;
            else  last_result = last; 
        }
    }
    return sum; 
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

棋盘覆盖问题
/*
Author: Tanky Woo
Blog:   www.WuTianQi.com
棋盘覆盖问题
分治法
2010-12-3
*/
#include <iostream>
using namespace std;
const int N = 11;
int Board[N][N];
int tile = 0;
 
/*
tr:棋盘左上角方格的行号
tc:棋盘左上角方格的列号
dr:特殊方格所在的行号
dc:特殊方格所在的列号
size:方形棋盘的边长
*/
void ChessBoard(int tr, int tc, int dr, int dc, int size)
{
    if(size == 1)
        return;
    int t = ++tile, s = size/2;
 
    //覆盖左上角子棋盘
    if(dr<tr+s && dc<tc+s)
        //特殊方格在此棋盘中
        ChessBoard(tr, tc, dr, dc, s);
    else   // 此棋盘无特殊方格
    {
        // 用t号L型骨型牌覆盖右下角
        Board[tr+s-1][tc+s-1] = t;
        // 覆盖其余方格
        ChessBoard(tr, tc, tr+s-1, tc+s-1, s);
    }
 
    //覆盖右上角子棋盘
    if(dr<tr+s && dc>=tc+s)
        ChessBoard(tr, tc+s, dr, dc, s);
    else
    {
        Board[tr+s-1][tc+s] = t;
        ChessBoard(tr, tc+s, tr+s-1, tc+s, s);
    }
 
    //覆盖左下角子棋盘
    if(dr>=tr+s && dc<tc+s)
        ChessBoard(tr+s, tc, dr, dc, s);
    else
    {
        Board[tr+s][tc+s-1] = t;
        ChessBoard(tr+s, tc, tr+s, tc+s-1, s);
    }
 
    //覆盖右下角子棋盘
    if(dr>=tr+s && dc>=tc+s)
        ChessBoard(tr+s, tc+s, dr, dc, s);
    else
    {
        Board[tr+s][tc+s] = t;
        ChessBoard(tr+s, tc+s, tr+s, tc+s, s);
    }
}
 
void DisplayBoard(int size)
{
    for(int i=1; i<=size; ++i)
    {
        for(int j=1; j<=size; ++j)
            printf("%2d ", Board[i][j]);
        printf("\n");
    }
}
 
int main()
{
    ChessBoard(1, 1, 1, 2, 4);
    DisplayBoard(4);
    return 0;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ 2622 [2012国家集训队测试]深入虎穴 SPFA
题意:链接
方法: SPFA
解析:
这题写深搜是作死，别问我为什么。
深搜过程您大概会RE8个点- -!
复杂度类似O(nm)？
其实总体东西就是个SPFA，不过这里面我们需要做一些改动。
这只老虎是DP老虎，他每次会占据你的最优方案。
所以使得你只能用次优方案来更新最优方案以及次优方案。
这就是SPFA的路子。
但是这个路子并不够。
让我们考虑一个点只有一个儿子的时候。
他可能会扫一圈后第一次让他的儿子更新一次答案。
这时候是有最短路而并没次短路的。
但是您肯定会更新一下它的儿子信息。
这时候儿子又会来更新这个点。
那么如果按照咱们的模拟过程，此时儿子就会更新次短距离以及最短距离。
但是显然，这个点是没有次短距离的。
所以如果给这个点更新了次短距离，那么这个点再向上走就会影响答案。
所以这种情况要避免。
具体怎么避免？
就是记录上一次它是被谁更新的，如果下次是同一点，那么就不更新次短距离。
复杂度就是SPFA复杂度了，可以接受。
代码:
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 100100
#define M 1000010
using namespace std;
int n,m,k,cnt;
int vip[N];
int head[N];
int v[N];
int val[N];
int dis[N];
int sec_dis[N];
int pre[N];
struct node
{
    int from,to,val,next;
}edge[M<<1];
void init()
{
    memset(dis,0x3f,sizeof(dis));
    memset(sec_dis,0x3f,sizeof(sec_dis));
    memset(head,-1,sizeof(head));
    cnt=1;
}
void edgeadd(int from,int to,int val)
{
    edge[cnt].from=from,edge[cnt].to=to,edge[cnt].val=val;
    edge[cnt].next=head[from];
    head[from]=cnt++;
}
void bfs()
{
    queue<int>q;
    for(int i=1;i<=k;i++)
    {
        int x;
        scanf("%d",&x);x++;
        dis[x]=sec_dis[x]=0;
        q.push(x);

        v[x]=1;
    }
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        v[u]=0;
        for(int i=head[u];i!=-1;i=edge[i].next)
        {
            int to=edge[i].to;
            if(sec_dis[u]+edge[i].val<=dis[to])
            {   
                if(pre[to]!=u) 
                    sec_dis[to]=dis[to];
                dis[to]=sec_dis[u]+edge[i].val;
                pre[to]=u;
                if(!v[to])
                {
                    q.push(to);
                    v[to]=1;
                }           
            }else if(sec_dis[u]+edge[i].val<sec_dis[to])
            {
                sec_dis[to]=sec_dis[u]+edge[i].val;
                if(!v[to])
                {
                    q.push(to);
                    v[to]=1;
                }
            }
        }
    }
}
int main()
{
    init();
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        x++,y++;
        edgeadd(x,y,z);
        edgeadd(y,x,z);
    }
    bfs();
    printf("%d\n",sec_dis[1]);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

轻松python文本专题-字符串逐字符反转以及逐单词反转
场景：
字符串逐字符反转以及逐单词反转

首先来看字符串逐字符反转，由于python提供了非常有用的切片，所以只需要一句就可以搞定了
>>> a='abc edf degd'
>>> a[::-1]
'dged fde cba'
>>> 
然后我们来看住单词反转
1.同样的我们也可以使用切片
>>> a='abc edf degd'
>>> a.split ()[::-1]
['degd', 'edf', 'abc']
2.可以使用原生方法reverse
>>> a='abc edf degd'
>>> result=a.split()
>>> result
['abc', 'edf', 'degd']
>>> result.reverse()
>>> result
['degd', 'edf', 'abc']
>>> result=' '.join (result)
>>> result
'degd edf abc'
>>> 
在反转的过程中，我意外发现join的另外使用方法
>>> a='abcd'
>>> ' '.join (a)
'a b c d'
>>> a='abc edf degd'
>>> ' '.join (a)
'a b c   e d f   d e g d'
>>> 
它可以快速的再每个字符中间加上我们赋值的字符
>>> '+'.join (a)
'a+b+c+ +e+d+f+ +d+e+g+d'
>>> 
综上所有，还是使用切片的方法最好，最推荐使用





就说到这里，谢谢大家


------------------------------------------------------------------

点击跳转零基础学python-目录



版权声明：本文为博主原创文章，未经博主允许不得转载。

Eclipse for github插件安装、使用图解（egit）
一、注册
github官网地址：https://github.com/ 

二、安装
软件安装地址：http://download.eclipse.org/egit/updates 
安装步骤如下： 
 
 
 
 

三、配置
 
 

四、提交到本地仓库
 
 
 
 
 
 

五、提交到远程git仓库
1.到github官网去创建远程仓库（记住仓库地址） 
2.将代码提交到远程仓库 
 
 
 
 
 
 
 
 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

一个23岁大学生的Raspberry Pi开源项目

对大多数人来说，谷歌阅读器的关闭是件苦恼的事，但对大学生雅各布·库克（Jacob Cook）而言，却是个一展抱负的机会。他自主开发了一个名为“ ARKOS”的操作系统，声称可以取代谷歌或者其他云公司提供的所有服务，包括运行电子邮件、聊天、文件共享、虚拟主机等基本服务，它通过一个信用卡大小的私人服务器来实现。

ARKOS是一个基于Linux的服务器操作系统，可在小巧的Raspberry Pi硬件上运行（将来有望在BeagleBoard开发板甚至全尺寸PC上运行）。如图所示，Raspberry Pi顶部是开放源码应用Genesis，它提供一个Web操作界面来控制服务器运行，Genesis应用里的所有文件在
 GitHub上也可使用，用户可以自行下载安装使用。但目前ARKOS还是个前期项目，暂时不建议在重要的项目中使用。


（小巧的Raspberry Pi 硬件）

一个23岁大学生的开源项目 谷歌要竖中指了

目前市面上也有类似的产品，例如PogoPlug，但是PogoPlug 只能管理自己的文件，不能提供一套全面的互联网服务，如聊天、网站托管、电子邮件等等。而ARKOS可以提供这些服务，在可定制的安全级别内允许控制其他任何资源。再如比较有名的Tails，它也是基于Linux版本的操作系统，但是它只能提供一个桌面操作环境，而ARKOS是个服务器。不过，如果在ARKOS上托管数据，然后通过其他电脑的Tails系统来访问，就是个完美的组合。


（Jacob Cook）

一个23岁大学生的开源项目 谷歌要竖中指了

该项目的开发者库克是一个23岁的大学生，他表示，谷歌在网页方面的服务功能的确是很强大，但是他们的表现越来越令人担忧，今年早些时候，谷歌关闭阅读器，这意味着，在没有足够利益可图的情况下，没有什么功能服务是神圣不可侵犯的，我们太过依赖别人提供服务了。事实上，谷歌服务也不是长期可靠的，一旦他们感到没什么商业利益，随时可能关闭任何应用或者下架任何产品。另外，“棱镜门”事件也是库克的ArkOS项目一个很大的推动力，如果NSA可以随意从谷歌，微软，脸谱，AOL（美国在线），推特上任意抓取数据，用户无异于在网上“裸奔”，还有谁可以相信。显然，库克选择了相信自己。

不过，ARKOS有潜在的局限性，大多数家庭互联网服务商会优化他们的服务提高下载速度，所以用户只要在家里安心看视频就好了。但是ARKOS如果托管一个大型的媒体库，在室外访问时，就会比较慢。库克尝试通过远程托管来运行arkOS数据中心，由此实现相同的Web界面操作，让用户可以由自行控制。

库克对计算机安全十分感兴趣，ARKOS是他做为Linux黑客和IT管理员的经验尝试。他承认自己没有足够深厚的加密知识，但是他的初衷并不是建立一个新的加密系统，所以这个问题并不大。他还邀请了其他爱好者来进行这个开发项目，但显然，他是灵魂人物。

也许他还只是一个年轻的码农，但 Linus Torvalds（林纳斯·托瓦兹，当今世界最著名的电脑程序员）曾经也只是一个孤独的编码者。

版权声明：本文为博主原创文章，未经博主允许不得转载。

循环赛日程表问题
#include<stdio.h>
#include<math.h>

void gametable(int k)
{       
    int a[100][100];
    int n,temp,i,j,p,t;
    n=2;//k=0两个参赛选手日程可以直接求得
    a[1][1]=1;a[1][2]=2;
    a[2][1]=2;a[2][2]=1;
    for(t=1;t<k;t++)//迭代处理，依次处理2^n....2^k个选手的比赛日程
    {
        temp=n;n=n*2;//填左下角元素
        for(i=temp+1;i<=n;i++)
            for(j=1;j<=temp;j++)
                a[i][j]=a[i-temp][j]+temp;//左下角和左上角元素的对应关系
        for(i=1;i<=temp;i++)//将左下角元素抄到右上角
            for(j=temp+1;j<=n;j++)
                a[i][j]=a[i+temp][(j+temp)%n];
        for(i=temp+1;i<=n;i++)//将左上角元素抄到右下角
            for(j=temp+1;j<=n;j++)
                a[i][j]=a[i-temp][j-temp];
     
    }
    printf("参赛人数为:%d\n(第i行第j列表示和第i个选手在第j天比赛的选手序号)\n",n);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            printf("%d ",a[i][j]);
                if(j==n)
                printf("\n");
        
        }
}

void main()
{
    int k;
    printf("比赛选手个数为n(n=2^k)，请输入参数K(K>0):\n");
    scanf("%d",&k);
    if(k!=0)
    gametable(k);
    
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

LeetCode：solution of shell problems
LeetCode problems下的shell题目(截止发文日期，共有4个shell problem)主要是考察对文本处理命令的熟练程度、具体应用，也涉及到正则表达式的一些知识。
1.Tenth Line

Description: How would you print just the 10th line of a file? For example, assume that file.txt has the following content.Your script should output the tenth line, which is:Line 10

Line 1 
  Line 2 
  Line 3 
  Line 4 
  Line 5 
  Line 6 
  Line 7 
  Line 8 
  Line 9 
  Line 10

Analysis: 就题目本身来说，首先需要考虑文本文件少于10行的情况，然后才是考虑文件中有不少于10行的数据如何输出数据。主要考察怎么得到文本的行数，和输出指定行数的内容。
Solution: [ `cat file.txt|wc -l` -ge 10 ] && sed -n ‘10p’ file.txt

2.Valid Phone Numbers

Description: Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers. 
You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit) 
You may also assume each line in the text file must not contain leading or trailing white spaces. 
For example, assume that file.txt has the following content:

987-123-4567 
  123 456 7890 
  (123) 456-7890

Your script should output the following valid phone numbers: 

987-123-4567 
  (123) 456-7890

Analysis: 此题就是考察正则表达式的应用，利用grep命令获取匹配正则表达式的行。当然也可以使用sed,awk命令。
Solution:  sed -nr '/^(\\([0-9]{3}\\) |[0-9]{3}-)[0-9]{3}-[0-9]{4}$/p' file.txt

3.Transpose File

Description: Given a text file file.txt, transpose its content. 
You may assume that each row has the same number of columns and each field is separated by the ’ ’ character. 
For example, if file.txt has the following content: 

name age 
  alice 21 
  ryan 30

Output the following: 

name alice ryan 
  age 21 30

Analysis: 题目表达得很明确，我们把输入抽象为一个矩阵模型，简单来说就是求其转置矩阵。在这种需求下，我选用awk工具来实现。awk处理文本的能力十分强大，一方面它支持文本的字段处理，另一方面用户还能利用内建变量、函数和自定义函数来编程实现相应的文本操作。
Solution: awk -F' ' ' 
{{for(i=1;i<=NF;i=i+1){array[NR,i]=$i}}}  
END{ 
for(i=1;i<=NF;i++){ 
for(j=1;j<=NR;j++){ 
printf("%s",array[j,i]); 
if(j<NR){printf(" ")} 
}; 
printf("\n") 
} 
}' file.txt

4.Word Frequency

Description: Write a bash script to calculate the frequency of each word in a text file words.txt. 
For simplicity sake, you may assume: 
words.txt contains only lowercase characters and space ’ ’ characters. 
Each word must consist of lowercase characters only. 
Words are separated by one or more whitespace characters. 
For example, assume that words.txt has the following content:

the day is sunny the the 
  the sunny is is

Your script should output the following, sorted by descending frequency: 

the 4 
  is 3 
  sunny 2 
  day 1

Analysis: 很自然地想到先将句子拆分为一个个单词，然后再执行统计操作。所以我们先要使用awk工具来做文本的字段处理；为了让uniq命令能够统计所有行中的单词，先用sort命令将输出排序（这里不用sort命令，uniq统计的结果是针对每一行的，具体原因我也不清楚，望知道的看官评论或私信告知一下，THX！）；接着按要求再用一次sort命令按词频降序排列；最后用awk命令来格式化一下输出，满足题目的格式要求。
Solution: awk -F' ' '{for(i=1;i<=NF;i=i+1){print $i}}' words.txt |sort|uniq -c|sort -nr|awk -F' ' '{printf("%s %s\n",$2,$1)}'

5.总结
这几个题目主要还是考察linux文本处理命令的使用和正则表达式的基础知识。我给出的题目解答不一定是最优的，仅供参考，有更优解答的各位看官，可以评论留言或者私信交流。:)

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        股票都去哪儿了

门前老树长新芽  半月之前六年最
院里枯木又开花  今天又是八年最
半生存了好多话  半生存的一点钱
藏进了满头白发  烧进了熊熊股堆

记忆中的小脚丫  记忆中的六千点
肉嘟嘟的小嘴巴  翻翻日历八年前
一生把爱交给他  为何要去股市浪
只为那一声爸妈  只为了两字挣钱

时间都去哪儿了            主力都去哪儿了
还没好好感受年轻就老了    还没好好跟着挣钱就跑了
生儿养女一辈子            买入卖出好纠结
满脑子都是孩子哭了笑了    满脑子都是等待反弹反弹
时间都去哪儿了            钱钱都去哪儿了  
还没好好看看你眼睛就花了  还没来得急逃跑你直接就停了
柴米油盐半辈子            上证深证创业板
转眼就只剩下满脸的皱纹了  转眼就只剩下停了全部都停了


版权声明：本文为博主原创文章，未经博主允许不得转载。

解决难题：一些宝贵的经验教训  （Problems and Solutions – Scott Berkun）


发明万有引力的牛顿大家都知道，你知道他花了最多时间在研究什么？万有引力？微积分？光学？
其实牛顿晚年精力都放在研究点金术上，当时他做了无数的实验，希望能从中获得突破，最后却是徒劳。现在我们了解了物理与化学的原理，知道这种研究一定是没结果的。所以，要解决问题必须对问题有充分的了解——这是否是个可以解决的问题，否则只会花费无谓的精力。
爱因斯坦说，如果他有20天去解决一个问题，那么他会用19天去把问题定义好。也是同样的道理。
把问题定义清楚，定好整个框架，这是解决问题的第一步。比如Intuit公司(maker of QUICKEN
软件) 的软件，老板Cook在定位产品时，并非是做一个好的会计软件，而是认为战胜最大的竞争对手是——笔和纸。他们公司以这个新的框架思维创做了一个成功的新产品。
爱迪生希望能够点亮一个城市，最后他发明了电力系统而不仅是灯泡。
8、90年代，很多公司都提出Personal Digital Assistant(PDA)手写随身电脑的构想，最后palm公司在96年研发成功。他是如何做到的？首先他列出重点：
> 必须可以放在衬衫的口袋里，
> 必须可以和PC机同步，
> 快速易用，
> 定价为299美元以下。
 
通过这些定义，研发时就知道哪些是必须的功能，哪些是暂时不需要的。这个原则和我们的敏捷创业类似，创业初期资源都是有限的，必须定义哪些是必须的，才能充分有效利用资源。
当我们创新时，怎么才能发现可能的问题？
PALM公司给出答案 –
原型。设计工程师先用木头做了很简单粗糙的原型，带到开会等各种场合去进行体验，别人都很奇怪，为什么带一个不能用的原型去开会，但是如果没有这个感受，他就不会知道将来这个东西会怎样用，有没有用。利用早期的原型，在类似的实际的状况中去试用，才尽早发现一些设计的重大问题，避免后面东西完成后才发现问题。
最后作者举了个有趣的例子，假如你在一个有很多电子设备的实验室中，突然发现衣服口袋中2颗糖果融化了，会怎么处理？有些人会换掉脏掉得衬衫。但是工程师珀西·勒巴朗·斯本塞（Dr
 Percy Spencer）想，”为什么糖果融化？”
通过多次实验，他发现了微波，最后发明了微波炉。
例如，现在万贴纸，也是一位3M工程师为了解决如何在厚厚的诗歌本中标志那一页，那一段的难题而发明，  
（他每周都会在圣诗班唱圣诗）为了解决这难题，他翻查以往3M的发明，发现3M有发明过一种特别的万用胶水，就替3M公司发明了万贴纸。
许多的发明是在日常的生活中发现的，发明家与普通人最大的区别是面对同一个问题时，发明家会从其他的角度去思考。这对我们做软件或其他事情，都是很有启发的。


版权声明：本文为博主原创文章，未经博主允许不得转载。

VS2008配置SVN

最近在使用VSS的过程中觉得不太好用，怀念之前使用SVN的日子，今天有点时间来试下.NET下用SVN


------准备软件：
1.AnkhSvn-2.1.8420.8.msi   --VS下SVN插件

2.Subversion-1.5.3.msi --Subversion服务端

3.TortoiseSVN-1.5.3.13783-win32-svn-1.5.2.msi --SVN客户端

 

------安装步骤(需重启见自动提示)：

1.首先安装服务端--Subversion

2.客户端--TortoiseSVN

3.VS插件AnkhSvn(其中插件最先安装或最后安装都行)

 

------安装完后配置SVN服务器:

1.在D:\下新建目录SVN(用处后面介绍)    即D:\SVN

2.再新建一目录用作版本库                    本人使用D:\WebProject

3.在SVN目录上右键选择"TortoiseSVN"--->"Create repository here" 建立镜像库，如下图




4.打开SVN下的conf目录

　　a.在[users]节点下增加:

           [users]

           myuser=mypassword     --前面为SVN用户名，=后为密码

　　b.修改authz文件中的:
            [groups]
            [/]
            myuser=rw          --myuser为passwd文件中我的用户名

      b.修改svnserve.conf文件

            anon-access = read
            auth-access = write
            password-db = passwd
            authz-db = authz   均去掉前面的#及空格

5.在WebProject目录上右键选择"SVN Checkout..." 进行测试,如下图

 

 

6.选择"SVN Checkout..."后会出现如下界面





再点击OK，如WebProject目录变成如下图样子便配置成功


 

------Subversion服务器安装时一般采用默认目录:C:\Program Files\Subversion
Microsoft Office 2016 for Mac (15.13.1)破解激活方法

操作系统版本：OS X Yosemite 10.10.4 
  Office版本：2016（15.13.1）

1. 准备工作
1.1 Office安装源
首先需要安装官方原版的Office 2016，截至目前（2015年8月24日）最新版本为15.13.1。要求是未破解的纯净状态，如果此前该系列应用已经使用其他方式进行过破解，那么需要通过AppCleaner或CleanMyMac等应用将Office 2016彻底删除干净，然后再重新安装纯净版的Office。
经测试，原本在15.12.x版本当中有效的破解方式，在经过升级之后，在15.13.x版本中无法生效。程序会频繁报错崩溃退出。
1.2 Xcode
Xcode是OS X平台下苹果官方推出的IDE，从App Store当中可以免费下载安装。安装之后需要至少运行一次，以接受其中的用户协议。破解Office的Shell脚本需要有Xcode支持才能顺利进行。通常下载安装Xcode特别慢，请耐心等候。
2. 破解激活
2.1 制作自签名证书

打开系统中的“钥匙串访问”（Cmd + 空格，输入“钥匙串”即可）。
点击菜单栏中的钥匙串访问 - 证书助理 - 创建证书...。
在新窗口中的“名称”中填写“Codesign”，“身份类型”不变，将“证书类型”改成“代码签名”，然后勾选“让我覆盖这些默认值”，点击“创建”按钮。如果过程中弹出任何提示，均选择“继续”即可。
下一个界面中“序列号”保持不变，将“有效期（天数）”改为3650，然后点击“继续”按钮。
在后面的所有界面中持续点击“继续”按钮直到界面提示证书创建完成。

2.2 运行Shell脚本
由于OneNote本来就是免费版的，因而不需要破解。其余的Word、Excel、PowerPoint、Outlook分别运行下面的4段Shell脚本即可。
使用Cmd + 空格输入“Terminal”打开终端窗口，即可输入以下4段Shell命令。在使用sudo命令时如果提示输入密码（Input Password），则输入当前Mac用户的解锁密码即可。如果过程中弹出任何提示，均选择“继续”即可。
首先是Word的Shell脚本：
echo "Patching Microsoft Office Word (15.13.1)..."
sudo perl -i -pe 's|\x00\x00\x74\x1D|\x00\x00\x90\x90|' /Applications/Microsoft\ Word.app/Contents/Frameworks/MicrosoftSetupUI.framework/Versions/Current/MicrosoftSetupUI
sudo codesign -f -s Codesign /Applications/Microsoft\ Word.app/Contents/Frameworks/MicrosoftSetupUI.framework
sudo codesign -f -s Codesign /Applications/Microsoft\ Word.app
注意这是4行命令：第1行以echo开头，后面3行都以sudo开头。中间出现的“Microsoft\ Word.app”中的空格前面的反斜杠表示该文件夹的名称中本身就有一个空格，而并非命令参数的分隔。（下同）
如果在制作自签名证书时选择的证书名称不是首字母大写的“Codesign”，则需要对应地替换上述Shell命令中首字母大写的Codesign为对应的名称。如果这个名称中带有空格，则需要将整个名称用双引号引起来，例如：
sudo codesign -f -s "The Sign Name" /Applications/Microsoft\ Word.app
下面是Excel的命令：
echo "Patching Microsoft Office Excel (15.13.1)..."
sudo perl -i -pe 's|\x00\x00\x74\x1D|\x00\x00\x90\x90|' /Applications/Microsoft\ Excel.app/Contents/Frameworks/MicrosoftSetupUI.framework/Versions/Current/MicrosoftSetupUI
sudo codesign -f -s Codesign /Applications/Microsoft\ Excel.app/Contents/Frameworks/MicrosoftSetupUI.framework
sudo codesign -f -s Codesign /Applications/Microsoft\ Excel.app
下面是PowerPoint的命令：
echo "Patching Microsoft Office PowerPoint (15.13.1)..."
sudo perl -i -pe 's|\x00\x00\x74\x1D|\x00\x00\x90\x90|' /Applications/Microsoft\ PowerPoint.app/Contents/Frameworks/MicrosoftSetupUI.framework/Versions/Current/MicrosoftSetupUI
sudo codesign -f -s Codesign /Applications/Microsoft\ PowerPoint.app/Contents/Frameworks/MicrosoftSetupUI.framework
sudo codesign -f -s Codesign /Applications/Microsoft\ PowerPoint.app
最后是Outlook的命令：
echo "Patching Microsoft Office Outlook (15.13.1)..."
sudo perl -i -pe 's|\x00\x00\x74\x1D|\x00\x00\x90\x90|' /Applications/Microsoft\ Outlook.app/Contents/Frameworks/MicrosoftSetupUI.framework/Versions/Current/MicrosoftSetupUI
sudo codesign -f -s Codesign /Applications/Microsoft\ Outlook.app/Contents/Frameworks/MicrosoftSetupUI.framework
sudo codesign -f -s Codesign /Applications/Microsoft\ Outlook.app
对于Windows平台下的Office中的Visio、Project等组件，貌似Mac平台上就从来没有出现过，此次发布的Office 2016当中也没有。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

政府信贷扭曲生产(第二篇)
　　要是我们不谈农业，而是谈其它的商业形式，上述道理还会更加明显。时常有人倡议政府应该承担起”私人产业承担不起”的那些风险。这意味着应该准许政府官僚拿纳税人的钱去冒险，做那些没有人会用自己的钱去冒险的投资。 
　　这种政策会带来诸多弊端。它会导致询私舞弊：借钱给亲朋好友，或者贷给贿赂者；它将不可避免地导致种种丑闻；只要投资项目运作失败，令纳税人的钱有去无回，必将导致互相指责推诱。它还会增加对社会主义的要求，因为，人们会很自然地问道：既然政府承担了风险，那为什么不应该取得所有的利润呢? 让纳税人承担风险而事实上只有私人资本来获利，哪里有这样的道理?然而，后面会谈到，政府对农民提供的”限抵无追偿”贷款，正是属于这种情况。（ 限抵无追偿贷款，指贷款追讨局限于抵押品价值，不额外向借贷者追讨超出抵押品价值的余额。） 
　　让我们暂且略过上述弊端，只关注政府贷款的一种后果。这就是，它会浪费资本和减少生产。政府信贷会把现有资本丢进糟糕，充其量也是效益不明的项目中。相对于没有此类信贷而将获得这样的资本的人，政府信贷会把资本交给能力更差、或者更不可靠的人，因为在任何时候，实体资本的数量都是有限的(有别于印钞机吐出来的货币数量)，交到乙手中的东西，就不可能再交给甲。 
　　人们希望把自己资本用于投资增值，但投资一定要谨慎，放出去的贷款一定是想收回来。因此，大部分放贷者把钱投下去之前，都会预先仔细审查投资计划，仔细衡量获利的预期和亏损的几率。他们有时也会犯错误，但基于诸多原因，他们犯错的可能性小于政府放贷者。理由如下：首先，借出去的钱是他们自己的，或是别人自愿托付给他们的。而政府借出去的钱却是从纳税人那里强制征收来的，不需要顾及纳税人的个人意愿。私人放贷，只会放给明确地期望在将来能偿还本金与利息或红利的借方。这标志着他们期望借款人能生产市场上有需求的东西。反观政府投钱，则围绕着诸如”创造就业”之类的模糊目的，并且，项目效益越低越好一一也就是说，相对于产出所雇用的人数越多，越有可能获得较高评价。 
　　其次，私人放贷者是经过严酷的市场筛选胜出的。经营不善就会赔钱，再也拿不出钱借给别人。他们只有经营得很成功，才可能有更多的钱借出去。因此，私人放贷者(除去通过继承遗产获得资金的一小部分人)经过了优胜劣汰的考验。反观政府贷款业务人员，不少只通过公务员考试，只知道如何用假设的方式回答假设性的问题，或者只是善于找来最动听的理由把钱贷出去，以及在贷款出问题时，找来最合适的借口以推脱责任。不过最终结果却不会因此改变：私人贷款比政府贷款更能充分运用现有的资源和资本，政府贷款与私人贷款相比会浪费更多的资本和资源。简单说，与私人贷款比较来看，政府贷款会减少生产，而不是增进生产。 
　　总之，主张由政府向私人个体或是项目提供贷款的提案，只看到了乙而忘记了甲。它只关注从中获得资本的人，而忘记了那些本来应该得到而没有得到此项资本的人。它只看得到有政府贷款注入的项目，而遗忘了无法获得资本的其它项目。它只关心某个群体的眼前利益，而不管其它群体的损失，以及整个社会的净损失。 
　　主张政府担保抵押贷款的人，同样忘记了实际借出的终究是有限的实体资本，如果扶助了看得到的乙，必然会牺牲看不到的甲。政府担保的住房抵押贷款(尤其是免首付款或首付款很少的住房抵押贷款)不可避免会发生更多的坏账。政府强迫全体纳税人去承担恶性风险与补偿损失。鼓励人们去“购买”自己其实负担不起的房子，最终造成住房供给相对于其它物品过剩。 
　　暂时过度刺激楼市，会使得每个人(包括以政府担保抵押贷款购买房子的人)负担的房价升高，甚至可能最终误导建筑业高成本地过度扩张。总的来说，从长期来看，政府信贷并没有提高国家整体的生产，却鼓励了不当的投资。 
　　人们时常听得到，罗斯福新政的执行者和主张政府千涉经济体制的人吹嘘，在1932年及其后一段时间，政府通过复兴金融公司、住房业主贷款公司及其它政府机构，如何”帮助经济走出困境”。然而，倘若政府不是在事先或事后征敛民财的话，它就不会有钱给企业资金上的帮助的。政府的全部资金都来自税收。即便是倍受吹捧的”政府信用贷款”，也是基于最终要由赋税支付其贷款这样一个前提。 
　　当政府向企业提供贷款或补贴的时候，它所做的就是向成功的私人企业征税，然后拿钱去扶持不成功的私人企业。在某些紧急状况下，或许有理由实行这样的政策，我们不准备在这里去考察其合理性。但是，长期这么下去，从国家整体的角度考虑，这似乎不是一个合算的机制，而且经验已经表明，这种做法的确得不偿失，或者说拆东墙补西墙。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

内存分配不成功导致内存泄漏的问题
内存泄漏是在写程序中容易发生的问题，所以解决内存泄漏问题至关重要，在这里我推荐一个内存泄漏的自动化检测软件：visual leak detector,非常好用的一个软件


#include <iostream>
void GetMemory(char  *p, int num)
{
p = (char *)malloc(sizeof(char) * num);
}
int main()
{
char  *str = NULL;
GetMemory(str, 100);
strcpy(str, "hello");
return 0;
}
上述代码 p申请了新的内存，但是p只是str的一个副本（编译器为函数参数制作临时副本），p指向的内存地址改变了，而str却没有改变。GetMemory没有返回值， 申请的内存得不到释放，最终造成内存泄漏。


解决方法1：采用指向指针的指针，传str的地址给函数

#include <iostream>
void GetMemory(char  **p, int num)
{
*p = (char *)malloc(sizeof(char) * num);
}
int main()
{
char  *str = NULL;
GetMemory(&str, 100);
strcpy(str, "hello");

return 0;
}
方法2：加返回值

#include <iostream>
char *GetMemory(char *p, int num)
{
p = (char *)malloc(sizeof(char) * num);
return p;
}
int main()
{
char  *str = NULL;
str = GetMemory(str, 100);
strcpy(str, "hello");

return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

【HDOJ 4272】 LianLianKan (vector深搜+剪枝)
【HDOJ 4272】 LianLianKan
不造正规做法 不过好歹是按题意做的(读懂题有时候也不是好事TOT 据说好多随意连水果去的。。。
经过5小时推出来了……整场就做了这么一道OOOOOOOOOOOTZ 题意要求只能连与他相距小于6的
即最远连到下面除顶部本身外的五个中的一个 有可以发现如果有连续的连其中任意一个效果都是一样的
这样搜索策略就是看下面五个中不连续的然后挨个接着搜。。。各种姿势都试了 各种超时 就这个可以有。。。不过不知道时不时也因为数据水TOT


代码如下:


#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <queue>
#include <map>
#include <list>
#include <stack>
#include <vector>
#include <set>
#include <ctime>
#include <cmath>
#include <bitset>

using namespace std;
#define STD_REOPEN() freopen("../in.in","r",stdin)
#define STT_REOPEN() freopen("../in.in","w",stdout)
#define INF 0x3f3f3f3f
#define _INF 63
#define eps 1e-4
#define ll long long
#define sc "%lld"
#define pr pair<int,int>
#define mod
#define sz

using namespace std;

vector <int> v;
int n;

bool dfs(vector<int>::iterator pos,int cnt)
{
	if(cnt == n) return true;
	int i,x = 0,np,nnp;
	int data = *pos;

	vector<int>::iterator it;
	vector<int>::iterator tmp;
	v.erase(pos);
	it = pos;
	tmp = it;
	for(x = 0,++it; tmp != v.end() && x < 5; ++tmp,++x,++it)//往下找5个
	{
		if(data == *tmp && (x == 4 || it == v.end() || *it != data))//如果该处和栈顶相同 并且是第五个 或者容器最后一个 或者与下一个不一样(即是连续的最后一个元素
		{
			v.erase(tmp);//深搜
			if(dfs(pos,cnt+2)) return true;
			v.insert(tmp,data);
		}
	}

	v.insert(pos,data);
	return false;
}

int main()
{
	int i,x;
    while(~scanf("%d",&n))
	{
		v.clear();
		for(i = 0; i < n; ++i)
		{
			scanf("%d",&x);
			v.insert(v.begin(),x);//用容器模拟栈(由于容器有删除的方法)
		}
		if(n&1)//奇数个肯定练不完
		{
			puts("0");
			continue;
		}

		if(dfs(v.begin(),0)) puts("1");
		else puts("0");
	}
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

swift 类型定义
//
//  PropertyClass.swift
//  swift属性
//
//  Created by wsy on 15/8/25.
//  Copyright (c) 2015年 WSY. All rights reserved.
//

import UIKit

class PropertyClass: NSObject {
    /**
    *  属性是描述特定类、结构或者枚举的值。存储属性作为实例的一部分存储常量与变量的值，而计算属性计算他们的值（不只是存储）。计算属性存在于类、结构与枚举中。存储属性仅仅只在类与结构中。
    
        属性通常与特定类型实例联系在一起。但属性也可以与类型本身联系在一起，这样的属性称之为类型属性。
    */
    // 1. 存储属性：
    /**
    *  存储属性存储着常量或者变量的值。存储属性可分为变量存储属性（关键字var描述）和常量存储属性（关键字let描述）。
    */
    
    struct FixLengteRange {
        // 存储属性
        var firstValue: Int
        let length: Int
    }

    func userFixLengthRange(){
        var rangeItem = FixLengteRange(firstValue: 0, length: 3)
        rangeItem.firstValue = 4
        // rangeItem.length = 3  error
        println("\(rangeItem.firstValue)")
        
        let rangItem2 = FixLengteRange(firstValue: 2, length: 4)
        // 因为rangeOfFourItems是一个常量（let），即便firstValue是一个变量属性，它的值也是不可以被改变的
        // rangItem2.firstValue = 2
    }
    
    // 2、计算属性
    // 除了存储属性，类、结构和枚举能够定义计算属性。计算属性并不存储值，它提供getter和可选的setter来间接地获取和设置其它的属性和值。
    struct MyPoint {
        var x = 0.0, y = 0.0
    }
    
    struct Mysize {
        var width = 0.0, height = 0.0
    }
    
    struct MyRect {
        var orign = MyPoint()
        var size = Mysize()
        
        /**
        *  Rect结构包含一个称之为center的计算属性。Rect当前中心点的坐标可以通过origin和size属性得来，所以并不需要显式地存储中心点的值。取而代之的是，Rect定义一个称为center的计算属性，它包含一个get和一个set方法，通过它们来操作长方形的中心点，就像它是一个真正的存储属性一样。
        */
        var center: MyPoint{
            get{
                let centerX = orign.x + (size.width/2)
                let centerY = orign.y + (size.height/2)
                return MyPoint(x: centerX, y: centerY)
            }
            set(newCenter){
                orign.x = newCenter.x - (size.width / 2)
                orign.y = newCenter.y - (size.height / 2)
            }
            
            // set 方法简写 默认地使用newValue这个名称来代替
//            set{
//                orign.x = newValue.x - size.width/2
//                orign.y = newValue.y - size.height/2
//            }
        }

    }
    
    // 3.只读计算属性
    /**
    *  只读计算属性只带有一个getter方法，通过点操作符，可以放回属性值，但是不能修改它的值。
       应该使用var关键字将计算属性－包含只读计算属性－定义成变量属性，因为它们的值并不是固定的。let关键字
       只被常量属性说使用，以表明一旦被设置它们的值就是不可改变的了
       通过移除get关键字和它的大括号，可以简化只读计算属性的定义：
    这个例子定义了一个三维长方体结构Cuboid，包含了长宽高三个属性，和一个表示长方体容积的只读计算属性volume。volume值是不可被设置的，因为它直接由长宽高三个属性计算而来。通过提供这样一个只读计算属性，Cuboid使外部用户能够访问到其当前的容积值。
    */
    struct Cuboid {
        var width = 0.0, heigth = 0.0, depth = 0.0
        var volume: Double{
            return width*heigth*depth
        }
    }
    var myCuboid = Cuboid(width: 2, heigth: 4, depth: 5)
    
    
   // 4.类型属性
    /**
    *  在C和Objective－C中，定义静态常量、变量和全局静态变量一样。但是在swift中，类型属性的定义要放在类型定义中进行，在类型定义的大括号中，显示地声明它在类型中的作用域。
    
    对值类型而言，定义类型属性使用static关键字，而定义类类型的类型属性使用class关键字。下面的例子展示了存储和计算类型属性的用法：
    */
    struct SomeStrcucture {
        static var storedTypeProperty = "Hello SomeStrcucture"
        static var computedTypeProperty: Int{
            get{
                return 3
            }
            set{

            }
        }
    }
    
    enum SomeEnumeration{
        static var storedTypeProperty = "Hello SomeEnumeration"
        static var computedTypeProperty: Int{
            get{
            return 4
            }
            set{
                
            }
        }
    }


}

// 2.Lazy Stored Properties（懒惰存储属性？）
// 懒惰存储属性是当它第一次被使用时才进行初值计算。通过在属性声明前加上@lazy来标识一个懒惰存储属性。
class DataImporter {
    var fileName: String = "data.text"
}

class DataManager {
    // DataManager实例被创建时，并不需要马上就创建一个新的DataImporter实例
    // DataImporter的实例importer只有在当它在第一次被访问时才被创建。例如它的fileName属性需要被访问时：
    // println("\(manager.imaporter.fileName)")
    lazy var imaporter = DataImporter()
    // 存储属性
    var data = [String]()

}


// 4、属性观察者
/**
*  属性观察者观察属性值的改变并对此做出响应。当设置属性的值时，属性观察者就被调用，即使当新值同原值相同时也会被调用。

除了懒惰存储属性，你可以为任何存储属性加上属性观察者定义。另外，通过重写子类属性，也可以继承属性（存储或计算）加上属性观察者定义。属性重写在“重写”章节定义。

注意
不必为未重写的计算属性定义属性观察者，因为可以通过它的setter方法直接对值的改变做出响应

定义属性的观察者时，你可以单独或同时使用下面的方法：
willSet：设置值前被调用
didSet：设置值后立刻被调用

当实现willSet观察者时，新的属性值作为常量参数被传递。你可以为这个参数起一个名字，如果不的话，这个参数就默认地被命名成newValue。

在实现didSet观察者时也是一样，只不过传递的产量参数表示的是旧的属性值。

注意：
属性初始化时，willset和didSet并不会被调用。只有在初始化上下文之外，当设置属性值时才被调用

下面是一个willSet和didSet用法的实例。定义了一个类StepCounter，用来统计人走路时的步数。它可以从计步器或其它计数器上获取输入数据，对日常联系锻炼的步数进行追踪。
*/

class StepCounter {
    var stepCount: Int = 0{
        willSet{
            // 新值
            println("About to set totalSteps to \(newValue)")
        }
        
        didSet{
            // 旧值
            println("old value \(oldValue)")
        }
    }
    
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

存储控制器和SDRAM 实验
S3C2440 存储控制器(memory controller)提供了访问外部设备所需的信号，这是一种通过总线形式来访问扩展的外设。


S3C2440  的存储器控制器有以下的特性：



支持小字节序、大字节序(通过软件选择)
每个BANK的地址空间为128MB，总共1GB(8 BANKs)
可编程控制的总线位宽(8/16/32 -bit)，不过 BANK0 只能选择两种位宽(16/32 -bit)
总共8个BANK， BANK0 ~ BANK5 可以支持外接 ROM，SRAM等，BANK6 ~ BANK7 除可以支持 ROM，SRAM外，还支持SDRAM等；
BANK0 ~ BANK6 共7个BANK的起始地址是固定的；
BANK7 的起始地址是可编程选择；
BANK6、BANK7的地址空间大小是可编程控制的；
每个BANK的访问周期均可编程控制；
可以通过外部的”wait“ 信号延长总线的访问周期；
在外接SDRAM时，支持自刷新(self-refresh)和省电模式(power down mode)。



S3C2440 对外引出的27根地址线 ADDR0 ~ ADDR26 的访问范围只有 128MB，那么如果达到上面所说的1GB的访问空间呢？CPU对外还引出了8根片选信号 nGCS0 ~ nGCS7，对应与 BANK0 ~ BANK7，当访问 BANKx 的地址空间时，nGCSx 引脚输出低电平用来选中外接的设备。这样，每个 nGCSx 对应 128MB 地址空间，8个 nGCSx
 信号总共就对应了 1GB 的地址空间。这8个 BANK的地址空间如图：



如图所示，左边对应不使用 NAND Flash 作为启动设备(单板上不接 NAND_BOOT 跳线)时的地址空间布局，右边对应使用 NAND Flash启动设备(单板上接 NAND_BOOT 跳线)时的地址空间布局。

S3C2440 作为32位的CPU，可以使用的地址范围理论上达到 4GB。除去上述用于连接外设的 1GB 地址空间外，还有一部分是 CPU 内部寄存器的地址，剩下的地址空间没有使用。
注意：这里说的是物理地址。



S3C2440 的寄存器地址范围都处于 0x48000000 ~ 0x5FFFFFFF，各功能部件的寄存器大体相同。如图：







源码：
@*************************************************************************
@ File：head.S
@ 功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDRAM继续执行
@*************************************************************************  

.equ				MEM_CTL_BASE,				0x48000000
.equ				SDRAM_BASE,					0x30000000

.text
.global _start
_start:
		bl 	disable_watch_dog									@ 关闭看门狗
		bl 	memsetup													@ 设置存储控制器
		bl 	copy_steppingstone_to_sdram				@ 复制代码到SDRAM中
		ldr pc, =on_sdram											@ 跳到SDRAM中继续执行
on_sdram:
		ldr sp,=0x34000000											@ 设置堆栈
		bl 	main
halt_loop:
		b 	halt_loop


disable_watch_dog:
		@ 往 WATCHDOG 寄存器写0 即可
		mov r1,			#0x53000000
		mov r2,			#0x0
		str r2,			[r1]
		mov pc, 		lr         @返回
		
		
copy_steppingstone_to_sdram:
		@ 将Steppingstone的4K数据全部复制到SDRAM中
		@ Steppingstone起始地址为 0x00000000，SDRAM中起始地址为 0x30000000
	
		mov r1, #0
		ldr r2, =SDRAM_BASE
		mov r3, #4*1024
1:
		ldr r4, [r1],#4				@ 从Steppingstone读取4字节的数据，并让源地址加4
		str r4, [r2],#4				@ 将此4字节的数据复制到SDRAM中，并让目地地址加4
		cmp r1, r3						@ 判断是否完成：源地址等于 Steppingstone 的末地址
		bne 1b								@ 若没有复制完，继续
		mov pc,  lr						@ 返回
		
		
memsetup:
		@ 设置存储控制器以便使用 SDRAM 等外设
		mov r1,		#MEM_CTL_BASE				@ 存储控制器的13个寄存器的开始地址
		adrl			r2, mem_cfg_val			@ 这13个值的起始存储地址
		add r3,		r1, #52							@ 13*4 = 52
1:
		ldr r4, 	[r2], #4						@ 读取设置值，并让 r2 加 4
		str r4,   [r1], #4						@ 将此值写入寄存器，并让 r1 加 4
		cmp r1,   r3									@ 判断是否设置完所有13个寄存器
		bne 1b												@ 若没有写成，继续
		mov pc,   lr									@ 返回
		
.align 4
mem_cfg_val:
	@  存储控制器 13 个寄存器的设置值
	
	@ 存储控制器共有 13 个寄存器， 
	@ BANK0 ~ BANK5 只需要设置 BWSCON 和 BANKCONx(x为0~5)两个寄存器： 
	@ BANK6、BANK7 外接SDRAM时，除 BWSCON 和 BANKCONx(x为6~7)外，还要设置 
	@ REFRESH、BANKSIZE、MRSRB6、MRSRB7 等4个寄存器。
	
	@ 位宽和等待控制寄存器 BWSCON (BUS WIDTH & WAIT CONTROL REGISTER)
	@ BWSCON 中每4位控制一个 BANK，最高4位对应 BANK7、接下来4位对应 BANK6，依此类推
	@ STx：启动/禁止 SDRAM 的数据掩码引脚，对于 SDRAM，此位为0；对于 SRAM，此位为 1
	@ WSx：是否使用存储器的 WAIT 信号，通常设为 0
	@ DWx：使用两位来设置相应 BANK 的位宽， 0b00 对应8位， 0b01 对应16位，0b10 对应32位，0b11表示保留
	@ 比较特殊的是 BANK0，它没有 ST0 和 WS0，DW0([2:1])只读---由硬件跳线决定：
	@ 0b01 对应16位，0b10 对应32位，BANK0 只支持16、32两种宽度
	@ 对于本开发板(JZ2440)，可以确定 BWSCON 寄存器的值为： 0x22011110
	.long		0x22011110							@ BWSCON
	
	@ BANK 控制寄存器 BANKCONx(BANK CONTROL REGISTER, x 为 0~5)
	@ 这几个寄存器用来控制 BANK0 ~ BANK5 外接设备的访问时序，使用默认的 0x0700 即可
	.long   0x00000700							@ BANKCON0
	.long   0x00000700							@ BANKCON1
	.long   0x00000700							@ BANKCON2
	.long   0x00000700							@ BANKCON3
	.long   0x00000700							@ BANKCON4
	.long   0x00000700							@ BANKCON5
	
	@ BANK 控制寄存器 BANKCONx(BANK CONTROL REGISTER, x 为 6~7)
	@ 在8个BANK中，只有BANK6和BANK７可以外接SRAM或SDRAM，
	@ 所以BANKCON6 ~ BANKCON7 与 BANKCON0 ~ BANKCON5 有点不同
	@ MT([16:15]) 用于设置本 BANK 外接的是 ROM/SRAM 还是 SDRAM。
	@ MT=0b00 时，此寄存器与 BANKCON0 ~ BANKCON5 类似。(外接SRAM)
	@ MT=0b11 时，此寄存器其它值如下设置。(外接SDRAM)
	@ Trcd([3:2]) RAS to CAS delay，设置推荐值为 0b01
	@ SCAN([1:0]) SDRAM  的列地址位数。对于本开发板使用的 SDRAM K4S561632，
	@ 列地址位数为 9， 所以 SCAN = 0b01。如果使用其他型号的 SDRAM， 需要查看其数据手册来决定 SCAN 的取值。
	@ 0b00 表示8位， 0b01 表示9位， 0b10 表示10位
	@ 综上所述，本开发板中 BANKCON6/7 均设为 0x00018005
	.long   0x00018005							@ BANKCON6
	.long   0x00018005							@ BANKCON7
	
	@ 刷新控制寄存器 REFRESH(REFRESH CONTROL REGISTER): 设为 0x008C0000 + R_CNT
	@ REFEN([23])	0 = 禁止 SDRAM 的刷新功能， 1 = 开启 SDRAM 的刷新功能
	@ TREFMD([22]) SDRAM 的刷新模式。0 = CBR/Auto Refresh， 1 = Self Refresh(一般在系统休眠时使用)
	@ Trp([21:20]) 设为 0 即可。
	@ Tsrc([19:18]) 设为默认值 0b11 即可。
	@ Refresh Counter([10:0]) 即上述的 R_CNT
	@ R_CNT 可如下计算 (SDRAM 时钟频率就是 HCLK)
	@ R_CNT = 2 ^ 11 + 1 - SDRAM 时钟频率(MHz) * SDRAM 刷新周期 (uS)
	@ SDRAM 的刷新周期在 SDRAM 的数据手册上有标明，在本开发板使用的 SDRAM K4S561632 的数据手册上，
	@ 可看见这么一行 "64 ms refresh period (8K Cycle)"
	@ 所以，刷新周期 = 64ms/8192 = 7.8125 us
	@ 在未使用 PLL 时， SDRAM 时钟频率等于晶振频率 12 MHz
	@ 现在可以计算： R_CNT = 2 ^ 11 + 1 - 12 * 7.8125 = 1955
	@ 所以，在末使用 PLL 时， REFRESH = 0x008C0000 + 1955 = 0x008C07A3
	.long   0x008C07A3							@ REFRESH
	
	@ BANKSIZE 寄存器 REFRESH (BANKSIZE REGISTER)
	@ BURST_EN([7]) 0 = ARM 核禁止突发传输， 1 = ARM 核支持突发传输
	@ SCKE_EN([5]) 0 = 不使用 SCKE 信号令 SDRAM 进入省电模式， 1 = 使用 SCKE 信号令 SDRAM 进入省电模式
	@ SCLK_EN([4]) 0 = 时刻发出 SCLK 信号， 1 = 仅在访问 SDRAM 期间发出 SCLK 信号
	@ BK76MAP([2:0]) 设置 BANK6/7 的大小
	@ BANK6/7 对应的地址空间与 BANK0~5 不同。 BANK0~5 的地址空间大小都是固定的 128MB，
	@ 地址返回是 (x*128M) 到 (x+1)*128M-1。 x表示 0 到 5。BANK6/7 的大小是可变的，
	@ 以保持这两个空间的地址连续，即 BANK7 的其实地址会随它们的大小变化。BK76MAP 的取值意义如下：
	@ 0b010 = 128M/128M
	@ 0b001 = 64MB/64MB
	@ 0b000 = 32MB/32MB
	@ 0b111 = 16MB/16MB
	@ 0b110 = 8MB/8MB
	@ 0b101 = 4M/4M
	@ 0b100 = 2M/2M
	@ 本开发板 BANK6 外接64MB的 SDRAM， 令[2:0]=0b001 (64MB/64MB)
	@ 表示 BANK6/7 的容量都是64MB，虽然 BANK7 没有使用
	@ 综上所述，本开发板 BANKSIZE 寄存器的值可算得 0xB1
	.long   0x000000B1							@ BANKSIZE
	
	@ SDRAM 模式设置寄存器 MRSRBx (SDRAM MODE REGISTER SET REGISTER, x为6~7)
	@ 能修改的只有位 CL([6:4])，这是 SDRAM 时序的一个时间参数：
	@ 0b000 = 1 clocks， 0b010 = 2 clocks， 0b011 = 3 clocks
	@ SDRAM K4S561632 不支持 CL = 1的情况，所以位[6:4]取值为 0b010 或 0b011 。
	@ 本开发板取最保守的值 0b011， 所以 MRSRB6/7 的值为 0x30
	.long   0x00000030							@ MRSRB6
	.long   0x00000030							@ MRSRB7
		



// leds.c
#define	GPFCON		(*(volatile unsigned long *)0x56000050)
#define	GPFDAT		(*(volatile unsigned long *)0x56000054)

#define	GPF4_out	(1<<(4*2))
#define	GPF5_out	(1<<(5*2))
#define	GPF6_out	(1<<(6*2))

void  wait(volatile unsigned long dly)
{
	for(; dly > 0; dly--);
}

int main(void)
{
	unsigned long i = 0;
	
	GPFCON = GPF4_out|GPF5_out|GPF6_out;		// 将LED1,2,4对应的GPF4/5/6三个引脚设为输出

	while(1){
		wait(30000);
		GPFDAT = (~(i<<4));	 	// 根据i的值，点亮LED1,2,4
		if(++i == 8)
			i = 0;
	}

	return 0;
}



#Makefile
sdram.bin : head.S leds.c
	arm-linux-gcc -g -c -o head.o head.S
	arm-linux-gcc -g -c -o leds.o leds.c
	arm-linux-ld -Ttext 0x30000000 -g head.o leds.o -o sdram_elf
	arm-linux-objcopy -O binary -S sdram_elf sdram.bin
	arm-linux-objdump -D -m arm sdram_elf > sdram.dis
clean:
	rm -f sdram.dis sdram.bin sdram.dis *.o





版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU4333
传送门：HDU4333
扩展KMP小应用，把原串复制一遍就行了。

对着某位博主的代码，死活改不出来，然后发现这货的代码是WA的……

代码上的`小细节见下。
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;

int ext[2000005];
int pre[2000005];
char S[2000005];
int n,length;

void Build_ext(const char *T,int* ext){
     int len=strlen(T),a=0,p=0;
     ext[0]=len;
     while(p<len-1&&T[p]==T[p+1])
        p++;
     ext[1]=p;
     a=1;
     for(int k=2;k<len;k++){
         if(ext[k-a]+k-1>=p){
             int j =max((p-k+1),0);
             while(k+j<len&&T[k+j]==T[j])
                j++;
             ext[k]=j;
             a=k;
             p=k+j-1;
         }
         else
             ext[k]=ext[k-a];
     }
}

void KMP(char* S,int len)
{
    pre[0]=-1;int k=-1;
    for(int i=1;i<len;i++){
        while(k>=0&&S[k+1]!=S[i])
            k=pre[k];
        if(S[k+1]==S[i])
            k++;
        pre[i]=k;
    }
}

void GetAns(int number)
{
    Build_ext(S,ext);
    int ans1=0,ans2=0,ans3=0;
    for(int i=1;i<=length;i++)
        if(ext[i]>=length)
            ans2++;
        else
            if(S[i+ext[i]]>S[ext[i]])
                ans3++;
            else
                ans1++;
    KMP(S,strlen(S));
    int tmp=length%(length-pre[length])==0?max(length/(length-pre[length]),1):1;
    printf("Case %d: %d %d %d\n",number,ans1/tmp,ans2/tmp,ans3/tmp);
}

void Readdata()
{
    freopen("loli.in","r",stdin);
    ios::sync_with_stdio(false);
    cin>>n;
}

void Solve()
{
    for(int i=1;i<=n;i++){
        cin>>S;
        length=strlen(S);
        for(int j=0;j<length;j++)
            S[j+length]=S[j];
        S[2*length]='\0';
        GetAns(i);
    }
}

void Close()
{
    fclose(stdin);
    fclose(stdout);
}

int main()
{
    Readdata();
    Solve();
    Close();
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

英语四六级见解（攻略）
（纯手打，转载请注明出处） 
这篇日志适用于那些年考过四六级，但是没有考过的少年们，在此结合我的一些经历，给大家提供一些中肯的建议。那些英语四六级裸考直逼六百的大神可以自动忽略。


 
我的英语很差，高考的时候只考了37分，第一次四级没有过，差了五分，总结原因是因为不了解四六级的答题顺序，没有把握好时间，听力试音时我的作文还没有写完，因为我打了草稿，这一点大家一定注意，作文只有半个小时，我们最好在二十到二十五分钟内完成，因为留五分钟要看听力的选项，熟悉听力的选项，我们听得时候就会有方向感，养成好习惯，同样英语六级考了两次，第一次裸考：409，第二次仔细准备了一些，分数是500，虽然感觉翻译做的很差，但是其他的试题由于平常的训练我都比较满意，付出就有回报，只要下劲努力学，就一定有收获。特别的，对于要考研的同学，英语一定要好好学习，不要等到快考试了，才去突击恶补，这种方法可能适用于政治这种课程，但是对于英语来说个人感觉收效甚微，甚至没有。
 
备考时间：
我的备考周期是两个月，前一个月就是背背单词，听一些听力，但不是真题听力。即四月中旬到五月中旬。这一阶段没有其他的事情，主要是搞定单词量的积累，但是不能轻视，一定以持之以恒，每天坚持下来，有很多同学都是刚开始很努力的记单词，慢慢就由于各种原因没有坚持下来，原先记住的单词也忘完了，这种人是最可惜的。
五月中旬到六月一号（考前两天。）：做真题，这段时间特别重要，切记：真题一定要按照考试时间安排，作文也要写。就是要营造考试的氛围，因为个人感觉六级时间有点紧，所以在平时要注重时间的掌握，按自己的做题顺序做题。千万不能做一道题停下来刷一下朋友圈，这样是没效果的，一定要认认真真全身心的去做题，这样才有效果。我身边有的同学做试卷还带着耳机听音乐，真不知道他的左右脑这么“发达”。以上出现的情况大家一定要引起重视，因为这是大部分学生的通病。
 
总体时间把握:
五一之前：基本把单词都背背认认
5.4  买了六级真题卷子
六月4号之前，就是把真题卷子做一下
其中一直坚持背翻译和作文。
五月19号前后两个星期做真题  按时间做真题，除了作文翻译以外。并且估分，分析各题的得分。
在真题中把自己的不会的单词查漏补缺，进行背诵，同时不要忘了背作文和翻译
一定要按照时间来做题，后面的时间是很紧张的。
 
下面针对不同的题型进行分类的解释：
 
单词篇：
很多人特别是男同胞们对于单词的记忆特别头疼，虽然有很多所谓的单词记忆方法，凡是感觉要想记住单词还得依靠自己的努力，不同的人有不同的方式，我介绍一下我的方法，单词的记忆分为三部分，第一部分就是依照单词书去记忆，个人建议不要使用顺序版的单词书。那样记单词特备容易记混。拿新东方英语单词乱序版来说，两天一个topic不算多吧，方法是：用手捂住词义，然后测试是否能准确回答，把不能回答的单词抄在一个小本子上，这个本子特别重要，记录你不认识或者记混的单词（长存脑海里的单词就没必要再去记忆），以后再回顾就要靠这个本子。切记：很多人拿着单词书就开始背，也没有去检验自己记住没，这样的后果是到最后自己却不知道哪些单词没记住。第三部分：就是通过试题来记单词，特指历年真题，有很多人做试卷知识漫漫的完成，然后对答案，分析错题，殊不知，真题的词汇很重要，当我们完成一套试题时，我们应该拿出红笔从新审视阅读，把不会的单词用笔勾出，然后记在小本子上，这一方法特别有用，因为你不由自主的就记住了那些高频词汇。
单词贵在坚持，每天把小本子拿出来背背，并且不断地往里面加入新单词，这样一来，你就会感觉做起阅读来得心应手。
 
 
 
 
 
听力篇：
很多人都对听力敬而远之，感觉听不懂，当然大学开设的英语课除了英语专业的学生外，个人感觉很鸡肋（并不是刻意否认英语老师的能力），只是大家从意识对英语就淡薄了，轮到四六级考试，才想起去恶补英语。听力我的方法是多听（这不是废话嘛），当然我用的听力教材是华研外语的“新编大学英语六级听力1000题”，其中它把听力的各个题型都拿出来分析，特别是不同的题在听不懂的条件下如何去锁定答案（有点投机取巧），个人感觉不错，既能练习听力又能增加词汇量。我推荐没必要都听，个人根据自己的情况有选择的去练习。比如说：我感觉开篇的八个短对话我的正确路很低，我就着重的进行练习。全部都练时间上不现实。这个依据个人时间而定。还有就是注重对题目选项的理解，写完作文后，我们可以对听力的选项进行快速的浏览，然后就可以判断出听力的答题内容了，这样一来我们再去听得时候就会有明确的方向感了。
 
阅读篇：
阅读占的分值最高，特别是仔细阅读，也就是我们平常所说的阅读理解，十个题，一个17.5分，这个分值是相当高了。
1.     
这个更加的重要，我自己针对的复习了很长时间，功夫不负有心人，仔细阅读全对，选词填空错一个，快速阅读全对。说一下我的一些方法：阅读包括仔细阅读，选词填空，快速匹配三种，很多同学做阅读遇到不懂得段落就开始“意淫”，然后根据自己的主观臆断去选择，历史经验证明，这种做法往往正中出题人的圈套，ＡＢＣＤ四个选项中一定存在某个选项是专门为读不懂文章的同学准备的。
2.     
还有一些同学做阅读的方法不对，一些人拿到文章直接闷头阅读，然后各种细节各种单词不认识，读完后云里雾里的不知道文章中心含义，结果可想而知。
个人感觉先去读题目，然后带着问题去读文章，这样更有，目的性，往往，题目的顺序与段落是相匹配的，当你做出第一题时，下一段落就有可能存在第二题的题解。而且要学会定义，阅读中出现不认识的单词词组那是相当常见，就如同汉语文章中还有很多我们不知道的词语，关键在于我们要学会从题目中的信息进行回文定位，这样很重要，定位到某几个句子时，我们在重点对这几个句子进行分析。而你死扣文章中不认识的单词有可能就不是出题点。这样不是白白浪费功夫吗。
3.    做题速度，很多同学由于平时在课下做试卷时散漫不注重时间，导致在考场上做题速度过慢，这很危险，即便试题你都会，但是写不到答题卡上什么都白说。这就是为什么我们要注重时间的把握。关于时间上的把握，不同的题有不同的限制时间，我们平常练习的就要在规定的时间内进行答题。以下是一份时间分配：
4.    快速阅读这个题型简直就是送分题，一个都不能错，个人的做题方法是：先读给出的句子，画出关键词，然后在从文章中一段一段的找，找到与之对应的关键词即可。
5.    选测填空，这个有一定的难度，方法：先浏览所给的词汇，分清名词、副词、形容词。然后在结合句意进行选择，最可怕的是：单词都不认识，更别说词性了，所以说，词汇量很重要，并不是说四六级考试中有确定的题目去考词汇量，词汇量是贯穿在整张试卷的，词汇量是基础。想想看，连单词意思都不知道，做对题得几率有多大呢？
 
 
 
作文篇：作文是老生常谈，只要是英语考试都涉及到作文。关于作文不多说，功夫在平时，平时在做阅读或者背范文时多积累好词好句，我们以仿照范文写出复杂的句式变换，需要注意的是：范文没必要都背，我们只要记住里面的经典句型和写作风格就行，把它们整理在一个本上（本子正面记录单词，背面记录作文句子），没事时常拿出来背背，默写，慢慢地就记住了。更重要的就是：当我们拿到一篇作文范文时，先不要看范文，先看题目，然后通过我们之前的积累先尝试的写出来，最后再与范文做比较，这样我们就更加知道自己的差距在哪了。
 
翻译篇：
这个要靠积累和一定的英语素养才能写出漂亮的句子，翻译是我的短板，往往看见汉语句子却想不出来如何组合成英语句子。我的方法就是，根据模板记一下关键的词汇，然后根据不同的主题进行分类记忆，比如说关于教育的，我们要掌握：研究生，博士生，本科生，教育产业化，教育改革，出国留学等一些关键的字眼。再比如说环保的，我们需要记：低碳生活，和谐社会，电子垃圾，碳排放，雾霾，治污，尾气超标等一些字眼。一句话，功夫在平时，只多积累一些素材，不求翻译能提分，至少不去拉分就行。
 
谨记：
还有一点很重要，就是关于听力耳机，各大高校在四六级考试之间都会进行听力试音，一定要提前调对好频率，不能到考场上再去调音。因为写完作文就开始放听力了，到时候可能时间来不及，如果听力没听或者因为耳机听得不清楚的，对于那些听力薄弱的同学们，基本上这次六级考试就被判了死刑了。所以一定要试音。有条件的可以去买一个带电子屏显调频的耳机，这样直接按到指定频率也可以。
最后在叨叨一句，检查好身份证、铅笔、准考证、橡皮、学生证。预祝骚年们都能顺利通过。
 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1520 Anniversary party（最大独立集 树形dp）
题目链接：点击打开链接
题目描述：现有一棵树，树上每个结点都有一个权值，问从中选一些点，这些点两两之间不直接连接，问权值最大为多少？
解题思路：很裸的一道树上最大独立集问题 树形dp即可
dp[i][0]:不选i节点 dp[i][0]+=max(dp[t][0],dp[t][1]);
dp[i][1]:选i节点     dp[i][1]+=dp[t][0];
代码：
#pragma comment(linker,"/STACK:1024000000,1024000000")
#include <cstdio>
#include <cstring>
#include <iostream>
#define MAXN 6010
using namespace std;
int head[MAXN],tol;
struct Edge{
    int v,next;
}edge[MAXN];
void addEdge(int u,int v){
    edge[tol].v=v;edge[tol].next=head[u];head[u]=tol++;
}
int max(int a,int b){
    return a>b?a:b;
}
int dp[MAXN][2];
int n,value[MAXN];
bool vis[MAXN];
void DP(int u,int p){
    dp[u][0]=0;
    dp[u][1]=value[u];
    int k,to;
    for(k=head[u];k!=-1;k=edge[k].next){
        to=edge[k].v;
        if(to==p) continue;
        DP(to,u);
        dp[u][0]+=max(dp[to][0],dp[to][1]);
        dp[u][1]+=dp[to][0];
    }
}
int main(){
    while(scanf("%d",&n)!=EOF){
        for(int i=1;i<=n;++i) scanf("%d",&value[i]);
        int u,v;
        tol=0;memset(head,-1,sizeof(head));
        memset(vis,false,sizeof(vis));
        while(scanf("%d%d",&u,&v)!=EOF&&(u!=0||v!=0)) {addEdge(v,u);vis[u]=true;}
        int root;
        for(int i=1;i<=n;i++){if(!vis[i]) {root=i;break;}}
        DP(root,root);
        printf("%d\n",max(dp[root][0],dp[root][1]));
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

心情无题
不吐槽，有吐槽的时间不如去奋发努力，外部的条件都是借口。
宣布一件事情：以后博客全部用英文完成，主要还是为了锻炼一下英文能力，为了以后做准备。当然了，开始英文语法肯定惨不忍睹，大家可以选择性无视我了。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Http  专题一：概述
什么是http
    当你使用Web浏览器打开一个网站的时候，你需要从网站的远端服务器拉取内容来展示，
    例如图片，html，css,js等。那么从web浏览器与服务器之间通信是需要统一
    沟通方式(对于两个来自不同国家的人来说，想要交流首先要统一表达方式，是口语交流还是文字交流)。
    web浏览器就使用http来实现与服务器之间的通信。

    在现代全球因特网中使用的公共语言就是http。tcp/ip与http的区别是什么？
    http是一种沟通方式，而tcp/ip则是沟通方式实现的细节。就像两个来自不同
    国家的人选择用口述的方式沟通(http),现在沟通方式确定了,那么接下来要确定
    使用哪种语言(tcp/ip)。官方点的描述是http协议属于应用层,tcp/ip分别属于传输层,网络层。

    web内容都是存储在web服务器上的。web服务器所使用的是http协议,
    因此经常会被称为http服务器。这些http服务器存储了因特网中的数据,
    如果http客户端发乎请求的话,它们会提供数据。客户端向服务器发送
    http请求,服务器会在http响应中回送所请求的数据。

    http客户端和http服务器共同构成了万维网的基本组件

什么是web资源
    web服务器是web资源的宿主。web资源是web内容的源头。
    最简单的web资源是web服务器文件系统转哦给你的静态文件。
    这些文件可以包括任意内容:文本文件,html文件,微软的word文件,
    adobe的acrobat文件,或所有其他你能够想到的格式。

    但资源不一定非得是静态文件。资源还可以是根据需要生成内容
    的软件程序。这些动态内容资源可以根据你的身份,所请求的信息或
    每天的不同时段来产生内容。它们可以为你显示照相机中活生生的招聘,
    也可以帮你进行股票交易等

什么是媒体类型
    英特网上有数千种不同的数据类型,http仔细的给每种要通过web传
    输的对象都进行标识,打上名为 MIME 类型的数据格式标签,最初设
    计MIME是为了解决在不同的电子邮件系统之间挪移报文存在的问题。
    MIME在电子邮件系统中工作的非常好,因此http也采纳了这种处理方
    式,用它来描述并标记多媒体内容。

    web服务器会为所有http对象数据附加一个MIME类型。
    当web浏览器从服务器中取回一个对象时,回去查看相关的MIME类型,
    看看它是否知道应该如何处理这个对象。大多数浏览器都可以处理数
    百种常见的对象类型:html,js,css,png等。MIME是一种文本标记,
    表示一中主要的对象类型和一个特定的子类型,中间由一条斜杠来区分。

    - html格式的文档由 text/html 类型来标记
    - 普通的ascll文本文档由 text/plain 类型来标记
    - jpeg格式的照片为 image/jpeg 类型
    - gif格式类型的图片为 image/gif 类型

什么是URI,什么是URL
    每个web服务器资源都有一个名字,这样客户端就可以说明它们
    感兴趣的资源是什么了。服务器资源名被成为统一资源标识符(Uniform Resource Identifier URL).
    URI就像因特网上的邮政地址一样,在世界范围内唯一标识并定位信息资源。

    URL,统一资源定位符。是资源标识符最常见的形式。URL描
    述了一台特定服务器上某资源的特定位置。它们可以明确说明如果从一个精确,固定的位置获取资源

    大部分的URL都遵循一个中标准格式，这种格式包含三个部分。

    - URL的第一部分被称为方案,说明了访问资源所使用的协议类型。这部分通常就是http协议(http://)

    - 第二部分给出了服务器的英特网地址(www.itget.cn)

    - 其余部分指定web服务器上的某个资源(/user/name);

    现在,几乎所有的URI都是URL.

什么是事务
    我们来更自习的看看客户端是怎样通过http与web服务器及其资源进
    行事务处理的。一个http事务由一条(从客户端发往服务器的)请求命令
    和一个(从服务器发回客户端的)响应结果组成。这中通信是通过名为http报文的格式化数据块进行的。

#方法

    http支持几种不同的请求命令,这些命令被称为http方法。
    每条http请求报文都包含一个方法。这个方法会告诉服务器要执行什么动作(获取一个web页面,运行一个网关程序,删除一个文件等)。

    GET     :  从服务器向客户端发送命名资源
    PUT     :  将来自客户端的数据存储到一个命名的服务器资源中去
    DELETE  :  从服务器中删除命名资源
    POST    :  将客户端数据发送到一个服务器网关应用程序
    HEAD    :  仅发送命名资源响应中的http首部

#报文

    现在我们来快速浏览一下 http请求和响应报文的结构。
    http报文是由一行一行的简单字符串组成的。http报文都是纯文本,不是二进制代码,所以人们可以很方便的对其进行读写。
    请求报文：
    |GET /test/bugall.txt http/1.1| 起始行
    |-----------------------------|
    |Accept : text/*              |
    |Accept-Language: en,fr       |  首部
    |_____________________________|

    相应报文
    |http/1.1 200 ok              | 起始行
    |-----------------------------|
    |Content-type:text/plain      |
    |Content-length:19            | 首部
    |-----------------------------|
    |Hi! I'm bugall!              | 主体
    |-----------------------------|

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

程序媛开发之路—JSP自定义标签
jsp自定义标签就是通过自定义标签实现类来实现复杂的、可重复利用的功能。简化jsp页面，提高代码的复用性。
比如我们需要在页面上定义一个下拉框控件（Select），我们需要加载从数据库中查出来的数据。我们就可以通过定义select标签的方式，将SQL查询，组织数据，如循环遍历等事情全部在jsp标签类中实现。 这样有什么好处呢？

主要目的是为了取代丑陋的jsp脚本，在Html页面中插入JSP有几个坏处：


JSP脚本非常丑陋，难以阅读。JSP脚本和HTML代码混杂，维护成本高。HTML页面中嵌入JSP脚本，导致美工人员难以参与开发。

所以出于以上的考虑，就有了自定义标签，自定义标签一方面具有和HTML类似的语法，一方面又可以完成JSP脚本的功能。同时，使用自定义标签可以复用，例入在系统中很多页面都需要用到下拉框循环遍历从数据库中查询的数据，如果是平时，每个人用一次就得循环一次，但是有了自定义标签，只需要引用标签就可以了，遍历的功能都封装到了标签内部。 不多说了，下面我就具体来介绍一下自定义标签吧。

一、基本概念： 
    
标签是一种XML元素，通过标签可以使JSP网页变得简洁并且易于维护。标签库是由一系列功能相似、逻辑上互相联系的标签构成的集合称为标签库。 标签库描述文件是一个XML文件，这个文件提供了标签库中类和JSP中对标签引用的映射关系。 标签处理类是一个Java类，这个类继承了TagSupport或者扩展了SimpleTag接口，通过这个类可以实现自定义jsp标签的具体功能。


二、 创建基本步骤

开发自定义标签的处理类，下面是一个处理地域字典的标签类

提供属性的get和set方法
       这个属性可以在jsp页面设置，这个属性值就是jsp数据到tag之间的入口。所以tag立面必须有一个setXXX()方法，这个属性值的名称是在tld里定义的，取什么名字都可以，只需tag里提供相应的set方法即可。


处理doStartTag 或doEndTag方法
       这两个方法是TagSupport提供的。例如<zw:areaInfo… />，当jsp解析这个标签的时候，在"<" 出触发doStartTag事件，在">"时触发doEndTag事件。一般doStartTag里进行逻辑操作，在doEndTag进行控制输出。代码如下：


<pre name="code" class="java">public class AreaInfoTag extends TagSupport{

private static final long serialVersionUID = 6306592846049270874L;

//标签数据的使用类型：new:新增；edit:修改；query:查询]	 
private String useType;	

// 选中父的标签 对应  AreaInfo 中的 SGuid 
private String parentCode;
	
// 选中的子标签 对应 AreaInfo 中的 SGuid
private String childrenCode;	
	
// 选中父标签回填属性]</p>
private String parentName;
	
// 选中子标签回填属性]
 private String childrenName;	
	
// select 的父类名]	 
private String parentClassName;	

// select 的子类名]
private String childrenClassName;

// 父标签的id名称]
private String parentId;
	
//子标签的id名称]
private String childrenId;
	
// 标签数据的生效时间]
private String beginDate;
	
// 标签数据的失效时间]
private String endDate;

private IAreaInfoService areaService;
@Override
public int doEndTag() throws JspException {
	JspWriter writer = pageContext.getOut();
	StringBuffer buf = new StringBuffer();
		
	try{
		if(areaService==null){
			areaService = (IAreaInfoService)SpringUtils.getBean("areaInfoService");
		}
		if(parentClassName==null||parentClassName.equals("")){
			buf.append("<select id=\""+parentId+"\" onchange=\"changeParent(this,'"+childrenId+"')\"; name=\""+parentName+"\">");
		}else{
			buf.append("<select id=\""+parentId+"\" onchange=\"changeParent(this,'"+childrenId+"')\"; name=\""+parentName+"\" class=\""+parentClassName+"\">");
		}
		buf.append("<option value=\"\">--请选择--</option>");
		List<AreaInfo> areaList = areaService.getAreaList(Constants.AREA_SUPER_SGUID, useType, beginDate, endDate);
		for (AreaInfo area : areaList) {
			if(area.getSGuid().trim().equals(parentCode.trim())){
				buf.append("<option selected=\"selected\" value=\""+StringUtil.getTrim(area.getSGuid())+"\">"+area.getSDictName()+"</option>");
			}else{
				buf.append("<option value=\""+StringUtil.getTrim(area.getSGuid())+"\">"+area.getSDictName()+"</option>");
			}
		}
		buf.append("</select>");
		if(childrenClassName==null||childrenClassName.equals("")){
			buf.append("<select id=\""+childrenId+"\" name=\""+childrenName+"\">");
		}else{
			buf.append("<select id=\""+childrenId+"\" name=\""+childrenName+"\" class=\""+childrenClassName+"\">");
		}
		
		buf.append("<option value=\"\">--请选择--</option>");	
		if(childrenCode!=null&&!childrenCode.equals("")){
			List<AreaInfo> subAreas = areaService.getAreaList(parentCode);
			for (AreaInfo area : subAreas) {
				if(area.getSGuid().trim().equals(childrenCode.trim())){
					buf.append("<option selected=\"selected\" value=\""+StringUtil.getTrim(area.getSGuid())+"\">"+area.getSDictName()+"</option>");
				}else{
					buf.append("<option value=\""+StringUtil.getTrim(area.getSGuid())+"\">"+area.getSDictName()+"</option>");
				}
			}
		}
		buf.append("</select>");
		System.out.println("buf:"+buf);
		writer.write(buf.toString());
		writer.flush();
	}catch(Exception e){
		e.printStackTrace();
	}
	return super.doEndTag();
}

public String getParentCode() {
	return parentCode;
}

public void setParentCode(String parentCode) {
	this.parentCode = parentCode;
}	

public String getChildrenCode() {
	return childrenCode;
}

public void setChildrenCode(String childrenCode) {
	this.childrenCode = childrenCode;
}

public String getParentName() {
	return parentName;
}

public void setParentName(String parentName) {
	this.parentName = parentName;
}

public String getChildrenName() {
	return childrenName;
}

public void setChildrenName(String childrenName) {
	this.childrenName = childrenName;
}

public String getParentId() {
	return parentId;
}

public void setParentId(String parentId) {
	this.parentId = parentId;
}
public String getChildrenId() {
	return childrenId;
}

public void setChildrenId(String childrenId) {
	this.childrenId = childrenId;
}

public String getParentClassName() {
	return parentClassName;
}

public void setParentClassName(String parentClassName) {
	this.parentClassName = parentClassName;
}

public String getChildrenClassName() {
	return childrenClassName;
}

public void setChildrenClassName(String childrenClassName) {
	this.childrenClassName = childrenClassName;
}

public String getUseType() {
	return useType;
}

public void setUseType(String useType) {
	this.useType = useType;
}

public String getBeginDate() {
	return beginDate;
}

public void setBeginDate(String beginDate) {
	this.beginDate = beginDate;
}

public String getEndDate() {
	return endDate;
}

public void setEndDate(String endDate) {
	this.endDate = endDate;
}
}


2. 编写tld 文件 每个自定义标签都必须在tld文件中声明，tld文件只不过一个xml文件。根元素是<taglib>,它包含一个或者多个<tag>标签，该元素用来声明定制标签。


		<?xml version="1.0" encoding="UTF-8" ?>
		<taglib xmlns="http://java.sun.com/xml/ns/j2ee"
		    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"
		    version="2.0">
		    <description>A tag library exercising SimpleTag handlers.</description>
		    <tlib-version>1.0</tlib-version>
		    <short-name>zw</short-name>
		    <uri>http://com.zlwy.frameTemplate/common/functions</uri>
		<tag>
			<description> AreaInfoTag </description>
			    <name>areaInfo</name>
			    <tag-class>com.zlwy.organ.tag.AreaInfoTag</tag-class>
			    <attribute>
			       <name>parentCode</name>
			       <required>false</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			    <attribute>
			       <name>childrenCode</name>
			       <required>false</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			     <attribute>
			       <name>parentClassName</name>
			       <required>false</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			     <attribute>
			       <name>childrenClassName</name>
			       <required>false</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			    <attribute>
			       <name>parentName</name>
			       <required>true</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			    <attribute>
			       <name>childrenName</name>
			       <required>true</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			     <attribute>
			       <name>parentId</name>
			       <required>true</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			    <attribute>
			       <name>childrenId</name>
			       <required>true</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			    <attribute>
			       <name>useType</name>
			       <required>true</required>
			       <rtexprvalue>false</rtexprvalue>
			    </attribute>
			    <attribute>
			       <name>beginDate</name>
			       <required>false</required>
			       <rtexprvalue>true</rtexprvalue>
			    </attribute>
			    
			</tag>

<taglib>  ： tld文件的根元素    （必须）

<taglib-version> :  此标签库的版本   （必须） 
<short-name>  : 当在JSP中使用标签时，此标签库首选或者建议的前缀。
<description> :描述信息

<uri>  ： 指定使用该标签库中标签的 URI




3. 在jsp中使用自定义标签 


	<pre name="code" class="html"><zw:areaInfo parentCode="${listPersonInsuranceTypeInfo.SWholeProvinceGuid}" parentClassName="content_content_select" childrenClassName="content_content_select" 
childrenName="listPersonInsuranceTypeInfo[${st.count - 1}].SWholeCityGuid" parentName="listPersonInsuranceTypeInfo[${st.count - 1}].SWholeProvinceGuid" parentId="pt${st.count-1}" 
useType="new" childrenId="cn${st.count - 1}" childrenCode="${listPersonInsuranceTypeInfo.SWholeCityGuid}">
</zw:areaInfo>

总结：


在平时的开发中jsp自定义标签经常被使用，从上面的例子中可以看出，自定义标签实现了特定的java类，封装了java代码编写的预定义行为，在运行时，标签被替换成相应的java代码。 简化了我们的jsp文件。



版权声明：本文为博主原创文章，未经博主允许不得转载。

花千骨与虐死人的源代码

曾几何时，你看到源代码就如同看花千骨，虐，如果你是白子画，你怎么想，用爱记 掌控内心城府的人

版权声明：本文为博主原创文章，未经博主允许不得转载。

CSUOJ 1336 Interesting Calculator  (spfa算法)
题目：http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1336 
题意：
分析：spfa资料1 spfa资料2
代码：
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
typedef long long LL;
const int maxn = 1e5+6;
const LL INF= 9e18;
int X,Y; 
bool visit[maxn];
int step[maxn],f[5][20];
LL cost[maxn];
queue <int > q; 
inline void slack(int u,int v,int w) //松弛操作 
{
	if(cost[v]>cost[u]+w || cost[v]==cost[u]+w && step[v]>step[u]+1)
	{
		cost[v]=cost[u]+w;
		step[v]=step[u]+1;
		if(!visit[v])
		{
			q.push(v);
			visit[v]=true;
		}
	}
}
void Init()
{
	memset(visit,false,sizeof(visit));
	fill(step,step+maxn,INF);
	fill(cost,cost+maxn,INF);
}
void spfa()
{
	q.push(X);
	visit[X]=1;
	step[X]=0;
	cost[X]=0;
	while(!q.empty())
	{
		int temp=q.front();
		q.pop();
		visit[temp]=false; 
		for(int i=0;i<10;i++)
			if(temp*10+i<=Y)
				slack(temp,temp*10+i,f[0][i]);
		for(int i=0;i<10;i++)
			if(temp+i<=Y)
				slack(temp,temp+i,f[1][i]);
		for(int i=0;i<10;i++)
			if(temp*i<=Y)
				slack(temp,temp*i,f[2][i]);
	}
}

int main()
{
	int ncase=1;
	while(scanf("%d%d",&X,&Y)!=EOF)
	{
		for(int i=0;i<3;i++)
			for(int j=0;j<10;j++)
				scanf("%d",&f[i][j]);
		Init();
		spfa();
		printf("Case %d: %I64d %d\n",ncase++,cost[Y],step[Y]);
	}
	return 0;
}
DNS解析过程详解








DNS解析过程详解









 
前言
 
最近这几天学习一下DNS相关的知识,为啥要学习DNS的知识呢?这个问题问得好,在回答这个问题之前,你得先明白1+1为啥2,如果你明白了,就不需要学DNS了,因为你可以去学数学了,不用走程序员这条路了,如果你不知道1+1为啥等于2,那就来吧,一起学.
 
 
 
根域
 
就是所谓的’.’(点号),其实我们的网址www.baidu.com在配置当中总应该是www.baidu.com.(还有最后一个点),一般我们在浏览器里输入时会省略后面的点,而这也已经成为了习惯.
 
根据服务器我们知道由13台,但是这是错误的观念.
 
根据服务器只是具有13个IP地址,但机器数量去不是13台,因为这些IP地址解除了任播的技术,所以我们可以在全球设立这些IP的镜像站点,你访问的这个IP并不是唯一的那台主机.
 
具体的镜像分布可以参考基维百科.这些主机的内容都是一样的.
 
 
 
域的划分
 
根域下来就是顶级域或者叫做一级域.
 
有两种划分方式,一种互联网刚兴起时的按照行业性质划分的com,net等,一种是按国家划分的如cn,jp等,具体是多少你可以自己去查.
 
每个域都会有域名服务器,也叫全为权威域名服务器.
 
baidu.com就是一个顶级域名,而www.baidu.com却不是一个顶级域名,它是在baidu.com这个域里的一个叫做www的主机.
 
一级域之后还有二级域,三级域,只要是我买了一个顶级域,并且我搭建了自己的BIND服务器(或者其他软件搭建的)注册到互联网中,那么我就可以随意在前面多加几个域了(当然长度是有限制的).
 
例如,a.www.baidu.com,在这个网址中,www.baidu.com变成了一个二级域而不是一台主机,主机名是a
 
 
 
域名服务器
 
能提供域名解析的服务器,上面的记录类型可以是A记录,NS记录,MX记录,CNAME记录等.
 
A记录是什么意思呢?就是记录一个IP地址和一个主机名字,比如我这个域名服务器所在的域test.baidu.com,我们知道这是个二级的域名,然后我在这里面有一条A记录,记录了主机为a的IP,查到了就返回给你了.
 
如果我现在要想baidu.com这个域名服务器查询a.test.baidu.com,那么这个顶级域名服务器就会发现你请求的这个网址在test.baidu.com这个域中,我这里记录了这个二级域的域名服务器test.baidu.com的NS的IP.我返回给你这个地址你再去查主机为a的主机.
 
这些域内的域名服务器都成为权威服务器,直接提供DNS查询服务.(这些服务器可不会做递归).
 
 
 
解析过程
 
那么我们的DNS是怎么解析一个域名的呢?
 
1.现在我有一台计算机,通过ISP接入了互联网,那么ISP就会给我分配一个DNS服务器,这个DNS服务器不是权威服务器,而是相当于一个代理的DNS解析服务器,他会帮你迭代权威服务器返回的应答,然后把最终查到的IP返回给你.
2.现在我的计算机要想这台ISPDNS发起请求查询www.baidu.com这个域名了(这里其实准确来说不是ISPDNS,而应该是用户自己电脑网络设置里的DNS,不一定是ISPDNS.比如也有可能你手工设置了8.8.8.8).
3.ISPDNS拿到请求后,先检查一下自己的缓存中有没有这个地址,有的话就直接返回.这个时候拿到的IP地址,会被标记为非权威服务器的应答.
4.如果缓存中没有的话,ISPDNS会从配置文件里面读取13个根域名服务器的地址(这些地址是不变的,直接在BIND的配置文件中)
5.然后像其中一台发起请求
6.根据服务器拿到这个请求后,知道它是com.这个顶级域名下的,所以就会返回com域中的NS记录,一般来说是13台主机名和IP
7.然后ISPDNS向其中一台再次发起请求,com域的服务器发现你这请求是baidu.com这个域的,我一查发现了这个域的NS,那我就返回给你,你再去查.(目前百度由4台baidu.com的顶级域名服务器)
8.ISPDNS不厌其烦的再次向baidu.com这个域的权威服务器发起请求,baidu.com收到之后,查了下由www这台主机,就把这个IP返回给你了.
9.然后ISPDNS拿到了之后,将其返回给了客户端,并且把这个保存在高速缓存中.
 
 
 
小小的结一下
 
其中文章中涉及到了A记录,NS记录等一些记录的名字,这些没啥,百度上都有啊,就是一些名称的缩写.
 
 
 
 
 
 
 
 


 
 
 
 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

win7设置电脑保护眼睛颜色（终极方法，提供两种颜色选择）
整了大半天终于把电脑的保护色设置好了。方法如下：
主要是替换文件C:\Windows\Resources\Themes\Aero\Shell\NormalColor\shellstyle.dll，按下文档中的步骤替换即可。

具体的方法在下载文件中有个word文档。请务必按照步骤来。否则可能不成功。
文档中提供了两种颜色，根据个人喜好替换。
备注：请将dll中的（**）去掉，即:改为shellstyle.dll
下载无需积分。
文件下载地址：http://download.csdn.net/detail/a358763471/9045857

版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer——数值的整数次方
题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
下面来看代码：
public class PowerSolution {
 public static double Power(double base, int exponent) {
      //当底数为0，指数小于0，则为非法情况。
     if (equal(base,0.0)&&exponent<0) {
        return 0.0f;
    }
     //当指数小于0的时候即求该数的倒数再乘方
       if (exponent<0) {
           int absExponent = -exponent;
           double result = PowerWithNonNegative(base, absExponent);
           result = 1.0/result;

           return result;
    }else {
        return PowerWithNonNegative(base, exponent);
    }
  }

  //自定义方法来判断两个double的数是不是相等，因为有误差所以在范围内都认为相等
 public static boolean equal(double a, double b){
     if (((a-b)>-0.00000001)&&((a-b)<0.00000001)) {
        return true;
    }else {
        return false;
    }

 }


 public static double PowerWithNonNegative(double base, int exponent){
        if(exponent==0){
            return 1;
        }

        if(exponent==1){
            return base;
        }

       double result = PowerWithNonNegative(base,exponent>>1);
       result*=result;

        //如果是奇数次方的情况，最终除2余1要与base相乘
        if((exponent&0x1)==1){
            result *=base;
        }
        return result;
 }
 }

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

linux终端中的通配符

通配符是一种特殊语句，主要有星号（*）和问号（?），用来对对字符串进行模糊匹配（比如文件名，参数名）。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。


终端里面输入的通配符是由 Shell 处理的，不是由所涉及到命令语句处理的，它只会出现在命令的“参数值”里（它不用在 命令名称里， 命令不记得，那就用Tab补全）。当 Shell 在“参数值”中遇到了通配符时，Shell 会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。总之，通配符 实际上就是一种 Shell 实现的路径扩展功能。在 通配符被处理后, Shell 会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。


先使用 touch 命令创建 2 个文件，后缀都为 txt：

$ touch adsfasd.txt wergjlkas.txt


可以给文件随意命名，假如过了很长时间，你已经忘了这两个文件的文件名，现在你想在你大堆其他文件中找到这两个文本文件，就可以使用通配符：

$ ls *.txt
在创建文件的时候，如果需要一次性创建多个文件，比如：“love_1_linux.txt，love_2_linux.txt，... love_10_linux.txt”。在 Linux 中十分方便：

$ touch love_{1..10}_linux.txt



Shell 常用通配符：






字符

含义





*

匹配 0 或多个字符



?

匹配任意一个字符



[list]

匹配 list 中的任意单一字符



[!list]

匹配 除list 中的任意单一字符以外的字符



[c1-c2]

匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]



{string1,string2,...}

匹配 sring1 或 string2 (或更多)其一字符串



{c2..c2}

匹配 c1-c2 中全部字符 如{1..10}






版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ 1194 [HNOI2006]潘多拉的盒子 BFS
题意:链接
方法: BFS
解析:
这题第一次没读懂的一定不止我一个233
这题其实挺好的。
不过考试的时候我没好好想，可惜了。
首先这题显然可以大块分成两部分。
第一块就是看谁是谁的升级。
第二块是求一个最长路了。
显然第二块是白给的，因为数据范围在那。
所以就在于第一块怎么来搞。
第一块的话因为数据小，所以我们考虑来搞一个s^2的循环来验证每两个自动机。
怎么验证？
先说一个神奇的做法。
随机搜索法。
设一个步数(保证复杂度)，然后两个自动机里开始跑这么多步，每一次随机向左向右走。
如果这么多步没有跑出B不包含A的子串，则认定B是A的升级。
这只是一个方法..但是正确性….也好卡。
所以正解是什么呢。
我们只需要BFS一下就好了嘛。
每两个自动机，你向左我也向左，你向右我也向右。
如果某个时刻A中跑到了一个输出节点而B没有，则B一定不是A的升级。
因为A有一个B不包含的子串。
所以每一次款搜是O(n*n)的复杂度？
总复杂度O(s^2*n^2)可过。
代码:
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 55
using namespace std;
int map[N][N][2];
int vip[N][N];
int v[N][N];
int lINK[N][N];
int s,n,m;
struct element
{
    int x,y;
};
int check(int s1,int s2)
{
    memset(v,0,sizeof(v));
    queue<element>q;
    element fir;
    fir.x=1,fir.y=1;
    q.push(fir);
    while(!q.empty())
    {
        element u=q.front();
        q.pop();
        if(vip[s1][u.x]&&!vip[s2][u.y])return 0;
        element tmp;
        tmp.x=map[s1][u.x][0],tmp.y=map[s2][u.y][0];
        if(!v[tmp.x][tmp.y])v[tmp.x][tmp.y]=1,q.push(tmp);
        tmp.x=map[s1][u.x][1],tmp.y=map[s2][u.y][1];
        if(!v[tmp.x][tmp.y])v[tmp.x][tmp.y]=1,q.push(tmp);
    }
    return 1;
}
int main()
{
    scanf("%d",&s);
    for(int i=1;i<=s;i++)
    {
        scanf("%d%d",&n,&m);
        for(int j=1;j<=m;j++)
        {
            int x;
            scanf("%d",&x);
            x++;
            vip[i][x]=1;
        }
        for(int j=1;j<=n;j++)
        {
            int x,y;
            scanf("%d%d",&x,&y);
            x++,y++;
            map[i][j][0]=x,map[i][j][1]=y;
        }
    }
    memset(lINK,-0x3f,sizeof(lINK));
    for(int i=1;i<=s;i++)
    {
        for(int j=1;j<=s;j++)
        {
            if(i==j)continue;
            if(check(i,j))
            {
                if(lINK[j][i]<0)
                    lINK[i][j]=1;
            }
        }
    }
    int ans=0;
    for(int k=1;k<=s;k++)
    {
        for(int i=1;i<=s;i++)
        {
            for(int j=1;j<=s;j++)
            {
                if(lINK[i][k]>0&&lINK[k][j]>0&&lINK[i][k]+lINK[k][j]>lINK[i][j])
                {
                    lINK[i][j]=lINK[i][k]+lINK[k][j];
                    ans=max(lINK[i][j],ans);
                }
            }
        }
    }
    printf("%d\n",ans+1);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

2015湖南长沙生存费用粗估


                  2015湖南长沙生存费用粗估表

 
 
 
目录
第一部分 估算原由3
第二部分 估算方法3
第三部分 中国长沙生存费用估算表3




第一部分 估算原由

前一段时间国家每年一度的平均工资发布了。国家统计局发布的2014年平均工资主要数据显示，全国城镇非私营单位就业人员年平均工资56339元，全国城镇私营单位就业人员年平均工资36390元。随后不久湖南平均工资也公布了，分别是城镇非私营单位47117元和城镇私营单位30568元。均遭到了大多数网友的吐槽。

虽然政府统计数据的效力已经众所周知了。也许政府公布的数据与给政府自己看的不一样。如内参之类的是普通百姓看不到的。国家做这样的统计也是为了清楚掌握经济发展情况、了解居民生活水平和生产力概况。基于这样的目的，我认为仅仅统计居民平均工资是不够的，还需要统计居民生活费用才能全面知晓居民生活状况、推测生产力高低。

 
第二部分 估算方法

本人非政府人员，因而没有大规模统计的条件；也不是经济专业人士，因而不能做专业统计；只能根据自己的生活经验来粗略估计，因而错漏之处难免；估算地区也只限于中国湖南长沙市，希望有识之士指正修订、补充其他地区数据。为方便有兴趣人员修正、补充，本文统计结果表可在CSDN下载频道下载，下载链接：http://download.csdn.net/detail/songhtao/9049493 主要估算内容包括：衣食住行和附加费用。
第三部分 中国长沙生存费用估算表

 

本估算表以中国长沙地区为例，估算的是维持生计所必须的费用包括衣食住行医学和附加费用部分，根据政府计划生育按夫妻，小孩和一老人共住，以较典型的四口之家计算。

 

 

 
表格 12015湖南长沙生存费用粗估表




项目


样本


劳动者平均




 


月耗


年用


费用比重


说明


年用


样本/平均（占比）




衣


0


0


0


沿用旧衣，基本0费用


 


 




食


1000


12000


0.142531357


够用一荤一素维持基本生活，不可吃零食


 


 




住


3250


39000


0.46322691


以长沙城市中心区一环每平12000 * 面积75 = 90万，或三环近城郊每平7500 * 面积120 = 90万；装修费15万；银行贷款利息90万；共195万，50年使用寿命计算


 


 




行


0


0


0


就近工作省交通费


 


 




小计（A）


4250


51000


0.605758267


 


 


 




水费


20.83333333


250


0.002969403


今年阶梯水价，费用会更多


 


 




电费


125


1500


0.01781642


按阶梯最低价每度0.60计


 


 




气费


20.83333333


250


0.002969403


今年阶梯气费，费用会增加


 


 




上网费


100


1200


0.014253136


电信宽带经济套餐


 


 




物业费


216


2592


0.030786773


每月每平1.80 * 面积120


 


 




小计（B）


482.6666667


5792


0.068795135


 


 


 




医疗费


250


3000


0.035632839


老人小孩易生病


 


 




学费


833.3333333


10000


0.118776131


义务教育，上过知道


 


 




社保（养老、医疗）


1200


14400


0.171037628


政府公布2015湖南平均工资城镇非私营单位47117元。因很多居民需个人缴纳统筹和自交部分，故按48000基数 缴费率30%全额统计粗估。


 


 




小计（c）


2283.333333


27400


0.325446598


 


 


 




红白喜事礼金/其他


0


0


0


无花费能力


 


 




税金等


0


0


0


无缴纳能力


 


 




小计（d）


0


0


0


 


 


 




合计（A + B + c + d）


7016


84192


1


 


 


 





 

 

注：1.本文计算的是基本生存费用故不包含零食、旅游、社交等费用，有兴趣者可扩充。

    2.生存费包括劳动者的简单生产和再生产因而包括子女教育学习费。

    3.劳动者的生活支撑保养包括住房、医疗、社保。

    4.水气等小额项目计算的原因在于，现在生活自理，即使只少一分钱（虽然现在已基本没有以分为单位计价的项目）也会被停电、停水。故有计算必要。


                
5.劳动者平均状况，无资料无法统计。
﻿﻿
﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

openssl api - 1
http://www.openssl.org/docs/manmaster/ssl/OpenSSL_add_ssl_algorithms.html
SSL_library_init

NAME
SSL_library_init, OpenSSL_add_ssl_algorithms, SSLeay_add_ssl_algorithms - initialize SSL library by registering algorithms
SYNOPSIS
 #include <openssl/ssl.h>

 int SSL_library_init(void);
 #define OpenSSL_add_ssl_algorithms()    SSL_library_init() 
 #define SSLeay_add_ssl_algorithms()     SSL_library_init()  （三个函数都是一样的定义。）
DESCRIPTION
SSL_library_init() registers the available SSL/TLS ciphers and digests.
OpenSSL_add_ssl_algorithms() and SSLeay_add_ssl_algorithms() are synonyms for SSL_library_init().
NOTES
SSL_library_init() must be called before any other action takes place. SSL_library_init() is not reentrant.
WARNING
SSL_library_init() adds ciphers and digests used directly and indirectly by SSL/TLS.
EXAMPLES
A typical TLS/SSL application will start with the library initialization, and provide readable error messages.
 SSL_load_error_strings();                /* readable error messages */
 SSL_library_init();                      /* initialize library */
RETURN VALUES
SSL_library_init() always returns "1", so it is safe to discard the return value.
NOTES
OpenSSL 0.9.8o and 1.0.0a and later added SHA2 algorithms to SSL_library_init(). Applications which need to use SHA2 in earlier versions of OpenSSL should call OpenSSL_add_all_algorithms() as well.


版权声明：本文为博主原创文章，未经博主允许不得转载。

Wind River Intelligent Device Platform XT 2.0.4.27
2692407267@qq.com，更多内容请关注http://user.qzone.qq.com/2692407267
Wind River Intelligent Device Platform XT 2.0.4.27，从2.0.3开始增加了Wind
 River Edge Management System 1.0 Agent，
图就不贴了，后面有时间慢慢补


版权声明：本文为博主原创文章，未经博主允许不得转载。

二十年目睹之怪状  序


版权声明：本文为博主原创文章，未经博主允许不得转载。

轻松python文本专题-字符串对齐
场景：
字符串对齐
python提供非常容易的方法，使得字符串对齐
>>> print("abc".center (30,'-'))
-------------abc--------------                       
>>> print("abc".ljust (30)+'|')
abc                           |
>>> print("abc".rjust (30))
                           abc
>>> 

分别是center，ljust，rjust
三个方法默认填充是空格，也可以使用其他字符填充
 
就说到这里，谢谢大家
------------------------------------------------------------------
点击跳转零基础学python-目录

版权声明：本文为博主原创文章，未经博主允许不得转载。

解决双系统下如何完全卸载Ubuntu系统
我就是这么一个爱倒腾的人，装了win7，然后又装个Linux，Linux玩腻了，如今想装个黑苹果，因此想把Linux给卸了。这个可不能乱动，万一出现了问题，电脑上这么多资源该怎么办。不过还是有办法解决的。如何完全卸载双系统（win7 vs linux）的Linux呢？ 
1、第一步：下载EasyBCD2.1.2。可以选择中文，可以选择英文。 
2、选择BCD部署，在MBR配置选项中选择在MBR中安装Windows vista/7的Bootloader，最后编写MBR 
 
3、接下来直接鼠标右键‘计算机’，选择‘管理’→‘磁盘管理’，找到你为ubuntu系统预留的分区，右键点击‘删除卷’。变成空闲分区了，用来新建逻辑磁盘，黑苹果走起啊，呵呵！ 
4、重启电脑。你会惊奇的发现只剩下一个win7了。好了，万事大吉……

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

使用HTTP协议从网上获取资源下载到本地(1)
创建工具类：
package com.blueZhang;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;

public class Demo4 {
	// 获取服务器端资源的字节输入流
	public static InputStream getInputStream(String path) {
		//
		URL url;
		//
		try {
			url = new URL(path);
			//
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();
			//
			conn.setRequestMethod("GET");
			//
			conn.setConnectTimeout(5000);
			//
			conn.setDoInput(true);
			//
			if (conn.getResponseCode() == 200) {
				//
				InputStream is = conn.getInputStream();

				return is;
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;

	}

	// 读取服务器端的资源
	public static void writeToFile(InputStream input) {
		//
		FileOutputStream fos = null;
		//
		try {
			//
			fos = new FileOutputStream("file/1.txt");
			//
			byte[] arr = new byte[1024];
			//
			int len = 0;
			//
			while ((len = input.read(arr)) != -1) {
				//
				fos.write(arr, 0, len);
				//
				fos.flush();
			}

		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (input != null) {
				try {
					input.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

			}
			if (fos != null) {
				try {
					fos.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

			}
		}

	}

	public static void main(String[] args) {

	}

}
 创建测试类
package com.blueZhang;

import java.io.InputStream;

public class Test {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		String path = "http://news.xinhuanet.com/ttgg/2015-08/23/c_1116344298.htm";
		InputStream in = HttpUtils.getInputStream(path);
		HttpUtils.writeToFile(in);
		
	}

}






版权声明：本文为博主原创文章，未经博主允许不得转载。

二十年目录之怪状-代表


版权声明：本文为博主原创文章，未经博主允许不得转载。

记一次当面试官的经历
　昨天不小心当了一把面试官，感觉比自己被面试还紧张（瀑布汗），但是总体来说还算应对沉稳，嘻嘻。
　面试者三十多岁，四年Android开发经验，按照他的年龄我的感觉是应该应聘项目经理之类更高的职位，把这个疑问告诉了老大，老大说哪有这么多经理给他当啊，哈哈哈，年龄不代表水平。还有一点是四年换了四次工作，给人一种极不踏实的感觉。还有是懂ios开发，老大说最不喜欢这种什么都会的，都会都不精等于都不会啊。
　首先自我介绍啦，巴拉巴拉，说了说自己做的项目。说说自定义过哪些控件，动画吧。支支吾吾，大体说了Dialog，Tab控件。说很多时候用第三方控件，用了哪些第三方控件？又支支吾吾。一听就知道平时不注重总结，哎。那下一话题吧，遇到过哪些性能方面的问题，是怎么解决的？又支支吾吾。下一话题，Android异步处理机制是怎样的？Handler，Looper，MessageQueue巴拉巴拉。下一话题，有没有接触过消息推送方面的方案？有，xmpp，极光推送，巴拉巴拉，看过mqtt代码。有没有写过mqtt客户端代码？没有。又扯了点其他的，最后想问点Java基础，又觉得没有必要了。
　权利翻转环节。有什么问题要问吗？有，介绍一下你们的项目情况吧，巴拉巴拉。有自己的软件架构吗？是自己写的吗？借鉴的开源架构。你们会关注新技术吗，比如阿里新出的热升级技术，MVP模式等等？不用热升级，不用MVP模式。
　几点感受： 
 1. 面试官想听的不是干巴巴的技术，而是你使用技术的活生生的经历。 
 2. 面试官很希望知道你在某一方面做了比较深入的研究。 
 3. 最后就是年龄真的不代表水平。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 3336 Count the string（KMP+DP）


Count the string
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 6558    Accepted Submission(s): 3037



Problem Description

It is well known that AekdyCoin is good at string problems as well as number theory problems. When given a string s, we can write down all the non-empty prefixes of this string. For example:
s: "abab"
The prefixes are: "a", "ab", "aba", "abab"
For each prefix, we can count the times it matches in s. So we can see that prefix "a" matches twice, "ab" matches twice too, "aba" matches once, and "abab" matches once. Now you are asked to calculate the sum of the match times for all the prefixes. For "abab",
 it is 2 + 2 + 1 + 1 = 6.
The answer may be very large, so output the answer mod 10007.


 


Input

The first line is a single integer T, indicating the number of test cases.
For each case, the first line is an integer n (1 <= n <= 200000), which is the length of string s. A line follows giving the string s. The characters in the strings are all lower-case letters.


 


Output

For each case, output only one number: the sum of the match times for all the prefixes of s mod 10007.

 


Sample Input

1
4
abab


 


Sample Output

6


 




题目大意：
给出一个字符串，输出每个前缀在原串中出现的次数总和。

解题思路：
n最大可以达到200000，如果对于每个前缀用一次KMP会TLE。
首先定义一个tmp数组，tmp[i]表示以i结尾的字符串的所有前缀出现次数之和。
KMP的Next数组保存的是从s[0]到s[i]的最大公共前后缀长度，即从s[0]到s[Next[i]-1]与s[i-Next[i]]到s[i-1]这一点的字符串是完全重合的。所有以i结尾的字符串的所有前缀出现次数之和即tmp[i]为以Next[i]-1结尾的字符串的所有前缀出现次数之和再加上1。

所有状态转移方程就是tmp[i]=(tmp[Next[i-1]]+1)%MOD。
参考代码：

#include<map>
#include<set>
#include<stack>
#include<queue>
#include<cmath>
#include<ctime>
#include<vector>
#include<cctype>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long LL;
const double pi=3.141592653;
const double eps=1e-10;
const int INF=0x3f3f3f3f;
const int MOD=10007;
const int MAXN=2e6+50;

int n,Next[MAXN],tmp[MAXN];
char a[MAXN];

void getNext(char* B)
{
    Next[0]=0;
    for(int i=1; i<n; i++)
    {
        int k=Next[i-1];
        while(B[i]!=B[k]&&k)
            k=Next[k-1];
        Next[i]=B[i]==B[k]?k+1:0;
    }
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
#endif // ONLINE_JUDGE
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%s",&n,a);
        getNext(a);
        int ans=0;
        memset(tmp,0,sizeof(tmp));
        for(int i=1;i<=n;i++)
        {
            tmp[i]=(tmp[Next[i-1]]+1)%MOD;
            ans=(ans+tmp[i])%MOD;
        }
        printf("%d\n",ans%MOD);
    }
    return 0;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

Neural Networks for Machine Learning by Geoffrey Hinton （6）


Overview of mini-batch gradient descent
错误面
Full Batch Learning 的收敛性问题
学习率问题
随机梯度下降法
2类学习算法
基本批梯度下降法


各种批梯度下降法中的小技巧
权重值初始化
中心化输入Shifting the inputs
均一化输入Scaling the inputs
更彻底的方法去除相关性
多层神经网络中容易出现的问题
4种加速批梯度下降的方法
动量方法
动量的直观理解
动量公式
极限速度
动量的改进版本


对不同权重使用单独的自适应学习率
思想的初衷
一种可行的独立调整方式


提高自适应学习率效果的若干技巧
RMSProp把梯度平均修正
Rprop仅仅使用梯度的符号
为什么Rprop不能用在 mini-batches上面
RMSPropmini-batch 版本的Rprop







Overview of mini-batch gradient descent
错误面

线性神经元在均方误差代价函数的错误面是一个抛物面，横截面是椭圆。
对于多层神经元、非线性网络，在局部依然近似是抛物面。

Full Batch Learning 的收敛性问题
full batch 的方式虽然是朝着梯度最大的方向下降，但是当错误横截面不是圆形的时候，前进的方向并不指向错误最小点，如图1。 
 
 
图1 

学习率问题
如果学习率过大，权重会在错误面上面来回震荡，如图2，我们希望 
- 在那些梯度较小，但是连续的方向上，快速前进。 
- 在那些梯度较大，但是不连续的方向上，缓慢移动。 
 
 
图2 

随机梯度下降法
如果数据集足够充分，那么用一半的数据训练算出来的梯度与用全部数据训练出来的梯度是几乎一样的。

极限情况就是每次只用1个样本进行训练，这就是在线（online）学习。

批梯度下降法（Mini-batches）通常比在线学习要好： 
- 更少的计算量。 
- 矩阵乘法跟适用于GPU。

批梯度下降法需要在训练样本选取上尽量均衡，比如随机选取各类。

2类学习算法

使用全数据集的方法（如 non-linear conjugate gradient，非线性联合梯度法）。
使用批数据集的批梯度法，通常对于大型神经网络与大型数据集，批梯度下降法更合适，而mini-batch也要选取地足够大，这样在计算上会更高效。

基本批梯度下降法
设置一个初始学习率： 
- 如果错误率持续变得糟糕或者剧烈震荡，需要减小学习率。 
- 如果错误率基本上是平稳下降，但是非常缓慢，那么应该增加学习率。
在批梯度下降快要结束前，应该尽量减小学习率：

因为在不同的mini-batch之间是有扰动成分的，减小学习率可以消除这个效应。

当错误率不再下降时，也需要减小学习率。

这个错误率是指的验证（validation）数据集，与训练数据集和测试数据集相互独立。

各种批梯度下降法中的小技巧
权重值初始化
如果两个神经元的权重初始值相同，输入和输出层相同，那么它们将不能学习到不同的特征。因此需要使用随机初始化方法来打破这种对称性。 
如果一个神经元输入端很多，那么这些输入权重的微小改变将会使得这个神经元反应过于剧烈。


因此一般需要按照 fan−in‾‾‾‾‾‾‾‾√\sqrt {{\rm{fan - in}}}  等比例初始化权重。
也可以按照相同的方式等比例放缩学习率。


中心化输入（Shifting the inputs）
中心化即把输入样本全部减去全体样本的均值，这样输入样本具有0均值。 
这样做的好处是能够平衡错误面，尽量扩大样本差异性。
均一化输入（Scaling the inputs）
均一化将数据都转化到单位长度上，这样可以把错误面变圆，如图3： 
 
 
图3 

更彻底的方法－去除相关性
对于线性神经元，使用 PCA (Principal Component Analysis) 方法可以去除掉各个成分之间的相关性。

对于球形错误面，梯度方向直接指向最小值处。

多层神经网络中容易出现的问题

如果初始学习率较大，隐含层的权重值将会变成很大的负值，从而梯度会变得很小，错误率会停止下降。

这是因为权重值跑道了一个很远的平面( plateau )上了，而这常常被错误认为是局部极值。

对用于分类的神经网络而言，网络很容易学会一种策略，这种策略让网络按照它应该输出为1的次数，成比例作出输出。

然而让网络学会更多关于输入的信息，会花费漫长的时间。这也因为是到了一个平面上，常常也被错误认为是到了局部最优值。


4种加速批梯度下降的方法

使用动量－使用权重的速度而非位置来改变权重。
针对不同权重参数使用不同学习率。 
RMSProp－这是Prop 的均方根 ( Mean Square ) 改进形式，Rprop 仅仅使用梯度的符号，RMSProp 是其针对 Mini-batches 的平均化版本。

Riedmiller, M., and H. Braun (1993), “A Direct Adaptive Method for Faster Backpropagation Learning: the Rprop Algorithm”, in: IEEE International Conference on Neural Networks, San Francisco, CA, pp. 586-591. 

利用曲率信息的最优化方法。

动量方法
动量的直观理解
如图4，小球在错误面上，最初朝梯度方向启动，但一旦具有速度，就不再完全按照梯度最大的方向前进了。 
- 动量使得其安装原先的方向运行。 
- 动量通过和之前梯度方向的结合显著减小在曲率交大处的震荡现象。 
- 动量的结果是让权重以一种温和并连续的梯度方向前进。 
 
 
图4 

动量公式

v(t)=αv(t−1)−ε∂E∂w(t)v\left( t \right) = \alpha v\left( {t - 1} \right) - \varepsilon \frac{{\partial E}}{{\partial w}}\left( t \right)

α \alpha  是衰减系数，是一个比1略小的常数。权重的改变量等于此刻的速度。

Δw(t)=v(t)=αv(t−1)−ε∂E∂w(t)=αΔw(t−1)−ε∂E∂w(t)\begin{array}{c}
\Delta w\left( t \right) = v\left( t \right)\\
 = \alpha v\left( {t - 1} \right) - \varepsilon \frac{{\partial E}}{{\partial w}}\left( t \right)\\
 = \alpha \Delta w\left( {t - 1} \right) - \varepsilon \frac{{\partial E}}{{\partial w}}\left( t \right)
\end{array} 

极限速度

v(∞)=11−α(−ε∂E∂w)v\left( \infty  \right) = \frac{1}{{1 - \alpha }}\left( { - \varepsilon \frac{{\partial E}}{{\partial w}}} \right)

由于α \alpha 接近1，可以看出极限速度会很大。在训练初始时刻，权重参数可能很大，需要把α \alpha 设置较小（如0.5）；当后期大权重系数消失后，权重可能卡在局部最优值中，这时需要将α \alpha 平滑过渡到最终值（0.9或0.99）。

如果没有使用动量，会造成剧烈的震荡现象。

动量的改进版本
Ilya Sutskever 提出了一种新的动量，如图5，核心思想是先按照之前的方向前进，计算新位置的梯度作为修正，然后按照合方向更新权重。本质上是先赌再改的方式。传统方法是先改再赌。

Sutskever, Ilya, et al. “On the importance of initialization and momentum in deep learning.” Proceedings of the 30th international conference on machine learning (ICML-13). 2013.

 
 
图5 

对不同权重使用单独的自适应学习率
思想的初衷
对于多层神经网络结构，针对不同隐含层的最合适的学习率可能相差甚远。
一种可行的独立调整方式
定义局部增益 ( local gain )  gij{g_{ij}}作为权重增量的调整系数，根据梯度的符号是否改变来相应调整权重的增量：

Δwij=−εgij∂E∂wijif(∂E∂wij(t)∂E∂wij(t−1))>0thengij=gij(t−1)+0.05elsegij=gij(t−1)∗0.95\begin{array}{l}
\Delta {w_{ij}} =  - \varepsilon {g_{ij}}\frac{{\partial E}}{{\partial {w_{ij}}}}\\
\begin{array}{*{20}{c}}
{if}&{\left( {\frac{{\partial E}}{{\partial {w_{ij}}}}\left( t \right)\frac{{\partial E}}{{\partial {w_{ij}}}}\left( {t - 1} \right)} \right) > 0}
\end{array}\\
\begin{array}{*{20}{c}}
{then}&{{g_{ij}} = {g_{ij}}\left( {t - 1} \right) + 0.05}
\end{array}\\
\begin{array}{*{20}{c}}
{else}&{{g_{ij}} = {g_{ij}}\left( {t - 1} \right)*0.95}
\end{array}
\end{array}


这种策略保证了当震荡开始时，局部增益显著下降。
如果梯度是完全随机的，那么局部增益将会收敛于1附近。

提高自适应学习率效果的若干技巧
 
限制增益在合理范围内，如 [0.1,10] \left[ {0.1,10} \right]。
使用Full Batch学习方式或者 Big mini-batches：

这保证了梯度符号的改变并非是由 mini-batch 的采样误差导致。

将自适应学习率与动量结合。
自适应学习率只能处理维度对齐( axis-aligned )的情况。 

  而动量却并不受影响。
RMSProp：把梯度平均修正
Rprop：仅仅使用梯度的符号
由于不同权重的梯度值差别巨大，因此选取一个全局的学习率很困难。 
对于full batch learning，我们能够只使用梯度的符号，对所有权重都更新相同的大小。

Rprop将只利用梯度符号与针对性单独更新各权值这两种思路结合了起来。 
  - 如果最近两次梯度符号相同，则乘以 1.2。 
  - 如果最近两次梯度符号相异，则乘以0.5。 
  - 让步长限定在合理范围内，如0.00001到50之间。

为什么Rprop不能用在 mini-batches上面？
因为不同mini-batch之间是有采样误差的，这样只要出现一次符号相异，之前积累的步长就完全被抵消了。
RMSProp：mini-batch 版本的Rprop
强制使得每次梯度的调整值非常接近：

vt=αvt−1+(1−α)(∇f)2θt=θt−1+ε∇f(θt−1)vt‾‾√+λ \begin{array}{l}
{v^t} = \alpha {v^{t - 1}} + \left( {1 - \alpha } \right){\left( {\nabla f} \right)^2}\\
{\theta ^t} = {\theta ^{t - 1}} + \varepsilon \frac{{\nabla f\left( {{\theta ^{t - 1}}} \right)}}{{\sqrt {{v_t}}  + \lambda }}
\end{array}  
  Dauphin, Yann N., et al. “RMSProp and equilibrated adaptive learning rates for non-convex optimization.” arXiv preprint arXiv:1502.04390 (2015).


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU2089 不要62(数位DP入门经典题目)
昨天做了一道很奇怪的数字题，不知道怎么做，今天才知道是数位DP ……我来学习学习。 
传送门 
大意：给定区间[n,m][n,m],求在n到m中没有“62“或“4“的数的个数。如62315包含62，88914包含4，这两个数都是不合法的。
思路：做这道题我们就要用到数位DP了，我们可以线预处理出一个F数组。用F[i,j]F[i,j]代表开头是j的i位数中不含”62”或”4”的数有几个。这样我们很好写出一个状态转移方程F[i,j]=F[i−1,k]|其中j≠4且当j=6时k≠2F[i,j] = F[i-1, k]|其中j≠4 且当 j = 6时k≠2。我们做的时候，从高到低枚举哪一位比n的哪一位小(这是可以为0的，我们枚举的时候不能取等就是因为我们算的是比他小的。比如说我们找一个数52496:首先答案会加上f[5][3]+f[5][2]+f[5][1]+f[5][0]+f[4][1]+f[4][0]然后就不加了，分别表示三开头的五位数，二开头的五位数，一开头的五位数，任意位数非5位数，以五一开头的五位数，以五零开头的五位数)是不是很易懂呢？
上代码：
#include<cstdio>
#include<cstring>
int f[10][10], n, m;
int bit[10];
int dp(int len)
{
    int ans = 0;
    bit[len + 1] = 0;
    for(int i = len; i > 0; i --){
        for(int j = 0; j < bit[i]; j ++){
            if(j == 2 && bit[i+1] == 6) continue;
            ans += f[i][j];
        }
        if(bit[i] == 4||(bit[i] == 2 && bit[i+1] == 6))    //找到了4或者连续的62说明后面的数都是接在4和62后面的，所以直接退出
            break;
    }
    return ans;
}
int main()
{
    f[0][0] = 1;
    for(int i = 1; i <= 7; i ++)
        for(int j = 0; j <= 9; j ++)
        {
            if(j == 4) continue;
            for(int k = 0; k <= 9; k ++)
            {
                if((j == 6 && k == 2) || k == 4) continue;
                f[i][j] += f[i-1][k];
            }
        }
    while(~scanf("%d%d", &n, &m) && n + m) {
        m ++;                 //因为我们只算了[1,r)的，所以上去间 ++
        int t1 = n, t2 = m, l1 = 0, l2 = 0;
        while(t1)
        {
            l1 ++;
            bit[l1] = t1 % 10;
            t1 /= 10;
        }
        t1 = dp(l1);
        while(t2)
        {
            l2 ++;
            bit[l2] = t2 % 10;
            t2 /= 10;
        }
        t2 = dp(l2);
        printf("%d\n", t2 - t1);
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：请随意转载O(∩_∩)O

轻松python文本专题-判断对象里面是否是类字符串（推荐使用isinstance(obj,str)）
场景：
判断对象里面是否是类字符串


一般立刻会想到使用type()来实现

>>> def isExactlyAString(obj):
	return type(obj) is type('')

>>> isExactlyAString(1)
False
>>> isExactlyAString('1')
True
>>> 

还有

>>> def isAString(obj):
	try :obj+''
	except:return False
	else:return True

	
>>> isAString(1)
False
>>> isAString('1')
True
>>> isAString({1})
False
>>> isAString(['1'])
False
>>> 
虽然思路上和方法使用上都没用问题，但是如果从python的特性出发，我们可以找到更好的方法：isinstance(obj,str)


>>> def isAString(obj):
	return isinstance(obj,str)

>>> isAString(1)
False
>>> isAString('1')
True
>>> 
str作为python3里面唯一的一个字符串类，我们可以检测字符串是否是str的实例





就说到这里，谢谢大家


------------------------------------------------------------------

点击跳转零基础学python-目录

 


版权声明：本文为博主原创文章，未经博主允许不得转载。

轻松python文本专题-去掉字符串前后空格
场景：
去掉字符串前后空格
可以使用strip，lstrip，rstrip方法
>>> a="abc".center (30)
>>> a
'             abc              '
>>> b=a.lstrip ()
>>> b
'abc              '
>>> c=a.rstrip ()
>>> c
'             abc'
>>> d=a.strip ()
>>> d
'abc'
>>> 
这三个方法默认是去掉空格，也可以通过参数去掉其他字符，等价与replace
>>> a="abc"
>>> b=a.strip ('a')
>>> b
'bc'
>>> c=a.replace ('a','')
>>> c
'bc'
>>> 



就说到这里，谢谢大家


------------------------------------------------------------------

点击跳转零基础学python-目录



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 4300 Clairewd’s message（KMP）


Clairewd’s message
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4255    Accepted Submission(s): 1628



Problem Description

Clairewd is a member of FBI. After several years concealing in BUPT, she intercepted some important messages and she was preparing for sending it to ykwd. They had agreed that each letter of these messages would be transfered to another one according to a conversion
 table.
Unfortunately, GFW(someone's name, not what you just think about) has detected their action. He also got their conversion table by some unknown methods before. Clairewd was so clever and vigilant that when she realized that somebody was monitoring their action,
 she just stopped transmitting messages.
But GFW knows that Clairewd would always firstly send the ciphertext and then plaintext(Note that they won't overlap each other). But he doesn't know how to separate the text because he has no idea about the whole message. However, he thinks that recovering
 the shortest possible text is not a hard task for you.
Now GFW will give you the intercepted text and the conversion table. You should help him work out this problem.


 


Input

The first line contains only one integer T, which is the number of test cases.
Each test case contains two lines. The first line of each test case is the conversion table S. S[i] is the ith latin letter's cryptographic letter. The second line is the intercepted text which has n letters that you should recover. It is possible that the
 text is complete.


Hint
Range of test data:
T<= 100 ;
n<= 100000;



 


Output

For each test case, output one line contains the shorest possible complete text.

 


Sample Input

2
abcdefghijklmnopqrstuvwxyz
abcdab
qwertyuiopasdfghjklzxcvbnm
qwertabcde


 


Sample Output

abcdabcd
qwertabcde


 




题目大意：
看了半天没看懂它在扯什么。。。其实题意很简单，首先给出26个字母，明文按照这个表转换成对应密文。然后给一个字符串，这个字符串前一段是完整的密文，后一段是明文，明文可能不完整，也可能根本就没有给出明文。然后让你输出完整的密文明文字符串，同时尽可能短。
比如样例：
第一组密文是abcd，明文也是abcd；第二组密文是qwert，明文是abcde。

解题思路：
输入的字符串中密文一定是完整的，明文不一定完整，所有明文占原字符串的长度一定小于等于原串一半。
比如：
qwertyuiopasdfghjklzxcvbnm
qwertabc
（首先我们能猜出最短答案是qwertabcde，qwert是密文，abcde是明文）
qwertabc这个字符串中明文长度一定小于等于4，所有原串的前半段一定全部是密文，后半段则不一定。然后我们在把前半段按照输入的明文密文转化表转化成明文。

那么
qwertabc
就变成了
abcdtabc
这个时候我们就只需要使用KMP中的Next数组（表示的是最长匹配前后缀）求出整个字符串的最长匹配前后缀，这个长度一定是最长明文长度。题目要求输出最短的密文明文，所以我们要使密文尽可能短，所以密文的长度就是字符串长度减去最长匹配前后缀。
另外还要特判
abcdefghijklmnopqrstuvwxyz
aaa
这种情况，正确答案是aaaa。判断Next[n-1]是否等于n-1同时整个字符串是否只由一个字符组成。

参考代码：
#include<map>
#include<set>
#include<stack>
#include<queue>
#include<cmath>
#include<ctime>
#include<vector>
#include<cctype>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long LL;
const double pi=3.141592653;
const double eps=1e-10;
const int INF=0x3f3f3f3f;
const int MOD=10007;
const int MAXN=1e6+50;

int n,Next[MAXN];
char a[MAXN],b[MAXN],tab[27],invtab[27];

void getNext(char* B)
{
    Next[0]=0;
    for(int i=1; i<n; i++)
    {
        int k=Next[i-1];
        while(B[i]!=B[k]&&k)
            k=Next[k-1];
        Next[i]=B[i]==B[k]?k+1:0;
    }
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
#endif // ONLINE_JUDGE
    int T;
    scanf("%d",&T);
    while(T--)
    {
        memset(tab,0,sizeof(tab));
        memset(invtab,0,sizeof(invtab));
        memset(Next,0,sizeof(Next));
        scanf("%s%s",tab,a);
        for(int i=0;i<26;i++)
            invtab[tab[i]-'a']=i+'a';
        n=strlen(a);
        for(int i=0;i<n;i++)
            b[i]=(i<=(n-1)/2)?invtab[a[i]-'a']:a[i];
        b[n]=0;
        getNext(b);
        if(Next[n-1]==n-1&&b[0]==b[1])//特判aaa这种情况，判断Next[n-1]是否等于n-1同时整个字符串是否只由一个字符组成
        {
            int m=(n+1)/2;//计算最小长度
            for(int i=0;i<2*m;i++)
                printf("%c",b[0]);
        }
        else
        {
            for(int i=0;i<n-Next[n-1];i++)
                printf("%c",a[i]);
            for(int i=0;i<n-Next[n-1];i++)
                printf("%c",invtab[a[i]-'a']);
        }
        puts("");
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

归并排序
//将有二个有序数列a[first...mid]和a[mid...last]合并。
void mergearray(int a[], int first, int mid, int last, int temp[])
{
	int i = first, j = mid + 1;
	int m = mid,   n = last;
	int k = 0;
	
	while (i <= m && j <= n)
	{
		if (a[i] <= a[j])
			temp[k++] = a[i++];
		else
			temp[k++] = a[j++];
	}
	
	while (i <= m)
		temp[k++] = a[i++];
	
	while (j <= n)
		temp[k++] = a[j++];
	
	for (i = 0; i < k; i++)
		a[first + i] = temp[i];
}
void mergesort(int a[], int first, int last, int temp[])
{
	if (first < last)
	{
		int mid = (first + last) / 2;
		mergesort(a, first, mid, temp);    //左边有序
		mergesort(a, mid + 1, last, temp); //右边有序
		mergearray(a, first, mid, last, temp); //再将二个有序数列合并
	}
}

bool MergeSort(int a[], int n)
{
	int *p = new int[n];
	if (p == NULL)
		return false;
	mergesort(a, 0, n - 1, p);
	delete[] p;
	return true;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

每天5道面试题（三）java基础
final, finally, finalize的区别？
　　final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
finally是异常处理语句结构的一部分，表示总是执行。 
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。
sleep() 和 wait() 有什么区别？
sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。

wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型？
方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。
error和exception有什么区别？
error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 
    exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。
同步和异步有何异同，在什么情况下分别使用他们？举例说明
如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。
abstract class和interface有什么区别?
声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 
接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ_2528 Mayor's poster(线段树+离散化)
题目请点我 
题解： 
这道题与之前的题目相比重点在于一个映射的预处理，题目所给的区间达到10000000，而最多只有10000个点，如果直接建树的话太过于空旷。把这些区间的左右节点一一对应，最多有4×10000个点，远小于之前的10000000，而且区间之间的对应关系也不会改变。

举个例子： 
  区间：[2,6],[4,8],[6,10] 
  我们进行下面对应: 
  2  4  6  8  10 
  1  2  3  4  5 
  则原区间变为[1,3],[2,4],[3,5]。可以发现它们之间的覆盖关系并没有改变，但是却紧凑了很多。 
  但是注意对应后，应该有一个去重的操作，防止出错。
还有一点去需要注意，区间的对应稍不注意会出现颜色丢失的情况，如下： 
  [1,10],–[1,4],–[6,10] 
  当我们手工模拟会发现，我们只是对1，4，6，10，进行了对应，即1，2，3，4，原集合中的4，6被视为了相邻元素，所以5处的颜色丢失，最终得到了错误的结果。 
  为了防止发生这种情况我们进行插值，在两个不相邻的节点间插入无关值，但是能有效的避免这种情况。
数组范围分析，10000个区间对应最多20000个节点，再进行插值后得到最多40000+个节点，对应segTree数组达到4×40000+。

而线段树部分实现起来就比较简单了，lazy标记一下，最后统计仍可见的不同颜色就可以了。
参考博客
代码实现：
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define MAX 20010
#define LCHILD root<<1,l,mid
#define RCHILD root<<1|1,mid+1,r
#define MID(x,y) (x+y)>>1

using namespace std;

int T;
int N;
int mm[MAX<<2];
int show[MAX<<3];
int L[MAX],R[MAX];
int segTree[MAX<<3];
void pushdown(int root);
int query(int root,int l,int r,int a,int b);
void update(int root,int l,int r,int a,int b,int flag);
int main(){
    scanf("%d",&T);
    while( T-- ){
        scanf("%d",&N);
        int pos = 1;
        int tmp = 2;
        //注意show[0]要提前标记为1
        memset(segTree,0,sizeof(segTree));
        memset(show,0,sizeof(show));show[0] = 1;
        for( int i = 1; i <= N; i++ ){
            scanf("%d%d",&L[i],&R[i]);
            mm[pos++] = L[i];
            mm[pos++] = R[i];
        }
        //去重操作
        sort(mm+1,mm+pos);
        for( int i = 2; i < pos; i++ ){
            if( mm[i] != mm[i-1] ){
                mm[tmp++] = mm[i];
            }
        }
        //插值
        pos = tmp;
        for( int i = pos-1; i > 1; i-- ){
            if( mm[i] != mm[i-1]+1 ){
                mm[pos++] = mm[i-1]+1;
            }
        }
        sort(mm+1,mm+pos);
        //lowe_bound找到a,b位置
        for( int i = 1; i <= N; i++ ){
            int a,b;
            a = lower_bound(mm+1,mm+pos,L[i])-mm;
            b = lower_bound(mm+1,mm+pos,R[i])-mm;
            update(1,1,pos-1,a,b,i);
        }
        int res = query(1,1,pos-1,1,pos-1);
        printf("%d\n",res);
    }
    return 0;
}

void update(int root,int l,int r,int a,int b,int flag){
    if( a > r || b < l ){
        return ;
    }
    if( a <= l && r <= b ){
        segTree[root] = flag;
        return ;
    }
    if( segTree[root] != 0 ){
        pushdown(root);
    }
    int mid = MID(l,r);
    update(LCHILD,a,b,flag);
    update(RCHILD,a,b,flag);
    return ;
}

int query(int root,int l,int r,int a,int b){
    if( a > r || b < l ){
        return 0;
    }
    //该区间属于同一种颜色，show数组标记是否已被统计
    if( segTree[root]!= 0 ){
        if( show[segTree[root]] != 1 ){
            show[segTree[root]] = 1;
            return 1;
        }
        return 0;
    }
    //未标色的叶子节点
    if( l == r ){
        return 0;
    }
    int mid = MID(l,r);
    return query(LCHILD,a,b)+query(RCHILD,a,b);
}

void pushdown(int root){
    segTree[root<<1] = segTree[root];
    segTree[root<<1|1] = segTree[root];
    segTree[root] = 0;
    return ;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

利用qq设置个性化的域名邮箱
首先有域名，先去注册先，国内有很多域名交易平台，我是在易名中国网上注册的一个域名，Lios.top,由于这个域名价值很低，一年才

10元，价格很实惠。

下一步就是去qq邮箱的设置里，找到账户，然后下面有域名邮箱设置：



点击进去然后去设置，一步一步来。

需要说明的是，需要到域名管理中，需要新添模板，国际模板添加后就可以使用（但是需要模板过户）。然后设置CNAME（按照qq提

示填写）和MX,其中设置MX时，按照qq上提示的做，但是总是提示MX未设置或者未通过审核

网上找了很多文章，很多都是如出一辙。其中有朋友说，把主机记录改为@试一下，尝试成功了！



然后就可以到qq中设置了，可以给朋友比较个性的域名邮箱！

当然也可以绑定自己的博客，域名Lios.top绑定我的个人博客地址，也是比较好玩！

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 4512 吉哥系列故事――完美队形I（最长公共上升子序列）


吉哥系列故事——完美队形I
Time Limit: 3000/1000 MS (Java/Others)    Memory Limit: 65535/32768 K (Java/Others)
Total Submission(s): 2638    Accepted Submission(s): 854



Problem Description

　　吉哥这几天对队形比较感兴趣。
　　有一天，有n个人按顺序站在他的面前，他们的身高分别是h[1], h[2] ... h[n]，吉哥希望从中挑出一些人，让这些人形成一个新的队形，新的队形若满足以下三点要求，则称之为完美队形：
　　
　　1、挑出的人保持他们在原队形的相对顺序不变；
　　2、左右对称，假设有m个人形成新的队形，则第1个人和第m个人身高相同，第2个人和第m-1个人身高相同，依此类推，当然，如果m是奇数，中间那个人可以任意；
　　3、从左到中间那个人，身高需保证递增，如果用H表示新队形的高度，则H[1] < H[2] < H[3] .... < H[mid]。

　　现在吉哥想知道：最多能选出多少人组成完美队形？

 


Input

　　第一行输入T，表示总共有T组数据(T <= 20)；
　　每组数据先输入原先队形的人数n(1<=n <= 200)，接下来一行输入n个整数，表示按顺序从左到右原先队形位置站的人的身高（50 <= h <= 250，不排除特别矮小和高大的）。

 


Output

　　请输出能组成完美队形的最多人数，每组数据输出占一行。

 


Sample Input

2
3
51 52 51
4
51 52 52 51


 


Sample Output

3
4


 




题目大意:
从n个人中挑出部分人组成一个队列，使得他们在原队列中的相对顺序不变，同时使得H[1]<H[2]<...<H[mid]<H[mid+1]<...<H[m],H[1]=H[m],H[2]=H[m-1]...

解题思路：
题目与HDU 4513非常相似，但是4513要求的是选出的连续的人，而这道题没有要求连续，所以这两道题的方法也完全不同。4513只需要manacher，这道题要用到LCIS。
所以这道题就是求最长公共上升子序列。每次求1~i与i~n的LCIS，把结果乘2减一就是奇数的情况，然后再求1~i与i+1~n的LCIS，结果乘2，循环n次求出结果的最大值。

参考代码：
/*
O（n^2）
Memory: 1808 KB		Time: 280 MS
Language: G++		Result: Accepted
*/

#include<bits/stdc++.h>
using namespace std;
const int MAXN=200+50;

int num[MAXN],n,dp[MAXN][MAXN];

int LCIS(int e1,int e2)
{
    memset(dp,0,sizeof(dp));
    int maxx=0;
    for(int i=1;i<=e1;i++)
    {
        maxx=0;
        for(int j=n;j>=e2;j--)
        {
            dp[i][j]=dp[i-1][j];
            if(num[i]>num[j])
                maxx=max(maxx,dp[i-1][j]);
            if(num[i]==num[j])
                dp[i][j]=maxx+1;
        }
    }
    int ans=1;
    for(int i=n;i>=e2;i--)
        ans=max(ans,dp[e1][i]);
    return ans;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
#endif // ONLINE_JUDGE
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
            scanf("%d",&num[i]);
        int ans=1;
        for(int i=1;i<=n;i++)
        {
            ans=max(ans,LCIS(i,i)*2-1);//奇数
            ans=max(ans,LCIS(i,i+1)*2);//偶数
        }
        printf("%d\n",ans);
    }
    return 0;
}
/*
O（n^3）
Memory: 1808 KB		Time: 842 MS
Language: G++		Result: Accepted
*/
#include<bits/stdc++.h>
using namespace std;
const int MAXN=200+50;

int num[MAXN],n,dp[MAXN][MAXN];

int LCIS(int e1,int e2)
{
    memset(dp,0,sizeof(dp));
    for(int i=1; i<=e1; i++)
        for(int j=n; j>=e2; j--)
        {
            dp[i][j]=dp[i-1][j];
            if(num[i]==num[j])
            {
                int maxx=0;
                for(int k=n; k>=j+1; k--)
                    if(num[k]<num[j])
                        maxx=max(maxx,dp[i-1][k]);
                dp[i][j]=maxx+1;
            }
        }
    int ans=1;
    for(int i=n;i>=e2;i--)
        ans=max(ans,dp[e1][i]);
    return ans;
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
#endif // ONLINE_JUDGE
    int T;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
            scanf("%d",&num[i]);
        int ans=1;
        for(int i=1;i<=n;i++)
        {
            ans=max(ans,LCIS(i,i)*2-1);//奇数
            ans=max(ans,LCIS(i,i+1)*2);//偶数
        }
        printf("%d\n",ans);
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

每天5道面试题（四）java基础
heap和stack有什么区别？
栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。 
堆是栈的一个组成元素
forward 和redirect的区别？
forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 
    redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以session,request参数都可以获取。
EJB与JAVA BEAN的区别？
Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat）的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理， EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。
Static Nested Class 和 Inner Class的不同？
Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。

JSP中动态INCLUDE与静态INCLUDE的区别？
动态INCLUDE用jsp:include动作实现 它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。 
静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面<%@ include file=”included.htm” %> 

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

中医古籍大全
作者 www.gudianxiaoshuo.com

















版权声明：本文为博主原创文章，未经博主允许不得转载。

IPV4理论知识3----分类编址址两级编址






IPV4理论知识3----分类编址址两级编址






 
前言
 
本次还是主要讲解IPV4方面的内容,因为这方面的内容比较多也比较重要,我就不在同意篇文章中介绍了,一个小知识点一个内容,看起来也不至于乱.如有问题,请指正.
 
 
 
两级编址
 
分类编址时,同一网络中的所有地址都属于同一个地址块,而每个地址块包含两个部分:网络ID和主机ID.网路ID是干嘛的来?还记得吗?主机ID呢?还记得0533-88888888哪个案例吗?网络ID指明了网络,主机ID则指明了连接到该网络的一台特定主机.对吧.下图描述了分类编址中一个IPV4地址.


上图是分类地址中的两级编址
 
 
 
提取地址数,首地址,末地址
 
一个地址块就是一段地址,如果给定一地址块中的任意一个IPV4地址,怎么得出该IP地址所在地址块的地址个数,首地址,末地址,看下面:分三步
1.该地址块的地址数N可以用N=2的32-n次方求出.
2.要求出首地址,我们保持最左边的n位不变,并将靠右边的32-n位全部置为0
3.要求出末地址,我们保持最左边的n位不变,并将靠右边的32-n位全部置为1.





总结
 
这一点内容不多,我希望大家想我一样能记住,该记死的东西记死.该死记的东西死记!


版权声明：本文为博主原创文章，未经博主允许不得转载。

选举


版权声明：本文为博主原创文章，未经博主允许不得转载。

Focus on Application Support and Maintenance
￼
Focus on Application Support and Maintenance
Mncedisi Kasper
THE SuppoRT And MAinTEnAnCE oF An AppliCATion should never, ever be an afterthought. Since over 80% of an application’s lifecycle is spent in maintenance, you should pay a lot of attention to the problems of support and maintenance when you’re designing. Fail to heed this, and you’ll watch with horror as your application stops being the architect’s dream and becomes a vile beast that dies a horrible death and is forever remembered as a failure. 
When most architects design applications, they think mainly of developers, who have IDEs and debuggers in place. If something goes wrong, highly skilled software engineers debug away and the bug is discovered. It’s easy to think this way because most architects have spent most of their lives as developers rather than administrators. Unfortunately, the developer and the support guy have different skill sets, just as the development/testing environment and the pro- duction environment have different purposes. 
Here are a few of the disadvantages that an administrator faces: 
• An administrator can’t resubmit a request message to reproduce the prob- lem. When you’re in production, you can’t reissue a financial transaction against the “live” database to see what went wrong. 
• Once the application is in production, the pressure to fix bugs comes from customers and executives, not from the project manager and the testing team—and an angry CEO can be a lot more threatening. 
• Once you’re in production, there is no debugger. 
• Once you’re in production, deployment needs to be scheduled and co- ordinated. You can’t take a production application down for a few minutes to test a bug fix. 
• The logging level is much higher in the development environment than in production. 
￼￼￼114 
￼ 
￼￼A few symptoms of this failure to plan for support are: 
• Most problems require a developer’s involvement. 
• The relationship between the development team and the support team is sour; the developers think the support team is a bunch of idiots. 
• The support team hates the new application. 
• The architect and development teams are spending a lot of time in production. 
• The application is restarted often as a way to resolve problems. 
• The administrators never have time to tune the system properly because they’re always fighting fires. 
To ensure that your application succeeds once it’s out of the developers’ hands, you should: 
• Understand that development and support require a different skill set. 
• Get a support lead as early in on the project as possible. 
• Make the support lead a core part of the team. 
• Involve a support lead with the planning for the application support. 
Design such that the learning curve for the support personnel is minimal. Traceability, auditing, and logging are crucial. When the administrators are happy, everybody is happy (especially your boss). 
Mncedisi Kasper is a director of technology and strategy at Open Xcellence ICT Solutions, a South Africa–based company specializing in enterprise application integration and SAP (ABAP/XI) consultancy.

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
【toj1163】Gone Fishing

说有个人钓鱼，好多湖，湖里的鱼从开始钓计时，每55分钟减少一定量，搞啊搞。。。最后可以在任何湖停止。问最多可以钓多少鱼。
直接dpdp即可。。。
应该可以贪心做，或者分组做，总之直接dpdp比较慢一点，复杂度是..

O(144nh2)O(144nh^2)
/* **********************************************

    File Name: 1163.cpp

    Auther: zhengdongjian@tju.edu.cn

    Created Time: 2015/8/26 星期三 下午 1:08:38

*********************************************** */
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> P;

const int INF = 0xfffffff;
const int MAX_T = 207;
const int MAX_L = 26;
struct State {
    int i, j, k;
};
int dp[MAX_L][MAX_T][MAX_T];
State dad[MAX_L][MAX_T][MAX_T];
int daisy[MAX_L];
int f[MAX_L], d[MAX_L], t[MAX_L];
/*
 * dp[i][j][0] = dp[i-1][j - t_{i-1}][..]
 * dp[i][j][k] = max{dp[i][j - 1][k - 1] + max(0,fi-(k-1)di)}
 */
int main() {
    int n, h;
    bool black = false;
    while (~scanf(" %d", &n) && n) {
        scanf(" %d", &h);
        h *= 12;
        for (int i = 1; i <= n; ++i) {
            scanf(" %d", f + i);
        }
        for (int i = 1; i <= n; ++i) {
            scanf(" %d", d + i);
        }
        for (int i = 1; i < n; ++i) {
            scanf(" %d", t + i);
        }
        t[0] = 0;
        //memset(dp, 0, sizeof(dp));
        for (int k = 0; k <= n; ++k) {
            for (int i = 0; i <= h; ++i) {
                for (int j = 0; j <= h; ++j) {
                    dp[k][i][j] = -INF;
                }
            }
        }
        dp[0][0][0] = 0;
        dad[0][0][0] = (struct State){-1, -1, -1};
        //memset(dp[0], 0, sizeof(dp[0]));
        int use = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = use; j <= h; ++j) {
                for (int k = 0; k <= h - use; ++k) {
                    if (k == 0) {
                        if (j < t[i - 1]) continue;
                        for (int r = 0; r <= h; ++r) {
                            if (dp[i - 1][j - t[i - 1]][r] > dp[i][j][k]) {
                                dp[i][j][k] = dp[i - 1][j - t[i - 1]][r];
                                dad[i][j][k] = (struct State){i - 1, j - t[i - 1], r};
                            }
                        }
                    } else {
                        if (j) {
                            int vl = dp[i][j - 1][k - 1] + max(0, f[i] - (k - 1) * d[i]);
                            if (dp[i][j][k] < vl) {
                                dp[i][j][k] = vl;
                                dad[i][j][k] = (struct State){i, j - 1, k - 1};
                            }
                        }
                    }
                }
            }
            use += t[i];
        }
        int ans = 0;
        P mom = P(0, 0);
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= h; ++j) {
                if (dp[i][h][j] > ans) {
                    ans = dp[i][h][j];
                    mom = P(i, j);
                }
            }
        }
        memset(daisy, 0, sizeof(daisy));
        State now = (struct State){mom.first, h, mom.second};
        //daisy[mom.first] = mom.second;
        while (now.i != -1) {
            daisy[now.i] = max(daisy[now.i], now.k);
            now = dad[now.i][now.j][now.k];
        }
        int sum = 0;
        for (int i = 1; i <= n; ++i) {
            sum += daisy[i];
        }
        for (int i = n; i >= 1; --i) {
            if (daisy[i]) {
                for (int j = i - 1; j >= 1; --j) {
                    sum += t[j];
                }
                break;
            }
        }
        daisy[1] += h - sum > 0 ? h - sum : 0;

        if (black) puts("");
        for (int i = 1; i < n; ++i) {
            printf("%d, ", daisy[i] * 5);
        }
        printf("%d\n", daisy[n] * 5);
        printf("Number of fish expected: %d\n", ans);
        black = true;
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：那泥烤去看鸭o o

集线,路由和交换的概念






集线,路由和交换的概念






 
前言
 
装了一天的系统,为啥要装系统呢,因为开学了,新学期新气象,但是想想本屌的计算机组成原理考了32分,一想到补考就头疼.走一步看一步吧,看了一下大三的课表,觉得计算机网络这门课貌似得好好学学,还有10天开学了,不知道能不能学的差不多.努力吧,少年!
 
 
 
先对各种常见的网络设备做一个简单的认识
 
集线器(HUB)
 
集线器就是将网线集中到一起的机器,也就是多态主机he设备的链接器.集线器的主要功能是对接收到的信号进行同步整形放大,以扩大网络的传输距离,是中继器的一种修行是,区别在于集线器能够提供多端口服务,也称为多口中继器.集线器在OSI/RM中的物理层.集线器的基本功能是信息分发,它把一个端口接收的所有信号向所有端口分发出去.一些集线器在分发之前将弱信号重新生成,一些集线器整理信号的时序以提供所有端口间的同步数据通信.
 
集线器实际就是一种多端口的中继器.集线器一般有4,816,24,32等数量的RJ45接口,通过这些接口,集线器便能为相应数量的电脑完成”中继”功能(将已经衰退的不完整的信号经过整理,重新产生完整的信号再继续传送).由于他在网络中处于一种”中心”位置,因此集线器也叫做”HUB”.
 
集线器的工作原理很简单,比如有一个具有8个端口的集线器,共连接了8台电脑.集线器处于网络的”中心”,通过集线器对信号进行转发,8台计算机之间可以相互通信.具体的通信过程是这样的:加入计算机1要给计算机8发一条短信,当计算机1的网卡将信息通过双绞线送到集线器上时,集线器并不会直接将信号给送计算机8,它会将信息进行”广播”----将信息同时发送给8个端口,当8个端口上的计算机接收到这条广播信息时,它会对信息进行检查,如果发现该信息时发给自己的,则接受,否则不予理睬.由于该信息是计算机1发送给计算机8的,因此最终计算机8会接受到该信息,而其他7台计算机看完信息后,会因为信息不是自己的而不接受该信息.
 
 
 
交换机(Switch)
 
交换机式集线器的升级换代产品,外形上和集线器没啥区别,是一种在通信系统中自动完成信息交换功能的设备,用途和HUB一样也是连接组网之用,但是它具有比集线器更强大的功能,要不怎么说是升级产品呢.
 
交换机也叫交换式集线器,它通过对信息进行重新生成,并经过内部处理后转发至指定端口,具备自动寻址能力和交换作用,由于交换机根据所传递信息包的目的地址,将每一条信息包地理的从源端口发送到目的端口,避免了和其他端口发生碰撞.广义的交换机就是一种在通信系统中完成信息交换功能的设备.
 
在计算机网络系统中,交换机是针对共享工作模式的软垫而推出的.集线器是采用共享工作模式的代表,如果把一个集线器比作一个邮递员,那么这个邮递员是个不认识字的”傻瓜”----要他去送信,他不知道直接根据信件上的地址将信件送给收件人,只会拿着信分发给所有的人,然后让接受的人根据地址信息来判断是不是自己的!而交换机则是一个聪明的邮递员----交换机拥有一条高带宽的背部总线和内部交换矩阵.交换机的所有的端口都挂接在这条背部总线上,当控制电路收到数据包以后,处理端口会查找内存中的地址对照表以确定目的MAC(网卡的硬件地址)的NIC(网卡)挂接在哪个端口上,通过内部交换矩阵迅速将数据包传送到目的端口.目的MAC若不存在,交换机才广播到所有的端口,接受端口回应后交换机”学习”新的地址,并把它添加入内部地址表中.
 
可见,交换机在收到某个网卡发过来的”信件”时,会根据上面的地址信息,以及自己掌握的”常住居民”快速将信件送到收件人的手上.万一收信人的地址不在这个”户口薄”上,交换机才会像集线器一样将信息分发给所有人,然后从中找到收件人.而找到收件人之后,交换机就会立刻将这个人的信息登记到”户口薄”上,这样以后再为该客服送信时,就可以迅速的找到这个人了.
 
 
 
路由器(Router)
路由器是网络中进行网间链接的关键设备.作为不同网络之间的互相连接的枢纽,路由器系统构成了基于TCP/IP的国际互联网络Internet的主体脉络.
 
路由器之所以在互联网络中处于关键地位,是因为它处于网络层,一方面能够扩约不同的物理网络类型(DDN,FDDI,以太网等等),两一方面在逻辑上将整个互联网分割成逻辑上独立的网络单位,使网络具有一定的逻辑结构.路由器的主要工作就是为经过路由器的每个数据帧寻找一条最佳的传输路径,并将该数据有效的传送到目的站点.路由器的基本功能是,把数据(IP报文)传送到正确的网络,细分则包括:1.IP数据包的转发,包括数据报的寻址和传送; 2.子网隔离,抑制广播风暴; 3.维护路由表,并与其他路由器交换路由信息,这是IP报文转发的基础; 4.IP数据报的差错处理以及简单的拥塞控制; 5.实现对IP数据报的过滤和记账.
 
路由器构成了Internet的骨架.它的处理速度是网络通信的主要瓶颈之一,它的可靠性则直接影响网络互连的指令.因此Internet研究领域中,路由器技术始终处于核心地位.
 
 
 
总结
 
集线器----电脑网络中的对讲机,它能以最简单的方式实现多台电脑的网络通信.
 
特点:接到统一集线器的多台电脑,就像是使用同一频率的对讲机进行通信新,在任何一个时刻只能有一对”对讲机”进行通信.即当电脑1与电脑3进行通信时,电脑2和与电脑4就不能进行通信,只有等电脑1与电脑3通信结束后才能通信.
 
 
交换机----电脑网络中的”电话接线员”,它负责互联网的”电话”接通工作.
 
特定:当电脑1像与电脑2通信时,它得先请”电话接线员”把它和电脑2的”电话”接通,接通后,”电话接线员”就可以做其他工作了,比如再接通电脑3和电脑4之间的”电话”.它能同时完成多路”电话”的交换与接通工作,所以叫做交换机.
 
 
路由器----电脑网络中的”传达室”,它负责分拣以及转发网络的各种信息.
 
特点:当”我”(电脑A)想访问”工人日报”网站时,”我”只要和”传达室”里的”大爷”说一声,就没有必要自己去邮局订阅或者找书报亭买了,由”传达室”统一负责订阅或购买,并且分发到”各家各户”.当”外单位的人”(电脑B)”有东西”(信息)要交给”我”时,只要把东西放到”传达室”即可,”传达室”里的”大爷”会把东西送上门.
 
 
用通俗的话说这三者的关系
集线器就好比把一个水龙头分成好几个,水流总量等于每个水龙头的量的和,水龙头多了每个水龙头就分的少了.
 
交换机就是带个转换头,这1秒给1号电脑用,下一秒给2号电脑用,每个用的都是全部水量,但是不是时时字在用.
 
路由器就是在这组水龙头边放了一个人,用人的智慧观察哪个需要就给哪个放水.

版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ 2006 [NOI2010]超级钢琴 主席树+堆
题意:链接
方法:主席树+堆
解析:
我们这么去想。
对于每一个能成为右端点的点。
我们要拿前k个sum[i]−sum[j−1]sum[i]-sum[j-1]，首先先处理出所有能成为右端点的点的最小的上面的那一坨。
然后呢我们拿最大的一坨。
之后这时候对于被拿的那一坨的右端点来说。
它的前面的最小的-sum[j]已经不能取了。
所以要取第2小的-sum[j]，
这时候再把这个值扔进堆里。
之后一直这么搞下去，从堆里取k个即可。
这时候涉及到一个区间取第k小的操作。
所以上个主席树就好了。
这个复杂度是多少呢？
O(klogn)，不虚可过。
代码:
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 500010
#define M 20000000 
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
int n,k,l,r,size,heap_root;
int ch[N][2]; 
int limit[N];
int fa[N];
int root[N];
int lson[M];
int rson[M];
int siz[M];
int sum[N];
int rnk[N];
int val[N];
int h[N];
int a[N];
int find(int x)
{
    while(fa[x])x=fa[x];
    return x;
} 
int merge(int x,int y)
{
    if((!x)||(!y))return x+y;
    if(val[x]<val[y])swap(x,y);
    ch[x][1]=merge(ch[x][1],y);
    fa[ch[x][1]]=x;
    if(h[ch[x][1]]>h[ch[x][0]])swap(ch[x][1],ch[x][0]);
    h[x]=h[ch[x][1]]+1;
    return x;
}
void insert(int l,int r,int x,int &y,int val)
{
    y=++size;
    siz[y]=siz[x]+1;
    if(l==r)return;
    lson[y]=lson[x],rson[y]=rson[x];
    int mid=(l+r)>>1;
    if(val<=mid)insert(l,mid,lson[x],lson[y],val);
    else insert(mid+1,r,rson[x],rson[y],val);
}
int query(int l,int r,int x,int y,int kth)
{
    if(l==r)return l;
    int mid=(l+r)>>1;
    int num=siz[lson[y]]-siz[lson[x]];
    if(num<kth)return query(mid+1,r,rson[x],rson[y],kth-num);
    else return query(l,mid,lson[x],lson[y],kth);
}
int main()
{
    h[0]=-1;
    scanf("%d%d%d%d",&n,&k,&l,&r);
    insert(-INF,INF,0,root[1],0);
    for(int i=2;i<=n+1;i++)
    {
        int x;
        scanf("%d",&x);
        sum[i]=sum[i-1]+x;
        insert(-INF,INF,root[i-1],root[i],sum[i]);
        rnk[i]=1;
    }
    val[l+1]=sum[l+1]; 
    for(int i=l+2;i<=n+1;i++)
    {
        if(i<=r+1)
        {
            val[i]=sum[i]-query(-INF,INF,root[1-1],root[i-l],rnk[i]);
            limit[i]=i-l+1;
        }
        else 
        {
            int t=query(-INF,INF,root[i-r-1],root[i-l],rnk[i]);
            val[i]=sum[i]-query(-INF,INF,root[i-r-1],root[i-l],rnk[i]);
            limit[i]=r-l+1;
        }
        rnk[i]++;
        heap_root=merge(find(i-1),i);
        fa[heap_root]=0;
    }
    ll ans=0;
    for(int i=1;i<=k;i++)
    {
        ans+=val[heap_root];
        int flag=0;
        if(rnk[heap_root]<=limit[heap_root])
        {
            if(heap_root<=r)
            {
                val[heap_root]=sum[heap_root]-query(-INF,INF,root[1-1],root[heap_root-l],rnk[heap_root]);
            }
            else 
            {
                val[heap_root]=sum[heap_root]-query(-INF,INF,root[heap_root-r-1],root[heap_root-l],rnk[heap_root]);
            }
            flag=1;
        }
        rnk[heap_root]++;
        int pre=heap_root;
        heap_root=merge(ch[heap_root][0],ch[heap_root][1]);
        fa[heap_root]=0;
        fa[pre]=0,ch[pre][0]=ch[pre][1]=0;
        if(flag){heap_root=merge(heap_root,pre);fa[heap_root]=0;}
    }
    printf("%lld\n",ans);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ3620
传送门：BZOJ3620
暴力做法小练习。
本质上就是求一个串，又是前缀又是后缀，然后有各种奇奇怪怪的要求。 
刚刚做了这种题…… 
枚举左端点i，枚举右端点j，对于[i,j],记录它们之间>k的最小的既是前缀又是后缀的值，判断这个值是否小于等于(j-i)/2即可。 
数据给出来就是暴力的，O(n2)O(n^2)能过真是感人肺腑。 
代码上的小细节见下。
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;

const int INF=0x7fffffff;

int pre[100005];
int num[100005];
char S[100005];
int len;
int c;

void Make_Table(char* S,int begin,int end)
{
    pre[begin]=begin-1;
    int k=begin-1;
    num[begin]=INF;
    for(int i=begin+1;i<=end;i++){
        while(k>=begin&&S[k+1]!=S[i])
            k=pre[k];
        if(S[k+1]==S[i])
            k++;
        pre[i]=k;
        num[i]=INF;
        if(k-begin+1>=c)
            num[i]=min(k-begin+1,num[pre[i]]);
    }
}

int Solve(int begin,int len)
{
    int ans=0;
    for(int i=begin+1;i<=len;i++)
        if((i-begin)/2>=num[i])
            ans++;
    return ans;
}

void Solve()
{
    int ans=0,len=strlen(S+1);
    for(int i=1;i<=len;i++){
        Make_Table(S,i,len);
        ans+=Solve(i,len);
    }
    printf("%d\n",ans);
}

void Close()
{
    fclose(stdin);
    fclose(stdout);
}

void Readdata()
{
    freopen("loli.in","r",stdin);
    scanf("%s",S+1);
    scanf("%d",&c);
}

int main()
{
    Readdata();
    Solve();
    Close();
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream 1420 High Speed Trains【Java大数高精度 + 递推】


High Speed Trains

Time Limit: 2000/1000MS (Java/Others) Memory Limit: 128000/64000KB (Java/Others)

链接：http://acdream.info/problem?pid=1420

Problem Description

      The kingdom of Flatland has n cities. Recently the king of Flatland visited Japan and was amazed by high speed trains Shinkansens going all around the country. Therefore he decided to build the system of high
 speed trains in Flatland.
      Each high speed train line will be bidirectional and connect exactly two different cities of Flatland. Although there is actually no need of high speed trains in Flatland, the king ordered that there must be at
 least one high speed train line from each city of Flatland.
      The minister of transportation told the king that there are several train system satisfying his requirements. The king was amazed by the fact and asked the minister to count the number of possible systems.
      Help the minister to calculate the number of train systems.


Input

      The input file contains one integer number n (2 ≤ n ≤ 100)

Output

      Output one integer number — the number of different train systems that can be arranged in Flatland.

Sample Input

4



Sample Output

41


题意：
给定N个点，保证每个点都至少有一条边与它相连，问可能情况的方案数。2 <= N < = 100

分析：

设ans[i] 表示的是i个点保证每个点都至少有一条边与它相连，可能情况的方案数。
N个顶点，最多构成N *（N - 1）/ 2条边，每条边有两种状态，即 选 和 不选，那么所有情况的状态数是2^(N *（N - 1）/ 2) ，然后将总状态数分别减去一个顶点无边相连的情况（即ans[N-1] * C（N-1，N）），两个顶点无边相连的情况（即ans[N-2] * C（N-2，N）），.......，N
 - 2个顶点无边相连的情况（即ans[2]*C(2,N)），N - 1个顶点无边相连的情况（这种情况特判，为0，因为，不存在仅有一个顶点存在边的情况），N 个顶点无边相连的情况 （即 ans[0]*C(0,N) == 1）。
这样，ans[i] 就可以由ans[j]  （j ∈ [0,N-1] ）递推求解出来了。
最后，大数的处理，Java的 BigInteger类 用起来真是方便啊！
代码实现：
import java.io.*;
import java.util.*;
import java.math.*;

public class Main {
	public static BigInteger C(int k,int n)
	{
		BigInteger ret = BigInteger.valueOf(1);
		for(int i = n;i >= n-k+1;i--) ret = ret.multiply(BigInteger.valueOf(i));
		for(int i = 2;i <= k;i++) ret = ret.divide(BigInteger.valueOf(i));
		return ret;
	}
	public static void main(String[] args) {
		BigInteger ONE = BigInteger.valueOf(1);
		BigInteger TWO = BigInteger.valueOf(2);
		BigInteger ans[] = new BigInteger[105];
		ans[2] = BigInteger.valueOf(1);
		for(int n = 3;n <= 100;n++) {
			int ENum = n*(n-1)/2;
			ans[n] = TWO.pow(ENum).subtract(ONE);
			for(int i = 2;i < n;i++){
				ans[n] = ans[n].subtract(C(i, n).multiply(ans[i]));
			}
		}
		Scanner cin = new Scanner(System.in);
		while(cin.hasNext()) {
			int N = cin.nextInt();
			System.out.println(ans[N]);
		}
	}
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

tomcat的环境变量部署

变量名：CATALINA_HOME

变量值：刚刚安装的路径

版权声明：本文为博主原创文章，未经博主允许不得转载。

小解差速齿轮
小时候喜欢折腾模型，玩过四驱车，里面有各种齿轮，主要是改变齿轮的转动方向，有个是变速齿轮，原理很简单就是改变齿轮的大小比，让小齿轮更小，大齿轮更大，从而增大转动比。但是，四驱车有一个非常隐蔽的缺点，就是四驱车不能转弯，除非用弯道通过左右边的高度差来实现转弯（火车转弯原理）。究其原因是当车转弯是，左右两个轮子的转动比是不一样的，内侧车轮的转速要低于外侧，这样才能实现转弯，而四驱车没有这样的功能。
今天要讲的就是用在汽车上的一种驱动技术-差速齿轮（写这篇文章原因也是前天晚上谁在床上，突然想起，又想不起怎样实现。。。）。差速齿轮顾名思义，能实现有不同转速的齿轮之间的传动。设计的非常巧妙，直接上视频。。。


总结一下，变速齿轮通过增加自身转动，实现了灵活的转移。当一边齿轮降低速度时，低速齿轮实际上成为了转动发起方，将转动转移给变速齿轮，而另一方面提高了其他齿轮的速度。当一放齿轮停止是，高速齿轮的转速实际上变成了原速度的2倍，这里也体现了能量守恒的定律。

生活中稍微留意观察一下大卡车的后轮杠杆中央的地方(就是屁股那，没有遮蔽），会发现几乎每个卡车那里都是一大瘤，那里就是变速齿轮，就是为汽车转弯变速用的。


最后留一个问题，是我以前从实验室大牛那里知道的，都说三角形稳定，为什么飞起器都是清一色的四个飞轮？
答案是：这是实验室大牛在制作飞行器的时候告诉我的，每个飞盘都有一定的角动量，如果是奇数个飞轮，飞行器会在空中自转。

版权声明：本文为博主原创文章，未经博主允许不得转载。

XX
昨晚刚回到学校，在火车上都感冒了，难受的很，老爹给我拿了一箱苹果，幸好晚上我舍友去接的我，大家都没有太多变化，我也是。今天上课了，居然和XX他们一块上课，不可思议。中午开始为赚钱做了一丢丢的准备。29号将是我能否赚回本钱的一天，加油。 
 睡了一会，实在难受的厉害，准备来实验室，很害怕，真的很害怕，3点就到了，真到4点才进来，我不敢，我害怕，好几次鼓起勇气准备进来的时候都停下来了，我害怕，很。。。很害怕。。。。也不知道在一楼到4楼这之间徘徊了多少趟，上楼、下楼，下楼、上楼。。。。上电梯、下电梯。。。。害怕真的很害怕。是，我要为自己的行为负责；是，路都是自己走过来的，既然我做了，我不后悔，没选上我确实。。。我，哎。。 
 最后还是鼓足了勇气，我进来了，我的东西。。。。没了，主要是我的本子，上面记录了很多痛苦的美好的回忆，也有学习在上面，尴尬，我真的害怕，或许我只知道逃避吧。。。不过，最终还是面对了，You’re the best! 
 不知道， I don’t know,我真的不知道。。。。。 
 省赛队员早已定，我不知道什么时候举办的比赛，Mr wang上场是我意料之外的，哈哈哈哈，好难过，不过这种结果也是对的，谁让我没坚持到底呢。。。我真的好累，不过现在我已经调整好了，我还是会继续坚持ACM，继续学好英语，无论我能否参加比赛，能否。。让自己拥有更多的东西才是第一位的。 
 回校之前，money让我们崩溃，发生了太多事，没有人可以帮忙，就连我最好的朋友都帮不上，没有人，nobody！ 
 好好学吧， You know! 
 when you got nothing, you got nothing to lose! 
 大二了，好快的，fighting!

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

链表中环的入口结点
思路：先用一个快慢指针，找到两者相遇结点，如果有环，结点一定在环中；接着求出环中结点数目n；然后用两个结点，第一个结点先走n步，第二个结点也开始走，相遇即为入口结点.
/**
     * 得到环中相遇点
     * @param root
     * @return
     */
    public static ListNote meetNode(ListNote root){
        if(root==null){
            return null;
        }

        ListNote slowNode=root.getNext();//慢指针
        ListNote quickNode=slowNode.getNext();//快指针
        while(quickNode!=null||slowNode!=null){
            if(quickNode==slowNode){
                return quickNode;
            }

            slowNode=slowNode.getNext();
            quickNode=quickNode.getNext();
            if(quickNode!=null){
                quickNode=quickNode.getNext();
            }
        }
        return null;
    }

    /**
     * 需找入口结点
     * @param root
     * @return
     */
    public static ListNote entryNode(ListNote root){        
        ListNote meetingNote=meetNode(root);//获得环内相遇结点
        if(meetingNote==null){
            return null;//无环
        }
        int nodesInLoop=1;
        ListNote note1=meetingNote;
        while(note1.getNext()!=meetingNote){//求出环内结点数
            note1=note1.getNext();
            nodesInLoop++;
        }
        note1=root;
        for(int i=0;i<nodesInLoop;i++){//node1先走nodesinloop步
            note1=note1.getNext();
        }
        ListNote note2=root;
        while(note1!=note2){//两结点相等即为环入口
            note1=note1.getNext();
            note2=note2.getNext();
        }
        return note1;
    }


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【POJ 1039】 Pipe (叉积判方向+叉积求交)
【POJ 1039】 Pipe
一个水管由多个拐点组成 给出每个拐点的上点 管宽1 即管上下两点分别为(x,y) (x,y-1)
问从管口射入光线能到达的最远的x 光线不可折射反射
分析可知 光线射得最远 一定会夹在上下两个拐点之间 画画图就明白了 并且一定是一上一下
这样枚举每两个拐点 每两个可以组成(x1-x2,(y1-1)-y2) (x1-x2,y1-(y2-1))这样两个上下向量
只要每个向量能不能从管口射入 并且找到他最远射到的位置即可
判断能不能射入 只要从后一个点往前枚举每个点(由于枚举的两个点之间的拐点也要判断 所以从后一个点往前枚举)
每个拐点的上下两点分别可以跟后一个点构成向量 如果上点跟后点构成向量在枚举的向量下方 或者下点构成的向量在枚举的向量上方 就说明碰到阻碍 即无法以该光线的轨迹从管口射入到此 判断向量相对位置就是叉乘 叉乘为正 说明后向量->前向量顺时针转动 否则逆时针
如果某个向量(光线)能从管口射入到此(前面没有障碍) 往右找能射达的最远点 同样的原理 刚才条件是没有阻碍 这次是有阻碍 当出现上面两种情况之一时 说明被组挡住了 此时在管壁形成的点为最远点
求x值时也用到了叉乘 叉乘中的求交点坐标 
假设过(x0,y0)直线(x1-x0,y1-y0) 与线段 (x2,y2)(x3,y3)相交 交点分割线段为|(x2-x0,y2-y0)x(x1-x0,y1-y0)| : |(x3-x0,y3-y0)x(x1-x0,y1-y0)| 'x'为叉乘 分割出来的两端比例就是叉乘之比 至于推到过程。。。弱不会作图。。大家自行推导或百度 大体就是因为叉乘就是以两向量为边的平行四边形的面积 也是三角形面积的平方 两边三角形之比就是截取的线段两部分之比
这样不断枚举判断是否可达再求x即可
要注意 x可能为负！！！一开始因为直接初始0导致WATOT 此题精度不过分 直接跟0判断就行


代码如下:

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#define INF 0x3f3f3f3f

using namespace std;

typedef struct Point
{
    double x,y;
}Point;

typedef struct Line
{
    double x,y;
     bool operator > (const struct Line a)const//该线->a 顺时针
    {
        return x*a.y - a.x*y < 0;
    }
    bool operator < (const struct Line a)const//该线->a 逆时针
    {
        return x*a.y - a.x*y > 0;
    }
    double operator ^ (const struct Line a)const//求叉乘
    {
        return  fabs(x*a.y-a.x*y);
    }
}Line;

Point pt[20];
int n;

double xnod(Point a,Point b,Point c,Point d)//求直线与线段交点的横坐标
{
    double t1,t2;
    Line l1,l2,l3;
    l1.x = b.x-a.x;
    l1.y = b.y-a.y;
    l2.x = c.x-a.x;
    l2.y = c.y-a.y;
    l3.x = d.x-a.x;
    l3.y = d.y-a.y;
    t1 = l2^l1;
    t2 = l3^l1;
    return c.x + (d.x-c.x)*(t1/(t1+t2));
}

double run(double x1,double y1,double x2,double y2,int low,int high)
{
    Line L,l;
    int i;
    L.x = x1 - x2;
    L.y = y1 - y2;
    for(i = 0; i < high; ++i)
    {
        l.x = pt[i].x - x2;
        l.y = pt[i].y - y2;
        if(l > L) return -INF;//高点形成的向量在光线下方(向量->光线 顺时针) 受到阻碍 即光线不可达 返回负无穷
        l.x = pt[i].x - x2;
        l.y = pt[i].y -1 - y2;
        if(l < L) return -INF;//低点形成的向量在光线上方(向量->光线 逆时针) 同上
    }

    L.x = x2 - x1;
    L.y = y2 - y1;
    for(i = high+1; i < n; ++i)
    {
        l.x = pt[i].x - x1;
        l.y = pt[i].y - y1;
        if(l < L) return xnod(Point{x1,y1},Point{x2,y2},Point{pt[i-1].x,pt[i-1].y},Point{pt[i].x,pt[i].y});//受到'\'这种管壁阻碍
        l.x = pt[i].x - x1;
        l.y = pt[i].y -1 - y1;
        if(l > L) return xnod(Point{x1,y1},Point{x2,y2},Point{pt[i-1].x,pt[i-1].y-1},Point{pt[i].x,pt[i].y-1});////受到'/'这种管壁阻碍
    }
    return INF;//穿过整管
}

int main()
{
    int i,j;
    double ans;
    while(~scanf("%d",&n) && n)
    {
        for(i = 0; i < n; ++i) scanf("%lf %lf",&pt[i].x,&pt[i].y);

        ans = -INF;//初始化负无穷！！！
        for(i = 0; i < n; ++i)
            for(j = i+1; j < n; ++j)
                ans = max(ans,max(run(pt[i].x,pt[i].y,pt[j].x,pt[j].y-1,i,j),run(pt[i].x,pt[i].y-1,pt[j].x,pt[j].y,i,j)));

        if(ans == INF) puts("Through all the pipe.");
        else printf("%.2f\n",ans);
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

【Sublime Text 3】Sublime Text 3 - cracked 3083\3085
                                                                                     
要使用3086破解版的童鞋请访问以下地址:
http://down.repaik.com/SublimeText/
Here's the address for cracked 3086 just in case someone wants to use it.
                     
                                                                                     
由于最新版本3086屏蔽了以下注册码，请童鞋们换回3085继续使用


3085下载地址:
http://pan.baidu.com/s/1kTKg9x1
密码:gbai




也可使用以下注册码进行手动注册。



—– BEGIN LICENSE —–
Andrew Weber
Single User License
EA7E-855605
813A03DD 5E4AD9E6 6C0EEB94 BC99798F
942194A6 02396E98 E62C9979 4BB979FE
91424C9D A45400BF F6747D88 2FB88078
90F5CC94 1CDC92DC 8457107A F151657B
1D22E383 A997F016 42397640 33F41CFC
E1D0AE85 A0BBD039 0E9C8D55 E1B89D5D
5CDB7036 E56DE1C0 EFCC0840 650CD3A6
B98FC99C 8FAC73EE D2B95564 DF450523

—— END LICENSE ——





版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu3887 Counting Offspring(dfs序+树状数组)
题目链接：点击打开链接
题目描述：给定一棵树，统计一棵子树中节点编号小于子树根节点的数量？


解题思路：
先dfs预处理，对于每个子树可以得到一段连续的序列
使用树状数组求连续区间的和


注意：
1、树是无向图，建树时注意建两条边，由于测试案例比较坑，我以为左边为右边的父节点，所以建图时只见了一条边，导致一直tle
2、dfs容易栈溢出，记得使用stack模拟递归（stack+标记数组即可）
3、注意输出格式


#include <cstdio>
#include <cstring>
#include <stack>
#define MAXN 100010
using namespace std;
int vis[MAXN][2];
int n,p;
int head[MAXN];
struct Edge{
    int v,next;
}edge[MAXN*2];///Time Limit Exceeded
int tol;
void addEdge(int u,int v){
    edge[tol].v=v; edge[tol].next=head[u]; head[u]=tol++;
    edge[tol].v=u; edge[tol].next=head[v]; head[v]=tol++;///Time Limit Exceeded
}
int id;
stack<int> st;
bool flag[MAXN];
void dfs(int rt){
    while(!st.empty()) st.pop();
    vis[rt][0]=id++;
    st.push(rt);
    flag[rt]=true;
    while(!st.empty()){
        rt=st.top();
        while(flag[edge[head[rt]].v]) head[rt]=edge[head[rt]].next;///Time Limit Exceeded
        if(head[rt]!=-1){
            vis[edge[head[rt]].v][0]=id++;
            flag[edge[head[rt]].v]=true;
            st.push(edge[head[rt]].v);
            head[rt]=edge[head[rt]].next;
        }
        else
        {
            vis[rt][1]=id++;
            st.pop();
        }
    }
}
int C[MAXN*2];
int lowbit(int x){
    return x&(-x);
}
int sum(int pos){
    int ret=0;
    while(pos>0){
        ret+=C[pos];
        pos-=lowbit(pos);
    }
    return ret;
}
void add(int pos,int v){
    while(pos<=id){
        C[pos]+=v;
        pos+=lowbit(pos);
    }
}
int main(){
    while(scanf("%d%d",&n,&p)!=EOF&&(n!=0||p!=0)){
        tol=0; memset(head,-1,sizeof(head));
        int u,v;
        for(int i=0;i<n-1;++i){scanf("%d%d",&u,&v); addEdge(u,v); }
        memset(flag,false,sizeof(flag));
        id=1;dfs(p);
        id--;
        memset(C,0,sizeof(C));
        for(int i=1;i<n;i++){
            add(vis[i][0],1);
            add(vis[i][1],1);
            printf("%d ",(sum(vis[i][1]-1)-sum(vis[i][0]))/2);
        }
        add(vis[n][0],1);
        add(vis[n][1],1);
        printf("%d\n",(sum(vis[n][1]-1)-sum(vis[n][0]))/2);///Presentation Error
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        屌丝giser成长记-大学篇

      作为一名屌丝giser的我，刚接触gis专业是2007年的大一，好悲催，当时gis这个专业是被调剂的，我压根都不知道gis为何物，那时候gis冷门的一逼，报名这个专业的寥寥无几。记得那时候得知被调剂到这个专业的时候，心情失落到极点，曾一度打算放弃就读，回去复读一年，以为gis是要到野外跑的那种，后面经过上网百度搜索gis以及查找本科学校的gis专业，才知道并不是这么一回事。本科学校把gis安排在计算机学院下面，这是比较少有的，主要是偏向gis开发方面，有点类似百度地图的电子地图等等，如今暗暗的庆幸，当初没有放弃，不然就没有后面的点点滴滴gis经历，更没有今天的我。从2007年接触gis以来，我没想到一路以来这么多年，一直守候着gis，跟gis作伴，中间起关键作用的是读研的三年（依然是gis专业），其中很多本科同学毕业之后要是弄java或者C#开发，要是就是转行了，坚守gis的很少很少，毕竟2011年本科毕业的时候，gis依然是那么的冷门，屌丝一枚。

      大一大二两年都是朦胧中度过，属于混日子的，应付式的考试，顺利的拿到学分就了事，学了一大推的gis基础课，都是死记硬背，比如经济地理学（1，2），地理信息系统导论，地图学，遥感导论等等，现在我早已忘光了，幸好还学了计算机编程C语言以及C++，让我自己有点编程的底子，为以后学习gis开发打下了基础，尽管后面做gis二次开发的时候不是用c、c++来编写的。除了计算机编程语言之外，还有就是数据结构以及数据库，这两门课程对我的帮助也挺大，尤其是对开发者来说。期间还谈了两次恋爱，然而并没有什么鸟用，傻乎乎的，谈了跟没谈一样，来也匆匆去也匆匆，如过客一般的存在，并不知道为何恋爱，也就是经历过这么一回事罢了，当时也有跟风的因素在吧。

      大学的转折点在于大二暑假，之前虽然学习了计算机的基本语言，但是没有系统化的学习上机操作，更没有经过项目的实战，刚好暑假有这么一个机遇，这里我要感谢我的好基友小黄，当时要不是没有他的积极向导师建议我，让我跟他一起参与导师的项目的话，我也没有机会进去。小黄也是gis的，他编程能力特强，在专业是数一数二的，我的gis编程之路就是在他的带领下，慢慢的入门，慢慢的熟悉起来的。记得当时那个项目是基于遥感影像内容的检索，属于遥感影像识别的，简单的来说就是以一幅影像来匹配影像库相似度的前20的影像图，我们实现的是基于三种方法来检索，分别是基于文本、基于影像的纹理特征值以及基于影像的形状搜索。其中，我负责比较简单的基于文本和基于影像的纹理特征值，小黄负责的是复杂度较高的基于影像形状特征检索。那一套是用C++来实现，用到MFC，当时觉的用MFC模式设计界面方式好方便，初学者都是喜欢那种拖拉控件布局界面吧，虽说我实现的功能，相对来说蛮简单的，但是对当时的我来说，也折腾的很久，不断的请教小黄，还有就是积极的上网搜索资源，百度搜索，csdn，那时候不知道有博客园，是小黄推荐csdn。我在csdn论坛里面问了很多问题，里面的大神回答的也挺积极的，从中，我找到了解决问题的方案或者思路，真的挺管用的。

      这个暑假真忙，中地MapGIS来到我们学校培训MapGIS开发，培训学生参加他们组办的MapGIS大赛，当时又是小黄，拉我，还有两位同学一起成立一个团队参加培训。那是第一次接触C#和.Net，MapGIS的培训内容就是。net平台，开发语言是C# 的二次开发，MapGIS是我接触的第一个GIS软件，当时觉的安装MapGIS好麻烦，安装时候360是要禁用的，不然安装不上，还有就是我们只能用学习版本，试用期是一个月，满期之后要重新注册，当时也没想那么多，而且觉的。net平台设计界面真的好方便，培训用的是windowform，直接就是简单拖拉来布局界面，当时搭建的界面真的不敢恭维。这次的MapGIS培训接触的知识，一切都是那么的陌生，幸好当时有个队长带领我们，也幸好当时的团队氛围够融洽，一起交流讨论，一起解决技术难题。当时的我们是多么的GIS菜鸟，现在回顾起来又想笑又觉的好囧，记得我们当时团队加入到一个mapgis群里，培训时候他们给的，刚开始我们很多的都不懂mapgis，也没什么经验，遇到不懂的，直接跑去群里问，不论mapgis软件还是gis编程问题，比如地图加载出不来，图层直接报错为空对象，甚至刚开始连断点跟踪都不会，不知道程序哪步出错了，唉，问的多了，群里的他们都厌倦了我们，说怎么不去百度先搜索一下，咋的咋的……但是我们还是慢慢的入门了，懂的了vs软件的调式，断点跟踪，排错，也知道了，遇到问题，先仔细分析，利用网络资源搜索，实在不行再到群里请教，慢慢的也熟悉了mapgis
 api的调用。经过这次培训的积累以及我们团队的努力，在后面的mapgis全国大赛，我们组获得了高级开发组二等奖，作品的主题是校园地理信息系统平台，哈哈，当时我们的团队还小小的风光了一把，校园挂起了横幅，还让那个我们去给GIS的师弟师妹做讲座，传授我们的心得体会以及学习GIS开发的方法。

      让我想不到的是，自从进入大三以来，我几乎都没用过C++，一直到现在，这点比较遗憾，大三到研三，都是在跟C#以及。net平台打交道了。自从参加MapGIS大赛之后，自己的编程能力得到进一步的提升，对MapGIS软件以及软件的应用有一定的了解和掌握，本以为自己会一直做mapgis二次开发，但是一次的偶然机会，接触了arcgis之后，竟然后面与mapgis越行越远，后面直接绝缘了，转向arcgis。那是一位研三的师兄的毕业设计，他自己忙不过来，然后请我们过来帮忙，顺便教我们，带领我们做他的毕业设计，这点我非常感激他，那么的耐心的指导我们。师兄的毕业设计主题室关于地震紧急疏散路径的研究，里面的算法是他自己弄的，GIS基本功能交给我们来实现，但是比较好的是他自己先搭建好了系统的框架，基于arcgis
 for silverlight的webgis，当时师兄还极力的推荐我们去学习silverlight，还真别说，当时2010时候，silverlight挺火的，谁知道后面几年它夭折了，唉，说起来就是坑啊，害我后面几年读书一直都是做arcgis for silverlight。不过当时确实是被silverlight做的界面吸引到了，做的那么炫酷，动态效果，还有就是webgis这种模式，bs的，不是之前mapgis学的cs模式。通过师兄的毕业设计，自己学会了安装arcgis desktop以及arcgis server，那时候是9.3.1版本，安装arcgis环境还挺麻烦的，尤其是新手，不像现在安装这么简单了。学会了arcgis
 api for silverlight的地图基本功能以及一些简单的gis分析，比如地图缩放，属性查询，空间查询，buffer分析以及最短路径分析等等。这一年也有两个gis专业的开发教程，关于webgis和arcgis engine的，当时webgis有flex方向以及js方向，后悔没选择js的。通过arcgis engine的课程，自己用vs2008开发工具练习搭建了一个简单的arcgis engine桌面系统，实现了一些简单的地图开发功能，比较的拖拉控件布局界面。整体而言，大二暑假和大三这段时期过的比较充实。

      进入大四的我，面临找工作还是考研的抉择，当时没想到有保研的名额，结果出乎我意外，争取到一名保研GIS的名额，在那之前自己也面试了几家GIS的公司，比如广州奥格，广州诚信所，都市圈，当时结果不太如意，当时许多同学都转行了，或者是做计算机编程，比如前面提到的小黄，有些女生做gis应用的，总之做gis开发的比较少。综合考虑了一下，还是选择保研继续深造去了，延续自己的GIS旅途……大四的这一年，没有课程可学，不是找工作就是编写毕业论文的准备，其中还帮师妹师弟指导一下他们的gis技术问题，他们的gis课程设计需要用到，哈哈，记得当时有个师妹貌似特别崇拜我似的，经常找我解决问题，时不时邀请我一起吃饭的，有时候去散散步什么的，感觉校园生活都是那么的美好，出来工作才发现，唉！

      就这么的度过了我的四年gis生活，没有多大的抱负，没有多大的理想和梦想，一切都是的那么的平凡，等待进入研究生的gis生活……

版权声明：本文为博主原创文章，未经博主允许不得转载。

完美跳槽，注意这八点！



　　一、不要让现在工作的公司知道你想跳槽：公司知道你想跳槽，对你会有所提防，一般不会再委以重任，晋升加薪的机会自然也就没有了。 
　　 
　　二、不要辞职找工作：找工作中的很多因素都不是自己能控制的，没有人可以确保自己一定能在某个期限内找到合适的工作。辞职后长时间找不到工作，会影响心情，打击自信，说不定就随便接受一个还不如原来的工作。

　　 
　　三、找工作期间尽量不要影响现有的工作：不要新的工作没找到，又丢了旧的工作。 
　　 
　　四、在没有拿到新单位书面的录用通知之前，不要辞职：世事难料，口头的承诺不保险，白纸黑字的东西比较可靠。 
　　 
　　五、在递交辞职信之前处理好所有的物品、文件与信件：有些公司，你交了辞职信后，就会禁止你再使用公司的电脑和文件。 
　　 
　　六、一定要通过电子邮件或寄挂号信的方式递交书面辞职信：万一离职发生纠纷，有据可查。 
　　 
　　七、商谈离职日期、赔款等问题时，要学会用法律保护自己的合法权益：一般情况下，只要提前30天递交书面辞职报告，无论公司同意与否，你都可以离职；现在很多公司与员工签署了行业禁止协议，实际上这个合同要生效，根据相关法律规定，公司必须支付给你巨额费用。换句话说，如果公司不付给你“损失费”，他们就肯定没有权利禁止你去同行业的公司。

　　 
　　八、递交辞职信后，做好并顺利交接现有的工作：这是任何一个职场人士基本的职业道德。（完）

版权声明：本文为博主原创文章，未经博主允许不得转载。

HTML5实现扫描识别二维码/生成二维码

扫描识别二维码

思路：

1. 操作摄像头，获取图片。HTML5 WEBRTC的navigator.getUserMedia方法去实时获取摄像头资源。 

2. 利用canvas使用相关算法分析图片识别图片得出结果，可用jquery.qrcode分析二维码 。（技术点：getImageData）




局限性：

移动平台支持getUserMedia/Stream API的浏览器比较少，支持列表http://caniuse.com/#feat=stream （目前没发现有IOS是支持的）






代码实现：

感谢github，有现成的算法

1. https://github.com/LazarSoft/jsqrcode

2. https://github.com/dwa012/html5-qrcode 

具体实现代码：

 

链接：http://pan.baidu.com/s/1ntH1le5 密码：7cic




生成二维码

具体代码

感谢github

1. https://github.com/LIGuoxiang/QRCode

      

链接：http://pan.baidu.com/s/1kT8HHH1 密码：6byh

测试用的二维码

qsa2015-08-08 CCID2212553









其他

IOS替代方案笔记：

调用摄像头拍照，把图片传到h5页面。然后在解析。



iOS 8版Safari可利用摄像头扫描录入信用卡号

http://36kr.com/p/212638.html




版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        实践计划进度etc.临时
2015年8月25日 13:26:04
上午完成:

lnk病毒三种利用方式的最终分析.并发文分享.
简要查看EdrawMax的注册方式中的陷阱,并做了记录.

暴露出的问题: 
正则表达式有点忘了.需要复习
下午: 
反调试课程.
晚上: 
阅读上午提取出的vbs病毒源码.√ 
+复习正则 
+学习python基础
2015年8月24日 22:28:44
近期任务安排:

lnk病毒三种.利用方式探究
结业前复习工作
杀毒软件用户模型探究工作.
某款感染性病毒的细致分析.

今天下午完成的工作有:

保护杀软启动项目的探究
浙大公开课-数据结构-复习
等.

2015年8月22日 12:50:46

基于图像识别的骚扰欺诈窗口拦截图像识别部分已经做出Demo,并对多种图形匹配算法的实战效果进行了比对.虽然部分算法通过了我们的筛选测试,但是结果差强人意.最近一直在查找资料并思考适合我们需求的图形识别算法.正在设计一种有趣的算法,该算法基于2D场景下结构匹配是我们另一个独立项目算法的降维(参见这里:从百度识图效果对智能识图的一些思考).
我计划在近期详细分析一款感染病毒来自于我高中时代的收藏.
在策划一款叫”斯巴达勇士”的智力闯关游戏APP.

2015年8月18日 11:55:36
常用加密算法的学习还在继续.已经将ZeroRootkit中的算法转换为CPP加入自己的项目中. 
完成了大部分壳设计的工作.

使用了调试器模块来达到反调试的目的.
设计了一种算法确保壳程序在内存中解密代码的不完整性.

近期计划:

整理已经完成的基于图像识别的骚扰欺诈窗口拦截引擎的代码.尽快做出Demo.
分析非对称算法在汇编上的表现.
三种快捷方式病毒利用方式分析.

2015年8月8日 07:27:08
近况:

复习调试器原理后用了一周打造了一个自己的简易调试器.
在DIY PE工具的同时在实现自己的壳.
该如何呈现自己的学习内容以分享给网友呢?长篇大论会涉及到大量简易的知识为了照顾新手读者,而介绍重复的知识有待商榷. 
我打算来个精华笔记整理,把自己遇到的不易解决的问题和探寻的答案整理成博文.
最近你的病毒样本分析文章没有继续?  最近虽然做了一些相关的工作涉及MFC恶意程序的分析.一直有思考恶意程序行为分析如何才能提高一步,机器可以识别的东西我们掌握就好,做些机器目前不好做的事情.也就是创新哈: 
更加响应市场急切需求的恶意程序识别和处置.
我的环境倒是够自由的.只是每天为基本生活而惆怅.

计划:

分析Win10的安全新特性.开始新系统之旅.
常用加密算法探究已经完成了部分.常用算法识别工具原理探究.
常用算法复习,并行化优化探究.

2015年7月12日 09:08:01
知识欠缺的地方,

对于数据结构很久没有复习了.该彻底地复习一下.
常用的加密算法.因为可能在逆向中常遇到.所以该来次总结和补漏.

分割线++

内核的学习,驱动开发的学习已经开始.
基于图像识别的反欺诈程序. 
+++++++++++++++++++++++++++++++++++

未知
如何向新手介绍IDA这款利器?最近一直在想如何在自己的系列文章中有效地介绍这款工具.
2015年6月7日 17:22:33
对非对称加密敲诈类恶意程序的识别与防护 
抗毒狮入门基础知识123 
构建秘术-探讨 
科幻小说-<百年之后> 
逆向病毒之策略探讨 
ReStart过杀软的逻辑 
StepByStep黑色样本没有讲清楚的事情 
UPX壳的解压过程

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，在注明作者和来源的情况下可自由转载。

Xshell 注册密钥

Xshell 是一个强大的安全终端模拟软件，它支持Telnet,SSH1,SSH2,RLogin等。非商业版可以免费使用，商业版注册码如下：
Xshell 4 注册码： 690313-111999-999313
Xftp 4 注册码：101210-450789-147200
Xmanager注册码：101210-450789-147200


版权声明：本文为博主原创文章，转载时请附带本博客链接声明出处。

BNUOJ 39423  暴力,DFS

最有的答案肯定是找到一些点的集合，这些点两两之间是朋友关系。
考虑到n，m比较小，这样的集合最多只有14个点，暴力找点的集合
先找出1 个点的集合，有n个这样的集合
然后找出2个点的集合，找的时候要求编号比之前的大，这样就能保证不重不漏



#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cctype>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>
typedef long long ll;
using namespace std;
struct node
{
    int tot;
    vector<int> p[11111];
}ji[16];
int n,m;
int Map[110][110];
int main()
{
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        memset(Map,0,sizeof(Map));
        for(int i=0;i<m;i++)
        {
            int x,y,z;
            scanf("%d%d%d",&x,&y,&z);
            Map[x][y] = Map[y][x] = z;
        }
        for(int i=0;i<16;i++)
        {
            for(int j=0;j<10010;j++)
                ji[i].p[j].clear();
            ji[i].tot = 0;
        }
        for(int i=1;i<=n;i++)
            ji[0].p[i-1].push_back(i);
        ji[0].tot = n;
        int Max = 0;
        for(int i = 0;i<min(n,14);i++)
        {
            int len = ji[i].tot;
            for(int j = 0;j < len;j++)
            {
                int ss = ji[i].p[j].size();
                int now = ji[i].p[j][ss-1];

                for(int k = now+1;k <= n;k ++ )
                {
                    int flag = 1;
                    for(int s = 0;s < ss;s++)
                        if(Map[k][ ji[i].p[j][s] ] ==0)
                            flag = 0;
                    if(flag)
                    {
                        int Sum  = 0;
                        for(int s = 0;s<ss;s++)
                            ji[i+1].p[ji[i+1].tot].push_back( ji[i].p[j][s]);
                        ji[i+1].p[ji[i+1].tot].push_back(k);

                        int L =  ji[i+1].p[ji[i+1].tot].size();
                        for(int ii = 0;ii<L;ii++)
                        {
                            int Min = 9999999;
                            for(int jj=0;jj<L;jj++)
                                if(ii!=jj)
                                Min = min(Min,Map[ji[i+1].p[ji[i+1].tot][ii]][ji[i+1].p[ji[i+1].tot][jj]]);
                            Sum +=Min;
                        }
                        Max = max(Max,Sum);
                        ji[i+1].tot++;
                    }

                }
            }
        }
//        for(int i=0;i<3;i++)
//            cout<<ji[i].tot<<endl;
        printf("%d\n",Max);
    }
    return 0;
}





DFS写法


#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cctype>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>
typedef long long ll;
using namespace std;
int Map[111][110];
int s[111];
int cur ;
int n,m;
int Max=  0;
int dfs(int st,int cur)
{
    if(cur>=2)
    {
        int sum = 0;
        for(int i=1;i<=cur;i++)
        {
            int Min  = 99999999;
            for(int j=1;j<=cur;j++)
            if(i!=j)
                Min =  min(Min,Map[s[i]][s[j]]);
            sum+=Min;
        }
        Max = max(sum,Max);
    }
    for(int i = st+1;i <= n;i++)
    {
        int ok = 1;
        for(int j = 1;j<=cur;j++)
        {
            if(Map[i][s[j]]==0)
                ok = 0;
        }
        if(ok)
        {
            s[cur+1] = i;
            dfs(i,cur+1);
        }
    }
    return 0;
}
int main()
{
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        for(int i=0;i<m;i++)
        {
            int x,y,z;
            scanf("%d%d%d",&x,&y,&z);
            Map[x][y]  = Map[y][x] = z;
        }
        Max = 0;
        dfs(0,0);
        printf("%d\n",Max);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

Aizu - 2305 Beautiful Currency (二分 + DFS遍历)

F. Beautiful Currency

Time Limit: 5000ms
Case Time Limit: 5000ms
Memory Limit: 65536KB



64-bit integer IO format: %lld      Java class name: Main

Submit Status PID:
 39422

Font Size: 
+
 
-



Beautiful Currency

KM country has N kinds of coins and each coin has its value a_i.

The king of the country, Kita_masa, thought that the current currency system is poor, and he decided to make it beautiful by changing the values of some (possibly no) coins.

A currency system is called beautiful if each coin has an integer value and the (i+1)-th smallest value is divisible by the i-th
 smallest value for all i (1 ¥leq i ¥leq N-1).

For example, the set {1, 5, 10, 50, 100, 500} is considered as a beautiful system, while the set {1, 5, 10, 25, 50, 100} is
 NOT, because 25 is not divisible by 10.

Since changing the currency system may confuse citizens, the king, Kita_masa, wants to minimize the maximum value of the confusion ratios. Here, the confusion ratio for the change in the i-th
 coin is defined as |a_i - b_i| / a_i, where a_i and b_i is
 the value of i-th coin before and after the structure changes, respectively.

Note that Kita_masa can change the value of each existing coin, but he cannot introduce new coins nor eliminate existing coins. After the modification, the values of two or more coins may coincide.

Input

Each dataset contains two lines. The first line contains a single integer, N, and the second line contains N integers, {a_i}.

You may assume the following constraints:

1 ¥leq N ¥leq 20

1 ¥leq a_1 ¥lt a_2 ¥lt... ¥lt a_N ¥lt 10^5

Output

Output one number that represents the minimum of the maximum value of the confusion ratios. The value may be printed with an arbitrary number of decimal digits, but may not contain an absolute error greater than or equal to 10^{-8}.

Sample Input 1
3
6 11 12


Output for the Sample Input 1
0.090909090909


Sample Input 2
3
6 11 24


Output for the Sample Input 2
0.090909090909


Sample Input 3
3
6 11 30


Output for the Sample Input 3

0.166666666667

二分P可以得到每一个数的变化范围[n - n * P, n + n * P]中，接着就是检查是否存在一个序列满足后一个是前一个的倍数。





#include <map>
#include <set>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <vector>
#include <queue>
#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <algorithm>
using namespace std;


#define pb push_back
#define mp make_pair
#define fillchar(a, x) memset(a, x, sizeof(a))
#define copy(a, b) memcpy(a, b, sizeof(a))
#define S_queue<P> priority_queue<P, vector<P>,greater<P> >
#define FIN freopen("D://imput.txt", "r", stdin)


typedef long long LL;
typedef pair<int, int > PII;
typedef unsigned long long uLL;
template<typename T>
void print(T* p, T* q, string Gap = " "){int d = p < q ? 1 : -1;while(p != q){cout << *p;p += d;if(p != q) cout << Gap; }cout << endl;}
template<typename T>
void print(const T &a, string bes = "") {int len = bes.length();if(len >= 2)cout << bes[0] << a << bes[1] << endl;else cout << a << endl;}

const int INF = 0x3f3f3f3f;
const int MAXM = 2e1 + 5;
const int MAXN = 1e2 + 5;
const double eps = 1e-8;
int A[MAXM], n;
double M;

bool DFS(int x, int id, double Max, double m){//是否存在一个序列满足条件
    if(id >= n) {
        M = min(Max, M);//更新最大值
        return true;
    }
    bool flag = false;
    int f = (int)(A[id] * m);
    int cnt = 1,Ma = A[id] + f,Mi = A[id] - f > 1 ? A[id] - f: 1;
    while(cnt * x <= Ma){
        if(cnt * x < Mi) {
            cnt ++;
            continue;
        }
        if(cnt * x >= Mi && cnt * x <= Ma){
            double f_t = fabs(cnt * x - A[id]) / A[id] * 1.0;
            if(DFS(cnt * x, id + 1, max(Max, f_t), m)) {
                    flag = true;
            }
        }
        cnt ++;
    }
    return flag;
}

bool C(double m){
    bool flag = false;
    int f = (int)(A[0] * m);
    int Mi = A[0] - f > 1? A[0] - f : 1, Ma = A[0] + f;
    for(int i = Mi;i <= Ma;i ++){
        if(DFS(i, 1, fabs(A[0] - i) / A[0] * 1.0, m)) {
                flag = true;
        }
    }
    return flag;
}

int main(){
    //FIN;
    while(cin >> n){
        for(int i = 0;i < n;i ++){
            cin >> A[i];
        }
        M = INF;
        double lb = -1,ub = 1.0;
        while(ub - lb > eps){
            double mid = (ub + lb) / 2.0;
            if(C(mid)) ub = mid;
            else lb = mid;
        }
        printf("%.12lf\n", M);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

数据挖掘的几个基本概念

True Positive （真正, TP）被模型预测为正的正样本；

True Negative（真负 , TN）被模型预测为负的负样本 ；

False Positive （假正, FP）被模型预测为正的负样本；

False Negative（假负 , FN）被模型预测为负的正样本；


True Positive Rate（真正率 , TPR）或灵敏度（sensitivity） 
   TPR = TP /（TP + FN） 
   正样本预测结果数 / 正样本实际数

True Negative Rate（真负率 , TNR）或特指度（specificity） 
   TNR = TN /（TN + FP） 
   负样本预测结果数 / 负样本实际数 

False Positive Rate （假正率, FPR） 
   FPR = FP /（FP + TN） 
   被预测为正的负样本结果数 /负样本实际数 


False Negative Rate（假负率 , FNR） 
   FNR = FN /（TP + FN） 
   被预测为负的正样本结果数 / 正样本实际数




召回率和精度：
例如：
－ 系统检索到的相关文档（Ａ）

－ 系统检索到的不相关文档（Ｂ）

－ 相关但是系统没有检索到的文档（Ｃ）

－ 不相关但是被系统检索到的文档（Ｄ）


 

直观的说，一个好的检索系统检索到的相关文档越多越好，不相关文档越少越好．

召回率和精度是衡量信息检索系统性能最重要的参数．

召回率Ｒ：用检索到相关文档数作为分子，所有相关文档总数作为分母，即 R=A/(A+C)

精度Ｐ： 用检索到相关文档数作为分子，所有检索到的文档总数作为分母．即  P=A/(A+B).

版权声明：本文为博主原创文章，未经博主允许不得转载。

公告：C币兑换平台系统停站维护公告

亲爱的CSDN用户：

                           CSDN C币平台将于2015年8月24日22点至8月25日7点进行服务器更新。

                           升级期间会影响大家的正常访问和操作。如给您带来不便，敬请谅解。




                           C币系统是CSDN最新推出的兑换机制，C币用于奖励用户对社区有价值的贡献。

                           C币可以兑换论坛可用分、下载积分、定制纪念品等。







                          结束后有任何问题请发邮件到webmaster@csdn.net反馈给管理员。 

                          感谢您对CSDN的支持！



CSDN产品运营部
2014年8月24日










                           






版权声明：本文为博主原创文章，未经博主允许不得转载。

PreTranslateMessage  DoModal()   ASSERT(::IsWindow(m_hWnd)
PreTranslateMessage  函数调用DoModal()在关闭对话框时会出现下面的bug！



原因分析：在PreTranslateMessage里的获取对应m_hWnd，DoModal()模态对话框退出后，m_hWnd不是有效的窗口句柄，需要return
 rrue
解决方法：在PreTranslateMessage中处理完键盘消息后，做一下两步：
1.重新设置焦点
2，return TRUE



//Enter键：进入当前选中模块
if (pMsg->wParam == VK_RETURN)
{


if (CountEnter == 2)
{
if (::IsWindow(GetSafeHwnd()))
{
pDlg->pDlgPgzb->OnBnClickedBtAdd();//  BN_CLICKED 调用了DoModal()


////P:重新返回焦点位置&&调用dlgmethod返回return 1；
pDlg->pDlgPgzb->SetFocus();
pDlg->pDlgPgzb->m_List_Method.SetItemState(0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
SetCursorPos(120,210);
return 1;

}



}












版权声明：本文为博主原创文章，未经博主允许不得转载。

Fedora21安装Fcitx及搜狗输入法的问题汇总

问题汇总
在Fedora21中按【1】、【2】安装Fcix及搜狗输入法后，会出现以下问题。
问题一:安装Fcitx后却没有任何输入法图标显示。
解决方法：需要在fcitx配置器中按需调整。按附录图1、2配置，即可正常使用LibPinyin和English，并可用Rshift进行切换。

问题二:   汉语的简繁切换 
解决方法：对汉语的简繁切换在Fcitx Configuration->Addon里面，找到并打开后如附录图3所示，特别注意的一点是”Toggle for enable or disable”后面的快捷键不是一个组合，而是表示或的关系，例如下图设定的意思是，输入F3或F6进行简繁切换。

问题三: 以上安装方法只能使用LibPinyin，但搜狗输入法不能使用。
解决方法：参考【3】重新安装搜狗输入法即可。

问题四: 在TeXstudio中无法输入中文，即无法调用fcitx输入法。
解决方法：参考【4】、【5】，添加fcitx对QT软件的支持，命令如下
sudo yum install fcitx-qt5

参考博客
【1】Fedora 19安装Fcitx输入法并安装搜狗输入法资源包 
【2】Fedora Server 21 安装 搜狗拼音输入法 
【3】fedora 21 安装搜狗输入法  
【4】Fcitx官方文档 
【5】Ubuntu下安装Texmaker的问题与解决方案

附录
====图1 

===图2 

===图3 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

最短路径问题
题目描述
平面上有n个点（n<=100），每个点的坐标均在-10000～10000之间。其中的一些点之间有连线。若有连线，则表示可从一个点到达另一个点，即两点间有通路，通路的距离为两点间的直线距离。现在的任务是找出从一点到另一点之间的最短距离。
输入
第1行为整数n。 
第2行到第n+1行（共n行），每行两个整数x和y，描述了一个点的坐标（以一个空格分隔）。 
第n+2行为一个整数m，表示图中连线的个数。 
此后的m行，每行描述一条连线，由两个整数i和j组成，表示第1个点和第j个点之间有连线。 
最后一行：两个整数s和t，分别表示源点和目标点。
输出
仅1行，一个实数（保留两位小数），表示从s到t的最短路径长度。
示例输入

5
0 0
2 0
2 2
0 2
3 1
5
1 2
1 3
1 4
2 5
3 5
1 5

示例输出

3.41


最短路问题，可以用floyd算法

#include<stdio.h>
#include<string.h>
#include<math.h>
#define N 10001
int a[101],b[101];
double g[101][101];
int main()
{
int n,m,i,j,k,x,y,s,t;
  scanf("%d",&n);
  for(i=1;i<=n;i++)
  {
    scanf("%d%d",&a[i],&b[i]);
  }
  for(i=1;i<=n;i++)
  {
    for(j=1;j<=n;j++)
    {
      g[i][j]=200000000;
    }
  }
  scanf("%d",&m);
  for(i=1;i<=m;i++)
  {
    scanf("%d%d",&x,&y);
    g[x][y]=sqrt(pow(a[x]-a[y],2)+pow(b[x]-b[y],2));
    g[y][x]=g[x][y];
  }
  scanf("%d%d",&s,&t);
  for(i=1;i<=n;i++)
  {
    g[i][i]=0;
  }
  for(k=1;k<=n;k++)
  {
    for(i=1;i<=n;i++)
    {
      for(j=1;j<=n;j++)
      {
       if(g[i][j]>g[i][k]+g[k][j])
       g[i][j]=g[i][k]+g[k][j];
      }
    }
  }

printf("%.2lf",g[s][t]);

  return 0;
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1702 ACboy needs your help again!
纯栈和队列应用的水题，这么好的水题我以前怎么没发现
#include<iostream>
#include<queue>
#include<stack>
using namespace std;
int n;
void que()
{
	queue<int>root;
	for(int i=0;i<n;i++)
	{
		string cmd;
		cin>>cmd;
		if(cmd=="IN")
		{
			int x;
			cin>>x;
			root.push(x);
		}
		else
		{
			if(root.size())
			{
				cout<<root.front()<<endl;
				root.pop();
			}
			else cout<<"None"<<endl;
		}
	}
}
void sta()
{
	stack<int>root;
	for(int i=0;i<n;i++)
	{
		string cmd;
		cin>>cmd;
		if(cmd=="IN")
		{
			int x;
			cin>>x;
			root.push(x);
		}
		else
		{
			if(root.size())
			{
				cout<<root.top()<<endl;
				root.pop();
			}
			else cout<<"None"<<endl;
		}
	}
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{	
		cin>>n;
		string cmd;
		cin>>cmd;
		if(cmd=="FIFO") que();
		else sta();
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

将数组元素循环右移k个位置（Java实现）
用四种方法实现了将数组元素循环右移k个位置，相关的解释作为注释放在代码里面了。
package movearrayelement;

import java.util.BitSet;

public class MoveArrayElement {
	/**
	 * 每次把数组中所有元素移动一个位置，移动k轮
	 * @param array
	 * @param k
	 */
	public static void moveArrayElement(int[] array, int k) {
		int length = array.length;
		// 右移newk + n * length个位置，和右移newk个位置效果是一样的
		int newk = k % length;
		int temp = 0;
		for(int i = 0; i < newk; i++) {
			temp = array[length - 1];
			for(int j = length - 2; j >= 0; j--) {
				array[j+1]=array[j];
			}
			array[0]=temp;
		}
	}
	
	/**
	 * 开辟一个新数组，把旧数组中的元素直接放在新数组中正确的位置
	 * @param array
	 * @param k
	 * @return
	 */
	public static int[] moveArrayElement1(int[] array, int k) {
		int length = array.length;
		// 右移newk + n * length个位置，和右移newk个位置效果是一样的
		int newk = k % length;
		int[] newArray = new int[length];
		// 重复length次把元素从旧位置移到新位置
		for(int i = 0; i < length; i++) {
			// 求出元素新的位置
			int newPosition = (i + newk) % length;
			newArray[newPosition] = array[i];
		}
		return newArray;
	}
	
	/**
	 * 1.把一个元素放在一个正确的位置，再把被占位置的元素放到它应该在的正确的位置，一直
	 * 重复下去，直到数组的所有元素都放在了正确的位置；
	 * 2.但是必须考虑环形的情况，比如十个元素的数组，右移5个位置，这时，位置0的元素应该放在位置5，
	 * 位置5的元素应该放在位置0，这样，完全通过1的迭代就不能得到 正确的结果
	 * @param array
	 * @param k
	 */
	public static void moveArrayElement2(int[] array, int k) {
		int length = array.length;
		
		BitSet bitSet = new BitSet(length);
		boolean flag = false;
		// 保证最多只移动count=length次位置
		int count = 0;
		for(int j = 0; j < length; j++) {
			if (flag) {
				break;
			}
			if (!bitSet.get(j)) {
				// 右移newk + n * length个位置，和右移newk个位置效果是一样的
				int newk = k % length;
				// 旧位置
				int oldPosition = j;
				// 保存旧位置的值
				int oldValue = array[oldPosition];
				// 临时值
				int temp = 0;
				// 重复length次把元素从旧位置移到新位置
				for(int i = 0; i < length; i++) {
					// 求出元素新的位置
					int newPosition = (oldPosition + newk) % length;
					// 如果新位置已经放置了对得值，就不要往新位置再次放入值了
					if (bitSet.get(newPosition)) {
						break;
					}
					// 临时保存新位置(也就是新的旧位置)的值
					temp = array[newPosition];
					// 移动元素到新位置
					array[newPosition] = oldValue;
					// 又一个位置放置了正确的值
					count++;
					if (count == length) {
						flag = true;
						break;
					}
					// 新位置放置了正确的值
					bitSet.set(newPosition);
					// 永久保存旧位置的值
					oldValue = temp;
					// 新位置变为旧位置
					oldPosition = newPosition;
				}
			}
		}
		System.out.println(count);
	}
	
	/**
	 * 经典方法，三次倒置数组中对应位置的元素;
	 * 简单说一下原理：数组元素右移k个位置的结果是，原来在
	 * 后面的k个元素跑到了数组前面，原来在前面的length-k
	 * 个元素，跑到了数组的后面，并且前后两部分元素各自的顺序和
	 * 移动前一致，而倒置整个数组元素就是让后面k个元素跑到前面去，
	 * 让前面length-k个元素跑到后面去，但是倒置之后前后两部分
	 * 元素的顺序跟移动之前不一样了，倒置了，所以要把两部分的元素
	 * 倒置回来
	 * @param array
	 * @param k
	 */
	public static void moveArrayElement3(int[] array, int k) {
		// 倒置所有元素
		reverse(array);
		// 倒置前k个元素
		reverse(array, 0, k - 1);
		// 倒置后length - k个元素
		reverse(array, k, array.length - 1);
	}
	
	/**
	 * 倒置数组中begin和end之间的元素，包括begin和end
	 * @param array
	 * @param begin
	 * @param end
	 */
	private static void reverse(int[] array, int begin, int end) {
		int length = end - begin + 1;
		int half = length / 2;
		for(int i = 0; i < half; i++) {
			int temp = array[begin];
			array[begin] = array[end];
			array[end] = temp;
			begin++;
			end--;
		}
		
	}
	
	/**
	 * 倒置数组中begin和end之间的元素，包括begin和end
	 * @param array
	 * @param begin
	 * @param end
	 */
	private static void reverse(int[] array) {
		reverse(array, 0, array.length - 1);
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        ArrayList与LinkedList大比拼之add和remove
ArrayList与LinkedList大比拼之add和remove






各大公司的Java面试都会考到一些java源码的问题，这个系列我将一一为大家剖析
各种java重要的源码


ArrayList与LinkedList是经常会进行比较的2个类，因为他们都实现了List类
本质上讲，他们底层存储方式是不一样的
private transient Object[] elementData;

这个是ArrayList的底层存储方式，是一个对象数组
而LinkedList底层是什么呢？
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;


        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }

这就是LinkedList的一个内部类，也是它的存储方式,其实LinkedList的存储方式就是一个双向链表
所以下面所说的区别，其实也就是数据结构是顺序存储结构和链式存储结构的区别
先看添加,add方法
ArrayList:
public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
public void add(int index, E element) {
        rangeCheckForAdd(index);


        ensureCapacityInternal(size + 1);  // Increments modCount!!
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }

ArrayList重载的这2种add方法，其中都调用了ensureCapacityInternal(size + 1);这个方法一直查看调用，会发现这个方法其实
就是新创建一个长度为size+1的数组，然后将现在数组的值拷贝上去，如果是add(E e)，拷贝完成后将e放到最后即可，如果是
add(int index, E element),则需要再进行一次拷贝，建index以及之后的元素后移一位，然后再讲元素放到index位置即完成，补充
一句这里的拷贝都是native层实现。
LinkedList:
public boolean add(E e) {
        linkLast(e);
        return true;
    }
public void add(int index, E element) {
        checkPositionIndex(index);


        if (index == size)
            linkLast(element);
        else
            linkBefore(element, node(index));
    }

可以看到当添加到末尾的时候都调用了linkLast(e);方法
 void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }

其实就是新建一个Node然后放到最后，如果不是添加到末尾的时候先调用node(index)方法找到那个节点
 Node<E> node(int index) {
        // assert isElementIndex(index);


        if (index < (size >> 1)) {
            Node<E> x = first;
            for (int i = 0; i < index; i++)
                x = x.next;
            return x;
        } else {
            Node<E> x = last;
            for (int i = size - 1; i > index; i--)
                x = x.prev;
            return x;
        }
    }

这里的查找也做了一定的优化，判断这个节点是离头近还是离尾近，然后调用linkBefore方法插入
void linkBefore(E e, Node<E> succ) {
        // assert succ != null;
        final Node<E> pred = succ.prev;
        final Node<E> newNode = new Node<>(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
    }

再看删除,remove方法
ArrayList:
public E remove(int index) {
        rangeCheck(index);


        modCount++;
        E oldValue = elementData(index);


        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work


        return oldValue;
    }
public boolean remove(Object o) {
        if (o == null) {
            for (int index = 0; index < size; index++)
                if (elementData[index] == null) {
                    fastRemove(index);
                    return true;
                }
        } else {
            for (int index = 0; index < size; index++)
                if (o.equals(elementData[index])) {
                    fastRemove(index);
                    return true;
                }
        }
        return false;
    }

如果要按照索引删除，先copy(删除索引位置元素,并调整后面元素位置)，然后将最后一个元素置空，方便GC回收

modCount++;是因为modCount是记录这个ArrayList对象的修改次数
如果要按照元素删除的话，其实是先找到索引然后调用fastRemove()
private void fastRemove(int index) {
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work
    }

这个方法其实和按照索引删除基本一样，只不过少了个索引的越界检查，因为这个是查找到的
LinkedList:
public E remove() {
        return removeFirst();
    }
public E remove(int index) {
        checkElementIndex(index);
        return unlink(node(index));
    }
public boolean remove(Object o) {
        if (o == null) {
            for (Node<E> x = first; x != null; x = x.next) {
                if (x.item == null) {
                    unlink(x);
                    return true;
                }
            }
        } else {
            for (Node<E> x = first; x != null; x = x.next) {
                if (o.equals(x.item)) {
                    unlink(x);
                    return true;
                }
            }
        }
        return false;
    }

如果是直接删除，调用removeFirst方法
public E removeFirst() {
        final Node<E> f = first;
        if (f == null)
            throw new NoSuchElementException();
        return unlinkFirst(f);
    }



LinkedList默认是删除第一个元素
如果是按照索引删除，先运用node()找到这个元素，前面已经介绍过了，然后调用unlink()方法，
E unlink(Node<E> x) {
        // assert x != null;
        final E element = x.item;
        final Node<E> next = x.next;
        final Node<E> prev = x.prev;


        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
            x.prev = null;
        }


        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }


        x.item = null;
        size--;
        modCount++;
        return element;
    }

如果是按照元素删除，则是先找到那个元素，然后还是调用unlink()方法


总结：1.总体来看ArrayList和LinkedList的add和remove方法，LinkedList要更加简单一点，效率也更快，原因还
是因为，存储结构的不同
 2.还有就是会发现一个我们没有见过的属性modCount，记录修改次数，这个属性有什么用呢，后边慢慢给大家讲
 3.对了，补充一点，查看继承关系，会发现，ArrayList是继承了AbstractList，AbstractList才实现了List,而
LinkedList是直接实现了List,所以LinkedList可以说是ArrayList的叔叔
 
 
 下一篇将详细解析ArrayList和LinkedList的查询和修改

版权声明：本文为博主原创文章，未经博主允许不得转载。

leetcode:Permutation Sequence
Permutation Sequence 
The set [1,2,3,…,n] contains a total of n! unique permutations.
By listing and labeling all of the permutations in order,We get the following sequence (ie, for n = 3): 
“123” 
“132” 
“213” 
“231” 
“312” 
“321” 
Given n and k, return the kth permutation sequence.
Note: Given n will be between 1 and 9 inclusive.
class Solution {
public:
    string getPermutation(int n, int k) {
        int pTable[10] = { 1 };
        for (int i = 1; i <= 9; i++){
            pTable[i] = i * pTable[i - 1];
        }
        string result;
        vector<char> numSet{ '1', '2', '3', '4', '5', '6', '7', '8', '9' };
        while (n > 0){
            int temp = (k - 1) / pTable[n - 1];
            result += numSet[temp];
            numSet.erase(numSet.begin() + temp);
            k = k - temp * pTable[n - 1];
            n--;
        }
        return result;
    }
};
/*
In this program, pTable refers to permutation table and numSet refers to a set of numbers from 1 to 9. 
Before while loop, we need to initialize pTable and numSet, which is trivial.

In while loop, we do these following things.
1 calculate which number we will use.
2 remove that number from numSet.
3 recalculate k.
4 n--.

Finally, we return result.
*/

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android的控件CheckBox、ImageView以及ListView的自定义Adapter用法
概述
1、CheckBox一般用于多选框，在登录界面设置“是否保存账号“选项时也能用到。 
2、ImageView的常用属性有： 
       a、background：可以设置背景颜色和图片，在设置图片时，图片会被自动拉伸。 
       b、scaleType=”XXX“：XXX可以是fitStart、fitXY、fitcenter、center、centerCrop、centerSide、fitEnd。 
       c、tint：设置覆盖颜色和透明度。 
       d、setAlpha 设置可见度。 
  3、ListView的常用适配器有：ArrayAdapter、SimpleAdapter、自定义Adapter。
代码与演示：
CheckBox
布局
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">

    <RadioGroup
        android:id="@+id/radio_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_margin="10dp"
        android:checkedButton="@+id/man">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="性别："/>
        <RadioButton
            android:id="@+id/man"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="男"/>
        <RadioButton
            android:id="@+id/human"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="女"/>
        <RadioButton
            android:id="@+id/extras"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="其他"/>
    </RadioGroup>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="您的兴趣爱好是："/>

    <CheckBox
        android:id="@+id/checkbox_eat"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:checked="false"
        android:text="品尝美食"/>

    <CheckBox
        android:id="@+id/checkbox_game"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:checked="false"
        android:text="玩游戏"/>

    <CheckBox
        android:id="@+id/checkbox_sing"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:checked="false"
        android:text="唱歌"/>

    <CheckBox
        android:id="@+id/checkbox_tour"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:checked="false"
        android:text="旅游"/>

    <Button
        android:id="@+id/button_select"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="提 交 问 题"/>

</LinearLayout>
java代码实现选择监听
public class MainActivity extends Activity {

    private Button mButtonSelect;
    private CheckBox mCheckBoxEat;
    private CheckBox mCheckBoxGame;
    private CheckBox mCheckBoxSing;
    private CheckBox mCheckBoxTour;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.radio_button_layout);

        mCheckBoxEat = (CheckBox)findViewById(R.id.checkbox_eat);
        mCheckBoxGame = (CheckBox)findViewById(R.id.checkbox_game);
        mCheckBoxSing = (CheckBox)findViewById(R.id.checkbox_sing);
        mCheckBoxTour = (CheckBox)findViewById(R.id.checkbox_tour);
        mButtonSelect = (Button)findViewById(R.id.button_select);
        mButtonSelect.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String hobby = "";
                //用idChecked()方法判断是否被选中。
                if(mCheckBoxEat.isChecked()){
                    hobby += mCheckBoxEat.getText();
                }if(mCheckBoxGame.isChecked()){
                    hobby += mCheckBoxGame.getText();
                }if(mCheckBoxSing.isChecked()){
                    hobby += mCheckBoxSing.getText();
                }if(mCheckBoxTour.isChecked()){
                    hobby += mCheckBoxTour.getText();
                }
                Log.d("d",hobby);
            }
        });
    }
}
效果： 

ImageView
布局 
布局用的是ScrollView，用于实现可滚动的效果
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:fillViewport="false">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <ImageView
            android:id="@+id/imageview"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@mipmap/image"
            android:src="@mipmap/pk"
            android:tint="#88ff0000"/>

        <Button
            android:id="@+id/add"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="增加透明度"/>
        <Button
            android:id="@+id/sub"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="减少透明度"/>
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="center"
            android:src="@mipmap/image"/>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="centerCrop"
            android:src="@mipmap/image"/>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="centerInside"
            android:src="@mipmap/image"/>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitCenter"
            android:src="@mipmap/image"/>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitStart"
            android:src="@mipmap/image"/>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitEnd"
            android:src="@mipmap/image"/>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:src="@mipmap/image"/>

        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="matrix"
            android:src="@mipmap/image"/>
    </LinearLayout>
</ScrollView>
java代码实现调整透明度
@TargetApi(Build.VERSION_CODES.JELLY_BEAN)
public class ImageActivity extends Activity implements View.OnClickListener{
    private ImageView mImageView;
    private Button mAddAlphaBtn;
    private Button mSubAlphaBtn;
    private int mAlphaCount;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.imageview_layout);

        mImageView = (ImageView)findViewById(R.id.imageview);
        mAddAlphaBtn = (Button)findViewById(R.id.add);
        mSubAlphaBtn = (Button)findViewById(R.id.sub);
        mAlphaCount = mImageView.getImageAlpha();

        mAddAlphaBtn.setOnClickListener(this);
        mSubAlphaBtn.setOnClickListener(this);
    }
    @Override
    public void onClick(View v) {
        int code = Build.VERSION.SDK_INT;
        switch (v.getId()){
            case R.id.add:
                mAlphaCount-=5;
                if(code<16){
                    mImageView.setAlpha(mAlphaCount);
                }else {
                    mImageView.setImageAlpha(mAlphaCount);
                }
                break;
            case R.id.sub:
                mAlphaCount+=5;
                if(code<16){
                    mImageView.setAlpha(mAlphaCount);
                }else{
                    mImageView.setImageAlpha(mAlphaCount);
                }
                break;
            default:
                break;
        }
    }
}
结果：
ListView
1、ArrayAdapter
用于成列的显示数组中内容，每个view中只能显示单个文本。 
**布局
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <ListView
        android:id="@+id/my_list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

    </ListView>
</LinearLayout>
public class ListActivity extends Activity {
    private ListView mListView;
    private String[] array = {"张三","李四","王五","赵六"};
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.activity_listview);

        mListView = (ListView)findViewById(R.id.my_list_view);
        ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,R.layout.my_list_item,array);
        mListView.setAdapter(adapter);
    }
}
R.layout.my_list_item
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:padding="5dp"
          android:textSize="20sp"
          android:textColor="#ff0000"/>
结果演示： 

2、SimpleAdapter
能够让每个view里显示多条信息 
布局：
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <ListView
        android:id="@+id/my_list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

    </ListView>
</LinearLayout>
用java代码实现列表
public class ListActivity extends Activity {
    private ListView mListView;
    private List<HashMap<String,String>> mData;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.activity_listview);

        mListView = (ListView)findViewById(R.id.my_list_view);

        initData();
        SimpleAdapter simpleAdapter = new SimpleAdapter(this,mData,R.layout.list_simple_adapter_item,
                new String[]{"name","sex","age","hobby"},new int[]{R.id.item_name,R.id.item_sex,R.id.item_age,R.id.item_hobby});
        mListView.setAdapter(simpleAdapter);

        mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                HashMap<String,String> itemData = mData.get(position);
                Log.d("d",itemData.get("name")+itemData.get("sex")+itemData.get("age")+ itemData.get("hobby"));
            }
        });
    }

    private void initData() {
        mData = new ArrayList<>();
        HashMap<String,String> zhangsan = createMap("張三","男","19","愛好吃");
        HashMap<String,String> lisi = createMap("李四","女","21","愛好打麻將");
        HashMap<String,String> wangwu = createMap("王五","男","22","愛好打遊戲");
        HashMap<String,String> zhaoliu = createMap("趙六","男","17","愛好學習");
        mData.add(zhangsan);
        mData.add(lisi);
        mData.add(wangwu);
        mData.add(zhaoliu);
    }

    private HashMap<String,String> createMap(String name,String sex,String age,String hobby) {
        HashMap<String,String> people = new HashMap<>();
        people.put("name",name);
        people.put("sex",sex);
        people.put("age",age);
        people.put("hobby",hobby);
        return people;
    }
}
R.layout.list_simple_adapter_item
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="horizontal"
              android:layout_margin="15dp"
              android:gravity="center_vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <TextView
        android:id="@+id/item_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="姓名"/>
    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginLeft="10dp"
        android:layout_marginRight="10dp"
        android:orientation="vertical">
        <TextView
            android:id="@+id/item_sex"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="性別"/>
        <TextView
            android:id="@+id/item_age"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="年齡"/>
    </LinearLayout>
    <TextView
        android:id="@+id/item_hobby"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="愛好"/>
</LinearLayout>
结果： 

3、自定义Adapter
自定义Adapter一定要继承于BaseAdapter，且必须实现BaseAdapter的所有抽象方法。 
布局：
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <ListView
        android:id="@+id/my_list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

    </ListView>
</LinearLayout>
利用java代码实现上述SimpleAdapter实现的功能并且加上个人照片信息。 
 
1、在如图路径下新建两个包adapter、modle，包中分别新建两个类MyAdapter、Student 
Student如下：
public class Student {

    private String name;
    private String sex;
    private String age;
    private String hobby;
    private int img;

    public Student(String name, String sex, String age, String hobby,int img) {
        this.name = name;
        this.sex = sex;
        this.age = age;
        this.hobby = hobby;
        this.img = img;
    }

    public int getImg() {
        return img;
    }

    public void setImg(int img) {
        this.img = img;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getAge() {
        return age;
    }

    public void setAge(String age) {
        this.age = age;
    }

    public String getHobby() {
        return hobby;
    }

    public void setHobby(String hobby) {
        this.hobby = hobby;
    }

}
MyAdapter如下：
public class MyAdapter extends BaseAdapter {
    private List<Student> mData;
    private LayoutInflater mInflater;
    public MyAdapter(LayoutInflater inflater,List<Student> mData) {
        this.mInflater = inflater;
        this.mData = mData;
    }

    @Override
    public int getCount() {
        return mData.size();
    }

    @Override
    public Object getItem(int position) {
        return position;
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        View view = mInflater.inflate(R.layout.list_simple_adapter_item,null);
        Student student = mData.get(position);
        TextView nameTextView = (TextView) view.findViewById(R.id.item_name);
        TextView sexTextView = (TextView) view.findViewById(R.id.item_sex);
        TextView ageTextView = (TextView) view.findViewById(R.id.item_age);
        TextView hobbyTextView = (TextView) view.findViewById(R.id.item_hobby);
        ImageView photoImageView = (ImageView) view.findViewById(R.id.item_image);
        nameTextView.setText(student.getName());
        sexTextView.setText(student.getSex());
        ageTextView.setText(student.getAge());
        hobbyTextView.setText(student.getHobby());
        photoImageView.setImageResource(student.getImg());
        return view;
    }
}
新建活动类
public class BaseAdapterTestActivity extends Activity{
    private ListView mListView;
    private MyAdapter mMyAdapter;
    private List<Student> mData;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.activity_listview);
        mListView = (ListView)findViewById(R.id.my_list_view);

        dataInit();

        LayoutInflater inflater = this.getLayoutInflater();
        mMyAdapter = new MyAdapter(inflater,mData);
        mListView.setAdapter(mMyAdapter);

    }

    private void dataInit() {
        mData = new ArrayList<>();
        Student zhangsan = new Student("張三","男","19","愛好吃",R.mipmap.image);
        Student lisi = new Student("李四","女","17","愛好打遊戲",R.mipmap.pk);
        Student wangwu = new Student("王五","男","19","愛好喝酒",R.mipmap.pk);
        Student zhaoliu = new Student("趙六","男","21","愛好學習",R.mipmap.image);
        Student suqi = new Student("蘇七","男","19","愛好裝逼",R.mipmap.pk);
        mData.add(zhangsan);
        mData.add(lisi);
        mData.add(wangwu);
        mData.add(zhaoliu);
        mData.add(suqi);
    }
}
R.layout.list_simple_adapter_item
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="horizontal"
              android:layout_margin="15dp"
              android:gravity="center_vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <ImageView
        android:id="@+id/item_image"
        android:layout_width="100dp"
        android:layout_height="100dp"/>
    <TextView
        android:id="@+id/item_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="姓名"/>
    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginLeft="10dp"
        android:layout_marginRight="10dp"
        android:orientation="vertical">
        <TextView
            android:id="@+id/item_sex"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="性別"/>
        <TextView
            android:id="@+id/item_age"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="年齡"/>
    </LinearLayout>
    <TextView
        android:id="@+id/item_hobby"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="愛好"/>
</LinearLayout>
结果演示： 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Don’t Stretch the Architecture Metaphors
￼
Don’t Stretch the Architecture Metaphors
David Ing
ARCHiTECTS liKE To dEAl WiTH METApHoRS. They provide nice con- crete handles on subjects that are often abstract, complex, and moving targets. Whether it is communicating with the rest of the team or talking through the architecture with the end user, it is so tempting to find something tangible or physical to use as a metaphor for what you are trying to build. 
This usually starts well, in that a common language can evolve where people start to feel that things are moving in the right direction. The metaphor devel- ops and grows over time until it takes on a life of its own. People feel good about the metaphor—we’re making progress! 
What usually happens is that the metaphor for the architecture now becomes dangerous. Here’s how it can turn on its architect creators: 
• The business domain customer starts to like your metaphor more that your proposed system, in that the happiest possible interpretation is now shared by all concerned and no real constraints are uncovered. 
Example: “We’re building a transport system like a ship travelling between a series of docks.” 
You think container ships crossing the Pacific. I was actually thinking a rowing boat in a swimming pool, with possibly one oar. 
• The development team starts to think that the metaphor is more impor- tant than the actual business problem. You start to justify odd decisions because of a fondness for the metaphor. 
￼ 
￼￼Example: “We said it’s like a filing cabinet, so of course we have to show it to the user alphabetically. I know it’s a filing cabinet with six dimensions and of infinite length and with a clock built in to it, but we’ve done the icon now—so it has to be a filing cabinet…”. 
• The delivered system contains relics of names from old, broken metaphors long gone—archaeological testimonials to concepts long refactored and dug over. 
Example: “Why does the Billing Factory object create a Port channel for the Rowing boat system? Surely it should return a Pomegranate view for the Hub Bus? What do you mean you’re new here?” 
So remember, don’t fall in love with your system metaphor—only use it for exploratory communication purposes, and don’t let it turn on you. 
David Ing is a software architect/technologist living and working in Vancouver, British Columbia. Originally from the U.K., he moved across to get away from the rain, although now feels tricked by dishonest tourist literature. 
As fashion dictates, he now works at Web 2.0 company Taglocity, where he splits his time trying to make email systems “less awful” and figure out what Web 2.0 actually means.

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
简单的快速幂取模
  HDU1097
本题为快速幂取模运算，直接套用模板即可
//题目描述：给你数a,b,让你输出a^b的最后一位
#include <iostream>
#include <cstdio>
using namespace std;

#define  LL long long
 
LL  pow_mod(LL  a, LL  b)
{
	LL  ans = 1;
	a = a % 10;
	while (b > 0)
	{
		if (b %2)
			ans = ans * a % 10;
		b= b >> 1;
		a = a * a % 10;
	}
	return ans;
}

int main()
{
	LL a, b;
	while (cin >> a >> b)
	{
		cout << pow_mod(a, b)<< endl;
	}
	return 0;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ 1197 [HNOI2006]花仙子的魔法 递推
题意:链接
方法:递推
解析:
先观察数据范围，乍一看好小，觉得可能是某种神的做法？
然后再考虑手玩一下。
发现三维及以上的都玩不了啊
只能玩1，2维。
然后看1维时，是这样的。
1,2,4,6,8,10…
即m=0时(我知道题里没有m=0)为1，m=1时为2….
二维呢？这不是刚学递推的时候的一个SB题么。
1,2,4,8,14,22….
然后呢？
观察表啊！
二维有一个地方是8，而1维是6。
因为二进制表示只有2^x这么多种。
所以猜测整个表是这样的
1,2,4…
1,2,4,8…
1,2,4,8,16….
…
那其他的部分呢？
不会啊，这怎么办。
继续观察表啊！
我们发现14=6+8,22=8+14。
所以猜测表中的每一个值都是其左边的值加上左上的值。
这为什么对？我不会啊。
但是我断言这道题一定是这么找规律的- -
我这个二维生物也只能靠1,2维找规律了。。。
所以直接上递推，居然A了，人生无憾啊。
代码:
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define M 110
#define N 20
using namespace std;
typedef long long ll;
int m,n;
ll f[N][M];
int main()
{
//  freopen("flower.in","r",stdin);
//  freopen("flower.out","w",stdout); 
    scanf("%d%d",&m,&n);
    f[1][0]=1;
    for(int i=1;i<=m;i++)
    {
        f[1][i]=i*2;
    }
    for(int i=2;i<=n;i++)
    {
        f[i][0]=1;
        for(int j=1;j<=m;j++)
        {
            f[i][j]=f[i-1][j-1]+f[i][j-1];
        }
    }
    printf("%lld\n",f[n][m]);
} 

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

失业七个月，面试六十家公司的深圳体验
首先，坦白的讲，如果我现在不是找到了一份还合适的工作，我是根本不愿意再去回想那七个月的事情的。 
　　 失业整整七个月，简直是噩梦一场。很辛酸，很痛苦，也很无奈。由刚开始的自信满满，多方挑剔，到最后的完全没有了自信，觉得自己是废物，这个过程让我经历了太多，如果不是有家人与好朋友一直支持着，应该是早就彻底放弃了的。 
　　 事情过后，再回过头去看这段简历，开始有点感谢这样一次机会，感谢这次有磨练的经历。至少，它让我看到了许多事情，学习到了许多东西，也让我感受了许多一直忽略的东西，更加让我成熟了许多，懂得了珍惜，也懂得了自信与坚持。 
　　 
　　 其实，我的资历很简单，远不像天涯上许多朋友那么优秀，远非精英人士，只是普通职员一名。 
　　 我毕业于普通的大学，工作四年，服务过两家公司。第一家是家合资公司，做市场助理；一年后，跳来深圳一家大型国企，从事物流工作。在这家公司工作了三年， 月薪也就5K而已，年薪大约7.5K。没有房子，没有车子，也没有存款。除了工作比较快，比较认真，比较负责任外，别无其他出众的能力。 
　　 所以，我面试的公司有大有小，我现在任职的公司也很普通（小的港资公司，月薪8K，小部门主管），不像其他朋友那样都是世界500强，更不像他们那样最后获得好的工作并取得事业成功。 
　　 
　　 我只是想和那些找工作的朋友们，分享一下我在深圳面试那么多家公司的面试经历，或许可以给他们一些参考；也给那些还在失业中辛苦挣扎想放弃的普通朋友们，说说我失业长达七个月的心情，给他们一些鼓励和信心。 
　　 
　　 关于面试与求职，如果您有什么需要问的，请随时问我，我会很乐意回答的；如果您也在辛苦求职，那么请继续加油，请相信，你一定行的！！！没有任何人可以否定你！！！ 

回头望去，自去年七月底辞职到现在，已经过去大半年了。 
　　 掐指头数，整整失业了七个月。 
　　 七月底辞职，在家休息了两个月。十月过来深圳开始认真找工作。十月到十二月的那三个月中，投了无数的简历，收到上百个面试通知，也参加了大大小小，至少60场的面试。有时候一天都赶三场面试。 
　　 有人家不要我的，有我不要人家的，但是大多数是人家不要我，有的甚至电话面试都没有通过，比如飞利浦。 
　　 我会主要讲述一下我所参加的公司的基本面试流程，重点讲一下当时面试官的各种问题，然后就是我自己总结的失败原因。 
　　 
　　 我面试的这六十多家公司，有大有小，有外企有私企有民企还有国企，其中有部分企业如下： 
　　 艾默生/西门子/华为/中兴/索尼/富士施乐/长城国际/ 
　　 马士基/SGS/宜家/法国迪卡侬/韩国三星/环球资源/ 
　　 德昌电机/三洋电机/美泰玩具/富士康/中国银行/东亚银行/ 
　　 吉之岛/西武百货/伟创力/清华同方/光汇石油/华孚/飞利浦/ 
　　 CITYGROUP等 

华为面试经历 
　　 
　　 
　　我十月过来，第一家面试的公司就是华为。 
　　事实上，我去过华为两次。 
　　我以前没有接触过，虽然听说工作压力很大，很累人，可我这个人最怕的是没有事情做，累点忙点，我不怕的。所以，我就很满怀期待的去了。 
　　 
　　华为的面试特点： 
　　1.华为几乎每天都在招人，如果你想找工作，可以随时去试试； 
　　2.大公司，架子大，喜欢在周六叫上上百人集中面试； 
　　2.流程多，至少3-4轮面试。还要填表格和笔试； 
　　3.公司人力资源部的地位比较高，甚至可以在最后否决你。 
　　 
　　我这次面试经历了四轮。 
　　早上八点半就赶过去了。 
　　首先是在门口等待。然后，有部门的人出来领你进去。 
　　华为喜欢在食堂面试。无论是科技园还是坂田，几乎都是集中在食堂。之后，有的部门是先填表后做题，有的部门是先做题后填表。 
　　反正，几乎都有面试题。 
　　 
　　第一轮，笔试。 
　　国际贸易这方面的题目，主要考 
　　1.外贸术语 比如，DDP是什么，S/C是什么等； 
　　2.英语翻译，中译英，英译中； 
　　3.给你个情景，书写英文函电。 
　　做完之后，交给接待小姐。你坐旁边等待。 
　　由于人多，我一直到十一点才等到第二轮。 
　　 
　　第二轮，也许是同事或者是主管面谈。 
　　主要问的问题有： 
　　1.你为什么想来华为工作？ 
　　2.你在原来公司做得挺好的，为什么想离开？ 
　　3.出口退税退的什么税？ 
　　4.ICC有哪几个险种？ 
　　5.你以前工作遇到同事不合作，是如何处理的？ 
　　然后是英语口语的考核 
　　1.COULD YOU TELL ME SOMETHING ABOUT YOURSELF? 
　　2.COULD YOU INTRODUCE YOUR JOB DUTIES? 
　　3.WHAT ARE YOUR STRONG POINTS AND WEAK POINTS? 
　　4.WHAT ARE THE DIFFERENCES BETWEEN HB/L AND MB/L? 
　　然后，又是等待。如果第二轮认为你不行，就会先叫你回家。 
　　 
　　我就又从十一点半等到了下午三点。 
　　中饭自理。 
　　 
　　下午三点，第三轮。一般是本部门经理。 
　　1.请介绍下你以前的工作内容。 
　　2.你觉得你过去工作中最成功的事情是什么？ 
　　3.你会和同事吵架吗？如果同事和你吵架，你如何处理？ 
　　4.你未来三年的目标是什么？ 
　　5.如果与客户发生合同纠纷时，如何处理？ 
　　 
　　之后又是坐旁边等待，等通知。不行，就又是通知你先回家等消息。 
等到下午五点多，终于轮到最后一轮了。 
　　公司人事部面试。 
　　我当时想着，人事部一般都只是审核下你的证书，签下合同而已，应该肯定成了。 
　　谁知道，最难过的却是人事这一关，而且最后失败也是在这里。 
　　当时，我从早上八点半等到下午五点多，真的是很累了，而且心里也有火了。 
　　面试我的是位中年女士。 
　　她面无表情，我和她打招呼，她也没有回应我。 
　　本来面试官这样子，我也习惯了，可我明明刚才还看到她对前一个面试的人笑容满面的，所以，就有点不舒服。 
　　她一直低头看我简历，然后就开始了她的咄咄逼人的询问： 
　　 
　　1.你为什么想来华为？ 
　　（我无非就是说华为的吸引力） 
　　2.你怎么知道华为管理好？ 
　　（我有同学在华为，我自己也有所了解） 
　　3.你如何界定华为就比你以前的公司好？ 
　　（我肯定我原来的公司，并且再次说华为的优势，并没有去比较华为与我原来的公司） 
　　4.你为什么认为自己适合华为？ 
　　（我强调自己的优势与长处） 
　　5.你既然在以前公司做得这么出色，为什么要离开？ 
　　（职业发展） 
　　6.为什么你可以被评为优秀员工，其他同事却没有？ 
　　(我具体说明自己的工作努力与成就） 
　　7.难道你其他同事工作不如你努力，没有你聪明？ 
　　(我避免直接回答，再次强调自己的成就与努力） 
　　8.你对你自己的形象如何看待？ 
　　（呵呵，这下子，终于言归正传了，这就是我失败的原因，也是她看我不顺眼对我如此咄咄追问的地方） 
　　 
　　说实话，我当时还没有反应过来是怎么回事情。 
　　我回问“形象?我没有觉得我形象有问题啊？” 
　　她紧接着问，“难道没有人对你的形象提出过要求吗？” 
　　 
　　听她这么说，我低头看了下自己，并没有觉得不妥啊。 
　　我一向形象还挺好的嘛。 
　　所以，我就回答“没有，我们公司对我的形象很满意。” 
　　“那你为什么剪个这样的发型，而且还还染了色！” 
　　我这才恍然大悟，原来是我的发型与发色问题。 
　　我当时的发型其实也没有大碍，只不过有点造型，颜色就是亚麻色而已，可人家要这么说，我也没有办法。 
　　我只能继续坚持说“我每天上班都西装革履的，公司一直对我形象很满意。” 
　　 
　　她哦了一句，就说，“真是对不起，耽误你这么多时间，你先回去等消息吧。” 
　　 
　　我一听她这么说，气就来了。 
　　但我还是忍着，我故作冷静的直接问她，你的意思是说回去等消息还是我没有通过？ 
　　她说不是，只是要我回去等消息，三天内有消息。 
　　我忍住火气，直接问，你们耗了我一天时间，我从早上八点到现在六点，经过了四轮面试，怎么着也以为今天可以有个结果，可是这样子。。。 
　　她又客气的回答我，他们也想今天结束，可是今天经理不在，还需要一轮刷选，所以只能请我回去等消息。 
　　 
　　我当时那个气啊。 
　　想想，我从早上八点半耗到下午六点，却因为这么个女人就没有通过，而且我都那么直接问她到底是录取还是不行，给个爽快，可她还是那么客套的忽悠。 
　　我立刻就走了。这次面试的不愉快经历，让我之前对华为的好感都没有了。 
失败总结： 
　　 
　　1.事后，我冷静总结了一下这次面试失败的原因，很明显是在于形象。 
　　都怪我自己太大意了，没有想过还是尽量保守点好。 
　　穿得正式点总是没有错的。 
　　 
　　所以，我立刻去剪了头发，染回黑色。并且以后的面试，我都是西装革履去的。 
　　如果我能力不行，我就认了；可我不想被别人因为一些无关紧要的因素而淘汰我。 
　　 
　　2.面对面试官充满怀疑与挑衅的问题时，一定要保持冷静，强调自己的优势，最好举具体事列来证明自己的能力。 
　　我当时面对那几个问题“6.为什么你可以被评为优秀员工，其他同事却没有？(我具体说明自己的工作努力与成就） 
　　　　7.难道你其他同事工作不如你努力，没有你聪明？ 
　　　　(我避免直接回答，再次强调自己的成就与努力） 
　　　 
　　就有点激动，都忘了拿出我的证明，公司的优秀员工证书与我们总经理的推荐信。 
　　 
　　 
　　3.面试的时候一定要保持警惕，对任何细节都要预感到，不要像我那样，人家一直都是对我形象不满意，我还不知道。 
　　 
　　 
　　 
　　不过，我很讨厌华为的面试流程。 
　　最不尊重面试者的时间了。 
　　所以，后来，华为多次都在网上搜到我简历，叫我去面试，我都拒绝了。 
　　有个部门的人，还对我用激将法，说华为的压力的确大，一般人是承受不了。 
　　我就直接告诉他，我不喜欢他们的面试流程，太耗时间了。

楼主,我都失业三个多月了,如果人家问我失业这长时间为什么没找到工作怎么办 
-------------------------------------------------------------------------- 

首先，三个月没有工作被面试官怀疑是很正常的。 
　　因为，职场出现空白是职业生涯的大忌。 
　　这也是我后来才明白的。 
　　 
　　其次，你不用怕别人怀疑。你要充分相信自己。 
　　其实，许多时候，面试官就是在故意打击你的自信，他想判断你是否真的自信。 
　　所以，他们再怎么怀疑，你都要坚持自信。 

　　 我个人觉得，你或许可以这么回答： 
　　 1.你可以很自信很坦白地告诉他，你在寻找合适的工作。记住不是好，而是合适。 
　　 2.你可以回答，工作了一段时间，你需要思考，你离职后给了自己一段时间，对自己的职业生涯重新进行思考和规划，所以，没有立即找工作。另外，你还可以补充说，你在充电，说些和职业有关的课程。 
　　 像我当时是回家休息了，而且我也的确还报了一个学习班，所以，我就坦白说，我工作累了，需要思考，同时需要充电。 

西门子面试经历 
　　 
　　说实话，我也挺喜欢外企的。所以，当西门子通知我面试的时候，我挺兴奋的。而且，我一直住华侨城那边，能够走路上班，实在很有诱惑力。 
　　 
　　早上十点，我准时来到华侨城汉唐大厦九楼。 
　　经过了华为的一整天面试后，我对是否要等待比较介意了。 
　　还好，外企就是外企，十点面试你就一定是十点。 
　　 
　　一面是人事部小姐。 
　　先是填份简单的表格，附上你的资料复印件。 
　　然后，就是一些简单的基本情况了解和英语口语测验。 
　　面试多了，你就会发现，有些问题是每次面试都会问到的，所以，最好准备一下。 
　　这次的问题有： 
　　1.你为什么离职？ 
　　2.你对所应聘的职位怎么理解的？ 
　　3.你了解西门子吗？ 
　　4.你的优缺点是什么？ 
　　5.你的未来有什么计划？ 
　　英语口语依然是： 
　　1.INTRODUCE YOURSELF 
　　2.YOUR HOBBIES 
　　3.ANY QUESTION 
　　完了，就叫我回去等通知，大概一个礼拜。 
　　就这么简单，我当时还以为没有什么戏了。 
　　五天后，收到二面的通知，下周三。说是部门经理特地从上海赶过来面试，要我好好准备一下。 
　　我就请教人事小姐，我该注意些什么。 
　　她很友好的告诉我，我应该注意下英语发音，然后认真研究一些招聘要求，对照职位来强调自己的优势。 
　　很感谢她的友好。可惜我并没有认真加强。 
　　 
　　下周三下午两点，我准时参加二面。 
　　面试我的经理是一位男士，和我一个同学同名。 
　　态度也比较平和，依然是先介绍了他自己和这个岗位的具体工作职责。 
　　然后，重点考核了我的专业知识和工作经验。 
　　尤其特别提到了几个公司招聘职位上要求的技能，而不幸的是，我恰恰不大会。我就都如实回答我不熟练，工作中没有用到。 
　　说到工作经验和以前在公司的表现，我有一些证明事件和推荐信，这个为了加了不少分。 
　　所以，最后面试结束时，经理很高兴的对我说，这也可以为你加分，那也可以为你加分，你会是我们优先考虑的对象。 
　　等我们第三次面试的通知。 
　　 
　　 
　　回去后的心情很轻松，三天后收到三面的通知。 
　　面试我的是CFO和部门经理。 
　　坦白说，我很久没有面试了，而且我挺看重这次面试的，所以有点紧张。 
　　1.当CFO要我自我介绍的时候，我结结巴巴说得没有重点，当时感觉就不怎么好了。 
　　2.然后，他很强势的盯着我看，问我，你为什么觉得自己适合这个职位呢？我们为什么要聘用你呢？ 
　　我之前的准备都忘了，只感觉压力。回答得很不理想。 
　　3.你熟悉合同法和商务谈判吗？ 
　　4.最后就是客套的，你还有什么问题要问？ 
　　5.回去等我们通知吧。 
　　 结果自然可想而知了。 
　　 
　　失败原因： 
　　1.不够自信，压力面试的时候容易放弃，而且如果出错了就很容易紧张； 
　　2.没有认真研究招聘要求，而且不知道的知识也没有临时去补一下。 
　　3.不够果断。 

LZ，挺佩服你的。 
　　　　 我想，深圳的知名企业你都面试了大部分了吧？ 
　　　　 哈哈哈 
　　　　 
　　　　 能将你面试的经历，写出来供我们这些准备跳槽的人看看，先谢过了～ 
　　　　 
　　　　 不过，有一个问题是：当初你怎么没有选择一边工作，另一边寻找下一家单位？ 
　　　　 这样也许就不会没有工作长达半年之久 
------------------------------------------------------------------------------------- 
　　 
　　呵呵，你说得很对，深圳的知名企业，我是大部分都去过了。 
　　然后，你的问题也问得很好。 
　　就职业生涯而言，最好不要出现职业空白期。所以，最好是边工作边找。找到后再辞职。 
　　一来，这至少从心理上，你占有优势，你不用担心经济，也没有压力，你不要我，我不怕，反正还有份工作。 
　　二来，面试的时候也避免了面试官抓住这点不放。 
　　至于我当时离职的原因，是由于个人私事原因。如果现在我再换工作，我就不会辞职再找了。哈哈。 

希望楼主能讲些电话面试方面的内容 
---------------------------------------------------------------- 
电话面试挺简单的。 
　　题目都是一面的那些常用题目。 
　　一般都是外企会采用电话面试的形式，而且都是对口语要求比较高的。主要目的就是先淘汰一批口语不合格的应聘者。 
　　一开口就是英语说的，我刚开始还真反应不过来。 
　　具体题目： 
　　1.自我介绍 
　　2.工作介绍 
　　3.个人兴趣爱好 
　　4.为什么离职 
　　5.个人优缺点 
　　6.个人家庭情况 
　　这几个题目是无论电话面试，还是中文面试都一定会问到的，所以，最好中英文都准备好，而且做到倒背如流。 
　　有准备才不吃亏啊。 

爱默生面试经历 
　　 
　　 
　　深圳爱默生公司总部在南山科技园，后来它又收购了华为的一个工厂，也就是在宝安的那个。 
　　所以，要看你是面试爱默生的哪部分，如果是关外那个部分，那纯粹就是华为的面试风格。 
　　 
　　爱默生也喜欢集体面试。 
　　一般都是同时约上许多人，一起等待，依次面试。 
　　一轮之后，回去等通知，之后还有两到三轮。 
　　 
　　我那次面试是在科技园南区，首先是做了份英文试题。 
　　之后，就是部门经理的面试。 
　　这次面试太简单了。当然，简单就意味着失败。 
　　一共就问了我四个基本问题，之后就是你有什么问题问我？ 
　　然后，就是感谢面试，请回去等通知。 
　　 
　　我到现在也想不通，自己怎么会那么轻易的被刷了下来。 
　　虽然我看了其他应聘者的学校，学历都比我好，可是相对这个职位而言，我的工作经验是绰绰有余的。 
　　 
　　也许，我真的不具备外企的工作素质吧。 

MSK马士基面试经历 
　　 
　　 
　　既然是做物流的，那么当然会去世界上最大的船公司面试一下。 
　　丹麦是北欧国家，网上老说北欧企业待遇好，然后，马士基本身是世界上最大的船公司，办公地点又在深圳最高写字楼地王大厦。 
　　我就想当然的以为薪水肯定不错。 
　　 
　　约了九点参加公司笔试。 
　　惨的是，我九点半才到地王大厦。 
　　前台小姐说你迟到了。等下一轮。果然是大公司做派。 
　　 
　　ＭＡＥＲＳＫ面试最著名的就是这个笔试。 
　　听说，马士基每年录取者和参加应聘者的比例是１：１０００，极高的淘汰率让能进入马士基的人成为一个神话。参加笔试者不用做任何准备，既不用准备英语，也不用回答 

诸如“为何要进我们公司”或者“你有什么特长”的问题，只需要做性格测试和快速智力问答两部分。做完后，公司当场收回试题，之后公司会根据你的选项输入电脑制作出个人 

发展曲线图，从中能看出某人的发展潜力和远期竞争力。综合考虑之后，通过了，才会有机会参加下面的面试。 
　　 
　　 
　　十点准时进入考场。 
　　两张试卷，逻辑和性格测试，12分钟一张。 
　　完了，收卷，等通知。 
　　 
　　三天后一面。 
　　面试我的是部门同事。人很和蔼。 
　　问题都很简单，还是那些。马士基最重要的性格测验的笔试部分。面试基本上都很简单。 
　　 
　　之后是二面。 
　　面试我的是部门经理。 
　　问了一些基本问题，专业知识和考核一下英语口语。 
　　1.你为什么来马士基？ 
　　2.你觉得你以前的工作经历对现在的工作有什么帮助？ 
　　3.在寻找新工作中，你最看重的是什么？ 
　　4.集装箱的种类有哪些？ 
　　5.AMS是什么？ 
　　6.你觉得如何节省运作成本？ 
　　7.散货和拼柜如何计费？ 
　　等等 
　　 
　　最后是公司经理面试。 
　　依然很客气，但是问的问题很细致。 
　　比如， 
　　1.你七月底就离职了，那你这几个月都去哪些公司面试了？ 
　　2.你为什么换工作？如果我们的工作内容和你以前差不多，你不觉得厌烦吗？ 
　　3.如果我们不能提供你所要求的薪水，你还愿意来我们公司吗？ 
　　听到这个问题，我大概知道怎么回事了。 
　　 
　　等到具体谈合同和薪水，就证实了工资真的不高。远低于我的预期。所以，只能说回去考虑了。 
　　 
　　后来，才听内部员工说，马士基的工资待遇是比它刚进入中国时低很多,大约降低三分之一了。

作者：vicxll　回复日期：2007-3-18　02:05:18　 
　　　　楼主，我是个应届的本科毕业生。来深圳也一星期多了。找也找了些单位。但是他们给我开出的薪水都才1000左右。这让我很失望，也很困惑。不知道是不是毕业生刚开 

始都是这样的呢？我不知道该不该去。 
-------------------------------------------------------------------------------------- 
你好，应届毕业的时候，由于没有工作经验，的确完全都是公司在挑我们。但是，你要相信自己的能力。现在，深圳市场上应届毕业生基本都是2000起价。 
　　 大公司就比较好，都有个基本的定价，不会低于2500。 
　　 总的来说，就我的了解，应届本科毕业生的工资大部分在2000-3500之间。 
　　 所以，我觉得你应聘的公司工资可能稍微偏低了点。 
　　 另外，除了基本工资外，也需要看公司的其他福利，比如包吃住，有提成，有奖金等。 
  
　　 在这里，我特别想和找了一段时间工作，开始失去信心，甚至想着如果有公司要就去的朋友们，说一句话：千万别这么想，越是这样想，越是很难找到合适的工作。 
　　 即使你真这么想，也千万别把这种感觉流露出来。 
　　 因为，首先，你要知道，我们不是在乞求一份工作，我们是提供我们的聪明才智与辛苦劳动去获得相应的报酬，事实上，是我们在养活公司，而不是公司养活我们。所以，我 

们首先一定要抬头挺胸的！ 
　　 其次，人的心理都是希望找到性价比最高的东西。公司招聘也在找性价比最高的人。所以，他们肯定希望自己招的人是足够有价值的珍品而不是买不出去的滞销品。 
　　 其实，面试官的心理本身就有点矛盾的。一方面，他们会想法设法的去挑剔你，打击你，迫使你放下自信；另一方面，他们又很希望看到你能够经得起打击与挑剔，依然自信 

。 
　　 而且，谁都喜欢高难度的东西。如果你是从千军万马中杀出来，成功获得那份工作的，你一定很有成就感；同样，公司也希望招到的人是有要求，肯定自身能力与价值的人。 
　　 
　　 所以，不管现在如何艰难，不管你是多么想放弃，请你都要抬头挺胸，不卑不亢的参加面试，同时勇敢的提出自己的要求与想法。 
　　 我们是与公司合作，是帮公司赚钱，而不是乞讨！！！ 

　　 在天涯的帖子里面，我看到许多朋友都对各公司人事部门的人心存意见，觉得他们傲慢无论，故意挑剔，装腔作势等等。 
　　 
　　 我非常想替从事人事工作的朋友们说句公道话，我在想，大家是否把人事部的人等同于面试官了呢？大家是否把面试你的人都当成人事部的人了呢？ 
　　 
　　 我面试的公司应该是范围很广的，什么类型都有。 
　　 就我面试的经历而言，除了极个别公司人事部的同事有点无礼外，90％以上公司的人事部都是非常和蔼礼貌的。遇到没有礼貌的面试官一般都是公司的中层管理者。 
　　 事实上，我去的那些公司，他们的人事部非常清楚自己的角色，是服务于公司其他部门。所以，他们对于我们应聘者都很礼貌，许多人还很热心。 
　　 我遇到过不少礼貌又热心的人事部朋友，有的好意提醒我面试的时候该注意什么，接下来的经理喜欢什么样的员工，有的甚至还特地告诉我面试没有通过的原因，并且再次帮 

我申请一次面试的机会等等。 
　　 
　　 呵呵，大家仔细回想一下，面试你的那个人真的是人事部的吗？ 

美泰玩具---原来外企的工资并不是同一水准的 
　　 
　　 
　　在没有看美国真人秀节目《飞黄腾达》之前，我还真的不知道美泰竟然是全球最知名的玩具品牌，也是世界500强之一。 
　　既然是外企又是500强，那么工资与发展应该都很不错的。于是，我又怀着美好想象，开始了一次外企的面试。 
　　 
　　美泰在深圳横岗，是关外，比较偏僻。 
　　约了十点面试，我怕迟到，七点半就坐车过去了。 
　　九点四十终于找到了工厂地址。 
　　工厂位于一个小工业区里，旁边都是居民房，感觉有点离想象很远的样子。 
　　 
　　接待人员是人事小姐。 
　　很和蔼亲切，一面自然就是她了。 
　　一面的内容依然还是基本情况了解与英语水平测试。 
　　1.先谈谈你自己吧。 
　　2.你在以前公司做得很好，为什么要来美泰？ 
　　3.如果在美泰从事基层工作，你愿意吗？ 
　　4.如果你下属不愿意加班，你怎么办？ 
　　5.你的期望薪水是多少？如果达不到你的要求，怎么办？ 
　　6.COULD YOU TELL ME ABOUT YOUR WORK EXPERIENCE? 
　　7.HOW WOULD YOU DESCRIBE YOUR RELATIONSHIP WITH YOUR MANAGER? 
　　等等 
　　 
　　然后，就是部门经理的二面。 
　　部门经理是香港人，不会讲国语。 
　　所以，我们的沟通就是粤语与英语。 
　　主要就是考核了工作内容与管理水平。 
　　1.你平时如何给下属分配工作？ 
　　2.如果一个人工作量很多，你是否会分给另一个人？ 
　　3.如果下属情绪不好，不愿意工作，你如何激励他？ 
　　4.你是如何帮助公司节省物流成本的？ 
　　等等 
　　 
　　最后，当然就是谈薪水了。 
　　美泰会直接告诉你多少薪水，福利很少，而且工资可波动幅度范围也很小。工资制定得比较死。 
　　当我听到薪水制度的时候，有点难以想象这是一家世界500强的美国公司。 
　　 
　　所以，只好说，我需要考虑。 
　　对方也很客气的说，那你回去考虑下，我们也要商量下，有消息再通知你。 
　　 
　　以前听多了人说外企工资高，一般职位都是8000左右，可我现在才发现不少外企（我到面试结束，现在整理才发现他们竟然都是世界500强），一般职位也就4000左右而已。 
　　 
　　唉，同企不同酬啊。 

另外再补充一个问题啊，就是这家公司是去年才成立的。对于新公司有必要去尝试一下吗？因为当时面试官对我说，如果我能被录取。也就是他们单位的一名元老，这些 

对我以后的发展有什么优势？又有什么劣势？ 
----------------------------------------------------------------------------------　 
　　新公司是种冒险但也是种机遇。 
　　冒险，是因为新公司的未来发展并不一定可靠，凡事都在摸索，很有可能业务无法开展，公司赚不到钱，自然你的发展也就无从可谈。 
　　机遇，是因为既然是新公司，自然一切都是未定的，你自己充分发挥自己的才能与智慧，一个人充当多面手，而且的确以后公司做大了，你就是元老，获得的发展与福利都很好。 
　　 
　　所以，关键在于，你需要自己去判断一下这家新公司的发展前景。你可以综合考虑一下，公司的产品，业务领域，行业竞争，公司的老板做事风格等等。然后，自己就基本可以判断出公司的发展如何了。 

富士施乐---唯一无论是否合适都会电话通知你结果的公司 
　富士施乐，之所以对它印象深刻，是因为在我面试的六十家公司中，它是唯一一家无论合适与否都一定会在一个礼拜里通知你结果的公司。虽然由于薪水低于我的要求无法达成合作，但人事的做事方法还是让我对它很有好感。 
　　 
　　由于深圳这边只是办事处，所以，面世人员是从广州公司特地赶过来的。 
　　统一约的是周五。 
　　我按照面试时间准时到达罗湖嘉里中心2906-2907，富士施乐的办事处。 
　　前台登记后，就在等待区域等。 
　　面试官过来了，很有礼貌而且非常注重礼仪的一位女士。连说对不起，需要各位久等，并请大家填份资料，做一下测试题。 
　　接下来，我们就坐着填写资料登记表，并做一份简单的计算机知识和英语测试。题目都很简单，基本可以应付过去。 
　　 

Linux环境编程2
如何通过程序实现获取环境变量的信息，这里可以做出来了。

#include <stdlib.h>
#include <stdlib.h>

extern char ** environ;
int main()
{
	char **env = environ;
	
	while (*env)
	{
		printf("%s\n", *env);
		env++;
	}
	exit(0);
}执行之后的结果





版权声明：本文为博主原创文章，未经博主允许不得转载。

IPV4理论知识2----分类编址







IPV4理论知识2----分类编址







 
前言
 
前面说过IPV4的理论知识,这里再说一下关于IPV4的那些没说到的知识,有同学反应我的博客排版格式绝了...我正在努力改正,正确让大家能看到一种比说书还好看的内容,比苍老师还漂亮的排版.
 
 
分类编址
 
IPV4的体系中有分类编址,肯定还有无分类编址,啥叫分类编址?别急,往下看.在分类编址时,IPV4地址分为A,B,C,D,E这五类.每类占用的IP比例和个数如下图
 
 
 
 
IPV4分类识别
 
 
 
计算机以二进制方式存储IPV4地址,在这种情况下可以很方便的写出一种算发,通过一个连续检查过程来查找出该IP地址的类别.流程图如下:
 
 
 
 
 
网络标识和主机标识
 
对于A,B,C类IP地址,都可以划分为网络和主机标识两部分.其中网络标识和主机标识的长度随地址类别的不同变化.网络标识和主机标识其实很好理解,就相当于我们使用的电信的座机号码.例如,我在山东淄博,0533-88888888,其中网络标识就相当于0533,主机标识就对应号码88888888.下图很清楚的说明了A,B,C类地址的网络标识和主机标识的长度.
 
 
 
 
地址类和地址块
 
分类编制中每一类地址都被划为固定数目的地址块.而每一个地址块的大小是固定的.看下图:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
扩展知识
 
啥叫分类编址?传统上将IP地址划分为5类.
 
如果你仔细看了上面的图,就应该能看到上面5类地址分类识别,D类地址用于多播编址,E类地址留给未来使用.剩下的A,B,C类地址用于标识单个网络和主机的主要地址类型.
 
地质类别是由前导1比特的个数标识的.A类地址由另个前导1比特,B类地址有一个,C类由两个,以此类推.标识地址很重要,因为对其余比特的解释都取决于地址的类型.
 
A,B,C类地址的其余比特被分为两个部分.其中第一部分是网络标识,用来标识地址所指的特定网络.之后是主机标识,用来标识特定网络中的那台电脑.
 
类别标识符比特也被当做网络标识的一部分.因此,130.50.10.200这个IP是一个网络标识为0x8232,别问咋来的,动动脑子.上面说了.
 
将地址空间划分为不同的类别是为了提高地址使用灵活性,不浪费地址.例如,A类地址就适用于具有大量(最多16177214台)主机的网络.
可用的主机标识有224个或16177216个,但主机0和主机标识全1都有特殊的含义.主机ID全1是广播地址.地址为广播地址的IP数据报会被传送到网络上所有的主机,主机标识为0标识”本主机”,只有在启动阶段,主机才会将其用作源地址来发现其主机号.因此,主机的数量通常都是2n 2台,其中n是知己标识的比特数.
 
A类网络的网络标识为7比特,所以有128个可能的A类地址.
 
和主机标识一样,这些网络中有两个被保留起来.网络0标识”本网络”,想主机0一样,再启动阶段,将其作为源地址来发现网络号.网络127是主机内部网络.发送给网络127的数据报就不应该离开源端主机.这个地址通常被称为环回(loopback)地址,因为发送给它的数据都被”环回”到同一主机上去了.
 
另一个极端的网络类别是C类.C类网络有很多,但每个网络都只有254个可用的主机标识.A类地址用于少量拥有数百万主机的网络,而C类地址则可用于数百万个只拥有少数主机的网络.




类别


网络


主机


地址范围




A
B
C


128
16284
2097152


16777214
65534
254


0,0,0,1~127.255.255.255
128.0.0.0~191.255.255.255
192.0.0.0~223.255.255.255




A,B,C类地址的网络数,主机数和地址范围




 
TCP/IP协议的设计者最初认为网络应该是以百计的,主机数应该是以千计的.
 
实际上呢,最初的设计中只有现在被称为A类地址的部分.将其划分为三类是后来为了适应网络数多于256的情况.
 
正如我们所知道的那样,廉价且无处不在的PC使网络和主机的数量出现了爆炸性的增长.现在因特网的规模已经远远超过了其设计者的预想.
 
这种增长暴露了分类编址的弱点.第一个问题是A类和B类网络中的主机的数量太大了.要知道,网络标识是用来说明一个物理网络,比如一个LAN的.但是没有谁会把65000台主机放在一个物理网络中,更不要说16 000 000台了,相反,大型网络都被划分为由路由器链接的,较小的网段了.
 
作为一个简单的案例,我们看看下图中显示的两个网段

 
如果主机H1和主机H2进行通信,他只需要用仁义驿中适用于低层网络的方法将H2的IP地址映射为它的物理地址,并将IP数据报放到”线路上”去就可以了.
 
现在假设主机H1和主机H3进行通信.但是即使H1知道或者能够发现H3的物理地址,H1也无法直接向H3发送IP数据报,因为H1和H3处于不同的网络----比如,不同的以太网电缆上.作为一种替代方式,H1要通过路由器R1间接的将数据报发出去.如果两个网络的网络标识不一致,H1只需要查询它的路由表以确定网段2的分组是由路由器R1处理的,然后将数据报发送给R1,并通过它转发给H3就可以了,总之一句话,路由器就是起到一个中转的作用.
 
除了为两个网段使用不同的网络标识,还有什么其他替代方法呢?对传统的分类编址方式来说,有两种可能的方法.一种方法是在H1的路由表中为网段2上的每台主机都包含一个条目,用来说明此主机的下一跳地址是R1.网段1的每台主机都要有相同的路由表,而网段2上的每台主机都要有一个类似的路由表对网段1的主机进行说明.很显然,对主机数量较多的情况来说,这种解决方法的扩展性不好.另外路由表需要手工维护,这是管理者不愿意看到的,因此这种方式基本不用.
 
另一种可能的方式被称为代理ARP,网段1把R1当做H3,H4和H5,网段2把R1当做H1,H2和R2.
 
代理ARP也被称为也称为混合ARP或者ARP出租.
 
只有当底层网络使用ARP(地址解析协议)将IP地址映射为物理地址时,才能使用这种方式.使用ARP时,要将IP地址映射为物理地址的主机会广播一条报文,请求具有期望IP地址的主机回送其物理地址.当然,网络上的所有主机都会受到ARP请求,但只有正确的IP地址的主机才会相应.
 
使用代理ARP时,如果H1要向H3发送一条IP数据报,但不知道其物理地址,它就会发送一条ARP请求,询问H3的物理地址.H3位于另一个网络上,所以它无法受到ARP请求,但作为其代理的R1是可以收到的,R1会用自己的地址应答.当发送给H3的数据报到达R1时,R1会将其转发给H3.对H1来说,看起来就和H3和它处于同一个网络中一样.
 
正如前面提到的,代理ARP只能在使用ARP的网络上工作,而且只能在箱单简单的网络拓扑中工作.比如,我们可以想像一下如果有多台路由器连接到网段1和2上,会发生什么情况.
 
从这里讨论的来看,对带有多个网段的网络来说,最通用的解决办法似乎是为每个网段分配一个独立的网络ID,但这种方法也有它自身的问题.首先,每个网络中都有很多潜在被浪费了的IP地址.比如,如果这段网络的每个网络都有自己的B类地址,那么与每个B类网络地址相关的大部分IP地址都会被浪费掉.要记住,每个B类网络地址中都有65534个主机地址.
 
第二,所有能将数据报直接传送到互联的网络上去的节点,都要在其路由表中为每个网段设置一个单独的条目.对我们举得这个小例子,这没啥问题,但是如果一个网络上包含了百个网段,并且有很多这样的网络,那么路由表就会变得很大了.
 
这个问题可能要比刚开始看起来更严重一点.路由器的内存通常是有限的,而且通常会将路由表放在接口板上一块特殊用途的内存中.
 
注意,如果只有一个网络标识是怎么消除这两个问题?需要更多主机时,总是可以通过添加网段来使用这些IP地址,这样IP地址就不会被永久浪费了.因为 只有一个网络标识,所以,只需要一个路由表条目就可以向网络中另一台主机发送数据报了.
 
 
小小的总结一下
 
本次主要是讲解IPV4的分类编址,内容看着多,实际上重点的东西不多,扩展的内容明白一下就可以了,那几个图都很重要,因为这些图很好懂,想我这样的屌丝都能看懂,想你肯定能看明白.

版权声明：本文为博主原创文章，未经博主允许不得转载。

Github错误：fatal: Authentication failed for 'https://github.com/ ...
GitHub push代码发生错误：fatal: Authentication failed for 'https://github.com/ ... 
使用的https提交，在用SourceTree提交代码时候发生错误，返回的错误提示说：
fatal: Authentication failed for 'https://github.com/ ... 
如图所示：



解决方案，重新执行git config命令配置用户名和邮箱即可：
git config -–global user.name "xxx" 
git config –-global user.email "xxx@xxx.com" 



﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。转载请注明出处：http://blog.csdn.net/zhangphil

BZOJ 4003 [JLOI2015]城池攻占 可并堆
题意: 链接
方法: 可并堆
解析:
今年的省选题，当时我做的时候一顿蒙B。
好像当时搞了个树形DP？不记得了，反正没拿到分。
这题首先->骑士之间互不影响
->到一个城池后所有到达的骑士都要改变攻击力
->并且每次到一个城池把小于该城池防御力的骑士杀死。
这一想..维护一个小根堆….最后一直传到根节点，然后再把根节点连一个防御力正无穷的城池不就好了么。
每次到一个节点后把这个堆里小于他防御力的骑士干死。
然后合并一个节点所有子节点时涉及到合并操作。
所以考虑到可并堆。
然后我们从顶向下递归搞是不行的，要爆栈，所以保险起见我们从下向上搜。
但是直接搜不行，因为在处理一个节点前要处理它的所有子节点。
所以在拓扑图上搞就可以了。
代码:
#include <queue> 
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 300010
#define INF (1ll<<63)-1
using namespace std;
typedef long long ll;
int n,m,cnt,cnt_l,top;
ll h[N],v[N],val[N];
int a[N],head[N],head_l[N],fa[N],du[N];
int he[N],ch[N][2],att[N],col[N],kill[N];
ll siz[N];
ll add[N],mul[N];
int stk[N],fron[N];
char getc()
{
    static const int LEN=1<<15;
    static char buf[LEN],*S=buf,*T=buf;
    if(S==T)
    {
        T=(S=buf)+fread(buf,1,LEN,stdin);
        if(S==T)    return EOF;
    }
    return *S++;
}
int read()
{
    static char ch;
    static int D;
    while(!isdigit(ch=getc()));
    for(D=ch-'0';isdigit(ch=getc());)
        D=(D<<3)+(D<<1)+(ch-'0');
    return D;
}
ll readll()
{
    static char ch;
    static ll D;
    ll f=1;
    while(!isdigit(ch=getc())){if(ch=='-')f=-1;}
    for(D=ch-'0';isdigit(ch=getc());)
        D=(D<<3)+(D<<1)+(ch-'0');
    return D*f;
}
struct node
{
    int from,to,next;
}edge[N];
struct link
{
    int from,to,next;
}l[N];
int find(int x)
{
    while(fa[x])x=fa[x];
    return x;
}
void init()
{
    he[0]=-1;
    memset(head,-1,sizeof(head));
    memset(head_l,-1,sizeof(head_l));
    for(int i=1;i<=m;i++)mul[i]=1;
    cnt=1,cnt_l=1;
}
void edgeadd(int from,int to)
{
    edge[cnt].from=from,edge[cnt].to=to,edge[cnt].next=head[from];
    head[from]=cnt++;
}
void linkadd(int from,int to)
{
    l[cnt_l].from=from,l[cnt_l].to=to,l[cnt_l].next=head_l[from];
    head_l[from]=cnt_l++;
}
void pushup(int x)
{
    siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;
}
void pushdown(int x)
{
    if(add[x]!=0||mul[x]!=1)
    {
        if(ch[x][0]!=0)
        {
            val[ch[x][0]]*=mul[x];
            val[ch[x][0]]+=add[x];
            add[ch[x][0]]*=mul[x];
            add[ch[x][0]]+=add[x];
            mul[ch[x][0]]*=mul[x];
        }
        if(ch[x][1]!=0)
        {
            val[ch[x][1]]*=mul[x];
            val[ch[x][1]]+=add[x];
            add[ch[x][1]]*=mul[x];
            add[ch[x][1]]+=add[x];
            mul[ch[x][1]]*=mul[x];
        }
        add[x]=0,mul[x]=1;
    }
}
void pushdown_att(int x)
{
    if(col[x])
    {
        if(ch[x][0]!=0)
            col[ch[x][0]]+=col[x],att[ch[x][0]]+=col[x];
        if(ch[x][1]!=0)
            col[ch[x][1]]+=col[x],att[ch[x][1]]+=col[x];
        col[x]=0;
    }
}
int merge(int x,int y)
{
    if((!x)||(!y))return x+y;
    if(val[y]<val[x])swap(x,y);
    pushdown(x),pushdown_att(x);
    ch[x][1]=merge(ch[x][1],y);
    fa[ch[x][1]]=x;
    if(he[ch[x][1]]>he[ch[x][0]])swap(ch[x][0],ch[x][1]);
    he[x]=he[ch[x][1]]+1;
    pushup(x);
    return x;
}
struct ele
{
    int x,pre; 
};
void bfs()
{
    for(int i=1;i<=n;i++)
    {
        if(du[i]==0)
        {
            stk[++top]=i;
        }
    }
    while(top)
    {
        int u=stk[top--];
        int pre=0;
        for(int i=head_l[u];i!=-1;i=l[i].next)
        {
            int to=l[i].to;
            int t=merge(pre,to);
            pre=t;
        }
        int t=merge(pre,fron[u]);
        fron[u]=t;
        while(val[fron[u]]<h[u]&&fron[u])
        {
            pushdown(fron[u]),pushdown_att(fron[u]);
            int t=merge(ch[fron[u]][0],ch[fron[u]][1]);
            fa[t]=0;
            fa[fron[u]]=ch[fron[u]][0]=ch[fron[u]][1]=0;
            kill[u]++;
            fron[u]=t;
        }
        col[fron[u]]++,att[fron[u]]++;
        if(!a[u])
        {
            val[fron[u]]+=v[u];
            add[fron[u]]+=v[u];
        }else 
        {
            val[fron[u]]*=v[u];
            mul[fron[u]]*=v[u];
            add[fron[u]]*=v[u];
        }
        for(int i=head[u];i!=-1;i=edge[i].next)
        {
            int to=edge[i].to;
            fron[to]=merge(fron[to],fron[u]);
            du[to]--;
            if(!du[to])stk[++top]=to;
        }
    }
}
int main()
{
//  freopen("fall.in","r",stdin);
//  freopen("fall.out","w",stdout); 
    n=read(),m=read();
    init();
    for(int i=1;i<=n;i++)h[i]=readll();
    h[n+1]=INF,edgeadd(1,1+n);
    du[1+n]=1;
    for(int i=2;i<=n;i++)
    {
        int pre;
        pre=read(),a[i]=read(),v[i]=readll(); 
        edgeadd(i,pre);
        du[pre]++; 
    }
    for(int i=1;i<=m;i++)
    {
        int fir;
        val[i]=readll(),fir=read(); 
        linkadd(fir,i);
    }
    bfs();
    for(int i=1;i<=n;i++)printf("%d\n",kill[i]);
    for(int i=1;i<=m;i++)printf("%d\n",att[i]);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu2586 How far away ？（LCA->RMQ）
题目链接：点击打开链接
题意描述：给定一棵树，找出树中任意两点之间的距离？


解题思路：
1、dfs预处理达到欧拉序列
2、使用RMQ找出最近公共祖先
3、找出根到任意一点的距离，答案为dis[f]+dis[t]-2*dis[rt]


代码：
#include <cstdio>
#include <cstring>
#include <cmath>
#include <stack>
#define MAXN 40010
using namespace std;

int head[MAXN],tol;
struct Edge{
    int to,v,next;
}edge[2*MAXN];
void addEdge(int f,int t,int v){
    edge[tol].to=t;edge[tol].v=v;edge[tol].next=head[f];head[f]=tol++;
    edge[tol].to=f;edge[tol].v=v;edge[tol].next=head[t];head[t]=tol++;
}
int e[2*MAXN],d[2*MAXN];
int fs[MAXN];
int dis[MAXN];
struct node{
    int ct,ds;
    node(int _ct,int _ds):ct(_ct),ds(_ds){}
};
stack<node> st;
bool vis[MAXN];
void dfs(int rt){
    int id=1,h=0,ds=0;
    while(!st.empty()) st.pop();
    st.push(node(rt,ds));vis[rt]=true;
    while(!st.empty()){
        node tmp=st.top();
        rt=tmp.ct;
        if(fs[rt]==-1){
            fs[rt]=id;
            dis[rt]=tmp.ds;
        }
        e[id]=rt;d[id++]=h;
        while(head[rt]!=-1&&vis[edge[head[rt]].to]) head[rt]=edge[head[rt]].next;
        if(head[rt]!=-1){
            h++;
            vis[edge[head[rt]].to]=true;
            st.push(node(edge[head[rt]].to,tmp.ds+edge[head[rt]].v));
            head[rt]=edge[head[rt]].next;
        }
        else {
            h--;
            st.pop();
        }
    }
}
int dp[MAXN*2][18];
void makeRmqIndex(int n,int b[]){
    int i,j;
    for(i=1;i<=n;i++)
        dp[i][0]=i;
    for(j=1;(1<<j)<=n;j++){
        int limit=n+1-(1<<j);
        for(i=1;i<=limit;i++)
            dp[i][j]=b[dp[i][j-1]] < b[dp[i+(1<<(j-1))][j-1]]? dp[i][j-1]:dp[i+(1<<(j-1))][j-1];
    }
}
int rmqIndex(int s,int v,int b[]){
    int k=(int)(log((v-s+1)*1.0)/log(2.0));
    return b[dp[s][k]]<b[dp[v-(1<<k)+1][k]]? dp[s][k]:dp[v-(1<<k)+1][k];
}
int n,m;
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&m);
        int f,t,v;
        tol=0;memset(head,-1,sizeof(head));
        for(int i=0;i<n-1;++i){scanf("%d%d%d",&f,&t,&v);addEdge(f,t,v);}
        memset(vis,false,sizeof(vis));
        memset(fs,-1,sizeof(fs));
        dfs(1);
        makeRmqIndex(2*n-1,d);
        for(int i=0;i<m;++i){
            scanf("%d%d",&f,&t);
            int rt;
            if(fs[f]>fs[t])///注意大小
            rt=rmqIndex(fs[t],fs[f],d);
            else
            rt=rmqIndex(fs[f],fs[t],d);
            rt=e[rt];
            printf("%d\n",dis[f]+dis[t]-2*dis[rt]);
        }
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 3371 Connect the Cities
重要的事情说三遍kruskal不可能AC kruskal不可能AC kruskal不可能AC
如果你说你能AC，请把你的代码再交一遍试试（这题的数据可能加强过），再把代码发我，让我开开眼界
开始随意的写了个没优化的prim算法都TLE到死，临接矩阵可以飘过，加了堆优化可能好一点，心太累，已经AC了就不想改了
#include<iostream>
#include<vector>
#include<cstdio>
#include<algorithm>
#define maxn 505
#define inf 1<<20
using namespace std;
int n;
vector<int>mapp[maxn];
int vaule[maxn][maxn];
int visit[maxn];
void prim()
{
	int d[maxn];
	fill(d,d+1+n,inf);
	fill(visit,visit+1+n,0);
	int re=0,k=0;
	d[1]=0;
	while(1)
	{
		int v=-1;
		for(int i=1;i<=n;i++)
		{
			if(!visit[i]&&(v==-1||d[i]<d[v])) v=i;
		}
		//cout<<v<<"~"<<endl; 
		if(v==-1||d[v]==inf) break;
		re+=d[v];
		k++;
		if(k==n) break;
		visit[v]=1;
		for(int i=0;i<mapp[v].size();i++)
		{
			int x=mapp[v][i];
			if(!visit[x]) d[x]=min(d[x],vaule[v][x]);//不加判断条件直接更新会TLE 
		}
	}
	//cout<<k<<endl;
	if(k==n) cout<<re<<endl;
	else cout<<"-1"<<endl;
}
int main()
{
	//cin.sync_with_stdio(false);
	int t;
	//cin>>t;
	scanf("%d",&t);
	while(t--)
	{
		for(int i=0;i<=n;i++) mapp[i].clear();
		int m,k;
		scanf("%d%d%d",&n,&m,&k);
		for(int i=0;i<=n;i++)
		{
			for(int j=0;j<=n;j++) vaule[i][j]=inf;
		} 
		for(int i=0;i<m;i++)
		{
			int x,y,z;
			scanf("%d%d%d",&x,&y,&z);
			if(vaule[x][y]==inf)
			{
				mapp[x].push_back(y);
				mapp[y].push_back(x);
				vaule[x][y]=min(vaule[x][y],z);
				vaule[y][x]=min(vaule[y][x],z);
				//cout<<vaule[x][y]<<endl;
			}
			else 
			{
				vaule[x][y]=min(vaule[x][y],z);
				vaule[y][x]=min(vaule[y][x],z);
			}
		}
		for(int i=0;i<k;i++)
		{
			int s;
			scanf("%d",&s);
			int x;
			scanf("%d",&x);
			for(int j=0;j<s-1;j++)
			{
				int y;
				scanf("%d",&y);
				if(vaule[x][y]==inf)
				{
					mapp[x].push_back(y);
					mapp[y].push_back(x);
					vaule[x][y]=0;
					vaule[y][x]=0;
				}
				else 
				{
					vaule[x][y]=0;
					vaule[y][x]=0;
				}
			}
		}
		prim();
	}
	return 0;
} 






版权声明：本文为博主原创文章，未经博主允许不得转载。

Nim 博弈
一，题意：
有n堆石子，每堆有ai个石子，Alice与Bob两人轮流取石子，每次取石子要求从非空
堆中取走至少一颗石子，Alice为先手，取光所有石子的一方获胜，
二，解析：
该题为标准的Nim博弈，
必胜态（非奇异态）：a1 ^ a2 ^ a3 …… ^an != 0;
必败态（奇异态）：   a1 ^ a2 ^ a3 …… ^an  == 0;
三，代码：
#include <iostream>
#include <stdio.h>
using namespace std;
int N;
int a[1000];

int main()
{
    while(scanf("%d",&N)!=EOF && N)
    {
        for(int i=0;i<N;i++)
            scanf("%d",&a[i]);
        int sum=a[0];
        for(int i=1;i<N;i++)
        {
            sum^=a[i];
        }
        if(sum)
            printf("Alice\n");
        else
            printf("Bob\n");
    }
    return 0;
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

统治世界的十大算法







统治世界的十大算法







 
前言
 
软件正在统治世界.而软件的核心则是算法.算法千千万,又有哪些算法属于”皇冠的珍珠”呢?
 
 
 
什么是算法
 
通俗的说,算法是一个定义明确的计算过程,可以一些值或一组值作为输入并产生一些值或一组值作为输出.因此算法就是将输入转换为输出的一系列计算步骤.
 
简而言之,算法就是可以完成特定任务的一系列步骤,它应该具备三大特性:
1.有限
2.指明明确
3.有效
 
 
 
下面开始介绍十大算法
 
一.归并排序,快速拍苏以及堆积排序
 
 
 
最好的排序算法跟需求密切相关,很难评判.但是从使用上来说,题目上说的三种使用频率最高.
 
归并排序是一种基于比较的排序算法,采用分而治之的方法解决问题,其阶是O(n^2).
 
快速排序可采用原地分割方法,也可采用分而治之算法.这不是一种稳定的排序算法,但对于基于RAM的数组排序来说很有效.
 
堆排序采用优先级队列来减少数据中的搜索时间.该算法也是原地算法,并非稳定排序.
 
这些排序算法相对于以前的冒泡排序算法等有了巨大的进步,实际上我们今天的数据挖掘,人工智能,连接分析以及包括web在内的大多数计算工具都要感谢他们.
 
 
 
二.傅里叶变换与快速傅里叶变换
 
 
我们的整个数字世界都是用这两个简单但是非常强大的算法,起作用是将信号从时域转为频域或者反之.就连你看到这篇博客都得感谢这些算法.
 
互联网,wifi,智能手机,电话,计算机,路由器,卫星,几乎所有内置有计算机的东西都会以各种方式使用这两种算法.
 
 
 
三.迪杰斯特拉算法
 
迪杰斯特拉是一种图谱搜索算法.许多问题都可以建模为图谱,然后利用迪杰斯特拉寻找两个节点之间的最短路径.如果没有迪杰斯特拉算法,互联网的运营效率必将大大降低.虽然今天我们已经有了更好的寻找最短路径的解决方案,但出于稳定性的要求,迪杰斯特拉算法仍然被很多系统使用.
 
 
 
四.RSA算法
 
如果没有密码术和网络安全,互联网就不会像今天这样重要,因为电子商务和电子交易需要这些技术来确保交易安全.而RSA算法是最重要的密码学算法之一.这个算法让密码学普及到了千家万户并奠定了密码术的应用基础.RSA要解决的问题既简单又复杂:如何如何在独立平台与最终用户之间共享公钥.其解决方案是加密.RSA家吗的基础是一个十分简单的数论事实:将两个大素数相乘十分容易,但是想要对其乘积进行因式分解却极其困难,因此可将乘积公开作为加密密钥.但在分布式计算和量子计算机理论日益成熟的今天,RSA加密安全性收到了挑战.
 
 
 
五.安全哈西算法
 
这个实际上并不算是算法,而是由美国国家标准技术研究所开发的一系列密码杂凑函数.但是这系列函数是全世界运作的基石.应用商店,点在邮件,反病毒,浏览器等在使用该算法系列函数,该算法函数可以用来确定下载的东西是否是自己想要的,还是说遭受了中间人攻击或钓鱼攻击.
 
 
 
六.整数因子分解
 
这是一个在计算领域使用的数学算法.如果没有这一算法,密码术就会变得不安全很多.整数因子分解是用来将一个合数分解成一系列素因子的一系列步骤.整数因子分解可被视为是FNP问题(FNP是难以解决的典型的NP问题的扩展).
 
许多密码协议均基于难以分解的大型合数或者相关问题.比方说前面提到的RSA问题.如果有算法能够有效分解任意数字,那么就会使得基于RSA的公钥密码系统陷入不安全的境地.
 
而量子计算的诞生则令此问题的解决变得容易,从而也打开了一个全新的领域,可利用量子世界的属性来令系统更加安全.
 
 
 
七.连接分析
 
在互联网时代,不同实体间关系的分析至关重要.从搜索引擎和社交网络到营销分析工具,每个人都想找出互联网的真正结构.
 
连接分析无疑是公众对算法的最大困惑与迷思之一.其问题在于进行连接分析有不同的方式,而增加一些特征就会令每一算法略有不同(从而使得算法收到专利保护),但基本上这些算法都是类似的.
 
连接分析算法背后的思路很简单,即把图谱以矩阵的形式标识,从而转为特征值问题,而特征值有助于了解图谱结构以及每个节点的相对重要性.
 
Google 的 PageRank，Facebook 展示新闻源，Google+，Facebook 朋友推荐，LinkedIn 工作及联系人推荐，Netflix 与 Hulu 的电影推荐，YouTube 视频推荐等均使用了链接分析算法。虽然每个都有不同的目标和参数，但其背后的数学是一样的。
 
尽管 Google 似乎是利用此类算法的第一家公司，但是实际上百度创始人李彦宏在 Google 诞生 2 两年前做的搜索引擎“RankDex”已经利用这种思路来进行搜索排名了。
 
 
 
八.比例积分微分算法
 
如果你用过飞机,汽车,微型服务或手机网络,如果你在工厂里呆过或者见过机器人,那么你已经见过PID算法的作用了.
 
该算法利用了控制回路 机制来让期望输出信号与实际输出信号之间的错误降到最小.只要需要信号处理货需要电子系统来控制自动化的机械,水力或电力系统就会用到它.
 
因此可以说,如果没有这一算法,人类的现代文明将不复存在.
 
 
 
九.数据压缩算法
 
数据压缩算法无疑是非常重要的,因为几乎所有的结构都用得到.除了最明显的压缩文档以外,网页下载时也会压缩,视频游戏,音乐,云计算,数据库等等都要使用压缩算法.可以说集合所有应用都要使用压缩算法,因为饮用不同,使用的压缩算法从zip到MP3,,JPEG或MPEG-2各异.
 
 
 
十.随机数生成算法
 
很多应用都需要随机数,像密码系统,视频游戏,人工智能,优化,问题的初始条件,金融等都需要生成随机数.但实际上我们并没有”真正”的随机数生成器,尽管有一些伪随机数生成器也是非常有效的.
 
 
 
小小的结一下
 
当然，十大算法也可能给有凑数之嫌，审视的角度不同对算法的重要性看法也会很不一样，如果你认为这一榜单有错漏的地方，不妨在评论中贡献你的意见.
 在以后的学习中我会在详细介绍这些算法的具体内容.
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ1260
传送门：BZOJ1260
傻逼题。
记f(i,j)表示把区间[i,j]染色最小操作次数，f(i,j)表示把区间[i,j]染色最小操作次数，则转移是f(i,j)={s[i]=s[j],minf(i+1,j),f(i,j−1)otherwise ,minf(i,k)+f(k+1,j),k∈[i,j−1]f(i,j)= \{^{s[i]=s[j],min{f(i+1,j),f(i,j-1)}}_{otherwise\text { },min{f(i,k)+f(k+1,j),k \in [i,j-1]}}
然后就可以Dp辣！！！
代码上的小细节见下。
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;

const int INF=0x3f3f3f3f;

char S[105];
int f[105][105];
bool used[105][105];

int Dp(int l,int r)
{
    if(used[l][r])
        return f[l][r];
    if(S[l]==S[r])
        f[l][r]=min(Dp(l+1,r),Dp(l,r-1));
    else{
        f[l][r]=INF;
        for(int k=l;k<r;k++)
            f[l][r]=min(f[l][r],Dp(l,k)+Dp(k+1,r));
    }
    used[l][r]=true;
    return f[l][r];
}

void Readdata()
{
    scanf("%s",S+1);
}

void First()
{
    int l=strlen(S+1);
    memset(used,false,sizeof(used));
    for(int i=1;i<=l;i++)
        f[i][i]=used[i][i]=1;
}

void Solve()
{
    printf("%d\n",Dp(1,strlen(S+1)));
}

void Close()
{
    fclose(stdin);
    fclose(stdout);
}

int main()
{
    Readdata();
    First();
    Solve();
    Close();
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

LightOJ 1184 - Marriage Media 【二分图最大匹配】
题目链接：http://www.lightoj.com/volume_showproblem.php?problem=1184
根据一些要求建图即可
代码：
#include <iostream>  
#include <algorithm>  
#include <set>  
#include <map>  
#include <string.h>  
#include <queue>  
#include <sstream>  
#include <stdio.h>  
#include <math.h>  
#include <stdlib.h>  

using namespace std;

int n, m;
int p[1000][1000];
int book[1000];
int match[1000];

int dfs(int u)
{
    int i;
    for (i = 1; i <= m; i++)
    {
        if (book[i] == 0 && p[u][i] == 1)
        {
            book[i] = 1;
            if (match[i] == 0 || dfs(match[i]))
            {
                match[i] = u;
                return 1;
            }
        }
    }
    return 0;
}


struct peo
{
    int hig;
    int age;
    int ok;
}a[110], b[110];

int main()
{
    int t;
    int cases = 1;
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d%d", &n, &m);

        for (int i = 1; i <= n; i++) scanf("%d%d%d", &a[i].hig, &a[i].age, &a[i].ok);
        for (int i = 1; i <= m; i++) scanf("%d%d%d", &b[i].hig, &b[i].age, &b[i].ok);

        int ans = 0;
        memset(match, 0, sizeof(match));
        memset(p, 0, sizeof(p));

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
            {
                if (a[i].ok == b[j].ok && abs(a[i].hig - b[j].hig) <= 12 && abs(a[i].age - b[j].age) <= 5)
                p[i][j] = 1;
            }

        for (int i = 1; i <= n; i++)
        {
            memset(book, 0, sizeof(book));
            if (dfs(i))
                ans++;
        }
        printf("Case %d: %d\n", cases++, ans);
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：转载请注明出处。

The science of interaction交互元素与知识构建过程的查询方式
The science of interaction
摘要
可视分析中增长的感知交互和查询无法摆脱。通过交互操作可视界面---分析的论述----构建、测试、精炼，及共享知识。本文反映可视化研究与开发会议中的交互挑战。识别最近可视分析研究典范，在真实的交互科学目标具有真实的进步，必须包括理论和可测试关于人与信息交互最合适机制。七个领域未来5年可视分析研究：普适，表征交互；获取用户意向性；基于知识的界面；交互评估。最终，科学交互目标是支持可视分析，人、机交互群体通过感知和实现最好的实践，在可视显示的表征和操作。
   
交互的元素，信息可视化领域将交互分为两个等级，低水平的交互（用户与软件界面的交互），高水平的交互（用户与信息空间的交互）。
 
 
三种方式获得知识，
1 abduction 诱导，从探索分析中获得的观察报告，通过一个“本能请求”刺激可能假设。（什么看起来对用户有意义？）对新数据空间变得熟悉的过程，被认为是诱导过程：用户开始了解问题，并形成目标，以及确认数据资源如果数据没有提前给定。熟悉的过程设计到检验（review）数据，确认其中的缺口，决定用什么工具和方法可以解决，转换数据到可以被这些方法使用的格式，确认数据中的变化如果提前检测到，理解消费者需求（在什么背景下分析师的答案会被采用），以及清楚现有假设。在构建驾驶或‘abduction’，分析师从事于数据空间的探索，以及思想模型的构建来解释观察结果。
2 Deduction 推理，在这里检查这些假设的结果。（如果发生的假设是真的，一个回答重新构造得到的问题，能评估主张假设会隐含的正确性吗？）推理可能导致驳倒之前形成的假设，作为不同于诱导过，它需要真实保质。在认证分析中，用户可能跳过诱导步骤（），并从事一个“顶端到底端”的推理评估。在这一点上，用户快速构建他们的信息空间来识别认证特征的能力是关键，与探索需求相比，当找到结果反映在多个互补的显示。
3 induction 归纳，归纳假设测试选择最可能的解释，通过查找附加指示和可选择解释排列。分析的证实阶段是一个典型的归纳，相反的指示器可能驳倒探索到的假设，可选择的解释是被考虑的，偏见被评估，有缺陷的与已解决的。归纳不是保护证实的，未来观察可能改变或反驳一个假设，但是在交互设计中，是一个有益的。用户目标是类似易变的，可视分析任务意图频繁，识别对观察最好的解释，知识是潜在多个解释，并且没有分析工具可能提供访问所有数据以及所有可能探索数据的方法。可视分析工具简单给用户提出问题的方式，并必须支持这些问题和他们答案随时间的演化。







版权声明：本文为博主原创文章，未经博主允许不得转载。

海贼王片头旁白前后两篇
拥有财富、名声、势力
富（とみ）、名声（めいせい）、力（ちから）


拥有整个世界的海贼王 哥尔.D.罗杰
この世（よ）の全（すべ）てを手（て）に入（い）れた男（おとこ）
海賊王（海賊王）ゴールドロジャー

他在临刑前的一句话让人们趋之若鹜奔向大海
彼（かれ）の死（し）に際（ぎわ）に話（はな）った一言（ひとこと）は
人々（ひとびと）を海（うみ）へ駆（か）り立（た）てた

想要我的财宝吗？
「俺（おれ）の財宝（ざいほう）か？」
想要的话就可以全部给你
「欲（ほ）しけりゃ　くれてやる」
去找吧 我把所有的财宝都放在那里
「探（さが）せ、この世（よ）の全（すべ）てをそこにおいてきた」

于是所有男子汉航向伟大的航路追逐梦想
男（おとこ）たちはグランドラインを目指（めざ）し　　
夢（ゆめ）を追（お）い続（つづ）ける

世界开始迎接大海贼时代的来临
世（よ）は、まさに、大海賊時代（だいかいぞくじだい）







梦想得到ONE PIECE的所有海贼

ワンピースを狙（ねら）う全（すべ）ての海賊達（かいぞくたち）が目指（めざ）す
向往到达的地方——后半之海

グランドライン後半（こうはん）の海（うみ）
人称“新世界”

人呼（ひとよ）んで「新世界（しんせかい）」
但是曾经成功征服这片海域的

しかし、かつてその海を制（せい）したのは
只有被称作“海贼王”的哥儿.D.罗杰一人

”海賊王（かいぞくおう）”ゴールド・ロジャーただ一人（ひとり）
“新世界”毁灭了无数海贼的梦想和野心
「新世界（しんせかい）」は幾多（いくた）の海賊（かいぞく）たちの夢（ゆめ）と野望（やぼう）を阻（はば）んできた
而现在 吃了橡胶果实成为橡胶人的少年蒙奇.D.路飞
その海（うみ）に今（いま）、ゴムゴムの実（み）を食（た）べゴム人間（にんげん）となった少年（しょうねん）
与他的伙伴们正在向着那片海域发起挑战
モンキ.D.ルフィとその仲間達（なかまたち）が挑（いど）む
海贼王 我当定了！
海賊王（かいぞくおう）にオレはなる！！











版权声明：本文为博主原创文章，未经博主允许不得转载。

LLVM Cookbook读书笔记（本书的缺点是直接展示大量Sample代码，对SSA/phi并没有怎么解释，TableGen部分也没讲清楚）
LLVM Cookbook（Packt，2015）





*重新理解 value --> use（每个IR就是一个value，SSA）builder.GetInsertBlock(); //Codegen: 先有cfg框架，TDD？if-then-else及for循环：需用PHI合并？（重点）优化步（IR层）

$ clang -S -O0 -emit-llvm test.cpp$ opt -O1 -S test.ll （注意：中间分析结果可以共享，如以文件数据库的形式，或VS里的.pdb）
3层概念：Function::iterator --> BasicBlock::iterator --> i->getOpcodeName()别名分析（AA）

AliasAnalysis：导出AliasResult、ModRefResult（*）alias(a,b)：--> MustAlias（肯定是）、PartialAlias、MayAlias、NoAliasgetAdjustedAnalysisPointer：当用多继承实现了分析接口？
$ opt

--aa-eval ...--print-dom-info ... （什么是dominator tree？）--count-aa -basicaa -licm ...
ImmutablePass --> 转换步

LLVMPassManagerRef PM: unwrap(PM)->add(pass);例，实现DCE（死代码终止），主要思路：开始假设所有IR为dead，然后从根开始，传播liveness
for(Use& OI : inst->operands()) {
if(Instruction* inst_refed = dyn_cast<Instruction>(OI)){ ... //记录到livelist
} for(Instruction& I : inst_range(F)) { ...//第2遍，过滤;
I.dropAllReferences();
} for(Instruction*& I : deadlist)
I->eraseFromParent();
//注意这里的多遍遍历的处理代码；这让我想起了jQuery作者用正则表达式多遍替换实现的Processing.js

函数调用内联

class MyInliner : public Inliner {
...bool runOnSCC(CallGraphSCC& );
InlineCost: getAlways()/getNever() //这算枚举常量吗Function* callee = callsite.getCalledFunction();
$ opt -memcpyopt

转换前：call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arr_i8, i8* bitcast([3 x i32] * @cst to i8*), i64 12, i32 4, i1 false);转换后：call void @llvm.memset.p0i8.i64(..., i8 -1, i64 12, ...);
Combining IR（指令序列的替换，Machine dep.）

高效的模式匹配是关键!
LICM（循环不变式外提）

其他：loop-rotate/-unswitch/-unroll
重结合表达式（注意，这些都是标量变换）Vectorizing IR

 ? bool matchFlatReduction(PHINode*, BinaryOp*, *DL);
目标无关的代码生成

SelectionDAG合法化

SDNode: target lowering--> MachineSDNode（.td -->tablegen .inc）拓扑排序/线性化（‘指令调度’?）
寄存器分配Code emission

addPassesToEmitFileAsmPrinter'llc'MCStreamer
寄存器分配
* 可视化CFG：GraphVizTableGen（最难理解的东西就是这个！）

class SAMPLEReg< bits<16> Enc, string n> : Register<n> { //每个实例代表一个寄存器;
foreach i=0-3 in { //注意这里的in，参考了ML的语法？
def R#i : R<i, "r"#i>;
...

*定义指令集：#see X86InstrInfo.tdMachineFunction, MachineBasicBlock, MachineInstr（addOperand/MemOperand，隐式参数？？）实现MachineInstrBuilder

BuildMI*
实现MBB

Predecessors/SuccessorsSplitCriticalEdge*
实现MF

-ConstantPool, -FrameInfo, -FunctionInfo, -RegisterInfo, ...
编写一个指令选择器Legalizing SelectionDAG（如i64-->i32）Optimizing SelectionDAG

DAGCombine.cpp ?
从DAG选择指令：SelectionDAGISel（注意这里诡异的ISel后缀，代表指令选择的意思）指令调度（线性化）：DFS，TopSort优化机器代码：到这里，仍然是SSA形式？

dce, cse（编译原理里面所谓的‘窥孔优化’？）：类似于IR，只是多了约束检查（比如RISC流水线/延迟槽？）分析live intervals（活跃区间）分配寄存器/SSA解构：phi -> copy*插入prologue-epilogue代码TCOSibling CO（C++11里的完美转发？）
*编写LLVM后端（除非是做CPU，否则实际中用不到）：a Toy backend with r0~r3 + sp + lr（不能再简单了！）

定义calling convention（cc）定义指令集frame lowering（？）sub target（如ARM Neon，Intel SSE/AVX）lowering到多个指令（汇编语言中的‘伪指’）注册target
LLVM应用

异常：__cxa_throw/begin_catch/end_catchsantizer：shadow内存（hook malloc/free），--> ValgrindGC：@llvm.gcroot / .statepointtoJSbugpoint（类似于git bisect，用于定位LLVM Pass的实现错误）LLDB（操作的是LLVM最终生成的目标平台机器指令？）utility步ClangStaticAnalyzer：符号执行（all path？）；ExplodedGraph 



版权声明：本文为博主原创文章，未经博主允许不得转载。

LeetCode（2） Remove Duplicates from Sorted Array
Remove Duplicates from Sorted Array

题目 考察数组 
描述 
Given a sorted array, remove the duplicates in place such that each element appear only 
once and return the new length. 
Do not allocate extra space for another array, you must do this in place with constant memory. 
For example, Given input array A = [1,1,2], 
Your function should return length = 2, and A is now [1,2].
C++代码如下 
时间复杂度o(n),空间复杂度o(1)：

/*
* Remove Duplicates from Sorted Array
* For example Given input array A= [1,1,2] 
* Your function should return length = 2; and A is now [1,2]
*/

#include <iostream>
using namespace std;


class Solution{


public:
    //返回值，函数参数，实现功能
    //指向整形数组的指针,数组和数组个数，实现对数组元素去重
    int * RemoveDuplicates(int *a,int num){

        //思路：按照判断相邻两个元素是否相同，若不相同，后一个元素覆盖前一个元素
        //      同时index 记录新的数组的个数
        int index =0;

        // 从第二个元素开始比较
        for(int i=1;i<num;i++){
            //如果相邻的两个元素不同
            if(a[index]!=a[i]){
                index++;
                a[index]=a[i];
            }

        }

        for(int j=0;j<=index;j++){
            cout<<a[j]<<" ";
        }
        cout<<endl;


        return a;
    }


};


int main(){

    int a[]={1,1,2,2,3};

    Solution s1;
    s1.RemoveDuplicates(a,5);


    getchar();
    getchar();
    return 0;
}

Result

1 2 3

概念理解
const 定义理解

const 修饰 
关于const修饰指针的情况，一般分为如下四种情况：

int b =500;
const int* a = &b; //情况1
int const *a = &b;//情况2
int * const a=&b; //情况3
const int* const a= &b; //情况4
如何区别呢？ 
（1）情况1 
如果const 位于星号的左侧，则const就是用来修饰指针所指向的变量的，即指针指向为常量。如果const位于星号右侧，const就是修饰指针本身，即指针本身是常量。因此，情况1和情况2相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作。
举一个通俗的例子，如果a是一名仓库管理员的话，他所进入的仓库，里面的货物（*a）是他没有权限允许动的。
const 与#define相比有什么不同？

解答
c++语言可以用const定义常量，也可以用#define定义常量，但是前者比后者有更多的优点：

1、const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而后者只进行字符替换，没有类型安全检查，并且在字符串替换过程中可能会产生意想不到的错误，也就是边际效应。
2、在有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。在c++程序中只是用const常量而不使用宏常量，即const常量完全取代宏定义。
常量的引进是在早期的c++版本中，当时标准C规范正在定制。那时，常量被看做一个好的思想而被包含在C中。但是，C中的const的意思是“一个不能被改变的普通变量”。在C中，它总是占用内存，而且它的名字是全局符。C编译器不能把const看出一个编译期间的常量。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

ubuntu系统截图常用方法
1.使用键盘快捷键抓图

　　我们可以使用键盘功能键Print Screen或Alt+Print Screen组合键来抓图，前者可以抓取整个屏幕的图像，而后者可以抓取当前活动窗口的图像。例如抓取整个屏幕的图像，则按下Alt+Print Screen组合键，不一会儿将弹出“保存抓图”对话框(图1)，对话框中显示截图的文件名以及图像存储的目标路径(这里我们使用默认存储路径)，如点击“复制到剪贴板”按钮则将截图复制到系统剪贴板中，在其他程序中使用时只要“粘贴”过去就可以了;如点击“保存”按钮则将抓取的屏幕图像保存为文件，文件名由系统自动生成，如Screenshot.png。使用键盘快捷键来抓图，优点是快捷、方便，适用于只需要抓取全屏或某个活动窗口图像的情况。


2.功能强大的KSnapshot
　　KSnapshot是KDE集成桌面环境自带的截图工具，不过在GNOME集成桌面环境下也可以安装和使用它。我们可以通过新立得软件包管理器或使用apt-get命令来安装它。假设使用命令行方式来安装，打开一个GNOME终端窗口，在终端窗口中输入如下命令：
　　sudo apt-get install ksnapshot
　　命令执行后，将在线下载并安装KSnapshot。安装完毕后，在菜单“应用程序”→“图像”下找到“KSnapshot”项，点击该项则运行KSnapshot程序(如图4)。
　　KSnapshot功能非常强大，提供的截图模式有全屏(Full Screen)、光标下的窗体(Window under cursor)、任意区域(Region)和窗体部件(Section of Window)四种。其中“光标下的窗体”抓取模式可以在不激活要抓取的窗体的情况下，只要将鼠标移动到该窗体的某个区域即可抓取该窗体。
　　在输出所抓取的图像方面，KSnapshot增加了复制到剪贴板和直接打印的功能。KSnapshot应该算得上是一款较为专业的抓图工具，使用KSnapshot几乎可以轻松抓取屏幕上的任意图像，笔者推荐大家安装和使用这款软件。



3.在dash 中输入screenshot 
此外，还可以使用命令来截图，ubuntu 中截图命令是gnome-screenshot .
可以在终端输入gnome-screenshot -h 来查看该命令的用法
用法：
gnome-screenshot [选项...] 抓取屏幕的图片
帮助选项：
-h, –help 显示帮助选项
–help-all 显示全部帮助选项
–help-gtk 显示 GTK+ 选项
应用程序选项：
-w, –window 抓取窗口，而不是整个屏幕
-a, –area 抓取屏幕的一个区域，而不是整个屏幕
-b, –include-border 抓图中包含窗口边框
-B, –remove-border 去除屏幕截图的窗口边框
-d, –delay=秒 在指定延迟后抓图[以秒计]
-e, –border-effect=效果 添加到边框的特效(阴影、边框或无特效)
-i, –interactive 交互式设定选项
–display=显示 要使用的 X 显示
我们常用到的截图选项是截取某个区域的，因此不妨给它设置一个快捷键。ubuntu 12.10 中怎么设置快捷键呢？
假设，我想要按下Ctrl+Alt +A 来实现区域截图
依次打开【system settings】（系统设置）–》【keyboard】(键盘)–》【shortcuts】（快捷键）–》【custom shortcuts】（自定义快捷键），点击那个加号“+”，在【name】输入 screenshot , 【command】输入 gnome-screenshot -a ，点击【apply】确定后，再点击disable ，接着就同时按下 Ctrl+Alt +A 就可以成功设置截图快捷键了。
想要在ubuntu上设置其它快捷键，方法与此类似。

版权声明：本文为博主原创文章，未经博主允许不得转载。

WPF之NPOIE导出xcel
最近，我做的统计功能用到了导出Excel的功能。刚开始我觉着，导出Excel是一个比较简单的功能，分分钟都能解决的，应该和自己当初做机房收费系统的时候一样，引用一下微软的SDK，再做一下相应的适应性处理就差不多了。后来，当我做出来的时候，测试人员说，自己做的功能，有点奇葩，没见过是这样导出Excel 的——打开Excel表格文件，然后将数据存放进去……
        之后自己反思一下，发现自己的实现方法确实有点跟平常用的不一样，或许当初自己做的导出Excel也只是仅仅限于没有用户的练习方法吧。
后来一个同事告诉我，用NPOI来实现导出Excel。后来自己在网上查了查相关的资料，发现NPOI确实是一个不错的工具包，相比微软的SDK它的优点大致如下：

1、您可以完全免费使用该框架
2、包含了大部分EXCEL的特性(单元格样式、数据格式、公式等等)
3、支持处理的文件格式包括xls, xlsx, docx.
4、采用面向接口的设计架构( 可以查看 NPOI.SS 的命名空间)
5、同时支持文件的导入和导出
6、基于.net 2.0 也支持xlsx 和 docx格式(当然也支持.net 4.0)
7、来自全世界大量成功且真实的测试Cases
8、大量的实例代码
9、你不需要在服务器上安装微软的Office，可以避免版权问题。
10、使用起来比Office PIA的API更加方便，更人性化。
11、导出速度也是不可同日而语的，之前用微软的SDK时，450条，10列左右的数据用时30多秒，而用NPOI时那速度就是一秒不到，用到项目中了根本不会出现系统卡顿的现象。这个优势也是让我特别惊奇的！
接下来我就把自己写的一个Demo贴出来，供大家参考：
首先是定义个接口类，其中存放了包括打开，保存，修改等功能的接口：
<span style="font-size:24px;"><span style="font-size:24px;"><span style="font-size:24px;">public class ExcelOperateInterface
    {
        //获取excel操作类对象
        public static ExcelOperateInterface CreateInterfaceInstance()
        {
            ExcelOperateInterface eoi = null;
            //switch (EnvirMemory.excelOperateTool)
            //{
            //    case ExcelOperateToolType.Excel_Office:
            //        {
            //            eoi = new ExcelOffice();
            //        } break;
            //    case ExcelOperateToolType.Excel_NPOI:
            //        {
             eoi = new ExcelNPOI();
                //    } break;
                //case ExcelOperateToolType.Excel_Defalut:
                //    {
                //        eoi = new ExcelOffice();
                //    } break;
                //default:
                //    {
                //        eoi = new ExcelOffice();
                //    } break;
            //}

            return eoi;

        }

        public virtual void OpenFile(string file,int iSheetIndex) { }

        public virtual void CreateFile(string file, int iSheetIndex) { }

        public virtual void CloseFile(bool bsave) { }

        public virtual string GetCellValue(int iRowIndex, int iColumnIndex) { return ""; }

        public virtual void SetCellValue(string sValue, int iRowIndex, int iColumnIndex) { }

        public virtual string GetDateCellValue(int iRowIndex, int iColumnIndex) { return ""; }

    }
</span></span></span>
接下来是具体的实现类：
<span style="font-size:24px;"><span style="font-size:24px;">public class ExcelNPOI : ExcelOperateInterface
    {

        private string filename;
        private IWorkbook m_iWorkbook;
        private ISheet m_iSheet;

        private void iInitEnvironment()
        {
            filename = "";
            m_iWorkbook = null;
            m_iSheet = null;
        }

        private void SaveFile()
        {
            try
            {
                //NPOI保存文件时，最好是先删除以前的 再新建一个文件
                //FilesManager.DeleteFile(filename);

                //新建文件流
                using (FileStream stream = new FileStream(filename, FileMode.OpenOrCreate, FileAccess.Write))
                {
                    int i = m_iWorkbook.NumberOfSheets;
                    for (int ii = 0; ii < i; ++ii)
                    {
                        ISheet ish = m_iWorkbook.GetSheetAt(ii);
                        ish.DisplayGridlines = true;
                        ish.DisplayRowColHeadings = true;
                    }

                    m_iWorkbook.Write(stream);
                    stream.Flush();
                }
            }
            catch (Exception ex)
            {

            }

        }

        public override void CreateFile(string file,int iSheetIndex)
        {
            try
            {

                IWorkbook workbook = new XSSFWorkbook();

                ISheet sheet = workbook.CreateSheet("sheet0");

                for (int i = 0; i < 450; i++)
                {
                    IRow row = sheet.CreateRow(i);

                    for (int j = 0; j < 50; j++)
                    {
                        ICell cell = row.CreateCell(j);
                        cell.SetCellValue("lcy");
                        
                    }
                }

                using (FileStream fs = File.OpenWrite(file))
                {
                    workbook.Write(fs);
                }

                
            }
            catch (Exception ex)
            {
                
                throw;
            }
        }

        public override void OpenFile(string file, int iSheetIndex)
        {
            try
            {
                iInitEnvironment();
                
                filename = file;
                using (FileStream sfile = new FileStream(file, FileMode.Open, FileAccess.Read))
                {

                    m_iWorkbook = WorkbookFactory.Create(sfile);
                    if (m_iWorkbook != null)
                    {
                        m_iSheet = m_iWorkbook.GetSheetAt(iSheetIndex - 1);
                    }
                }
            }
            catch (Exception ex)
            {

            }

        }

        public override void CloseFile(bool bsave)
        {
            try
            {
                if (bsave)
                {
                    SaveFile();
                }
                iInitEnvironment();
            }
            catch
            {

            }
        }

        public override string GetCellValue(int iRowIndex, int iColumnIndex)
        {
            string sResult = "";
            try
            {
                IRow irow = m_iSheet.GetRow(iRowIndex - 1);
                if (irow != null)
                {
                    ICell icell = irow.GetCell(iColumnIndex - 1);
                    if (icell != null)
                    {
                        sResult = icell.ToString();
                    }
                }
            }
            catch
            {

            }
            return sResult;

        }

        public override string GetDateCellValue(int iRowIndex, int iColumnIndex)
        {
            string sResult = "";
            try
            {
                IRow irow = m_iSheet.GetRow(iRowIndex - 1);
                if (irow != null)
                {
                    ICell icell = irow.GetCell(iColumnIndex - 1);
                    if (icell != null)
                    {
                        DateTime dt;
                        if (DateTime.TryParse(icell.ToString(), out dt))
                        {
                            if (icell.CellType == CellType.Numeric)
                            {
                                sResult = icell.DateCellValue.ToString();
                            }
                            else
                            {
                                sResult = icell.ToString();
                            }
                        }
                    }
                }
            }
            catch
            {

            }
            return sResult;
        }

        public override void SetCellValue(string sValue, int iRowIndex, int iColumnIndex)
        {
            try
            {
                //CreateFile("D:\\excel333.xls", 1);
                IRow irow = m_iSheet.GetRow(iRowIndex - 1);
                if (irow == null)
                {
                    irow = m_iSheet.CreateRow(iRowIndex - 1);
                }

                ICell icell = irow.GetCell(iColumnIndex - 1);
                if (icell == null)
                {
                    icell = irow.CreateCell(iColumnIndex - 1);
                }

                icell.SetCellType(CellType.String);
                if (sValue == "")
                {
                    sValue = "/";
                }
                icell.SetCellValue(sValue);

                

                CloseFile(true);

            }
            catch
            {

            }
        }

    }</span></span>最后就是调用了：方法很简单，我现在只用到了导出的功能，所以只用一个Create方法就可以实现了，打开、保存之类的方法是不需要的：
 
<span style="font-size:24px;"><span style="font-size:24px;"> string file = @"D:\\excel550.xls";
            ExcelOperate.ExcelOperateInterface.CreateInterfaceInstance().CreateFile(file, 1);</span></span>


另外，在项目中需要引用一下NPOI的dll文件，在网上比较好找，而且版本更新挺快的，所以在此就不再提供了。





版权声明：本文为博主原创文章，未经博主允许不得转载。

