面向模式的软件体系结构(3)--管道与过滤器
看了一整晚，不甚理解管道/过滤器。常见的案例Linux命令管道是比较好理解的，但加之混乱的主动/被动的动态概念，就不太好理解了。暂先整理笔记，后面再回顾。


这是看的第2类体系结构，不是有所收获：大致可抽象出一些常见设计的范式
1、体系结构现过程关键点：拆、定义接口/格式、合、出错处理
2、优点关注：重用度
 “考虑到一般变更的设计是优秀系统深化的一个主要助推器”


【概述】
管道和过滤器（Pipes and Filters）为处理数据流的系统提供了一种结构。每个处理步骤封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输。重组过滤器可以建立相关系统族。


【细节】
例子 -- Java语言的解析过程（词法分析，语法分析，语义分析，中间代码生成，中间代码优化）
语境 -- 处理数据流
问题 -- 存在不同的输入数据源；想要达到未来可灵活重新排列步骤，需要提前做好规划；不相连的处理步骤不共享信息etc
解决方案 -- 将系统任务分成几个顺序的处理步骤。
结构 --
1、随后的流水线单元从过滤器中拉出输出数据（被动过滤器）
2、前面的流水线单元把新的输入数据压入过滤器（被动过滤器）
3、最常用的，过滤器以循环方式工作，从流水线中拉出其输入数据并且将其输出数据压入流水线（主动过滤器）


过滤器，职责：获得输入数据；在其输入数据上执行1个函数；供给输出数据
管道表示过滤器之间的连接，职责：转化数据，缓冲数据，同步主动邻居


动态特性 -- 主动被动过滤器之区分（暂搞不懂）
实现 -- 
1、为把系统任务分成一系列处理阶段
2、定义沿每个管道传输的数据格式
3、决定如何实现每个管道连接
4、设计和实现过滤器
5、设计出错处理
6、建立处理流水线


已解决的例子 -- TCP/IP协议
已知使用：Unix流水线任务：程序编译、文档创建
效果 --
优点：不一定需要中间文件、过滤器交换/重组灵活性、重用、快速原型、并行处理效率
不足：共享状态信息昂贵/不灵活、并行处理效率未必高、数据转换额外开销、错误处理




版权声明：本文为博主原创文章，未经博主允许不得转载。

Filter过滤器实现自动登录
Filter介绍
问题:Filter是什么，它能做什么?
    1.从两个方面来解析Filter是什么?
       1.功能  可以帮助我们对请求与响应操作进行过滤。
       2.技术  Sun公司定义的一个接口，javax.servlet.Filter

   2.Filter能完成什么操作?
       常用示例:
       1.通用编码过滤器.
       2.粗粒度的权限控制(url级别)
       3.过滤一些敏感字

Filter创建步骤:
        1.创建一个类实现javax.servlet.Filter接口。
        2.重写Filter接口中三个方法  init  doFilter  destroy.
        3.在web.xml文件中配置Filter

为什么在web.xml文件中配置Filter?
        1.Filter也是一个资源，也要被服务器加载，所以要在web.xml文件中配置.

        2.我们在web.xml文件中配置Filter的另一个目的是用来设置Filter拦截什么资源。


实例：需求：网站登录的时候当用户勾选自动登录选框之后，当用户再来登录，自动登录进网站。
      准备：简单的模拟如下页面：
      
<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title></title>
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	  </head>
  <body>
    <h3>这里是最美网</h3>
	    <c:if test="${ not empty existUser}">	    
	    	<h2>欢迎您：${existUser.nickname }</h2>
	    </c:if>
	    <c:if test="${empty existUser }">
	    	<a href="${pageContext.request.contextPath }/login.jsp">请登录</a>
	    </c:if>
    <h3>新闻标题</h3>
    <h2>大阅兵</h2>
  </body>
</html>

    <%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title></title>
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	  </head>
  <body>
  <form action="${pageContext.request.contextPath }/login" method="post">
	    <p style="color:red">${msg }</p>
	    用户名：<input type="text" id="username" name = "username"><br>
	    密码：<input type="password" id="password" name="password"><br>
	    <input type="checkbox" name="autologin" value="auto_ok">自动登录<br>
	    <button type="submit" value="登录">登录</button>
    </form>
  </body>
</html>

   过滤器：
public class myFilter implements Filter {

	public void destroy() {
		
	}

	public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
		
		/**
		 * 从session中获取existUser
		 * 如果不为空，说明已经登录并且没有关闭浏览器，放行
		 * 如果为空说明没有登录，获取指定名称的cookie
		 *   *如果找不到该cookie说明用户没有开启自动登录功能 ，放行
		 *   *如果不为空，从cookie中拿到用户名和密码从数据库中查询
		 *    *如果查不到 ，则用户名或密码改变了，不处理  放行
		 *    *如果查到了放到session中，放行
		 * 
		 */
		
		//从session中获取用户existUser
		HttpServletRequest req =(HttpServletRequest) request ;
		HttpSession session = req.getSession();
		User existUser  =(User) session.getAttribute("existUser");
		
		if (existUser!=null) {
			
			chain.doFilter(req, response);
			
		}else {
			//为空，说明没有登录
			//获取指定cookie
			//获取保存cookie的数组
		    Cookie []cookies =	req.getCookies();
		    
		    Cookie cookie =MyCookieUtile.findCookieByName(cookies, "autologin");
		    
		    //判断cookie是否为空
		    if (cookie==null) {
		    	
		    	chain.doFilter(req, response);
				
			}else{
				
				//获取cookie的value值
				String value = cookie.getValue();
				String username = value.split(":")[0];
				String password = value.split(":")[1];
				
				//拿到cookie中的用户名和密码去数据库中查
				UserDao dao = new UserDao();
				
				try {
					User user = dao.checkUser(username, password);
					
					if (user==null) {
						chain.doFilter(req, response);
					}else{
						//说明成功，自动登录
						session.setAttribute("existUser",user);
						//放行
						chain.doFilter(req, response);
						
					}
					
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}   		        
		    
		}
		
	}

	public void init(FilterConfig filterConfig) throws ServletException {
		
	}

}
       public class MyCookieUtile {
	
	/**
	 * 通过传入的cookie名称从传入的cookie数组中查找cookie
	 * 如果数组为空，则没有找到返回为null
	 * 如果不为空，找到返回cookie
	 * @param cookies
	 * @param cookiename
	 * @return
	 */	
	public static Cookie findCookieByName(Cookie []cookies,String cookiename){
		
		if (cookies==null) {
			return null;			
		}else{	
			
			for (Cookie cookie : cookies) {
				//获取cookie的名称和传入的名称对比
				if (cookiename.equals(cookie.getName()) ) {
					//相同则返回
					return cookie;					
				}
			}
			return null;
		}				
	}
}


     servlet：
public class LoginServlet extends HttpServlet {

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		
		/**
		 * 接收参数
		 * 根据用户名和密码查询数据库
		 * 如果成功，返回到content页
		 * 如果不成功，返回登录页继续登录
		 */
		//解决中文乱码问题
		request.setCharacterEncoding("UTF-8");		
		String username = request.getParameter("username");
		String password = request.getParameter("password");		
		//调用dao层查询
		UserDao dao = new UserDao();
		try {
			User existUser = dao.checkUser( username, password);
			
			if (existUser==null) {
				request.setAttribute("msg", "用户名或密码错误");
				request.getRequestDispatcher("/login.jsp").forward(request, response);
				
			}else{
				//登录成功
				
				//回写cookie
				String autologin = request.getParameter("autologin");
				
				if ("auto_ok".equals(autologin)) {
					
					String value = username+":"+password;
					Cookie cookie = new Cookie("autologin", value);					
					//设置有效时间
					cookie.setMaxAge(60*60);
					//设置有效路径
					cookie.setPath("/");					
					//回写到客户端
					response.addCookie(cookie);		
					
				}				
				request.getSession().setAttribute("existUser", existUser);				
				
				//重定向到content页面
				response.sendRedirect(request.getContextPath()+"/content.jsp");
				
			}				
			
		} catch (SQLException e) {
			e.printStackTrace();
		}		
	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		this.doGet(request, response);

	}
}




         最后在配置文件中web.xml文件中配置filter。这样当用户勾选了自动登录，关闭浏览器之后，再次访问即可自动登录进网站。
      在我们创建一个Filter时，要重写接口中的方法，有一个方法doFilter,它就是用于拦截操作的方法。在配置Filter时，可以指定拦截什么资源，当浏览器访问这个资源时，Filter的doFilter方法就会执行拦截操作。

      我们如果在Filter中，它的doFilter方法执行了，代表拦截操作开始了，如果想要让其可以继续向下访问资源，就需要通过doFilter方法的第三个参数FilterChain类型，调用它的doFilter方法，完成向下执行操作。

      总结:
   1.在Filter中具体的拦截操作是由doFilter方法执行的。  如果要想访问资源，需要chain.doFilter()放行.
   2.拦截什么资源是由web.xml文件中配置的Filter确定的。






版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        常规功能和模块自定义系统(cfcmms)—001序言
常规功能和模块自定义系统(cfcmms)—001序言




　　在写了《常规功能和模块自定义系统(http://blog.csdn.net/jfok/article/details/24309239)》extjs4版的设计和开发思想的博客，以及《跟我一起学extjs5(http://blog.csdn.net/jfok/article/details/35550713)》中对此自定义系统的部分功能进行了开发讲解之后，现在有必要来对《常规功能和模块自定义系统》（以后简称本系统或自定义系统）的设计、开发来做一个全面的升级和总解了，从现在开始将会写一个新的博客来介绍本系统。
　　在这个新的博客中将会对项目的开发环境、系统项目的建立、自定义系统架构、系统内置的各种功能进行全面的设计和源码的分析讲解。系统的开发工具为eclipse，其中前台为extjs6，后台使用java+spring mvc+hibernate(jdbc)+mysql(mssql)。
　　由于此系统的设计和编码都比较复杂，因此不能象前一个博客介绍开发过程了(这也是《跟我一起学extjs5》这个博客写不下去的原因)，我现在的想法是能把一个阶段的系统代码发布后，对设计和主要部分的前后台代码进行讲解。对于此系统的读者而言能够在一个可以运行的系统下来对系统设计和编码来了解和解读，无疑也是降低了需要了解本系统的人员的门槛。
　　系统的升级和开发是我的即时开发，在完成了一定功能后，会发布一个新的版本并更新博客。如果老版本中有bug或者在新的版本中进行过修改，则老版本不会进行更新。由于本人对extjs和java spring mvc都没有进行过系统的学习，因此在设计和编码时会有不合规范和无理之处，请大家多提意见指正。
　　对本系统有兴趣的读者可以加入QQ群：386100815；对此系统有任何建议或意见的可以跟贴回复，或者发邮件jfok1972@qq.com 和我进行联系。

版权声明：本文为博主原创文章，未经博主允许不得转载。

给Java开发者的Play Framework(2.4)介绍 Part1：Play的优缺点以及适用场景
1. 关于这篇系列这篇系列不是Play框架的Hello World，因为这样的文章网上已经有很多。这篇系列会首先结合实际代码介绍Play的特点以及适用场景，然后会有几篇文章介绍Play与Spring，JPA（Hibernate）的集成，以及一些Play应用的最佳实践， 这期间会在Github上提供一个脚手架项目，方便感兴趣的朋友直接动手尝试。最后会简单分析Play的部分源码，帮助大家理解黑盒子的内部机制。我水平有限，有错误欢迎指出。2. Play介绍Play Framework是一个开源的Web框架，背后商业公司是Typesafe。要介绍Play之前，首先理清Play的两个不同的分支。 Play 1.x 使用Java开发，最新版本是1.3.1，只支持Java项目。从11年开始就进入了维护阶段，新项目一般不考虑使用Play1。 Play 2.x 使用Scala和Java开发，同时支持Java和Scala项目。 这里主要介绍最新的Play2.4 for Java。有一点需要提前说明，虽然Play2主要由Scala开发，但是对于项目中的一般开发人员而言， 使用Play可以完全不懂Scala，具体情况后面会说明。3. 为什么要了解Play现在的Web框架或者类库可以说是浩如烟海。近十年来，在Web开发领域，JVM阵营的占有率一直不高，  数据来源(http://hotframeworks.com/#rankings)这是国外开源项目的数据，相对来说国内Java框架的使用率会高一些。而最近几年，Ruby和Python在国内的开发群体也在不断壮大。 Java框架在Web领域不那么受欢迎，主要原因在于开发速度远落后于其他的开发框架。对于初创公司而言，快速开发出产品投入市场试错比花半年打磨出一款功能性能齐备的 应用更加重要，而对于成熟产品，也需要快速响应频繁的需求变化，这方面动态语言又更胜一筹。所以说到Web后端框架的技术选型，除非技术团队有比较深的JVM背景， 否则会倾向于选择RoR，Django这些框架。JVM阵营在Web领域逐渐落后主要有三个原因：编译的锅，技术栈的锅和语言的锅。大家都知道Java源代码需要编译之后才能运行，直接结果是每次修改源代码都需要重启Web服务器才能看到效果。如果项目比较小类也少，重启时间还勉强能接受。 我以前参与的一个项目，使用的是WebLogic服务器，Spring容器里大概有上千个Bean，重启一次至少得花5分钟，还是优化后的结果。工作时间至少有20%花在重启上了。 虽然现在有JRebel之类的热加载技术，但是国内使用的相对较少。Servlet规范在1997年出现，在当时可以说是很先进的技术，加上Tomcat的横空出世，直接促成了JSP的崛起。然而时过境迁，Servlet风光不再， Web容器存在的必要性也被越来越多的人质疑。原因就在于人为的将应用与容器剥离， 虽然这种做法本意是好的，但是结果就是给开发测试部署带来一系列集成的问题，现在越来越多的项目开始使用内嵌的Jetty或Tomcat就是一个现实的例子。 Servlet还带来一个问题，就是有状态的服务器。一旦使用了Session，服务器就无法享受到水平扩展的好处了，由此不得不采用Session复制或者粘性Session(Sticky Session)的 方案来解决这个问题，无论采取哪种方案都会有性能损耗，并且推高了技术成本。Servlet说到底是Java EE家族的一员，由于Sun的领导（Oracle背锅）， 从Java EE 5开始，Java EE的角色已经从技术创新者转换为跟随者，这些年基本上可以说是跟着开源社区的步子在走的，除了政府大单和跨国企业，你很难再看见它的身影了。 至于语言，其实从JDK8开始，Java已经很好用了。不过从JDK5到JDK8，十年太长，尤其是在Web。之前Java阵营受累于没有成熟的快速开发框架，Spring热衷于提供各种集成方案，可是配置和使用还是相当的麻烦，直到Spring Boot的出现才有改善。 不过近几年出现了一些相当优秀的框架，如Dropwizard，Play，Vert.x。 这篇系列要介绍的Play，通过ClassLoader在源代码修改的时候动态加载类，解决了修改代码需要重启服务器的问题，完全抛弃了Servlet技术栈，基于Netty实现了自己的 请求响应接口（Request/Result），基于Play的应用就是无状态的，另外Play处理请求的方式是无阻塞的（Non-Blocking）。Play2在设计的时候借鉴了RoR的许多优点， 学习Play能够让你了解一些现代化框架的特点，同时能够为你打开异步编程世界的大门。Promise已经被Scala，JavaScript等语言大量使用，Actor模型也已经遍地开花， 这些你都可以直接在Play中使用，或者你想保持原来的编程风格也完全没有问题。4. Play的特性1. Play2的模板引擎Play2的模板是很强大并且容易上手的. 相对于Java领域其他模板引擎(Freemarker, Velocity, JSP, Groovy, etc), 主要有三个特点.1) 简单易上手, 没有JSP里面繁杂的内置对象和指令, 所有功能都通过方法调用完成.2) 主流IDE中都支持Play模板的静态类型检查, 类似JSP. 3) 支持反向路由.举个例子, 一般系统都会有一个固定的页面布局, 比如分出页头页尾。如果用JSP或者Velocity之类的模板， 一般都是通过sitemesh+filter或者在每个页面include来完成布局。使用Play模板, 完成这个功能非常容易。 首先定义一个main页面 main.scala.html：1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
@(title: String = "默认标题")(staticFile: Html = Html(""))(content: Html)

<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
    <meta charset="utf-8" />
    <title>@title</title>


</head>

<body>

@header()  <-- 页头 -->

@navigator() <!-- 导航 -->

@content

<script src="@routes.Assets.versioned("js/jquery-1.11.2.min.js")"></script>

@staticFile
1
@(title: String = "默认标题")(staticFile: Html = Html(""))(content: Html)
这一部分是参数声明，这里声明了三个参数:title标题, 有默认值；staticFile为html代码块, 可以传js等；content为页面内容。1
2
3
@header()  <-- 页头 -->

@navigator() <!-- 导航 -->
这一部分是引用同目录下的另外两个页面：header.scala.html和navigator.scala.html。为什么能这样引用，因为这些页面(main,header,navigator)都会被自动 编译成一个方法（准确地说是一个Scala object，不过这里先当做方法），所以这里相当于方法调用。同样，这个main也会被编译成方法，其他页面可以调用main来完成布局， 例如 login.scala.html1
2
3
4
5
6
7
8
9
@main() {
    <script type="text/javascript">
        FG.user.login();
    </script>
} {
    <div class="login width1200">
    <!-- login -->
    </div>
}
这就是一个简单的登录页面。登录页面调用main页面的方法，第一个参数不传使用默认标题，第二个参数传入登录页面的js代码，第三个参数传入登录页面的html代码。 这样就完成了页面布局, 没有随处可见的include, 也没有暗箱操作的filter, 所有的一切都是方法调用, 是不是很简单清晰？静态类型检查就不说了, 本来Java的一大优点(Que Dian)就是类型检查，所以在Java里用Freemarker或者Velocity这种模板的做法值得商榷。反向路由的意思是, 在Play中, 所有的Controller url都配置在一个routes文件中, 例如1
GET         /register                           @controllers.user.LoginController.registerPage
之后无论是在Controller里还是模板中, 都不用硬编码url。而是使用routes文件。例如在Controller中使用redirect(routes.LoginController.registerPage())就能实现重定向。 而在模板中使用 <a href="@controllers.routes.LoginController.registerPage()">来指向链接。这种风格就是REST里的URI模板。2. 热部署这个上面介绍过，不用重启服务器。3. 内置dev/prod环境，内置部署脚本平常开发的时候使用run启动Play，是跑在dev模式。 Play会定时扫描源码目录进行热更新，并且类都是访问的时候再加载，提高启动速度。 使用start启动项目就运行在prod模式。Play内置dist命令，可以把所有的文件打包成一个zip，解压之后直接运行bin目录下的可执行文件即可启动项目，除了JDK之外无须任何其他外部依赖。 这大大减轻了运维成本，同时也能够很方便的进行持续集成（CI）。4. 使用Play开发的Server大部分能做到Stateless这个之前也说过，Play抛弃了Servlet/JSP里Session等概念, 内置没有提供方法将对象与服务器实例进行绑定(你要使用HashMap存的话Play也没办法)。 推荐的做法是使用外部缓存, 比如Redis, Memcached等。可能有人会觉得没有Session是Play的一个缺点（Play里的Session和Servlet Session不是一回事）, 但是只要你开发过流量大一点的应用, 你就会理解这点。5. 好用的配置库如果你之前开发过Java项目, 肯定写过**.properties或者管理过一大堆的xml。Java内置库对properties文件的处理是很弱的，你不得不自己写一些工具类去进行处理， 而且properties文件还不支持更复杂的语法。Play使用Typesafe Config库，配置文件使用HOCON格式，默认配置文件为application.conf。 你能很容易读取里面的配置, 并且你也可以把自己的配置写在里面。所以项目中基本不需要使用properties或者xml文件了，除了第三方库需要的。6. Play插件RoR框架之所以好用，主要原因之一就是围绕RoR有相当丰富的插件可供选择，很多业务功能甚至都不需要开发就能实现。Play的插件数量当然相对于RoR还是要少一些， 不过你遇到的需求基本都有现成的插件可以使用。比如发邮件, 授权和验证, sitemap生成，第三方登录等等。自己写一个插件也很简单。7. 优秀的测试支持因为Play诞生的时候TDD已经很火热，所以Play对测试的支持非常好。 例如下面的几行代码就能对Controller进行测试。1
2
3
Http.RequestBuilder request = new Http.RequestBuilder().method(POST).uri(routes.LoginController.requestPhoneCode(phone).url());
Result result = route(request);
assertThat(result.status(), is(OK));
Play还内置了对 Selenium WebDriver的支持，可以模拟浏览器进行测试。以下是官方的例子：1
2
3
4
5
6
7
8
9
public class BrowserFunctionalTest extends WithBrowser {

    @Test
    public void runInBrowser() {
        browser.goTo("/");
        assertNotNull(browser.$("title").getText());
    }

}
8. 优秀的REST支持Play2从诞生起就能很容易的支持RESTful风格的架构（因为Play2在设计的时候REST就已经大行其道）， 在Play2中实现RESTful API的示例可以参考Stackoverflow上的这个回答5. 使用Play过程中遇到的坑1. 首次编译速度过慢这是Scala的锅。Scala在编译过程中要经历至少30个步骤， 导致编译速度相当慢。在我的机器上（Core™ i5-4590 CPU @ 3.30GHz，RAM 8GB），编译100多个Scala类大约需要1到2分钟。好在sbt可以增量编译， 即首次编译之后，你再修改代码，编译器只会编译那些它认为需要编译的类，编译几个类的时候速度很快，基本刷新页面就能完成。2. IDE的Scala插件偶尔会误报错误首先得说明，最适合开发Play项目的IDE是IntelliJ IDEA。现在IDEA最新的Scala插件相比之前的版本，已经有很大的提升。 不过偶尔还是会出现误报的情况，这个问题随着新版本插件的发布应该会慢慢解决。3. Scala和Sbt的学习成本较高这可能是初次接触Play的用户遇到的最大障碍。其实对于大多数业务开发人员来说，这不是问题。使用Play for Java版本，项目代码99%都是Java代码， 而Sbt类似于Maven，一旦项目搭建好后不需要过多接触，只要学会几个常用的命令就可以了，例如project root(切换项目), run(启动服务器在dev模式)。 我们团队大部分成员之前都没有接触过Scala和Play，经过一两周的磨合期之后都能很顺利的使用Play进行开发了。4. Play的API变化速度比较快Play的版本号遵循Semantic Versioning，不同主版本的API变化非常大，比如Play1和Play2就是两个不同的框架。 而副版本之间API也会有一些变化，而且不一定完全向后兼容。例如使用Play2.3.x的项目在升级到2.4的时候，需要按照官方提供的迁移手册进行代码修改， 不然是运行不了的。这对于其他背景的开发者来说可能比较容易理解，但是如果是一直习惯于使用Spring MVC或Struts2的话，可能会对这点感到不适。6.总结Play2可以算是一个现代化的框架，吸收了RoR诸多优点，同时又解决了Java开发中的一些痛点，在国外已经被大量使用。参见  数据来源(http://www.infoq.com/research/jvm-web-frameworks)Play和Spring MVC的定位有些相似，但是比Spring MVC提供更丰富的功能，和Web有关的项目都可以使用Play。但是如果要用好Play，对团队有一定的要求。首先，你的团队应该不是墨守成规的团队。大部分人都害怕变化，这是不争的事实。JDK的发展缓慢加上国内的技术氛围，着实让Java开发人员过了几年的舒服日子。 你如果是05年学会了ibatis和Spring，然后这十年去环游世界了，在15年你照样能轻松找到一份待遇还算可以的工作。然而事情已经开始发生变化，不会学习可能会被淘汰。其次，你的团队应该重视工作效率和质量，并且有时间做出改进。国内很多团队信奉的是人海战术。以低薪聘请大量不合格的开发人员来开发业务功能， 而不是注重单人的工作效率和质量，很多项目的加班和延期都源于此。这样的团队就不适合用Play。很难想象每天都要加班去应付工作的团队有时间打磨升级自己的工具和技能。 但是反过来低效率的工具和技能又拖累了自己的工作效率，这是一个恶性循环。最后，团队中需要有人对Scala和Sbt有一定的了解。虽然Play有Java版本可以使用，但是如果不会Scala和Sbt，在搭建环境，使用一些高级功能（如Filter）的时候可能会遇到麻烦。下篇我会介绍Play和Spring还有JPA（Hibernate）的集成，毕竟Spring在大部分Java项目还是主流。有问题和建议欢迎指出。 本文借鉴：http://skaka.me/blog/2015/07/27/play1/

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

eclipse安装subversion(SVN)版本控制插件
陈科肇
查看插件更新站点
网址：http://subclipse.tigris.org/servlets/ProjectProcess?pageID=p4wYuA 
网站截图： 
 
根据自己的eclipse版本，选择需要的更新站点.
使用eclipse集成subservion插件
Help > Install New Software…> 
 
 
 
 
 
等待下载安装插件… 
 
遇到这种情况，点OK继续！ 
 
最后一步，重启eclipse就可以了.
检验安装结果
 
 

插件安装成功！

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[笔记]软件体系结构(2)--分层
分层是大家耳熟能详的体系结构模式，如ISO7层模型、Struts的MVC，Web项目常用的运行视图分层表现层/业务层/数据访问层。
可能概念/原则上比较好理解，网络上比较完整的讲解极少。整理完一遍，对分层的理解更清晰了：在怎样的场景需要考虑分层，分层的具体方式（经常遗漏的重复考虑分层、错误处理），在分层过程中对其优势点的平衡等


【概述】
层的应用背景：有助于构建能够被分解成子任务组的应用系统，其中每个子任务组处于1个特定的抽象层次上
与单块协议相比，分层方法被视为更好的实践，支持分工（效率）、单个部件方案替换


【原则】


层与层之前使用接口交互，保持稳定每层是可替换的，其变化不影响整体系统（即影响限制在层组件内）层，松耦合，高内聚。不同层提供的功能不重叠不跨层访问：自顶向下的消息和控制流称之“请求”（1->N低层请求，推模式），自底向上调用可以称为“通知”（N低层 ->压缩1个更高结构通知）   （为什么？可维护性：可替换性、AOP支持）



【细节】
例子 -- ISO7层模型
语境 -- 一个需要被分解的大系统
问题 -- 系统混合低层高层问题，往往需要一个与其垂直子划分正交的水平构建，使几个独立操作处于同一抽象层

需要平衡的强制条件有：


变更影响可控、接口稳定、组件可替换、低层重用度（在其他系统）、分工效率。“考虑到一般变更的设计是优秀系统深化的一个主要助推器”

解决方案/结构 -- 自顶向下 N~1
动态特性 -- 自顶向下请求，自底向上通知（如设备驱动探测输入）、被满足即止而非要全层访问
实现 -- 

1、为把任务分组成层而定义抽象准则
2、根据抽象准则定义抽象层数
3、给每个层命名并指定其任务
4、指定服务：层间共享模块放松了严格 分层的原则
5、细化分层：重复1~4步骤，进化到自然/稳定分层
6、为每层指定一个接口
7、构建独立层：
8、指定相邻层间的通信：推/拉
9、分离邻接层：
   单路耦合
   自底向上通信，也可使用回调函数且保留自顶向下单路耦合，高层要注册低层的回调函数，从低层发往高层的可能事件集固定时，这种方式特别有效。反应器模式、命令模式
10、设计一种错误处理策略：尽可能在最低层处理错误，至少将相似错误类型归类，并仅传播这些更一般的错误



已解决的例子 -- TCP/IP协议
变体 -- 

松散分层系统：每个层可以使用比它低的所有层的服务。 灵活性/性能的增加是对可维护性丧失的回报。常用于基础结构系统，如Unix操作系统，修改较少，性能更重要
通过继承分层：面向对象，耦合不利可维护性

已知使用--虚拟机（Run Every Where）etc
效果 --

优点：重用、标准化支持、局部依赖性（可测试性）、可替换性/移植、分工/变更效率
不足：更改行为的重叠、降低效率（如可直接从N-1中间其他透传层）、层的正确粒度（层少优势不能发挥，层多有冗余/性能开销）





版权声明：本文为博主原创文章，未经博主允许不得转载。

领域驱动设计学习笔记
        最近学习了领域驱动设计，基本上熟悉了领域驱动的一些基本术语以及一些分析的方法，并结合了实际的开发架构。基本的概念是通过《领域驱动设计：软件核心复杂性应对之道》这本书来进行学习的，里面详细讲解了领域驱动的一些基本概念以及领域驱动的多个设计模式，如果想对领域驱动进行深入学习的话，这本书是一个不错的基础。
        有了基本的概念之后，为了与实际的开发进行结合，我还阅读了《领域驱动设计C# 2008实现问题.设计.解决方案》。这本书作者通过实际的项目来展开讲解的，前面几章根据领域驱动的概念设计了领域驱动的基础框架，并对项目的架构进行了明确的分层。基础的框架里面包括了领域对象的基础类，仓储接口，DI注入实现，工作单元的实现等等。接下来的几章通过对项目的分析、建模分别设计了不同业务的领域对象，并对对象的仓储做了实现。
        以下是我收集的领域驱动设计的书籍http://yunpan.cn/cmf5zztizjstw         访问密码 4111
        如果只是想了解领域驱动设计的话可以浏览：
        基本介绍：http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html
        四色分析法：http://www.infoq.com/cn/articles/xh-four-color-modeling/


        对于领域驱动的扩展学习可以有CQRS架构、DCI架构等等。

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        最全的Spring面试题和答案
1、什么是Spring框架？Spring框架有哪些主要模块？        Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。       Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。更多信息：Spring 框架教程。2、使用Spring框架能带来哪些好处？下面列举了一些使用Spring框架带来的主要好处：          Dependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。          与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。         Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。 要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。         Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。3、什么是控制反转(IOC)？什么是依赖注入？         控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。         控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？在Java中依然注入有以下三种实现方式：构造器注入Setter方法注入接口注入4、请解释下Spring框架中的IoC？           Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。           BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。5、BeanFactory和ApplicationContext有什么区别？         BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。          BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。提供了支持国际化的文本消息统一的资源文件读取方式已在监听器中注册的bean的事件以下是三种较常见的 ApplicationContext 实现方式：1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。


ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);
2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。

ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);
3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。6、Spring有几种配置方式？将Spring配置到应用开发中有以下三种方式：基于XML的配置 基于注解的配置 基于Java的配置7、如何用基于XML配置的方式配置Spring？          在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。           SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）           Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。 <beans>
 
    <!-- JSON Support -->
    <bean name="viewResolver" class="org.springframework.web.servlet.view.BeanNameViewResolver"/>
    <bean name="jsonTemplate" class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
 
    <bean id="restTemplate" class="org.springframework.web.client.RestTemplate"/>
 
</beans>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。<web-app>
  <display-name>Archetype Created Web Application</display-name>
 
  <servlet>
        <servlet-name>spring</servlet-name>
            <servlet-class>
                org.springframework.web.servlet.DispatcherServlet
            </servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
 
    <servlet-mapping>
        <servlet-name>spring</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
 
</web-app>8、如何用基于Java配置的方式配置Spring？            Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与<bean/> 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。最简单的@Configuration 声明类请参考下面的代码： @Configuration
public class AppConfig
{
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}对于上面的@Beans配置文件相同的XML配置文件如下： <beans>
    <bean id="myService" class="com.howtodoinjava.services.MyServiceImpl"/>
</beans>上述配置方式的实例化方式如下：利用AnnotationConfigApplicationContext 类进行实例化 public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}要使用组件组建扫描，仅需用@Configuration进行注解即可： @Configuration
@ComponentScan(basePackages = "com.howtodoinjava")
public class AppConfig  {
    ...
}在上面的例子中，com.acme包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照Sring bean定义进行注册。如果你要在你的web应用开发中选用上述的配置的方式的话，需要用AnnotationConfigWebApplicationContext 类来读取配置文件，可以用来配置Spring的Servlet监听器ContrextLoaderListener或者Spring MVC的DispatcherServlet。 <web-app>
    <!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>
 
    <!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.howtodoinjava.AppConfig</param-value>
    </context-param>
 
    <!-- Bootstrap the root application context as usual using ContextLoaderListener -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
 
    <!-- Declare a Spring MVC DispatcherServlet as usual -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext -->
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.howtodoinjava.web.MvcConfig</param-value>
        </init-param>
    </servlet>
 
    <!-- map all requests for /app/* to the dispatcher servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>9、怎样用注解的方式配置Spring？            Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。             注解装配在Spring中是默认关闭的。所以需要在Spring文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 <beans>
 
   <context:annotation-config/>
   <!-- bean definitions go here -->
 
</beans>在 <context:annotation-config/>标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。下面是几种比较重要的注解类型：@Required：该注解应用于设值方法。@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy。10、请解释Spring Bean的生命周期？            Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。            Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。           初始化之后调用的回调方法。           销毁之前调用的回调方法。          Spring框架提供了以下四种方式来管理bean的生命周期事件：         InitializingBean和DisposableBean回调接口         针对特殊行为的其他Aware接口         Bean配置文件中的Custom init()方法和destroy()方法         @PostConstruct和@PreDestroy注解方式         使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下： <beans>
    <bean id="demoBean" class="com.howtodoinjava.task.DemoBean"
            init-method="customInit" destroy-method="customDestroy"></bean>
</beans>更多内容请参考：Spring生命周期Spring Bean Life Cycle。11、Spring Bean的作用域之间有什么区别？         Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。 全局作用域与Servlet中的session作用域效果相同。更多内容请参考 : Spring Bean Scopes。					           原文地址：http://www.itmmd.com/201504/714.html   该文章由 萌萌的IT人 整理发布,转载须标明出处。 

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

后端分布式系列：分布式存储－HDFS DataNode 设计实现解析
前文分析了 NameNode，本文进一步解析 DataNode 的设计和实现要点。
文件存储
DataNode 正如其名是负责存储文件数据的节点。HDFS 中文件的存储方式是将文件按块（block）切分，默认一个 block 64MB（该大小可配置）。若文件大小超过一个 block 的容量可能会被切分为多个 block，并存储在不同的 DataNode 上。若文件大小小于一个 block 的容量，则文件只有一个 block，实际占用的存储空间为文件大小容量加上一点额外的校验数据。也可以这么说一个文件至少由一个或多个 block 组成，而一个 block 仅属于一个文件。
block 是一个逻辑概念对象，由 DataNode 基于本地文件系统来实现。每个 block 在本地文件系统中由两个文件组成，第一个文件包含文件数据本身，第二个文件则记录 block 的元信息（metadata）如：数据校验和（checksum）。所以每一个 block 对象实际物理对应两个文件，但 DataNode 不会将文件创建在同一个目录下。因为本机文件系统可能不能高效的支持单目录下的大量文件，DataNode 会使用启发式方法决定单个目录下存放多少文件合适并在适当时候创建子目录。
文件数据存储的可靠性依赖多副本保障，对于单一 DataNode 节点而言只需保证自己存储的 block 是完整且无损坏的。DataNode 会主动周期性的运行一个 block 扫描器（scanner）通过比对 checksum 来检查 block 是否损坏。另外还有一种被动的检查方式，就是当读取时检查。
文件操作
HDFS 支持的文件操作包括写入（新增、追加）、读取和删除。HDFS 定义了一种 multi-reader, single-writer 的文件访问语义。而访问标准依然参照大家熟悉的依据 POSIX（Portable Operating System Interface）为单机文件系统定义的 API。

Open 打开文件  
Read/Write 读写文件  
Close 关闭文件

下面我们分别讲述文件操作的设计实现要点。
写文件

写文件流程如图示，在分布式环境下，Client 请求 NameNode 获得一个针对指定文件的租约（lease，本质上是一种分布式锁，详细请自行维基百科下）。只有持有该租约的 Client 可以向该文件写入，以这种机制来确保写文件的 single-writer 的语义。获得写入租约后 NameNode 向 Client 分配一组用于存放文件数据的 DataNodes，若配置的副本数为 3，则会返回 3 个 DataNode。这一组 DataNodes 被组成一条流水线来写入，有效提升写入性能降低写入延迟。Client 将文件组织成一个个 packet 发送给流水线上第一个 DataNode，第一个 DataNode 存储下该 packet 后再转发给第二个 DataNode，依此类推。然后 DataNodes 再按流水线反方向发回确认 packet 给 Client。当所有文件 block 写入完成后，DataNodes 会向 NameNode 报告文件的 block 接收完毕，NameNode 相应去改变文件元数据的状态。
写文件的主体流程如上所述，如果过程中一切正常那么多么简单美好。但实际在分布式环境下，写文件过程涉及 Client、NameNode 和一组 DataNodes，这其中任何一个环节都有可能产生异常。按照分布式设计第一原则：Design for failure，我们需要考这个流程中的所有参与者都有可能出现失败异常的情况。这里先提出这个问题，考虑每种失败异常的场景下，软件设计实现要怎么去处理？本文先不在这里展开论述，后面会专门撰文深入分析。
读文件

读文件流程如图示，Client 首先请求 NameNode 定位文件 block 所在的 DataNodes。然后按顺序请求对应的 DataNodes 读取其上存储的 block。关于读取顺序，HDFS 有一个就近读取的优化策略，DataNodes 的读取排序会按照它们离 Client 的距离来确定。距离的概念主要区分以下几种场景：

距离 0，表示在同一个节点上  
距离 2，表示同一个机架下的不同节点  
距离 4，表示同一个数据中心的不同机架下
距离 8，表示不同的数据中心

删文件
文件删除的处理首先将文件重命名后放进 /trash 目录。文件会在 /trash 目录中存放一段时间（可配置），在时间到期后再自动清理。所以实际上文件删除操作非常轻量级，仅仅是 NameNode 的内存数据结构的变动，真正的物理删除在后续的自动清理时才做。
可见性
在文件写入过程中，HDFS 不保证文件对其他 Client Reader 可见。只有文件的 block 已经写入 DataNode，并报告给了 NameNode 更新到正确的状态才对其他 Reader 可见。简单说，如果一个文件有多个 block，写入总是发生在最后一个 block 上，那么前面的 block 对其他 Reader 是可见的，但最后一个 block 则不可见，这涉及 block 的状态变化，这里先不展开，后面会专门撰文深入分析。
生命周期
DataNode 启动后首先连接到 NameNode 完成握手，握手的目的是验证 DataNode 的软件版本和 namespace ID。namespace ID 是整个 HDFS 集群的唯一标识，如果 DataNode namespace ID 或 软件版本与 NameNode 不匹配，DataNode 将无法加入集群并自动关闭。若是一个全新的 DataNode 启动时没有 namespace ID，则在握手时由 NameNode 分配并加入集群。此外，NameNode 还会分配一个集群全局唯一的 storage ID 给 DataNode 用于唯一标记，之后不再改变。
完成握手后，DataNode 会立刻向 NameNode 发送 block report 信息，block report 就是 DataNode 上存储了哪些文件 block 的列表。之后会定期（默认 1 小时）向 NameNode 报告。此外，DataNode 将定时向 NameNode 发送心跳（默认 3 秒）来报告自身的存活性。一段时间（默认 10 分钟）收不到 DataNode 最近的心跳，NameNode 会认定其死亡，并不会再将 I/O 请求转发到其上。心跳除了用于 DataNode 报告其存活性，NameNode 也通过心跳回复来捎带控制命令要求 DataNode 执行，因为 NameNode 设计上不直接调用 DataNode 其控制命令都是通过心跳回复来执行，所以心跳的默认间隔比较短。
除了 DataNode 的非正常死亡外，DataNode 还可以正常退休，可以通过管理端标记一个 DataNode 进入退休中（decommissioning）状态。处于退休中状态的 DataNode 不再服务于写请求（包括从 Client 写入或从其他 DataNode 复制），但它可以继续服务读请求。进入退休中状态的 DataNode 将被安排将其上存储的所有 block 复制到其他节点，完成这个过程后 NameNode 将其标记为已退休（decommissioned）状态，然后就可以安全下线了。
总结
本文重点描述了，DataNode 生命周期对 HDFS 集群整体的影响以及文件访问操作的流程。对于异常处理部分没有详细展开讲述，这个系列的后续文章还会进一步深入剖析。
参考
[1] Hadoop Documentation. HDFS Architecture. 
[2] Robert Chansler, Hairong Kuang, Sanjay Radia, Konstantin Shvachko, and Suresh Srinivas. The Hadoop Distributed File System 
[3] Tom White. Hadoop: The Definitive Guide. O’Reilly Media(2012-05), pp 94-96



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        常规功能和模块自定义系统(cfcmms)—003概述


常规功能和模块自定义系统(cfcmms)—003概述


一、系统设计思想的来源


      在我多年的编程工作中，所编制多为管理型软件。从最初的企业工资管理软件、劳动工资统计软件，到后来的财务软件、税务软件、反避税查询系统、工程合同资金管理、票据管理等，主要功能都是数据列表展示、录入修改删除、处理、输出、查询、图表这几大块。
       我使用过的编程语言也比较多，从90年代最初的foxbase、foxpro，后来使用过c，c++，vfp，delphi，smartGwt+java，到现在的用js+java开发B/S管理软件。个人觉得各个语言之间就是语法有差异，有各自开发库，用熟了之后都没啥区别。在用过这些语言开发了多年的管理型软件后，我想有必要对开发过程做一下总结，能够设计一套快速开发的系统，对常规功能和模块定义能够简单、快捷的完成。
        相信各位程序员都有这样的心情，同样的东西不想再做第二次。一个模块你设计了一个界面，有列表、增、删、查、改，搜索、导航、导入导出、打印、图表、附件、权限设计等功能，第二个模块如果你还要全部重新做一次，恐怕是没这个心情了。如果有几十上百个模块，那一个个做更是会让人崩溃的事情。另外在系统上线运行后如有微调，例如模块、字段要改个名字，如果还要在后台修改，重新步署、重启服务那也是一件很不方便的事。基于我的编程积累和以上原因，我于2007年开始就着手设计开发一个能够自定义的系统，经过好几年的开发、总结、几次改版重构后，现在使用extjs6
 + java + spring mvc + hibernate + jdbc + mysql(mssql) 的架构开发出可以在前台进行系统配置的管理系统。
       本人一直在小软件公司里工作，与外界的交流也不多，不清楚其他公司的先进架构，只是根据自己的开发经验和客户的需求设计这套系统的各个方面。由于系统都是我设计开发的，在选择前后台的开发语言时就只能着重于易用性和开发的快速性。前台一开始选用的extjs3，在开发了第一个版本之后由于我对js不熟，改用了smartGwt+java的架构。后来由于smartGwt调试起来太慢，在extjs4发布后前台又改回了extjs。后台的选择上一开始使用的是java+ssh，之后学习了spring
 mvc觉得配置更少，用标注语言开发更方便，现在的系统即是基于这几个开发语言之下。


 二、系统的最终目标


        借助于java script语言解释执行的灵活性和java的反射机制，系统的最终目标是可以在浏览器中对系统的各个模块和各种功能进行配置。配置的结果一般只要刷新网页，即可立即生效。（业务逻辑除外）。在作为查询系统使用时，可以一套代码适用于各个不同的系统，只要换个数据库即可换至新的查询系统。


三、系统的适用性

1.本系统适用于模块为树状结构、分层清晰的中小型的管理型软件；
2.可以适用于绝大多数系统作为免代码的综合查询系统；
3.可以快速的为新系统制作原型产品；




对本系统有兴趣的读者可以加入QQ群：386100815；对此系统有任何建议或意见的可以跟贴回复，或者发邮件jfok1972@qq.com 和我进行联系。




版权声明：本文为博主原创文章，未经博主允许不得转载。

SpringMVC入门案例（3）
一个简单的入门实例教程该实例的源码和实例中的jar源码：http://download.csdn.net/detail/swingpyzf/5348563所需要的jar:  http://download.csdn.net/detail/swingpyzf/5348531另外一篇关于SpringMVC 文件上传，多文件上传：http://blog.csdn.net/swingpyzf/article/details/20230865简单注解配置的实例：一、创建项目：1、建立新的动态web项目：2、为项目命名为：SpringMVC_013、添加tomcat运行时环境\依赖库  如果是MyEclipse的话创建web项目时就不需要此步骤右键项目，点击Build Path->Add Librares:添加完后会多出tomcat 的 Servlet包4、最后添加Spring及SpringMVC所需要的jar，我添加以下jar到项目中二、配置文件：1、首先在web.xml中配置一个DispatcherServlet，并通过<servlet-mapping>指定需要拦截的url。 下面xml中配置一个拦截.html为后缀的url.[html] view plaincopyprint?<!-- 配置Spring MVC DispatcherServlet -->      <servlet>          <servlet-name>MVC</servlet-name>          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>          <!-- 初始化参数 -->          <init-param>              <!-- 加载SpringMVC的xml到 spring的上下文容器中 -->              <param-name>contextConfigLocation</param-name>              <param-value>                  /WEB-INF/classes/mvc*.*              </param-value>          </init-param>          <load-on-startup>1</load-on-startup>      </servlet>        <!-- 配置DispatcherServlet所需要拦截的 url -->      <servlet-mapping>          <servlet-name>MVC</servlet-name>          <url-pattern>*.html</url-pattern>      </servlet-mapping>  <!-- 配置Spring MVC DispatcherServlet -->
	<servlet>
		<servlet-name>MVC</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<!-- 初始化参数 -->
		<init-param>
			<!-- 加载SpringMVC的xml到 spring的上下文容器中 -->
			<param-name>contextConfigLocation</param-name>
			<param-value>
				/WEB-INF/classes/mvc*.*
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<!-- 配置DispatcherServlet所需要拦截的 url -->
	<servlet-mapping>
		<servlet-name>MVC</servlet-name>
		<url-pattern>*.html</url-pattern>
	</servlet-mapping> 先配置一个servlet 然后 加载SpringMVC的xml文件到Spring的上下文中。然后配置servlet-mapping，servlet-name为刚刚的servlet中的配置的name，然后指定要拦截的url为*.html 2、配置Spring的上下文监听器，并且指定Spring的xml配置文件的路径。[html] view plaincopyprint?<!-- 监听spring上下文容器 -->  <listener>      <listener-class>          org.springframework.web.context.ContextLoaderListener      </listener-class>  </listener>    <!-- 加载spring的xml配置文件到 spring的上下文容器中 -->  <context-param>      <param-name>contextConfigLocation</param-name>      <param-value>classpath:root-context.xml</param-value>  </context-param>  	<!-- 监听spring上下文容器 -->
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>
	
	<!-- 加载spring的xml配置文件到 spring的上下文容器中 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:root-context.xml</param-value>
	</context-param> 这里指定的路径classpath为 项目编译后的classes文件中。 最终web.xml文件内容：[html] view plaincopyprint?<?xml version="1.0" encoding="UTF-8"?>  <web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee       http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd">      <display-name></display-name>                  <!-- 监听spring上下文容器 -->      <listener>          <listener-class>              org.springframework.web.context.ContextLoaderListener          </listener-class>      </listener>            <!-- 加载spring的xml配置文件到 spring的上下文容器中 -->      <context-param>          <param-name>contextConfigLocation</param-name>          <param-value>classpath:root-context.xml</param-value>      </context-param>            <!-- 配置Spring MVC DispatcherServlet -->      <servlet>          <servlet-name>MVC</servlet-name>          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>          <!-- 初始化参数 -->          <init-param>              <!-- 加载SpringMVC的xml到 spring的上下文容器中 -->              <param-name>contextConfigLocation</param-name>              <param-value>                  /WEB-INF/classes/mvc*.*              </param-value>          </init-param>          <load-on-startup>1</load-on-startup>      </servlet>        <!-- 配置DispatcherServlet所需要拦截的 url -->      <servlet-mapping>          <servlet-name>MVC</servlet-name>          <url-pattern>*.html</url-pattern>      </servlet-mapping>        <welcome-file-list>          <welcome-file>index.html</welcome-file>      </welcome-file-list>      </web-app>  <?xml version="1.0" encoding="UTF-8"?>
<web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
	http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd">
	<display-name></display-name>
	
	
	<!-- 监听spring上下文容器 -->
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>
	
	<!-- 加载spring的xml配置文件到 spring的上下文容器中 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:root-context.xml</param-value>
	</context-param>
	
	<!-- 配置Spring MVC DispatcherServlet -->
	<servlet>
		<servlet-name>MVC</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<!-- 初始化参数 -->
		<init-param>
			<!-- 加载SpringMVC的xml到 spring的上下文容器中 -->
			<param-name>contextConfigLocation</param-name>
			<param-value>
				/WEB-INF/classes/mvc*.*
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<!-- 配置DispatcherServlet所需要拦截的 url -->
	<servlet-mapping>
		<servlet-name>MVC</servlet-name>
		<url-pattern>*.html</url-pattern>
	</servlet-mapping>

	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
	</welcome-file-list>


</web-app>
3、创建SpringMVC所需要的xml文件和applicationContext的xml文件，这里由于第一步中配置的servlet中init-param所需要加载的格式为：mvc*.* 就是去寻找为mvc开头的文件所以创建SpringMVC的xml文件时必须要有mvc开头，我命名为：mvc-context.xml，并且按照context-param中的配置，将applicationContext文件命名为：root-context.xml；4、配置mvc-context.xml:首先通过import标签 导入root-context.xml,然后通过component-scan标签扫描指定包名，让该包下的所有java类的spring注解生效然后配置SpringMVC的视图渲染解析器，让其前缀为/page/ 后缀为.jsp  这样能够SpringMVC 所需要渲染的路径能够在/page/返回值.jsp中寻找。[html] view plaincopyprint?<!-- 加载Spring的全局配置文件 -->      <beans:import resource="root-context.xml" />            <!-- SpringMVC配置 -->            <!-- 通过component-scan 让Spring扫描org.swinglife.controller下的所有的类，让Spring的代码注解生效 -->      <context:component-scan base-package="org.swinglife.controller"></context:component-scan>            <!-- 配置SpringMVC的视图渲染器， 让其前缀为:/page/ 后缀为.jsp  将视图渲染到/page/<method返回值>.jsp中 -->      <beans:bean          class="org.springframework.web.servlet.view.InternalResourceViewResolver"          p:prefix="/page/" p:suffix=".jsp">          </beans:bean>  <!-- 加载Spring的全局配置文件 -->
	<beans:import resource="root-context.xml" />
	
	<!-- SpringMVC配置 -->
	
	<!-- 通过component-scan 让Spring扫描org.swinglife.controller下的所有的类，让Spring的代码注解生效 -->
	<context:component-scan base-package="org.swinglife.controller"></context:component-scan>
	
	<!-- 配置SpringMVC的视图渲染器， 让其前缀为:/page/ 后缀为.jsp  将视图渲染到/page/<method返回值>.jsp中 -->
	<beans:bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"
		p:prefix="/page/" p:suffix=".jsp">
		</beans:bean>最后mvc-context.xml和root-context.xml为：mav-context.xml:[html] view plaincopyprint?<?xml version="1.0" encoding="UTF-8"?>  <beans:beans xmlns="http://www.springframework.org/schema/mvc"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:beans="http://www.springframework.org/schema/beans"      xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop"      xmlns:context="http://www.springframework.org/schema/context"      xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd                  http://www.springframework.org/schema/aop                  http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">      <!-- 加载Spring的全局配置文件 -->      <beans:import resource="root-context.xml" />            <!-- SpringMVC配置 -->            <!-- 通过component-scan 让Spring扫描org.swinglife.controller下的所有的类，让Spring的代码注解生效 -->      <context:component-scan base-package="org.swinglife.controller"></context:component-scan>            <!-- 配置SpringMVC的视图渲染器， 让其前缀为:/ 后缀为.jsp  将视图渲染到/page/<method返回值>.jsp中 -->      <beans:bean          class="org.springframework.web.servlet.view.InternalResourceViewResolver"          p:prefix="/page/" p:suffix=".jsp">          </beans:bean>      </beans:beans>  <?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
				http://www.springframework.org/schema/aop
				http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
	<!-- 加载Spring的全局配置文件 -->
	<beans:import resource="root-context.xml" />
	
	<!-- SpringMVC配置 -->
	
	<!-- 通过component-scan 让Spring扫描org.swinglife.controller下的所有的类，让Spring的代码注解生效 -->
	<context:component-scan base-package="org.swinglife.controller"></context:component-scan>
	
	<!-- 配置SpringMVC的视图渲染器， 让其前缀为:/ 后缀为.jsp  将视图渲染到/page/<method返回值>.jsp中 -->
	<beans:bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"
		p:prefix="/page/" p:suffix=".jsp">
		</beans:bean>


</beans:beans>
 root-context.xml: [html] view plaincopyprint?<?xml version="1.0" encoding="UTF-8"?>  <beans xmlns="http://www.springframework.org/schema/beans"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"      xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd                  http://www.springframework.org/schema/context                   http://www.springframework.org/schema/context/spring-context-3.2.xsd                  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd">      <!-- Root Context: defines shared resources visible to all other web components -->           </beans>  <?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
				http://www.springframework.org/schema/context
				 http://www.springframework.org/schema/context/spring-context-3.2.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd">
	<!-- Root Context: defines shared resources visible to all other web components -->

	 
</beans>
三、编写Controller1、创建org.swinglife.controller的package，用来存放Controller类，接着新建HomeController.java，用来编写首页的Controller2、使用注解@Controller将HomeController类定义为一个Controller,并且在方法中通过@RequestMapping(“value”)来指定所需要访问的路径或者方法名。 SpringMVC可以通过一个@Controller注解将一个POJO转化为处理请求的控制器，通过@RequestMapping为控制器指定哪些需要的请求。[java] view plaincopyprint?@Controller   public class HomeController {            /***      * 首页 返回至/page/home.jsp页面      * @return      */      @RequestMapping("index")      public ModelAndView index(){          //创建模型跟视图，用于渲染页面。并且指定要返回的页面为home页面          ModelAndView mav = new ModelAndView("home");          return mav;      }  }  @Controller 
public class HomeController {
	
	/***
	 * 首页 返回至/page/home.jsp页面
	 * @return
	 */
	@RequestMapping("index")
	public ModelAndView index(){
		//创建模型跟视图，用于渲染页面。并且指定要返回的页面为home页面
		ModelAndView mav = new ModelAndView("home");
		return mav;
	}
}
方法中定义了ModelAndView对象，通过该对象指定所需要渲染的视图为home最后返回ModelAndView 将页面渲染到home.jsp中。 3、最后在WebContent目录中 创建/page/home.jsp使SpringMVC能够寻找并渲染该页面视图。[html] view plaincopyprint?<%@ page language="java" contentType="text/html; charset=GB18030"      pageEncoding="GB18030"%>  <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">  <html>  <head>  <meta http-equiv="Content-Type" content="text/html; charset=GB18030">  <title>home</title>  </head>  <body>  <h2>spring mvc 实例</h2>      </body>  </html>  <%@ page language="java" contentType="text/html; charset=GB18030"
    pageEncoding="GB18030"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GB18030">
<title>home</title>
</head>
<body>
<h2>spring mvc 实例</h2>


</body>
</html>现在一个完整的SpringMVC的模式已经搭建完成了，可以运行项目来进行测试。 四、编写参数的提交与传递：1、编写一个新的UserController类来假定用户登录，将username,password提交到Controller中进行处理，并且登陆成功后将username,password传递到成功的页面。创建UserController.java创建/page/succ.jsp页面 作为用户成功登陆页面UserController中的代码：[java] view plaincopyprint?@Controller  public class UserController {        /***      * 用户登陆      * <p>注解配置，只允许POST提交到该方法      * @param username      * @param password      * @return      */      @RequestMapping(value="login",method=RequestMethod.POST)      public ModelAndView login(String username,String password){          //验证传递过来的参数是否正确，否则返回到登陆页面。          if(this.checkParams(new String[]{username,password})){              //指定要返回的页面为succ.jsp              ModelAndView mav = new ModelAndView("succ");              //将参数返回给页面              mav.addObject("username",username);              mav.addObject("password", password);              return mav;          }          return new ModelAndView("home");      }            /***      * 验证参数是否为空      * @param params      * @return      */      private boolean checkParams(String[] params){          for(String param:params){              if(param==""||param==null||param.isEmpty()){                  return false;              }          }          return true;      }  @Controller
public class UserController {

	/***
	 * 用户登陆
	 * <p>注解配置，只允许POST提交到该方法
	 * @param username
	 * @param password
	 * @return
	 */
	@RequestMapping(value="login",method=RequestMethod.POST)
	public ModelAndView login(String username,String password){
		//验证传递过来的参数是否正确，否则返回到登陆页面。
		if(this.checkParams(new String[]{username,password})){
			//指定要返回的页面为succ.jsp
			ModelAndView mav = new ModelAndView("succ");
			//将参数返回给页面
			mav.addObject("username",username);
			mav.addObject("password", password);
			return mav;
		}
		return new ModelAndView("home");
	}
	
	/***
	 * 验证参数是否为空
	 * @param params
	 * @return
	 */
	private boolean checkParams(String[] params){
		for(String param:params){
			if(param==""||param==null||param.isEmpty()){
				return false;
			}
		}
		return true;
	}首先指定@Controller，然后指定@RequestMapping为login方法； 需要注意的是这次@RequestMapping中指定了页面方法模式必须为POST模式否则将无法访问。其次value参数指定访问路径。并且在login方法中设定带参，参数为表单中的name属性。然后通过ModelAndView的 addObject方法将参数加入到request中，这样则能够在返回的页面中显示这些参数。在此之外还有其他将参数传递到页面中的方式为：[java] view plaincopyprint?/***  * 另一种参数传递的形式  * 通过request来处理请求过来的参数。  * @param username  * @param password  * @param request  * @return  */  @RequestMapping(value="login",method=RequestMethod.POST)  public ModelAndView login(String username,String password,HttpServletRequest request){      request.setAttribute("username", username);      request.setAttribute("password", password);      return new ModelAndView("succ");  }  	/***
	 * 另一种参数传递的形式
	 * 通过request来处理请求过来的参数。
	 * @param username
	 * @param password
	 * @param request
	 * @return
	 */
	@RequestMapping(value="login",method=RequestMethod.POST)
	public ModelAndView login(String username,String password,HttpServletRequest request){
		request.setAttribute("username", username);
		request.setAttribute("password", password);
		return new ModelAndView("succ");
	}以上这种方式则是直接通过将参数加入到request中来使用。 2、编写succ.jsp页面跟表单页面：succ.jsp:[html] view plaincopyprint?<body>  <h2>登陆</h2>     username:${username }  <p>  password:${password }     </body>  <body>
<h2>登陆</h2>
 
username:${username }
<p>
password:${password }
 
</body>form: [html] view plaincopyprint?<form action="login.html" method="post">      username:<input type="text" name="username" />      <p>      password:<input type="password" name="password"/>      <p>      <input type="submit" value="submit" />  </form>  <form action="login.html" method="post">
	username:<input type="text" name="username" />
	<p>
	password:<input type="password" name="password"/>
	<p>
	<input type="submit" value="submit" />
</form> 3、最后运行项目来进行测试：  OK都完成了。以上就是一个比较简单的SpringMVC的示例搭建了。在给出的源码中，还有另一中直接用String当做返回值来指定显示页面的方法。本文借鉴：http://blog.csdn.net/u011225629/article/details/48002333

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

[置顶]
        笨鸟先飞之Java---缠缠绵绵的注解和注释
     在平时的编程中注释一直与我们为伴，但是在Java编程中我们会经常性的使用注解。一字之差，也不知是否会有“失之毫厘差以千里”之说？？
     一起来看：

 一、注解：
    ❁ 首先来看在ITOO Java中使用的注解：
	@Stateless(name = "SystemStudentIdModuleValueBean")
	@Remote(SystemStudentIdModuleValueBean.class)
	@TransactionManagement(TransactionManagementType.CONTAINER)
	@TransactionAttribute(TransactionAttributeType.REQUIRED)
	public class SystemStudentIdModuleValueBeanImpl extends BaseBeanImpl implements
			SystemStudentIdModuleValueBean {
			
			}
    从本质上说，注解就是一种类型！它可以定义、使用，以及包含有自己的属性、方法。
    先来对注解这个东西进行一下宏观的了解：
    1）.注解这个东西主要是给编译器看的，比如最常见的@override表示这个方法重写了父类中的方法；


    2）.大家共同认可的，就可以使用一个公式来代替，以节省代码：这就是注解


    3）.注解为我们在代码中添加信息提供了一种形式化的方法，使我们可以在之后的某个时刻方便的使用这些数据（通过解析注解来使用这些数据），常见的作用有如下几种：
     ○ 生成文档：这是最常见的，也是Java最早提供的注解，常用的有@see,@param,@return等
     ○ 跟踪代码依赖性，实现替代配置文件的功能。现在的框架基本上都使用了这种配置里减少配置文件的数量。

     ○ 
在编译时进行格式检查。如@override放在方法钱前，如果这个方法并不是覆盖的超类的方法，则会在编译时被检查出来。


   ❁ 其次，当我们定义了注解，难道直接使用？？肯定不是的呗！！    
    在使用反射之前必须使用import java.lang.reflect.* 来导入和反射相关的类。
    α要得到某一个类或接口的注解信息，可以使用如下代码：
        Annotation annotation = TestAnnotation.class.getAnnotation(MyAnnotation.class);
    β要得到全部的注解信息可使用如下语句：
        Annotation[] annotations = TestAnnotation.class.getAnnotations();或
        Annotation[] annotations = TestAnnotation.class.getDeclaredAnnotations();  
    γ要得到其它成员的注解，可先得到这个成员，然后再得到相应的注解。如得到myMethod的注解。
        Method method = TestAnnotation.class.getMethod("myMethod", null);
        Annotation annotation = method.getAnnotation(MyAnnotation.class);


PS：要想使用反射得到注解信息，这个注解必须使用@Retention(RetentionPolicy.RUNTIME)进行注解。


   所以注解是编程给我们提供的一个桥梁，帮我们摆脱繁杂无序的代码，使我们无限靠近“面向对象”这座城堡，让我们走向编程世界的更远方：
        

二、注释
    对于每日相伴的注释我们应该很熟悉：主要是帮助我们理解某些代码的或者用来记录一些信息（比如开发时间、开发人员），在myEclipse中：
    • 单行注释：Ctrl+/   : 在行代码上打上双斜线。
    • 多行注释：/**/
    • .jsp页面的注释：<-- 这是要被注释掉的内容 -->
    • .properties页面注释：将键盘切换到英文状态，使用#（或者！）进行注释

   所以注释就像是编程向我们伸出的援助之手，随时向我们提供帮助：
        

三、总结：
    注解和注释虽然一字之差，却带着我们走入两个不同的世界，一个帮助我们理解（不会对编译器或者程序造成影响），一个通过对配置文件的封装帮助我们高效开发：
    注解是J2SE5.0提供的一项非常有趣的功能。它不但有趣，而且还非常有用。如即将出台的EJB3.0规范就是借助于注解实现的。这样将使EJB3.0在实现起来更简单，更人性化。还有Hibernate3.0除了使用传统的方法生成hibernate映射外，也可以使用注解来生成hibernate映射。总之，如果能将注解灵活应用到程序中，将会使你的程序更加简洁和强大。

   到这里，"形似"的注解和注释就说完了，如果有什么问题，欢迎大家踊跃拍砖。也期待大家的交流和意见哦：
          
   


版权声明：本文为博主原创文章，未经博主允许不得转载。

给Java开发者的Play Framework(2.4)介绍 Part2：使用Play，Spring，JPA进行开发
1. 介绍这篇文章会使用Play，Spring，JPA（hibernate）开发一个简单的CRUD功能，主要是为了介绍如何使用Play进行开发。2. 界面截图  很简单的新增和查询功能。我们来看看代码如何实现。3. 代码实现1. Model代码架构使用典型的MVC，分层为Controller-Service-Dao-Model。首先来看Model。1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
//省略了部分字段
@Table(name = "test_object")
@Entity
public class TestObject implements EntityClass<Integer>, OperableData {

    private Integer id;

    private String orderNo;

    /**
     * 状态
     */
    private TestObjectStatus status;

    //...
    /**
     * 下单时间
     */
    private DateTime buyTime;
    //...

    private List<TestObjectItem> testObjectItemList = new ArrayList<>(0);


    @OneToMany(fetch = FetchType.LAZY, mappedBy = "testObject")
    public List<TestObjectItem> getTestObjectItemList() {
        return testObjectItemList;
    }

    public void setTestObjectItemList(List<TestObjectItem> testObjectItemList) {
        this.testObjectItemList = testObjectItemList;
    }

    @GeneratedValue(strategy = GenerationType.AUTO)
    @Id
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }


    @Column(name = "status")
    @Enumerated(EnumType.STRING)
    public TestObjectStatus getStatus() {
        return status;
    }

    public void setStatus(TestObjectStatus status) {
        this.status = status;
    }


    @Column(name = "buy_time")
    @Type(type="org.jadira.usertype.dateandtime.joda.PersistentDateTime")
    public DateTime getBuyTime() {
        return buyTime;
    }

    public void setBuyTime(DateTime buyTime) {
        this.buyTime = buyTime;
    }


}
很普通的Entity，使用JPA注解，唯一需要注意的是在处理枚举类型和Joda DateTime类型的时候用到了不同的类型注解。2. Dao1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
//省略了部分方法
@Repository
public class GeneralDao {

    @PersistenceContext
    EntityManager em;

    public GeneralDao(){}

    public GeneralDao(EntityManager em) {this.em = em;}

    public EntityManager getEm() {
        return em;
    }

    /**
     * 使用jpql进行查询
     * @param ql jpql
     * @param page 分页对象,可选
     * @param queryParams 查询参数
     * @param <T>
     * @return
     */
    public <T> List<T> query(String ql, Optional<Page<T>> page, Map<String, Object> queryParams) {
      //...
    }

    /**
     * 使用jpql进行数据更新操作
     * @param ql
     * @param queryParams
     * @return
     */
    public int update(String ql, Map<String, Object> queryParams) {
      //...
    }

    public <T extends EntityClass<Integer>> void persist(T t) {
        setOperableDataIfNecessary(t, t.getId() == null || t.getId() == 0);
        em.persist(t);
    }

    public <T extends EntityClass<Integer>> T merge(T t) {
        setOperableDataIfNecessary(t, t.getId() == null || t.getId() == 0);
        return em.merge(t);
    }

    public <T extends EntityClass<Integer>> boolean remove(T t) {
        if(t != null) {
            em.remove(t);
            return true;
        } else {
            return false;
        }
    }

    public <T extends EntityClass<Integer>> boolean removeById(Class<T> type, Integer id) {
        T t = get(type, id);
        return remove(t);
    }

    public <T extends EntityClass<Integer>> T get(Class<T> type, Integer id) {
        return em.find(type, id);
    }

    public void flush() {
        em.flush();
    }

    public <T extends EntityClass<Integer>> void refresh(T t) {
        em.refresh(t);
    }

    public <T extends EntityClass<Integer>> void detach(T t) {
        em.detach(t);
    }
}
这里使用的是通用Dao，一般的增删改查操作可以直接通过该Dao完成。可以看出这个Dao只是对JPA的EntityManager一个简单封装， 大部分操作还是委派给EntityManager完成。代码中也可以直接取得EntityManager进行操作。 3. Service1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
//省略了部分方法
@Service
public class TestObjectService {

    @PersistenceContext
    EntityManager em;

    @Autowired
    GeneralDao generalDao;

    @Transactional(readOnly = true)
    public List<TestObject> findByKey(Optional<Page<TestObject>> page, Optional<String> orderNo, Optional<TestObjectStatus> status,
            Optional<DateTime> createTimeStart, Optional<DateTime> createTimeEnd) {

        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<TestObject> cq = cb.createQuery(TestObject.class);
        Root<TestObject> order = cq.from(TestObject.class);

        List<Predicate> predicateList = new ArrayList<>();
        if(orderNo.isPresent()) {
            predicateList.add(cb.equal(order.get("orderNo"), orderNo.get()));
        }
        if(createTimeStart.isPresent()) {
            predicateList.add(cb.greaterThanOrEqualTo(order.get("createTime"), createTimeStart.get()));
        }
        if(createTimeEnd.isPresent()) {
            predicateList.add(cb.lessThanOrEqualTo(order.get("createTime"), createTimeEnd.get()));
        }
        if(status.isPresent()) {
            predicateList.add(cb.equal(order.get("status"), status.get()));
        }

        cq.select(order).where(predicateList.toArray(new Predicate[predicateList.size()])).orderBy(cb.desc(order.get("updateTime")));

        TypedQuery<TestObject> query = em.createQuery(cq);

        if(page.isPresent()) {
            CriteriaQuery<Long> countCq = cb.createQuery(Long.class);
            countCq.select(cb.count(countCq.from(TestObject.class))).where(predicateList.toArray(new Predicate[predicateList.size()]));
            Long count = em.createQuery(countCq).getSingleResult();
            page.get().setTotalCount(count.intValue());

            query.setFirstResult(page.get().getStart());
            query.setMaxResults(page.get().getLimit());
        }

        List<TestObject> results = query.getResultList();

        if(page.isPresent()) {
            page.get().setResult(results);
        }

        return results;
    }


    @Transactional(readOnly = true)
    public TestObject get(Integer id) {
        return generalDao.get(TestObject.class, id);
    }

}
findByKey方法是一个查询方法，这里使用的是JPA的Criteria查询。Service类没有使用接口，只有实现类。Service就是一个Spring管理的Bean， 事务边界在Service层。4. Controller1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
//省略了部分方法
@org.springframework.stereotype.Controller
public class TestObjectController extends Controller {

    @Autowired
    private TestObjectService testObjectService;


    public Result list(String status, String orderNo) {

        List<TestObject> testObjectList = testObjectService.findByKey(of(PageFactory.getPage(request())), ofNullable(orderNo),
                ofNullable(status).map(TestObjectStatus::valueOf), empty(), empty());

        return ok(list.render(testObjectList));
    }

    public Result addPage() {
        return ok(add.render(Form.form(TestObject.class)));
    }

    public Result updatePage(Integer id) {
        return ok(update.render(Form.form(TestObject.class).fill(testObjectService.get(id))));
    }

    //...
}
Controller继承play.mvc.Controller。和SpringMVC一样，在Play中，Controller就是一系列Action的集合。例如我开发用户有关的功能， 那么我就建一个UserController，然后把用户的CRUD方法都放在UserController里，每个方法都有自己的路由规则。这里我们先来看list方法：1
2
3
4
5
6
7
public Result list(String status, String orderNo) {

    List<TestObject> testObjectList = testObjectService.findByKey(of(PageFactory.getPage(request())), ofNullable(orderNo),
            ofNullable(status).map(TestObjectStatus::valueOf), empty(), empty());

    return ok(list.render(testObjectList));
}
这里list的功能是查询出所有满足条件的测试对象（TestObject对象）。首先来看参数，这里声明了两个查询参数status和orderNo，用来匹配Http请求QueryString中的参数， 这和SpringMVC中声明了RequestParam(“status”)的参数类似。注意有一点区别，这里的status和orderNo不能捕捉通过Http Body提交的参数，只能匹配QueryString中的参数。Controller中调用service方法来完成查询，然后将结果返回。方法的返回值声明是play.mvc.Result接口，你可以理解Result的实现类只需要包含两个值： ResponseHeader和ResponseBody。对于ResponseHeader的设置，这里调用父类的ok方法设置返回的Http状态码为200，对应的还有created 201, notFound 404等方法。 ok方法参数需要传入的就是ResponseBody，参数类型声明为play.twirl.api.Content特质（Scala中的特质类似于Java的接口），你基本上永远不需要去手动构造这个特质的实现， 而是使用Play提供的模板。这里我在views.html.test目录下有一个list.scala.html模板，这个模板文件会被IDE自动编译成views.html.test.list类，类里面有一个render方法来完成模板的渲染， render方法返回值就是play.twirl.api.Content的子类。所以我在这里可以直接调用list.render(testObjectList)方法来完成模板的渲染。好了，现在来对照SpringMVC，如果是用SpringMVC的话，这个方法应该是这样的1
2
3
4
5
6
7
8
9
10
11
@RequestMapping(value = "/test/objects", method = RequestMethod.GET)
@ResponseStatus(HttpStatus.OK)  //可省略
public String list(String status, String orderNo, Model model) {

    List<TestObject> testObjectList = testObjectService.findByKey(of(PageFactory.getPage(request())), ofNullable(orderNo),
            ofNullable(status).map(TestObjectStatus::valueOf), empty(), empty());

    model.addAttribute("testObjectList", testObjectList);

    return "views/html/test/list";
}
细心的你可能已经发现了，Play的版本与SpringMVC的对照，少了一个路由的信息，那么在Play中怎么配置路由呢，请看下节5. routes文件（路由）在Play中，所有的路由信息都是统一放在一个文件里，即conf/routes文件。上面的list方法路由在routes中对应如下：1
GET         /test/objects                     @controllers.test.TestObjectController.list(status ?= null, orderNo ?= null)
最左边的GET声明的是Http Method，在Play中每个路由都要明确写出对应的Http Method，中间是路由的URI，最右边是映射的Controller方法。参数status ?= null代表参数是可选的， 如果请求参数中没有status则默认值是null。routes文件的一大好处是在写映射Controller方法的时候IDE能帮助自动补全，并且编译器在编译的时候也能校验声明的参数个数与类型是否一致， 这能有效的帮助开发者减少错误。路由也配好了，剩下的工作就是模板的编写。6. 模板list.scala.html1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
@(testObjects: List[ordercenter.models.TestObject])

@import common.utils.DateUtils._

@main()() {

    <div class="breadcrumbs" id="breadcrumbs">
        <script type="text/javascript">
        try{ace.settings.check('breadcrumbs' , 'fixed')}catch(e){}
        </script>

        <ul class="breadcrumb">
            <li>
                <i class="icon-home home-icon"></i>测试对象管理
            </li>
            <li class="active"><a href="@controllers.test.routes.TestObjectController.list()">测试对象查询</a></li>
        </ul><!-- .breadcrumb -->
    </div>

    <div class="page-content">
        <div class="page-header">
            <h1>
                测试对象管理
                <small>
                    <i class="icon-double-angle-right"></i>测试对象查询
                </small>
            </h1>
        </div>
            <!-- /.page-header -->

        <div class="row">
            <div class="col-xs-12">
                    <!-- PAGE CONTENT BEGINS -->

                <div class="row">
                    <div class="col-xs-12">
                        <div class="table-responsive">
                            <table id="sample-table-1" class="table table-striped table-bordered table-hover">
                                <thead>
                                    <tr>
                                        <th>状态</th>
                                        <th>买家</th>
                                        <th class="hidden-480">金额</th>
                                        <th>下单时间</th>
                                        <th></th>
                                    </tr>
                                </thead>

                                <tbody>
                                @for(testObject <- testObjects) {
                                    <tr>
                                        <td>@testObject.getStatus.value</td>
                                        <td>@testObject.getBuyerId</td>
                                        <td>@testObject.getActualFee</td>
                                        <td>@printDateTime(testObject.getCreateTime) </td>
                                        <td>
                                            <div class="visible-md visible-lg hidden-sm hidden-xs btn-group">
                                                <button class="btn btn-xs btn-info" onclick="location.href='@controllers.test.routes.TestObjectController.updatePage(testObject.getId)'">
                                                    <i class="icon-edit bigger-120"></i>
                                                </button>
                                                <button class="btn btn-xs btn-success" onclick="location.href='@controllers.test.routes.TestObjectController.list()'">
                                                    <i class="icon-info bigger-120"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                }

                                </tbody>
                            </table>
                        </div><!-- /.table-responsive -->
                    </div><!-- /span -->
                </div>
            </div>
        </div>
    </div>
}
Play的模板引擎是Twirl，关于这个引擎的介绍可以参考上一篇文章。@(testObjects: List[ordercenter.models.TestObject])是参数声明，写Play模板的时候，建议参数都通过这种声明的形式传入，而不是使用页面隐藏对象。 因为编译器能够自动帮我们校验类型和个数，重构起来也会更方便。下面一行@import common.utils.DateUtils._引入了定义好的一个工具类， 下面的@printDateTime(testObject.getCreateTime)用来格式化显示时间。@main()() {...}的形式是调用main模板完成渲染，main模板前两个参数可以省略，第三个参数需要传入html代码。在Scala中，方法调用既可以用小括号，比如println("ok")， 也可以用大括号println{"ok"}。而这里第三个参数使用的是大括号。@for(testObject <- testObjects){}是循环的写法，这里循环testObjects，取出每一条记录用来显示。onclick="location.href='@controllers.test.routes.TestObjectController.list()'"绑定了onClick事件，用户在点击的时候会跳转到测试对象的编辑页面。 这里没有硬编码uri，而是使用routes反向路由的写法。之所以能这样写，是因为IDE在编译的时候会根据routes文件自动生成一个routes对象， 对象里面的方法对应的就是我们配置好的controller方法映射。这里写的@controllers.test.routes.TestObjectController.list()在模板渲染的时候就会被替换成/test/objects这个URI。4. 总结这一篇主要介绍了Play在整合Spring和JPA之后是如何进行开发的。可以看出，开发Play应用与开发SSH应用没有太大区别，只是Controller和模板的写法有所不同， 但是我们能很快享受到Play的便利：简单易用的模板，修改代码无需重启服务器，不需要配置外部服务器，etc。随着业务和技术的扩展，使用Play的项目更容易整合其他服务。 例如整合监控工具StatsD+Graphite+Grafana+Kamon，Docker化，服务化。这篇文章我没有介绍如何启动应用，因为这需要一些开发环境的准备，以及了解SBT的基本用法。这些内容我会在下一篇博客介绍。这篇文章相关的代码已经提交到Github， 项目地址。 这个项目整合了Play，Spring，JPA，数据存储使用MySQL和Redis，使用Bootstrap作为页面框架，可以作为脚手架项目给有兴趣的朋友进行研究。除此之外，感兴趣的朋友还可以下载Typesafe Reactive Platform进行学习。这这上面有很多关于Play，Akka的项目模板， 并且你可以通过浏览器查看编辑这些代码，还可以直接运行。另外要进一步学习可以读这本书，网上有电子版的。下篇我会介绍如何搭建开发环境，以及如何调试应用。掌握了之后，你会发现开发和调试过程原来还能这样直观和简单!

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

Spring之Aop与Ioc
用Spring用了这么久，也该找个时间总结总结，这里我并没有把Aop和Ioc分开讲。
首先概述一下Spring，Spring是一款设计非常好的解耦框架，无侵入性，可以整合其它很多框架，比如常用的Struts,Hibernate,Mybatis或者Ibatis等，由此可以解决企业开发的复杂性，其核心的两个东西，就是AOP和IOC。
Spring包含了7个模块，每个模块可以独立存在

每个模块的作用如下（这里参考的其它博客。原文地址：http://www.ibm.com/developerworks/cn/java/wa-spring1，感谢作者）：


核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。

IOC：

概念：控制反转，因为这个名字晦涩难懂，后来Martine Fowler将其取名为依赖注入(DI)，它不是什么技术，只是一种思想
IOC容器：可以实现控制反转功能的容器

原理：为何叫控制反转，因为我们在javaee中要使用某个对象的方法，通常是要new一下这个对象，可以理解为正转，就是普通处理的方式，但是这样就会出现大量依赖的对象，比如A依赖B，A依赖C，出现了大量的耦合，那么控制反转为什么叫反转，因为它把对象交给了Spring容器处理，并非在程序里面声明，把对象交给外部容器处理，内部程序只需调用，其实就是使用了java的反射技术，在程序运行时动态创建，调用对象，在Spring运行时，和其配置文件动态创建，调用对象，也就是Spring容器初始化，装配及管理Bean对象，这些Bean对象再由IOC容器进行控制管理


从图中可以看出控制反转IOC实际包括DL和DI，即依赖查找和依赖注入两种方式，前者是获取依赖关系，后者是注入依赖关系。


关于控制反转IOC，我这里还想罗嗦两句：控制反转这个概念确实不是很好理解，而且这个概念很泛，首先最基本的我要说明的是IOC并不是Spring特有的，在其它框架中也有这个概念，依赖注入在类似框架中只是一种思想，依赖注入实现的方式主要有三种：接口注入，设值注入，构造注入。IOC主要出现过两次较大的争议：一是IOC的概念很模糊抽象，容易让人迷惑，而是作者引入依赖注入代替控制反转后，使用构造注入还是设值注入好，当然作者的观点是可以先使用构造注入，如果出现问题再换成设值注入，个人觉得不如一开始就采用后者（仅个人观点），作者Martine
 Fowler提出使用XML的方式配置比编码的方式配置好，这也符合OO思想，事实也的确这样。
注入方式（依赖注入）在Spring中的具体实现：
            1.接口注入：这种方法由于具有一定的侵入性，而且实际开发中也不常见，暂且不予研究
            2.设值注入：
            3.构造注入：

（时间比较晚了，先暂时放一放）


AOP：
概念：面向切面编程（Aspect-Oriented Programming的缩写），它也是一种编程的思想，AOP将系统分成了核心业务逻辑和横向的通用逻辑，也就是所谓的方面，这些方面像持久化管理，事务管理，安全管理，日志管理和调试管理等都属于系统通用的逻辑，这样我们通过配置Spring的配置文件就可以重复利用这些通用的逻辑，避免了代码的冗余，配置了该切面的方法后，Spring运行到该方法时会被Spring拦截执行
让我们从定义一些重要的AOP概念开始。
　　— 方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的Advisor或拦截器实现。
　　— 连接点（Joinpoint）：程序执行过程中明确的点，如方法的调用或特定的异常被抛出。
　　— 通知（Advice）：在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。
　　— 切入点（Pointcut）：指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点，例如，使用正则表达式。
　　— 引入（Introduction）：添加方法或字段到被通知的类。Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现IsModified接口，来简化缓存。
　　— 目标对象（Target Object）：包含连接点的对象，也被称作被通知或被代理对象。
　　— AOP代理（AOP Proxy）：AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。
　　— 编织（Weaving）：组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。

原理：AOP的实现主要通过代理来实现的，这里分为两种：（http://my.oschina.net/chape/blog/136453，来自该博文分享，感谢博文作者）
           1.静态代理：针对每个具体的类编写代理类；针对一个接口编写一个代理类

            2.动态代理：针对一个方面编写一个Invocation Handler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类
动态代理：
不用写代理类，虚拟机根据真实对象实现的接口产生一个类，通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。 
     

             1、产生动态代理的类:


                            java.lang.refect.Proxy


             2、装备必须实现InvocationHandler接口实现invoke方法


AOP和IOC是Spring中非常重要的两大核心，如果弄清了它们，基本上就弄清了Spring，而且IOC和AOP是互相补充的，以此解决业务上的复杂问题
好了，暂时Ok吧，时间比较晚了，具体的例子只有抽空再写了








版权声明：本文为博主原创文章，未经博主允许不得转载。

JAVA操作Excel文件

JAVA EXCEL API:是一开放源码项目，通过它Java开发人员可以读取Excel文件的内容、创建新的Excel文件、更新已经存在的Excel文件。使用该API非Windows操作系统也可以通过纯Java应用来处理Excel数据表。因为它是使用Java编写的，所以我们在Web应用中可以通过JSP、Servlet来调用API实现对Excel数据表的访问。

下载：

Java Excel API的jar包可以通过以下URL获得：

http://sourceforge.net/projects/jexcelapi/files/jexcelapi/2.6.6/jexcelapi_2_6_6.zip/download

（包括所有版本）：http://sourceforge.net/projects/jexcelapi/files/

直接下载地址（迅雷上新建任务即可）：

http://nchc.dl.sourceforge.net/project/jexcelapi/jexcelapi/2.6.6/jexcelapi_2_6_6.zip 

示例1：读取本地Excel文件F:\红楼人物.xls

1.       新建Excel文件F:\红楼人物.xls

内容如下：



2.       Java通过jexcelapi包操作excel文件：




//in ExcelOperater   
  
import java.io.File;   
  
import java.io.FileInputStream;   
  
import java.io.InputStream;   
  
    
  
import jxl.Cell;   
  
import jxl.CellType;   
  
import jxl.Sheet;   
  
import jxl.Workbook;   
  
import jxl.write.Label;   
  
    
  
public class ExcelOperater    
  
{   
  
    public static void main(String[] args)    
  
    {   
  
        jxl.Workbook readwb = null;   
  
        try    
  
        {   
  
            //构建Workbook对象, 只读Workbook对象   
  
            //直接从本地文件创建Workbook   
  
            InputStream instream = new FileInputStream("F:/红楼人物.xls");   
  
            readwb = Workbook.getWorkbook(instream);   
  
    
  
            //Sheet的下标是从0开始   
  
            //获取第一张Sheet表   
  
            Sheet readsheet = readwb.getSheet(0);   
  
            //获取Sheet表中所包含的总列数   
  
            int rsColumns = readsheet.getColumns();   
  
            //获取Sheet表中所包含的总行数   
  
            int rsRows = readsheet.getRows();   
  
            //获取指定单元格的对象引用   
  
            for (int i = 0; i < rsRows; i++)   
  
            {   
  
                for (int j = 0; j < rsColumns; j++)   
  
                {   
  
                    Cell cell = readsheet.getCell(j, i);   
  
                    System.out.print(cell.getContents() + " ");   
  
                }   
  
                System.out.println();   
  
            }   
  
               
  
            //利用已经创建的Excel工作薄,创建新的可写入的Excel工作薄   
  
            jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(new File(   
  
                    "F:/红楼人物1.xls"), readwb);   
  
            //读取第一张工作表   
  
            jxl.write.WritableSheet ws = wwb.getSheet(0);   
  
            //获得第一个单元格对象   
  
            jxl.write.WritableCell wc = ws.getWritableCell(0, 0);   
  
            //判断单元格的类型, 做出相应的转化   
  
            if (wc.getType() == CellType.LABEL)    
  
            {   
  
                Label l = (Label) wc;   
  
                l.setString("新姓名");   
  
            }   
  
            //写入Excel对象   
  
            wwb.write();   
  
            wwb.close();   
  
        } catch (Exception e) {   
  
            e.printStackTrace();   
  
        } finally {   
  
            readwb.close();   
  
        }   
  
}   
  
}   
  



3.       结果：

①     控制台输出：

人物 等级 大观园位置 金陵十二钗

林黛玉 小姐 潇湘馆 正册

妙玉 世外 栊翠庵 正册

晴雯 丫鬟 怡红院 副册

香菱 妾 蘅芜苑 又副册

②     创建文件F:\红楼人物1.xls



4.       程序解析：

所引用的包：

①     Workbook对象，需要jxl.Workbook包；

②     InputStream、FileInputStream对象：需要java.io.FileInputStream和java.io.InputStream包。

③     Sheet对象：jxl.Sheet包；注意excel中sheet表单的行列从0开始计数。

④     Cell对象：jxl.Cell包；对单元进行处理

⑤     Label：选择jxl.write.label包

⑥     WritableWorkbook、WritableSheet、WritableCelll对象

实例二：3个功能-----从excel文件F:\红楼人物.xls读取数据；生成新的excel文件F:\红楼人物2.xls；修改原excel一个单元并输出为F:\红楼人物3.xls。

原始文件：F:\红楼人物.xls



运行结果：

①     控制台输出：

人物 等级 大观园位置 金陵十二钗

林黛玉 小姐 潇湘馆 正册

妙玉 世外 栊翠庵 正册

晴雯 丫鬟 怡红院 副册

香菱 妾 蘅芜苑 又副册

②     写入输出Excel文件：F:\红楼人物2.xls



③     修改输出文件 F:\红楼人物3.xls （加修饰后输出）


示例程序：




//in ExcelHandle   
  
import jxl.*;   
  
import jxl.format.UnderlineStyle;   
  
import jxl.write.*;   
  
import jxl.write.Number;   
  
import jxl.write.Boolean;   
  
import jxl.Cell;   
  
    
  
import java.io.*;   
  
    
  
public class ExcelHandle   
  
{   
  
    public ExcelHandle()   
  
    {   
  
    }   
  
    /***读取Excel*/  
  
    public static void readExcel(String filePath)   
  
    {   
  
        try  
  
        {   
  
            InputStream is = new FileInputStream(filePath);   
  
            Workbook rwb = Workbook.getWorkbook(is);   
  
            //这里有两种方法获取sheet表:名字和下标（从0开始）   
  
            //Sheet st = rwb.getSheet("original");   
  
            Sheet st = rwb.getSheet(0);   
  
            /**  
 
            //获得第一行第一列单元的值  
 
            Cell c00 = st.getCell(0,0);  
 
            //通用的获取cell值的方式,返回字符串  
 
            String strc00 = c00.getContents();  
 
            //获得cell具体类型值的方式  
 
            if(c00.getType() == CellType.LABEL)  
 
            {  
 
                LabelCell labelc00 = (LabelCell)c00;  
 
                strc00 = labelc00.getString();  
 
            }  
 
            //输出  
 
            System.out.println(strc00);*/  
  
            //Sheet的下标是从0开始   
  
            //获取第一张Sheet表   
  
            Sheet rst = rwb.getSheet(0);   
  
            //获取Sheet表中所包含的总列数   
  
            int rsColumns = rst.getColumns();   
  
            //获取Sheet表中所包含的总行数   
  
            int rsRows = rst.getRows();   
  
            //获取指定单元格的对象引用   
  
            for (int i = 0; i < rsRows; i++)   
  
            {   
  
                for (int j = 0; j < rsColumns; j++)   
  
                {   
  
                    Cell cell = rst.getCell(j, i);   
  
                    System.out.print(cell.getContents() + " ");   
  
                }   
  
                System.out.println();   
  
            }             
  
            //关闭   
  
            rwb.close();   
  
        }   
  
        catch(Exception e)   
  
        {   
  
            e.printStackTrace();   
  
        }   
  
    }   
  
    /**输出Excel*/  
  
    public static void writeExcel(OutputStream os)   
  
    {   
  
        try  
  
        {   
  
   /** 只能通过API提供的 工厂方法来创建Workbook，而不能使用WritableWorkbook的构造函数，因为类WritableWorkbook的构造函数为 protected类型：方法一：直接从目标文件中读取 WritableWorkbook wwb = Workbook.createWorkbook(new File(targetfile));方法 二：如下实例所示 将WritableWorkbook直接写入到输出流*/  
  
            WritableWorkbook wwb = Workbook.createWorkbook(os);   
  
            //创建Excel工作表 指定名称和位置   
  
            WritableSheet ws = wwb.createSheet("Test Sheet 1",0);   
  
            /**************往工作表中添加数据*****************/  
  
            //1.添加Label对象   
  
            Label label = new Label(0,0,"测试");   
  
            ws.addCell(label);   
  
            //添加带有字型Formatting对象   
  
            WritableFont wf = new WritableFont(WritableFont.TIMES,18,WritableFont.BOLD,true);   
  
            WritableCellFormat wcf = new WritableCellFormat(wf);   
  
            Label labelcf = new Label(1,0,"this is a label test",wcf);   
  
            ws.addCell(labelcf);   
  
            //添加带有字体颜色的Formatting对象   
  
            WritableFont wfc = new WritableFont(WritableFont.ARIAL,10,WritableFont.NO_BOLD,false,   
  
                    UnderlineStyle.NO_UNDERLINE,jxl.format.Colour.DARK_YELLOW);   
  
            WritableCellFormat wcfFC = new WritableCellFormat(wfc);   
  
            Label labelCF = new Label(1,0,"Ok",wcfFC);   
  
            ws.addCell(labelCF);   
  
              
  
            //2.添加Number对象   
  
            Number labelN = new Number(0,1,3.1415926);   
  
            ws.addCell(labelN);   
  
            //添加带有formatting的Number对象   
  
            NumberFormat nf = new NumberFormat("#.##");   
  
            WritableCellFormat wcfN = new WritableCellFormat(nf);   
  
            Number labelNF = new jxl.write.Number(1,1,3.1415926,wcfN);   
  
            ws.addCell(labelNF);   
  
               
  
            //3.添加Boolean对象   
  
            Boolean labelB = new jxl.write.Boolean(0,2,true);   
  
            ws.addCell(labelB);   
  
            Boolean labelB1 = new jxl.write.Boolean(1,2,false);   
  
            ws.addCell(labelB1);             
  
            //4.添加DateTime对象   
  
            jxl.write.DateTime labelDT = new jxl.write.DateTime(0,3,new java.util.Date());   
  
            ws.addCell(labelDT);   
  
              
  
            //5.添加带有formatting的DateFormat对象   
  
            DateFormat df = new DateFormat("dd MM yyyy hh:mm:ss");   
  
            WritableCellFormat wcfDF = new WritableCellFormat(df);   
  
            DateTime labelDTF = new DateTime(1,3,new java.util.Date(),wcfDF);   
  
            ws.addCell(labelDTF);   
  
            //6.添加图片对象,jxl只支持png格式图片   
  
            File image = new File("f:\\1.png");   
  
            WritableImage wimage = new WritableImage(0,4,6,17,image);   
  
            ws.addImage(wimage);   
  
            //7.写入工作表   
  
            wwb.write();   
  
            wwb.close();   
  
        }   
  
        catch(Exception e)   
  
        {   
  
            e.printStackTrace();   
  
        }   
  
    }   
  
    /** 将file1拷贝后,进行修改并创建输出对象file2  
 
     * 单元格原有的格式化修饰不能去掉，但仍可将新的单元格修饰加上去，  
 
     * 以使单元格的内容以不同的形式表现  
 
     */  
  
    public static void modifyExcel(File file1,File file2)   
  
    {   
  
        try  
  
        {   
  
            Workbook rwb = Workbook.getWorkbook(file1);   
  
            WritableWorkbook wwb = Workbook.createWorkbook(file2,rwb);//copy   
  
            WritableFont wfc = new WritableFont(WritableFont.ARIAL,10,WritableFont.NO_BOLD,false,   
  
                    UnderlineStyle.NO_UNDERLINE,jxl.format.Colour.BLUE);   
  
            WritableCellFormat wcfFC = new WritableCellFormat(wfc);    
  
            WritableSheet ws = wwb.getSheet(0);   
  
            WritableCell wc = ws.getWritableCell(0,0);   
  
            //判断单元格的类型,做出相应的转换   
  
            if(wc.getType() == CellType.LABEL)   
  
            {   
  
                Label labelCF =new Label(0,0,"人物（新）",wcfFC);   
  
                ws.addCell(labelCF);     
  
              //Label label = (Label)wc;   
  
              //label.setString("被修改");   
  
            }   
  
          wwb.write();   
  
            wwb.close();   
  
            rwb.close();   
  
        }   
  
        catch(Exception e)   
  
        {   
  
            e.printStackTrace();   
  
        }   
  
    }   
  
    //测试   
  
    public static void main(String args[])   
  
    {   
  
        try  
  
        {   
  
            //读EXCEL   
  
        ExcelHandle.readExcel("F:/红楼人物.xls");   
  
            //输出EXCEL   
  
        File filewrite=new File("F:/红楼人物2.xls");   
  
        filewrite.createNewFile();   
  
        OutputStream os=new FileOutputStream(filewrite);   
  
        ExcelHandle.writeExcel(os);   
  
            //修改EXCEL   
  
        ExcelHandle.modifyExcel(new File("F:/红楼人物.xls"), new File("F:/红楼人物3.xls"));   
  
        }   
  
        catch(Exception e)   
  
        {   
  
        e.printStackTrace();   
  
        }   
  
    }   
  
}   
  



附：

调用流程如下:
1.打开工作文件Workbook，在此之前先用java的io流创建或者读取文件
2.打开工作表Sheet
3.读行，然后读列。注意，行和列是从零开始的
4.取得数据进行操作
 

来自网络à读取Excel数据表

第一步：创建Workbook（术语：工作薄）

2种方法：Workbook，就可以通过它来访问Excel Sheet（术语：工作表）：




//从输入流创建Workbook读取excel数据表   
  
    InputStream is = new FileInputStream(sourcefile);   
  
    jxl.Workbook workbook = Workbook.getWorkbook(is);   
  
//直接从本地文件（.xls）创建Workbook   
  
Workbook workbook = Workbook.getWorkbook(new File(excelfile));   



一旦创建了

第二步：访问sheet。

2种方法：通过sheet的名称；或者通过下标，下标从0开始。




//获取第一张Sheet表   
  
Sheet rs = workbook.getSheet(0);   
  
一旦得到了Sheet，就可以通过它来访问Excel Cell（术语：单元格）。   
  
第三步：访问单元格cell   
  
//获取第一行，第一列的值   
  
Cell c00 = rs.getCell(0, 0);   
  
String strc00 = c00.getContents();   
  
//获取第一行，第二列的值   
  
Cell c10 = rs.getCell(1, 0);   
  
String strc10 = c10.getContents();   
  
//获取第二行，第二列的值   
  
Cell c11 = rs.getCell(1, 1);   
  
String strc11 = c11.getContents();   
  
    
  
System.out.println("Cell(0, 0)" + " value : " + strc00 + "; type : " + c00.getType());   
  
System.out.println("Cell(1, 0)" + " value : " + strc10 + "; type : " + c10.getType());   
  
System.out.println("Cell(1, 1)" + " value : " + strc11 + "; type : " + c11.getType());   
  



第四步：操作数据

如果仅仅是取得Cell的 值，我们可以方便地通过getContents()方法，它可以将任何类型的Cell值都作为一个字符串返回。如果有需要知道Cell内容的确切类型，API也提供了一系列的方法：




String strc00 = null;   
  
double strc10 = 0.00;   
  
Date strc11 = null;   
  
Cell c00 = rs.getCell(0, 0);   
  
Cell c10 = rs.getCell(1, 0);   
  
Cell c11 = rs.getCell(1, 1);   
  
if(c00.getType() == CellType.LABEL)   
  
{   
  
LabelCell labelc00 = (LabelCell)c00;   
  
strc00 = labelc00.getString();   
  
}   
  
if(c10.getType() == CellType.NUMBER)   
  
{   
  
NmberCell numc10 = (NumberCell)c10;   
  
strc10 = numc10.getValue();   
  
}   
  
if(c11.getType() == CellType.DATE)   
  
{   
  
DateCell datec11 = (DateCell)c11;   
  
strc11 = datec11.getDate();   
  
}   
  
    
  
System.out.println("Cell(0, 0)" + " value : " + strc00 + "; type : " + c00.getType());   
  
System.out.println("Cell(1, 0)" + " value : " + strc10 + "; type : " + c10.getType());   
  
System.out.println("Cell(1, 1)" + " value : " + strc11 + "; type : " + c11.getType());   
  



在得到
单机千万并发连接实战
　　c10k，c100k，c1000k等问题大家都已经司空见惯，那么10m（千万）并发连接呢？今天就来一起挑战一下吧。
准备机器
　　10m连接，大家的个人电脑肯定无法满足要求，如果不是在大公司任职，弄个实际的物理机对大家是个奢望。那么怎么办？我也面临同样问题。 
　　现在的云计算这么发达，还可以按小时计费，一小时的费用也就几元，那就试试云计算产品吧。小编先是在阿里云上测试，但阿里云的按需付费主机配置不高，费了不少时间，最终只跑到了3m个连接。阿里云的不行，是主机的配置问题还是程序的问题呢？为了得到最终的结论，我尝试了其他的云产品，最终ucloud的云主机给了我兴奋的答案。
　　首先创建ucloud主机 
ucloud主机（一共需要两台，一台作为服务器，一台作为客户端）： 
. 选择主机管理的创建主机 
. 系统选择ubuntu14.4 64bit （小编的测试程序是c++11，需要高版本的g++） 
. 机型标准版 
. 网络增强一定要选择开启 （千万连接是网络IO密集型，网络当然要强大型） 
. cpu 16核 内存64G 数据盘0 
. 下一步中的网络类型选择基础网络即可，创建主机之后，需要购买弹性ip，并且绑定到主机 
. 价格：小编实验时，上述的配置，一台仅需7.2元一小时，两台不到15元
　　做实验的时候，大家记得要眼疾手快哦，一小时十几元，获得了自己想要的结果就赶紧释放主机哈
调整参数
　　10m并发连接对系统是个挑战，需要调整相关的参数
sysctl -w fs.file-max=10485760 #系统允许的文件描述符数量10m
sysctl -w net.ipv4.tcp_rmem=1024 #每个tcp连接的读取缓冲区1k，一个连接1k，10m只需要10G
sysctl -w net.ipv4.tcp_wmem=1024 #每个tcp连接的写入缓冲区1k
echo '* soft nofile 1048576' >> /etc/security/limits.conf #用户单进程的最大文件数，用户登录时生效
echo '* hard nofile 1048576' >> /etc/security/limits.conf #用户单进程的最大文件数，用户登录时生效
ulimit -n 1048576 #用户单进程的最大文件数 当前会话生效
部署测试程序
　　下面可以开始部署我们的测试程序了
apt-get update
apt-get install -y screen git make g++ nload iptraf

git clone https://github.com/yedf/handy
cd handy
make -j4
cd examples
运行测试程序
　　选取一台主机S作为服务器，运行命令
python 1kw-svr.py 1000 1000 10
　　该脚本会以job方式启动十个进程，每个进程监听100个端口，一共监听了1000-2000的1000个端口，每个服务器简单的echo收到的数据 
　　选取另一台主机C作为客户端，在screen里运行命令（需要填写S的内网ip）
python 1kw-cli.py ip-S 1000 2000 10000000 1000 300
　　该脚本会以job启动1000个进程，每个进程会产生1w（10000000/1000）个连接，连接S的1000-2000端口。最后的300表示每300秒往服务器发送一个数据包 
　　每个进程都会几秒输出一条信息，1000个进程会造成刷屏，表面刷屏数据导致的外网网络流量可能影响ssh，一般观察一小段时间后，小编就detach screen了 
　　10m连接的创建需要花费不少时间的，如果疯狂的创建连接，导致的结果是很多连接都不成功，于是脚本每启动一个进程，睡眠0.5s，让连接的创建速度保持在2w/s，因此大约需要10分钟的时间才能把所有连接都创建成功。
观察结果
　　然后，10m连接的建立就不需要更多的步骤啦，使用命令
watch ss -s
　　我们就可以开始观察连接的创建进度啦，看着连接渐渐的往上走，超过10w，100w是不是很有成就感。
更多内容
　　还可以通过iptraf，nload等工具来查看系统的网络情况
　　系统在上面千万连接运行中，并没有多少的负载，当然啦，一部分负载跑到底层的hypervisor去了
　　小编实验的机器上内存占用大约40G，平均一个连接前后一共用了4k，不多不多
　　网络发包数量是3w/s，收包数量是6w/s，这是为什么呢？熟悉tcp协议的同学可能已经知道了，C发送数据，S回应数据并带了ACK，C需要对S发送的数据ACK
　　大家还可以跑两个发送大量数据的程序，例如 
./1kw-cli ip-S 1000 2000 10000 0 1024 
　　这个程序会打开10000个连接，不断的与S进行数据收发，数据大小为1024Byte 
　　小编这里启动了两个这样的程序，网卡流量立刻就超过了500MBit/s
　　写到这里，顺便给出我测是的ucloud主机的性能参数吧： 
　　网卡流量最多可以到1.2GBit/s，并非所有时间都到了这么高，并不稳定，一般在800M-1.2G之间波动 
　　tcp收包发包的最高qps是12w/s，多了就上不去了

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[Golang] 从零开始写Socket Server（4）：将运行参数放入配置文件（XML/YAML）
    为了将我们写好的Server发布到服务器上，就要将我们的代码进行build打包，这样如果以后想要修改一些代码的话，需要重新给代码进行编译打包并上传到服务器上。 

   显然，这么做过于繁琐。。。因此常见的做法都是将Server运行中可能会频繁变更的变量、数值写入配置文件中，这样直接让程序从配置文件读取参数，避免对代码频繁的操作。 

   关于配置文件的格式，在这里推荐YAML 和XML~ XML是传统的配置文件写法，不过本人比较推荐yaml，他比XML要更加人性化，也更好写，关于yaml的详细信息可以参考： yaml官网


   比如我们可以将Server监听的端口作为变量，写入配置文件 config.yaml 和 config.xml，放入代码的根目录下，这样当我们想要更换服务器端口的时候，只要在配置文件中修改port对应的值就可以拉。 config.xml内容如下：



<?xml version="1.0" encoding="UTF-8"?>
<Config1>GetConfig</Config1>
<Config2>THE</Config2>
<Config3>Information</Config3>
<Feature1>HereIsTEST1</Feature1>
<Feature2>1024</Feature2>
<Feature3>Feature23333</Feature3>

config.yaml内容如下：




Address: 172.168.0.1
Config1: Easy
Config2:
  Feature1: 2
  Feature2: [3, 4]
Port: :6060
Config4: IS
Config5: ATest


接下来就是解析他们了，目前golang官方还没有解析yaml的库，因此我推荐使用第三方的go-yaml包，

地址如下：  go-yaml  ，go get安装该包后，我们就可以通过他解析文件啦：



//解析文件，取出所有参数
func GetYamlConfig() map[interface{}]interface{}{

	data, err := ioutil.ReadFile("config.yaml")
	//将解析出的参数转为map的形式
	m := make(map[interface{}]interface{})
	if err != nil {
		LogErr("error: %v", err)
	}
	err = yaml.Unmarshal([]byte(data), &m)

	return m
}
//根据需求取出对应值
func GetElement(key string,themap map[interface{}]interface{})string {
	if value,ok:=themap[key];ok {
		return value.(string)
	}

	LogErr("Can't find the *.yaml")
	return ""
}



这里同样给出解析xml配置文件的代码：




func GetXMLConfig() map[string]string {

	var t xml.Token
	var err error

	Keylst := make([]string,6)
	Valuelst:=make([]string,6)
//将解析出的元素填入map中，便于查找
	map1:=make(map[string]string)
	content, err := ioutil.ReadFile("config.xml")
	CheckError(err)
	decoder := xml.NewDecoder(bytes.NewBuffer(content))

	i:=0
	j:=0
	for t, err = decoder.Token(); err == nil; t, err = decoder.Token() {

		switch token := t.(type) {
		// 处理元素
		case xml.StartElement:

			name := token.Name.Local
			Keylst[i]=string(name)
			i=i+1

		case xml.CharData:
			content1 := string([]byte(token))
			//Valuelst=append(Valuelst,content1)
			Valuelst[j]=content1
			j=j+1

		}
	}
	for count:=0;count<len(Keylst);count++{
		map1[Keylst[count]]=Valuelst[count]
	}

	return map1
}
//取出map的函数跟yaml中的差不多，此处略过





运行效果如下：






版权声明：本文为博主原创文章，未经博主允许不得转载。

Spring学习（一）ioc理解

对Spring有所了解的都应该知道，spring贯穿始终的两个重要的思想，一个是IOC（控制反转）,一个是DI（依赖注入），对于新手而言，这两个概念比较难理解，我用自己的想法来解释下。

首先我们要知道在程序开发中为什么要使用spring框架。
这里先引入两个概念：耦合性、侵入性。简单的讲：耦合性，在java中表现为类之间的关系，耦合性强说明类之间的依赖关系强；侵入性：框架对代码的侵入，比如你项目用了struts1，要改框架时发现改的东西太多了，比如actionForm等，所以struts1对代码的侵入性是很高的。
在传统的java开发中具有高度的耦合性和侵入型。一个项目中，一般一个类都要依赖很多其他的类来完成自己的操作，我们往往采用new这个类的对象来调用他的方法，这样就造成了两个类的依赖关系太强，改一个地方，往往牵扯很多类牵扯大量的代码。侵入性上一段的例子可以明白。
当然EJB也可以解决耦合性和侵入性的问题，但是ejb太依赖服务器，属于重量级的框架。
可以说在这样的背景下，spring应运而生，一个轻量级的框架，解决传统企业开发的复杂性；使用普通的javaBean代替EJB技术。可以管理对象和对象之间的依赖关系，我们不需要自己建立对象，把这部分工作全部转交给容器完成，具有低耦合，对代码没有侵略性，对服务器没有依赖性特点的框架。
而这个容器，即IOC.

如何理解IOC思想？
一个很流行的例子，我换了种说法，这样更好理解：好比找女朋友，普通的方式是我们依赖各种关系找到这个女朋友（相当于new了对象），有一天分手了，而以前的那些关系也没有了，要想找到新的女朋友就要依赖新的关系（重新 new另外一个对象）,可以想象这个过程很麻烦。于是有了一种新的方式找对象——婚介所，这里就是我们所说的IOC方式，你把你要求的对象的特征告诉婚介所，他会直接给你找到一对象，没有中间复杂的过程，你只管相处的事情就好了，new的过程不用管，不需要任何依赖关系，即使哪天要换了，再把需要的对象提交给婚介所就行了，你就会得到你想要的新的对象了。 
事实上，使用ioc方式创建对象的目的，是为了以“被动”的方式形成对象之间的依赖关系。传统的开发过程中，不管是new，还是普通工厂，都需要目标对象主动创建、主动查找其需要的依赖对象 ， 目标对象会将他的精力分散在不必要的非业务逻辑方面。IOC通过DI(依赖注入)把建立好的对象注入到目标对象中。

Spring IOC具体如何实现？
上文中的婚介所就是ioc管理对象的容器，实际上是一个xml文件，将对象配置在xml里面，通过spring的工厂类进行解析，以“反射”的方式创建对象。
spring IOC容器的关键点：
* 必须将被管理的对象定义到spring配置文件中
* 必须定义构造函数或setter方法，让spring将对象注入过来

我们可以通过下面这里例子理解spring ioc的实现。本例使用spring 3.2 
1.配置applicationContext.xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <bean id="userDao4MySqlImpl" class="com.bjsxt.spring.dao.UserDao4MySqlImpl"/>
    <bean id="userDao4OracleImpl" class="com.bjsxt.spring.dao.UserDao4OracleImpl"/>
    <bean id="userManager" class="com.bjsxt.spring.manager.UserManagerImpl">
        <!-- 构造方法注入 
        <constructor-arg ref="userDao4OracleImpl"/>
         -->
         <!-- setter方法注入 -->
         <property name="userDao" ref="userDao4OracleImpl"/>
    </bean>
</beans>

2.注入的类：
package com.bjsxt.spring.dao;

public interface UserDao {

    public void save(String username, String password);
}
package com.bjsxt.spring.dao;

public class UserDao4MySqlImpl implements UserDao {

    public void save(String username, String password) {
        System.out.println("--------UserDao4MySqlImpl.save()-------");
    }
}
package com.bjsxt.spring.dao;

public class UserDao4OracleImpl implements UserDao {

    public void save(String username, String password) {
        System.out.println("--------UserDao4OracleImpl.save()-------");
    }
}

3.被注入的类：
package com.bjsxt.spring.manager;

public interface UserManager {
    public void save(String username, String password);
}

package com.bjsxt.spring.manager;

import com.bjsxt.spring.dao.UserDao;

public class UserManagerImpl implements UserManager {
    /**
     * 两种方式：如果这个类中需要注入对象，先建立对象属性，
     *      在写构造方法或者settet方法。
     * 
     */
    private UserDao userDao;

/*  public UserManagerImpl(UserDao userDao) {
        this.userDao = userDao;
    } */

    public void save(String username, String password) {
        this.userDao.save(username, password);
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}

4.测试类：
package com.bjsxt.spring.client;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.bjsxt.spring.manager.UserManager;

public class Client {

    public static void main(String[] args) {
/*  传统的通过new对象建立类之间的关系
 * UserManager userManager = new UserManagerImpl(new UserDao4OracleImpl());
        UserManager userManager = new UserManagerImpl(new UserDao4MySqlImpl());
        userManager.save("张三", "123");*/
/**
 * IOC思想     通过工厂类解析xml文件，以“反射”的方式创建对象：
 */
        BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserManager userManager = (UserManager)factory.getBean("userManager");
        userManager.save("张三", "123");
/**
 * IOC思想   实际的执行过程，这也是为什么需要setter方法或构造方法的原因：        
 */
//      UserManagerImpl userManager = new UserManagerImpl();
//      userManager.setUserDao(new UserDao4MySqlImpl());
//      userManager.save("张三", "123");
    }
}

这样就实现了spring ioc思想。 
本文完全个人理解，如有不对的地方，恳请指正。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        SpringMVC核心思想详解
Spring MVC是spring的一个web组件，它为构建稳健的web应用提供了丰富的功能。Spring MVC是基于每个逻辑和功能是高可配置的这样架构和设计的。当然spring MVC可以与其它流行的web框架像struts、webwork、javaserverface及tapestry实现无缝集成。我们看一下spring MVC的核心思想。   Spring请求的生命周期  为了便于理解，我把spring MVC的生命周期拆解为如下一个步骤总结一下springMVC几个关键的步骤，总共可以分为六个步骤，分别为：（1）    客户端向spring容器发起一个http请求（2）    发起的请求被前端控制起所拦截(DispatcherServlet)，前端控制器会去找恰当的映射处理器来处理这次请求。（3）    根据处理器映射（Handler Mapping）来选择并决定将请求发送给那一个控制器。（4）    在控制器中处理所发送的请求，并以modelAndView（属性值和返回的页面）的形式返回给向前端控制器。（5）    前端控制器通过查询viewResolver对象来试着解决从控制返回的视图。（6）    如果前端控制找到对应的视图，则将视图返回给客户端，否则抛异常。通过上面的图和springMVC生命周期的六个步骤，想必大家对springMVC的核心思想有个了大概的了解了，下面我们以实例为主，带领大家慢慢熟悉整个springMVC及如何使用springMVC。（本教程基于maven实现springMVC中的例子，所以大家得对maven需要有大概的了解）。 二、spring3.1 mvc 框架的特点如果仅仅关注于web方面的支持，Spring有下面一些特点：·         清晰的角色划分：控制器（controler），验证器(Validate)，命令对象(Object)，表单对象(BeanObject)和模型对象(Model)；分发器(Adapter)，处理器映射（HandlerAdapter）和视图解析器(ViewResolver)；等等。·         直接将框架类和应用类都作为JavaBean配置，包括通过应用上下文配置中间层引用，例如，从web控制器到业务对象和验证器的引用。·         可适应性，但不具有强制性：根据不同的情况，使用任何你需要的控制器子类（普通控制器，命令，表单，向导，多个行为，或者自定义的），而不是要求任何东西都要从Action/ActionForm继承。可重用的业务代码，而不需要代码重复：你可以使用现有的业务对象作为命令对象或表单对象，而不需要在ActionForm的子类中重复它们的定义·         可定制的绑定和验证：将类型不匹配作为应用级的验证错误，这可以保存错误的值，以及本地化的日期和数字绑定等，而不是只能使用字符串表单对象，手动解析它并转换到业务对象。·         可定制的处理器映射，可定制的视图解析：灵活的模型可以根据名字/值映射，处理器映射和视图解析使应用策略从简单过渡到复杂，而不是只有一种单一的方法。·         可定制的本地化和主题解析，支持JSP，无论有没有使用Spring标签库，支持JSTL，支持不需要额外过渡的Velocity，等等。简单而强大的标签库，它尽可能地避免在HTML生成时的开销，提供在标记方面的最大灵活性。 三、spring 3.1 MVC入门列子HelloWorld（1）在WEB-INF/web.xml中加入如下代码：         <servlet>        <servlet-name>dispatcherServlet</servlet-name>        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>        <init-param>           <param-name>contextConfigLocation</param-name>           <param-value>              classpath*:spring-servlet.xml           </param-value>       </init-param>        <load-on-startup>1</load-on-startup>    </servlet>     <servlet-mapping>        <servlet-name>dispatcherServlet</servlet-name>        <url-pattern>*.html</url-pattern></servlet-mapping>上述的配置的就是前段控制器，在servlet-mapping配置了*.html，意味着所有以.html结尾的请求多会通过这个servlet，当dispatcherServlet启动时，他默认会在web-info目录下查找一个spring-servlet.xml的配置文件。上面我们通过显示指定了这个文件的位置，即在类路径底下的spring-servlet.xml.这个文件我们会在第二步点给他家做详细介绍。（2）在类路径底下添加spring-servlet.xml文件，其内容如下：<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:p="http://www.springframework.org/schema/p"    xmlns:context=http://www.springframework.org/schema/contextxsi:schemaLocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context-3.0.xsd">     <context:component-scan       base-package="com.pango.spring.helloworld.controller" />     <bean id="viewResolver"       class="org.springframework.web.servlet.view.UrlBasedViewResolver">       <property name="viewClass"           value="org.springframework.web.servlet.view.JstlView" />       <property name="prefix" value="/WEB-INF/jsp/" />       <property name="suffix" value=".jsp" />    </bean></beans>上面这个文件，我们定义了一个<context:component-scan       base-package="com.pango.spring.helloworld.controller" />这样的标签，定义了这个后，当spring在启动时，会加载com.pango.spring.helloworld.controller这个包底下及子包底下的所有的组件（这就包的自动扫描机制，即spring会将标有@Controller @Component等类加载到spring容器管理中），后面我们还定义了<bean id="viewResolver"       class="org.springframework.web.servlet.view.UrlBasedViewResolver">       <property name="viewClass"           value="org.springframework.web.servlet.view.JstlView" />       <property name="prefix" value="/WEB-INF/jsp/" />       <property name="suffix" value=".jsp" />    </bean>ViewResolver是一个试图解析器，就是我们第一部分提到的springMVC生命周期中的第五步，上面这段的配置的意思就是，当我们从后端控制器中返回的视图时，前端控制器就根据这一段配置来返回一个具体的视图，如后端控制返回的是一个hello，根据上面的配置，最后前端控制器会组并成这样的一个地址：/web-inf/jsp/hello.jsp,然后从/web-inf/jsp/这个目录下面查找一个hello.jsp返回客户端。第三部分我们看我们写得HelloworldController后台控制器。（3）在包底下写一个HelloWorldController的类，其内容如下：@Controller

public class HelloWorldController {

@RequestMapping(value="/hello")

    public String sayHello(ModelMap modelMap){

       modelMap.put("sayHello", "hello world");

       return "/hello"; 

    }

}
在这里简单介绍下上面的配置，后面我们会详细讲解各个参数：Ø         Controller即声明这个类是一个控制器，上面第二部分我们说明了，只要加了@Controller标示的，spring会通过自动扫描机制，将这个类纳入spring容器管理中。Ø         @RequestMapping(value="/hello")，这个定义的就是一个请求路径，只要符合/hello路径的多会交给这个控制器的sayhello方法来处理。Ø         最后我们返回/hello的视图给客户端。（4）好了，大功告成，我们再在web-info/jsp/目录下添加一个hello.jsp文件，就可以启动运行我们的第一个程序了。hello.jsp的内容如下：<%@ page language="java" contentType="text/html; charset=UTF-8"

    pageEncoding="UTF-8"%>

 <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Insert title here</title>

</head>

<body>

    <span>${sayHello}</span>

   

</body>

</html>
 运行后访问ip;port/project/hello.html就可以看到我们预期的结果了。    四、springMVC参数传递 mvc结构中，v层不断有数据和c层交互，所以弄明白在springMVC中如何与后台进行数据交互是极其重要的，当然在下面我不会介绍每一个方法，只是对常用的方法，对于我这里没有涉及的方法大家可以参考spring官方的文档中springMVC这个章节。下面我们来看一幅图。当我们向springMVC发起请求到视图返回前，spring MVC帮我们做了主要是上面几个步骤，通过数据绑定、数据类型转换、验证、结果绑定这几个步骤。让我们看下实例：@RequestMapping("/user/find")    public String findUserById(@RequestParam("userId") int userId,ModelMap modelMap){       modelMap.put("userId", userId);       return "/user";}Ø         @RequestMapping("/user/find")，是对请求映射的说明，这个注解中主要包含四个属性，分别value、method、params、header，这四个参数分别表示：Value：指定路径Method：请求方式Params：参数Headers：请求头后面三个就是对请求路径的一个限制条件。SpringMVC对于路径的定义非常的灵活以下URL都是合法的：l       /usercreateUser    匹配/user/createUser、/user/aaa/bbb/createUser等URL。l       /user/createUser??    匹配/user/createUseraa、/user/createUserbb等URL。l       /user/{userId}    匹配user/123、user/abc等URL。l       /user{userId}    匹配user/aaa/bbb/123、user/aaa/456等URL。 l       company/{companyId}/user/{userId}/detail    匹配company/123/user/456/detail等的URL。 Ø         对RequestParam的介绍@RequestParam有以下三个参数。l       value：参数名。l       required：是否必需，默认为true，表示请求中必须包含对应的参数名，如果不存在将抛出异常。l       defaultValue：默认参数名，设置该参数时，自动将required设为false。极少情况需要使用该参数，也不推荐使用该参数。 当发送请求时，请求参数中必须要包含userId这个参数，当不包含这个参数，请求将找不到这个映射。当属性required=true时，不包含这个参数将会抛异常，如果不能确定是否需要这个参数是我们可以写成，@RequestParam(value = "userId", required = false) 。Ø         直接将属性映射到对象中    @RequestMapping("/user/find2")    public String find2UserById(User user,ModelMap modelMap){       modelMap.put("user", user);       return "/user";    }    Spring MVC按：     “HTTP请求参数名 =  命令/表单对象的属性名”    的规则，自动绑定请求数据，支持“级联属性名”，自动进行基本类型数据转换。         如：发起下面这个请求，springMVC会自动将id、name、password属性的值填充到user对象中。         http://localhost:8080/springParam/user/save.html?id=12&name=marcle&password=123Ø         SpringMVC以rest技术向springMVC传递参数通过 REST 风格体系架构，请求和响应都是基于资源表示的传输来构建的。资源是通过全局 ID 来标识的，这些 ID 一般使用的是一个统一资源标识符（URI）。客户端应用使用 HTTP 方法（如，GET、POST、PUT 或 DELETE）来操作一个或多个资源。通常，GET 是用于获取或列出一个或多个资源，POST 用于创建，PUT 用于更新或替换，而 DELETE 则用于删除资源。例如，GET http://host/context/employees/12345 将获取 ID 为 12345 的员工的表示。这个响应表示可以是包含详细的员工信息的 XML 或 ATOM，或者是具有更好 UI 的 JSP/HTML 页面。您看到哪种表示方式取决于服务器端实现和您的客户端请求的 MIME 类型。RESTful Web Service 是一个使用 HTTP 和 REST 原理实现的 Web Service。通常，一个 RESTful Web Service 将定义基本资源 URI、它所支持的表示/响应 MIME，以及它所支持的操作。Spring 3.0之后引入了对rest风格的支持。我们看实例@RequestMapping("/user/find/{id}")    public String rest(@PathVariable int id,ModelMap modelMap){       User user = new User(); user.setName("marcle");       user.setPassword("123");       user.setId(id);       modelMap.put("user", user);       return "/user";    }这里需要注意的地方时@RequestMapping("/user/find/{id}")和@PathVariable int id名称必须一样，否则会出现异常。Ø         简单介绍返回视图的方式u        ModelAndView 形式返回@RequestMapping("/user/save2")    public ModelAndView save2(User user,ModelMap modelMap){       ModelAndView mav = new ModelAndView();       mav.setViewName("/user");       mav.addObject("user", user);       return mav;    }ModelAndView就是对返回到页面的值和视图进行封装。u       直接字符串的形式返回，如”return “/user””,再把属性通过modelMap进行封装，modelMap存储的值属于request范围内，如果要发送服务器端请求，springMVC非常方便，你只要这样写即可return ”direct:user”.还有一种传递参数的方法，我放在springMVC中的rest技术介绍  下面我们看看springMVC返回的过程 五、springMVC标签介绍 SpringMVC简单没几个标签，用起来还是非常好用的，在使用springMVC中的标签之前需要向每个jsp的头部引入标签支持<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>1）      form标签这个标签会生成一个HTML的form标签，同时为内部标签的绑定暴露了一个绑定路径，它把命令对象（command object）放在pageContext中，这样内部的标签就可以访问这个对象，这个库中的其它标签都是这个标签的嵌套标签。如我们有个user的域对象，包含id、name、password属性，我们将把它当作返回index.jsp表单控制器的对象，如下面的代码：<form:form action="${ctx}/user/save.${ext}" method="post" commandName="user">

       <table>

           <tr>

              <td>Id:</td>

              <td><form:input path ="id" /></td>

           </tr>

           <tr>

              <td>name:</td>

              <td><form:input path ="name" /></td>

           </tr>

           <tr>

              <td>password:</td>

              <td><form:input path ="password" /></td>

           </tr>

           <tr>

              <td colspan="2"><input type ="submit" value="Save" /></td>

           </tr>

       </table>

    </form:form>
上述的id、name、password由页面控制器放置在pageContext中，即在内部控制器方法中需要做这样的声明：@RequestMapping(value="/user/save",method=RequestMethod.GET)    public String forSave(@ModelAttribute User user){       return "/index";    }后台控制器中必须绑定这个@ModelAttribute User user命令行对象，而form下面的属性需要于这个user中的属性对应起来，否则将会抛异常。标签经过解析后生成的代码如下：<form id="user" action="/springTag/user/save.html" method="post">

               <table>

                       <tr>

                               <td>Id:</td>

                               <td><input id="id" name="id" type="text" value="0"/></td>

                       </tr>

                       <tr>

                               <td>name:</td>

                               <td><input id="name" name="name" type="text" value=""/></td>

                       </tr>

                       <tr>

                               <td>password:</td>

                               <td><input id="password" name="password" type="text" value=""/></td>

                       </tr>

                       <tr>

                               <td colspan="2"><input type ="submit" value="Save Changes" /></td>

                       </tr>

               </table>

        </form>
（2）  input 标签使用时如上面的表达式，<form:input path ="id" />解析后会变成<input id="name" name="name" type="text" value=""/>可见用spring标签比传统的html简洁很多。（3）checkbox 标签这个标签解析之后会变成html’中的type为checkbox的input元素，我们假设我们的用户有很多的参考东西，如信息的订阅、爱好、格言等，即如下面的域模型：public class Preferences { 
                      
    private boolean receiveNewsletter; 
  
    private String[] interests; 
  
    private String favouriteWord; 
  
    public boolean isReceiveNewsletter() { 
        return receiveNewsletter; 
    } 
  
    public void setReceiveNewsletter(boolean receiveNewsletter) { 
        this.receiveNewsletter = receiveNewsletter; 
    } 
  
    public String[] getInterests() { 
        return interests; 
    } 
  
    public void setInterests(String[] interests) { 
        this.interests = interests; 
    } 
  
    public String getFavouriteWord() { 
        return favouriteWord; 
    } 
  
    public void setFavouriteWord(String favouriteWord) { 
        this.favouriteWord = favouriteWord; 
    } 
} 
我们的相应的jsp文件可以写成：<form:form action="${ctx}/pre/save.${ext}" method="post" commandName="preferences">

    <table>

        <tr>

            <td>Subscribe to newsletter?:</td>

            <%-- Approach 1: Property is of type java.lang.Boolean --%>

            <td><form:checkbox path="receiveNewsletter"/></td>

            <td> </td>

        </tr>

 

        <tr>

            <td>Interests:</td>

            <td>

                <%-- Approach 2: Property is of an array or of type java.util.Collection --%>

                Quidditch: <form:checkbox path="interests" value="Quidditch"/>

                Herbology: <form:checkbox path="interests" value="Herbology"/>

                Defence Against the Dark Arts: <form:checkbox path="interests"

                    value="Defence Against the Dark Arts"/>

            </td>

            <td> </td>

        </tr>

        <tr>

            <td>Favourite Word:</td>

            <td>

                <%-- Approach 3: Property is of type java.lang.Object --%>

                Magic: <form:checkbox path="favouriteWord" value="Magic"/>

            </td>

            <td> </td>

        </tr>

        <tr>

        <td colspan="2">

             <input type="submit" value="submit"/>

        </td>

        </tr>

    </table>

</form:form>
如果有多个供选择的，在后台我们以数组的形式存储。（4）radiobutton 标签解析后会变成html元素中type为radio的input元素如下面的情况：<tr> 
    <td>Sex:</td> 
    <td>Male: <form:radiobutton path="sex" value="M"/> <br/> 
        Female: <form:radiobutton path="sex" value="F"/> </td> 
    <td> </td> 
</tr> 
（5）password标签解析后变成html元素中type为password的input元素，即为密码框。<tr> 
    <td>Password:</td> 
    <td> 
        <form:password path="password" /> 
    </td> 
</tr> 
（6）select标签这个标签对应于html元素中的下拉框，即为select元素。<tr>

              <td>Skills:</td>

              <td><form:select path="skills" items="${skills}" /></td>

              <td></td>

           </tr>
 （7）option标签<form:select path="house"> 
            <form:option value="Gryffindor"/> 
            <form:option value="Hufflepuff"/> 
            <form:option value="Ravenclaw"/> 
            <form:option value="Slytherin"/> 
        </form:select> 
（8）options标签<form:select path="country"> 
            <form:option value="-" label="--Please Select"/> 
            <form:options items="${countryList}" itemValue="code" itemLabel="name"/> 
        </form:select> 
（9）textarea标签<td><form:textarea path="notes" rows="3" cols="20" /></td> （10）hidden标签       <form:hidden path="house" /> （11）errors标签<form:form> 
    <table> 
        <tr> 
            <td>First Name:</td> 
            <td><form:input path="firstName" /></td> 
            <%-- Show errors for firstName field --%> 
            <td><form:errors path="firstName" /></td> 
        </tr> 
  
        <tr> 
            <td>Last Name:</td> 
            <td><form:input path="lastName" /></td> 
            <%-- Show errors for lastName field --%> 
            <td><form:errors path="lastName"  /></td> 
        </tr> 
        <tr> 
            <td colspan="3"> 
                <input type="submit" value="Save Changes" /> 
            </td> 
        </tr> 
    </table> 
</form:form> 
 六、springMVC拦截器和Struts2一样，Spring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现HandlerInterceptor接口。这个接口中定义了三个方法：preHandle()、postHandle()、afterCompletion()。下面对代码中的三个方法进行解释。preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求request进行处理。如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true；如果程序员决定不需要再调用其他的组件去处理请求，则返回false。postHandle()：这个方法在业务处理器处理完请求后，但是DispatcherServlet向客户端返回请求前被调用，在该方法中对用户请求request进行处理。afterCompletion()：这个方法在DispatcherServlet完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。下面通过一个例子来说明如何使用Spring MVC框架的拦截器。要求编写一个拦截器，拦截所有不在工作时间的请求，把这些请求转发到一个特定的静态页面，而不对它们的请求进行处理。首先编写TimeInterceptor.Java，代码如下：public class TimeInterceptor extends HandlerInterceptorAdapter {

    private int openingTime; // openingTime 属性指定上班时间

    private int closingTime; // closingTime属性指定下班时间

    private String outsideOfficeHoursPage; // outsideOfficeHoursPage属性指定错误

 

    public void setOpeningTime(int openingTime) {

       this.openingTime = openingTime;

    }

 

    public void setClosingTime(int closingTime) {

       this.closingTime = closingTime;

    }

 

    public void setOutsideOfficeHoursPage(String outsideOfficeHoursPage) {

       this.outsideOfficeHoursPage = outsideOfficeHoursPage;

    }

 

    // 重写 preHandle()方法，在业务处理器处理请求之前对该请求进行拦截处理

    public boolean preHandle(HttpServletRequest request,

           HttpServletResponse response, Object handler) throws Exception {

       Calendar cal = Calendar.getInstance();

       int hour = cal.get(Calendar.HOUR_OF_DAY); // 获取当前时间

       if (openingTime <= hour && hour < closingTime) { // 判断当前是否处于工作 时间段内

 

           return true;

       } else {

           response.sendRedirect(outsideOfficeHoursPage); // 返回提示页面

           return false;

       }

    }

 

}
 可以看出，上面的代码重载了preHandle()方法，该方法在业务处理器处理请求之前被调用。在该方法中，首先获得当前的时间，判断其是否在 openingTime和closingTime之间，如果在，返回true，这样才会调用业务控制器去处理该请求；否则直接转向一个静态页面，返回 false，这样该请求就不会被处理。下面是在dispatcherServlet-servlet.xml中对拦截器进行的配置，代码如下：<mvc:interceptors>

       <mvc:interceptor>

           <mvc:mapping path="/user/*" />

           <bean class="com.pango.spring.interceptor.TimeInterceptor">

              <property name="openingTime" value="12"></property>

              <property name="closingTime" value="24"></property>

              <property name="outsideOfficeHoursPage" value="outTime.html"></property>

           </bean>

       </mvc:interceptor>

    </mvc:interceptors>
 可以看出，上面代码用bean标签去定义TimeInterceptor，令其id为officeHoursInterceptor，并给它的3个属性赋值。在urlMapping中通过<property name="interceptors">去指定officeHoursInterceptor为一个拦截器，读者可以在<list> 和</list>之间定义多个拦截器outsideOfficeHours.html的代码很简单，只是输出一句提示语。运行程序，在浏览器中随便访问一个页面，如果请求的时间在9点～18点之间，则该请求可以被处理；否则，返回一句提示语，如图23-5所示 说 明：在第22章中介绍过控制反转是Spring框架的核心思想，即用一个接口去定义一些操作，在接口的实现类中去重写这些操作，然后在Spring的配置文件中去把该接口的实现类注入到应有框架中，这样就可以通过调用接口去调用接口的实现类。本节讲的拦截器就体现了这种思想，即实现 HandlerInterceptorAdapter接口，重写preHandle()方法并在配置文件中实现TimeInterceptor的注入。这 样当框架调用HandlerInterceptorAdapter时，就可以调用到TimeInterceptor类的preHandle()方法七、spring3 MVC 类型转换  Servlet中的输入参数为都是string类型，而spring mvc通过data bind机制将这些string 类型的输入参数转换为相应的command object（根据view和controller之间传输数据的具体逻辑，也可称为model attributes, domain model objects）。在这个转换过程中，spring实际是先利用java.beans.PropertyEditor中的 setAdText方法来把string格式的输入转换为bean属性，亦可通过继承java.beans.PropertyEditorSupport来实现自定义的PropertyEditors。自定义完毕propertyEditor后，有以下几种方式来注册自定义的customer propertyEditor. （我只实现了第二种转换方式，至于其它方法大家可以自己尝试）Ø        直接将自定义的propertyEditor放到需要处理的java bean相同的目录下名称和java Bean相同但后面带Editor后缀。例如需要转换的java bean 名为User,则在相同的包中存在UserEditor类可实现customer propertyEditor的自动注册。Ø        利用@InitBinder来注册customer propertyEditor这个在之前的笔记中已经介绍过了，即在controller类中增加一个使用@InitBinder标注的方法，在其中注册customer EditorJava代码   public class BaseController {

   

    @InitBinder

    public void initBinder(WebDataBinder binder) {

       binder.registerCustomEditor(Date.class, new CustomDateEditor(true));

    }

}
Ø        继承 WebBindingInitializer 接口来实现全局注册使用@InitBinder只能对特定的controller类生效，为注册一个全局的customer Editor，可以实现接口WebBindingInitializer 。Java代码   public class CustomerBinding implements WebBindingInitializer {

 

    public void initBinder(WebDataBinder binder, WebRequest request) {

       // TODO Auto-generated method stub

         SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); 

                   dateFormat.setLenient(false); 

                   binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));

 
    }

 

}
并修改 spring-servlet xml配置文件Xml代码   <bean  

        class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">  

        <property name="webBindingInitializer">  

            <bean  

                class="net.zhepu.web.customerBinding.CustomerBinding" />  

        </property>  

    </bean>  
 但这样一来就无法使用mvc:annotation-driven  了。使用conversion-service来注册自定义的converterDataBinder实现了PropertyEditorRegistry, TypeConverter这两个interface，而在spring mvc实际处理时，返回值都是return binder.convertIfNecessary(见HandlerMethodInvoker中的具体处理逻辑)。因此可以使用customer conversionService来实现自定义的类型转换。Xml代码   <bean id="conversionService" 

    class="org.springframework.format.support.FormattingConversionServiceFactoryBean"> 

     

    <property name="converters"> 

        <list> 

            <bean class="net.zhepu.web.customerBinding.CustomerConverter" /> 

        </list> 

    </property> 

     

</bean> 
 需要修改spring-servlet xml配置文件中的annotation-driven,增加属性conversion-service指向新增的conversionService bean。Xml代码   <mvc:annotation-driven validator="validator"  conversion-service="conversionService" /> 对于第二种方式实现如下Date类型编辑器public class CustomDateEditor extends PropertyEditorSupport {

    private static final Map<String, String> dateMap;

 

    static {

       dateMap = new HashMap<String, String>();

       dateMap.put("yyyy-MM-dd", "\\d{4}-\\d{2}-\\d{2}");

       dateMap.put("yyyy-MM-dd hh:mm:ss", "\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}");

       dateMap.put("yyyy年MM月dd日", "\\d{4}年\\d{2}月\\d{2}日");

    }

 

    private final boolean allowEmpty;

 

    public CustomDateEditor(boolean allowEmpty) {

       this.allowEmpty = allowEmpty;

    }

 

    @Override

    public void setAsText(String text) throws IllegalArgumentException {

   

       if (this.allowEmpty && !StringUtils.hasText(text)) {

           // Treat empty String as null value.

          

           setValue(null);

       } else {

      

           try {

             

              boolean flag = false;

              for (String dateFormatStr : dateMap.keySet()) {

                  if (text.matches(dateMap.get(dateFormatStr))) {

                     flag = true;

                     System.out.println(text);

                     DateFormat dateFormat = new SimpleDateFormat(dateFormatStr);

                     setValue(dateFormat.parse(text));

                     break;

                  }

              }

              if (!flag) {

                  //throw new IllegalArgumentException("Could not parse date: " + text);

              }

           } catch (ParseException ex) {

              //throw new IllegalArgumentException("Could not parse date: " + ex.getMessage(), ex);

           }

       }

    }

 

    @Override

    public String getAsText() {

       Date value = (Date) getValue();

       DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

 

       return value != null ? dateFormat.format(value) : "";

    }

}

@InitBinder来注册customer propertyEditor

@InitBinder

    public void initBinder(WebDataBinder binder) {

      

       binder.registerCustomEditor(Date.class, new CustomDateEditor(true));

    }
最后讲讲对于requestBody或httpEntity中数据的类型转换Spring MVC中对于requestBody中发送的数据转换不是通过databind来实现，而是使用HttpMessageConverter来实现具体的类型转换。例如，之前提到的json格式的输入，在将json格式的输入转换为具体的model的过程中，spring mvc首先找出request header中的contenttype，再遍历当前所注册的所有的HttpMessageConverter子类，根据子类中的canRead()方法来决定调用哪个具体的子类来实现对requestBody中的数据的解析。如果当前所注册的 httpMessageConverter中都无法解析对应contexttype类型，则抛出 HttpMediaTypeNotSupportedException （http 415错误）。那么需要如何注册自定义的messageConverter呢，很不幸，在spring 3.0.5中如果使用annotation-driven的配置方式的话，无法实现自定义的messageConverter的配置，必须老老实实的自己定义AnnotationMethodHandlerAdapter的bean定义，再设置其messageConverters以注册自定义的 messageConverter。Xml代码   <mvc:annotation-driven>  

    <mvc:message-converters>  

        <bean class="org.springframework.http.converter.StringHttpMessageConverter"/>  

        <bean class="org.springframework.http.converter.ResourceHttpMessageConverter"/>  

        <bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"/>  

    </mvc:message-converters>  

</mvc:annotation-driven>
  八、json格式数据的输入和输出Spring mvc处理json需要使用jackson的类库，因此为支持json格式的输入输出需要先修改pom.xml增加jackson包的引用Xml代码   <dependency>

           <groupId>org.codehaus.jackson</groupId>

           <artifactId>jackson-core-lgpl</artifactId>

           <version>1.8.0</version>

           <scope>compile</scope>

       </dependency>

       <dependency>

           <groupId>org.codehaus.jackson</groupId>

           <artifactId>jackson-mapper-asl</artifactId>

           <version>1.8.0</version>

</dependency>
 在spring-servlet.xml中必须加入这段代码：<mvc:annotation-driven />根据前面的分析，在spring mvc中解析输入为json格式的数据有两种方式1:使用@RequestBody来设置输入Java代码   @RequestMapping("/json1")    @ResponseBody    public JsonResult testJson1(@RequestBody User u){    log.info("get json input from request body annotation");    log.info(u.getUserName());    return new JsonResult(true,"return ok");}2:使用HttpEntity来实现输入绑定Java代码       @RequestMapping("/json2")

    public ResponseEntity<JsonResult> testJson2(HttpEntity<User> u){

    log.info("get json input from HttpEntity annotation");

    log.info(u.getBody().getUserName());

    ResponseEntity<JsonResult> responseResult = new ResponseEntity<JsonResult>( new JsonResult(true,"return ok"),HttpStatus.OK);

    return responseResult;
 对应Json格式的输出也对应有两种方式1：使用@responseBody来设置输出内容为context body@RequestMapping(value="/kfc/brands/{name}", method = RequestMethod.GET)

    public @ResponseBody List<Shop> getShopInJSON(@PathVariable String name) {

    List<Shop> shops = new ArrayList<Shop>();

       Shop shop = new Shop();

       shop.setName(name);

       shop.setStaffName(new String[]{"mkyong1", "mkyong2"});

      

       shops.add(shop);

      

       Shop shop2 = new Shop();

       shop2.setName(name);

       shop2.setStaffName(new String[]{"mktong1", "mktong2"});

       shops.add(shop2);

       return shops;

}       
     当我们在地址栏中输入：http://localhost:8080/springJson/kfc/brands/kfc_name.html服务器端会返回给我们jason格式的数据，这样我们就可以省去手工繁琐的组并了   2：返回值设置为ResponseEntity<?>类型，以返回context body@RequestMapping("/json2")    public ResponseEntity<JsonResult> testJson2(HttpEntity<User> u){    log.info("get json input from HttpEntity annotation");    log.info(u.getBody().getUserName());    ResponseEntity<JsonResult> responseResult = new ResponseEntity<JsonResult>( new JsonResult(true,"return ok"),HttpStatus.OK);    return responseResult;    }九、spring3mvc文件上传 Spring mvc使用jakarta的commons fileupload来支持文件上传，因此我们需要在pom.xml中导入所依赖的两个包：<dependency> 

        <groupId>commons-io</groupId> 

        <artifactId>commons-io</artifactId> 

        <version>2.0.1</version> 

    </dependency> 

           

    <dependency> 

        <groupId>commons-fileupload</groupId> 

        <artifactId>commons-fileupload</artifactId> 

        <version>1.2.2</version> 

</dependency> 
 在spring-servlet.xml中加入以下这段代码：<bean id="multipartResolver"       class="org.springframework.web.multipart.commons.CommonsMultipartResolver">        <!-- one of the properties available; the maximum file size in bytes -->       <property name="maxUploadSize" value="100000" />          </bean> 其中的property中可以限制最大和最小文件上传。在客户端的代码如下：<form method="post" action="${ctx}/user/upload.${ext}" enctype="multipart/form-data"><input type="text" name="name"/><input type="file" name="file"/><input type="submit"/></form>服务器端的代码如下：@RequestMapping(value = "/user/upload", method = RequestMethod.POST)

    public String handleFormUpload(@RequestParam("name") String name,

           @RequestParam("file") MultipartFile file, HttpServletRequest request)

           throws IOException {

       String filePath = request.getRealPath("/");

       if (!file.isEmpty()) {

           String fileName = file.getOriginalFilename();

           System.out.println(filePath + "/" + fileName);

           byte[] bytes = file.getBytes();

           FileOutputStream output = new FileOutputStream(new File(filePath

                  + fileName));

           output.write(bytes);

           output.close();

           return "redirect:/success.jsp";

       } else {

           return "redirect:/failure.jsp";

       }

    }
 十、spring mvc国际化和本地化 何为国际化，简单来说就是在那个国家显示哪个国家的语言，在计算机中，国际化和本地化意味着计算机软件要适应不同的语言和地区的差异。国际化就是设计为了适应不同地区和语言的差异而工程不需要做任何改动。这一节的目的就是在springMVC中增加国际化和本地化的应用，我们将在这一节实现三种语言可以相互切换的国际化和本地化。（1）我们在resources下面添加三个property文件，分别为：messages_de.properties、messages_en.properties、messages_zh.properties，文件的命名规则：messages_语言.properties三个文件的内容如下：Ø         messages_de.propertieslabel.firstname=Vornamelabel.lastname=Familienamelabel.email=Emaillabel.telephone=Telefonlabel.addcontact=Addieren Kontaktlabel.title=spring mvc Internationalization (i18n) / LocalizationØ         messages_en.propertieslabel.firstname=First Namelabel.lastname=Last Namelabel.email=Emaillabel.telephone=Telephonelabel.addcontact=Add Contactlabel.title=spring mvc Internationalization (i18n) / LocalizationØ         messages_zh.properties（经过转换后的中文）label.firstname=\u59D3label.lastname=\u540D\u5B57label.email=\u7535\u5B50\u90AE\u4EF6label.telephone=\u7535\u8BDDlabel.addcontact=\u8054\u7CFB\u65B9\u5F0Flabel.title=spring mvc \u56FD\u9645\u5316\u548C\u672C\u5730\u5316\u652F\u6301 （2）spring-servet.xml文件的配置<!-- 为了使用国际化信息源，Spring MVC 必须实现MessageSource接口。当然框架内部有许多内置的实现类。我们需要做的是注册一个MessageSource类型的Bean。Bean 的名称必须为messageSource，从而方便DispatcherServlet自动检测它。每个DispatcherServlet只能注册一个信息源-->  <bean id="messageSource"

       class="org.springframework.context.support.ReloadableResourceBundleMessageSource">

       <property name="basename" value="classpath:messages" />

       <property name="defaultEncoding" value="UTF-8" />

    </bean>

<!—session 解析区域 -->

    <bean id="localeResolver" 

        class="org.springframework.web.servlet.i18n.SessionLocaleResolver"> 

     

<!-- property name="defaultLocale" value="en"/> --> 

    </bean> 

 <!-- 修改用户的区域需要调用区域修改拦截器 LocaleChangeInterceptor。如下所设定设定paramName属性来设定拦截请求中的特定参数（这里是language）确定区域。既然是拦截器那就需要注册到拦截器 Bean 中，这里是注册到了DefaultAnnotationHandlerMapping Bean中 -->

    <bean id="localeChangeInterceptor"

       class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">

       <property name="paramName" value="lang" />

    </bean>

<!--

    <bean id="localeResolver"

       class="org.springframework.web.servlet.i18n.CookieLocaleResolver">

       <property name="defaultLocale" value="en" />

    </bean>

 -->

    <bean id="handlerMapping"

        class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">

       <property name="interceptors">

           <ref bean="localeChangeInterceptor" />

       </property>

    </bean>
（3）在jsp目录下面创建一个contact.jsp文件<%@ page language="java" contentType="text/html; charset=UTF-8"

    pageEncoding="UTF-8"%>

<%@taglib uri="http://www.springframework.org/tags" prefix="spring"%>

<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<c:set var="ctx" value="${pageContext.request.contextPath}" />

<c:set var="ext" value="html" />

<html>

<head>

    <title>Spring 3 MVC Series - Contact Manager</title>

</head>

<body>

<h3><spring:message code="label.title"/></h3>

 

<span style="float: right">

    <a href="${ctx}/language.${ext}?local=en">英文</a>

    |

    <a href="${ctx}/language.${ext}?local=de">德文</a>

    <a href="${ctx}/language.${ext}?local=zh">中文</a>

</span>

 

 

<form:form method="post" action="addContact.html" commandName="contact">

 

    <table>

    <tr>

       <td><form:label path="firstname"><spring:message code="label.firstname"/></form:label></td>

       <td><form:input path="firstname" /></td>

    </tr>

    <tr>

       <td><form:label path="lastname"><spring:message code="label.lastname"/></form:label></td>

       <td><form:input path="lastname" /></td>

    </tr>

    <tr>

       <td><form:label path="lastname"><spring:message code="label.email"/></form:label></td>

       <td><form:input path="email" /></td>

    </tr>

    <tr>

       <td><form:label path="lastname"><spring:message code="label.telephone"/></form:label></td>

        <td><form:input path="telephone" /></td>

    </tr>

    <tr>

       <td colspan="2">

           <input type="submit" value="<spring:message code="label.addcontact"/>"/>

       </td>

    </tr>

</table>  

   

</form:form>

</body>

</html>
 其中<spring:message>标签结合 ResourceBundleMessageSource 的功能，在网页上显示 messages.properties 中的文字讯息。（4）创建LanguageController@Controller

public class LanguageController {

    @Autowired

    private SessionLocaleResolver localeResolver;

    @RequestMapping("/forLanguage")

    public String forLanguage(@ModelAttribute Contact contact){

       return "/contact";

    }

    @RequestMapping(value="/language",method=RequestMethod.GET)

     public ModelAndView changeLocal(@ModelAttribute Contact contact,HttpServletRequest request,@RequestParam String local,HttpServletResponse response){ 

            if("zh".equals(local)){

           

            localeResolver.setLocale(request, response, Locale.CHINA); 

            }else if("en".equals(local))  {

            localeResolver.setLocale(request, response, Locale.ENGLISH); 

            }else if("de".equals(local)){

            localeResolver.setLocale(request, response, Locale.GERMAN);

            }

               

            return new ModelAndView("/contact"); 

        } 

 

}
 其中红色部分就是对语言的设置效果如下图： 十一、使用jsr303进行验证 JSR 303 – Bean Validation 是一个数据验证的规范，2009 年 11 月确定最终方案。2009 年 12 月 Java EE 6 发布，Bean Validation 作为一个重要特性被包含其中，Spring MVC在使用了<mvc:annotation-driven> 后，如果路径中有jsr 303的实现，将自动提供对jsr 303验证方式的支持。Ø         引入hibernate-validator，hibernate-validator对jsr 303做了实现  <dependency>    <groupId>org.hibernate</groupId>    <artifactId>hibernate-validator</artifactId>    <version>4.2.0.Final</version></dependency>Ø         新增一个pojo bean ,增加jsr 303格式的验证annotationpublic class Contact {

    private Long id = 0L;

 

    @Size(min = 1)

    private String firstName;

 

    @NotNull

    @Size(min = 1)

    private String lastName;

 

    @Past

    private Date dateOfBirth;

 

    private boolean married;

 

    @Min(0)

    @Max(20)

    private int children;

}
Ø         在controller 类中的handler method中，对需要验证的对象前增加@Valid 标志  @RequestMapping(value="/add",method=RequestMethod.POST)    public String addContact(@ModelAttribute @Valid Contact contact,BindingResult result){       if(result.hasErrors()){           return "/contact";       }       return "/contact";    } Ø         在jsp页面中添加contact.jsp<form:form action="${ctx }/contact/add.${ext}" method="post"

       commandName="contact">

 

       <table border="1">

 

           <tr>

 

              <th> </th>

 

              <th><spring:message code="editcontact.heading" /></th>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message

                     code="editcontact.label.firstname" /></td>

 

              <td><form:input path="firstName" size="40" /><font

                  color="#FF0000"><form:errors path="firstName*" /></font></td>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message

                     code="editcontact.label.lastname" /></td>

 

              <td><form:input path="lastName" size="40" /><font

                  color="#FF0000"><form:errors path="lastName*" /></font></td>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message code="editcontact.label.dob" /></td>

 

              <td><form:input path="dateOfBirth" size="40" /><font

                  color="#FF0000"><form:errors path="dateOfBirth*" /></font></td>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message

                     code="editcontact.label.married" /></td>

 

              <td><form:checkbox path="married" /><font color="#FF0000"><form:errors

                         path="married" /></font></td>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message

                     code="editcontact.label.children" /></td>

 

              <td><form:input path="children" size="5" /><font

                  color="#FF0000"><form:errors path="children*" /></font></td>

 

           </tr>

 

           <tr>

 

              <td><input type="submit"

                  value="<spring:message code="editcontact.button.save"/>" /></td>

 

              <td><input type="reset"

                  value="<spring:message code="editcontact.button.reset"/>" /></td>

           </tr>

       </table>

    </form:form>
 Ø         结果 使用jsr 303非常简单吧，有些人就问了，可以不可以自定义错误信息，当然是可以的，下面我就通过自定义错误来实现对contact的校验。@Size(min = 1, message = "Contact first name is required.")    private String firstName;     @NotNull(message = "Contact cannot be left empty.")    @Size(min = 1, message = "Contact last name is required.")    private String lastName;     @Past(message = "Contact date of birth must be a date in the past.")    @DateTimeFormat(pattern="yyyy-MM-dd")    private Date dateOfBirth;     private boolean married;     @Min(value = 0, message = "A contact cannot have fewer than 0 children")    @Max(value = 20, message = "A contact cannot have more than 20 children")    private int children; 只要将错误信息写到注解后面的message中即可，简单吧，我们再来看看jsr 303 主要的注解有哪些？表 1. Bean Validation 中内置的 constraint注    解功能说明@Null 被注释的元素必须为 null@NotNull 被注释的元素必须不为 null@AssertTrue 被注释的元素必须为 true@AssertFalse 被注释的元素必须为 false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max, min) 被注释的元素的大小必须在指定的范围内@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(value)被注释的元素必须符合指定的正则表达式 表 2. Hibernate Validator 附加的 constraint @Email                    被注释的元素必须是电子邮箱地址@Length                   被注释的字符串的大小必须在指定的范围内@NotEmpty                 被注释的字符串的必须非空@Range                    被注释的元素必须在合适的范围内 有人写就问了，那么可以不可以自定义注释类型呢？答案当然是可以的。Ø         自定义jsr303注释类型（1）@Age是一个定制化的 constraint，由两个内置的 constraint 组合而成。代码如下         @Max(130)@Min(1)@Constraint(validatedBy = {})@Documented@Target( { ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })@Retention(RetentionPolicy.RUNTIME)public @interface Age {    String message() default "年龄填写不正确";     Class<?>[] groups() default {};     Class<? extends Payload>[] payload() default {};}（2）status是一个重新写得注释类型@Status 的 annotation 部分@Constraint(validatedBy = {StatusValidator.class})@Documented@Target( { ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })@Retention(RetentionPolicy.RUNTIME)public @interface Status {     String message() default "状态选择不正确";     Class<?>[] groups() default {};     Class<? extends Payload>[] payload() default {}; }@Status 的 constraint validator 部分public class StatusValidator implements ConstraintValidator<Status, Integer> {

    private final int[] ALL_STATUS = {1, 2, 3};

    public void initialize(Status arg0) {

       // TODO Auto-generated method stub

      

    }

 

    public boolean isValid(Integer value, ConstraintValidatorContext arg1) {

       if(Arrays.asList(ALL_STATUS).contains(value)) {

            return true;

          

       } else{

            return false;

       }

    }

 

}
如果大家对于注释怎么写不够了解，请参考其它相关文档。 在属性上增加age、status@Ageprivate int age;@Statusprivate int status;运行结果如下  

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

高并发面试必问：技术架构

高并发的业务架构是:

前端:异步请求+资源静态化+cdn
后端:请求队列+轮询分发+负载均衡+共享缓存数据层:redis缓存+数据分表+写队列存储:raid阵列+热备网络:dns轮询+DDOS攻击防护

版权声明：

Spring MVC入门案例（1）
开始Spring MVC建立一个web project,并导入spring 3.x的jar包配置web.xml根据上面的spring mvc流程图，我们知道DispatcherServlet是spring mvc 的一个前端控制器，所以我们当然要去配置它，以便于将请求转给DispatcherServlet处理   <servlet>

    <servlet-name>dispatcher</servlet-name>

    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

    <init-param>

        <param-name>contextConfigLocation</param-name>

<!-- 如果配置文件位于classpath下，可以这么写： classpath:dispatcher.xml -->

        <param-value>/WEB-INF/dispatcher.xml</param-value>

    </init-param>

    <load-on-startup>1</load-on-startup>

  </servlet>

 

  <servlet-mapping>

    <servlet-name>dispatcher</servlet-name>

    <url-pattern>/</url-pattern>

  </servlet-mapping>
  注：由于DispatcherServlet在初始化的过程中需要一个配置文件来生产文件中的各种bean,并生成WebApplicationContext对象，保存到ServletContext中(如果DispatcherServlet有多个，那么每一个DispatcherServlet都对应一个WebApplicationContext)，我们可以在Servlet的init-param中配置配置文件的路径，当然如果我们没有配置Init-Param,它会默认到WEB-INF的文件夹中找[servletname]-servlet.xml文件，例如上面如果我们没有配置，则会去寻找dispatcher-servlet.xml这个配置文件。（在init-param中我们可以指定多个配置文件，用逗号分隔也可以使用通配符*）配置上文中我们指定的所需的dispatcher.xml文件<?xml version="1.0" encoding="UTF-8"?>

 

<beans xmlns="http://www.springframework.org/schema/beans"

    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

    xmlns:p="http://www.springframework.org/schema/p"

    xmlns:context="http://www.springframework.org/schema/context"

    xmlns:mvc="http://www.springframework.org/schema/mvc"

    xsi:schemaLocation="

    http://www.springframework.org/schema/beans

    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd

    http://www.springframework.org/schema/context

    http://www.springframework.org/schema/context/spring-context-3.0.xsd

    http://www.springframework.org/schema/mvc

    http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd">

 

    <context:component-scan base-package="com.controls" />

   

    <mvc:annotation-driven />

   

    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">

       <property name="prefix" value="/WEB-INF/views/"></property>

       <property name="suffix" value=".jsp"></property>

       <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"></property>

    </bean>

   

</beans>
  配置文件说明：<context:component-scan base-package="com.controls" />由于我们使用了基于注解的Controller，所以这里指定了需要被扫描的包路径，如果有多个可以使用逗号分隔 <mvc:annotation-driven />上面的spring mvc流程图中我们知道DispatcherServlet接管请求后，会由HandlerMapping来执行映射，所以我们需要注册HanlderMapping，比如上面的标签会自动注册比如DefaultAnnotationHandlerMapping（执行请求到Controller的映射）和AnnotationMethodHandlerAdapter（调用controller中的方法）这样的bean，当然这个标签还提供了其他的一些支持(更多介绍请参照spring官方文档第455页)。 <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">

       <property name="prefix" value="/WEB-INF/views/"></property>

       <property name="suffix" value=".jsp"></property>

       <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"></property>

</bean>
 上面spring mvc流程图的最后controller处理完毕后会交给一个ViewResolver进行处理，大体上是解析视图逻辑名并经过一定的处理获取一个视图，这里的意思是设置视图用jsp来处理(比如我们设置viewClass为JstlView)来进行处理，就是以forward的形式转发给jsp，这个地址是：/WEB-INF/views/[controller返回值].jsp ，当然视图解析器可以定义多个，（视图解析器不会处理ModelAndView中已经设置了View的请求，因为已经有View来处理了，那当然就不需要它来解析到真正的视图View啦）编写Controller控制器这里我们使用例子的形式来说明 实现一个控制器类@Controller

@RequestMapping("/user")

public class UserControl {

}
 只要给类加上Controller的注解，并放在被扫描的包中，那么这个类就是一个控制器了，RequestMapping表明匹配的路径，可以写在类或者类的方法上，如果类上面有RequestMapping注解，那么其下面的方法就是相对于类上面注解地址的一个相对路径  定义一个接管请求的方法方法名：无任何要求--------------------------------------------------------------参数：(顺序以及个数无任何要求)HttpServletRequestHttpServletResponsePrintWriter             相当于HttpResponse.getWriter()获得的对象Map                       其实是获得了ModelAndView中的ModelBindingResult           绑定数据的处理结果HttpSession             如果使用此参数，需要注意如果是第一次访问还没有session的话会报错@PathVariable           用于接收路径变量@RequestParam         相当于调用request.getParameter(“name”)方法@CookieValue           获取cookie的值@RequestHeader        获取header中的值实体对象              会根据请求的参数名，注入到这个对象对于得属性中，必须提供set方法等等等等等--------------------------------------------------------------返回值：void                 返回值是void，如果接收了PrintWriter 或者  HttpServletResponse 参数，那么返回的ModelAndView就是null，也就是直接将输出流输出到客户端，如果方法没有接收输出参数，后面会默认生成一个视图名 String                视图逻辑名 ModelAndView        是一个视图逻辑名+Map的封装类其他任意类型         存入ModelAndView中的Model-------------------------------------------------------------- 不管我们的返回类型是什么，返回值会通过处理，最终返回一个ModelAndView或者null例1:给方法定义一个请求映射并使用路径变量    @RequestMapping("/id/{userid}/name/{username}")

    public String queryUser(@PathVariable("userid") long userID

           , @PathVariable("username") String userName

           , Map<String, User> model) {

      

       User user = new User();

       user.setUserID(userID);

       user.setUserName(userName);

      

       model.put("userInfo", user);

      

       return "Home";

    }
  @RequestMapping定义路由映射，其中{userid} {username} 是PathVariable(路径变量)这样我们只需访问 http://localhost:8080/SpringMVC/user/id/10001/name/liudehua 就能进入上面的方法RequestMapping还可以使用通配符，如： /test/*/name/{name}例2:接受请求参数@RequestMapping("/save")

    public String save(@RequestParam("userName") String userName

           ,@RequestParam("Age") int age) {

      

       System.out.println(userName);

       System.out.println(age);

      

       return "Home";

    }
   例3:请求参数直接注入到Model@RequestMapping("/save")

    public String save(User user) {

      

       System.out.println(user.getUserID());

       System.out.println(user.getUserName());

      

       return "Home";

    }
  例4:转发与重定向转发：   (相当于 request.getRequestDispatcher(“”).forward(request, response))return “forward:/user/test”; 重定向： (相当于response.redirect(“”))return “redirect:/user/test”return “redirect:http://www.google.com.hk”; 例5:根据HttpMethod来过滤请求@RequestMapping(value="", method=RequestMethod.POST)    public String Test(//…) {       //…}  例6:根据参数来进行过滤@RequestMapping(params="hello=world", method={RequestMethod.GET, RequestMethod.POST})  public String helloworld() {}  必须有个hello的参数并且名称为world，而且只能是get或post请求才会进入此方法   

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

Content模块设计意图

Content 模块概述


“content”模块放在src \content里面，并使用多进程浏览器沙盒模块来呈现页面所需的核心代码。它包括所有的网络平台功能（如HTML5）和GPU加速。它不包括Chrome浏览器的功能，即扩展/自动填充/拼写等。它的目标是，任何嵌入者或者说使用者应该能够用它来开始建立一个浏览器，然后从中挑选Chrome功能。


动机是什么？


由于Chrome代码的不断壮大，功能不可避免地有时候会放在错误的地方，从而导致分层规则的不规范，以及不应该存在的依赖关系。它已经很难为开发者找出最好的方法，因为这些API和功能都在同一个目录下。为了避免这种情况发生，并增加核心部分的代码，Chrome采用多进程浏览器并对呈现页面的工作明确分工，把核心浏览器代码转移​​到src\content里面。


content 还是Chrome？


content应该只是呈现页面所需的核心代码。 Chrome功能由content提供的API来过滤IPC，以及得到事件通知。


举一个例子好了，下面是一个Chrome功能列表部分。它们并不在content里面，这意味着content的代码不应该知道他们，content只需要提供通用的API，Chrome的那些功能可以基于这些API来编写：

ExtensionsNaClChromeFrameSpellCheckAutofillSyncPrerenderingSafe BrowsingTranslate


体系结构图






上图显示了不同模块的层次结构。一个模块可以直接包括较低的模块代码。模块可以不包括一个比它更高模块的代码。这是通过DEPS规则强制执行实现的。模块可以实现嵌入者比如Chrome的API，使低于自己的模块可以调用自己。这些API的实例是WebKit的API和content的API。


Content API


Content API 告诉我们如何基于content来间接调用浏览器。如果可能的话，Chrome功能尝试通过IPC过滤，监听事件来设置钩子。如果没有足够的上下文（比如WebKit的回调），或在回调是一次性的情况下，chromium有一个ContentClient接口，嵌入者（Chrome浏览器）实现好了的。 ContentClient在所有进程里都是可用的，一些进程也有自己的回调API，比如 ContentBrowserClient / ContentRendererClient / ContentPluginClient等等。






部分参考：http://www.chromium.org/developers/content-module


本文属原创，转载请注明出处，违者必究

关注chromium群480089700，或者微信公众平台:程序员互动联盟(coder_online)，你可以第一时间获取原创技术文章，和（java/C/C++/Android/Windows/Linux）技术大牛做朋友，在线交流编程经验，获取编程基础知识，解决编程问题。程序员互动联盟，开发人员自己的家。








版权声明：本文为博主原创文章，未经博主允许不得转载。

Spring MVC入门案例（2）
以下这个学习案例是我最近学习Spring MVC时跟从一本书上的示例，原文中的示例代码有一些小错误，不过我在调试的过程中已经给予了修正，如还有其它错误，还请各位批评指正。对于现有较成熟的Model-View-Control(MVC)框架而言，其解决的主要问题无外乎下面几部分：1． 将Web页面中的输入元素封装为一个（请求）数据对象。2． 根据请求的不同，调度相应的逻辑处理单元，并将（请求）数据对象作为参数传入。3． 逻辑处理单元完成运算后，返回一个结果数据对象。4． 将结果数据对象中的数据与预先设计的表现层相融合并展现给用户。各个MVC 实现固然存在差异，但其中的关键流程大致如上。结合一个实例，我们来看看这几个关键流程在Spring MVC框架中的处理手法。下面的实例，实现了一个常见的用户登录逻辑，即用户通过用户名和密码登录，系统对用户名和密码进行检测，如果正确，则在页面上显示几条通知信息。如果登录失败，则返回失败界面。(示例中，表示层以JSP2.0实现。)出于简洁考虑，这里的“用户名/密码”检测以及通知信息的生成均在代码中以硬编码实现。首先来看登录界面：对应的index.html:<html>

<body>

<form method="POST" action="login.do">

<p align="center">登录</p>

<br>

用户名:

<input type="text" name="username" >

<br>

密 码 :

<input type="password" name="password" >

<br>

<p>

<input type="submit" value="提交" name="B1">

<input type="reset" value="重置" name="B2">

</p>

</form>

</body>

</html>
很简单的一个登录界面，其中包含了一个用以输入用户名密码的form，针对此form的提交将被发送到"login.do"MVC 关键流程的第一步，即收集页面输入参数，并转换为请求数据对象。这个静态页面提供了一个基本的输入界面，下面这些输入的数据将被发送至何处，将如何被转换为请求数据对象？现在来看接下来发发生的事情：当用户输入用户名密码提交之后，此请求被递交给Web 服务器处理，上面我们设定form提交目标为"login.do"，那么Web服务器将如何处理这个请求？显然，标准Http 协议中，并没有以.do 为后缀的服务资源，这是我们自己定义的一种请求匹配模式。此模式在web.xml中设定：<?xml version="1.0" encoding="ISO-8859-1"?>

<web-app xmlns="http://java.sun.com/xml/ns/j2ee"

xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee

http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"

version="2.4">

<servlet> ⑴

<servlet-name>Dispatcher</servlet-name>

<servlet-class>

org.springframework.web.servlet.DispatcherServlet

</servlet-class>

<init-param>

<param-name>contextConfigLocation</param-name>

<param-value>/WEB-INF/Config.xml</param-value>

</init-param>

</servlet>

<servlet-mapping> ⑵

<servlet-name>Dispatcher</servlet-name>

<url-pattern>*.do</url-pattern>

</servlet-mapping>

</web-app>
⑴ Servlet定义这里我们定义了请求分发Servlet，即：org.springframework.web.servlet.DispatcherServletDispatcherServlet 是Spring MVC 中负责请_____求调度的核心引擎，所有的请求将由此Servlet 根据配置分发至各个逻辑处理单元。其内部同时也维护了一个ApplicationContext实例。我们在<init-param>节点中配置了名为“contextConfigLocation”的Servlet参数，此参数指定了Spring配置文件的位置“/WEB-INF/Config.xml”。如果忽略此设定，则默认为“/WEB-INF/<servlet name>-servlet.xml”，其中<servlet name>以Servlet 名替换（在当前环境下，默认值也就是“/WEB-INF/Dispatcher-servlet.xml）。⑵ 请求映射我们将所有以.do结尾的请求交给Spring MVC进行处理。当然，也可以设为其他值，如.action、.action等。通过以上设定，Web 服务器将把登录界面提交的请求转交给Dispatcher 处理，Dispatcher将提取请求（HttpServletRequest）中的输入数据，分发给对应的处理单元，各单元处理完毕后，将输出页面返回给Web服务器，再由Web服务器返回给用户浏览器。Dispatcher 根据什么分发这些请求？显然，我们还需要一个配置文件加以设定。这也就是上面提及的Config.xml，此文件包含了所有的“请求/处理单元”关系映射设定，以及返回时表现层的一些属性设置。<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"

"http://www.springframework.org/dtd/spring-beans.dtd">

<beans>

<!--Definition of View Resolver -->

<bean id="viewResolver" ⑴

class="org.springframework.web.servlet.view.InternalResou

rceViewResolver">

<property name="viewClass"> ⑵

<value>

org.springframework.web.servlet.view.JstlView

</value>

</property>

<property name="prefix"> ⑶

<value>

/WEB-INF/view/

</value>

</property>

<property name="suffix"> ⑷

<value>.jsp</value>

</property>

</bean>

<!--Request Mapping -->

<bean id="urlMapping" ⑸

class="org.springframework.web.servlet.handler.SimpleUr

lHandlerMapping">

<property name="mappings">

<props>

<prop key="/login.do">LoginAction</prop>

</props>

</property>

</bean>

<!---Action Definition-->

<bean id="LoginAction" ⑹

class="net.xiaxin.action.LoginAction">

<property name="commandClass"> ⑺

<value>net.xiaxin.action.LoginInfo</value>

</property>

<property name="fail_view"> ⑻

<value>loginfail</value>

</property>

<property name="success_view">

<value>main</value>

</property>

</bean>

</beans>
⑴ Resolver设定Resolver将把输出结果与输出界面相融合，为表现层提供呈现资源。⑵ View Resolver的viewClass参数这里我们使用JSP页面作为输出，因此，设定为：org.springframework.web.servlet.view.JstlView其余可选的viewClass还有:Ø org.springframework.web.servlet.view.freemarker.FreeMarkerView（用于基于FreeMarker模板的表现层实现）Ø org.springframework.web.servlet.view.velocity.VelocityView（用于基于velocity模板的表现层实现）等。⑶⑷ View Resolver的prefix和suffix参数指定了表现层资源的前缀和后缀，运行时，Spring 将为指定的表现层资源自动追加前缀和后缀，以形成一个完整的资源路径。另参见⑻⑸ “请求/处理单元”关系映射可以看到，这里我们将“/login.do”请求映射到处理单元LoginAction。<props>节点下可以有多个映射关系存在，目前我们只定义了一个。⑹ LoginAction定义这里定义了逻辑处理单元LoginAction 的具体实现，这里，LoginAction 的实现类为net.xiaxin.action.LoginAction。⑺ LoginAction的请求数据对象commandClass 参数源于LoginAction 的基类BaseCommandController，BaseCommandControlle 包含了请求数据封装和验证方法（ BaseCommandController.bindAndValidate ） ， 它将根据传入的HttpServletRequest构造请求数据对象。这里我们指定commandClass 为net.xiaxin.action.LoginInfo，这是一个非常简单的Java Bean，它封装了登录请求所需的数据内容：public class LoginInfo {

private String username;

private String password;

public String getPassword() {

return password;

}

public void setPassword(String password) {

this.password = password;

}

public String getUsername() {

return username;

}

public void setUsername(String username) {

this.username = username;

}

}
Spring会根据LoginAction的commandClass定义自动加载对应的LoginInfo实例。之后，对Http 请求中的参数进行遍历，并查找LoginInfo 对象中是否存在与之同名的属性，如果找到，则将此参数值复制到LoginInfo对象的同名属性中.请求数据转换完成之后，我们得到了一个封装了所有请求参数的Java 对象，并将此对象作为输入参数传递给LoginAction。⑻ 返回视图定义对于这里的LoginAction 而言，有两种返回结果，即登录失败时返回错误界面，登录成功时进入系统主界面。对应我们配置了fail_view、success_view两个自定义参数。参数值将由Resolver进行处理，为其加上前缀后缀，如对于fail_view而言，实际的视图路径为/WEB-INF/view/loginfail.jsp。之后，Resolver 会将LoginAction的返回数据与视图相融合，返回最终的显示界面。业务逻辑处理单元:LoginAction.java：

public class LoginAction extends SimpleFormController {

private String fail_view;

private String success_view;

protected ModelAndView onSubmit( ⑴

Object cmd,

BindException ex

)throws Exception {

LoginInfo loginInfo = (LoginInfo) cmd; ⑵

HashMap result_map = new HashMap();

if (login(loginInfo) == 0) {

result_map.put("logininfo", loginInfo);

List msgList = new LinkedList();

msgList.add("msg1");

msgList.add("msg2");

msgList.add("msg3");

result_map.put("messages", msgList);

return new

ModelAndView(this.getSuccess_view(), result_map); ⑶

} else {

result_map.put("failmsg", new String("Sorry, you input the wrong username or password!"));

return new ModelAndView(this.getFail_view(), result_map);

}

}

private int login(LoginInfo loginInfo) {

if ("Erica".equalsIgnoreCase(loginInfo.getUsername())

&&"mypass".equals(loginInfo.getPassword())) {

return 0;

}

return 1;

}

public String getFail_view() {

return fail_view;

}

public String getSuccess_view() {

return success_view;

}

public void setFail_view(String string) {

fail_view = string;

}

public void setSuccess_view(String string) {

success_view = string;

}

}
其中：⑴ onSubmit方法我们在子类中覆盖了父类的onSubmit方法；而onSubmit方法用于处理业务请求。负责数据封装和请求分发的Dispatcher，将对传入的HttpServletRequest进行封装，形成请求数据对象，之后根据配置文件，调用对应业务逻辑类的入口方法（这里就是LoginAction）的onSubmit()方法，并将请求数据对象及其他相关资源引用传入。protected ModelAndView onSubmit(Object cmd,BindException ex)onSubmit方法包含了两个参数：Object cmd和BindException ex。前面曾经多次提到请求数据对象，这个名为cmd的Object型参数，正是传入的请求数据对象的引用。BindException ex参数则提供了数据绑定错误的跟踪机制。它作为错误描述工具，用于向上层反馈错误信息。在Spring MVC中，BindException将被向上层表现层反馈，以便在表现层统一处理异常情况（如显示对应的错误提示），这一机制稍后在“输入参数合法性校验”部分再具体探讨。onSubmit还有另外一个签名版本：protected ModelAndView onSubmit(

HttpServletRequest request,

HttpServletResponse response,

Object cmd,

BindException ex

)
可以看到，类似Servlet的doGet/doPost方法，此版本的onSubmit方法签名中包含了Servlet规范中的HttpServletRequest、HttpServletResponse以提供与Web服务器的交互功能（如Session的访问）。此参数类型的onSubmit方法的调用优先级较高。也就是说，如果我们在子类中同时覆盖了这两个不同参数的onSubmit方法，那么只有此版本的方法被执行，另一个将被忽略。⑵ 将输入的请求数据对象强制转型为预定义的请求对象类型。⑶ 返回处理结果ModelAndView类包含了逻辑单元返回的结果数据集和表现层信息。ModelAndView本身起到关系保存的作用。它将被传递给Dispatcher，由Dispatcher 根据其中保存的结果数据集和表现层设定合成最后的界面。这里我们用到了两种签名版本的ModelAndView构造方法：Ø public ModelAndView(String viewname)返回界面无需通过结果数据集进行填充。Ø public ModelAndView(String viewname, Map model)返回界面由指定的结果数据集加以填充。可以看到，结果数据集采用了Map接口实现的数据类型。其中包含了返回结果中的各个数据单元。关于结果数据集在界面中的填充操作，可参见下面关于返回界面的描述。上面这两个版本的构造子中，通过viewname指定了表示层资源。另外，我们也可以通过传递View对象指定表示层资源。Ø public ModelAndView(View view)Ø public ModelAndView(View view, Map model)我们可以结合RedirectView完成转向功能，如：return new ModelAndView(new RedirectView(“/redirected.jsp”));当然，我们也可以在带有HttpServletRequest参数的onSubmit方法实现中，通过HttpServletRequest/HttpServletResponse完成forward/redirect功能，这两种途径可以达到同样的效果。最后，来看返回界面：错误返回界面loginfail.jsp只是个纯html文件（为了与View Resolver中设定的后缀相匹配，因此以.jsp作为文件后缀），这里就不再浪费篇幅。再看成功登录后的页面main.jsp:界面显示效果如下：<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt" %>

<html>

<body>

<p>Login Success!!!</p>

<p>Current User:

<c:out value="${logininfo.username}"/><br>

</p>

<p>Your current messages:</p>

<c:forEach items="${messages}"

var="item"

begin="0"

end="9"

step="1"

varStatus="var">

<c:if test="${var.index % 2 == 0}">

*

</c:if>

${item}<br>

</c:forEach>

</body>

</html>
登录失败后的页面loginfail.jsp:<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt"%><html><body><p>Login Fail!!!</p><c:out value="${failmsg}"/></body></html> 页面逻辑非常简单，首先显示当前登录用户的用户名。然后循环显示当前用户的通知消息“messages”。如果当前循环索引为奇数，则在消息前追加一个“*”号（这个小特性在这里似乎有些多余，但却为不熟悉JSTL 的读者提供了如何使用JSTL Core taglib 进行循环和逻辑判断的样例）。实际上这只是个普通JSTL/JSP页面，并没有任何特殊之处，如果说有些值得研究的技术，也就是其中引用的JSTL Core Taglib<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt" %>上面这句话申明了页面中所引用的taglib，指定其前缀为“c”，也就是说，在页面中，所有以“c”为前缀，形同<c:xxxx>的节点都表明是此taglib的引用，在这里，也就是对JSTLCore Lib的引用。这里需要注意的是，笔者所采用的Web 容器为Tomcat 5(支持Servlet 2.4/JSP2.0规范)以及Apache JSTL 2.0(http://jakarta.apache.org/taglibs/index.html)。<c:out value="${logininfo.username}"/><c:out>将value 中的内容输出到当前位置，这里也就是把logininfo 对象的username属性值输出到页面当前位置。${……}是JSP2.0 中的Expression Language（EL）的语法。它定义了一个表达式，其中的表达式可以是一个常量（如上），也可以是一个具体的表达语句（如forEach循环体中的情况）。典型案例如下：Ø ${logininfo.username}这表明引用logininfo 对象的username 属性。我们可以通过“.”操作符引用对象的属性，也可以用“[]”引用对象属性，如${logininfo[username]}与${logininfo.username}达到了同样的效果。“[]”引用方式的意义在于，如果属性名中出现了特殊字符，如“.”或者“-”，此时就必须使用“[]”获取属性值以避免语法上的冲突（系统开发时应尽量避免这一现象的出现）。与之等同的JSP Script大致如下：LoginInfo logininfo =(LoginInfo)session.getAttribute(“logininfo”);String username = logininfo.getUsername();可以看到，EL大大节省了编码量。这里引出的另外一个问题就是，EL 将从哪里找到logininfo 对象，对于${logininfo.username}这样的表达式而言，首先会从当前页面中寻找之前是否定义了变量logininfo，如果没有找到则依次到Request、Session、Application 范围内寻找，直到找到为止。如果直到最后依然没有找到匹配的变量，则返回null.如果我们需要指定变量的寻找范围，可以在EL表达式中指定搜寻范围：${pageScope.logininfo.username}${requestScope.logininfo.username}${sessionScope.logininfo.username}${applicationScope.logininfo.username}在Spring 中，所有逻辑处理单元返回的结果数据，都将作为Attribute 被放置到HttpServletRequest 对象中返回（具体实现可参见Spring 源码中org.springframework.web.servlet.view.InternalResourceView.exposeModelAsRequestAttributes方法的实现代码），也就是说SpringMVC 中，结果数据对象默认都是requestScope。因此，在Spring MVC 中，以下寻址方法应慎用：${sessionScope.logininfo.username}${applicationScope.logininfo.username}Ø ${1＋2}结果为表达式计算结果，即整数值3。Ø ${i>1}如果变量值i>1的话，将返回bool类型true。与上例比较，可以_____发现EL会自动根据表达式计算结果返回不同的数据类型。表达式的写法与java代码中的表达式编写方式大致相同。<c:forEach items="${messages}"var="item"begin="0"end="9"step="1"varStatus="var">……</c:forEach>上面这段代码的意思是针对messages 对象进行循环，循环中的每个循环项的引用变量为item，循环范围是从0到9，每次步长为1。而varStatus则定义了一个循环状态变量var，循环状态变量中保存了循环进行时的状态信息，包括以下几个属性：属性 类型 说明index int 当前循环索引号count int 成员总数first boolean 当前成员是否首位成员last boolean 当前成员是否末尾成员再看：<c:if test="${var.index % 2 == 0}">*</c:if>这段代码演示了判定Tag <c:if>的使用方法。可以看到，其test属性指明了判定条件，判定条件一般为一个EL表达式。<c:if>并没有提供else子句，使用的时候可能有些不便，此时我们可以通过<c:choose>tag来达到类似的目的：<c:choose><c:when test="${var.index % 2 == 0}">*</c:when><c:otherwise>!</c:otherwise></c:choose>类似Java 中的switch 语句，<c:choose>提供了复杂判定条件下的简化处理手法。其中 <c:when>子句类似case子句，可以出现多次。上面的代码，在奇数行时输出“*”号，而偶数行时输出“!”。通过<c:choose>改造后的输出页面：至此，一个典型的请求/响应过程结束。通过这个过程，我们也了解了Spring MVC 的核心实现机制。对其进行总结，得到以下UML序列图：

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

java excel Workbook API
     1. int getNumberOfSheets()
　　获得工作薄（Workbook）中工作表（Sheet）的个数，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
int sheets = rwb.getNumberOfSheets();




　　2. Sheet[] getSheets()
　　返回工作薄（Workbook）中工作表（Sheet）对象数组，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
Sheet[] sheets = rwb.getSheets();




　　3. String getVersion()
　　返回正在使用的API的版本号，好像是没什么太大的作用。





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
String apiVersion = rwb.getVersion();




　　Sheet接口提供的方法

　　1) String getName()
　　获取Sheet的名称，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
String sheetName = rs.getName();




　　2) int getColumns()
　　获取Sheet表中所包含的总列数，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
int rsColumns = rs.getColumns();




　　3) Cell[] getColumn(int column)

　　获取某一列的所有单元格，返回的是单元格对象数组，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
Cell[] cell = rs.getColumn(0);




　　4) int getRows()
　　获取Sheet表中所包含的总行数，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
int rsRows = rs.getRows();




　　5) Cell[] getRow(int row)
　　获取某一行的所有单元格，返回的是单元格对象数组，示例子：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
Cell[] cell = rs.getRow(0);




　　6) Cell getCell(int column, int row)
　　获取指定单元格的对象引用，需要注意的是它的两个参数，第一个是列数，第二个是行数，这与通常的行、列组合有些不同。





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
Cell cell = rs.getCell(0, 0);




　　2、生成新的Excel工作薄

　　下面的代码主要是向大家介绍如何生成简单的Excel工作表，在这里单元格的内容是不带任何修饰的(如：字体，颜色等等)，所有的内容都作为字符串写入。(完整代码见ExcelWriting.java)

　　与读取Excel工作表相似，首先要使用Workbook类的工厂方法创建一个可写入的工作薄(Workbook)对象，这里要注意的是，只能通过API提供的工厂方法来创建Workbook，而不能使用WritableWorkbook的构造函数，因为类WritableWorkbook的构造函数为protected类型。示例代码片段如下：





import java.io.*;
import jxl.*;
import jxl.write.*;
… … … …
try
{
//构建Workbook对象, 只读Workbook对象
//Method 1：创建可写入的Excel工作薄
jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(new File(targetfile));

//Method 2：将WritableWorkbook直接写入到输出流

}
catch (Exception e)
{
e.printStackTrace();
}




　　API提供了两种方式来处理可写入的输出流，一种是直接生成本地文件，如果文件名不带全路径的话，缺省的文件会定位在当前目录，如果文件名带有全路径的话，则生成的Excel文件则会定位在相应的目录；另外一种是将Excel对象直接写入到输出流，例如：用户通过浏览器来访问Web服务器，如果HTTP头设置正确的话，浏览器自动调用客户端的Excel应用程序，来显示动态生成的Excel电子表格。

　　接下来就是要创建工作表，创建工作表的方法与创建工作薄的方法几乎一样，同样是通过工厂模式方法获得相应的对象，该方法需要两个参数，一个是工作表的名称，另一个是工作表在工作薄中的位置，参考下面的代码片段：





//创建Excel工作表
jxl.write.WritableSheet ws = wwb.createSheet("Test Sheet 1", 0);

"这锅也支好了，材料也准备齐全了，可以开始下锅了！"，现在要做的只是实例化API所提供的Excel基本数据类型，并将它们添加到工作表中就可以了，参考下面的代码片段：
//1.添加Label对象
jxl.write.Label labelC = new jxl.write.Label(0, 0, "This is a Label cell");
ws.addCell(labelC);

//添加带有字型Formatting的对象
jxl.write.WritableFont wf = new jxl.write.WritableFont(WritableFont.TIMES, 18, WritableFont.BOLD, true);
jxl.write.WritableCellFormat wcfF = new jxl.write.WritableCellFormat(wf);
jxl.write.Label labelCF = new jxl.write.Label(1, 0, "This is a Label Cell", wcfF);
ws.addCell(labelCF);

//添加带有字体颜色Formatting的对象
jxl.write.WritableFont wfc = new jxl.write.WritableFont(WritableFont.ARIAL, 10, WritableFont.NO_BOLD, false,
Underlinestyle.NO_UNDERLINE, jxl.format.Colour.RED);
jxl.write.WritableCellFormat wcfFC = new jxl.write.WritableCellFormat(wfc);
jxl.write.Label labelCFC = new jxl.write.Label(1, 0, "This is a Label Cell", wcfFC);
ws.addCell(labelCF);

//2.添加Number对象
jxl.write.Number labelN = new jxl.write.Number(0, 1, 3.1415926);
ws.addCell(labelN);

//添加带有formatting的Number对象
jxl.write.NumberFormat nf = new jxl.write.NumberFormat("#.##");
jxl.write.WritableCellFormat wcfN = new jxl.write.WritableCellFormat(nf);
jxl.write.Number labelNF = new jxl.write.Number(1, 1, 3.1415926, wcfN);
ws.addCell(labelNF);

//3.添加Boolean对象
jxl.write.Boolean labelB = new jxl.write.Boolean(0, 2, false);
ws.addCell(labelB);

//4.添加DateTime对象
jxl.write.DateTime labelDT = new jxl.write.DateTime(0, 3, new java.util.Date());
ws.addCell(labelDT);

//添加带有formatting的DateFormat对象
jxl.write.DateFormat df = new jxl.write.DateFormat("dd MM yyyy hh:mm:ss");
jxl.write.WritableCellFormat wcfDF = new jxl.write.WritableCellFormat(df);
jxl.write.DateTime labelDTF = new jxl.write.DateTime(1, 3, new java.util.Date(), wcfDF);
ws.addCell(labelDTF);




　　这里有两点大家要引起大家的注意。第一点，在构造单元格时，单元格在工作表中的位置就已经确定了。一旦创建后，单元格的位置是不能够变更的，尽管单元格的内容是可以改变的。第二点，单元格的定位是按照下面这样的规律(column, row)，而且下标都是从0开始，例如，A1被存储在(0, 0)，B1被存储在(1, 0)。

　　最后，不要忘记关闭打开的Excel工作薄对象，以释放占用的内存，参见下面的代码片段：





//写入Exel工作表
wwb.write();

//关闭Excel工作薄对象
wwb.close();




　　这可能与读取Excel文件的操作有少少不同，在关闭Excel对象之前，你必须要先调用write()方法，因为先前的操作都是存储在缓存中的，所以要通过该方法将操作的内容保存在文件中。如果你先关闭了Excel对象，那么只能得到一张空的工作薄了。

　　3、拷贝、更新Excel工作薄

　　接下来简要介绍一下如何更新一个已经存在的工作薄，主要是下面二步操作，第一步是构造只读的Excel工作薄，第二步是利用已经创建的Excel工作薄创建新的可写入的Excel工作薄，参考下面的代码片段：(完整代码见ExcelModifying.java)





//创建只读的Excel工作薄的对象
jxl.Workbook rw = jxl.Workbook.getWorkbook(new File(sourcefile));

//创建可写入的Excel工作薄对象
jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(new File(targetfile), rw);

//读取第一张工作表
jxl.write.WritableSheet ws = wwb.getSheet(0);

//获得第一个单元格对象
jxl.write.WritableCell wc = ws.getWritableCell(0, 0);

//判断单元格的类型, 做出相应的转化
if(wc.getType() == CellType.LABEL)
{
Label l = (Label)wc;
l.setString("The value has been modified.");
}

//写入Excel对象
wwb.write();

//关闭可写入的Excel对象
wwb.close();

//关闭只读的Excel对象
rw.close();




　　之所以使用这种方式构建Excel对象，完全是因为效率的原因，因为上面的示例才是API的主要应用。为了提高性能，在读取工作表时，与数据相关的一些输出信息，所有的格式信息，如：字体、颜色等等，是不被处理的，因为我们的目的是获得行数据的值，既使没有了修饰，也不会对行数据的值产生什么影响。唯一的不利之处就是，在内存中会同时保存两个同样的工作表，这样当工作表体积比较大时，会占用相当大的内存，但现在好像内存的大小并不是什么关键因素了。

　　一旦获得了可写入的工作表对象，我们就可以对单元格对象进行更新的操作了，在这里我们不必调用API提供的add()方法，因为单元格已经于工作表当中，所以我们只需要调用相应的setXXX()方法，就可以完成更新的操作了。

　　尽单元格原有的格式化修饰是不能去掉的，我们还是可以将新的单元格修饰加上去，以使单元格的内容以不同的形式表现。

　　新生成的工作表对象是可写入的，我们除了更新原有的单元格外，还可以添加新的单元格到工作表中，这与示例2的操作是完全一样的。

　　最后，不要忘记调用write()方法，将更新的内容写入到文件中，然后关闭工作薄对象，这里有两个工作薄对象要关闭，一个是只读的，另外一个是可写入的。

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDFS源码分析(五)-----节点注册与心跳机制
前言在Hadoop的HDFS启动的时候,不知道大家有没有注意到一个细节,一般都是先启动NameNode,然后再启动DataNode,细想一下,原因就很简单了,因为NameNode要维护元数据信息,而这些信息都是要等待后续启动的DataNode的情况汇报才能逐步构建的.然后之后通过保持心跳的形式进行block块映射关系的维护与更新.而今天的文章就以此方面,对这块流程做全面的分析.相关涉及类依旧需要介绍一下相关的涉及类,首先要有一个大概的了解.下面是主要的类:1.DataNode--数据节点类,这个和之前的数据节点描述符类又又有点不同,里面也定义了许多与数据节点相关的方法.2.NaemNode--名字节点类,注册信息的处理以及心跳包的处理都需要名字节点处理,名字节点的处理方法会调用FSNamesystem大系统中的方法.3.DatanodeCommand以及BlockCommand--数据节点命令类以及他的子类,block相关命令类,此类用于名字节点心跳回复命令给数据节点时用的.4.FSNamesystem和DatanodeDescriptor--附属类,这些类中的某些方法会在上述过程中被用到.OK,涉及的类的总数也不多,下面讲述第一个流程,节点注册,数据节点是如何在启动的时候注册到名字节点的呢.节点注册节点的注册是在数据节点启动之后发生的,首先进入main主方法public static void main(String args[]) {
    secureMain(args, null);
  }然后进入secureMainpublic static void secureMain(String [] args, SecureResources resources) {
    try {
      StringUtils.startupShutdownMessage(DataNode.class, args, LOG);
      DataNode datanode = createDataNode(args, null, resources);
      if (datanode != null)
        datanode.join();
    } catch (Throwable e) {
      LOG.error(StringUtils.stringifyException(e));
      System.exit(-1);
    } finally {
      // We need to add System.exit here because either shutdown was called or
      // some disk related conditions like volumes tolerated or volumes required
      // condition was not met. Also, In secure mode, control will go to Jsvc and
      // the process hangs without System.exit.
      LOG.info("Exiting Datanode");
      System.exit(0);
    }
  }进入createDataNode方法,中间还会有1,2个方法,最终会调用到核心的runDatanodeDaemon()方法/** Start a single datanode daemon and wait for it to finish.
   *  If this thread is specifically interrupted, it will stop waiting.
   * 数据节点启动的核心方法
   */
  public static void runDatanodeDaemon(DataNode dn) throws IOException {
    if (dn != null) {
      //register datanode
      //首先注册节点
      dn.register();
      //后续开启相应线程
      dn.dataNodeThread = new Thread(dn, dnThreadName);
      dn.dataNodeThread.setDaemon(true); // needed for JUnit testing
      dn.dataNodeThread.start();
    }
  }于是就调用了register的方法/**
   * Register datanode
   * <p>
   * The datanode needs to register with the namenode on startup in order
   * 1) to report which storage it is serving now and 
   * 2) to receive a registrationID 
   * issued by the namenode to recognize registered datanodes.
   * 
   * @see FSNamesystem#registerDatanode(DatanodeRegistration)
   * @throws IOException
   * 数据节点的注册方法,会调用到namenode上的注册方法
   */
  private void register() throws IOException {
    if (dnRegistration.getStorageID().equals("")) {
      setNewStorageID(dnRegistration);
    }
    while(shouldRun) {
      try {
        // reset name to machineName. Mainly for web interface.
        dnRegistration.name = machineName + ":" + dnRegistration.getPort();
        //调用namenode上的注册方法
        dnRegistration = namenode.register(dnRegistration);
        break;
....然后这里,我们可以看到,注册方法实质上调用名字节点的注册方法.跟踪名字节点的同名法方法////////////////////////////////////////////////////////////////
  // DatanodeProtocol
  ////////////////////////////////////////////////////////////////
  /** 
   * 名字节点的注册方法,调用的是FSNameSystem方法
   */
  public DatanodeRegistration register(DatanodeRegistration nodeReg
                                       ) throws IOException {
    //首先做版本验证 
    verifyVersion(nodeReg.getVersion());
    //调用namesystem的注册节点方法
    namesystem.registerDatanode(nodeReg);
      
    return nodeReg;
  }名字节点调用的又是命名系统的方法，对注册节点的判断分为以下3种情况1、现有的节点进行新的存储ID注册2、现有节点的重复注册，由于集群已经保存有此信息，进行网络位置的更新即可3、从未注册过的节点，直接进行分配新的存储ID进行注册。具体方法判断如下，方法比较长/**
   * Register Datanode.
   * <p>
   * The purpose of registration is to identify whether the new datanode
   * serves a new data storage, and will report new data block copies,
   * which the namenode was not aware of; or the datanode is a replacement
   * node for the data storage that was previously served by a different
   * or the same (in terms of host:port) datanode.
   * The data storages are distinguished by their storageIDs. When a new
   * data storage is reported the namenode issues a new unique storageID.
   * <p>
   * Finally, the namenode returns its namespaceID as the registrationID
   * for the datanodes. 
   * namespaceID is a persistent attribute of the name space.
   * The registrationID is checked every time the datanode is communicating
   * with the namenode. 
   * Datanodes with inappropriate registrationID are rejected.
   * If the namenode stops, and then restarts it can restore its 
   * namespaceID and will continue serving the datanodes that has previously
   * registered with the namenode without restarting the whole cluster.
   * 
   * @see org.apache.hadoop.hdfs.server.datanode.DataNode#register()
   * 名字节点实现数据节点的注册操作
   */
  public synchronized void registerDatanode(DatanodeRegistration nodeReg
                                            ) throws IOException {
    String dnAddress = Server.getRemoteAddress();
    if (dnAddress == null) {
      // Mostly called inside an RPC.
      // But if not, use address passed by the data-node.
      dnAddress = nodeReg.getHost();
    }      

    // check if the datanode is allowed to be connect to the namenode
    if (!verifyNodeRegistration(nodeReg, dnAddress)) {
      throw new DisallowedDatanodeException(nodeReg);
    }

    String hostName = nodeReg.getHost();
      
    // update the datanode's name with ip:port
    DatanodeID dnReg = new DatanodeID(dnAddress + ":" + nodeReg.getPort(),
                                      nodeReg.getStorageID(),
                                      nodeReg.getInfoPort(),
                                      nodeReg.getIpcPort());
    nodeReg.updateRegInfo(dnReg);
    nodeReg.exportedKeys = getBlockKeys();
      
    NameNode.stateChangeLog.info(
                                 "BLOCK* NameSystem.registerDatanode: "
                                 + "node registration from " + nodeReg.getName()
                                 + " storage " + nodeReg.getStorageID());

    //取出主机相关信息
    DatanodeDescriptor nodeS = datanodeMap.get(nodeReg.getStorageID());
    DatanodeDescriptor nodeN = host2DataNodeMap.getDatanodeByName(nodeReg.getName());
    
    //判断此节点之前是否已经存在
    if (nodeN != null && nodeN != nodeS) {
     //此情况为数据节点存在,但是使用了新的存储ID
      NameNode.LOG.info("BLOCK* NameSystem.registerDatanode: "
                        + "node from name: " + nodeN.getName());
      // nodeN previously served a different data storage, 
      // which is not served by anybody anymore.
      //移动掉旧的datanodeID信息
      removeDatanode(nodeN);
      // physically remove node from datanodeMap
      //从物理层面的记录进行移除
      wipeDatanode(nodeN);
      nodeN = null;
    }
    
    //重复注册的情况
    if (nodeS != null) {
      if (nodeN == nodeS) {
        // The same datanode has been just restarted to serve the same data 
        // storage. We do not need to remove old data blocks, the delta will
        // be calculated on the next block report from the datanode
        NameNode.stateChangeLog.debug("BLOCK* NameSystem.registerDatanode: "
                                      + "node restarted.");
      } else {
        // nodeS is found
        /* The registering datanode is a replacement node for the existing 
          data storage, which from now on will be served by a new node.
          If this message repeats, both nodes might have same storageID 
          by (insanely rare) random chance. User needs to restart one of the
          nodes with its data cleared (or user can just remove the StorageID
          value in "VERSION" file under the data directory of the datanode,
          but this is might not work if VERSION file format has changed 
       */        
        NameNode.stateChangeLog.info( "BLOCK* NameSystem.registerDatanode: "
                                      + "node " + nodeS.getName()
                                      + " is replaced by " + nodeReg.getName() + 
                                      " with the same storageID " +
                                      nodeReg.getStorageID());
      }
      // update cluster map
      //更新集群的网络信息
      clusterMap.remove(nodeS);
      nodeS.updateRegInfo(nodeReg);
      nodeS.setHostName(hostName);
      
      // resolve network location
      resolveNetworkLocation(nodeS);
      clusterMap.add(nodeS);
        
      // also treat the registration message as a heartbeat
      synchronized(heartbeats) {
        if( !heartbeats.contains(nodeS)) {
          heartbeats.add(nodeS);
          //update its timestamp
          nodeS.updateHeartbeat(0L, 0L, 0L, 0);
          nodeS.isAlive = true;
        }
      }
      return;
    } 

    // this is a new datanode serving a new data storage
    //当此时确认为一个新的节点时,为新节点分配存储ID
    if (nodeReg.getStorageID().equals("")) {
      // this data storage has never been registered
      // it is either empty or was created by pre-storageID version of DFS
      nodeReg.storageID = newStorageID();
      NameNode.stateChangeLog.debug(
                                    "BLOCK* NameSystem.registerDatanode: "
                                    + "new storageID " + nodeReg.getStorageID() + " assigned.");
    }
    // register new datanode
    //创建新的节点
    DatanodeDescriptor nodeDescr 
      = new DatanodeDescriptor(nodeReg, NetworkTopology.DEFAULT_RACK, hostName);
    resolveNetworkLocation(nodeDescr);
    unprotectedAddDatanode(nodeDescr);
    clusterMap.add(nodeDescr);
      
    // also treat the registration message as a heartbeat
    //将注册信息加入到心跳
    synchronized(heartbeats) {
      heartbeats.add(nodeDescr);
      nodeDescr.isAlive = true;
      // no need to update its timestamp
      // because its is done when the descriptor is created
    }
    return;
  }移除原有信息的代码如下，还做了更新操作/**
   * remove a datanode descriptor
   * @param nodeInfo datanode descriptor
   */
  private void removeDatanode(DatanodeDescriptor nodeInfo) {
    synchronized (heartbeats) {
      if (nodeInfo.isAlive) {
      	//更新集群中的统计信息
        updateStats(nodeInfo, false);
        //从心跳列表信息中移除对于此节点的心跳信息
        heartbeats.remove(nodeInfo);
        nodeInfo.isAlive = false;
      }
    }

    //移除第二关系中数据块对于此节点的映射关系
    for (Iterator<Block> it = nodeInfo.getBlockIterator(); it.hasNext();) {
      removeStoredBlock(it.next(), nodeInfo);
    }
    unprotectedRemoveDatanode(nodeInfo);
    //从集群图中移除此节点信息
    clusterMap.remove(nodeInfo);
  }心跳机制心跳机制最简单的由来就是为了证明数据节点还活着，如果一段时间内datanode没有向namenode发送心跳包信息，就会被dead状态。并且datanode从心跳包回复中获取命令信息，然后进行下一步操作，所以从这里可以看出，心跳机制在整个HDFS系统中都有很重要的作用。下面一步步揭开HDFS心跳机制的实现。首先心跳信息是由数据节点发起的，主动方在Datanode上，就是下面这个方法/**
   * Main loop for the DataNode.  Runs until shutdown,
   * forever calling remote NameNode functions.
   * datanode在循环中不断向名字节点发送心跳信息 
   */
  public void offerService() throws Exception {
     
    LOG.info("using BLOCKREPORT_INTERVAL of " + blockReportInterval + "msec" + 
       " Initial delay: " + initialBlockReportDelay + "msec");

    //
    // Now loop for a long time....
    //

    while (shouldRun) {
      try {
        long startTime = now();

        //
        // Every so often, send heartbeat or block-report
        //
        
        if (startTime - lastHeartbeat > heartBeatInterval) {
          //
          // All heartbeat messages include following info:
          // -- Datanode name
          // -- data transfer port
          // -- Total capacity
          // -- Bytes remaining
          //
         //向名字节点发送此时节点的一些信息，dfs使用量，剩余使用量信息等
          lastHeartbeat = startTime;
          //调用namenode.sendHeartbeat进行心跳信息的发送，返回数据节点的操作命令
          DatanodeCommand[] cmds = namenode.sendHeartbeat(dnRegistration,
                                                       data.getCapacity(),
                                                       data.getDfsUsed(),
                                                       data.getRemaining(),
                                                       xmitsInProgress.get(),
                                                       getXceiverCount());
          myMetrics.addHeartBeat(now() - startTime);
          //LOG.info("Just sent heartbeat, with name " + localName);
          //进行返回命令的处理，如果没有成功不进行后续block块上报工作
          if (!processCommand(cmds))
            continue;
        }首先先观察前部分代码，可以看到，这是一个循环，而且是周期性的发送消息，然后调用namenode的方法进行心跳信息发送，然后接收DatanodeCommand回复命令，然后再本节点执行。然后，跟踪一下里面namenode的方法/**
   * Data node notify the name node that it is alive 
   * Return an array of block-oriented commands for the datanode to execute.
   * This will be either a transfer or a delete operation.
   * 数据节点调用此方法进行心跳信息的发送
   */
  public DatanodeCommand[] sendHeartbeat(DatanodeRegistration nodeReg,
                                       long capacity,
                                       long dfsUsed,
                                       long remaining,
                                       int xmitsInProgress,
                                       int xceiverCount) throws IOException {
    //对节点注册信息的确认
    verifyRequest(nodeReg);
    //然后再次调用fsnamesystem的handleHeartbeat方法
    return namesystem.handleHeartbeat(nodeReg, capacity, dfsUsed, remaining,
        xceiverCount, xmitsInProgress);
  }namenode调用的又是命名系统的方法/**
   * The given node has reported in.  This method should:
   * 1) Record the heartbeat, so the datanode isn't timed out
   * 2) Adjust usage stats for future block allocation
   * 
   * If a substantial amount of time passed since the last datanode 
   * heartbeat then request an immediate block report.  
   * 
   * @return an array of datanode commands 
   * @throws IOException
   * 一个给定的数据节点进行心跳信息的上报，主要做2个操作
   * 1.心跳信息的记录，避免数据节点超时
   * 2.调整新的名字节点中维护的数据块分配情况
   */
  DatanodeCommand[] handleHeartbeat(DatanodeRegistration nodeReg,
      long capacity, long dfsUsed, long remaining,
      int xceiverCount, int xmitsInProgress) throws IOException {
    DatanodeCommand cmd = null;
    synchronized (heartbeats) {
      synchronized (datanodeMap) {
        DatanodeDescriptor nodeinfo = null;
        try {
          nodeinfo = getDatanode(nodeReg);
        } catch(UnregisteredDatanodeException e) {
          return new DatanodeCommand[]{DatanodeCommand.REGISTER};
        }
          
        // Check if this datanode should actually be shutdown instead. 
        if (nodeinfo != null && shouldNodeShutdown(nodeinfo)) {
          setDatanodeDead(nodeinfo);
          throw new DisallowedDatanodeException(nodeinfo);
        }

        //如果不存在此节点信息，说明此节点还未注册，返回节点注册命令
        if (nodeinfo == null || !nodeinfo.isAlive) {
          return new DatanodeCommand[]{DatanodeCommand.REGISTER};
        }

        updateStats(nodeinfo, false);
        nodeinfo.updateHeartbeat(capacity, dfsUsed, remaining, xceiverCount);
        updateStats(nodeinfo, true);看前半段的代码分析，主要是做相应节点的信息更新，如果节点是未注册过的野节点的话，返回注册命令，但是还有下半段的操作，/**
   * The given node has reported in.  This method should:
   * 1) Record the heartbeat, so the datanode isn't timed out
   * 2) Adjust usage stats for future block allocation
   * 
   * If a substantial amount of time passed since the last datanode 
   * heartbeat then request an immediate block report.  
   * 
   * @return an array of datanode commands 
   * @throws IOException
   * 一个给定的数据节点进行心跳信息的上报，主要做2个操作
   * 1.心跳信息的记录，避免数据节点超时
   * 2.调整新的名字节点中维护的数据块分配情况
   */
  DatanodeCommand[] handleHeartbeat(DatanodeRegistration nodeReg,
      long capacity, long dfsUsed, long remaining,
      int xceiverCount, int xmitsInProgress) throws IOException {
   ........... 
        //check lease recovery
        //检查租约过期情况
        cmd = nodeinfo.getLeaseRecoveryCommand(Integer.MAX_VALUE);
        if (cmd != null) {
          return new DatanodeCommand[] {cmd};
        }
        
        //新建命令集合，心跳回复将返回许多的命令
        ArrayList<DatanodeCommand> cmds = new ArrayList<DatanodeCommand>();
        //check pending replication
        //获取待复制的副本块命令，命令中包含有副本块列表内容
        cmd = nodeinfo.getReplicationCommand(
              maxReplicationStreams - xmitsInProgress);
        if (cmd != null) {
          cmds.add(cmd);
        }
        //check block invalidation
        //块删除命令
        cmd = nodeinfo.getInvalidateBlocks(blockInvalidateLimit);
        if (cmd != null) {
          cmds.add(cmd);
        }
        // check access key update
        if (isAccessTokenEnabled && nodeinfo.needKeyUpdate) {
          cmds.add(new KeyUpdateCommand(accessTokenHandler.exportKeys()));
          nodeinfo.needKeyUpdate = false;
        }
        // check for balancer bandwidth update
        if (nodeinfo.getBalancerBandwidth() > 0) {
          cmds.add(new BalancerBandwidthCommand(nodeinfo.getBalancerBandwidth()));
          // set back to 0 to indicate that datanode has been sent the new value
          nodeinfo.setBalancerBandwidth(0);
        }
        if (!cmds.isEmpty()) {
          //返回命令组
          return cmds.toArray(new DatanodeCommand[cmds.size()]);
        }
      }
    }就是命名系统类会检查节点block情况，进行命令回复，比如添加需要复制的block请求，无效快的删除请求等等。下面是一个示例//与block命令相关的函数
  BlockCommand getReplicationCommand(int maxTransfers) {
  	//获取待复制的副本block块列表
    List<BlockTargetPair> blocktargetlist = replicateBlocks.poll(maxTransfers);
    //将变量保证在BlockCommand中进行返回
    return blocktargetlist == null? null:
        new BlockCommand(DatanodeProtocol.DNA_TRANSFER, blocktargetlist);
  }因为BlockCommand是DataCommand的子集，也是属于DatanodeCommand。在这里有必要了解一下，datanode执行命令的形式，首先是父类，比较简单一些//DatanodeCommand继承自Writable序列化类，说明命令是被序列化传输的
public abstract class DatanodeCommand implements Writable {
  static class Register extends DatanodeCommand {
    private Register() {super(DatanodeProtocol.DNA_REGISTER);}
    public void readFields(DataInput in) {}
    public void write(DataOutput out) {}
  }

  static class Finalize extends DatanodeCommand {
    private Finalize() {super(DatanodeProtocol.DNA_FINALIZE);}
    public void readFields(DataInput in) {}
    public void write(DataOutput out) {}
  }
  .....
  //action保存了命令操作类型
  private int action;
  
  .....
  
  ///////////////////////////////////////////
  // Writable
  ///////////////////////////////////////////
  //DatanodeCommand将命令操作写在序列化流中
  public void write(DataOutput out) throws IOException {
    out.writeInt(this.action);
  }
  
  public void readFields(DataInput in) throws IOException {
    this.action = in.readInt();
  }
}这里的action很重要，保存的就是命令的类型，同时，注意这些都是可序列化的，用于RPC传输。那么与Block相关的命令在上面做了哪些的改变才使得能把block块列表的信息也传入命令中呢，答案就在下面/****************************************************
 * A BlockCommand is an instruction to a datanode 
 * regarding some blocks under its control.  It tells
 * the DataNode to either invalidate a set of indicated
 * blocks, or to copy a set of indicated blocks to 
 * another DataNode.
 * 
 ****************************************************/
public class BlockCommand extends DatanodeCommand {
  Block blocks[];
  DatanodeInfo targets[][];

  public BlockCommand() {}

  /**
   * Create BlockCommand for transferring blocks to another datanode
   * @param blocktargetlist    blocks to be transferred 
   */
  public BlockCommand(int action, List<BlockTargetPair> blocktargetlist) {
    super(action);

    blocks = new Block[blocktargetlist.size()]; 
    targets = new DatanodeInfo[blocks.length][];
    for(int i = 0; i < blocks.length; i++) {
      BlockTargetPair p = blocktargetlist.get(i);
      blocks[i] = p.block;
      targets[i] = p.targets;
    }
  }

  private static final DatanodeInfo[][] EMPTY_TARGET = {};

  /**
   * Create BlockCommand for the given action
   * @param blocks blocks related to the action
   */
  public BlockCommand(int action, Block blocks[]) {
    super(action);
    this.blocks = blocks;
    this.targets = EMPTY_TARGET;
  }
  ......
  
  //重载序列化写入方法
  public void write(DataOutput out) throws IOException {
    super.write(out);
    out.writeInt(blocks.length);
    //将block块依次序列化写入
    for (int i = 0; i < blocks.length; i++) {
      blocks[i].write(out);
    }
    out.writeInt(targets.length);
    for (int i = 0; i < targets.length; i++) {
      out.writeInt(targets[i].length);
      for (int j = 0; j < targets[i].length; j++) {
        targets[i][j].write(out);
      }
    }
  }
OK，心跳回复命令已经清楚，看看数据节点如何执行命名节点返回的心跳命令然后做出调整。/**
   * Process an array of datanode commands
   * 
   * @param cmds an array of datanode commands
   * @return true if further processing may be required or false otherwise. 
   * 数据节点批量执行操作
   */
  private boolean processCommand(DatanodeCommand[] cmds) {
    if (cmds != null) {
      for (DatanodeCommand cmd : cmds) {
        try {
        	//在命令组中，只要有一条命令执行出错，整个执行过程就算失败
          if (processCommand(cmd) == false) {
            return false;
          }
        } catch (IOException ioe) {
          LOG.warn("Error processing datanode Command", ioe);
        }
      }
    }
    return true;
  }然后是单条命令执行，这才是我们想看到的/**
     * 
     * @param cmd
     * @return true if further processing may be required or false otherwise. 
     * @throws IOException
     * 调用单条命令处理方法
     */
  private boolean processCommand(DatanodeCommand cmd) throws IOException {
    if (cmd == null)
      return true;
    final BlockCommand bcmd = cmd instanceof BlockCommand? (BlockCommand)cmd: null;
    
    //取出命令的action值类型，进行分别判断处理
    switch(cmd.getAction()) {
    case DatanodeProtocol.DNA_TRANSFER:
      // Send a copy of a block to another datanode
      ....
      break;
    case DatanodeProtocol.DNA_INVALIDATE:
      //如果是无效块，则进行blockScanner类扫描删除操作
      //
      // Some local block(s) are obsolete and can be 
      // safely garbage-collected.
      //
      Block toDelete[] = bcmd.getBlocks();
      try {
        if (blockScanner != null) {
          blockScanner.deleteBlocks(toDelete);
        }
        data.invalidate(toDelete);
      } catch(IOException e) {
        checkDiskError();
        throw e;
      }
      myMetrics.incrBlocksRemoved(toDelete.length);
      break;
    case DatanodeProtocol.DNA_SHUTDOWN:
      ....
    case DatanodeProtocol.DNA_REGISTER:
      //如果是注册命令，则调用注册操作
      .....
      break;
    case DatanodeProtocol.DNA_FINALIZE:
      storage.finalizeUpgrade();
      break;
    case UpgradeCommand.UC_ACTION_START_UPGRADE:
      // start distributed upgrade here
      processDistributedUpgradeCommand((UpgradeCommand)cmd);
      break;
    case DatanodeProtocol.DNA_RECOVERBLOCK:
      recoverBlocks(bcmd.getBlocks(), bcmd.getTargets());
      break;
    case DatanodeProtocol.DNA_ACCESSKEYUPDATE:
      LOG.info("DatanodeCommand action: DNA_ACCESSKEYUPDATE");
      if (isBlockTokenEnabled) {
        blockTokenSecretManager.setKeys(((KeyUpdateCommand) cmd).getExportedKeys());
      }
      break;
    case DatanodeProtocol.DNA_BALANCERBANDWIDTHUPDATE:
      .....
    default:
      LOG.warn("Unknown DatanodeCommand action: " + cmd.getAction());
    }
    return true;
  }对每种命令，取出action值类别，进行分别处理。OK，到这里就处理完了前半部分代码所做的事情了，在后面会进行数据块上报的工作，准确的说，这方面的操作就不算是心跳机制里面的过程了，但是都是在一个大循环中进行的。//检测新接收到的block
        // check if there are newly received blocks
        Block [] blockArray=null;
        String [] delHintArray=null;
        synchronized(receivedBlockList) {
          synchronized(delHints) {
            int numBlocks = receivedBlockList.size();
            if (numBlocks > 0) {
              if(numBlocks!=delHints.size()) {
                LOG.warn("Panic: receiveBlockList and delHints are not of the same length" );
              }
              //
              // Send newly-received blockids to namenode
              //
              blockArray = receivedBlockList.toArray(new Block[numBlocks]);
              delHintArray = delHints.toArray(new String[numBlocks]);
            }
          }
        }
        if (blockArray != null) {
          if(delHintArray == null || delHintArray.length != blockArray.length ) {
            LOG.warn("Panic: block array & delHintArray are not the same" );
          }
          //将接收到的新block信息上报
          namenode.blockReceived(dnRegistration, blockArray, delHintArray);
          synchronized (receivedBlockList) {
            synchronized (delHints) {
              for(int i=0; i<blockArray.length; i++) {
                receivedBlockList.remove(blockArray[i]);
                delHints.remove(delHintArray[i]);
              }
            }
          }
        }数据节点进行心跳信息上传，名字节点如何判断节点是否长期没有上报心跳呢，在这之间必然会有监控线程，在命名系统类中，相关的变量/**
   * Stores a set of DatanodeDescriptor objects.
   * This is a subset of {@link #datanodeMap}, containing nodes that are 
   * considered alive.
   * The {@link HeartbeatMonitor} periodically checks for outdated entries,
   * and removes them from the list.
   * 是datanodeMap的子集，保存了节点中存活的节点集合，在HeartbeatMonitor中会被使用
   */
  ArrayList<DatanodeDescriptor> heartbeats = new ArrayList<DatanodeDescriptor>();此变量就代表着现有存活的节点列表/**
   * Periodically calls heartbeatCheck() and updateAccessKey()
   * 心跳监控线程
   */
  class HeartbeatMonitor implements Runnable {
  	//上次心跳的检测时间
    private long lastHeartbeatCheck;
    private long lastAccessKeyUpdate;
    /**
     */
    public void run() {
      while (fsRunning) {
        try {
          long now = now();
          if (lastHeartbeatCheck + heartbeatRecheckInterval < now) {
          	//如果在间隔时间内，做心跳检测
            heartbeatCheck();
            lastHeartbeatCheck = now;
          }
          if (isAccessTokenEnabled && (lastAccessKeyUpdate + accessKeyUpdateInterval < now)) {
            updateAccessKey();
            lastAccessKeyUpdate = now;
          }
        } catch (Exception e) {
          FSNamesystem.LOG.err上面是监控线程的执行方法，在做心跳检测的方法时，作者采用了一种很有远见的想法，采用了故障寻找，故障分离的办法，原因是考虑到分布式系统的负载情况，以及对于系统整体性能的影响，下面是故障寻找/**
   * Check if there are any expired heartbeats, and if so,
   * whether any blocks have to be re-replicated.
   * While removing dead datanodes, make sure that only one datanode is marked
   * dead at a time within the synchronized section. Otherwise, a cascading
   * effect causes more datanodes to be declared dead.
   * 检测是否有任何过期的心跳，移除dead状态的节点
   */
  void heartbeatCheck() {
  	//安全模式下不做任何的检查
    if (isInSafeMode()) {
      // not to check dead nodes if in safemode
      return;
    }
    boolean allAlive = false;
    while (!allAlive) {
      boolean foundDead = false;
      DatanodeID nodeID = null;

      // locate the first dead node.
      //定位寻找第一个dead故障状态的节点
      synchronized(heartbeats) {
        for (Iterator<DatanodeDescriptor> it = heartbeats.iterator();
             it.hasNext();) {
          DatanodeDescriptor nodeInfo = it.next();
          if (isDatanodeDead(nodeInfo)) {
          	//一旦找到，并取出对应消息并跳出循环
            foundDead = true;
            nodeID = nodeInfo;
            break;
          }
        }
      }
然后是处理，但是处理之前还需要在判断一次是否是故障节点，分布式的环境嘛，各种因素影响。// acquire the fsnamesystem lock, and then remove the dead node.
      if (foundDead) {
      	//为了确保同步性，进行加锁操作，进行dead故障状态节点的处理操作
        synchronized (this) {
          synchronized(heartbeats) {
            synchronized (datanodeMap) {
              DatanodeDescriptor nodeInfo = null;
              try {
                nodeInfo = getDatanode(nodeID);
              } catch (IOException e) {
                nodeInfo = null;
              }
              if (nodeInfo != null && isDatanodeDead(nodeInfo)) {
                NameNode.stateChangeLog.info("BLOCK* NameSystem.heartbeatCheck: "
                                             + "lost heartbeat from " + nodeInfo.getName());
                //移除此节点的信息，此方法会调用headtbeat的移除nodeinfo操作
                removeDatanode(nodeInfo);
              }
            }
          }
        }
      }
      //重置标志位
      allAlive = !foundDead;
    }心跳故障处理检测完毕，这种故障处理检测的思想或许对于我们日后自己动手设计大型分布式系统可能会有所启发。全部代码的分析请点击链接https://github.com/linyiqun/hadoop-hdfs,后续将会继续更新HDFS其他方面的代码分析。参考文献《Hadoop技术内部–HDFS结构设计与实现原理》.蔡斌等

版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式： 自己手动写一个工厂模式（整合工厂方法模式和抽象工厂模式）
 工厂模式： 所有工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象的创建过程封装的目的。
工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

抽象工厂模式提供一个接口，用来创建相关或依赖对象的家族，而不需要明确指定具体类。

工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。
抽象工厂使用对象组合： 对象的创建被实现在工厂接口所暴露出来的方法中。抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。


下面是工厂方法的类图




下面是工程的结构图


AbstractFactorys包下的类主要体现抽象工厂模式的运用

factoryMethods 包下的类主要体现工厂方法模式的运用



源代码如下：
先给出 factoryMethods 下的代码
package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

/**
 * 披萨商店抽象类 超类
 * @author Arvon
 *
 */
public abstract class PizzaStore {
	PizzaIngredientFactory ingredientFactory;
	public void orderPizza(String type,PizzaIngredientFactory ingredientFactory){
		Pizza pizza;
		pizza = createPizza(type,ingredientFactory);
		pizza.prepare();
		pizza.bake();
		pizza.cut();
		pizza.box();
	}
	/**
	 * 生产披萨  工厂方法 由子类来实现
	 * @param type
	 * @return
	 */
	public abstract Pizza createPizza(String type,PizzaIngredientFactory ingredientFactory);
	
	
}


package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

/**
 * 芝加哥披萨商店 负责生产披萨
 * @author Administrator
 *
 */
public class ChicagoPizzaStore extends PizzaStore {
	
	@Override
	public Pizza createPizza(String type,PizzaIngredientFactory ingredientFactory) {
		if(type.equals(Constant.CHEESE))
			return new ChicagoStyleCheesePizza(ingredientFactory);
		else if(type.equals(Constant.VEGGIE))
			return new ChicagoStyleVeggiePizza(ingredientFactory);
		else return null;
	}

}




package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

/**
 * 纽约披萨商店 负责生产披萨
 * @author Administrator
 *
 */
public class NYPizzaStroe extends PizzaStore {

	@Override
	public Pizza createPizza(String type, PizzaIngredientFactory ingredientFactory) {
		if(type.equals(Constant.CHEESE))
			return new NYStyleCheesePizza(ingredientFactory);
		else if(type.equals(Constant.VEGGIE))
			return new NYStyleVeggiePizza();
		else return null;
	}
}


package factoryMethods;

import AbstractFactorys.Cheese;
import AbstractFactorys.Veggie;

/**
 * 产品类 超类
 * @author Administrator
 *
 */
public abstract class Pizza {
	String name;
	Veggie veggie;
	Cheese cheese;
	
	
	public abstract void prepare();

	public void bake() {
		System.out.println("Bake for 25 minutes at 350");
		
	}

	public void cut() {
		System.out.println("Cutting the pizza into diagonal slices");
	}

	public void box() {
		System.out.println("Place pizza in official PizzaStore box");
	}

	public void setName(String name) {
		this.name = name;
	}
	
	

}


package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

public class ChicagoStyleCheesePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
	public ChicagoStyleCheesePizza(PizzaIngredientFactory ingredientFactory) {
		super();
		// TODO Auto-generated constructor stub
		name = "ChicagoStyleCheesePizza";
		this.ingredientFactory = ingredientFactory;
	}

	@Override
	public void prepare() {
		
	}
	
}

package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

public class ChicagoStyleVeggiePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
	public ChicagoStyleVeggiePizza(PizzaIngredientFactory ingredientFactory) {
		super();
		// TODO Auto-generated constructor stub
		name = "ChicagoStyleVeggiePizza";
		this.ingredientFactory = ingredientFactory;
	}

	@Override
	public void prepare() {
		// TODO Auto-generated method stub
		cheese = ingredientFactory.createCheese();
		veggie = ingredientFactory.createVeggie();
		System.out.println("Preparing " + name);
		System.out.println(cheese.getName());
		System.out.println(veggie.getName());
	}
	
}


package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

public class NYStyleCheesePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
	public NYStyleCheesePizza(PizzaIngredientFactory ingredientFactory) {
		super();
		name = "NYStyleCheesePizza";
		this.ingredientFactory = ingredientFactory;
	}

	@Override
	public void prepare() {
		cheese = ingredientFactory.createCheese();
		veggie = ingredientFactory.createVeggie();
		System.out.println("Preparing " + name);
		System.out.println(cheese.getName());
		System.out.println(veggie.getName());
	}
	
}


package factoryMethods;

public class NYStyleVeggiePizza extends Pizza {

	public NYStyleVeggiePizza() {
		super();
		// TODO Auto-generated constructor stub
		name = "NYStyleVeggiePizza";
	}

	@Override
	public void prepare() {
		// TODO Auto-generated method stub
		
	}

}

package factoryMethods;

public interface Constant {
	public static final String CHEESE = "cheese";
	public static final String VEGGIE = "veggie";
}


接下来是AbstractFactorys包里的类
package AbstractFactorys;
/**
 * 原料生产工厂 抽象工厂
 * @author Administrator
 *
 */
public interface PizzaIngredientFactory {
	public Cheese createCheese();
	public Veggie createVeggie();
	
}


package AbstractFactorys;
/**
 * 原料生产工厂 具体工厂
 * @author Administrator
 *
 */
public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory {

	@Override
	public Cheese createCheese() {
		return new Cheese(this);
	}

	@Override
	public Veggie createVeggie() {
		return new Veggie(this);
	}

}


package AbstractFactorys;
/**
 * 原料生产工厂 具体工厂
 * @author Administrator
 *
 */
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {

	@Override
	public Cheese createCheese() {
		// TODO Auto-generated method stub
		return new Cheese(this);
	}

	@Override
	public Veggie createVeggie() {
		// TODO Auto-generated method stub
		return new Veggie(this);
	}

}


package AbstractFactorys;
/**
 * 原料类 超类
 * @author Administrator
 *
 */
public class Ingredient {
	String name;

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}
	
	
}

package AbstractFactorys;
/**
 * 具体的原料
 * @author Administrator
 *
 */
public class Cheese extends Ingredient {

	public Cheese(PizzaIngredientFactory ingredientFactory) {
		name = "cheese from "+ ingredientFactory.getClass().getSimpleName();
		setName(name);
	}
	
}


package AbstractFactorys;
/**
 * 具体的原料
 * @author Administrator
 *
 */
public class Veggie extends Ingredient {

	public Veggie(PizzaIngredientFactory ingredientFactory) {
		name = "veggie from "+ ingredientFactory.getClass().getSimpleName();
	}

}


测试类
package factoryMethods;

import AbstractFactorys.ChicagoPizzaIngredientFactory;
import AbstractFactorys.NYPizzaIngredientFactory;
import AbstractFactorys.PizzaIngredientFactory;

/**
 * 测试类
 * @author Administrator
 *
 */
public class Test {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		PizzaStore mPizzaStore = new NYPizzaStroe();
		PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();
		mPizzaStore.orderPizza("cheese", ingredientFactory);
		System.out.println("-----------------------------------");
		ingredientFactory = new ChicagoPizzaIngredientFactory();
		mPizzaStore = new ChicagoPizzaStore();
		mPizzaStore.orderPizza("veggie", ingredientFactory);
		
	}
	

}

测试结果：
Preparing NYStyleCheesePizza
cheese from NYPizzaIngredientFactory
veggie from NYPizzaIngredientFactory
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in official PizzaStore box
-----------------------------------
Preparing ChicagoStyleVeggiePizza
cheese from ChicagoPizzaIngredientFactory
veggie from ChicagoPizzaIngredientFactory
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in official PizzaStore box





版权声明：本文为博主原创文章，未经博主允许不得转载。

HDFS源码分析(六)-----租约
前言在文章开始，先讲个大家都经历过的事--去图书馆借书，当然，喜欢阅读的朋友也许和我一样比较喜欢借书阅读，借书阅读方便是方便，但是唯一不好的地方在于他又期限，就是deadlline，之前在我们学校有规定，如果超期为归还的书不允许借阅另外的书籍，所以要想使自己能接到新的书，就必须先归怀超期的书籍。当然这个经历本身再寻常不过了，但是我想表达的是在HDFS分布式文件系统中的租约机制与此过程有着极强的吻合性，后面的归还书籍相当于租约恢复的操作，下面详细介绍一下什么是租约。租约以及租约相关类租约可简单理解为在短期时间内对于租约持有者也就是客户端一定的权限，例如写文件的凭证。在每次HDFS中进行块的添加，删除操作时候，都会进行租约的核查和更新，以此维护各个文件操作情况。一下列出租约的相关类：1.LeaseManager--租约管理类，可以理解为是一个租约大管家，里面维护了多种映射关系的租约集合列表。2.LeaseManager.Lease--租约实体类，就是租约具体的表现形式类。在下面会详细介绍，此类中的变量和方法。3.FSNamesystem--名字系统类，因为在这个大杂烩的大类中会用到租约相关的方法，也就加入进来。Lease首先从小类开始分析，也就是租约类Lease,他是一个内部类，存在于LeaseManager中。对于租约，首先有明白这样一个概念，租约是凭证，对客户端写操作文件的一种凭证，首先肯定得包含租约持有者变量，其次有租约记录的操作文件列表，当然租约还需要有时间，来记录租约超时的情况，所以类的变量结构如下/************************************************************
   * A Lease governs all the locks held by a single client.
   * For each client there's a corresponding lease, whose
   * timestamp is updated when the client periodically
   * checks in.  If the client dies and allows its lease to
   * expire, all the corresponding locks can be released.
   *************************************************************/
   //每条租约记录信息，只能被单一的客户端占有
  class Lease implements Comparable<Lease> {
    //租约信息客户持有者
    private final String holder;
    //租约最后更新时间
    private long lastUpdate;
    //此租约内所打开的文件，维护一个客户端打开的所有文件
    private final Collection<String> paths = new TreeSet<String>();
  
    /** Only LeaseManager object can create a lease */
    private Lease(String holder) {
      this.holder = holder;
      renew();
    }
.....在这里，Lease类将客户端打开的所有文件维护在了paths类中，然后通过租约持有者的名字进行初始构造函数的构造。然后注意这里有一个renew()方法，他是做租约时间更新的/** Only LeaseManager object can renew a lease */
    //根据租约最后的检测时间
    private void renew() {
      this.lastUpdate = FSNamesystem.now();
    }OK，租约类暂时先了解到这里，跳到下一个租约管理者类LeaseManager.LeaseManager身为一个管理者，内部变量肯定会稍稍多一些/**
 * LeaseManager does the lease housekeeping for writing on files.   
 * This class also provides useful static methods for lease recovery.
 * 
 * Lease Recovery Algorithm
 * 1) Namenode retrieves lease information
 * 2) For each file f in the lease, consider the last block b of f
 * 2.1) Get the datanodes which contains b
 * 2.2) Assign one of the datanodes as the primary datanode p

 * 2.3) p obtains a new generation stamp form the namenode
 * 2.4) p get the block info from each datanode
 * 2.5) p computes the minimum block length
 * 2.6) p updates the datanodes, which have a valid generation stamp,
 *      with the new generation stamp and the minimum block length 
 * 2.7) p acknowledges the namenode the update results

 * 2.8) Namenode updates the BlockInfo
 * 2.9) Namenode removes f from the lease
 *      and removes the lease once all files have been removed
 * 2.10) Namenode commit changes to edit log
 * 租约管理器,包含了与文件租约相关的许多方法
 */
public class LeaseManager {
  public static final Log LOG = LogFactory.getLog(LeaseManager.class);

  private final FSNamesystem fsnamesystem;
  
  //租约软超时时间
  private long softLimit = FSConstants.LEASE_SOFTLIMIT_PERIOD;
  //租约硬超时时间
  private long hardLimit = FSConstants.LEASE_HARDLIMIT_PERIOD;

  //
  // Used for handling lock-leases
  // Mapping: leaseHolder -> Lease
  //租约持有者到租约的映射图,保存在treeMap图中
  private SortedMap<String, Lease> leases = new TreeMap<String, Lease>();
  // Set of: Lease
  //全部租约图
  private SortedSet<Lease> sortedLeases = new TreeSet<Lease>();

  // 
  // Map path names to leases. It is protected by the sortedLeases lock.
  // The map stores pathnames in lexicographical order.
  //路径租约图映射关系
  private SortedMap<String, Lease> sortedLeasesByPath = new TreeMap<String, Lease>();
.....从上往下看，首先是2个超时时间，软超时时间和硬超时时间，这2个超时时间分别运用在了不同的租约场景检测环境中，在后面会做分析。其次，管理者类在这里维护了3种租约映射关系对1.租约持有者到所属租约2.所有租约集合类3.文件路径就是打开文件到租约的映射集合初步分析，作者这么设计的目的是为了方便快速的找出目标租约，以便进行后续操作。这里用到了SortedMap也是为了超找的快速。毕竟如此庞大的分布式系统，租约记录将会非常多，因为实时的操作文件数数目也一定是非常多的。OK，下面再回到类，看看几个与租约操作相关的几个典型方法/** @return the lease containing src */
  //根据路径获取租约
  public Lease getLeaseByPath(String src) {return sortedLeasesByPath.get(src);}从其中一个集合中直接获取，这个很好理解。下面是一个添加新的租约记录方法/**
   * Adds (or re-adds) the lease for the specified file.
   * 添加指定文件的租约信息
   */
  synchronized Lease addLease(String holder, String src) {
    //根据用户名获取其租约
    Lease lease = getLease(holder);
    if (lease == null) {
      //如果租约为空
      lease = new Lease(holder);
      //加入租约集合中
      leases.put(holder, lease);
      sortedLeases.add(lease);
    } else {
      //如果存在此用户的租约,则进行租约更新
      renewLease(lease);
    }
    //加入一条新的路径到租约的映射信息
    sortedLeasesByPath.put(src, lease);
    //在此租约路径映射信息中加入新路径
    lease.paths.add(src);
    return lease;
  }在加入新的租约记录时，要同时同步相应集合的数据。对应的租约移除方法/**
   * Remove the specified lease and src.
   * 移除值指定路径以及租约
   */
  synchronized void removeLease(Lease lease, String src) {
    //移动掉指定路径的映射信息
    sortedLeasesByPath.remove(src);
    //租约内部移除此路径
    if (!lease.removePath(src)) {
      LOG.error(src + " not found in lease.paths (=" + lease.paths + ")");
    }
    
    if (!lease.hasPath()) {
      //根据租约持有者移除指定租约
      leases.remove(lease.holder);
      if (!sortedLeases.remove(lease)) {
        LOG.error(lease + " not found in sortedLeases");
      }
    }
  }实际租约样例下面通过实际的操作文件方法，看看租约在这个过程中发挥的作用。比如在FSNamesystem的一个打开文件操作/**
   * Create a new file entry in the namespace.
   * 
   * @see ClientProtocol#create(String, FsPermission, String, boolean, short, long)
   * 
   * @throws IOException if file name is invalid
   *         {@link FSDirectory#isValidToCreate(String)}.
   * 命名系统打开一个新的文件
   */
  void startFile(String src, PermissionStatus permissions,
                 String holder, String clientMachine,
                 boolean overwrite, boolean createParent, short replication, long blockSize
                ) throws IOException {
    //调用startFileInternal方法
    startFileInternal(src, permissions, holder, clientMachine, overwrite, false,
                      createParent, replication, blockSize);
    getEditLog().logSync();
    if (auditLog.isInfoEnabled() && isExternalInvocation()) {
      final HdfsFileStatus stat = dir.getFileInfo(src);
      logAuditEvent(UserGroupInformation.getCurrentUser(),
                    Server.getRemoteIp(),
                    "create", src, null, stat);
    }
  }继续追踪private synchronized void startFileInternal(String src,
                                              PermissionStatus permissions,
                                              String holder, 
                                              String clientMachine, 
                                              boolean overwrite,
                                              boolean append,
                                              boolean createParent,
                                              short replication,
                                              long blockSize
                                              ) throws IOException {
    if (NameNode.stateChangeLog.isDebugEnabled()) {
      NameNode.stateChangeLog.debug("DIR* NameSystem.startFile: src=" + src
          + ", holder=" + holder
          + ", clientMachine=" + clientMachine
          + ", createParent=" + createParent
          + ", replication=" + replication
          + ", overwrite=" + overwrite
          + ", append=" + append);
    }

    if (isInSafeMode())
      throw new SafeModeException("Cannot create file" + src, safeMode);
    if (!DFSUtil.isValidName(src)) {
      throw new IOException("Invalid file name: " + src);
    }
.....

    if (!createParent) {
      verifyParentDir(src);
    }

    try {
      INode myFile = dir.getFileINode(src);
      //在这里进行租约的恢复操作
      recoverLeaseInternal(myFile, src, holder, clientMachine, false);
     ....因为重新操作了此文件，所以要进行租约的恢复操作//租约恢复操作
  private void recoverLeaseInternal(INode fileInode, 
      String src, String holder, String clientMachine, boolean force)
  throws IOException {
    if (fileInode != null && fileInode.isUnderConstruction()) {
      INodeFileUnderConstruction pendingFile = (INodeFileUnderConstruction) fileInode;
      //
      // If the file is under construction , then it must be in our
      // leases. Find the appropriate lease record.
      //
      //根据客户端名称,取出其租约
      Lease lease = leaseManager.getLease(holder);
      //
      // We found the lease for this file. And surprisingly the original
      // holder is trying to recreate this file. This should never occur.
      //
      if (!force && lease != null) {
        //如果租约记录中已经存在此文件路径,不允许重复创建记录操作
        Lease leaseFile = leaseManager.getLeaseByPath(src);
        if (leaseFile != null && leaseFile.equals(lease)) { 
          throw new AlreadyBeingCreatedException(
                    "failed to create file " + src + " for " + holder +
                    " on client " + clientMachine + 
                    " because current leaseholder is trying to recreate file.");
        }
      }
      //
      // Find the original holder.
      //取出客户端的租约记录
      lease = leaseManager.getLease(pendingFile.clientName);
      if (lease == null) {
        throw new AlreadyBeingCreatedException(
                    "failed to create file " + src + " for " + holder +
                    " on client " + clientMachine + 
                    " because pendingCreates is non-null but no leases found.");
      }
      if (force) {
        // close now: no need to wait for soft lease expiration and 
        // close only the file src
        LOG.info("recoverLease: recover lease " + lease + ", src=" + src +
                 " from client " + pendingFile.clientName);
        //如果设置了强制执行参数,直接进行租约恢复操作
        internalReleaseLeaseOne(lease, src);
      } else {
        //
        // If the original holder has not renewed in the last SOFTLIMIT 
        // period, then start lease recovery.
        //
        //如果没有设置,判断是否软超时,来进行租约恢复
        if (lease.expiredSoftLimit()) {
          LOG.info("startFile: recover lease " + lease + ", src=" + src +
              " from client " + pendingFile.clientName);
          internalReleaseLease(lease, src);
        }
        throw new AlreadyBeingCreatedException(
            "failed to create file " + src + " for " + holder +
            " on client " + clientMachine + 
            ", because this file is already being created by " +
            pendingFile.getClientName() + 
            " on " + pendingFile.getClientMachine());
      }
    }

  }这里就用到了软超时时间。继续调用恢复租约操作/**
   * This is invoked when a lease expires. On lease expiry, 
   * all the files that were written from that dfsclient should be
   * recovered.
   * 进行租约恢复操作
   */
  void internalReleaseLease(Lease lease, String src) throws IOException {
    if (lease.hasPath()) {
      // make a copy of the paths because internalReleaseLeaseOne removes
      // pathnames from the lease record.
      String[] leasePaths = new String[lease.getPaths().size()];
      lease.getPaths().toArray(leasePaths);
      for (String p: leasePaths) {
        internalReleaseLeaseOne(lease, p);
      }
    } else {
      internalReleaseLeaseOne(lease, src);
    }
  }根据租约维护的打开文件列表一条条的恢复/**
   * Move a file that is being written to be immutable.
   * @param src The filename
   * @param lease The lease for the client creating the file
   */
  void internalReleaseLeaseOne(Lease lease, String src) throws IOException {
    assert Thread.holdsLock(this);

    LOG.info("Recovering lease=" + lease + ", src=" + src);

    INodeFile iFile = dir.getFileINode(src);
    if (iFile == null) {
      final String message = "DIR* NameSystem.internalReleaseCreate: "
        + "attempt to release a create lock on "
        + src + " file does not exist.";
      NameNode.stateChangeLog.warn(message);
      throw new IOException(message);
    }
    if (!iFile.isUnderConstruction()) {
      final String message = "DIR* NameSystem.internalReleaseCreate: "
        + "attempt to release a create lock on "
        + src + " but file is already closed.";
      NameNode.stateChangeLog.warn(message);
      throw new IOException(message);
    }

    INodeFileUnderConstruction pendingFile = (INodeFileUnderConstruction) iFile;
    .....
    // start lease recovery of the last block for this file.
    pendingFile.assignPrimaryDatanode();
    //在末尾进行租约的重分配
    Lease reassignedLease = reassignLease(
      lease, src, HdfsConstants.NN_RECOVERY_LEASEHOLDER, pendingFile);
    leaseManager.renewLease(reassignedLease);
  }进行租约重分配，重分配操作很简单，就是先移除老租约，再添加新的租约，然后更新一下时间/**
   * Reassign lease for file src to the new holder.
   * 租约重分配方法,等价于先移除后添加的方法
   */
  synchronized Lease reassignLease(Lease lease, String src, String newHolder) {
    assert newHolder != null : "new lease holder is null";
    if (lease != null) {
      removeLease(lease, src);
    }
    return addLease(newHolder, src);
  }

synchronized void renewLease(Lease lease) {
    if (lease != null) {
      //首先进行列表租约移除
      sortedLeases.remove(lease);
      //更新时间
      lease.renew();
      //再进行添加
      sortedLeases.add(lease);
    }
  }当你要具体操作block块的时候，还会经历租约检测工作，比如下面abandon块操作的时候/**
   * The client would like to let go of the given block
   */
  public synchronized boolean abandonBlock(Block b, String src, String holder
      ) throws IOException {
    //
    // Remove the block from the pending creates list
    //
    NameNode.stateChangeLog.debug("BLOCK* NameSystem.abandonBlock: "
                                  +b+"of file "+src);
    if (isInSafeMode()) {
      throw new SafeModeException("Cannot abandon block " + b +
                                  " for fle" + src, safeMode);
    }
    //移除块操作时进行租约检查,如果出现不符号要求的时候会抛异常
    INodeFileUnderConstruction file = checkLease(src, holder);
    dir.removeBlock(src, file, b);
    NameNode.stateChangeLog.debug("BLOCK* NameSystem.abandonBlock: "
                                    + b
                                    + " is removed from pendingCreates");
    return true;
  }// make sure that we still have the lease on this file.
  private INodeFileUnderConstruction checkLease(String src, String holder) 
                                                      throws IOException {
    INodeFile file = dir.getFileINode(src);
    //继续调用同名方法
    checkLease(src, holder, file);
    return (INodeFileUnderConstruction)file;
  }然后是下面的核心检查方法//下面是租约检查的核心逻辑方法
  private void checkLease(String src, String holder, INode file) 
                                                     throws IOException {
    //如果正在操作的文件不存在,抛异常
    if (file == null || file.isDirectory()) {
      Lease lease = leaseManager.getLease(holder);
      throw new LeaseExpiredException("No lease on " + src +
                                      " File does not exist. " +
                                      (lease != null ? lease.toString() :
                                       "Holder " + holder + 
                                       " does not have any open files."));
    }
    
    //如果文件没有被打开,说明一定没有对应的租约记录存在,也抛异常
    if (!file.isUnderConstruction()) {
      Lease lease = leaseManager.getLease(holder);
      throw new LeaseExpiredException("No lease on " + src + 
                                      " File is not open for writing. " +
                                      (lease != null ? lease.toString() :
                                       "Holder " + holder + 
                                       " does not have any open files."));
    }

    INodeFileUnderConstruction pendingFile = (INodeFileUnderConstruction)file;
    //判断文件所有者和客户端租约持有者是否一致
    if (holder != null && !pendingFile.getClientName().equals(holder)) {
      throw new LeaseExpiredException("Lease mismatch on " + src + " owned by "
          + pendingFile.getClientName() + " but is accessed by " + holder);
    }
  }主要进行了租约持有者与文件所属者名称进行检查，还有文件打开状态的判断。通过抛出异常的方式阻止用户的操作。租约监控在租约管理器内部也有租约线程操作//租约过期监控检测线程
  class Monitor implements Runnable {
    final String name = getClass().getSimpleName();

    /** Check leases periodically. */
    public void run() {
      for(; fsnamesystem.isRunning(); ) {
        synchronized(fsnamesystem) {
          //执行checkLeases方法
          checkLeases();
        }

        try {
          Thread.sleep(2000);
        } catch(InterruptedException ie) {
          if (LOG.isDebugEnabled()) {
            LOG.debug(name + " is interrupted", ie);
          }
        }
      }
    }
  }会进行定期的租约检查操作，并对超时租约进行租约恢复操作  /** Check the leases beginning from the oldest. */
  synchronized void checkLeases() {
    for(; sortedLeases.size() > 0; ) {
      //获取距离目前最晚的租约时间开始
      final Lease oldest = sortedLeases.first();
      //如果最晚的时间是否超过硬超时时间
      if (!oldest.expiredHardLimit()) {
        return;
      }

      //到了这步，说明已经发生租约超时
      LOG.info("Lease " + oldest + " has expired hard limit");

      final List<String> removing = new ArrayList<String>();
      // need to create a copy of the oldest lease paths, becuase 
      // internalReleaseLease() removes paths corresponding to empty files,
      // i.e. it needs to modify the collection being iterated over
      // causing ConcurrentModificationException
      //获取此租约管理的文件路径
      String[] leasePaths = new String[oldest.getPaths().size()];
      oldest.getPaths().toArray(leasePaths);
      for(String p : leasePaths) {
        try {
          //进行租约释放
          fsnamesystem.internalReleaseLeaseOne(oldest, p);
        } catch (IOException e) {
          // 如果是租约释放失败的情况加入移除列表中
          LOG.error("Cannot release the path "+p+" in the lease "+oldest, e);
          removing.add(p);
        }
      }
      
      //进行移除租约记录的remove操作
      for(String p : removing) {
        removeLease(oldest, p);
      }
    }
  }每次从获取最晚的租约记录检测。全部代码的分析请点击链接https://github.com/linyiqun/hadoop-hdfs,后续将会继续更新HDFS其他方面的代码分析。参考文献《Hadoop技术内部–HDFS结构设计与实现原理》.蔡斌等

版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式： 自己手动写一适配器和外观模式
适配器模式： 将一个类的接口，转换成客户所期待的接口，适配器让原本不兼容的类可以合作无间。有两种形式：类适配器和对象适配器。前者需要用到多重继承（java不支持），后者要用到组合。
外观模式： 提供了一个统一的简化的接口，用来访问子系统里的一群接口。外观定义了一个高层接口，让子系统更容易使用。


适配器的类图




适配器的一个简单源码：
package adapter;
/**
 * 鸭子接口
 * @author Arvon
 *
 */
public interface Duck {
	public void quack();
	public void fly();
}

package adapter;
/**
 * 火鸡接口
 * @author Administrator
 *
 */
public interface Turkey {
	public void fly();
	public void goggle();
}

package adapter;
/**
 * 一个伪装成火鸡的鸭 
 * @author Administrator
 *
 */
public class TurkeyAdapter implements Duck {
	private Turkey turkey;
	
	
	public TurkeyAdapter(Turkey turkey) {
		super();
		this.turkey = turkey;
	}

	@Override
	public void quack() {
		// TODO Auto-generated method stub
		turkey.goggle();

	}

	@Override
	public void fly() {
		// TODO Auto-generated method stub
		for(int i=0;i<5;i++)
			turkey.fly();

	}

}



package adapter;

public class MalladDuck implements Duck {

	@Override
	public void quack() {
		// TODO Auto-generated method stub
		System.out.println("i am quacking...");

	}

	@Override
	public void fly() {
		// TODO Auto-generated method stub
		System.out.println("i am flying ...");

	}

}



package adapter;

public class WildTurkey implements Turkey {

	@Override
	public void fly() {
		// TODO Auto-generated method stub
		System.out.println("i am flying short distance...");

	}

	@Override
	public void goggle() {
		// TODO Auto-generated method stub
		System.out.println("i am goggling....");

	}

}


package adapter;

public class AdapterTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Duck duck = new MalladDuck();
		System.out.println(duck.getClass().getSimpleName()+" says...");
		testDuck(duck);
		//将鸭子接口转换成了火鸡接口
		Duck fakeDuck = new TurkeyAdapter(new WildTurkey());
		System.out.println(fakeDuck.getClass().getSimpleName()+" says...");
		testDuck(fakeDuck);
		
		

	}

	private static void testDuck(Duck duck) {
		duck.quack();
		duck.fly();
	}

}

程序输出：
MalladDuck says...
i am quacking...
i am flying ...
TurkeyAdapter says...
i am goggling....
i am flying short distance...
i am flying short distance...
i am flying short distance...
i am flying short distance...
i am flying short distance...



外观模式类图




核心代码：
package facade;
/**
 * 简化了的接口
 * @author Administrator
 *
 */
public class HomeTheaterFacade {
	Amplifier amp;
	Tuner tuner;
	DvdPlayer dvd;
	CdPlayer cd;
	Projector projector;
	TheaterLights lights;
	Screen screen;
	PopcornPopper popper;
	public HomeTheaterFacade(Amplifier amp, Tuner tuner, DvdPlayer dvd, CdPlayer cd, Projector projector,
			TheaterLights lights, Screen screen, PopcornPopper popper) {
		super();
		this.amp = amp;
		this.tuner = tuner;
		this.dvd = dvd;
		this.cd = cd;
		this.projector = projector;
		this.lights = lights;
		this.screen = screen;
		this.popper = popper;
	}
	
	public void watchMovie(String movie) {
		System.out.println("Get ready to watch a movie...");
		popper.on();
		popper.pop();
		lights.dim(10);
		screen.down();
		projector.on();
		projector.wideScreenMode();
		amp.on();
		amp.setDvd(dvd);
		amp.setSurroundSound();
		amp.setVolume(5);
		dvd.on();
		dvd.play(movie);
	}
 
 
	public void endMovie() {
		System.out.println("Shutting movie theater down...");
		popper.off();
		lights.on();
		screen.up();
		projector.off();
		amp.off();
		dvd.stop();
		dvd.eject();
		dvd.off();
	}
	

}


package facade;

public class FacadeTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Amplifier amp = new Amplifier("Top-O-Line Amplifier");
		Tuner tuner = new Tuner("Top-O-Line AM/FM Tuner", amp);
		DvdPlayer dvd = new DvdPlayer("Top-O-Line DVD Player", amp);
		CdPlayer cd = new CdPlayer("Top-O-Line CD Player", amp);
		Projector projector = new Projector("Top-O-Line Projector", dvd);
		TheaterLights lights = new TheaterLights("Theater Ceiling Lights");
		Screen screen = new Screen("Theater Screen");
		PopcornPopper popper = new PopcornPopper("Popcorn Popper");
 
		HomeTheaterFacade homeTheater = 
				new HomeTheaterFacade(amp, tuner, dvd, cd, 
						projector, lights, screen, popper);
 
		homeTheater.watchMovie("Raiders of the Lost Ark");
		homeTheater.endMovie();

	}

}


其他的类都是子系统的类 这里就不贴出来啦。
程序的输出：
Get ready to watch a movie...
Popcorn Popper on
Popcorn Popper popping popcorn!
Theater Ceiling Lights dimming to 10%
Theater Screen going down
Top-O-Line Projector on
Top-O-Line Projector in widescreen mode (16x9 aspect ratio)
Top-O-Line Amplifier on
Top-O-Line Amplifier setting DVD player to Top-O-Line DVD Player
Top-O-Line Amplifier surround sound on (5 speakers, 1 subwoofer)
Top-O-Line Amplifier setting volume to 5
Top-O-Line DVD Player on
Top-O-Line DVD Player playing "Raiders of the Lost Ark"
Shutting movie theater down...
Popcorn Popper off
Theater Ceiling Lights on
Theater Screen going up
Top-O-Line Projector off
Top-O-Line Amplifier off
Top-O-Line DVD Player stopped "Raiders of the Lost Ark"
Top-O-Line DVD Player eject
Top-O-Line DVD Player off













版权声明：本文为博主原创文章，未经博主允许不得转载。

Java之旅hibernate（8）——基本关系映射
　　何为关系，何为映射，关系这个词想必大家都不陌生，比如你和老师之间是师生关系，你和父母之间是父子或者父女（母子或者母女关系）。
　　关系是存在某种联系物体之间产生的，什么都是可能的，比如你和工具，你只能使用工具，但是工具不能使用你，这样的关系是单向的，但是换种说法，你拥有工具，工具也属于你，那么这种关系就是双向的了，此外一个人可以拥有多个工具，并且多个工具也可以是属于一个人的，还有就是多个人拥有多个工具，并且多个工具也属于人，根据这些特征，我们将关系分为以下几种：
　　单向关系：
　　one2one,（一对一）
　　many3one（多对一）
　　one2many（一对多）
　　many2many（多对多）
　　双向关系：
　　one2many（一对多）
　　many2many（多对多）
　　one2one（一对一）
　基本映射必备知识
　　必须存在的文件和实体
　　实体类（.java）
　　实体类的存在是基础，因为我们要做的就是将实体类映射成为表，在映射之前先建好实体类，以及主键和各个属性字段。代码如下图：
import java.util.Date;

public class User {

	private String id;
	
	private String name;

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
　　映射文件(*.hbm.xml)
　　映射文件通常是以.hbm.xml为后缀的，比如我们建立一个User的实体，那么我们的映射文件就是User.hbm.xml,将实体映射为表也是在这里进行配置的。配置如下：
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC 
	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.bjpowernode.hibernate.User">
		<id name="id">
			<generator class="uuid"/>
		</id>
		<property name="name"/>
		<property name="password"/>
	</class>
</hibernate-mapping>
　　Hibernate的配置文件（hibernate.cfg.xml）
　　当我们建立了实体和映射文件后，下面我们就该进行在配置文件中进行配置了，因为配置文件是我们拿到整个接口和方法的入口，所以在此配置尤为重要。
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
	<session-factory>
		<property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
		<property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate_session</property>
		<property name="hibernate.connection.username">root</property>
		<property name="hibernate.connection.password">bjpowernode</property>
		<property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
		<property name="hibernate.show_sql">true</property>
		
		<mapping resource="com/bjpowernode/hibernate/User.hbm.xml"/>
	</session-factory>
</hibernate-configuration>
　　这里不仅仅配置了数据库的信息，并且也配置了映射文件，从而可以通过工具类将映射文件导入到数据库。
　　工具类
　　这是我们自己手写的工具类，用于将实体类映射成表，并保存到数据库。
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

/**
 * 将hbm生成ddl
 * @author Administrator
 *
 */
public class ExportDB {

	public static void main(String[] args) {
		
		//默认读取hibernate.cfg.xml文件
		Configuration cfg = new Configuration().configure();
		
		SchemaExport export = new SchemaExport(cfg);
		export.create(true, true);
	}
}
　小结
　　了解了上面的基本信息，那就便于我们对于hibernate的七种映射关系进行理解，下面的文章将进行hibernate七种关系的一一讲解。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Atitit.使用引擎加脚本架构的设计 使用php,js来开发桌面程序。。

Atitit.使用引擎加脚本架构的设计 使用php,js来开发桌面程序。。
 
 
1. 引擎加脚本架构 跨平台，桌面与web的优势
1
2. 架构桌面引擎（java，c#）
2
3. php桌面引擎要点
2
3.1. 运行环境：同时支持cs桌面与web方式
2
3.2. 界面使用html5+css+js实现
2
3.3. Cli接口互操作，与web接口互操作
2
3.4. 其他----------流程
2
3.4.1. Html5界面确定要是有的后台引擎$parser=php c# java js
2
3.4.2. 桌面引擎dispatch
3
3.4.3. 使用cli引擎转发到php
3
3.4.4. phprun.bat
4
3.4.5. Php同时支持web与桌面的参数传递
4
3.4.6. 桌面程序$_GET参数的解析，自定义req引擎
4
3.4.7. 回调js 通过$callback
5
4. 常见问题与最近实践
5
4.1. 使用cmd.exe还是直接bat。。
5
5. 其他的php桌面程序方案
6
6. 参考
6
 
1. 引擎加脚本架构 跨平台，桌面与web的优势
跨平台方面java很不错。但是java需要编译。。如果需要一个桌面程序，需要灵活修改，可以脚本写成的化，就可以考虑引擎加脚本架构 。。。使用php或者js来做桌面后端。。。

作者:: 老哇的爪子 Attilax 艾龙，  EMAIL:1466519819@qq.com

转载请注明来源： http://blog.csdn.net/attilax
 
2. 架构桌面引擎（java，c#）

 
3. php桌面引擎要点
3.1. 运行环境：同时支持cs桌面与web方式
3.2. 界面使用html5+css+js实现
3.3. Cli接口互操作，与web接口互操作
3.4. 其他----------流程
3.4.1. Html5界面确定要是有的后台引擎$parser=php c# java js
使用dwr引擎转换为http param..
最好可以有个总配置要使用什么引擎，也可以单独页面配置不同的引擎。。
 
3.4.2. 桌面引擎dispatch 
Proj.amazon splider
  //供JS调用
        public void sendNSCommand(Object message, Object message2, Object message3, Object message4, Object message5, Object message6, Object message7)
        {
          //  Object[] objs = (Object[])message;
            Console.WriteLine(message);
 
            String meth =(String) message;
            //p822
            string paramsx=((string) message2);
            if (paramsx.Contains("$parser"))
            {
                String r = new php—ParesrX(paramsx).exec().Trim() ;
                Map m = new ParamX().urlParams2Map((string)message2);
                 String callback = (String)m.get("$callback");
                 String js2 = callback + "('" + r + "');";
                 WebBrowser webBrowser1 = (WebBrowser)iocx.getBean("webBrowser1");
                 object[] objects = new object[1];
                 objects[0] = r;
                 Object o = webBrowser1.Document.InvokeScript(callback, objects);
                 Console.WriteLine("==exe js rzt:" + o);
                 return;
            }
 
3.4.3. 使用cli引擎转发到php
 class ParesrX
    {
        private string meth;
 
        public ParesrX(string meth)
        {
            // TODO: Complete member initialization
            this.meth = meth;
 
        }
 
        internal String exec()
        {
            Map m =new  ParamX().urlParams2Map(this.meth);
            if (((String)m.get("$parser")).Equals("php"))
            {
                String urlparams = m.serialize();
                String cmd = "@qut" + pathx.StartupPath() + "/phprun.bat@qut  @qut" + pathx.StartupPath() + "/com.attilax/api.php@qut  @qut" + urlparams + "@qut";
              cmd=cmd.Replace("@qut","\"");
                Console.WriteLine(cmd);
            String r=    new Cmd().RunCmd(cmd);
            return r;
            }
            return "";
 
 
3.4.4. phprun.bat
@d:
 
@"%~dp0php5.3.10\php.exe"  -c "%~dp0php5.3.10\php.ini"  -f %1  %2  %3
 
 
3.4.5. Php同时支持web与桌面的参数传递
/com.attilax/api.php@qut  @qut" + urlparams + "@qut";
Web方式    api.php?urlparams....
 
3.4.6. 桌面程序$_GET参数的解析，自定义req引擎
 if(count($_GET)==0) //cli mode
 {
 
 $param=$argv[1]; 
  $GLOBALS["varx"]["argv"]=$argv ;
 
 $_GET=urlParams2Map($param); 
   $GLOBALS["varx"]["get"]=$_GET ;
  
 
 }
 
 
 
function   urlParams2Map( $params) {
 $o=array();
$a=explode('&',$params);
 $GLOBALS["varx"]["a"]=$a ;
  $GLOBALS["varx"]["params"]=$params;
  foreach( $a as $k2=>$v2 )
  {
 
  $a2=explode("=",$v2);
   $k=$a2[0];
   $v=$a2[1];
   $o[$k]=$v;
  }
   $GLOBALS["varx"]["o"]=$o ;
return $o;

}
 
3.4.7. 回调js 通过$callback
    String callback = (String)m.get("$callback");
                 String js2 = callback + "('" + r + "');";
                 WebBrowser webBrowser1 = (WebBrowser)iocx.getBean("webBrowser1");
                 object[] objects = new object[1];
                 objects[0] = r;
                 Object o = webBrowser1.Document.InvokeScript(callback, objects);
 
4. 常见问题与最近实践
4.1. 使用cmd.exe还是直接bat。。
推荐使用bat方式。。否则cmd.exe 
 
        String cmd = "@qut" + pathx.StartupPath() + "/phprun.bat@qut  @qut" + pathx.StartupPath() + "/com.attilax/api.php@qut  @qut" + urlparams + "@qut";
              cmd=cmd.Replace("@qut","\"");
 
正确的方式是，将 /C 后面所有字符，再加上双引号：
对比两段命令，很多人马上就明白为什么了。

因为，这里相当于有两条命令，并且是嵌套的，外面的命令是：

cmd.exe /C "command"

命令是 cmd.exe，两个参数分别是 /C， "command"，我们这里的 command 是
 
      
5. 其他的php桌面程序方案
php gtk
WinBinder 
 
6. 参考
用PHP开发桌面应用.html
执行 CMD 时，参数加引号常见问题 - 的米-漠石's Blog - 博客频道 - CSDN.NET.html
C#执行DOS命令（CMD命令） - 杨友山 - 博客频道 - CSDN.NET
paip.asp vbs通过CLI命令行调用PHP代码 - attilax的专栏 - 博客频道 - CSDN.NET
paip.执行shell cmd 命令uapi java php python总结 - attilax的专栏 - 博客频道 - CSDN.NET
 



﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

面向模式的软件体系结构(3)--管道与过滤器
看了一整晚，不甚理解管道/过滤器。常见的案例Linux命令管道是比较好理解的，但加之混乱的主动/被动的动态概念，就不太好理解了。暂先整理笔记，后面再回顾。


这是看的第2类体系结构，不是有所收获：大致可抽象出一些常见设计的范式
1、体系结构现过程关键点：拆、定义接口/格式、合、出错处理
2、优点关注：重用度
 “考虑到一般变更的设计是优秀系统深化的一个主要助推器”


【概述】
管道和过滤器（Pipes and Filters）为处理数据流的系统提供了一种结构。每个处理步骤封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输。重组过滤器可以建立相关系统族。


【细节】
例子 -- Java语言的解析过程（词法分析，语法分析，语义分析，中间代码生成，中间代码优化）
语境 -- 处理数据流
问题 -- 存在不同的输入数据源；想要达到未来可灵活重新排列步骤，需要提前做好规划；不相连的处理步骤不共享信息etc
解决方案 -- 将系统任务分成几个顺序的处理步骤。
结构 --
1、随后的流水线单元从过滤器中拉出输出数据（被动过滤器）
2、前面的流水线单元把新的输入数据压入过滤器（被动过滤器）
3、最常用的，过滤器以循环方式工作，从流水线中拉出其输入数据并且将其输出数据压入流水线（主动过滤器）


过滤器，职责：获得输入数据；在其输入数据上执行1个函数；供给输出数据
管道表示过滤器之间的连接，职责：转化数据，缓冲数据，同步主动邻居


动态特性 -- 主动被动过滤器之区分（暂搞不懂）
实现 -- 
1、为把系统任务分成一系列处理阶段
2、定义沿每个管道传输的数据格式
3、决定如何实现每个管道连接
4、设计和实现过滤器
5、设计出错处理
6、建立处理流水线


已解决的例子 -- TCP/IP协议
已知使用：Unix流水线任务：程序编译、文档创建
效果 --
优点：不一定需要中间文件、过滤器交换/重组灵活性、重用、快速原型、并行处理效率
不足：共享状态信息昂贵/不灵活、并行处理效率未必高、数据转换额外开销、错误处理




版权声明：本文为博主原创文章，未经博主允许不得转载。

Filter过滤器实现自动登录
Filter介绍
问题:Filter是什么，它能做什么?
    1.从两个方面来解析Filter是什么?
       1.功能  可以帮助我们对请求与响应操作进行过滤。
       2.技术  Sun公司定义的一个接口，javax.servlet.Filter

   2.Filter能完成什么操作?
       常用示例:
       1.通用编码过滤器.
       2.粗粒度的权限控制(url级别)
       3.过滤一些敏感字

Filter创建步骤:
        1.创建一个类实现javax.servlet.Filter接口。
        2.重写Filter接口中三个方法  init  doFilter  destroy.
        3.在web.xml文件中配置Filter

为什么在web.xml文件中配置Filter?
        1.Filter也是一个资源，也要被服务器加载，所以要在web.xml文件中配置.

        2.我们在web.xml文件中配置Filter的另一个目的是用来设置Filter拦截什么资源。


实例：需求：网站登录的时候当用户勾选自动登录选框之后，当用户再来登录，自动登录进网站。
      准备：简单的模拟如下页面：
      
<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title></title>
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	  </head>
  <body>
    <h3>这里是最美网</h3>
	    <c:if test="${ not empty existUser}">	    
	    	<h2>欢迎您：${existUser.nickname }</h2>
	    </c:if>
	    <c:if test="${empty existUser }">
	    	<a href="${pageContext.request.contextPath }/login.jsp">请登录</a>
	    </c:if>
    <h3>新闻标题</h3>
    <h2>大阅兵</h2>
  </body>
</html>

    <%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title></title>
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	  </head>
  <body>
  <form action="${pageContext.request.contextPath }/login" method="post">
	    <p style="color:red">${msg }</p>
	    用户名：<input type="text" id="username" name = "username"><br>
	    密码：<input type="password" id="password" name="password"><br>
	    <input type="checkbox" name="autologin" value="auto_ok">自动登录<br>
	    <button type="submit" value="登录">登录</button>
    </form>
  </body>
</html>

   过滤器：
public class myFilter implements Filter {

	public void destroy() {
		
	}

	public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
		
		/**
		 * 从session中获取existUser
		 * 如果不为空，说明已经登录并且没有关闭浏览器，放行
		 * 如果为空说明没有登录，获取指定名称的cookie
		 *   *如果找不到该cookie说明用户没有开启自动登录功能 ，放行
		 *   *如果不为空，从cookie中拿到用户名和密码从数据库中查询
		 *    *如果查不到 ，则用户名或密码改变了，不处理  放行
		 *    *如果查到了放到session中，放行
		 * 
		 */
		
		//从session中获取用户existUser
		HttpServletRequest req =(HttpServletRequest) request ;
		HttpSession session = req.getSession();
		User existUser  =(User) session.getAttribute("existUser");
		
		if (existUser!=null) {
			
			chain.doFilter(req, response);
			
		}else {
			//为空，说明没有登录
			//获取指定cookie
			//获取保存cookie的数组
		    Cookie []cookies =	req.getCookies();
		    
		    Cookie cookie =MyCookieUtile.findCookieByName(cookies, "autologin");
		    
		    //判断cookie是否为空
		    if (cookie==null) {
		    	
		    	chain.doFilter(req, response);
				
			}else{
				
				//获取cookie的value值
				String value = cookie.getValue();
				String username = value.split(":")[0];
				String password = value.split(":")[1];
				
				//拿到cookie中的用户名和密码去数据库中查
				UserDao dao = new UserDao();
				
				try {
					User user = dao.checkUser(username, password);
					
					if (user==null) {
						chain.doFilter(req, response);
					}else{
						//说明成功，自动登录
						session.setAttribute("existUser",user);
						//放行
						chain.doFilter(req, response);
						
					}
					
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}   		        
		    
		}
		
	}

	public void init(FilterConfig filterConfig) throws ServletException {
		
	}

}
       public class MyCookieUtile {
	
	/**
	 * 通过传入的cookie名称从传入的cookie数组中查找cookie
	 * 如果数组为空，则没有找到返回为null
	 * 如果不为空，找到返回cookie
	 * @param cookies
	 * @param cookiename
	 * @return
	 */	
	public static Cookie findCookieByName(Cookie []cookies,String cookiename){
		
		if (cookies==null) {
			return null;			
		}else{	
			
			for (Cookie cookie : cookies) {
				//获取cookie的名称和传入的名称对比
				if (cookiename.equals(cookie.getName()) ) {
					//相同则返回
					return cookie;					
				}
			}
			return null;
		}				
	}
}


     servlet：
public class LoginServlet extends HttpServlet {

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		
		/**
		 * 接收参数
		 * 根据用户名和密码查询数据库
		 * 如果成功，返回到content页
		 * 如果不成功，返回登录页继续登录
		 */
		//解决中文乱码问题
		request.setCharacterEncoding("UTF-8");		
		String username = request.getParameter("username");
		String password = request.getParameter("password");		
		//调用dao层查询
		UserDao dao = new UserDao();
		try {
			User existUser = dao.checkUser( username, password);
			
			if (existUser==null) {
				request.setAttribute("msg", "用户名或密码错误");
				request.getRequestDispatcher("/login.jsp").forward(request, response);
				
			}else{
				//登录成功
				
				//回写cookie
				String autologin = request.getParameter("autologin");
				
				if ("auto_ok".equals(autologin)) {
					
					String value = username+":"+password;
					Cookie cookie = new Cookie("autologin", value);					
					//设置有效时间
					cookie.setMaxAge(60*60);
					//设置有效路径
					cookie.setPath("/");					
					//回写到客户端
					response.addCookie(cookie);		
					
				}				
				request.getSession().setAttribute("existUser", existUser);				
				
				//重定向到content页面
				response.sendRedirect(request.getContextPath()+"/content.jsp");
				
			}				
			
		} catch (SQLException e) {
			e.printStackTrace();
		}		
	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		this.doGet(request, response);

	}
}




         最后在配置文件中web.xml文件中配置filter。这样当用户勾选了自动登录，关闭浏览器之后，再次访问即可自动登录进网站。
      在我们创建一个Filter时，要重写接口中的方法，有一个方法doFilter,它就是用于拦截操作的方法。在配置Filter时，可以指定拦截什么资源，当浏览器访问这个资源时，Filter的doFilter方法就会执行拦截操作。

      我们如果在Filter中，它的doFilter方法执行了，代表拦截操作开始了，如果想要让其可以继续向下访问资源，就需要通过doFilter方法的第三个参数FilterChain类型，调用它的doFilter方法，完成向下执行操作。

      总结:
   1.在Filter中具体的拦截操作是由doFilter方法执行的。  如果要想访问资源，需要chain.doFilter()放行.
   2.拦截什么资源是由web.xml文件中配置的Filter确定的。






版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        常规功能和模块自定义系统(cfcmms)—001序言
常规功能和模块自定义系统(cfcmms)—001序言




　　在写了《常规功能和模块自定义系统(http://blog.csdn.net/jfok/article/details/24309239)》extjs4版的设计和开发思想的博客，以及《跟我一起学extjs5(http://blog.csdn.net/jfok/article/details/35550713)》中对此自定义系统的部分功能进行了开发讲解之后，现在有必要来对《常规功能和模块自定义系统》（以后简称本系统或自定义系统）的设计、开发来做一个全面的升级和总解了，从现在开始将会写一个新的博客来介绍本系统。
　　在这个新的博客中将会对项目的开发环境、系统项目的建立、自定义系统架构、系统内置的各种功能进行全面的设计和源码的分析讲解。系统的开发工具为eclipse，其中前台为extjs6，后台使用java+spring mvc+hibernate(jdbc)+mysql(mssql)。
　　由于此系统的设计和编码都比较复杂，因此不能象前一个博客介绍开发过程了(这也是《跟我一起学extjs5》这个博客写不下去的原因)，我现在的想法是能把一个阶段的系统代码发布后，对设计和主要部分的前后台代码进行讲解。对于此系统的读者而言能够在一个可以运行的系统下来对系统设计和编码来了解和解读，无疑也是降低了需要了解本系统的人员的门槛。
　　系统的升级和开发是我的即时开发，在完成了一定功能后，会发布一个新的版本并更新博客。如果老版本中有bug或者在新的版本中进行过修改，则老版本不会进行更新。由于本人对extjs和java spring mvc都没有进行过系统的学习，因此在设计和编码时会有不合规范和无理之处，请大家多提意见指正。
　　对本系统有兴趣的读者可以加入QQ群：386100815；对此系统有任何建议或意见的可以跟贴回复，或者发邮件jfok1972@qq.com 和我进行联系。

版权声明：本文为博主原创文章，未经博主允许不得转载。

给Java开发者的Play Framework(2.4)介绍 Part1：Play的优缺点以及适用场景
1. 关于这篇系列这篇系列不是Play框架的Hello World，因为这样的文章网上已经有很多。这篇系列会首先结合实际代码介绍Play的特点以及适用场景，然后会有几篇文章介绍Play与Spring，JPA（Hibernate）的集成，以及一些Play应用的最佳实践， 这期间会在Github上提供一个脚手架项目，方便感兴趣的朋友直接动手尝试。最后会简单分析Play的部分源码，帮助大家理解黑盒子的内部机制。我水平有限，有错误欢迎指出。2. Play介绍Play Framework是一个开源的Web框架，背后商业公司是Typesafe。要介绍Play之前，首先理清Play的两个不同的分支。 Play 1.x 使用Java开发，最新版本是1.3.1，只支持Java项目。从11年开始就进入了维护阶段，新项目一般不考虑使用Play1。 Play 2.x 使用Scala和Java开发，同时支持Java和Scala项目。 这里主要介绍最新的Play2.4 for Java。有一点需要提前说明，虽然Play2主要由Scala开发，但是对于项目中的一般开发人员而言， 使用Play可以完全不懂Scala，具体情况后面会说明。3. 为什么要了解Play现在的Web框架或者类库可以说是浩如烟海。近十年来，在Web开发领域，JVM阵营的占有率一直不高，  数据来源(http://hotframeworks.com/#rankings)这是国外开源项目的数据，相对来说国内Java框架的使用率会高一些。而最近几年，Ruby和Python在国内的开发群体也在不断壮大。 Java框架在Web领域不那么受欢迎，主要原因在于开发速度远落后于其他的开发框架。对于初创公司而言，快速开发出产品投入市场试错比花半年打磨出一款功能性能齐备的 应用更加重要，而对于成熟产品，也需要快速响应频繁的需求变化，这方面动态语言又更胜一筹。所以说到Web后端框架的技术选型，除非技术团队有比较深的JVM背景， 否则会倾向于选择RoR，Django这些框架。JVM阵营在Web领域逐渐落后主要有三个原因：编译的锅，技术栈的锅和语言的锅。大家都知道Java源代码需要编译之后才能运行，直接结果是每次修改源代码都需要重启Web服务器才能看到效果。如果项目比较小类也少，重启时间还勉强能接受。 我以前参与的一个项目，使用的是WebLogic服务器，Spring容器里大概有上千个Bean，重启一次至少得花5分钟，还是优化后的结果。工作时间至少有20%花在重启上了。 虽然现在有JRebel之类的热加载技术，但是国内使用的相对较少。Servlet规范在1997年出现，在当时可以说是很先进的技术，加上Tomcat的横空出世，直接促成了JSP的崛起。然而时过境迁，Servlet风光不再， Web容器存在的必要性也被越来越多的人质疑。原因就在于人为的将应用与容器剥离， 虽然这种做法本意是好的，但是结果就是给开发测试部署带来一系列集成的问题，现在越来越多的项目开始使用内嵌的Jetty或Tomcat就是一个现实的例子。 Servlet还带来一个问题，就是有状态的服务器。一旦使用了Session，服务器就无法享受到水平扩展的好处了，由此不得不采用Session复制或者粘性Session(Sticky Session)的 方案来解决这个问题，无论采取哪种方案都会有性能损耗，并且推高了技术成本。Servlet说到底是Java EE家族的一员，由于Sun的领导（Oracle背锅）， 从Java EE 5开始，Java EE的角色已经从技术创新者转换为跟随者，这些年基本上可以说是跟着开源社区的步子在走的，除了政府大单和跨国企业，你很难再看见它的身影了。 至于语言，其实从JDK8开始，Java已经很好用了。不过从JDK5到JDK8，十年太长，尤其是在Web。之前Java阵营受累于没有成熟的快速开发框架，Spring热衷于提供各种集成方案，可是配置和使用还是相当的麻烦，直到Spring Boot的出现才有改善。 不过近几年出现了一些相当优秀的框架，如Dropwizard，Play，Vert.x。 这篇系列要介绍的Play，通过ClassLoader在源代码修改的时候动态加载类，解决了修改代码需要重启服务器的问题，完全抛弃了Servlet技术栈，基于Netty实现了自己的 请求响应接口（Request/Result），基于Play的应用就是无状态的，另外Play处理请求的方式是无阻塞的（Non-Blocking）。Play2在设计的时候借鉴了RoR的许多优点， 学习Play能够让你了解一些现代化框架的特点，同时能够为你打开异步编程世界的大门。Promise已经被Scala，JavaScript等语言大量使用，Actor模型也已经遍地开花， 这些你都可以直接在Play中使用，或者你想保持原来的编程风格也完全没有问题。4. Play的特性1. Play2的模板引擎Play2的模板是很强大并且容易上手的. 相对于Java领域其他模板引擎(Freemarker, Velocity, JSP, Groovy, etc), 主要有三个特点.1) 简单易上手, 没有JSP里面繁杂的内置对象和指令, 所有功能都通过方法调用完成.2) 主流IDE中都支持Play模板的静态类型检查, 类似JSP. 3) 支持反向路由.举个例子, 一般系统都会有一个固定的页面布局, 比如分出页头页尾。如果用JSP或者Velocity之类的模板， 一般都是通过sitemesh+filter或者在每个页面include来完成布局。使用Play模板, 完成这个功能非常容易。 首先定义一个main页面 main.scala.html：1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
@(title: String = "默认标题")(staticFile: Html = Html(""))(content: Html)

<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
    <meta charset="utf-8" />
    <title>@title</title>


</head>

<body>

@header()  <-- 页头 -->

@navigator() <!-- 导航 -->

@content

<script src="@routes.Assets.versioned("js/jquery-1.11.2.min.js")"></script>

@staticFile
1
@(title: String = "默认标题")(staticFile: Html = Html(""))(content: Html)
这一部分是参数声明，这里声明了三个参数:title标题, 有默认值；staticFile为html代码块, 可以传js等；content为页面内容。1
2
3
@header()  <-- 页头 -->

@navigator() <!-- 导航 -->
这一部分是引用同目录下的另外两个页面：header.scala.html和navigator.scala.html。为什么能这样引用，因为这些页面(main,header,navigator)都会被自动 编译成一个方法（准确地说是一个Scala object，不过这里先当做方法），所以这里相当于方法调用。同样，这个main也会被编译成方法，其他页面可以调用main来完成布局， 例如 login.scala.html1
2
3
4
5
6
7
8
9
@main() {
    <script type="text/javascript">
        FG.user.login();
    </script>
} {
    <div class="login width1200">
    <!-- login -->
    </div>
}
这就是一个简单的登录页面。登录页面调用main页面的方法，第一个参数不传使用默认标题，第二个参数传入登录页面的js代码，第三个参数传入登录页面的html代码。 这样就完成了页面布局, 没有随处可见的include, 也没有暗箱操作的filter, 所有的一切都是方法调用, 是不是很简单清晰？静态类型检查就不说了, 本来Java的一大优点(Que Dian)就是类型检查，所以在Java里用Freemarker或者Velocity这种模板的做法值得商榷。反向路由的意思是, 在Play中, 所有的Controller url都配置在一个routes文件中, 例如1
GET         /register                           @controllers.user.LoginController.registerPage
之后无论是在Controller里还是模板中, 都不用硬编码url。而是使用routes文件。例如在Controller中使用redirect(routes.LoginController.registerPage())就能实现重定向。 而在模板中使用 <a href="@controllers.routes.LoginController.registerPage()">来指向链接。这种风格就是REST里的URI模板。2. 热部署这个上面介绍过，不用重启服务器。3. 内置dev/prod环境，内置部署脚本平常开发的时候使用run启动Play，是跑在dev模式。 Play会定时扫描源码目录进行热更新，并且类都是访问的时候再加载，提高启动速度。 使用start启动项目就运行在prod模式。Play内置dist命令，可以把所有的文件打包成一个zip，解压之后直接运行bin目录下的可执行文件即可启动项目，除了JDK之外无须任何其他外部依赖。 这大大减轻了运维成本，同时也能够很方便的进行持续集成（CI）。4. 使用Play开发的Server大部分能做到Stateless这个之前也说过，Play抛弃了Servlet/JSP里Session等概念, 内置没有提供方法将对象与服务器实例进行绑定(你要使用HashMap存的话Play也没办法)。 推荐的做法是使用外部缓存, 比如Redis, Memcached等。可能有人会觉得没有Session是Play的一个缺点（Play里的Session和Servlet Session不是一回事）, 但是只要你开发过流量大一点的应用, 你就会理解这点。5. 好用的配置库如果你之前开发过Java项目, 肯定写过**.properties或者管理过一大堆的xml。Java内置库对properties文件的处理是很弱的，你不得不自己写一些工具类去进行处理， 而且properties文件还不支持更复杂的语法。Play使用Typesafe Config库，配置文件使用HOCON格式，默认配置文件为application.conf。 你能很容易读取里面的配置, 并且你也可以把自己的配置写在里面。所以项目中基本不需要使用properties或者xml文件了，除了第三方库需要的。6. Play插件RoR框架之所以好用，主要原因之一就是围绕RoR有相当丰富的插件可供选择，很多业务功能甚至都不需要开发就能实现。Play的插件数量当然相对于RoR还是要少一些， 不过你遇到的需求基本都有现成的插件可以使用。比如发邮件, 授权和验证, sitemap生成，第三方登录等等。自己写一个插件也很简单。7. 优秀的测试支持因为Play诞生的时候TDD已经很火热，所以Play对测试的支持非常好。 例如下面的几行代码就能对Controller进行测试。1
2
3
Http.RequestBuilder request = new Http.RequestBuilder().method(POST).uri(routes.LoginController.requestPhoneCode(phone).url());
Result result = route(request);
assertThat(result.status(), is(OK));
Play还内置了对 Selenium WebDriver的支持，可以模拟浏览器进行测试。以下是官方的例子：1
2
3
4
5
6
7
8
9
public class BrowserFunctionalTest extends WithBrowser {

    @Test
    public void runInBrowser() {
        browser.goTo("/");
        assertNotNull(browser.$("title").getText());
    }

}
8. 优秀的REST支持Play2从诞生起就能很容易的支持RESTful风格的架构（因为Play2在设计的时候REST就已经大行其道）， 在Play2中实现RESTful API的示例可以参考Stackoverflow上的这个回答5. 使用Play过程中遇到的坑1. 首次编译速度过慢这是Scala的锅。Scala在编译过程中要经历至少30个步骤， 导致编译速度相当慢。在我的机器上（Core™ i5-4590 CPU @ 3.30GHz，RAM 8GB），编译100多个Scala类大约需要1到2分钟。好在sbt可以增量编译， 即首次编译之后，你再修改代码，编译器只会编译那些它认为需要编译的类，编译几个类的时候速度很快，基本刷新页面就能完成。2. IDE的Scala插件偶尔会误报错误首先得说明，最适合开发Play项目的IDE是IntelliJ IDEA。现在IDEA最新的Scala插件相比之前的版本，已经有很大的提升。 不过偶尔还是会出现误报的情况，这个问题随着新版本插件的发布应该会慢慢解决。3. Scala和Sbt的学习成本较高这可能是初次接触Play的用户遇到的最大障碍。其实对于大多数业务开发人员来说，这不是问题。使用Play for Java版本，项目代码99%都是Java代码， 而Sbt类似于Maven，一旦项目搭建好后不需要过多接触，只要学会几个常用的命令就可以了，例如project root(切换项目), run(启动服务器在dev模式)。 我们团队大部分成员之前都没有接触过Scala和Play，经过一两周的磨合期之后都能很顺利的使用Play进行开发了。4. Play的API变化速度比较快Play的版本号遵循Semantic Versioning，不同主版本的API变化非常大，比如Play1和Play2就是两个不同的框架。 而副版本之间API也会有一些变化，而且不一定完全向后兼容。例如使用Play2.3.x的项目在升级到2.4的时候，需要按照官方提供的迁移手册进行代码修改， 不然是运行不了的。这对于其他背景的开发者来说可能比较容易理解，但是如果是一直习惯于使用Spring MVC或Struts2的话，可能会对这点感到不适。6.总结Play2可以算是一个现代化的框架，吸收了RoR诸多优点，同时又解决了Java开发中的一些痛点，在国外已经被大量使用。参见  数据来源(http://www.infoq.com/research/jvm-web-frameworks)Play和Spring MVC的定位有些相似，但是比Spring MVC提供更丰富的功能，和Web有关的项目都可以使用Play。但是如果要用好Play，对团队有一定的要求。首先，你的团队应该不是墨守成规的团队。大部分人都害怕变化，这是不争的事实。JDK的发展缓慢加上国内的技术氛围，着实让Java开发人员过了几年的舒服日子。 你如果是05年学会了ibatis和Spring，然后这十年去环游世界了，在15年你照样能轻松找到一份待遇还算可以的工作。然而事情已经开始发生变化，不会学习可能会被淘汰。其次，你的团队应该重视工作效率和质量，并且有时间做出改进。国内很多团队信奉的是人海战术。以低薪聘请大量不合格的开发人员来开发业务功能， 而不是注重单人的工作效率和质量，很多项目的加班和延期都源于此。这样的团队就不适合用Play。很难想象每天都要加班去应付工作的团队有时间打磨升级自己的工具和技能。 但是反过来低效率的工具和技能又拖累了自己的工作效率，这是一个恶性循环。最后，团队中需要有人对Scala和Sbt有一定的了解。虽然Play有Java版本可以使用，但是如果不会Scala和Sbt，在搭建环境，使用一些高级功能（如Filter）的时候可能会遇到麻烦。下篇我会介绍Play和Spring还有JPA（Hibernate）的集成，毕竟Spring在大部分Java项目还是主流。有问题和建议欢迎指出。 本文借鉴：http://skaka.me/blog/2015/07/27/play1/

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

eclipse安装subversion(SVN)版本控制插件
陈科肇
查看插件更新站点
网址：http://subclipse.tigris.org/servlets/ProjectProcess?pageID=p4wYuA 
网站截图： 
 
根据自己的eclipse版本，选择需要的更新站点.
使用eclipse集成subservion插件
Help > Install New Software…> 
 
 
 
 
 
等待下载安装插件… 
 
遇到这种情况，点OK继续！ 
 
最后一步，重启eclipse就可以了.
检验安装结果
 
 

插件安装成功！

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[笔记]软件体系结构(2)--分层
分层是大家耳熟能详的体系结构模式，如ISO7层模型、Struts的MVC，Web项目常用的运行视图分层表现层/业务层/数据访问层。
可能概念/原则上比较好理解，网络上比较完整的讲解极少。整理完一遍，对分层的理解更清晰了：在怎样的场景需要考虑分层，分层的具体方式（经常遗漏的重复考虑分层、错误处理），在分层过程中对其优势点的平衡等


【概述】
层的应用背景：有助于构建能够被分解成子任务组的应用系统，其中每个子任务组处于1个特定的抽象层次上
与单块协议相比，分层方法被视为更好的实践，支持分工（效率）、单个部件方案替换


【原则】


层与层之前使用接口交互，保持稳定每层是可替换的，其变化不影响整体系统（即影响限制在层组件内）层，松耦合，高内聚。不同层提供的功能不重叠不跨层访问：自顶向下的消息和控制流称之“请求”（1->N低层请求，推模式），自底向上调用可以称为“通知”（N低层 ->压缩1个更高结构通知）   （为什么？可维护性：可替换性、AOP支持）



【细节】
例子 -- ISO7层模型
语境 -- 一个需要被分解的大系统
问题 -- 系统混合低层高层问题，往往需要一个与其垂直子划分正交的水平构建，使几个独立操作处于同一抽象层

需要平衡的强制条件有：


变更影响可控、接口稳定、组件可替换、低层重用度（在其他系统）、分工效率。“考虑到一般变更的设计是优秀系统深化的一个主要助推器”

解决方案/结构 -- 自顶向下 N~1
动态特性 -- 自顶向下请求，自底向上通知（如设备驱动探测输入）、被满足即止而非要全层访问
实现 -- 

1、为把任务分组成层而定义抽象准则
2、根据抽象准则定义抽象层数
3、给每个层命名并指定其任务
4、指定服务：层间共享模块放松了严格 分层的原则
5、细化分层：重复1~4步骤，进化到自然/稳定分层
6、为每层指定一个接口
7、构建独立层：
8、指定相邻层间的通信：推/拉
9、分离邻接层：
   单路耦合
   自底向上通信，也可使用回调函数且保留自顶向下单路耦合，高层要注册低层的回调函数，从低层发往高层的可能事件集固定时，这种方式特别有效。反应器模式、命令模式
10、设计一种错误处理策略：尽可能在最低层处理错误，至少将相似错误类型归类，并仅传播这些更一般的错误



已解决的例子 -- TCP/IP协议
变体 -- 

松散分层系统：每个层可以使用比它低的所有层的服务。 灵活性/性能的增加是对可维护性丧失的回报。常用于基础结构系统，如Unix操作系统，修改较少，性能更重要
通过继承分层：面向对象，耦合不利可维护性

已知使用--虚拟机（Run Every Where）etc
效果 --

优点：重用、标准化支持、局部依赖性（可测试性）、可替换性/移植、分工/变更效率
不足：更改行为的重叠、降低效率（如可直接从N-1中间其他透传层）、层的正确粒度（层少优势不能发挥，层多有冗余/性能开销）





版权声明：本文为博主原创文章，未经博主允许不得转载。

领域驱动设计学习笔记
        最近学习了领域驱动设计，基本上熟悉了领域驱动的一些基本术语以及一些分析的方法，并结合了实际的开发架构。基本的概念是通过《领域驱动设计：软件核心复杂性应对之道》这本书来进行学习的，里面详细讲解了领域驱动的一些基本概念以及领域驱动的多个设计模式，如果想对领域驱动进行深入学习的话，这本书是一个不错的基础。
        有了基本的概念之后，为了与实际的开发进行结合，我还阅读了《领域驱动设计C# 2008实现问题.设计.解决方案》。这本书作者通过实际的项目来展开讲解的，前面几章根据领域驱动的概念设计了领域驱动的基础框架，并对项目的架构进行了明确的分层。基础的框架里面包括了领域对象的基础类，仓储接口，DI注入实现，工作单元的实现等等。接下来的几章通过对项目的分析、建模分别设计了不同业务的领域对象，并对对象的仓储做了实现。
        以下是我收集的领域驱动设计的书籍http://yunpan.cn/cmf5zztizjstw         访问密码 4111
        如果只是想了解领域驱动设计的话可以浏览：
        基本介绍：http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html
        四色分析法：http://www.infoq.com/cn/articles/xh-four-color-modeling/


        对于领域驱动的扩展学习可以有CQRS架构、DCI架构等等。

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        最全的Spring面试题和答案
1、什么是Spring框架？Spring框架有哪些主要模块？        Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。       Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。更多信息：Spring 框架教程。2、使用Spring框架能带来哪些好处？下面列举了一些使用Spring框架带来的主要好处：          Dependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。          与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。         Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。 要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。         Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。3、什么是控制反转(IOC)？什么是依赖注入？         控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。         控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？在Java中依然注入有以下三种实现方式：构造器注入Setter方法注入接口注入4、请解释下Spring框架中的IoC？           Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。           BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。org.springframework.beans.factory.BeanFactory 是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC 容器的核心接口。5、BeanFactory和ApplicationContext有什么区别？         BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。          BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。提供了支持国际化的文本消息统一的资源文件读取方式已在监听器中注册的bean的事件以下是三种较常见的 ApplicationContext 实现方式：1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。


ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);
2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。

ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);
3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。6、Spring有几种配置方式？将Spring配置到应用开发中有以下三种方式：基于XML的配置 基于注解的配置 基于Java的配置7、如何用基于XML配置的方式配置Spring？          在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。           SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）           Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。 <beans>
 
    <!-- JSON Support -->
    <bean name="viewResolver" class="org.springframework.web.servlet.view.BeanNameViewResolver"/>
    <bean name="jsonTemplate" class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
 
    <bean id="restTemplate" class="org.springframework.web.client.RestTemplate"/>
 
</beans>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。<web-app>
  <display-name>Archetype Created Web Application</display-name>
 
  <servlet>
        <servlet-name>spring</servlet-name>
            <servlet-class>
                org.springframework.web.servlet.DispatcherServlet
            </servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
 
    <servlet-mapping>
        <servlet-name>spring</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
 
</web-app>8、如何用基于Java配置的方式配置Spring？            Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与<bean/> 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。最简单的@Configuration 声明类请参考下面的代码： @Configuration
public class AppConfig
{
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}对于上面的@Beans配置文件相同的XML配置文件如下： <beans>
    <bean id="myService" class="com.howtodoinjava.services.MyServiceImpl"/>
</beans>上述配置方式的实例化方式如下：利用AnnotationConfigApplicationContext 类进行实例化 public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}要使用组件组建扫描，仅需用@Configuration进行注解即可： @Configuration
@ComponentScan(basePackages = "com.howtodoinjava")
public class AppConfig  {
    ...
}在上面的例子中，com.acme包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照Sring bean定义进行注册。如果你要在你的web应用开发中选用上述的配置的方式的话，需要用AnnotationConfigWebApplicationContext 类来读取配置文件，可以用来配置Spring的Servlet监听器ContrextLoaderListener或者Spring MVC的DispatcherServlet。 <web-app>
    <!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>
 
    <!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.howtodoinjava.AppConfig</param-value>
    </context-param>
 
    <!-- Bootstrap the root application context as usual using ContextLoaderListener -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
 
    <!-- Declare a Spring MVC DispatcherServlet as usual -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext -->
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.howtodoinjava.web.MvcConfig</param-value>
        </init-param>
    </servlet>
 
    <!-- map all requests for /app/* to the dispatcher servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>9、怎样用注解的方式配置Spring？            Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。             注解装配在Spring中是默认关闭的。所以需要在Spring文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 <beans>
 
   <context:annotation-config/>
   <!-- bean definitions go here -->
 
</beans>在 <context:annotation-config/>标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。下面是几种比较重要的注解类型：@Required：该注解应用于设值方法。@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy。10、请解释Spring Bean的生命周期？            Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。            Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。           初始化之后调用的回调方法。           销毁之前调用的回调方法。          Spring框架提供了以下四种方式来管理bean的生命周期事件：         InitializingBean和DisposableBean回调接口         针对特殊行为的其他Aware接口         Bean配置文件中的Custom init()方法和destroy()方法         @PostConstruct和@PreDestroy注解方式         使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下： <beans>
    <bean id="demoBean" class="com.howtodoinjava.task.DemoBean"
            init-method="customInit" destroy-method="customDestroy"></bean>
</beans>更多内容请参考：Spring生命周期Spring Bean Life Cycle。11、Spring Bean的作用域之间有什么区别？         Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。 全局作用域与Servlet中的session作用域效果相同。更多内容请参考 : Spring Bean Scopes。					           原文地址：http://www.itmmd.com/201504/714.html   该文章由 萌萌的IT人 整理发布,转载须标明出处。 

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

后端分布式系列：分布式存储－HDFS DataNode 设计实现解析
前文分析了 NameNode，本文进一步解析 DataNode 的设计和实现要点。
文件存储
DataNode 正如其名是负责存储文件数据的节点。HDFS 中文件的存储方式是将文件按块（block）切分，默认一个 block 64MB（该大小可配置）。若文件大小超过一个 block 的容量可能会被切分为多个 block，并存储在不同的 DataNode 上。若文件大小小于一个 block 的容量，则文件只有一个 block，实际占用的存储空间为文件大小容量加上一点额外的校验数据。也可以这么说一个文件至少由一个或多个 block 组成，而一个 block 仅属于一个文件。
block 是一个逻辑概念对象，由 DataNode 基于本地文件系统来实现。每个 block 在本地文件系统中由两个文件组成，第一个文件包含文件数据本身，第二个文件则记录 block 的元信息（metadata）如：数据校验和（checksum）。所以每一个 block 对象实际物理对应两个文件，但 DataNode 不会将文件创建在同一个目录下。因为本机文件系统可能不能高效的支持单目录下的大量文件，DataNode 会使用启发式方法决定单个目录下存放多少文件合适并在适当时候创建子目录。
文件数据存储的可靠性依赖多副本保障，对于单一 DataNode 节点而言只需保证自己存储的 block 是完整且无损坏的。DataNode 会主动周期性的运行一个 block 扫描器（scanner）通过比对 checksum 来检查 block 是否损坏。另外还有一种被动的检查方式，就是当读取时检查。
文件操作
HDFS 支持的文件操作包括写入（新增、追加）、读取和删除。HDFS 定义了一种 multi-reader, single-writer 的文件访问语义。而访问标准依然参照大家熟悉的依据 POSIX（Portable Operating System Interface）为单机文件系统定义的 API。

Open 打开文件  
Read/Write 读写文件  
Close 关闭文件

下面我们分别讲述文件操作的设计实现要点。
写文件

写文件流程如图示，在分布式环境下，Client 请求 NameNode 获得一个针对指定文件的租约（lease，本质上是一种分布式锁，详细请自行维基百科下）。只有持有该租约的 Client 可以向该文件写入，以这种机制来确保写文件的 single-writer 的语义。获得写入租约后 NameNode 向 Client 分配一组用于存放文件数据的 DataNodes，若配置的副本数为 3，则会返回 3 个 DataNode。这一组 DataNodes 被组成一条流水线来写入，有效提升写入性能降低写入延迟。Client 将文件组织成一个个 packet 发送给流水线上第一个 DataNode，第一个 DataNode 存储下该 packet 后再转发给第二个 DataNode，依此类推。然后 DataNodes 再按流水线反方向发回确认 packet 给 Client。当所有文件 block 写入完成后，DataNodes 会向 NameNode 报告文件的 block 接收完毕，NameNode 相应去改变文件元数据的状态。
写文件的主体流程如上所述，如果过程中一切正常那么多么简单美好。但实际在分布式环境下，写文件过程涉及 Client、NameNode 和一组 DataNodes，这其中任何一个环节都有可能产生异常。按照分布式设计第一原则：Design for failure，我们需要考这个流程中的所有参与者都有可能出现失败异常的情况。这里先提出这个问题，考虑每种失败异常的场景下，软件设计实现要怎么去处理？本文先不在这里展开论述，后面会专门撰文深入分析。
读文件

读文件流程如图示，Client 首先请求 NameNode 定位文件 block 所在的 DataNodes。然后按顺序请求对应的 DataNodes 读取其上存储的 block。关于读取顺序，HDFS 有一个就近读取的优化策略，DataNodes 的读取排序会按照它们离 Client 的距离来确定。距离的概念主要区分以下几种场景：

距离 0，表示在同一个节点上  
距离 2，表示同一个机架下的不同节点  
距离 4，表示同一个数据中心的不同机架下
距离 8，表示不同的数据中心

删文件
文件删除的处理首先将文件重命名后放进 /trash 目录。文件会在 /trash 目录中存放一段时间（可配置），在时间到期后再自动清理。所以实际上文件删除操作非常轻量级，仅仅是 NameNode 的内存数据结构的变动，真正的物理删除在后续的自动清理时才做。
可见性
在文件写入过程中，HDFS 不保证文件对其他 Client Reader 可见。只有文件的 block 已经写入 DataNode，并报告给了 NameNode 更新到正确的状态才对其他 Reader 可见。简单说，如果一个文件有多个 block，写入总是发生在最后一个 block 上，那么前面的 block 对其他 Reader 是可见的，但最后一个 block 则不可见，这涉及 block 的状态变化，这里先不展开，后面会专门撰文深入分析。
生命周期
DataNode 启动后首先连接到 NameNode 完成握手，握手的目的是验证 DataNode 的软件版本和 namespace ID。namespace ID 是整个 HDFS 集群的唯一标识，如果 DataNode namespace ID 或 软件版本与 NameNode 不匹配，DataNode 将无法加入集群并自动关闭。若是一个全新的 DataNode 启动时没有 namespace ID，则在握手时由 NameNode 分配并加入集群。此外，NameNode 还会分配一个集群全局唯一的 storage ID 给 DataNode 用于唯一标记，之后不再改变。
完成握手后，DataNode 会立刻向 NameNode 发送 block report 信息，block report 就是 DataNode 上存储了哪些文件 block 的列表。之后会定期（默认 1 小时）向 NameNode 报告。此外，DataNode 将定时向 NameNode 发送心跳（默认 3 秒）来报告自身的存活性。一段时间（默认 10 分钟）收不到 DataNode 最近的心跳，NameNode 会认定其死亡，并不会再将 I/O 请求转发到其上。心跳除了用于 DataNode 报告其存活性，NameNode 也通过心跳回复来捎带控制命令要求 DataNode 执行，因为 NameNode 设计上不直接调用 DataNode 其控制命令都是通过心跳回复来执行，所以心跳的默认间隔比较短。
除了 DataNode 的非正常死亡外，DataNode 还可以正常退休，可以通过管理端标记一个 DataNode 进入退休中（decommissioning）状态。处于退休中状态的 DataNode 不再服务于写请求（包括从 Client 写入或从其他 DataNode 复制），但它可以继续服务读请求。进入退休中状态的 DataNode 将被安排将其上存储的所有 block 复制到其他节点，完成这个过程后 NameNode 将其标记为已退休（decommissioned）状态，然后就可以安全下线了。
总结
本文重点描述了，DataNode 生命周期对 HDFS 集群整体的影响以及文件访问操作的流程。对于异常处理部分没有详细展开讲述，这个系列的后续文章还会进一步深入剖析。
参考
[1] Hadoop Documentation. HDFS Architecture. 
[2] Robert Chansler, Hairong Kuang, Sanjay Radia, Konstantin Shvachko, and Suresh Srinivas. The Hadoop Distributed File System 
[3] Tom White. Hadoop: The Definitive Guide. O’Reilly Media(2012-05), pp 94-96



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        常规功能和模块自定义系统(cfcmms)—003概述


常规功能和模块自定义系统(cfcmms)—003概述


一、系统设计思想的来源


      在我多年的编程工作中，所编制多为管理型软件。从最初的企业工资管理软件、劳动工资统计软件，到后来的财务软件、税务软件、反避税查询系统、工程合同资金管理、票据管理等，主要功能都是数据列表展示、录入修改删除、处理、输出、查询、图表这几大块。
       我使用过的编程语言也比较多，从90年代最初的foxbase、foxpro，后来使用过c，c++，vfp，delphi，smartGwt+java，到现在的用js+java开发B/S管理软件。个人觉得各个语言之间就是语法有差异，有各自开发库，用熟了之后都没啥区别。在用过这些语言开发了多年的管理型软件后，我想有必要对开发过程做一下总结，能够设计一套快速开发的系统，对常规功能和模块定义能够简单、快捷的完成。
        相信各位程序员都有这样的心情，同样的东西不想再做第二次。一个模块你设计了一个界面，有列表、增、删、查、改，搜索、导航、导入导出、打印、图表、附件、权限设计等功能，第二个模块如果你还要全部重新做一次，恐怕是没这个心情了。如果有几十上百个模块，那一个个做更是会让人崩溃的事情。另外在系统上线运行后如有微调，例如模块、字段要改个名字，如果还要在后台修改，重新步署、重启服务那也是一件很不方便的事。基于我的编程积累和以上原因，我于2007年开始就着手设计开发一个能够自定义的系统，经过好几年的开发、总结、几次改版重构后，现在使用extjs6
 + java + spring mvc + hibernate + jdbc + mysql(mssql) 的架构开发出可以在前台进行系统配置的管理系统。
       本人一直在小软件公司里工作，与外界的交流也不多，不清楚其他公司的先进架构，只是根据自己的开发经验和客户的需求设计这套系统的各个方面。由于系统都是我设计开发的，在选择前后台的开发语言时就只能着重于易用性和开发的快速性。前台一开始选用的extjs3，在开发了第一个版本之后由于我对js不熟，改用了smartGwt+java的架构。后来由于smartGwt调试起来太慢，在extjs4发布后前台又改回了extjs。后台的选择上一开始使用的是java+ssh，之后学习了spring
 mvc觉得配置更少，用标注语言开发更方便，现在的系统即是基于这几个开发语言之下。


 二、系统的最终目标


        借助于java script语言解释执行的灵活性和java的反射机制，系统的最终目标是可以在浏览器中对系统的各个模块和各种功能进行配置。配置的结果一般只要刷新网页，即可立即生效。（业务逻辑除外）。在作为查询系统使用时，可以一套代码适用于各个不同的系统，只要换个数据库即可换至新的查询系统。


三、系统的适用性

1.本系统适用于模块为树状结构、分层清晰的中小型的管理型软件；
2.可以适用于绝大多数系统作为免代码的综合查询系统；
3.可以快速的为新系统制作原型产品；




对本系统有兴趣的读者可以加入QQ群：386100815；对此系统有任何建议或意见的可以跟贴回复，或者发邮件jfok1972@qq.com 和我进行联系。




版权声明：本文为博主原创文章，未经博主允许不得转载。

SpringMVC入门案例（3）
一个简单的入门实例教程该实例的源码和实例中的jar源码：http://download.csdn.net/detail/swingpyzf/5348563所需要的jar:  http://download.csdn.net/detail/swingpyzf/5348531另外一篇关于SpringMVC 文件上传，多文件上传：http://blog.csdn.net/swingpyzf/article/details/20230865简单注解配置的实例：一、创建项目：1、建立新的动态web项目：2、为项目命名为：SpringMVC_013、添加tomcat运行时环境\依赖库  如果是MyEclipse的话创建web项目时就不需要此步骤右键项目，点击Build Path->Add Librares:添加完后会多出tomcat 的 Servlet包4、最后添加Spring及SpringMVC所需要的jar，我添加以下jar到项目中二、配置文件：1、首先在web.xml中配置一个DispatcherServlet，并通过<servlet-mapping>指定需要拦截的url。 下面xml中配置一个拦截.html为后缀的url.[html] view plaincopyprint?<!-- 配置Spring MVC DispatcherServlet -->      <servlet>          <servlet-name>MVC</servlet-name>          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>          <!-- 初始化参数 -->          <init-param>              <!-- 加载SpringMVC的xml到 spring的上下文容器中 -->              <param-name>contextConfigLocation</param-name>              <param-value>                  /WEB-INF/classes/mvc*.*              </param-value>          </init-param>          <load-on-startup>1</load-on-startup>      </servlet>        <!-- 配置DispatcherServlet所需要拦截的 url -->      <servlet-mapping>          <servlet-name>MVC</servlet-name>          <url-pattern>*.html</url-pattern>      </servlet-mapping>  <!-- 配置Spring MVC DispatcherServlet -->
	<servlet>
		<servlet-name>MVC</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<!-- 初始化参数 -->
		<init-param>
			<!-- 加载SpringMVC的xml到 spring的上下文容器中 -->
			<param-name>contextConfigLocation</param-name>
			<param-value>
				/WEB-INF/classes/mvc*.*
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<!-- 配置DispatcherServlet所需要拦截的 url -->
	<servlet-mapping>
		<servlet-name>MVC</servlet-name>
		<url-pattern>*.html</url-pattern>
	</servlet-mapping> 先配置一个servlet 然后 加载SpringMVC的xml文件到Spring的上下文中。然后配置servlet-mapping，servlet-name为刚刚的servlet中的配置的name，然后指定要拦截的url为*.html 2、配置Spring的上下文监听器，并且指定Spring的xml配置文件的路径。[html] view plaincopyprint?<!-- 监听spring上下文容器 -->  <listener>      <listener-class>          org.springframework.web.context.ContextLoaderListener      </listener-class>  </listener>    <!-- 加载spring的xml配置文件到 spring的上下文容器中 -->  <context-param>      <param-name>contextConfigLocation</param-name>      <param-value>classpath:root-context.xml</param-value>  </context-param>  	<!-- 监听spring上下文容器 -->
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>
	
	<!-- 加载spring的xml配置文件到 spring的上下文容器中 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:root-context.xml</param-value>
	</context-param> 这里指定的路径classpath为 项目编译后的classes文件中。 最终web.xml文件内容：[html] view plaincopyprint?<?xml version="1.0" encoding="UTF-8"?>  <web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee       http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd">      <display-name></display-name>                  <!-- 监听spring上下文容器 -->      <listener>          <listener-class>              org.springframework.web.context.ContextLoaderListener          </listener-class>      </listener>            <!-- 加载spring的xml配置文件到 spring的上下文容器中 -->      <context-param>          <param-name>contextConfigLocation</param-name>          <param-value>classpath:root-context.xml</param-value>      </context-param>            <!-- 配置Spring MVC DispatcherServlet -->      <servlet>          <servlet-name>MVC</servlet-name>          <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>          <!-- 初始化参数 -->          <init-param>              <!-- 加载SpringMVC的xml到 spring的上下文容器中 -->              <param-name>contextConfigLocation</param-name>              <param-value>                  /WEB-INF/classes/mvc*.*              </param-value>          </init-param>          <load-on-startup>1</load-on-startup>      </servlet>        <!-- 配置DispatcherServlet所需要拦截的 url -->      <servlet-mapping>          <servlet-name>MVC</servlet-name>          <url-pattern>*.html</url-pattern>      </servlet-mapping>        <welcome-file-list>          <welcome-file>index.html</welcome-file>      </welcome-file-list>      </web-app>  <?xml version="1.0" encoding="UTF-8"?>
<web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
	http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd">
	<display-name></display-name>
	
	
	<!-- 监听spring上下文容器 -->
	<listener>
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>
	
	<!-- 加载spring的xml配置文件到 spring的上下文容器中 -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:root-context.xml</param-value>
	</context-param>
	
	<!-- 配置Spring MVC DispatcherServlet -->
	<servlet>
		<servlet-name>MVC</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<!-- 初始化参数 -->
		<init-param>
			<!-- 加载SpringMVC的xml到 spring的上下文容器中 -->
			<param-name>contextConfigLocation</param-name>
			<param-value>
				/WEB-INF/classes/mvc*.*
			</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<!-- 配置DispatcherServlet所需要拦截的 url -->
	<servlet-mapping>
		<servlet-name>MVC</servlet-name>
		<url-pattern>*.html</url-pattern>
	</servlet-mapping>

	<welcome-file-list>
		<welcome-file>index.html</welcome-file>
	</welcome-file-list>


</web-app>
3、创建SpringMVC所需要的xml文件和applicationContext的xml文件，这里由于第一步中配置的servlet中init-param所需要加载的格式为：mvc*.* 就是去寻找为mvc开头的文件所以创建SpringMVC的xml文件时必须要有mvc开头，我命名为：mvc-context.xml，并且按照context-param中的配置，将applicationContext文件命名为：root-context.xml；4、配置mvc-context.xml:首先通过import标签 导入root-context.xml,然后通过component-scan标签扫描指定包名，让该包下的所有java类的spring注解生效然后配置SpringMVC的视图渲染解析器，让其前缀为/page/ 后缀为.jsp  这样能够SpringMVC 所需要渲染的路径能够在/page/返回值.jsp中寻找。[html] view plaincopyprint?<!-- 加载Spring的全局配置文件 -->      <beans:import resource="root-context.xml" />            <!-- SpringMVC配置 -->            <!-- 通过component-scan 让Spring扫描org.swinglife.controller下的所有的类，让Spring的代码注解生效 -->      <context:component-scan base-package="org.swinglife.controller"></context:component-scan>            <!-- 配置SpringMVC的视图渲染器， 让其前缀为:/page/ 后缀为.jsp  将视图渲染到/page/<method返回值>.jsp中 -->      <beans:bean          class="org.springframework.web.servlet.view.InternalResourceViewResolver"          p:prefix="/page/" p:suffix=".jsp">          </beans:bean>  <!-- 加载Spring的全局配置文件 -->
	<beans:import resource="root-context.xml" />
	
	<!-- SpringMVC配置 -->
	
	<!-- 通过component-scan 让Spring扫描org.swinglife.controller下的所有的类，让Spring的代码注解生效 -->
	<context:component-scan base-package="org.swinglife.controller"></context:component-scan>
	
	<!-- 配置SpringMVC的视图渲染器， 让其前缀为:/page/ 后缀为.jsp  将视图渲染到/page/<method返回值>.jsp中 -->
	<beans:bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"
		p:prefix="/page/" p:suffix=".jsp">
		</beans:bean>最后mvc-context.xml和root-context.xml为：mav-context.xml:[html] view plaincopyprint?<?xml version="1.0" encoding="UTF-8"?>  <beans:beans xmlns="http://www.springframework.org/schema/mvc"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:beans="http://www.springframework.org/schema/beans"      xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop"      xmlns:context="http://www.springframework.org/schema/context"      xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd                  http://www.springframework.org/schema/aop                  http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">      <!-- 加载Spring的全局配置文件 -->      <beans:import resource="root-context.xml" />            <!-- SpringMVC配置 -->            <!-- 通过component-scan 让Spring扫描org.swinglife.controller下的所有的类，让Spring的代码注解生效 -->      <context:component-scan base-package="org.swinglife.controller"></context:component-scan>            <!-- 配置SpringMVC的视图渲染器， 让其前缀为:/ 后缀为.jsp  将视图渲染到/page/<method返回值>.jsp中 -->      <beans:bean          class="org.springframework.web.servlet.view.InternalResourceViewResolver"          p:prefix="/page/" p:suffix=".jsp">          </beans:bean>      </beans:beans>  <?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd
				http://www.springframework.org/schema/aop
				http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
	<!-- 加载Spring的全局配置文件 -->
	<beans:import resource="root-context.xml" />
	
	<!-- SpringMVC配置 -->
	
	<!-- 通过component-scan 让Spring扫描org.swinglife.controller下的所有的类，让Spring的代码注解生效 -->
	<context:component-scan base-package="org.swinglife.controller"></context:component-scan>
	
	<!-- 配置SpringMVC的视图渲染器， 让其前缀为:/ 后缀为.jsp  将视图渲染到/page/<method返回值>.jsp中 -->
	<beans:bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver"
		p:prefix="/page/" p:suffix=".jsp">
		</beans:bean>


</beans:beans>
 root-context.xml: [html] view plaincopyprint?<?xml version="1.0" encoding="UTF-8"?>  <beans xmlns="http://www.springframework.org/schema/beans"      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"      xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd                  http://www.springframework.org/schema/context                   http://www.springframework.org/schema/context/spring-context-3.2.xsd                  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd">      <!-- Root Context: defines shared resources visible to all other web components -->           </beans>  <?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
				http://www.springframework.org/schema/context
				 http://www.springframework.org/schema/context/spring-context-3.2.xsd
				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd">
	<!-- Root Context: defines shared resources visible to all other web components -->

	 
</beans>
三、编写Controller1、创建org.swinglife.controller的package，用来存放Controller类，接着新建HomeController.java，用来编写首页的Controller2、使用注解@Controller将HomeController类定义为一个Controller,并且在方法中通过@RequestMapping(“value”)来指定所需要访问的路径或者方法名。 SpringMVC可以通过一个@Controller注解将一个POJO转化为处理请求的控制器，通过@RequestMapping为控制器指定哪些需要的请求。[java] view plaincopyprint?@Controller   public class HomeController {            /***      * 首页 返回至/page/home.jsp页面      * @return      */      @RequestMapping("index")      public ModelAndView index(){          //创建模型跟视图，用于渲染页面。并且指定要返回的页面为home页面          ModelAndView mav = new ModelAndView("home");          return mav;      }  }  @Controller 
public class HomeController {
	
	/***
	 * 首页 返回至/page/home.jsp页面
	 * @return
	 */
	@RequestMapping("index")
	public ModelAndView index(){
		//创建模型跟视图，用于渲染页面。并且指定要返回的页面为home页面
		ModelAndView mav = new ModelAndView("home");
		return mav;
	}
}
方法中定义了ModelAndView对象，通过该对象指定所需要渲染的视图为home最后返回ModelAndView 将页面渲染到home.jsp中。 3、最后在WebContent目录中 创建/page/home.jsp使SpringMVC能够寻找并渲染该页面视图。[html] view plaincopyprint?<%@ page language="java" contentType="text/html; charset=GB18030"      pageEncoding="GB18030"%>  <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">  <html>  <head>  <meta http-equiv="Content-Type" content="text/html; charset=GB18030">  <title>home</title>  </head>  <body>  <h2>spring mvc 实例</h2>      </body>  </html>  <%@ page language="java" contentType="text/html; charset=GB18030"
    pageEncoding="GB18030"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GB18030">
<title>home</title>
</head>
<body>
<h2>spring mvc 实例</h2>


</body>
</html>现在一个完整的SpringMVC的模式已经搭建完成了，可以运行项目来进行测试。 四、编写参数的提交与传递：1、编写一个新的UserController类来假定用户登录，将username,password提交到Controller中进行处理，并且登陆成功后将username,password传递到成功的页面。创建UserController.java创建/page/succ.jsp页面 作为用户成功登陆页面UserController中的代码：[java] view plaincopyprint?@Controller  public class UserController {        /***      * 用户登陆      * <p>注解配置，只允许POST提交到该方法      * @param username      * @param password      * @return      */      @RequestMapping(value="login",method=RequestMethod.POST)      public ModelAndView login(String username,String password){          //验证传递过来的参数是否正确，否则返回到登陆页面。          if(this.checkParams(new String[]{username,password})){              //指定要返回的页面为succ.jsp              ModelAndView mav = new ModelAndView("succ");              //将参数返回给页面              mav.addObject("username",username);              mav.addObject("password", password);              return mav;          }          return new ModelAndView("home");      }            /***      * 验证参数是否为空      * @param params      * @return      */      private boolean checkParams(String[] params){          for(String param:params){              if(param==""||param==null||param.isEmpty()){                  return false;              }          }          return true;      }  @Controller
public class UserController {

	/***
	 * 用户登陆
	 * <p>注解配置，只允许POST提交到该方法
	 * @param username
	 * @param password
	 * @return
	 */
	@RequestMapping(value="login",method=RequestMethod.POST)
	public ModelAndView login(String username,String password){
		//验证传递过来的参数是否正确，否则返回到登陆页面。
		if(this.checkParams(new String[]{username,password})){
			//指定要返回的页面为succ.jsp
			ModelAndView mav = new ModelAndView("succ");
			//将参数返回给页面
			mav.addObject("username",username);
			mav.addObject("password", password);
			return mav;
		}
		return new ModelAndView("home");
	}
	
	/***
	 * 验证参数是否为空
	 * @param params
	 * @return
	 */
	private boolean checkParams(String[] params){
		for(String param:params){
			if(param==""||param==null||param.isEmpty()){
				return false;
			}
		}
		return true;
	}首先指定@Controller，然后指定@RequestMapping为login方法； 需要注意的是这次@RequestMapping中指定了页面方法模式必须为POST模式否则将无法访问。其次value参数指定访问路径。并且在login方法中设定带参，参数为表单中的name属性。然后通过ModelAndView的 addObject方法将参数加入到request中，这样则能够在返回的页面中显示这些参数。在此之外还有其他将参数传递到页面中的方式为：[java] view plaincopyprint?/***  * 另一种参数传递的形式  * 通过request来处理请求过来的参数。  * @param username  * @param password  * @param request  * @return  */  @RequestMapping(value="login",method=RequestMethod.POST)  public ModelAndView login(String username,String password,HttpServletRequest request){      request.setAttribute("username", username);      request.setAttribute("password", password);      return new ModelAndView("succ");  }  	/***
	 * 另一种参数传递的形式
	 * 通过request来处理请求过来的参数。
	 * @param username
	 * @param password
	 * @param request
	 * @return
	 */
	@RequestMapping(value="login",method=RequestMethod.POST)
	public ModelAndView login(String username,String password,HttpServletRequest request){
		request.setAttribute("username", username);
		request.setAttribute("password", password);
		return new ModelAndView("succ");
	}以上这种方式则是直接通过将参数加入到request中来使用。 2、编写succ.jsp页面跟表单页面：succ.jsp:[html] view plaincopyprint?<body>  <h2>登陆</h2>     username:${username }  <p>  password:${password }     </body>  <body>
<h2>登陆</h2>
 
username:${username }
<p>
password:${password }
 
</body>form: [html] view plaincopyprint?<form action="login.html" method="post">      username:<input type="text" name="username" />      <p>      password:<input type="password" name="password"/>      <p>      <input type="submit" value="submit" />  </form>  <form action="login.html" method="post">
	username:<input type="text" name="username" />
	<p>
	password:<input type="password" name="password"/>
	<p>
	<input type="submit" value="submit" />
</form> 3、最后运行项目来进行测试：  OK都完成了。以上就是一个比较简单的SpringMVC的示例搭建了。在给出的源码中，还有另一中直接用String当做返回值来指定显示页面的方法。本文借鉴：http://blog.csdn.net/u011225629/article/details/48002333

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

[置顶]
        笨鸟先飞之Java---缠缠绵绵的注解和注释
     在平时的编程中注释一直与我们为伴，但是在Java编程中我们会经常性的使用注解。一字之差，也不知是否会有“失之毫厘差以千里”之说？？
     一起来看：

 一、注解：
    ❁ 首先来看在ITOO Java中使用的注解：
	@Stateless(name = "SystemStudentIdModuleValueBean")
	@Remote(SystemStudentIdModuleValueBean.class)
	@TransactionManagement(TransactionManagementType.CONTAINER)
	@TransactionAttribute(TransactionAttributeType.REQUIRED)
	public class SystemStudentIdModuleValueBeanImpl extends BaseBeanImpl implements
			SystemStudentIdModuleValueBean {
			
			}
    从本质上说，注解就是一种类型！它可以定义、使用，以及包含有自己的属性、方法。
    先来对注解这个东西进行一下宏观的了解：
    1）.注解这个东西主要是给编译器看的，比如最常见的@override表示这个方法重写了父类中的方法；


    2）.大家共同认可的，就可以使用一个公式来代替，以节省代码：这就是注解


    3）.注解为我们在代码中添加信息提供了一种形式化的方法，使我们可以在之后的某个时刻方便的使用这些数据（通过解析注解来使用这些数据），常见的作用有如下几种：
     ○ 生成文档：这是最常见的，也是Java最早提供的注解，常用的有@see,@param,@return等
     ○ 跟踪代码依赖性，实现替代配置文件的功能。现在的框架基本上都使用了这种配置里减少配置文件的数量。

     ○ 
在编译时进行格式检查。如@override放在方法钱前，如果这个方法并不是覆盖的超类的方法，则会在编译时被检查出来。


   ❁ 其次，当我们定义了注解，难道直接使用？？肯定不是的呗！！    
    在使用反射之前必须使用import java.lang.reflect.* 来导入和反射相关的类。
    α要得到某一个类或接口的注解信息，可以使用如下代码：
        Annotation annotation = TestAnnotation.class.getAnnotation(MyAnnotation.class);
    β要得到全部的注解信息可使用如下语句：
        Annotation[] annotations = TestAnnotation.class.getAnnotations();或
        Annotation[] annotations = TestAnnotation.class.getDeclaredAnnotations();  
    γ要得到其它成员的注解，可先得到这个成员，然后再得到相应的注解。如得到myMethod的注解。
        Method method = TestAnnotation.class.getMethod("myMethod", null);
        Annotation annotation = method.getAnnotation(MyAnnotation.class);


PS：要想使用反射得到注解信息，这个注解必须使用@Retention(RetentionPolicy.RUNTIME)进行注解。


   所以注解是编程给我们提供的一个桥梁，帮我们摆脱繁杂无序的代码，使我们无限靠近“面向对象”这座城堡，让我们走向编程世界的更远方：
        

二、注释
    对于每日相伴的注释我们应该很熟悉：主要是帮助我们理解某些代码的或者用来记录一些信息（比如开发时间、开发人员），在myEclipse中：
    • 单行注释：Ctrl+/   : 在行代码上打上双斜线。
    • 多行注释：/**/
    • .jsp页面的注释：<-- 这是要被注释掉的内容 -->
    • .properties页面注释：将键盘切换到英文状态，使用#（或者！）进行注释

   所以注释就像是编程向我们伸出的援助之手，随时向我们提供帮助：
        

三、总结：
    注解和注释虽然一字之差，却带着我们走入两个不同的世界，一个帮助我们理解（不会对编译器或者程序造成影响），一个通过对配置文件的封装帮助我们高效开发：
    注解是J2SE5.0提供的一项非常有趣的功能。它不但有趣，而且还非常有用。如即将出台的EJB3.0规范就是借助于注解实现的。这样将使EJB3.0在实现起来更简单，更人性化。还有Hibernate3.0除了使用传统的方法生成hibernate映射外，也可以使用注解来生成hibernate映射。总之，如果能将注解灵活应用到程序中，将会使你的程序更加简洁和强大。

   到这里，"形似"的注解和注释就说完了，如果有什么问题，欢迎大家踊跃拍砖。也期待大家的交流和意见哦：
          
   


版权声明：本文为博主原创文章，未经博主允许不得转载。

给Java开发者的Play Framework(2.4)介绍 Part2：使用Play，Spring，JPA进行开发
1. 介绍这篇文章会使用Play，Spring，JPA（hibernate）开发一个简单的CRUD功能，主要是为了介绍如何使用Play进行开发。2. 界面截图  很简单的新增和查询功能。我们来看看代码如何实现。3. 代码实现1. Model代码架构使用典型的MVC，分层为Controller-Service-Dao-Model。首先来看Model。1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
//省略了部分字段
@Table(name = "test_object")
@Entity
public class TestObject implements EntityClass<Integer>, OperableData {

    private Integer id;

    private String orderNo;

    /**
     * 状态
     */
    private TestObjectStatus status;

    //...
    /**
     * 下单时间
     */
    private DateTime buyTime;
    //...

    private List<TestObjectItem> testObjectItemList = new ArrayList<>(0);


    @OneToMany(fetch = FetchType.LAZY, mappedBy = "testObject")
    public List<TestObjectItem> getTestObjectItemList() {
        return testObjectItemList;
    }

    public void setTestObjectItemList(List<TestObjectItem> testObjectItemList) {
        this.testObjectItemList = testObjectItemList;
    }

    @GeneratedValue(strategy = GenerationType.AUTO)
    @Id
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }


    @Column(name = "status")
    @Enumerated(EnumType.STRING)
    public TestObjectStatus getStatus() {
        return status;
    }

    public void setStatus(TestObjectStatus status) {
        this.status = status;
    }


    @Column(name = "buy_time")
    @Type(type="org.jadira.usertype.dateandtime.joda.PersistentDateTime")
    public DateTime getBuyTime() {
        return buyTime;
    }

    public void setBuyTime(DateTime buyTime) {
        this.buyTime = buyTime;
    }


}
很普通的Entity，使用JPA注解，唯一需要注意的是在处理枚举类型和Joda DateTime类型的时候用到了不同的类型注解。2. Dao1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
//省略了部分方法
@Repository
public class GeneralDao {

    @PersistenceContext
    EntityManager em;

    public GeneralDao(){}

    public GeneralDao(EntityManager em) {this.em = em;}

    public EntityManager getEm() {
        return em;
    }

    /**
     * 使用jpql进行查询
     * @param ql jpql
     * @param page 分页对象,可选
     * @param queryParams 查询参数
     * @param <T>
     * @return
     */
    public <T> List<T> query(String ql, Optional<Page<T>> page, Map<String, Object> queryParams) {
      //...
    }

    /**
     * 使用jpql进行数据更新操作
     * @param ql
     * @param queryParams
     * @return
     */
    public int update(String ql, Map<String, Object> queryParams) {
      //...
    }

    public <T extends EntityClass<Integer>> void persist(T t) {
        setOperableDataIfNecessary(t, t.getId() == null || t.getId() == 0);
        em.persist(t);
    }

    public <T extends EntityClass<Integer>> T merge(T t) {
        setOperableDataIfNecessary(t, t.getId() == null || t.getId() == 0);
        return em.merge(t);
    }

    public <T extends EntityClass<Integer>> boolean remove(T t) {
        if(t != null) {
            em.remove(t);
            return true;
        } else {
            return false;
        }
    }

    public <T extends EntityClass<Integer>> boolean removeById(Class<T> type, Integer id) {
        T t = get(type, id);
        return remove(t);
    }

    public <T extends EntityClass<Integer>> T get(Class<T> type, Integer id) {
        return em.find(type, id);
    }

    public void flush() {
        em.flush();
    }

    public <T extends EntityClass<Integer>> void refresh(T t) {
        em.refresh(t);
    }

    public <T extends EntityClass<Integer>> void detach(T t) {
        em.detach(t);
    }
}
这里使用的是通用Dao，一般的增删改查操作可以直接通过该Dao完成。可以看出这个Dao只是对JPA的EntityManager一个简单封装， 大部分操作还是委派给EntityManager完成。代码中也可以直接取得EntityManager进行操作。 3. Service1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
//省略了部分方法
@Service
public class TestObjectService {

    @PersistenceContext
    EntityManager em;

    @Autowired
    GeneralDao generalDao;

    @Transactional(readOnly = true)
    public List<TestObject> findByKey(Optional<Page<TestObject>> page, Optional<String> orderNo, Optional<TestObjectStatus> status,
            Optional<DateTime> createTimeStart, Optional<DateTime> createTimeEnd) {

        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<TestObject> cq = cb.createQuery(TestObject.class);
        Root<TestObject> order = cq.from(TestObject.class);

        List<Predicate> predicateList = new ArrayList<>();
        if(orderNo.isPresent()) {
            predicateList.add(cb.equal(order.get("orderNo"), orderNo.get()));
        }
        if(createTimeStart.isPresent()) {
            predicateList.add(cb.greaterThanOrEqualTo(order.get("createTime"), createTimeStart.get()));
        }
        if(createTimeEnd.isPresent()) {
            predicateList.add(cb.lessThanOrEqualTo(order.get("createTime"), createTimeEnd.get()));
        }
        if(status.isPresent()) {
            predicateList.add(cb.equal(order.get("status"), status.get()));
        }

        cq.select(order).where(predicateList.toArray(new Predicate[predicateList.size()])).orderBy(cb.desc(order.get("updateTime")));

        TypedQuery<TestObject> query = em.createQuery(cq);

        if(page.isPresent()) {
            CriteriaQuery<Long> countCq = cb.createQuery(Long.class);
            countCq.select(cb.count(countCq.from(TestObject.class))).where(predicateList.toArray(new Predicate[predicateList.size()]));
            Long count = em.createQuery(countCq).getSingleResult();
            page.get().setTotalCount(count.intValue());

            query.setFirstResult(page.get().getStart());
            query.setMaxResults(page.get().getLimit());
        }

        List<TestObject> results = query.getResultList();

        if(page.isPresent()) {
            page.get().setResult(results);
        }

        return results;
    }


    @Transactional(readOnly = true)
    public TestObject get(Integer id) {
        return generalDao.get(TestObject.class, id);
    }

}
findByKey方法是一个查询方法，这里使用的是JPA的Criteria查询。Service类没有使用接口，只有实现类。Service就是一个Spring管理的Bean， 事务边界在Service层。4. Controller1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
//省略了部分方法
@org.springframework.stereotype.Controller
public class TestObjectController extends Controller {

    @Autowired
    private TestObjectService testObjectService;


    public Result list(String status, String orderNo) {

        List<TestObject> testObjectList = testObjectService.findByKey(of(PageFactory.getPage(request())), ofNullable(orderNo),
                ofNullable(status).map(TestObjectStatus::valueOf), empty(), empty());

        return ok(list.render(testObjectList));
    }

    public Result addPage() {
        return ok(add.render(Form.form(TestObject.class)));
    }

    public Result updatePage(Integer id) {
        return ok(update.render(Form.form(TestObject.class).fill(testObjectService.get(id))));
    }

    //...
}
Controller继承play.mvc.Controller。和SpringMVC一样，在Play中，Controller就是一系列Action的集合。例如我开发用户有关的功能， 那么我就建一个UserController，然后把用户的CRUD方法都放在UserController里，每个方法都有自己的路由规则。这里我们先来看list方法：1
2
3
4
5
6
7
public Result list(String status, String orderNo) {

    List<TestObject> testObjectList = testObjectService.findByKey(of(PageFactory.getPage(request())), ofNullable(orderNo),
            ofNullable(status).map(TestObjectStatus::valueOf), empty(), empty());

    return ok(list.render(testObjectList));
}
这里list的功能是查询出所有满足条件的测试对象（TestObject对象）。首先来看参数，这里声明了两个查询参数status和orderNo，用来匹配Http请求QueryString中的参数， 这和SpringMVC中声明了RequestParam(“status”)的参数类似。注意有一点区别，这里的status和orderNo不能捕捉通过Http Body提交的参数，只能匹配QueryString中的参数。Controller中调用service方法来完成查询，然后将结果返回。方法的返回值声明是play.mvc.Result接口，你可以理解Result的实现类只需要包含两个值： ResponseHeader和ResponseBody。对于ResponseHeader的设置，这里调用父类的ok方法设置返回的Http状态码为200，对应的还有created 201, notFound 404等方法。 ok方法参数需要传入的就是ResponseBody，参数类型声明为play.twirl.api.Content特质（Scala中的特质类似于Java的接口），你基本上永远不需要去手动构造这个特质的实现， 而是使用Play提供的模板。这里我在views.html.test目录下有一个list.scala.html模板，这个模板文件会被IDE自动编译成views.html.test.list类，类里面有一个render方法来完成模板的渲染， render方法返回值就是play.twirl.api.Content的子类。所以我在这里可以直接调用list.render(testObjectList)方法来完成模板的渲染。好了，现在来对照SpringMVC，如果是用SpringMVC的话，这个方法应该是这样的1
2
3
4
5
6
7
8
9
10
11
@RequestMapping(value = "/test/objects", method = RequestMethod.GET)
@ResponseStatus(HttpStatus.OK)  //可省略
public String list(String status, String orderNo, Model model) {

    List<TestObject> testObjectList = testObjectService.findByKey(of(PageFactory.getPage(request())), ofNullable(orderNo),
            ofNullable(status).map(TestObjectStatus::valueOf), empty(), empty());

    model.addAttribute("testObjectList", testObjectList);

    return "views/html/test/list";
}
细心的你可能已经发现了，Play的版本与SpringMVC的对照，少了一个路由的信息，那么在Play中怎么配置路由呢，请看下节5. routes文件（路由）在Play中，所有的路由信息都是统一放在一个文件里，即conf/routes文件。上面的list方法路由在routes中对应如下：1
GET         /test/objects                     @controllers.test.TestObjectController.list(status ?= null, orderNo ?= null)
最左边的GET声明的是Http Method，在Play中每个路由都要明确写出对应的Http Method，中间是路由的URI，最右边是映射的Controller方法。参数status ?= null代表参数是可选的， 如果请求参数中没有status则默认值是null。routes文件的一大好处是在写映射Controller方法的时候IDE能帮助自动补全，并且编译器在编译的时候也能校验声明的参数个数与类型是否一致， 这能有效的帮助开发者减少错误。路由也配好了，剩下的工作就是模板的编写。6. 模板list.scala.html1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
@(testObjects: List[ordercenter.models.TestObject])

@import common.utils.DateUtils._

@main()() {

    <div class="breadcrumbs" id="breadcrumbs">
        <script type="text/javascript">
        try{ace.settings.check('breadcrumbs' , 'fixed')}catch(e){}
        </script>

        <ul class="breadcrumb">
            <li>
                <i class="icon-home home-icon"></i>测试对象管理
            </li>
            <li class="active"><a href="@controllers.test.routes.TestObjectController.list()">测试对象查询</a></li>
        </ul><!-- .breadcrumb -->
    </div>

    <div class="page-content">
        <div class="page-header">
            <h1>
                测试对象管理
                <small>
                    <i class="icon-double-angle-right"></i>测试对象查询
                </small>
            </h1>
        </div>
            <!-- /.page-header -->

        <div class="row">
            <div class="col-xs-12">
                    <!-- PAGE CONTENT BEGINS -->

                <div class="row">
                    <div class="col-xs-12">
                        <div class="table-responsive">
                            <table id="sample-table-1" class="table table-striped table-bordered table-hover">
                                <thead>
                                    <tr>
                                        <th>状态</th>
                                        <th>买家</th>
                                        <th class="hidden-480">金额</th>
                                        <th>下单时间</th>
                                        <th></th>
                                    </tr>
                                </thead>

                                <tbody>
                                @for(testObject <- testObjects) {
                                    <tr>
                                        <td>@testObject.getStatus.value</td>
                                        <td>@testObject.getBuyerId</td>
                                        <td>@testObject.getActualFee</td>
                                        <td>@printDateTime(testObject.getCreateTime) </td>
                                        <td>
                                            <div class="visible-md visible-lg hidden-sm hidden-xs btn-group">
                                                <button class="btn btn-xs btn-info" onclick="location.href='@controllers.test.routes.TestObjectController.updatePage(testObject.getId)'">
                                                    <i class="icon-edit bigger-120"></i>
                                                </button>
                                                <button class="btn btn-xs btn-success" onclick="location.href='@controllers.test.routes.TestObjectController.list()'">
                                                    <i class="icon-info bigger-120"></i>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                }

                                </tbody>
                            </table>
                        </div><!-- /.table-responsive -->
                    </div><!-- /span -->
                </div>
            </div>
        </div>
    </div>
}
Play的模板引擎是Twirl，关于这个引擎的介绍可以参考上一篇文章。@(testObjects: List[ordercenter.models.TestObject])是参数声明，写Play模板的时候，建议参数都通过这种声明的形式传入，而不是使用页面隐藏对象。 因为编译器能够自动帮我们校验类型和个数，重构起来也会更方便。下面一行@import common.utils.DateUtils._引入了定义好的一个工具类， 下面的@printDateTime(testObject.getCreateTime)用来格式化显示时间。@main()() {...}的形式是调用main模板完成渲染，main模板前两个参数可以省略，第三个参数需要传入html代码。在Scala中，方法调用既可以用小括号，比如println("ok")， 也可以用大括号println{"ok"}。而这里第三个参数使用的是大括号。@for(testObject <- testObjects){}是循环的写法，这里循环testObjects，取出每一条记录用来显示。onclick="location.href='@controllers.test.routes.TestObjectController.list()'"绑定了onClick事件，用户在点击的时候会跳转到测试对象的编辑页面。 这里没有硬编码uri，而是使用routes反向路由的写法。之所以能这样写，是因为IDE在编译的时候会根据routes文件自动生成一个routes对象， 对象里面的方法对应的就是我们配置好的controller方法映射。这里写的@controllers.test.routes.TestObjectController.list()在模板渲染的时候就会被替换成/test/objects这个URI。4. 总结这一篇主要介绍了Play在整合Spring和JPA之后是如何进行开发的。可以看出，开发Play应用与开发SSH应用没有太大区别，只是Controller和模板的写法有所不同， 但是我们能很快享受到Play的便利：简单易用的模板，修改代码无需重启服务器，不需要配置外部服务器，etc。随着业务和技术的扩展，使用Play的项目更容易整合其他服务。 例如整合监控工具StatsD+Graphite+Grafana+Kamon，Docker化，服务化。这篇文章我没有介绍如何启动应用，因为这需要一些开发环境的准备，以及了解SBT的基本用法。这些内容我会在下一篇博客介绍。这篇文章相关的代码已经提交到Github， 项目地址。 这个项目整合了Play，Spring，JPA，数据存储使用MySQL和Redis，使用Bootstrap作为页面框架，可以作为脚手架项目给有兴趣的朋友进行研究。除此之外，感兴趣的朋友还可以下载Typesafe Reactive Platform进行学习。这这上面有很多关于Play，Akka的项目模板， 并且你可以通过浏览器查看编辑这些代码，还可以直接运行。另外要进一步学习可以读这本书，网上有电子版的。下篇我会介绍如何搭建开发环境，以及如何调试应用。掌握了之后，你会发现开发和调试过程原来还能这样直观和简单!

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

Spring之Aop与Ioc
用Spring用了这么久，也该找个时间总结总结，这里我并没有把Aop和Ioc分开讲。
首先概述一下Spring，Spring是一款设计非常好的解耦框架，无侵入性，可以整合其它很多框架，比如常用的Struts,Hibernate,Mybatis或者Ibatis等，由此可以解决企业开发的复杂性，其核心的两个东西，就是AOP和IOC。
Spring包含了7个模块，每个模块可以独立存在

每个模块的作用如下（这里参考的其它博客。原文地址：http://www.ibm.com/developerworks/cn/java/wa-spring1，感谢作者）：


核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。

IOC：

概念：控制反转，因为这个名字晦涩难懂，后来Martine Fowler将其取名为依赖注入(DI)，它不是什么技术，只是一种思想
IOC容器：可以实现控制反转功能的容器

原理：为何叫控制反转，因为我们在javaee中要使用某个对象的方法，通常是要new一下这个对象，可以理解为正转，就是普通处理的方式，但是这样就会出现大量依赖的对象，比如A依赖B，A依赖C，出现了大量的耦合，那么控制反转为什么叫反转，因为它把对象交给了Spring容器处理，并非在程序里面声明，把对象交给外部容器处理，内部程序只需调用，其实就是使用了java的反射技术，在程序运行时动态创建，调用对象，在Spring运行时，和其配置文件动态创建，调用对象，也就是Spring容器初始化，装配及管理Bean对象，这些Bean对象再由IOC容器进行控制管理


从图中可以看出控制反转IOC实际包括DL和DI，即依赖查找和依赖注入两种方式，前者是获取依赖关系，后者是注入依赖关系。


关于控制反转IOC，我这里还想罗嗦两句：控制反转这个概念确实不是很好理解，而且这个概念很泛，首先最基本的我要说明的是IOC并不是Spring特有的，在其它框架中也有这个概念，依赖注入在类似框架中只是一种思想，依赖注入实现的方式主要有三种：接口注入，设值注入，构造注入。IOC主要出现过两次较大的争议：一是IOC的概念很模糊抽象，容易让人迷惑，而是作者引入依赖注入代替控制反转后，使用构造注入还是设值注入好，当然作者的观点是可以先使用构造注入，如果出现问题再换成设值注入，个人觉得不如一开始就采用后者（仅个人观点），作者Martine
 Fowler提出使用XML的方式配置比编码的方式配置好，这也符合OO思想，事实也的确这样。
注入方式（依赖注入）在Spring中的具体实现：
            1.接口注入：这种方法由于具有一定的侵入性，而且实际开发中也不常见，暂且不予研究
            2.设值注入：
            3.构造注入：

（时间比较晚了，先暂时放一放）


AOP：
概念：面向切面编程（Aspect-Oriented Programming的缩写），它也是一种编程的思想，AOP将系统分成了核心业务逻辑和横向的通用逻辑，也就是所谓的方面，这些方面像持久化管理，事务管理，安全管理，日志管理和调试管理等都属于系统通用的逻辑，这样我们通过配置Spring的配置文件就可以重复利用这些通用的逻辑，避免了代码的冗余，配置了该切面的方法后，Spring运行到该方法时会被Spring拦截执行
让我们从定义一些重要的AOP概念开始。
　　— 方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的Advisor或拦截器实现。
　　— 连接点（Joinpoint）：程序执行过程中明确的点，如方法的调用或特定的异常被抛出。
　　— 通知（Advice）：在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。
　　— 切入点（Pointcut）：指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点，例如，使用正则表达式。
　　— 引入（Introduction）：添加方法或字段到被通知的类。Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现IsModified接口，来简化缓存。
　　— 目标对象（Target Object）：包含连接点的对象，也被称作被通知或被代理对象。
　　— AOP代理（AOP Proxy）：AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。
　　— 编织（Weaving）：组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。

原理：AOP的实现主要通过代理来实现的，这里分为两种：（http://my.oschina.net/chape/blog/136453，来自该博文分享，感谢博文作者）
           1.静态代理：针对每个具体的类编写代理类；针对一个接口编写一个代理类

            2.动态代理：针对一个方面编写一个Invocation Handler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类
动态代理：
不用写代理类，虚拟机根据真实对象实现的接口产生一个类，通过类实例化一个动态代理，在实例化动态代理时将真实对象及装备注入到动态代理中，向客户端公开的是动态代理，当客户端调用动态代理方法时，动态代理根据类的反射得到真实对象的Method,调用装备的invoke方法，将动态代理、 Method、方法参数传与装备的invoke方法，invoke方法在唤起method方法前或后做一些处理。 
     

             1、产生动态代理的类:


                            java.lang.refect.Proxy


             2、装备必须实现InvocationHandler接口实现invoke方法


AOP和IOC是Spring中非常重要的两大核心，如果弄清了它们，基本上就弄清了Spring，而且IOC和AOP是互相补充的，以此解决业务上的复杂问题
好了，暂时Ok吧，时间比较晚了，具体的例子只有抽空再写了








版权声明：本文为博主原创文章，未经博主允许不得转载。

JAVA操作Excel文件

JAVA EXCEL API:是一开放源码项目，通过它Java开发人员可以读取Excel文件的内容、创建新的Excel文件、更新已经存在的Excel文件。使用该API非Windows操作系统也可以通过纯Java应用来处理Excel数据表。因为它是使用Java编写的，所以我们在Web应用中可以通过JSP、Servlet来调用API实现对Excel数据表的访问。

下载：

Java Excel API的jar包可以通过以下URL获得：

http://sourceforge.net/projects/jexcelapi/files/jexcelapi/2.6.6/jexcelapi_2_6_6.zip/download

（包括所有版本）：http://sourceforge.net/projects/jexcelapi/files/

直接下载地址（迅雷上新建任务即可）：

http://nchc.dl.sourceforge.net/project/jexcelapi/jexcelapi/2.6.6/jexcelapi_2_6_6.zip 

示例1：读取本地Excel文件F:\红楼人物.xls

1.       新建Excel文件F:\红楼人物.xls

内容如下：



2.       Java通过jexcelapi包操作excel文件：




//in ExcelOperater   
  
import java.io.File;   
  
import java.io.FileInputStream;   
  
import java.io.InputStream;   
  
    
  
import jxl.Cell;   
  
import jxl.CellType;   
  
import jxl.Sheet;   
  
import jxl.Workbook;   
  
import jxl.write.Label;   
  
    
  
public class ExcelOperater    
  
{   
  
    public static void main(String[] args)    
  
    {   
  
        jxl.Workbook readwb = null;   
  
        try    
  
        {   
  
            //构建Workbook对象, 只读Workbook对象   
  
            //直接从本地文件创建Workbook   
  
            InputStream instream = new FileInputStream("F:/红楼人物.xls");   
  
            readwb = Workbook.getWorkbook(instream);   
  
    
  
            //Sheet的下标是从0开始   
  
            //获取第一张Sheet表   
  
            Sheet readsheet = readwb.getSheet(0);   
  
            //获取Sheet表中所包含的总列数   
  
            int rsColumns = readsheet.getColumns();   
  
            //获取Sheet表中所包含的总行数   
  
            int rsRows = readsheet.getRows();   
  
            //获取指定单元格的对象引用   
  
            for (int i = 0; i < rsRows; i++)   
  
            {   
  
                for (int j = 0; j < rsColumns; j++)   
  
                {   
  
                    Cell cell = readsheet.getCell(j, i);   
  
                    System.out.print(cell.getContents() + " ");   
  
                }   
  
                System.out.println();   
  
            }   
  
               
  
            //利用已经创建的Excel工作薄,创建新的可写入的Excel工作薄   
  
            jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(new File(   
  
                    "F:/红楼人物1.xls"), readwb);   
  
            //读取第一张工作表   
  
            jxl.write.WritableSheet ws = wwb.getSheet(0);   
  
            //获得第一个单元格对象   
  
            jxl.write.WritableCell wc = ws.getWritableCell(0, 0);   
  
            //判断单元格的类型, 做出相应的转化   
  
            if (wc.getType() == CellType.LABEL)    
  
            {   
  
                Label l = (Label) wc;   
  
                l.setString("新姓名");   
  
            }   
  
            //写入Excel对象   
  
            wwb.write();   
  
            wwb.close();   
  
        } catch (Exception e) {   
  
            e.printStackTrace();   
  
        } finally {   
  
            readwb.close();   
  
        }   
  
}   
  
}   
  



3.       结果：

①     控制台输出：

人物 等级 大观园位置 金陵十二钗

林黛玉 小姐 潇湘馆 正册

妙玉 世外 栊翠庵 正册

晴雯 丫鬟 怡红院 副册

香菱 妾 蘅芜苑 又副册

②     创建文件F:\红楼人物1.xls



4.       程序解析：

所引用的包：

①     Workbook对象，需要jxl.Workbook包；

②     InputStream、FileInputStream对象：需要java.io.FileInputStream和java.io.InputStream包。

③     Sheet对象：jxl.Sheet包；注意excel中sheet表单的行列从0开始计数。

④     Cell对象：jxl.Cell包；对单元进行处理

⑤     Label：选择jxl.write.label包

⑥     WritableWorkbook、WritableSheet、WritableCelll对象

实例二：3个功能-----从excel文件F:\红楼人物.xls读取数据；生成新的excel文件F:\红楼人物2.xls；修改原excel一个单元并输出为F:\红楼人物3.xls。

原始文件：F:\红楼人物.xls



运行结果：

①     控制台输出：

人物 等级 大观园位置 金陵十二钗

林黛玉 小姐 潇湘馆 正册

妙玉 世外 栊翠庵 正册

晴雯 丫鬟 怡红院 副册

香菱 妾 蘅芜苑 又副册

②     写入输出Excel文件：F:\红楼人物2.xls



③     修改输出文件 F:\红楼人物3.xls （加修饰后输出）


示例程序：




//in ExcelHandle   
  
import jxl.*;   
  
import jxl.format.UnderlineStyle;   
  
import jxl.write.*;   
  
import jxl.write.Number;   
  
import jxl.write.Boolean;   
  
import jxl.Cell;   
  
    
  
import java.io.*;   
  
    
  
public class ExcelHandle   
  
{   
  
    public ExcelHandle()   
  
    {   
  
    }   
  
    /***读取Excel*/  
  
    public static void readExcel(String filePath)   
  
    {   
  
        try  
  
        {   
  
            InputStream is = new FileInputStream(filePath);   
  
            Workbook rwb = Workbook.getWorkbook(is);   
  
            //这里有两种方法获取sheet表:名字和下标（从0开始）   
  
            //Sheet st = rwb.getSheet("original");   
  
            Sheet st = rwb.getSheet(0);   
  
            /**  
 
            //获得第一行第一列单元的值  
 
            Cell c00 = st.getCell(0,0);  
 
            //通用的获取cell值的方式,返回字符串  
 
            String strc00 = c00.getContents();  
 
            //获得cell具体类型值的方式  
 
            if(c00.getType() == CellType.LABEL)  
 
            {  
 
                LabelCell labelc00 = (LabelCell)c00;  
 
                strc00 = labelc00.getString();  
 
            }  
 
            //输出  
 
            System.out.println(strc00);*/  
  
            //Sheet的下标是从0开始   
  
            //获取第一张Sheet表   
  
            Sheet rst = rwb.getSheet(0);   
  
            //获取Sheet表中所包含的总列数   
  
            int rsColumns = rst.getColumns();   
  
            //获取Sheet表中所包含的总行数   
  
            int rsRows = rst.getRows();   
  
            //获取指定单元格的对象引用   
  
            for (int i = 0; i < rsRows; i++)   
  
            {   
  
                for (int j = 0; j < rsColumns; j++)   
  
                {   
  
                    Cell cell = rst.getCell(j, i);   
  
                    System.out.print(cell.getContents() + " ");   
  
                }   
  
                System.out.println();   
  
            }             
  
            //关闭   
  
            rwb.close();   
  
        }   
  
        catch(Exception e)   
  
        {   
  
            e.printStackTrace();   
  
        }   
  
    }   
  
    /**输出Excel*/  
  
    public static void writeExcel(OutputStream os)   
  
    {   
  
        try  
  
        {   
  
   /** 只能通过API提供的 工厂方法来创建Workbook，而不能使用WritableWorkbook的构造函数，因为类WritableWorkbook的构造函数为 protected类型：方法一：直接从目标文件中读取 WritableWorkbook wwb = Workbook.createWorkbook(new File(targetfile));方法 二：如下实例所示 将WritableWorkbook直接写入到输出流*/  
  
            WritableWorkbook wwb = Workbook.createWorkbook(os);   
  
            //创建Excel工作表 指定名称和位置   
  
            WritableSheet ws = wwb.createSheet("Test Sheet 1",0);   
  
            /**************往工作表中添加数据*****************/  
  
            //1.添加Label对象   
  
            Label label = new Label(0,0,"测试");   
  
            ws.addCell(label);   
  
            //添加带有字型Formatting对象   
  
            WritableFont wf = new WritableFont(WritableFont.TIMES,18,WritableFont.BOLD,true);   
  
            WritableCellFormat wcf = new WritableCellFormat(wf);   
  
            Label labelcf = new Label(1,0,"this is a label test",wcf);   
  
            ws.addCell(labelcf);   
  
            //添加带有字体颜色的Formatting对象   
  
            WritableFont wfc = new WritableFont(WritableFont.ARIAL,10,WritableFont.NO_BOLD,false,   
  
                    UnderlineStyle.NO_UNDERLINE,jxl.format.Colour.DARK_YELLOW);   
  
            WritableCellFormat wcfFC = new WritableCellFormat(wfc);   
  
            Label labelCF = new Label(1,0,"Ok",wcfFC);   
  
            ws.addCell(labelCF);   
  
              
  
            //2.添加Number对象   
  
            Number labelN = new Number(0,1,3.1415926);   
  
            ws.addCell(labelN);   
  
            //添加带有formatting的Number对象   
  
            NumberFormat nf = new NumberFormat("#.##");   
  
            WritableCellFormat wcfN = new WritableCellFormat(nf);   
  
            Number labelNF = new jxl.write.Number(1,1,3.1415926,wcfN);   
  
            ws.addCell(labelNF);   
  
               
  
            //3.添加Boolean对象   
  
            Boolean labelB = new jxl.write.Boolean(0,2,true);   
  
            ws.addCell(labelB);   
  
            Boolean labelB1 = new jxl.write.Boolean(1,2,false);   
  
            ws.addCell(labelB1);             
  
            //4.添加DateTime对象   
  
            jxl.write.DateTime labelDT = new jxl.write.DateTime(0,3,new java.util.Date());   
  
            ws.addCell(labelDT);   
  
              
  
            //5.添加带有formatting的DateFormat对象   
  
            DateFormat df = new DateFormat("dd MM yyyy hh:mm:ss");   
  
            WritableCellFormat wcfDF = new WritableCellFormat(df);   
  
            DateTime labelDTF = new DateTime(1,3,new java.util.Date(),wcfDF);   
  
            ws.addCell(labelDTF);   
  
            //6.添加图片对象,jxl只支持png格式图片   
  
            File image = new File("f:\\1.png");   
  
            WritableImage wimage = new WritableImage(0,4,6,17,image);   
  
            ws.addImage(wimage);   
  
            //7.写入工作表   
  
            wwb.write();   
  
            wwb.close();   
  
        }   
  
        catch(Exception e)   
  
        {   
  
            e.printStackTrace();   
  
        }   
  
    }   
  
    /** 将file1拷贝后,进行修改并创建输出对象file2  
 
     * 单元格原有的格式化修饰不能去掉，但仍可将新的单元格修饰加上去，  
 
     * 以使单元格的内容以不同的形式表现  
 
     */  
  
    public static void modifyExcel(File file1,File file2)   
  
    {   
  
        try  
  
        {   
  
            Workbook rwb = Workbook.getWorkbook(file1);   
  
            WritableWorkbook wwb = Workbook.createWorkbook(file2,rwb);//copy   
  
            WritableFont wfc = new WritableFont(WritableFont.ARIAL,10,WritableFont.NO_BOLD,false,   
  
                    UnderlineStyle.NO_UNDERLINE,jxl.format.Colour.BLUE);   
  
            WritableCellFormat wcfFC = new WritableCellFormat(wfc);    
  
            WritableSheet ws = wwb.getSheet(0);   
  
            WritableCell wc = ws.getWritableCell(0,0);   
  
            //判断单元格的类型,做出相应的转换   
  
            if(wc.getType() == CellType.LABEL)   
  
            {   
  
                Label labelCF =new Label(0,0,"人物（新）",wcfFC);   
  
                ws.addCell(labelCF);     
  
              //Label label = (Label)wc;   
  
              //label.setString("被修改");   
  
            }   
  
          wwb.write();   
  
            wwb.close();   
  
            rwb.close();   
  
        }   
  
        catch(Exception e)   
  
        {   
  
            e.printStackTrace();   
  
        }   
  
    }   
  
    //测试   
  
    public static void main(String args[])   
  
    {   
  
        try  
  
        {   
  
            //读EXCEL   
  
        ExcelHandle.readExcel("F:/红楼人物.xls");   
  
            //输出EXCEL   
  
        File filewrite=new File("F:/红楼人物2.xls");   
  
        filewrite.createNewFile();   
  
        OutputStream os=new FileOutputStream(filewrite);   
  
        ExcelHandle.writeExcel(os);   
  
            //修改EXCEL   
  
        ExcelHandle.modifyExcel(new File("F:/红楼人物.xls"), new File("F:/红楼人物3.xls"));   
  
        }   
  
        catch(Exception e)   
  
        {   
  
        e.printStackTrace();   
  
        }   
  
    }   
  
}   
  



附：

调用流程如下:
1.打开工作文件Workbook，在此之前先用java的io流创建或者读取文件
2.打开工作表Sheet
3.读行，然后读列。注意，行和列是从零开始的
4.取得数据进行操作
 

来自网络à读取Excel数据表

第一步：创建Workbook（术语：工作薄）

2种方法：Workbook，就可以通过它来访问Excel Sheet（术语：工作表）：




//从输入流创建Workbook读取excel数据表   
  
    InputStream is = new FileInputStream(sourcefile);   
  
    jxl.Workbook workbook = Workbook.getWorkbook(is);   
  
//直接从本地文件（.xls）创建Workbook   
  
Workbook workbook = Workbook.getWorkbook(new File(excelfile));   



一旦创建了

第二步：访问sheet。

2种方法：通过sheet的名称；或者通过下标，下标从0开始。




//获取第一张Sheet表   
  
Sheet rs = workbook.getSheet(0);   
  
一旦得到了Sheet，就可以通过它来访问Excel Cell（术语：单元格）。   
  
第三步：访问单元格cell   
  
//获取第一行，第一列的值   
  
Cell c00 = rs.getCell(0, 0);   
  
String strc00 = c00.getContents();   
  
//获取第一行，第二列的值   
  
Cell c10 = rs.getCell(1, 0);   
  
String strc10 = c10.getContents();   
  
//获取第二行，第二列的值   
  
Cell c11 = rs.getCell(1, 1);   
  
String strc11 = c11.getContents();   
  
    
  
System.out.println("Cell(0, 0)" + " value : " + strc00 + "; type : " + c00.getType());   
  
System.out.println("Cell(1, 0)" + " value : " + strc10 + "; type : " + c10.getType());   
  
System.out.println("Cell(1, 1)" + " value : " + strc11 + "; type : " + c11.getType());   
  



第四步：操作数据

如果仅仅是取得Cell的 值，我们可以方便地通过getContents()方法，它可以将任何类型的Cell值都作为一个字符串返回。如果有需要知道Cell内容的确切类型，API也提供了一系列的方法：




String strc00 = null;   
  
double strc10 = 0.00;   
  
Date strc11 = null;   
  
Cell c00 = rs.getCell(0, 0);   
  
Cell c10 = rs.getCell(1, 0);   
  
Cell c11 = rs.getCell(1, 1);   
  
if(c00.getType() == CellType.LABEL)   
  
{   
  
LabelCell labelc00 = (LabelCell)c00;   
  
strc00 = labelc00.getString();   
  
}   
  
if(c10.getType() == CellType.NUMBER)   
  
{   
  
NmberCell numc10 = (NumberCell)c10;   
  
strc10 = numc10.getValue();   
  
}   
  
if(c11.getType() == CellType.DATE)   
  
{   
  
DateCell datec11 = (DateCell)c11;   
  
strc11 = datec11.getDate();   
  
}   
  
    
  
System.out.println("Cell(0, 0)" + " value : " + strc00 + "; type : " + c00.getType());   
  
System.out.println("Cell(1, 0)" + " value : " + strc10 + "; type : " + c10.getType());   
  
System.out.println("Cell(1, 1)" + " value : " + strc11 + "; type : " + c11.getType());   
  



在得到
单机千万并发连接实战
　　c10k，c100k，c1000k等问题大家都已经司空见惯，那么10m（千万）并发连接呢？今天就来一起挑战一下吧。
准备机器
　　10m连接，大家的个人电脑肯定无法满足要求，如果不是在大公司任职，弄个实际的物理机对大家是个奢望。那么怎么办？我也面临同样问题。 
　　现在的云计算这么发达，还可以按小时计费，一小时的费用也就几元，那就试试云计算产品吧。小编先是在阿里云上测试，但阿里云的按需付费主机配置不高，费了不少时间，最终只跑到了3m个连接。阿里云的不行，是主机的配置问题还是程序的问题呢？为了得到最终的结论，我尝试了其他的云产品，最终ucloud的云主机给了我兴奋的答案。
　　首先创建ucloud主机 
ucloud主机（一共需要两台，一台作为服务器，一台作为客户端）： 
. 选择主机管理的创建主机 
. 系统选择ubuntu14.4 64bit （小编的测试程序是c++11，需要高版本的g++） 
. 机型标准版 
. 网络增强一定要选择开启 （千万连接是网络IO密集型，网络当然要强大型） 
. cpu 16核 内存64G 数据盘0 
. 下一步中的网络类型选择基础网络即可，创建主机之后，需要购买弹性ip，并且绑定到主机 
. 价格：小编实验时，上述的配置，一台仅需7.2元一小时，两台不到15元
　　做实验的时候，大家记得要眼疾手快哦，一小时十几元，获得了自己想要的结果就赶紧释放主机哈
调整参数
　　10m并发连接对系统是个挑战，需要调整相关的参数
sysctl -w fs.file-max=10485760 #系统允许的文件描述符数量10m
sysctl -w net.ipv4.tcp_rmem=1024 #每个tcp连接的读取缓冲区1k，一个连接1k，10m只需要10G
sysctl -w net.ipv4.tcp_wmem=1024 #每个tcp连接的写入缓冲区1k
echo '* soft nofile 1048576' >> /etc/security/limits.conf #用户单进程的最大文件数，用户登录时生效
echo '* hard nofile 1048576' >> /etc/security/limits.conf #用户单进程的最大文件数，用户登录时生效
ulimit -n 1048576 #用户单进程的最大文件数 当前会话生效
部署测试程序
　　下面可以开始部署我们的测试程序了
apt-get update
apt-get install -y screen git make g++ nload iptraf

git clone https://github.com/yedf/handy
cd handy
make -j4
cd examples
运行测试程序
　　选取一台主机S作为服务器，运行命令
python 1kw-svr.py 1000 1000 10
　　该脚本会以job方式启动十个进程，每个进程监听100个端口，一共监听了1000-2000的1000个端口，每个服务器简单的echo收到的数据 
　　选取另一台主机C作为客户端，在screen里运行命令（需要填写S的内网ip）
python 1kw-cli.py ip-S 1000 2000 10000000 1000 300
　　该脚本会以job启动1000个进程，每个进程会产生1w（10000000/1000）个连接，连接S的1000-2000端口。最后的300表示每300秒往服务器发送一个数据包 
　　每个进程都会几秒输出一条信息，1000个进程会造成刷屏，表面刷屏数据导致的外网网络流量可能影响ssh，一般观察一小段时间后，小编就detach screen了 
　　10m连接的创建需要花费不少时间的，如果疯狂的创建连接，导致的结果是很多连接都不成功，于是脚本每启动一个进程，睡眠0.5s，让连接的创建速度保持在2w/s，因此大约需要10分钟的时间才能把所有连接都创建成功。
观察结果
　　然后，10m连接的建立就不需要更多的步骤啦，使用命令
watch ss -s
　　我们就可以开始观察连接的创建进度啦，看着连接渐渐的往上走，超过10w，100w是不是很有成就感。
更多内容
　　还可以通过iptraf，nload等工具来查看系统的网络情况
　　系统在上面千万连接运行中，并没有多少的负载，当然啦，一部分负载跑到底层的hypervisor去了
　　小编实验的机器上内存占用大约40G，平均一个连接前后一共用了4k，不多不多
　　网络发包数量是3w/s，收包数量是6w/s，这是为什么呢？熟悉tcp协议的同学可能已经知道了，C发送数据，S回应数据并带了ACK，C需要对S发送的数据ACK
　　大家还可以跑两个发送大量数据的程序，例如 
./1kw-cli ip-S 1000 2000 10000 0 1024 
　　这个程序会打开10000个连接，不断的与S进行数据收发，数据大小为1024Byte 
　　小编这里启动了两个这样的程序，网卡流量立刻就超过了500MBit/s
　　写到这里，顺便给出我测是的ucloud主机的性能参数吧： 
　　网卡流量最多可以到1.2GBit/s，并非所有时间都到了这么高，并不稳定，一般在800M-1.2G之间波动 
　　tcp收包发包的最高qps是12w/s，多了就上不去了

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[Golang] 从零开始写Socket Server（4）：将运行参数放入配置文件（XML/YAML）
    为了将我们写好的Server发布到服务器上，就要将我们的代码进行build打包，这样如果以后想要修改一些代码的话，需要重新给代码进行编译打包并上传到服务器上。 

   显然，这么做过于繁琐。。。因此常见的做法都是将Server运行中可能会频繁变更的变量、数值写入配置文件中，这样直接让程序从配置文件读取参数，避免对代码频繁的操作。 

   关于配置文件的格式，在这里推荐YAML 和XML~ XML是传统的配置文件写法，不过本人比较推荐yaml，他比XML要更加人性化，也更好写，关于yaml的详细信息可以参考： yaml官网


   比如我们可以将Server监听的端口作为变量，写入配置文件 config.yaml 和 config.xml，放入代码的根目录下，这样当我们想要更换服务器端口的时候，只要在配置文件中修改port对应的值就可以拉。 config.xml内容如下：



<?xml version="1.0" encoding="UTF-8"?>
<Config1>GetConfig</Config1>
<Config2>THE</Config2>
<Config3>Information</Config3>
<Feature1>HereIsTEST1</Feature1>
<Feature2>1024</Feature2>
<Feature3>Feature23333</Feature3>

config.yaml内容如下：




Address: 172.168.0.1
Config1: Easy
Config2:
  Feature1: 2
  Feature2: [3, 4]
Port: :6060
Config4: IS
Config5: ATest


接下来就是解析他们了，目前golang官方还没有解析yaml的库，因此我推荐使用第三方的go-yaml包，

地址如下：  go-yaml  ，go get安装该包后，我们就可以通过他解析文件啦：



//解析文件，取出所有参数
func GetYamlConfig() map[interface{}]interface{}{

	data, err := ioutil.ReadFile("config.yaml")
	//将解析出的参数转为map的形式
	m := make(map[interface{}]interface{})
	if err != nil {
		LogErr("error: %v", err)
	}
	err = yaml.Unmarshal([]byte(data), &m)

	return m
}
//根据需求取出对应值
func GetElement(key string,themap map[interface{}]interface{})string {
	if value,ok:=themap[key];ok {
		return value.(string)
	}

	LogErr("Can't find the *.yaml")
	return ""
}



这里同样给出解析xml配置文件的代码：




func GetXMLConfig() map[string]string {

	var t xml.Token
	var err error

	Keylst := make([]string,6)
	Valuelst:=make([]string,6)
//将解析出的元素填入map中，便于查找
	map1:=make(map[string]string)
	content, err := ioutil.ReadFile("config.xml")
	CheckError(err)
	decoder := xml.NewDecoder(bytes.NewBuffer(content))

	i:=0
	j:=0
	for t, err = decoder.Token(); err == nil; t, err = decoder.Token() {

		switch token := t.(type) {
		// 处理元素
		case xml.StartElement:

			name := token.Name.Local
			Keylst[i]=string(name)
			i=i+1

		case xml.CharData:
			content1 := string([]byte(token))
			//Valuelst=append(Valuelst,content1)
			Valuelst[j]=content1
			j=j+1

		}
	}
	for count:=0;count<len(Keylst);count++{
		map1[Keylst[count]]=Valuelst[count]
	}

	return map1
}
//取出map的函数跟yaml中的差不多，此处略过





运行效果如下：






版权声明：本文为博主原创文章，未经博主允许不得转载。

Spring学习（一）ioc理解

对Spring有所了解的都应该知道，spring贯穿始终的两个重要的思想，一个是IOC（控制反转）,一个是DI（依赖注入），对于新手而言，这两个概念比较难理解，我用自己的想法来解释下。

首先我们要知道在程序开发中为什么要使用spring框架。
这里先引入两个概念：耦合性、侵入性。简单的讲：耦合性，在java中表现为类之间的关系，耦合性强说明类之间的依赖关系强；侵入性：框架对代码的侵入，比如你项目用了struts1，要改框架时发现改的东西太多了，比如actionForm等，所以struts1对代码的侵入性是很高的。
在传统的java开发中具有高度的耦合性和侵入型。一个项目中，一般一个类都要依赖很多其他的类来完成自己的操作，我们往往采用new这个类的对象来调用他的方法，这样就造成了两个类的依赖关系太强，改一个地方，往往牵扯很多类牵扯大量的代码。侵入性上一段的例子可以明白。
当然EJB也可以解决耦合性和侵入性的问题，但是ejb太依赖服务器，属于重量级的框架。
可以说在这样的背景下，spring应运而生，一个轻量级的框架，解决传统企业开发的复杂性；使用普通的javaBean代替EJB技术。可以管理对象和对象之间的依赖关系，我们不需要自己建立对象，把这部分工作全部转交给容器完成，具有低耦合，对代码没有侵略性，对服务器没有依赖性特点的框架。
而这个容器，即IOC.

如何理解IOC思想？
一个很流行的例子，我换了种说法，这样更好理解：好比找女朋友，普通的方式是我们依赖各种关系找到这个女朋友（相当于new了对象），有一天分手了，而以前的那些关系也没有了，要想找到新的女朋友就要依赖新的关系（重新 new另外一个对象）,可以想象这个过程很麻烦。于是有了一种新的方式找对象——婚介所，这里就是我们所说的IOC方式，你把你要求的对象的特征告诉婚介所，他会直接给你找到一对象，没有中间复杂的过程，你只管相处的事情就好了，new的过程不用管，不需要任何依赖关系，即使哪天要换了，再把需要的对象提交给婚介所就行了，你就会得到你想要的新的对象了。 
事实上，使用ioc方式创建对象的目的，是为了以“被动”的方式形成对象之间的依赖关系。传统的开发过程中，不管是new，还是普通工厂，都需要目标对象主动创建、主动查找其需要的依赖对象 ， 目标对象会将他的精力分散在不必要的非业务逻辑方面。IOC通过DI(依赖注入)把建立好的对象注入到目标对象中。

Spring IOC具体如何实现？
上文中的婚介所就是ioc管理对象的容器，实际上是一个xml文件，将对象配置在xml里面，通过spring的工厂类进行解析，以“反射”的方式创建对象。
spring IOC容器的关键点：
* 必须将被管理的对象定义到spring配置文件中
* 必须定义构造函数或setter方法，让spring将对象注入过来

我们可以通过下面这里例子理解spring ioc的实现。本例使用spring 3.2 
1.配置applicationContext.xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <bean id="userDao4MySqlImpl" class="com.bjsxt.spring.dao.UserDao4MySqlImpl"/>
    <bean id="userDao4OracleImpl" class="com.bjsxt.spring.dao.UserDao4OracleImpl"/>
    <bean id="userManager" class="com.bjsxt.spring.manager.UserManagerImpl">
        <!-- 构造方法注入 
        <constructor-arg ref="userDao4OracleImpl"/>
         -->
         <!-- setter方法注入 -->
         <property name="userDao" ref="userDao4OracleImpl"/>
    </bean>
</beans>

2.注入的类：
package com.bjsxt.spring.dao;

public interface UserDao {

    public void save(String username, String password);
}
package com.bjsxt.spring.dao;

public class UserDao4MySqlImpl implements UserDao {

    public void save(String username, String password) {
        System.out.println("--------UserDao4MySqlImpl.save()-------");
    }
}
package com.bjsxt.spring.dao;

public class UserDao4OracleImpl implements UserDao {

    public void save(String username, String password) {
        System.out.println("--------UserDao4OracleImpl.save()-------");
    }
}

3.被注入的类：
package com.bjsxt.spring.manager;

public interface UserManager {
    public void save(String username, String password);
}

package com.bjsxt.spring.manager;

import com.bjsxt.spring.dao.UserDao;

public class UserManagerImpl implements UserManager {
    /**
     * 两种方式：如果这个类中需要注入对象，先建立对象属性，
     *      在写构造方法或者settet方法。
     * 
     */
    private UserDao userDao;

/*  public UserManagerImpl(UserDao userDao) {
        this.userDao = userDao;
    } */

    public void save(String username, String password) {
        this.userDao.save(username, password);
    }

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}

4.测试类：
package com.bjsxt.spring.client;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.bjsxt.spring.manager.UserManager;

public class Client {

    public static void main(String[] args) {
/*  传统的通过new对象建立类之间的关系
 * UserManager userManager = new UserManagerImpl(new UserDao4OracleImpl());
        UserManager userManager = new UserManagerImpl(new UserDao4MySqlImpl());
        userManager.save("张三", "123");*/
/**
 * IOC思想     通过工厂类解析xml文件，以“反射”的方式创建对象：
 */
        BeanFactory factory = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserManager userManager = (UserManager)factory.getBean("userManager");
        userManager.save("张三", "123");
/**
 * IOC思想   实际的执行过程，这也是为什么需要setter方法或构造方法的原因：        
 */
//      UserManagerImpl userManager = new UserManagerImpl();
//      userManager.setUserDao(new UserDao4MySqlImpl());
//      userManager.save("张三", "123");
    }
}

这样就实现了spring ioc思想。 
本文完全个人理解，如有不对的地方，恳请指正。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        SpringMVC核心思想详解
Spring MVC是spring的一个web组件，它为构建稳健的web应用提供了丰富的功能。Spring MVC是基于每个逻辑和功能是高可配置的这样架构和设计的。当然spring MVC可以与其它流行的web框架像struts、webwork、javaserverface及tapestry实现无缝集成。我们看一下spring MVC的核心思想。   Spring请求的生命周期  为了便于理解，我把spring MVC的生命周期拆解为如下一个步骤总结一下springMVC几个关键的步骤，总共可以分为六个步骤，分别为：（1）    客户端向spring容器发起一个http请求（2）    发起的请求被前端控制起所拦截(DispatcherServlet)，前端控制器会去找恰当的映射处理器来处理这次请求。（3）    根据处理器映射（Handler Mapping）来选择并决定将请求发送给那一个控制器。（4）    在控制器中处理所发送的请求，并以modelAndView（属性值和返回的页面）的形式返回给向前端控制器。（5）    前端控制器通过查询viewResolver对象来试着解决从控制返回的视图。（6）    如果前端控制找到对应的视图，则将视图返回给客户端，否则抛异常。通过上面的图和springMVC生命周期的六个步骤，想必大家对springMVC的核心思想有个了大概的了解了，下面我们以实例为主，带领大家慢慢熟悉整个springMVC及如何使用springMVC。（本教程基于maven实现springMVC中的例子，所以大家得对maven需要有大概的了解）。 二、spring3.1 mvc 框架的特点如果仅仅关注于web方面的支持，Spring有下面一些特点：·         清晰的角色划分：控制器（controler），验证器(Validate)，命令对象(Object)，表单对象(BeanObject)和模型对象(Model)；分发器(Adapter)，处理器映射（HandlerAdapter）和视图解析器(ViewResolver)；等等。·         直接将框架类和应用类都作为JavaBean配置，包括通过应用上下文配置中间层引用，例如，从web控制器到业务对象和验证器的引用。·         可适应性，但不具有强制性：根据不同的情况，使用任何你需要的控制器子类（普通控制器，命令，表单，向导，多个行为，或者自定义的），而不是要求任何东西都要从Action/ActionForm继承。可重用的业务代码，而不需要代码重复：你可以使用现有的业务对象作为命令对象或表单对象，而不需要在ActionForm的子类中重复它们的定义·         可定制的绑定和验证：将类型不匹配作为应用级的验证错误，这可以保存错误的值，以及本地化的日期和数字绑定等，而不是只能使用字符串表单对象，手动解析它并转换到业务对象。·         可定制的处理器映射，可定制的视图解析：灵活的模型可以根据名字/值映射，处理器映射和视图解析使应用策略从简单过渡到复杂，而不是只有一种单一的方法。·         可定制的本地化和主题解析，支持JSP，无论有没有使用Spring标签库，支持JSTL，支持不需要额外过渡的Velocity，等等。简单而强大的标签库，它尽可能地避免在HTML生成时的开销，提供在标记方面的最大灵活性。 三、spring 3.1 MVC入门列子HelloWorld（1）在WEB-INF/web.xml中加入如下代码：         <servlet>        <servlet-name>dispatcherServlet</servlet-name>        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>        <init-param>           <param-name>contextConfigLocation</param-name>           <param-value>              classpath*:spring-servlet.xml           </param-value>       </init-param>        <load-on-startup>1</load-on-startup>    </servlet>     <servlet-mapping>        <servlet-name>dispatcherServlet</servlet-name>        <url-pattern>*.html</url-pattern></servlet-mapping>上述的配置的就是前段控制器，在servlet-mapping配置了*.html，意味着所有以.html结尾的请求多会通过这个servlet，当dispatcherServlet启动时，他默认会在web-info目录下查找一个spring-servlet.xml的配置文件。上面我们通过显示指定了这个文件的位置，即在类路径底下的spring-servlet.xml.这个文件我们会在第二步点给他家做详细介绍。（2）在类路径底下添加spring-servlet.xml文件，其内容如下：<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:p="http://www.springframework.org/schema/p"    xmlns:context=http://www.springframework.org/schema/contextxsi:schemaLocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context-3.0.xsd">     <context:component-scan       base-package="com.pango.spring.helloworld.controller" />     <bean id="viewResolver"       class="org.springframework.web.servlet.view.UrlBasedViewResolver">       <property name="viewClass"           value="org.springframework.web.servlet.view.JstlView" />       <property name="prefix" value="/WEB-INF/jsp/" />       <property name="suffix" value=".jsp" />    </bean></beans>上面这个文件，我们定义了一个<context:component-scan       base-package="com.pango.spring.helloworld.controller" />这样的标签，定义了这个后，当spring在启动时，会加载com.pango.spring.helloworld.controller这个包底下及子包底下的所有的组件（这就包的自动扫描机制，即spring会将标有@Controller @Component等类加载到spring容器管理中），后面我们还定义了<bean id="viewResolver"       class="org.springframework.web.servlet.view.UrlBasedViewResolver">       <property name="viewClass"           value="org.springframework.web.servlet.view.JstlView" />       <property name="prefix" value="/WEB-INF/jsp/" />       <property name="suffix" value=".jsp" />    </bean>ViewResolver是一个试图解析器，就是我们第一部分提到的springMVC生命周期中的第五步，上面这段的配置的意思就是，当我们从后端控制器中返回的视图时，前端控制器就根据这一段配置来返回一个具体的视图，如后端控制返回的是一个hello，根据上面的配置，最后前端控制器会组并成这样的一个地址：/web-inf/jsp/hello.jsp,然后从/web-inf/jsp/这个目录下面查找一个hello.jsp返回客户端。第三部分我们看我们写得HelloworldController后台控制器。（3）在包底下写一个HelloWorldController的类，其内容如下：@Controller

public class HelloWorldController {

@RequestMapping(value="/hello")

    public String sayHello(ModelMap modelMap){

       modelMap.put("sayHello", "hello world");

       return "/hello"; 

    }

}
在这里简单介绍下上面的配置，后面我们会详细讲解各个参数：Ø         Controller即声明这个类是一个控制器，上面第二部分我们说明了，只要加了@Controller标示的，spring会通过自动扫描机制，将这个类纳入spring容器管理中。Ø         @RequestMapping(value="/hello")，这个定义的就是一个请求路径，只要符合/hello路径的多会交给这个控制器的sayhello方法来处理。Ø         最后我们返回/hello的视图给客户端。（4）好了，大功告成，我们再在web-info/jsp/目录下添加一个hello.jsp文件，就可以启动运行我们的第一个程序了。hello.jsp的内容如下：<%@ page language="java" contentType="text/html; charset=UTF-8"

    pageEncoding="UTF-8"%>

 <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Insert title here</title>

</head>

<body>

    <span>${sayHello}</span>

   

</body>

</html>
 运行后访问ip;port/project/hello.html就可以看到我们预期的结果了。    四、springMVC参数传递 mvc结构中，v层不断有数据和c层交互，所以弄明白在springMVC中如何与后台进行数据交互是极其重要的，当然在下面我不会介绍每一个方法，只是对常用的方法，对于我这里没有涉及的方法大家可以参考spring官方的文档中springMVC这个章节。下面我们来看一幅图。当我们向springMVC发起请求到视图返回前，spring MVC帮我们做了主要是上面几个步骤，通过数据绑定、数据类型转换、验证、结果绑定这几个步骤。让我们看下实例：@RequestMapping("/user/find")    public String findUserById(@RequestParam("userId") int userId,ModelMap modelMap){       modelMap.put("userId", userId);       return "/user";}Ø         @RequestMapping("/user/find")，是对请求映射的说明，这个注解中主要包含四个属性，分别value、method、params、header，这四个参数分别表示：Value：指定路径Method：请求方式Params：参数Headers：请求头后面三个就是对请求路径的一个限制条件。SpringMVC对于路径的定义非常的灵活以下URL都是合法的：l       /usercreateUser    匹配/user/createUser、/user/aaa/bbb/createUser等URL。l       /user/createUser??    匹配/user/createUseraa、/user/createUserbb等URL。l       /user/{userId}    匹配user/123、user/abc等URL。l       /user{userId}    匹配user/aaa/bbb/123、user/aaa/456等URL。 l       company/{companyId}/user/{userId}/detail    匹配company/123/user/456/detail等的URL。 Ø         对RequestParam的介绍@RequestParam有以下三个参数。l       value：参数名。l       required：是否必需，默认为true，表示请求中必须包含对应的参数名，如果不存在将抛出异常。l       defaultValue：默认参数名，设置该参数时，自动将required设为false。极少情况需要使用该参数，也不推荐使用该参数。 当发送请求时，请求参数中必须要包含userId这个参数，当不包含这个参数，请求将找不到这个映射。当属性required=true时，不包含这个参数将会抛异常，如果不能确定是否需要这个参数是我们可以写成，@RequestParam(value = "userId", required = false) 。Ø         直接将属性映射到对象中    @RequestMapping("/user/find2")    public String find2UserById(User user,ModelMap modelMap){       modelMap.put("user", user);       return "/user";    }    Spring MVC按：     “HTTP请求参数名 =  命令/表单对象的属性名”    的规则，自动绑定请求数据，支持“级联属性名”，自动进行基本类型数据转换。         如：发起下面这个请求，springMVC会自动将id、name、password属性的值填充到user对象中。         http://localhost:8080/springParam/user/save.html?id=12&name=marcle&password=123Ø         SpringMVC以rest技术向springMVC传递参数通过 REST 风格体系架构，请求和响应都是基于资源表示的传输来构建的。资源是通过全局 ID 来标识的，这些 ID 一般使用的是一个统一资源标识符（URI）。客户端应用使用 HTTP 方法（如，GET、POST、PUT 或 DELETE）来操作一个或多个资源。通常，GET 是用于获取或列出一个或多个资源，POST 用于创建，PUT 用于更新或替换，而 DELETE 则用于删除资源。例如，GET http://host/context/employees/12345 将获取 ID 为 12345 的员工的表示。这个响应表示可以是包含详细的员工信息的 XML 或 ATOM，或者是具有更好 UI 的 JSP/HTML 页面。您看到哪种表示方式取决于服务器端实现和您的客户端请求的 MIME 类型。RESTful Web Service 是一个使用 HTTP 和 REST 原理实现的 Web Service。通常，一个 RESTful Web Service 将定义基本资源 URI、它所支持的表示/响应 MIME，以及它所支持的操作。Spring 3.0之后引入了对rest风格的支持。我们看实例@RequestMapping("/user/find/{id}")    public String rest(@PathVariable int id,ModelMap modelMap){       User user = new User(); user.setName("marcle");       user.setPassword("123");       user.setId(id);       modelMap.put("user", user);       return "/user";    }这里需要注意的地方时@RequestMapping("/user/find/{id}")和@PathVariable int id名称必须一样，否则会出现异常。Ø         简单介绍返回视图的方式u        ModelAndView 形式返回@RequestMapping("/user/save2")    public ModelAndView save2(User user,ModelMap modelMap){       ModelAndView mav = new ModelAndView();       mav.setViewName("/user");       mav.addObject("user", user);       return mav;    }ModelAndView就是对返回到页面的值和视图进行封装。u       直接字符串的形式返回，如”return “/user””,再把属性通过modelMap进行封装，modelMap存储的值属于request范围内，如果要发送服务器端请求，springMVC非常方便，你只要这样写即可return ”direct:user”.还有一种传递参数的方法，我放在springMVC中的rest技术介绍  下面我们看看springMVC返回的过程 五、springMVC标签介绍 SpringMVC简单没几个标签，用起来还是非常好用的，在使用springMVC中的标签之前需要向每个jsp的头部引入标签支持<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>1）      form标签这个标签会生成一个HTML的form标签，同时为内部标签的绑定暴露了一个绑定路径，它把命令对象（command object）放在pageContext中，这样内部的标签就可以访问这个对象，这个库中的其它标签都是这个标签的嵌套标签。如我们有个user的域对象，包含id、name、password属性，我们将把它当作返回index.jsp表单控制器的对象，如下面的代码：<form:form action="${ctx}/user/save.${ext}" method="post" commandName="user">

       <table>

           <tr>

              <td>Id:</td>

              <td><form:input path ="id" /></td>

           </tr>

           <tr>

              <td>name:</td>

              <td><form:input path ="name" /></td>

           </tr>

           <tr>

              <td>password:</td>

              <td><form:input path ="password" /></td>

           </tr>

           <tr>

              <td colspan="2"><input type ="submit" value="Save" /></td>

           </tr>

       </table>

    </form:form>
上述的id、name、password由页面控制器放置在pageContext中，即在内部控制器方法中需要做这样的声明：@RequestMapping(value="/user/save",method=RequestMethod.GET)    public String forSave(@ModelAttribute User user){       return "/index";    }后台控制器中必须绑定这个@ModelAttribute User user命令行对象，而form下面的属性需要于这个user中的属性对应起来，否则将会抛异常。标签经过解析后生成的代码如下：<form id="user" action="/springTag/user/save.html" method="post">

               <table>

                       <tr>

                               <td>Id:</td>

                               <td><input id="id" name="id" type="text" value="0"/></td>

                       </tr>

                       <tr>

                               <td>name:</td>

                               <td><input id="name" name="name" type="text" value=""/></td>

                       </tr>

                       <tr>

                               <td>password:</td>

                               <td><input id="password" name="password" type="text" value=""/></td>

                       </tr>

                       <tr>

                               <td colspan="2"><input type ="submit" value="Save Changes" /></td>

                       </tr>

               </table>

        </form>
（2）  input 标签使用时如上面的表达式，<form:input path ="id" />解析后会变成<input id="name" name="name" type="text" value=""/>可见用spring标签比传统的html简洁很多。（3）checkbox 标签这个标签解析之后会变成html’中的type为checkbox的input元素，我们假设我们的用户有很多的参考东西，如信息的订阅、爱好、格言等，即如下面的域模型：public class Preferences { 
                      
    private boolean receiveNewsletter; 
  
    private String[] interests; 
  
    private String favouriteWord; 
  
    public boolean isReceiveNewsletter() { 
        return receiveNewsletter; 
    } 
  
    public void setReceiveNewsletter(boolean receiveNewsletter) { 
        this.receiveNewsletter = receiveNewsletter; 
    } 
  
    public String[] getInterests() { 
        return interests; 
    } 
  
    public void setInterests(String[] interests) { 
        this.interests = interests; 
    } 
  
    public String getFavouriteWord() { 
        return favouriteWord; 
    } 
  
    public void setFavouriteWord(String favouriteWord) { 
        this.favouriteWord = favouriteWord; 
    } 
} 
我们的相应的jsp文件可以写成：<form:form action="${ctx}/pre/save.${ext}" method="post" commandName="preferences">

    <table>

        <tr>

            <td>Subscribe to newsletter?:</td>

            <%-- Approach 1: Property is of type java.lang.Boolean --%>

            <td><form:checkbox path="receiveNewsletter"/></td>

            <td> </td>

        </tr>

 

        <tr>

            <td>Interests:</td>

            <td>

                <%-- Approach 2: Property is of an array or of type java.util.Collection --%>

                Quidditch: <form:checkbox path="interests" value="Quidditch"/>

                Herbology: <form:checkbox path="interests" value="Herbology"/>

                Defence Against the Dark Arts: <form:checkbox path="interests"

                    value="Defence Against the Dark Arts"/>

            </td>

            <td> </td>

        </tr>

        <tr>

            <td>Favourite Word:</td>

            <td>

                <%-- Approach 3: Property is of type java.lang.Object --%>

                Magic: <form:checkbox path="favouriteWord" value="Magic"/>

            </td>

            <td> </td>

        </tr>

        <tr>

        <td colspan="2">

             <input type="submit" value="submit"/>

        </td>

        </tr>

    </table>

</form:form>
如果有多个供选择的，在后台我们以数组的形式存储。（4）radiobutton 标签解析后会变成html元素中type为radio的input元素如下面的情况：<tr> 
    <td>Sex:</td> 
    <td>Male: <form:radiobutton path="sex" value="M"/> <br/> 
        Female: <form:radiobutton path="sex" value="F"/> </td> 
    <td> </td> 
</tr> 
（5）password标签解析后变成html元素中type为password的input元素，即为密码框。<tr> 
    <td>Password:</td> 
    <td> 
        <form:password path="password" /> 
    </td> 
</tr> 
（6）select标签这个标签对应于html元素中的下拉框，即为select元素。<tr>

              <td>Skills:</td>

              <td><form:select path="skills" items="${skills}" /></td>

              <td></td>

           </tr>
 （7）option标签<form:select path="house"> 
            <form:option value="Gryffindor"/> 
            <form:option value="Hufflepuff"/> 
            <form:option value="Ravenclaw"/> 
            <form:option value="Slytherin"/> 
        </form:select> 
（8）options标签<form:select path="country"> 
            <form:option value="-" label="--Please Select"/> 
            <form:options items="${countryList}" itemValue="code" itemLabel="name"/> 
        </form:select> 
（9）textarea标签<td><form:textarea path="notes" rows="3" cols="20" /></td> （10）hidden标签       <form:hidden path="house" /> （11）errors标签<form:form> 
    <table> 
        <tr> 
            <td>First Name:</td> 
            <td><form:input path="firstName" /></td> 
            <%-- Show errors for firstName field --%> 
            <td><form:errors path="firstName" /></td> 
        </tr> 
  
        <tr> 
            <td>Last Name:</td> 
            <td><form:input path="lastName" /></td> 
            <%-- Show errors for lastName field --%> 
            <td><form:errors path="lastName"  /></td> 
        </tr> 
        <tr> 
            <td colspan="3"> 
                <input type="submit" value="Save Changes" /> 
            </td> 
        </tr> 
    </table> 
</form:form> 
 六、springMVC拦截器和Struts2一样，Spring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现HandlerInterceptor接口。这个接口中定义了三个方法：preHandle()、postHandle()、afterCompletion()。下面对代码中的三个方法进行解释。preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求request进行处理。如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true；如果程序员决定不需要再调用其他的组件去处理请求，则返回false。postHandle()：这个方法在业务处理器处理完请求后，但是DispatcherServlet向客户端返回请求前被调用，在该方法中对用户请求request进行处理。afterCompletion()：这个方法在DispatcherServlet完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。下面通过一个例子来说明如何使用Spring MVC框架的拦截器。要求编写一个拦截器，拦截所有不在工作时间的请求，把这些请求转发到一个特定的静态页面，而不对它们的请求进行处理。首先编写TimeInterceptor.Java，代码如下：public class TimeInterceptor extends HandlerInterceptorAdapter {

    private int openingTime; // openingTime 属性指定上班时间

    private int closingTime; // closingTime属性指定下班时间

    private String outsideOfficeHoursPage; // outsideOfficeHoursPage属性指定错误

 

    public void setOpeningTime(int openingTime) {

       this.openingTime = openingTime;

    }

 

    public void setClosingTime(int closingTime) {

       this.closingTime = closingTime;

    }

 

    public void setOutsideOfficeHoursPage(String outsideOfficeHoursPage) {

       this.outsideOfficeHoursPage = outsideOfficeHoursPage;

    }

 

    // 重写 preHandle()方法，在业务处理器处理请求之前对该请求进行拦截处理

    public boolean preHandle(HttpServletRequest request,

           HttpServletResponse response, Object handler) throws Exception {

       Calendar cal = Calendar.getInstance();

       int hour = cal.get(Calendar.HOUR_OF_DAY); // 获取当前时间

       if (openingTime <= hour && hour < closingTime) { // 判断当前是否处于工作 时间段内

 

           return true;

       } else {

           response.sendRedirect(outsideOfficeHoursPage); // 返回提示页面

           return false;

       }

    }

 

}
 可以看出，上面的代码重载了preHandle()方法，该方法在业务处理器处理请求之前被调用。在该方法中，首先获得当前的时间，判断其是否在 openingTime和closingTime之间，如果在，返回true，这样才会调用业务控制器去处理该请求；否则直接转向一个静态页面，返回 false，这样该请求就不会被处理。下面是在dispatcherServlet-servlet.xml中对拦截器进行的配置，代码如下：<mvc:interceptors>

       <mvc:interceptor>

           <mvc:mapping path="/user/*" />

           <bean class="com.pango.spring.interceptor.TimeInterceptor">

              <property name="openingTime" value="12"></property>

              <property name="closingTime" value="24"></property>

              <property name="outsideOfficeHoursPage" value="outTime.html"></property>

           </bean>

       </mvc:interceptor>

    </mvc:interceptors>
 可以看出，上面代码用bean标签去定义TimeInterceptor，令其id为officeHoursInterceptor，并给它的3个属性赋值。在urlMapping中通过<property name="interceptors">去指定officeHoursInterceptor为一个拦截器，读者可以在<list> 和</list>之间定义多个拦截器outsideOfficeHours.html的代码很简单，只是输出一句提示语。运行程序，在浏览器中随便访问一个页面，如果请求的时间在9点～18点之间，则该请求可以被处理；否则，返回一句提示语，如图23-5所示 说 明：在第22章中介绍过控制反转是Spring框架的核心思想，即用一个接口去定义一些操作，在接口的实现类中去重写这些操作，然后在Spring的配置文件中去把该接口的实现类注入到应有框架中，这样就可以通过调用接口去调用接口的实现类。本节讲的拦截器就体现了这种思想，即实现 HandlerInterceptorAdapter接口，重写preHandle()方法并在配置文件中实现TimeInterceptor的注入。这 样当框架调用HandlerInterceptorAdapter时，就可以调用到TimeInterceptor类的preHandle()方法七、spring3 MVC 类型转换  Servlet中的输入参数为都是string类型，而spring mvc通过data bind机制将这些string 类型的输入参数转换为相应的command object（根据view和controller之间传输数据的具体逻辑，也可称为model attributes, domain model objects）。在这个转换过程中，spring实际是先利用java.beans.PropertyEditor中的 setAdText方法来把string格式的输入转换为bean属性，亦可通过继承java.beans.PropertyEditorSupport来实现自定义的PropertyEditors。自定义完毕propertyEditor后，有以下几种方式来注册自定义的customer propertyEditor. （我只实现了第二种转换方式，至于其它方法大家可以自己尝试）Ø        直接将自定义的propertyEditor放到需要处理的java bean相同的目录下名称和java Bean相同但后面带Editor后缀。例如需要转换的java bean 名为User,则在相同的包中存在UserEditor类可实现customer propertyEditor的自动注册。Ø        利用@InitBinder来注册customer propertyEditor这个在之前的笔记中已经介绍过了，即在controller类中增加一个使用@InitBinder标注的方法，在其中注册customer EditorJava代码   public class BaseController {

   

    @InitBinder

    public void initBinder(WebDataBinder binder) {

       binder.registerCustomEditor(Date.class, new CustomDateEditor(true));

    }

}
Ø        继承 WebBindingInitializer 接口来实现全局注册使用@InitBinder只能对特定的controller类生效，为注册一个全局的customer Editor，可以实现接口WebBindingInitializer 。Java代码   public class CustomerBinding implements WebBindingInitializer {

 

    public void initBinder(WebDataBinder binder, WebRequest request) {

       // TODO Auto-generated method stub

         SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); 

                   dateFormat.setLenient(false); 

                   binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));

 
    }

 

}
并修改 spring-servlet xml配置文件Xml代码   <bean  

        class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">  

        <property name="webBindingInitializer">  

            <bean  

                class="net.zhepu.web.customerBinding.CustomerBinding" />  

        </property>  

    </bean>  
 但这样一来就无法使用mvc:annotation-driven  了。使用conversion-service来注册自定义的converterDataBinder实现了PropertyEditorRegistry, TypeConverter这两个interface，而在spring mvc实际处理时，返回值都是return binder.convertIfNecessary(见HandlerMethodInvoker中的具体处理逻辑)。因此可以使用customer conversionService来实现自定义的类型转换。Xml代码   <bean id="conversionService" 

    class="org.springframework.format.support.FormattingConversionServiceFactoryBean"> 

     

    <property name="converters"> 

        <list> 

            <bean class="net.zhepu.web.customerBinding.CustomerConverter" /> 

        </list> 

    </property> 

     

</bean> 
 需要修改spring-servlet xml配置文件中的annotation-driven,增加属性conversion-service指向新增的conversionService bean。Xml代码   <mvc:annotation-driven validator="validator"  conversion-service="conversionService" /> 对于第二种方式实现如下Date类型编辑器public class CustomDateEditor extends PropertyEditorSupport {

    private static final Map<String, String> dateMap;

 

    static {

       dateMap = new HashMap<String, String>();

       dateMap.put("yyyy-MM-dd", "\\d{4}-\\d{2}-\\d{2}");

       dateMap.put("yyyy-MM-dd hh:mm:ss", "\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}");

       dateMap.put("yyyy年MM月dd日", "\\d{4}年\\d{2}月\\d{2}日");

    }

 

    private final boolean allowEmpty;

 

    public CustomDateEditor(boolean allowEmpty) {

       this.allowEmpty = allowEmpty;

    }

 

    @Override

    public void setAsText(String text) throws IllegalArgumentException {

   

       if (this.allowEmpty && !StringUtils.hasText(text)) {

           // Treat empty String as null value.

          

           setValue(null);

       } else {

      

           try {

             

              boolean flag = false;

              for (String dateFormatStr : dateMap.keySet()) {

                  if (text.matches(dateMap.get(dateFormatStr))) {

                     flag = true;

                     System.out.println(text);

                     DateFormat dateFormat = new SimpleDateFormat(dateFormatStr);

                     setValue(dateFormat.parse(text));

                     break;

                  }

              }

              if (!flag) {

                  //throw new IllegalArgumentException("Could not parse date: " + text);

              }

           } catch (ParseException ex) {

              //throw new IllegalArgumentException("Could not parse date: " + ex.getMessage(), ex);

           }

       }

    }

 

    @Override

    public String getAsText() {

       Date value = (Date) getValue();

       DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

 

       return value != null ? dateFormat.format(value) : "";

    }

}

@InitBinder来注册customer propertyEditor

@InitBinder

    public void initBinder(WebDataBinder binder) {

      

       binder.registerCustomEditor(Date.class, new CustomDateEditor(true));

    }
最后讲讲对于requestBody或httpEntity中数据的类型转换Spring MVC中对于requestBody中发送的数据转换不是通过databind来实现，而是使用HttpMessageConverter来实现具体的类型转换。例如，之前提到的json格式的输入，在将json格式的输入转换为具体的model的过程中，spring mvc首先找出request header中的contenttype，再遍历当前所注册的所有的HttpMessageConverter子类，根据子类中的canRead()方法来决定调用哪个具体的子类来实现对requestBody中的数据的解析。如果当前所注册的 httpMessageConverter中都无法解析对应contexttype类型，则抛出 HttpMediaTypeNotSupportedException （http 415错误）。那么需要如何注册自定义的messageConverter呢，很不幸，在spring 3.0.5中如果使用annotation-driven的配置方式的话，无法实现自定义的messageConverter的配置，必须老老实实的自己定义AnnotationMethodHandlerAdapter的bean定义，再设置其messageConverters以注册自定义的 messageConverter。Xml代码   <mvc:annotation-driven>  

    <mvc:message-converters>  

        <bean class="org.springframework.http.converter.StringHttpMessageConverter"/>  

        <bean class="org.springframework.http.converter.ResourceHttpMessageConverter"/>  

        <bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"/>  

    </mvc:message-converters>  

</mvc:annotation-driven>
  八、json格式数据的输入和输出Spring mvc处理json需要使用jackson的类库，因此为支持json格式的输入输出需要先修改pom.xml增加jackson包的引用Xml代码   <dependency>

           <groupId>org.codehaus.jackson</groupId>

           <artifactId>jackson-core-lgpl</artifactId>

           <version>1.8.0</version>

           <scope>compile</scope>

       </dependency>

       <dependency>

           <groupId>org.codehaus.jackson</groupId>

           <artifactId>jackson-mapper-asl</artifactId>

           <version>1.8.0</version>

</dependency>
 在spring-servlet.xml中必须加入这段代码：<mvc:annotation-driven />根据前面的分析，在spring mvc中解析输入为json格式的数据有两种方式1:使用@RequestBody来设置输入Java代码   @RequestMapping("/json1")    @ResponseBody    public JsonResult testJson1(@RequestBody User u){    log.info("get json input from request body annotation");    log.info(u.getUserName());    return new JsonResult(true,"return ok");}2:使用HttpEntity来实现输入绑定Java代码       @RequestMapping("/json2")

    public ResponseEntity<JsonResult> testJson2(HttpEntity<User> u){

    log.info("get json input from HttpEntity annotation");

    log.info(u.getBody().getUserName());

    ResponseEntity<JsonResult> responseResult = new ResponseEntity<JsonResult>( new JsonResult(true,"return ok"),HttpStatus.OK);

    return responseResult;
 对应Json格式的输出也对应有两种方式1：使用@responseBody来设置输出内容为context body@RequestMapping(value="/kfc/brands/{name}", method = RequestMethod.GET)

    public @ResponseBody List<Shop> getShopInJSON(@PathVariable String name) {

    List<Shop> shops = new ArrayList<Shop>();

       Shop shop = new Shop();

       shop.setName(name);

       shop.setStaffName(new String[]{"mkyong1", "mkyong2"});

      

       shops.add(shop);

      

       Shop shop2 = new Shop();

       shop2.setName(name);

       shop2.setStaffName(new String[]{"mktong1", "mktong2"});

       shops.add(shop2);

       return shops;

}       
     当我们在地址栏中输入：http://localhost:8080/springJson/kfc/brands/kfc_name.html服务器端会返回给我们jason格式的数据，这样我们就可以省去手工繁琐的组并了   2：返回值设置为ResponseEntity<?>类型，以返回context body@RequestMapping("/json2")    public ResponseEntity<JsonResult> testJson2(HttpEntity<User> u){    log.info("get json input from HttpEntity annotation");    log.info(u.getBody().getUserName());    ResponseEntity<JsonResult> responseResult = new ResponseEntity<JsonResult>( new JsonResult(true,"return ok"),HttpStatus.OK);    return responseResult;    }九、spring3mvc文件上传 Spring mvc使用jakarta的commons fileupload来支持文件上传，因此我们需要在pom.xml中导入所依赖的两个包：<dependency> 

        <groupId>commons-io</groupId> 

        <artifactId>commons-io</artifactId> 

        <version>2.0.1</version> 

    </dependency> 

           

    <dependency> 

        <groupId>commons-fileupload</groupId> 

        <artifactId>commons-fileupload</artifactId> 

        <version>1.2.2</version> 

</dependency> 
 在spring-servlet.xml中加入以下这段代码：<bean id="multipartResolver"       class="org.springframework.web.multipart.commons.CommonsMultipartResolver">        <!-- one of the properties available; the maximum file size in bytes -->       <property name="maxUploadSize" value="100000" />          </bean> 其中的property中可以限制最大和最小文件上传。在客户端的代码如下：<form method="post" action="${ctx}/user/upload.${ext}" enctype="multipart/form-data"><input type="text" name="name"/><input type="file" name="file"/><input type="submit"/></form>服务器端的代码如下：@RequestMapping(value = "/user/upload", method = RequestMethod.POST)

    public String handleFormUpload(@RequestParam("name") String name,

           @RequestParam("file") MultipartFile file, HttpServletRequest request)

           throws IOException {

       String filePath = request.getRealPath("/");

       if (!file.isEmpty()) {

           String fileName = file.getOriginalFilename();

           System.out.println(filePath + "/" + fileName);

           byte[] bytes = file.getBytes();

           FileOutputStream output = new FileOutputStream(new File(filePath

                  + fileName));

           output.write(bytes);

           output.close();

           return "redirect:/success.jsp";

       } else {

           return "redirect:/failure.jsp";

       }

    }
 十、spring mvc国际化和本地化 何为国际化，简单来说就是在那个国家显示哪个国家的语言，在计算机中，国际化和本地化意味着计算机软件要适应不同的语言和地区的差异。国际化就是设计为了适应不同地区和语言的差异而工程不需要做任何改动。这一节的目的就是在springMVC中增加国际化和本地化的应用，我们将在这一节实现三种语言可以相互切换的国际化和本地化。（1）我们在resources下面添加三个property文件，分别为：messages_de.properties、messages_en.properties、messages_zh.properties，文件的命名规则：messages_语言.properties三个文件的内容如下：Ø         messages_de.propertieslabel.firstname=Vornamelabel.lastname=Familienamelabel.email=Emaillabel.telephone=Telefonlabel.addcontact=Addieren Kontaktlabel.title=spring mvc Internationalization (i18n) / LocalizationØ         messages_en.propertieslabel.firstname=First Namelabel.lastname=Last Namelabel.email=Emaillabel.telephone=Telephonelabel.addcontact=Add Contactlabel.title=spring mvc Internationalization (i18n) / LocalizationØ         messages_zh.properties（经过转换后的中文）label.firstname=\u59D3label.lastname=\u540D\u5B57label.email=\u7535\u5B50\u90AE\u4EF6label.telephone=\u7535\u8BDDlabel.addcontact=\u8054\u7CFB\u65B9\u5F0Flabel.title=spring mvc \u56FD\u9645\u5316\u548C\u672C\u5730\u5316\u652F\u6301 （2）spring-servet.xml文件的配置<!-- 为了使用国际化信息源，Spring MVC 必须实现MessageSource接口。当然框架内部有许多内置的实现类。我们需要做的是注册一个MessageSource类型的Bean。Bean 的名称必须为messageSource，从而方便DispatcherServlet自动检测它。每个DispatcherServlet只能注册一个信息源-->  <bean id="messageSource"

       class="org.springframework.context.support.ReloadableResourceBundleMessageSource">

       <property name="basename" value="classpath:messages" />

       <property name="defaultEncoding" value="UTF-8" />

    </bean>

<!—session 解析区域 -->

    <bean id="localeResolver" 

        class="org.springframework.web.servlet.i18n.SessionLocaleResolver"> 

     

<!-- property name="defaultLocale" value="en"/> --> 

    </bean> 

 <!-- 修改用户的区域需要调用区域修改拦截器 LocaleChangeInterceptor。如下所设定设定paramName属性来设定拦截请求中的特定参数（这里是language）确定区域。既然是拦截器那就需要注册到拦截器 Bean 中，这里是注册到了DefaultAnnotationHandlerMapping Bean中 -->

    <bean id="localeChangeInterceptor"

       class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">

       <property name="paramName" value="lang" />

    </bean>

<!--

    <bean id="localeResolver"

       class="org.springframework.web.servlet.i18n.CookieLocaleResolver">

       <property name="defaultLocale" value="en" />

    </bean>

 -->

    <bean id="handlerMapping"

        class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">

       <property name="interceptors">

           <ref bean="localeChangeInterceptor" />

       </property>

    </bean>
（3）在jsp目录下面创建一个contact.jsp文件<%@ page language="java" contentType="text/html; charset=UTF-8"

    pageEncoding="UTF-8"%>

<%@taglib uri="http://www.springframework.org/tags" prefix="spring"%>

<%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%>

<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<c:set var="ctx" value="${pageContext.request.contextPath}" />

<c:set var="ext" value="html" />

<html>

<head>

    <title>Spring 3 MVC Series - Contact Manager</title>

</head>

<body>

<h3><spring:message code="label.title"/></h3>

 

<span style="float: right">

    <a href="${ctx}/language.${ext}?local=en">英文</a>

    |

    <a href="${ctx}/language.${ext}?local=de">德文</a>

    <a href="${ctx}/language.${ext}?local=zh">中文</a>

</span>

 

 

<form:form method="post" action="addContact.html" commandName="contact">

 

    <table>

    <tr>

       <td><form:label path="firstname"><spring:message code="label.firstname"/></form:label></td>

       <td><form:input path="firstname" /></td>

    </tr>

    <tr>

       <td><form:label path="lastname"><spring:message code="label.lastname"/></form:label></td>

       <td><form:input path="lastname" /></td>

    </tr>

    <tr>

       <td><form:label path="lastname"><spring:message code="label.email"/></form:label></td>

       <td><form:input path="email" /></td>

    </tr>

    <tr>

       <td><form:label path="lastname"><spring:message code="label.telephone"/></form:label></td>

        <td><form:input path="telephone" /></td>

    </tr>

    <tr>

       <td colspan="2">

           <input type="submit" value="<spring:message code="label.addcontact"/>"/>

       </td>

    </tr>

</table>  

   

</form:form>

</body>

</html>
 其中<spring:message>标签结合 ResourceBundleMessageSource 的功能，在网页上显示 messages.properties 中的文字讯息。（4）创建LanguageController@Controller

public class LanguageController {

    @Autowired

    private SessionLocaleResolver localeResolver;

    @RequestMapping("/forLanguage")

    public String forLanguage(@ModelAttribute Contact contact){

       return "/contact";

    }

    @RequestMapping(value="/language",method=RequestMethod.GET)

     public ModelAndView changeLocal(@ModelAttribute Contact contact,HttpServletRequest request,@RequestParam String local,HttpServletResponse response){ 

            if("zh".equals(local)){

           

            localeResolver.setLocale(request, response, Locale.CHINA); 

            }else if("en".equals(local))  {

            localeResolver.setLocale(request, response, Locale.ENGLISH); 

            }else if("de".equals(local)){

            localeResolver.setLocale(request, response, Locale.GERMAN);

            }

               

            return new ModelAndView("/contact"); 

        } 

 

}
 其中红色部分就是对语言的设置效果如下图： 十一、使用jsr303进行验证 JSR 303 – Bean Validation 是一个数据验证的规范，2009 年 11 月确定最终方案。2009 年 12 月 Java EE 6 发布，Bean Validation 作为一个重要特性被包含其中，Spring MVC在使用了<mvc:annotation-driven> 后，如果路径中有jsr 303的实现，将自动提供对jsr 303验证方式的支持。Ø         引入hibernate-validator，hibernate-validator对jsr 303做了实现  <dependency>    <groupId>org.hibernate</groupId>    <artifactId>hibernate-validator</artifactId>    <version>4.2.0.Final</version></dependency>Ø         新增一个pojo bean ,增加jsr 303格式的验证annotationpublic class Contact {

    private Long id = 0L;

 

    @Size(min = 1)

    private String firstName;

 

    @NotNull

    @Size(min = 1)

    private String lastName;

 

    @Past

    private Date dateOfBirth;

 

    private boolean married;

 

    @Min(0)

    @Max(20)

    private int children;

}
Ø         在controller 类中的handler method中，对需要验证的对象前增加@Valid 标志  @RequestMapping(value="/add",method=RequestMethod.POST)    public String addContact(@ModelAttribute @Valid Contact contact,BindingResult result){       if(result.hasErrors()){           return "/contact";       }       return "/contact";    } Ø         在jsp页面中添加contact.jsp<form:form action="${ctx }/contact/add.${ext}" method="post"

       commandName="contact">

 

       <table border="1">

 

           <tr>

 

              <th> </th>

 

              <th><spring:message code="editcontact.heading" /></th>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message

                     code="editcontact.label.firstname" /></td>

 

              <td><form:input path="firstName" size="40" /><font

                  color="#FF0000"><form:errors path="firstName*" /></font></td>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message

                     code="editcontact.label.lastname" /></td>

 

              <td><form:input path="lastName" size="40" /><font

                  color="#FF0000"><form:errors path="lastName*" /></font></td>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message code="editcontact.label.dob" /></td>

 

              <td><form:input path="dateOfBirth" size="40" /><font

                  color="#FF0000"><form:errors path="dateOfBirth*" /></font></td>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message

                     code="editcontact.label.married" /></td>

 

              <td><form:checkbox path="married" /><font color="#FF0000"><form:errors

                         path="married" /></font></td>

 

           </tr>

 

           <tr>

 

              <td bgcolor="cyan"><spring:message

                     code="editcontact.label.children" /></td>

 

              <td><form:input path="children" size="5" /><font

                  color="#FF0000"><form:errors path="children*" /></font></td>

 

           </tr>

 

           <tr>

 

              <td><input type="submit"

                  value="<spring:message code="editcontact.button.save"/>" /></td>

 

              <td><input type="reset"

                  value="<spring:message code="editcontact.button.reset"/>" /></td>

           </tr>

       </table>

    </form:form>
 Ø         结果 使用jsr 303非常简单吧，有些人就问了，可以不可以自定义错误信息，当然是可以的，下面我就通过自定义错误来实现对contact的校验。@Size(min = 1, message = "Contact first name is required.")    private String firstName;     @NotNull(message = "Contact cannot be left empty.")    @Size(min = 1, message = "Contact last name is required.")    private String lastName;     @Past(message = "Contact date of birth must be a date in the past.")    @DateTimeFormat(pattern="yyyy-MM-dd")    private Date dateOfBirth;     private boolean married;     @Min(value = 0, message = "A contact cannot have fewer than 0 children")    @Max(value = 20, message = "A contact cannot have more than 20 children")    private int children; 只要将错误信息写到注解后面的message中即可，简单吧，我们再来看看jsr 303 主要的注解有哪些？表 1. Bean Validation 中内置的 constraint注    解功能说明@Null 被注释的元素必须为 null@NotNull 被注释的元素必须不为 null@AssertTrue 被注释的元素必须为 true@AssertFalse 被注释的元素必须为 false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max, min) 被注释的元素的大小必须在指定的范围内@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(value)被注释的元素必须符合指定的正则表达式 表 2. Hibernate Validator 附加的 constraint @Email                    被注释的元素必须是电子邮箱地址@Length                   被注释的字符串的大小必须在指定的范围内@NotEmpty                 被注释的字符串的必须非空@Range                    被注释的元素必须在合适的范围内 有人写就问了，那么可以不可以自定义注释类型呢？答案当然是可以的。Ø         自定义jsr303注释类型（1）@Age是一个定制化的 constraint，由两个内置的 constraint 组合而成。代码如下         @Max(130)@Min(1)@Constraint(validatedBy = {})@Documented@Target( { ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })@Retention(RetentionPolicy.RUNTIME)public @interface Age {    String message() default "年龄填写不正确";     Class<?>[] groups() default {};     Class<? extends Payload>[] payload() default {};}（2）status是一个重新写得注释类型@Status 的 annotation 部分@Constraint(validatedBy = {StatusValidator.class})@Documented@Target( { ElementType.ANNOTATION_TYPE, ElementType.METHOD, ElementType.FIELD })@Retention(RetentionPolicy.RUNTIME)public @interface Status {     String message() default "状态选择不正确";     Class<?>[] groups() default {};     Class<? extends Payload>[] payload() default {}; }@Status 的 constraint validator 部分public class StatusValidator implements ConstraintValidator<Status, Integer> {

    private final int[] ALL_STATUS = {1, 2, 3};

    public void initialize(Status arg0) {

       // TODO Auto-generated method stub

      

    }

 

    public boolean isValid(Integer value, ConstraintValidatorContext arg1) {

       if(Arrays.asList(ALL_STATUS).contains(value)) {

            return true;

          

       } else{

            return false;

       }

    }

 

}
如果大家对于注释怎么写不够了解，请参考其它相关文档。 在属性上增加age、status@Ageprivate int age;@Statusprivate int status;运行结果如下  

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

高并发面试必问：技术架构

高并发的业务架构是:

前端:异步请求+资源静态化+cdn
后端:请求队列+轮询分发+负载均衡+共享缓存数据层:redis缓存+数据分表+写队列存储:raid阵列+热备网络:dns轮询+DDOS攻击防护

版权声明：

Spring MVC入门案例（1）
开始Spring MVC建立一个web project,并导入spring 3.x的jar包配置web.xml根据上面的spring mvc流程图，我们知道DispatcherServlet是spring mvc 的一个前端控制器，所以我们当然要去配置它，以便于将请求转给DispatcherServlet处理   <servlet>

    <servlet-name>dispatcher</servlet-name>

    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

    <init-param>

        <param-name>contextConfigLocation</param-name>

<!-- 如果配置文件位于classpath下，可以这么写： classpath:dispatcher.xml -->

        <param-value>/WEB-INF/dispatcher.xml</param-value>

    </init-param>

    <load-on-startup>1</load-on-startup>

  </servlet>

 

  <servlet-mapping>

    <servlet-name>dispatcher</servlet-name>

    <url-pattern>/</url-pattern>

  </servlet-mapping>
  注：由于DispatcherServlet在初始化的过程中需要一个配置文件来生产文件中的各种bean,并生成WebApplicationContext对象，保存到ServletContext中(如果DispatcherServlet有多个，那么每一个DispatcherServlet都对应一个WebApplicationContext)，我们可以在Servlet的init-param中配置配置文件的路径，当然如果我们没有配置Init-Param,它会默认到WEB-INF的文件夹中找[servletname]-servlet.xml文件，例如上面如果我们没有配置，则会去寻找dispatcher-servlet.xml这个配置文件。（在init-param中我们可以指定多个配置文件，用逗号分隔也可以使用通配符*）配置上文中我们指定的所需的dispatcher.xml文件<?xml version="1.0" encoding="UTF-8"?>

 

<beans xmlns="http://www.springframework.org/schema/beans"

    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

    xmlns:p="http://www.springframework.org/schema/p"

    xmlns:context="http://www.springframework.org/schema/context"

    xmlns:mvc="http://www.springframework.org/schema/mvc"

    xsi:schemaLocation="

    http://www.springframework.org/schema/beans

    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd

    http://www.springframework.org/schema/context

    http://www.springframework.org/schema/context/spring-context-3.0.xsd

    http://www.springframework.org/schema/mvc

    http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd">

 

    <context:component-scan base-package="com.controls" />

   

    <mvc:annotation-driven />

   

    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">

       <property name="prefix" value="/WEB-INF/views/"></property>

       <property name="suffix" value=".jsp"></property>

       <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"></property>

    </bean>

   

</beans>
  配置文件说明：<context:component-scan base-package="com.controls" />由于我们使用了基于注解的Controller，所以这里指定了需要被扫描的包路径，如果有多个可以使用逗号分隔 <mvc:annotation-driven />上面的spring mvc流程图中我们知道DispatcherServlet接管请求后，会由HandlerMapping来执行映射，所以我们需要注册HanlderMapping，比如上面的标签会自动注册比如DefaultAnnotationHandlerMapping（执行请求到Controller的映射）和AnnotationMethodHandlerAdapter（调用controller中的方法）这样的bean，当然这个标签还提供了其他的一些支持(更多介绍请参照spring官方文档第455页)。 <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">

       <property name="prefix" value="/WEB-INF/views/"></property>

       <property name="suffix" value=".jsp"></property>

       <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"></property>

</bean>
 上面spring mvc流程图的最后controller处理完毕后会交给一个ViewResolver进行处理，大体上是解析视图逻辑名并经过一定的处理获取一个视图，这里的意思是设置视图用jsp来处理(比如我们设置viewClass为JstlView)来进行处理，就是以forward的形式转发给jsp，这个地址是：/WEB-INF/views/[controller返回值].jsp ，当然视图解析器可以定义多个，（视图解析器不会处理ModelAndView中已经设置了View的请求，因为已经有View来处理了，那当然就不需要它来解析到真正的视图View啦）编写Controller控制器这里我们使用例子的形式来说明 实现一个控制器类@Controller

@RequestMapping("/user")

public class UserControl {

}
 只要给类加上Controller的注解，并放在被扫描的包中，那么这个类就是一个控制器了，RequestMapping表明匹配的路径，可以写在类或者类的方法上，如果类上面有RequestMapping注解，那么其下面的方法就是相对于类上面注解地址的一个相对路径  定义一个接管请求的方法方法名：无任何要求--------------------------------------------------------------参数：(顺序以及个数无任何要求)HttpServletRequestHttpServletResponsePrintWriter             相当于HttpResponse.getWriter()获得的对象Map                       其实是获得了ModelAndView中的ModelBindingResult           绑定数据的处理结果HttpSession             如果使用此参数，需要注意如果是第一次访问还没有session的话会报错@PathVariable           用于接收路径变量@RequestParam         相当于调用request.getParameter(“name”)方法@CookieValue           获取cookie的值@RequestHeader        获取header中的值实体对象              会根据请求的参数名，注入到这个对象对于得属性中，必须提供set方法等等等等等--------------------------------------------------------------返回值：void                 返回值是void，如果接收了PrintWriter 或者  HttpServletResponse 参数，那么返回的ModelAndView就是null，也就是直接将输出流输出到客户端，如果方法没有接收输出参数，后面会默认生成一个视图名 String                视图逻辑名 ModelAndView        是一个视图逻辑名+Map的封装类其他任意类型         存入ModelAndView中的Model-------------------------------------------------------------- 不管我们的返回类型是什么，返回值会通过处理，最终返回一个ModelAndView或者null例1:给方法定义一个请求映射并使用路径变量    @RequestMapping("/id/{userid}/name/{username}")

    public String queryUser(@PathVariable("userid") long userID

           , @PathVariable("username") String userName

           , Map<String, User> model) {

      

       User user = new User();

       user.setUserID(userID);

       user.setUserName(userName);

      

       model.put("userInfo", user);

      

       return "Home";

    }
  @RequestMapping定义路由映射，其中{userid} {username} 是PathVariable(路径变量)这样我们只需访问 http://localhost:8080/SpringMVC/user/id/10001/name/liudehua 就能进入上面的方法RequestMapping还可以使用通配符，如： /test/*/name/{name}例2:接受请求参数@RequestMapping("/save")

    public String save(@RequestParam("userName") String userName

           ,@RequestParam("Age") int age) {

      

       System.out.println(userName);

       System.out.println(age);

      

       return "Home";

    }
   例3:请求参数直接注入到Model@RequestMapping("/save")

    public String save(User user) {

      

       System.out.println(user.getUserID());

       System.out.println(user.getUserName());

      

       return "Home";

    }
  例4:转发与重定向转发：   (相当于 request.getRequestDispatcher(“”).forward(request, response))return “forward:/user/test”; 重定向： (相当于response.redirect(“”))return “redirect:/user/test”return “redirect:http://www.google.com.hk”; 例5:根据HttpMethod来过滤请求@RequestMapping(value="", method=RequestMethod.POST)    public String Test(//…) {       //…}  例6:根据参数来进行过滤@RequestMapping(params="hello=world", method={RequestMethod.GET, RequestMethod.POST})  public String helloworld() {}  必须有个hello的参数并且名称为world，而且只能是get或post请求才会进入此方法   

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

Content模块设计意图

Content 模块概述


“content”模块放在src \content里面，并使用多进程浏览器沙盒模块来呈现页面所需的核心代码。它包括所有的网络平台功能（如HTML5）和GPU加速。它不包括Chrome浏览器的功能，即扩展/自动填充/拼写等。它的目标是，任何嵌入者或者说使用者应该能够用它来开始建立一个浏览器，然后从中挑选Chrome功能。


动机是什么？


由于Chrome代码的不断壮大，功能不可避免地有时候会放在错误的地方，从而导致分层规则的不规范，以及不应该存在的依赖关系。它已经很难为开发者找出最好的方法，因为这些API和功能都在同一个目录下。为了避免这种情况发生，并增加核心部分的代码，Chrome采用多进程浏览器并对呈现页面的工作明确分工，把核心浏览器代码转移​​到src\content里面。


content 还是Chrome？


content应该只是呈现页面所需的核心代码。 Chrome功能由content提供的API来过滤IPC，以及得到事件通知。


举一个例子好了，下面是一个Chrome功能列表部分。它们并不在content里面，这意味着content的代码不应该知道他们，content只需要提供通用的API，Chrome的那些功能可以基于这些API来编写：

ExtensionsNaClChromeFrameSpellCheckAutofillSyncPrerenderingSafe BrowsingTranslate


体系结构图






上图显示了不同模块的层次结构。一个模块可以直接包括较低的模块代码。模块可以不包括一个比它更高模块的代码。这是通过DEPS规则强制执行实现的。模块可以实现嵌入者比如Chrome的API，使低于自己的模块可以调用自己。这些API的实例是WebKit的API和content的API。


Content API


Content API 告诉我们如何基于content来间接调用浏览器。如果可能的话，Chrome功能尝试通过IPC过滤，监听事件来设置钩子。如果没有足够的上下文（比如WebKit的回调），或在回调是一次性的情况下，chromium有一个ContentClient接口，嵌入者（Chrome浏览器）实现好了的。 ContentClient在所有进程里都是可用的，一些进程也有自己的回调API，比如 ContentBrowserClient / ContentRendererClient / ContentPluginClient等等。






部分参考：http://www.chromium.org/developers/content-module


本文属原创，转载请注明出处，违者必究

关注chromium群480089700，或者微信公众平台:程序员互动联盟(coder_online)，你可以第一时间获取原创技术文章，和（java/C/C++/Android/Windows/Linux）技术大牛做朋友，在线交流编程经验，获取编程基础知识，解决编程问题。程序员互动联盟，开发人员自己的家。








版权声明：本文为博主原创文章，未经博主允许不得转载。

Spring MVC入门案例（2）
以下这个学习案例是我最近学习Spring MVC时跟从一本书上的示例，原文中的示例代码有一些小错误，不过我在调试的过程中已经给予了修正，如还有其它错误，还请各位批评指正。对于现有较成熟的Model-View-Control(MVC)框架而言，其解决的主要问题无外乎下面几部分：1． 将Web页面中的输入元素封装为一个（请求）数据对象。2． 根据请求的不同，调度相应的逻辑处理单元，并将（请求）数据对象作为参数传入。3． 逻辑处理单元完成运算后，返回一个结果数据对象。4． 将结果数据对象中的数据与预先设计的表现层相融合并展现给用户。各个MVC 实现固然存在差异，但其中的关键流程大致如上。结合一个实例，我们来看看这几个关键流程在Spring MVC框架中的处理手法。下面的实例，实现了一个常见的用户登录逻辑，即用户通过用户名和密码登录，系统对用户名和密码进行检测，如果正确，则在页面上显示几条通知信息。如果登录失败，则返回失败界面。(示例中，表示层以JSP2.0实现。)出于简洁考虑，这里的“用户名/密码”检测以及通知信息的生成均在代码中以硬编码实现。首先来看登录界面：对应的index.html:<html>

<body>

<form method="POST" action="login.do">

<p align="center">登录</p>

<br>

用户名:

<input type="text" name="username" >

<br>

密 码 :

<input type="password" name="password" >

<br>

<p>

<input type="submit" value="提交" name="B1">

<input type="reset" value="重置" name="B2">

</p>

</form>

</body>

</html>
很简单的一个登录界面，其中包含了一个用以输入用户名密码的form，针对此form的提交将被发送到"login.do"MVC 关键流程的第一步，即收集页面输入参数，并转换为请求数据对象。这个静态页面提供了一个基本的输入界面，下面这些输入的数据将被发送至何处，将如何被转换为请求数据对象？现在来看接下来发发生的事情：当用户输入用户名密码提交之后，此请求被递交给Web 服务器处理，上面我们设定form提交目标为"login.do"，那么Web服务器将如何处理这个请求？显然，标准Http 协议中，并没有以.do 为后缀的服务资源，这是我们自己定义的一种请求匹配模式。此模式在web.xml中设定：<?xml version="1.0" encoding="ISO-8859-1"?>

<web-app xmlns="http://java.sun.com/xml/ns/j2ee"

xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee

http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"

version="2.4">

<servlet> ⑴

<servlet-name>Dispatcher</servlet-name>

<servlet-class>

org.springframework.web.servlet.DispatcherServlet

</servlet-class>

<init-param>

<param-name>contextConfigLocation</param-name>

<param-value>/WEB-INF/Config.xml</param-value>

</init-param>

</servlet>

<servlet-mapping> ⑵

<servlet-name>Dispatcher</servlet-name>

<url-pattern>*.do</url-pattern>

</servlet-mapping>

</web-app>
⑴ Servlet定义这里我们定义了请求分发Servlet，即：org.springframework.web.servlet.DispatcherServletDispatcherServlet 是Spring MVC 中负责请_____求调度的核心引擎，所有的请求将由此Servlet 根据配置分发至各个逻辑处理单元。其内部同时也维护了一个ApplicationContext实例。我们在<init-param>节点中配置了名为“contextConfigLocation”的Servlet参数，此参数指定了Spring配置文件的位置“/WEB-INF/Config.xml”。如果忽略此设定，则默认为“/WEB-INF/<servlet name>-servlet.xml”，其中<servlet name>以Servlet 名替换（在当前环境下，默认值也就是“/WEB-INF/Dispatcher-servlet.xml）。⑵ 请求映射我们将所有以.do结尾的请求交给Spring MVC进行处理。当然，也可以设为其他值，如.action、.action等。通过以上设定，Web 服务器将把登录界面提交的请求转交给Dispatcher 处理，Dispatcher将提取请求（HttpServletRequest）中的输入数据，分发给对应的处理单元，各单元处理完毕后，将输出页面返回给Web服务器，再由Web服务器返回给用户浏览器。Dispatcher 根据什么分发这些请求？显然，我们还需要一个配置文件加以设定。这也就是上面提及的Config.xml，此文件包含了所有的“请求/处理单元”关系映射设定，以及返回时表现层的一些属性设置。<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"

"http://www.springframework.org/dtd/spring-beans.dtd">

<beans>

<!--Definition of View Resolver -->

<bean id="viewResolver" ⑴

class="org.springframework.web.servlet.view.InternalResou

rceViewResolver">

<property name="viewClass"> ⑵

<value>

org.springframework.web.servlet.view.JstlView

</value>

</property>

<property name="prefix"> ⑶

<value>

/WEB-INF/view/

</value>

</property>

<property name="suffix"> ⑷

<value>.jsp</value>

</property>

</bean>

<!--Request Mapping -->

<bean id="urlMapping" ⑸

class="org.springframework.web.servlet.handler.SimpleUr

lHandlerMapping">

<property name="mappings">

<props>

<prop key="/login.do">LoginAction</prop>

</props>

</property>

</bean>

<!---Action Definition-->

<bean id="LoginAction" ⑹

class="net.xiaxin.action.LoginAction">

<property name="commandClass"> ⑺

<value>net.xiaxin.action.LoginInfo</value>

</property>

<property name="fail_view"> ⑻

<value>loginfail</value>

</property>

<property name="success_view">

<value>main</value>

</property>

</bean>

</beans>
⑴ Resolver设定Resolver将把输出结果与输出界面相融合，为表现层提供呈现资源。⑵ View Resolver的viewClass参数这里我们使用JSP页面作为输出，因此，设定为：org.springframework.web.servlet.view.JstlView其余可选的viewClass还有:Ø org.springframework.web.servlet.view.freemarker.FreeMarkerView（用于基于FreeMarker模板的表现层实现）Ø org.springframework.web.servlet.view.velocity.VelocityView（用于基于velocity模板的表现层实现）等。⑶⑷ View Resolver的prefix和suffix参数指定了表现层资源的前缀和后缀，运行时，Spring 将为指定的表现层资源自动追加前缀和后缀，以形成一个完整的资源路径。另参见⑻⑸ “请求/处理单元”关系映射可以看到，这里我们将“/login.do”请求映射到处理单元LoginAction。<props>节点下可以有多个映射关系存在，目前我们只定义了一个。⑹ LoginAction定义这里定义了逻辑处理单元LoginAction 的具体实现，这里，LoginAction 的实现类为net.xiaxin.action.LoginAction。⑺ LoginAction的请求数据对象commandClass 参数源于LoginAction 的基类BaseCommandController，BaseCommandControlle 包含了请求数据封装和验证方法（ BaseCommandController.bindAndValidate ） ， 它将根据传入的HttpServletRequest构造请求数据对象。这里我们指定commandClass 为net.xiaxin.action.LoginInfo，这是一个非常简单的Java Bean，它封装了登录请求所需的数据内容：public class LoginInfo {

private String username;

private String password;

public String getPassword() {

return password;

}

public void setPassword(String password) {

this.password = password;

}

public String getUsername() {

return username;

}

public void setUsername(String username) {

this.username = username;

}

}
Spring会根据LoginAction的commandClass定义自动加载对应的LoginInfo实例。之后，对Http 请求中的参数进行遍历，并查找LoginInfo 对象中是否存在与之同名的属性，如果找到，则将此参数值复制到LoginInfo对象的同名属性中.请求数据转换完成之后，我们得到了一个封装了所有请求参数的Java 对象，并将此对象作为输入参数传递给LoginAction。⑻ 返回视图定义对于这里的LoginAction 而言，有两种返回结果，即登录失败时返回错误界面，登录成功时进入系统主界面。对应我们配置了fail_view、success_view两个自定义参数。参数值将由Resolver进行处理，为其加上前缀后缀，如对于fail_view而言，实际的视图路径为/WEB-INF/view/loginfail.jsp。之后，Resolver 会将LoginAction的返回数据与视图相融合，返回最终的显示界面。业务逻辑处理单元:LoginAction.java：

public class LoginAction extends SimpleFormController {

private String fail_view;

private String success_view;

protected ModelAndView onSubmit( ⑴

Object cmd,

BindException ex

)throws Exception {

LoginInfo loginInfo = (LoginInfo) cmd; ⑵

HashMap result_map = new HashMap();

if (login(loginInfo) == 0) {

result_map.put("logininfo", loginInfo);

List msgList = new LinkedList();

msgList.add("msg1");

msgList.add("msg2");

msgList.add("msg3");

result_map.put("messages", msgList);

return new

ModelAndView(this.getSuccess_view(), result_map); ⑶

} else {

result_map.put("failmsg", new String("Sorry, you input the wrong username or password!"));

return new ModelAndView(this.getFail_view(), result_map);

}

}

private int login(LoginInfo loginInfo) {

if ("Erica".equalsIgnoreCase(loginInfo.getUsername())

&&"mypass".equals(loginInfo.getPassword())) {

return 0;

}

return 1;

}

public String getFail_view() {

return fail_view;

}

public String getSuccess_view() {

return success_view;

}

public void setFail_view(String string) {

fail_view = string;

}

public void setSuccess_view(String string) {

success_view = string;

}

}
其中：⑴ onSubmit方法我们在子类中覆盖了父类的onSubmit方法；而onSubmit方法用于处理业务请求。负责数据封装和请求分发的Dispatcher，将对传入的HttpServletRequest进行封装，形成请求数据对象，之后根据配置文件，调用对应业务逻辑类的入口方法（这里就是LoginAction）的onSubmit()方法，并将请求数据对象及其他相关资源引用传入。protected ModelAndView onSubmit(Object cmd,BindException ex)onSubmit方法包含了两个参数：Object cmd和BindException ex。前面曾经多次提到请求数据对象，这个名为cmd的Object型参数，正是传入的请求数据对象的引用。BindException ex参数则提供了数据绑定错误的跟踪机制。它作为错误描述工具，用于向上层反馈错误信息。在Spring MVC中，BindException将被向上层表现层反馈，以便在表现层统一处理异常情况（如显示对应的错误提示），这一机制稍后在“输入参数合法性校验”部分再具体探讨。onSubmit还有另外一个签名版本：protected ModelAndView onSubmit(

HttpServletRequest request,

HttpServletResponse response,

Object cmd,

BindException ex

)
可以看到，类似Servlet的doGet/doPost方法，此版本的onSubmit方法签名中包含了Servlet规范中的HttpServletRequest、HttpServletResponse以提供与Web服务器的交互功能（如Session的访问）。此参数类型的onSubmit方法的调用优先级较高。也就是说，如果我们在子类中同时覆盖了这两个不同参数的onSubmit方法，那么只有此版本的方法被执行，另一个将被忽略。⑵ 将输入的请求数据对象强制转型为预定义的请求对象类型。⑶ 返回处理结果ModelAndView类包含了逻辑单元返回的结果数据集和表现层信息。ModelAndView本身起到关系保存的作用。它将被传递给Dispatcher，由Dispatcher 根据其中保存的结果数据集和表现层设定合成最后的界面。这里我们用到了两种签名版本的ModelAndView构造方法：Ø public ModelAndView(String viewname)返回界面无需通过结果数据集进行填充。Ø public ModelAndView(String viewname, Map model)返回界面由指定的结果数据集加以填充。可以看到，结果数据集采用了Map接口实现的数据类型。其中包含了返回结果中的各个数据单元。关于结果数据集在界面中的填充操作，可参见下面关于返回界面的描述。上面这两个版本的构造子中，通过viewname指定了表示层资源。另外，我们也可以通过传递View对象指定表示层资源。Ø public ModelAndView(View view)Ø public ModelAndView(View view, Map model)我们可以结合RedirectView完成转向功能，如：return new ModelAndView(new RedirectView(“/redirected.jsp”));当然，我们也可以在带有HttpServletRequest参数的onSubmit方法实现中，通过HttpServletRequest/HttpServletResponse完成forward/redirect功能，这两种途径可以达到同样的效果。最后，来看返回界面：错误返回界面loginfail.jsp只是个纯html文件（为了与View Resolver中设定的后缀相匹配，因此以.jsp作为文件后缀），这里就不再浪费篇幅。再看成功登录后的页面main.jsp:界面显示效果如下：<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt" %>

<html>

<body>

<p>Login Success!!!</p>

<p>Current User:

<c:out value="${logininfo.username}"/><br>

</p>

<p>Your current messages:</p>

<c:forEach items="${messages}"

var="item"

begin="0"

end="9"

step="1"

varStatus="var">

<c:if test="${var.index % 2 == 0}">

*

</c:if>

${item}<br>

</c:forEach>

</body>

</html>
登录失败后的页面loginfail.jsp:<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt"%><html><body><p>Login Fail!!!</p><c:out value="${failmsg}"/></body></html> 页面逻辑非常简单，首先显示当前登录用户的用户名。然后循环显示当前用户的通知消息“messages”。如果当前循环索引为奇数，则在消息前追加一个“*”号（这个小特性在这里似乎有些多余，但却为不熟悉JSTL 的读者提供了如何使用JSTL Core taglib 进行循环和逻辑判断的样例）。实际上这只是个普通JSTL/JSP页面，并没有任何特殊之处，如果说有些值得研究的技术，也就是其中引用的JSTL Core Taglib<%@ taglib prefix="c" uri="http://java.sun.com/jstl/core_rt" %>上面这句话申明了页面中所引用的taglib，指定其前缀为“c”，也就是说，在页面中，所有以“c”为前缀，形同<c:xxxx>的节点都表明是此taglib的引用，在这里，也就是对JSTLCore Lib的引用。这里需要注意的是，笔者所采用的Web 容器为Tomcat 5(支持Servlet 2.4/JSP2.0规范)以及Apache JSTL 2.0(http://jakarta.apache.org/taglibs/index.html)。<c:out value="${logininfo.username}"/><c:out>将value 中的内容输出到当前位置，这里也就是把logininfo 对象的username属性值输出到页面当前位置。${……}是JSP2.0 中的Expression Language（EL）的语法。它定义了一个表达式，其中的表达式可以是一个常量（如上），也可以是一个具体的表达语句（如forEach循环体中的情况）。典型案例如下：Ø ${logininfo.username}这表明引用logininfo 对象的username 属性。我们可以通过“.”操作符引用对象的属性，也可以用“[]”引用对象属性，如${logininfo[username]}与${logininfo.username}达到了同样的效果。“[]”引用方式的意义在于，如果属性名中出现了特殊字符，如“.”或者“-”，此时就必须使用“[]”获取属性值以避免语法上的冲突（系统开发时应尽量避免这一现象的出现）。与之等同的JSP Script大致如下：LoginInfo logininfo =(LoginInfo)session.getAttribute(“logininfo”);String username = logininfo.getUsername();可以看到，EL大大节省了编码量。这里引出的另外一个问题就是，EL 将从哪里找到logininfo 对象，对于${logininfo.username}这样的表达式而言，首先会从当前页面中寻找之前是否定义了变量logininfo，如果没有找到则依次到Request、Session、Application 范围内寻找，直到找到为止。如果直到最后依然没有找到匹配的变量，则返回null.如果我们需要指定变量的寻找范围，可以在EL表达式中指定搜寻范围：${pageScope.logininfo.username}${requestScope.logininfo.username}${sessionScope.logininfo.username}${applicationScope.logininfo.username}在Spring 中，所有逻辑处理单元返回的结果数据，都将作为Attribute 被放置到HttpServletRequest 对象中返回（具体实现可参见Spring 源码中org.springframework.web.servlet.view.InternalResourceView.exposeModelAsRequestAttributes方法的实现代码），也就是说SpringMVC 中，结果数据对象默认都是requestScope。因此，在Spring MVC 中，以下寻址方法应慎用：${sessionScope.logininfo.username}${applicationScope.logininfo.username}Ø ${1＋2}结果为表达式计算结果，即整数值3。Ø ${i>1}如果变量值i>1的话，将返回bool类型true。与上例比较，可以_____发现EL会自动根据表达式计算结果返回不同的数据类型。表达式的写法与java代码中的表达式编写方式大致相同。<c:forEach items="${messages}"var="item"begin="0"end="9"step="1"varStatus="var">……</c:forEach>上面这段代码的意思是针对messages 对象进行循环，循环中的每个循环项的引用变量为item，循环范围是从0到9，每次步长为1。而varStatus则定义了一个循环状态变量var，循环状态变量中保存了循环进行时的状态信息，包括以下几个属性：属性 类型 说明index int 当前循环索引号count int 成员总数first boolean 当前成员是否首位成员last boolean 当前成员是否末尾成员再看：<c:if test="${var.index % 2 == 0}">*</c:if>这段代码演示了判定Tag <c:if>的使用方法。可以看到，其test属性指明了判定条件，判定条件一般为一个EL表达式。<c:if>并没有提供else子句，使用的时候可能有些不便，此时我们可以通过<c:choose>tag来达到类似的目的：<c:choose><c:when test="${var.index % 2 == 0}">*</c:when><c:otherwise>!</c:otherwise></c:choose>类似Java 中的switch 语句，<c:choose>提供了复杂判定条件下的简化处理手法。其中 <c:when>子句类似case子句，可以出现多次。上面的代码，在奇数行时输出“*”号，而偶数行时输出“!”。通过<c:choose>改造后的输出页面：至此，一个典型的请求/响应过程结束。通过这个过程，我们也了解了Spring MVC 的核心实现机制。对其进行总结，得到以下UML序列图：

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

java excel Workbook API
     1. int getNumberOfSheets()
　　获得工作薄（Workbook）中工作表（Sheet）的个数，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
int sheets = rwb.getNumberOfSheets();




　　2. Sheet[] getSheets()
　　返回工作薄（Workbook）中工作表（Sheet）对象数组，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
Sheet[] sheets = rwb.getSheets();




　　3. String getVersion()
　　返回正在使用的API的版本号，好像是没什么太大的作用。





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
String apiVersion = rwb.getVersion();




　　Sheet接口提供的方法

　　1) String getName()
　　获取Sheet的名称，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
String sheetName = rs.getName();




　　2) int getColumns()
　　获取Sheet表中所包含的总列数，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
int rsColumns = rs.getColumns();




　　3) Cell[] getColumn(int column)

　　获取某一列的所有单元格，返回的是单元格对象数组，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
Cell[] cell = rs.getColumn(0);




　　4) int getRows()
　　获取Sheet表中所包含的总行数，示例：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
int rsRows = rs.getRows();




　　5) Cell[] getRow(int row)
　　获取某一行的所有单元格，返回的是单元格对象数组，示例子：





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
Cell[] cell = rs.getRow(0);




　　6) Cell getCell(int column, int row)
　　获取指定单元格的对象引用，需要注意的是它的两个参数，第一个是列数，第二个是行数，这与通常的行、列组合有些不同。





jxl.Workbook rwb = jxl.Workbook.getWorkbook(new File(sourcefile));
jxl.Sheet rs = rwb.getSheet(0);
Cell cell = rs.getCell(0, 0);




　　2、生成新的Excel工作薄

　　下面的代码主要是向大家介绍如何生成简单的Excel工作表，在这里单元格的内容是不带任何修饰的(如：字体，颜色等等)，所有的内容都作为字符串写入。(完整代码见ExcelWriting.java)

　　与读取Excel工作表相似，首先要使用Workbook类的工厂方法创建一个可写入的工作薄(Workbook)对象，这里要注意的是，只能通过API提供的工厂方法来创建Workbook，而不能使用WritableWorkbook的构造函数，因为类WritableWorkbook的构造函数为protected类型。示例代码片段如下：





import java.io.*;
import jxl.*;
import jxl.write.*;
… … … …
try
{
//构建Workbook对象, 只读Workbook对象
//Method 1：创建可写入的Excel工作薄
jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(new File(targetfile));

//Method 2：将WritableWorkbook直接写入到输出流

}
catch (Exception e)
{
e.printStackTrace();
}




　　API提供了两种方式来处理可写入的输出流，一种是直接生成本地文件，如果文件名不带全路径的话，缺省的文件会定位在当前目录，如果文件名带有全路径的话，则生成的Excel文件则会定位在相应的目录；另外一种是将Excel对象直接写入到输出流，例如：用户通过浏览器来访问Web服务器，如果HTTP头设置正确的话，浏览器自动调用客户端的Excel应用程序，来显示动态生成的Excel电子表格。

　　接下来就是要创建工作表，创建工作表的方法与创建工作薄的方法几乎一样，同样是通过工厂模式方法获得相应的对象，该方法需要两个参数，一个是工作表的名称，另一个是工作表在工作薄中的位置，参考下面的代码片段：





//创建Excel工作表
jxl.write.WritableSheet ws = wwb.createSheet("Test Sheet 1", 0);

"这锅也支好了，材料也准备齐全了，可以开始下锅了！"，现在要做的只是实例化API所提供的Excel基本数据类型，并将它们添加到工作表中就可以了，参考下面的代码片段：
//1.添加Label对象
jxl.write.Label labelC = new jxl.write.Label(0, 0, "This is a Label cell");
ws.addCell(labelC);

//添加带有字型Formatting的对象
jxl.write.WritableFont wf = new jxl.write.WritableFont(WritableFont.TIMES, 18, WritableFont.BOLD, true);
jxl.write.WritableCellFormat wcfF = new jxl.write.WritableCellFormat(wf);
jxl.write.Label labelCF = new jxl.write.Label(1, 0, "This is a Label Cell", wcfF);
ws.addCell(labelCF);

//添加带有字体颜色Formatting的对象
jxl.write.WritableFont wfc = new jxl.write.WritableFont(WritableFont.ARIAL, 10, WritableFont.NO_BOLD, false,
Underlinestyle.NO_UNDERLINE, jxl.format.Colour.RED);
jxl.write.WritableCellFormat wcfFC = new jxl.write.WritableCellFormat(wfc);
jxl.write.Label labelCFC = new jxl.write.Label(1, 0, "This is a Label Cell", wcfFC);
ws.addCell(labelCF);

//2.添加Number对象
jxl.write.Number labelN = new jxl.write.Number(0, 1, 3.1415926);
ws.addCell(labelN);

//添加带有formatting的Number对象
jxl.write.NumberFormat nf = new jxl.write.NumberFormat("#.##");
jxl.write.WritableCellFormat wcfN = new jxl.write.WritableCellFormat(nf);
jxl.write.Number labelNF = new jxl.write.Number(1, 1, 3.1415926, wcfN);
ws.addCell(labelNF);

//3.添加Boolean对象
jxl.write.Boolean labelB = new jxl.write.Boolean(0, 2, false);
ws.addCell(labelB);

//4.添加DateTime对象
jxl.write.DateTime labelDT = new jxl.write.DateTime(0, 3, new java.util.Date());
ws.addCell(labelDT);

//添加带有formatting的DateFormat对象
jxl.write.DateFormat df = new jxl.write.DateFormat("dd MM yyyy hh:mm:ss");
jxl.write.WritableCellFormat wcfDF = new jxl.write.WritableCellFormat(df);
jxl.write.DateTime labelDTF = new jxl.write.DateTime(1, 3, new java.util.Date(), wcfDF);
ws.addCell(labelDTF);




　　这里有两点大家要引起大家的注意。第一点，在构造单元格时，单元格在工作表中的位置就已经确定了。一旦创建后，单元格的位置是不能够变更的，尽管单元格的内容是可以改变的。第二点，单元格的定位是按照下面这样的规律(column, row)，而且下标都是从0开始，例如，A1被存储在(0, 0)，B1被存储在(1, 0)。

　　最后，不要忘记关闭打开的Excel工作薄对象，以释放占用的内存，参见下面的代码片段：





//写入Exel工作表
wwb.write();

//关闭Excel工作薄对象
wwb.close();




　　这可能与读取Excel文件的操作有少少不同，在关闭Excel对象之前，你必须要先调用write()方法，因为先前的操作都是存储在缓存中的，所以要通过该方法将操作的内容保存在文件中。如果你先关闭了Excel对象，那么只能得到一张空的工作薄了。

　　3、拷贝、更新Excel工作薄

　　接下来简要介绍一下如何更新一个已经存在的工作薄，主要是下面二步操作，第一步是构造只读的Excel工作薄，第二步是利用已经创建的Excel工作薄创建新的可写入的Excel工作薄，参考下面的代码片段：(完整代码见ExcelModifying.java)





//创建只读的Excel工作薄的对象
jxl.Workbook rw = jxl.Workbook.getWorkbook(new File(sourcefile));

//创建可写入的Excel工作薄对象
jxl.write.WritableWorkbook wwb = Workbook.createWorkbook(new File(targetfile), rw);

//读取第一张工作表
jxl.write.WritableSheet ws = wwb.getSheet(0);

//获得第一个单元格对象
jxl.write.WritableCell wc = ws.getWritableCell(0, 0);

//判断单元格的类型, 做出相应的转化
if(wc.getType() == CellType.LABEL)
{
Label l = (Label)wc;
l.setString("The value has been modified.");
}

//写入Excel对象
wwb.write();

//关闭可写入的Excel对象
wwb.close();

//关闭只读的Excel对象
rw.close();




　　之所以使用这种方式构建Excel对象，完全是因为效率的原因，因为上面的示例才是API的主要应用。为了提高性能，在读取工作表时，与数据相关的一些输出信息，所有的格式信息，如：字体、颜色等等，是不被处理的，因为我们的目的是获得行数据的值，既使没有了修饰，也不会对行数据的值产生什么影响。唯一的不利之处就是，在内存中会同时保存两个同样的工作表，这样当工作表体积比较大时，会占用相当大的内存，但现在好像内存的大小并不是什么关键因素了。

　　一旦获得了可写入的工作表对象，我们就可以对单元格对象进行更新的操作了，在这里我们不必调用API提供的add()方法，因为单元格已经于工作表当中，所以我们只需要调用相应的setXXX()方法，就可以完成更新的操作了。

　　尽单元格原有的格式化修饰是不能去掉的，我们还是可以将新的单元格修饰加上去，以使单元格的内容以不同的形式表现。

　　新生成的工作表对象是可写入的，我们除了更新原有的单元格外，还可以添加新的单元格到工作表中，这与示例2的操作是完全一样的。

　　最后，不要忘记调用write()方法，将更新的内容写入到文件中，然后关闭工作薄对象，这里有两个工作薄对象要关闭，一个是只读的，另外一个是可写入的。

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDFS源码分析(五)-----节点注册与心跳机制
前言在Hadoop的HDFS启动的时候,不知道大家有没有注意到一个细节,一般都是先启动NameNode,然后再启动DataNode,细想一下,原因就很简单了,因为NameNode要维护元数据信息,而这些信息都是要等待后续启动的DataNode的情况汇报才能逐步构建的.然后之后通过保持心跳的形式进行block块映射关系的维护与更新.而今天的文章就以此方面,对这块流程做全面的分析.相关涉及类依旧需要介绍一下相关的涉及类,首先要有一个大概的了解.下面是主要的类:1.DataNode--数据节点类,这个和之前的数据节点描述符类又又有点不同,里面也定义了许多与数据节点相关的方法.2.NaemNode--名字节点类,注册信息的处理以及心跳包的处理都需要名字节点处理,名字节点的处理方法会调用FSNamesystem大系统中的方法.3.DatanodeCommand以及BlockCommand--数据节点命令类以及他的子类,block相关命令类,此类用于名字节点心跳回复命令给数据节点时用的.4.FSNamesystem和DatanodeDescriptor--附属类,这些类中的某些方法会在上述过程中被用到.OK,涉及的类的总数也不多,下面讲述第一个流程,节点注册,数据节点是如何在启动的时候注册到名字节点的呢.节点注册节点的注册是在数据节点启动之后发生的,首先进入main主方法public static void main(String args[]) {
    secureMain(args, null);
  }然后进入secureMainpublic static void secureMain(String [] args, SecureResources resources) {
    try {
      StringUtils.startupShutdownMessage(DataNode.class, args, LOG);
      DataNode datanode = createDataNode(args, null, resources);
      if (datanode != null)
        datanode.join();
    } catch (Throwable e) {
      LOG.error(StringUtils.stringifyException(e));
      System.exit(-1);
    } finally {
      // We need to add System.exit here because either shutdown was called or
      // some disk related conditions like volumes tolerated or volumes required
      // condition was not met. Also, In secure mode, control will go to Jsvc and
      // the process hangs without System.exit.
      LOG.info("Exiting Datanode");
      System.exit(0);
    }
  }进入createDataNode方法,中间还会有1,2个方法,最终会调用到核心的runDatanodeDaemon()方法/** Start a single datanode daemon and wait for it to finish.
   *  If this thread is specifically interrupted, it will stop waiting.
   * 数据节点启动的核心方法
   */
  public static void runDatanodeDaemon(DataNode dn) throws IOException {
    if (dn != null) {
      //register datanode
      //首先注册节点
      dn.register();
      //后续开启相应线程
      dn.dataNodeThread = new Thread(dn, dnThreadName);
      dn.dataNodeThread.setDaemon(true); // needed for JUnit testing
      dn.dataNodeThread.start();
    }
  }于是就调用了register的方法/**
   * Register datanode
   * <p>
   * The datanode needs to register with the namenode on startup in order
   * 1) to report which storage it is serving now and 
   * 2) to receive a registrationID 
   * issued by the namenode to recognize registered datanodes.
   * 
   * @see FSNamesystem#registerDatanode(DatanodeRegistration)
   * @throws IOException
   * 数据节点的注册方法,会调用到namenode上的注册方法
   */
  private void register() throws IOException {
    if (dnRegistration.getStorageID().equals("")) {
      setNewStorageID(dnRegistration);
    }
    while(shouldRun) {
      try {
        // reset name to machineName. Mainly for web interface.
        dnRegistration.name = machineName + ":" + dnRegistration.getPort();
        //调用namenode上的注册方法
        dnRegistration = namenode.register(dnRegistration);
        break;
....然后这里,我们可以看到,注册方法实质上调用名字节点的注册方法.跟踪名字节点的同名法方法////////////////////////////////////////////////////////////////
  // DatanodeProtocol
  ////////////////////////////////////////////////////////////////
  /** 
   * 名字节点的注册方法,调用的是FSNameSystem方法
   */
  public DatanodeRegistration register(DatanodeRegistration nodeReg
                                       ) throws IOException {
    //首先做版本验证 
    verifyVersion(nodeReg.getVersion());
    //调用namesystem的注册节点方法
    namesystem.registerDatanode(nodeReg);
      
    return nodeReg;
  }名字节点调用的又是命名系统的方法，对注册节点的判断分为以下3种情况1、现有的节点进行新的存储ID注册2、现有节点的重复注册，由于集群已经保存有此信息，进行网络位置的更新即可3、从未注册过的节点，直接进行分配新的存储ID进行注册。具体方法判断如下，方法比较长/**
   * Register Datanode.
   * <p>
   * The purpose of registration is to identify whether the new datanode
   * serves a new data storage, and will report new data block copies,
   * which the namenode was not aware of; or the datanode is a replacement
   * node for the data storage that was previously served by a different
   * or the same (in terms of host:port) datanode.
   * The data storages are distinguished by their storageIDs. When a new
   * data storage is reported the namenode issues a new unique storageID.
   * <p>
   * Finally, the namenode returns its namespaceID as the registrationID
   * for the datanodes. 
   * namespaceID is a persistent attribute of the name space.
   * The registrationID is checked every time the datanode is communicating
   * with the namenode. 
   * Datanodes with inappropriate registrationID are rejected.
   * If the namenode stops, and then restarts it can restore its 
   * namespaceID and will continue serving the datanodes that has previously
   * registered with the namenode without restarting the whole cluster.
   * 
   * @see org.apache.hadoop.hdfs.server.datanode.DataNode#register()
   * 名字节点实现数据节点的注册操作
   */
  public synchronized void registerDatanode(DatanodeRegistration nodeReg
                                            ) throws IOException {
    String dnAddress = Server.getRemoteAddress();
    if (dnAddress == null) {
      // Mostly called inside an RPC.
      // But if not, use address passed by the data-node.
      dnAddress = nodeReg.getHost();
    }      

    // check if the datanode is allowed to be connect to the namenode
    if (!verifyNodeRegistration(nodeReg, dnAddress)) {
      throw new DisallowedDatanodeException(nodeReg);
    }

    String hostName = nodeReg.getHost();
      
    // update the datanode's name with ip:port
    DatanodeID dnReg = new DatanodeID(dnAddress + ":" + nodeReg.getPort(),
                                      nodeReg.getStorageID(),
                                      nodeReg.getInfoPort(),
                                      nodeReg.getIpcPort());
    nodeReg.updateRegInfo(dnReg);
    nodeReg.exportedKeys = getBlockKeys();
      
    NameNode.stateChangeLog.info(
                                 "BLOCK* NameSystem.registerDatanode: "
                                 + "node registration from " + nodeReg.getName()
                                 + " storage " + nodeReg.getStorageID());

    //取出主机相关信息
    DatanodeDescriptor nodeS = datanodeMap.get(nodeReg.getStorageID());
    DatanodeDescriptor nodeN = host2DataNodeMap.getDatanodeByName(nodeReg.getName());
    
    //判断此节点之前是否已经存在
    if (nodeN != null && nodeN != nodeS) {
     //此情况为数据节点存在,但是使用了新的存储ID
      NameNode.LOG.info("BLOCK* NameSystem.registerDatanode: "
                        + "node from name: " + nodeN.getName());
      // nodeN previously served a different data storage, 
      // which is not served by anybody anymore.
      //移动掉旧的datanodeID信息
      removeDatanode(nodeN);
      // physically remove node from datanodeMap
      //从物理层面的记录进行移除
      wipeDatanode(nodeN);
      nodeN = null;
    }
    
    //重复注册的情况
    if (nodeS != null) {
      if (nodeN == nodeS) {
        // The same datanode has been just restarted to serve the same data 
        // storage. We do not need to remove old data blocks, the delta will
        // be calculated on the next block report from the datanode
        NameNode.stateChangeLog.debug("BLOCK* NameSystem.registerDatanode: "
                                      + "node restarted.");
      } else {
        // nodeS is found
        /* The registering datanode is a replacement node for the existing 
          data storage, which from now on will be served by a new node.
          If this message repeats, both nodes might have same storageID 
          by (insanely rare) random chance. User needs to restart one of the
          nodes with its data cleared (or user can just remove the StorageID
          value in "VERSION" file under the data directory of the datanode,
          but this is might not work if VERSION file format has changed 
       */        
        NameNode.stateChangeLog.info( "BLOCK* NameSystem.registerDatanode: "
                                      + "node " + nodeS.getName()
                                      + " is replaced by " + nodeReg.getName() + 
                                      " with the same storageID " +
                                      nodeReg.getStorageID());
      }
      // update cluster map
      //更新集群的网络信息
      clusterMap.remove(nodeS);
      nodeS.updateRegInfo(nodeReg);
      nodeS.setHostName(hostName);
      
      // resolve network location
      resolveNetworkLocation(nodeS);
      clusterMap.add(nodeS);
        
      // also treat the registration message as a heartbeat
      synchronized(heartbeats) {
        if( !heartbeats.contains(nodeS)) {
          heartbeats.add(nodeS);
          //update its timestamp
          nodeS.updateHeartbeat(0L, 0L, 0L, 0);
          nodeS.isAlive = true;
        }
      }
      return;
    } 

    // this is a new datanode serving a new data storage
    //当此时确认为一个新的节点时,为新节点分配存储ID
    if (nodeReg.getStorageID().equals("")) {
      // this data storage has never been registered
      // it is either empty or was created by pre-storageID version of DFS
      nodeReg.storageID = newStorageID();
      NameNode.stateChangeLog.debug(
                                    "BLOCK* NameSystem.registerDatanode: "
                                    + "new storageID " + nodeReg.getStorageID() + " assigned.");
    }
    // register new datanode
    //创建新的节点
    DatanodeDescriptor nodeDescr 
      = new DatanodeDescriptor(nodeReg, NetworkTopology.DEFAULT_RACK, hostName);
    resolveNetworkLocation(nodeDescr);
    unprotectedAddDatanode(nodeDescr);
    clusterMap.add(nodeDescr);
      
    // also treat the registration message as a heartbeat
    //将注册信息加入到心跳
    synchronized(heartbeats) {
      heartbeats.add(nodeDescr);
      nodeDescr.isAlive = true;
      // no need to update its timestamp
      // because its is done when the descriptor is created
    }
    return;
  }移除原有信息的代码如下，还做了更新操作/**
   * remove a datanode descriptor
   * @param nodeInfo datanode descriptor
   */
  private void removeDatanode(DatanodeDescriptor nodeInfo) {
    synchronized (heartbeats) {
      if (nodeInfo.isAlive) {
      	//更新集群中的统计信息
        updateStats(nodeInfo, false);
        //从心跳列表信息中移除对于此节点的心跳信息
        heartbeats.remove(nodeInfo);
        nodeInfo.isAlive = false;
      }
    }

    //移除第二关系中数据块对于此节点的映射关系
    for (Iterator<Block> it = nodeInfo.getBlockIterator(); it.hasNext();) {
      removeStoredBlock(it.next(), nodeInfo);
    }
    unprotectedRemoveDatanode(nodeInfo);
    //从集群图中移除此节点信息
    clusterMap.remove(nodeInfo);
  }心跳机制心跳机制最简单的由来就是为了证明数据节点还活着，如果一段时间内datanode没有向namenode发送心跳包信息，就会被dead状态。并且datanode从心跳包回复中获取命令信息，然后进行下一步操作，所以从这里可以看出，心跳机制在整个HDFS系统中都有很重要的作用。下面一步步揭开HDFS心跳机制的实现。首先心跳信息是由数据节点发起的，主动方在Datanode上，就是下面这个方法/**
   * Main loop for the DataNode.  Runs until shutdown,
   * forever calling remote NameNode functions.
   * datanode在循环中不断向名字节点发送心跳信息 
   */
  public void offerService() throws Exception {
     
    LOG.info("using BLOCKREPORT_INTERVAL of " + blockReportInterval + "msec" + 
       " Initial delay: " + initialBlockReportDelay + "msec");

    //
    // Now loop for a long time....
    //

    while (shouldRun) {
      try {
        long startTime = now();

        //
        // Every so often, send heartbeat or block-report
        //
        
        if (startTime - lastHeartbeat > heartBeatInterval) {
          //
          // All heartbeat messages include following info:
          // -- Datanode name
          // -- data transfer port
          // -- Total capacity
          // -- Bytes remaining
          //
         //向名字节点发送此时节点的一些信息，dfs使用量，剩余使用量信息等
          lastHeartbeat = startTime;
          //调用namenode.sendHeartbeat进行心跳信息的发送，返回数据节点的操作命令
          DatanodeCommand[] cmds = namenode.sendHeartbeat(dnRegistration,
                                                       data.getCapacity(),
                                                       data.getDfsUsed(),
                                                       data.getRemaining(),
                                                       xmitsInProgress.get(),
                                                       getXceiverCount());
          myMetrics.addHeartBeat(now() - startTime);
          //LOG.info("Just sent heartbeat, with name " + localName);
          //进行返回命令的处理，如果没有成功不进行后续block块上报工作
          if (!processCommand(cmds))
            continue;
        }首先先观察前部分代码，可以看到，这是一个循环，而且是周期性的发送消息，然后调用namenode的方法进行心跳信息发送，然后接收DatanodeCommand回复命令，然后再本节点执行。然后，跟踪一下里面namenode的方法/**
   * Data node notify the name node that it is alive 
   * Return an array of block-oriented commands for the datanode to execute.
   * This will be either a transfer or a delete operation.
   * 数据节点调用此方法进行心跳信息的发送
   */
  public DatanodeCommand[] sendHeartbeat(DatanodeRegistration nodeReg,
                                       long capacity,
                                       long dfsUsed,
                                       long remaining,
                                       int xmitsInProgress,
                                       int xceiverCount) throws IOException {
    //对节点注册信息的确认
    verifyRequest(nodeReg);
    //然后再次调用fsnamesystem的handleHeartbeat方法
    return namesystem.handleHeartbeat(nodeReg, capacity, dfsUsed, remaining,
        xceiverCount, xmitsInProgress);
  }namenode调用的又是命名系统的方法/**
   * The given node has reported in.  This method should:
   * 1) Record the heartbeat, so the datanode isn't timed out
   * 2) Adjust usage stats for future block allocation
   * 
   * If a substantial amount of time passed since the last datanode 
   * heartbeat then request an immediate block report.  
   * 
   * @return an array of datanode commands 
   * @throws IOException
   * 一个给定的数据节点进行心跳信息的上报，主要做2个操作
   * 1.心跳信息的记录，避免数据节点超时
   * 2.调整新的名字节点中维护的数据块分配情况
   */
  DatanodeCommand[] handleHeartbeat(DatanodeRegistration nodeReg,
      long capacity, long dfsUsed, long remaining,
      int xceiverCount, int xmitsInProgress) throws IOException {
    DatanodeCommand cmd = null;
    synchronized (heartbeats) {
      synchronized (datanodeMap) {
        DatanodeDescriptor nodeinfo = null;
        try {
          nodeinfo = getDatanode(nodeReg);
        } catch(UnregisteredDatanodeException e) {
          return new DatanodeCommand[]{DatanodeCommand.REGISTER};
        }
          
        // Check if this datanode should actually be shutdown instead. 
        if (nodeinfo != null && shouldNodeShutdown(nodeinfo)) {
          setDatanodeDead(nodeinfo);
          throw new DisallowedDatanodeException(nodeinfo);
        }

        //如果不存在此节点信息，说明此节点还未注册，返回节点注册命令
        if (nodeinfo == null || !nodeinfo.isAlive) {
          return new DatanodeCommand[]{DatanodeCommand.REGISTER};
        }

        updateStats(nodeinfo, false);
        nodeinfo.updateHeartbeat(capacity, dfsUsed, remaining, xceiverCount);
        updateStats(nodeinfo, true);看前半段的代码分析，主要是做相应节点的信息更新，如果节点是未注册过的野节点的话，返回注册命令，但是还有下半段的操作，/**
   * The given node has reported in.  This method should:
   * 1) Record the heartbeat, so the datanode isn't timed out
   * 2) Adjust usage stats for future block allocation
   * 
   * If a substantial amount of time passed since the last datanode 
   * heartbeat then request an immediate block report.  
   * 
   * @return an array of datanode commands 
   * @throws IOException
   * 一个给定的数据节点进行心跳信息的上报，主要做2个操作
   * 1.心跳信息的记录，避免数据节点超时
   * 2.调整新的名字节点中维护的数据块分配情况
   */
  DatanodeCommand[] handleHeartbeat(DatanodeRegistration nodeReg,
      long capacity, long dfsUsed, long remaining,
      int xceiverCount, int xmitsInProgress) throws IOException {
   ........... 
        //check lease recovery
        //检查租约过期情况
        cmd = nodeinfo.getLeaseRecoveryCommand(Integer.MAX_VALUE);
        if (cmd != null) {
          return new DatanodeCommand[] {cmd};
        }
        
        //新建命令集合，心跳回复将返回许多的命令
        ArrayList<DatanodeCommand> cmds = new ArrayList<DatanodeCommand>();
        //check pending replication
        //获取待复制的副本块命令，命令中包含有副本块列表内容
        cmd = nodeinfo.getReplicationCommand(
              maxReplicationStreams - xmitsInProgress);
        if (cmd != null) {
          cmds.add(cmd);
        }
        //check block invalidation
        //块删除命令
        cmd = nodeinfo.getInvalidateBlocks(blockInvalidateLimit);
        if (cmd != null) {
          cmds.add(cmd);
        }
        // check access key update
        if (isAccessTokenEnabled && nodeinfo.needKeyUpdate) {
          cmds.add(new KeyUpdateCommand(accessTokenHandler.exportKeys()));
          nodeinfo.needKeyUpdate = false;
        }
        // check for balancer bandwidth update
        if (nodeinfo.getBalancerBandwidth() > 0) {
          cmds.add(new BalancerBandwidthCommand(nodeinfo.getBalancerBandwidth()));
          // set back to 0 to indicate that datanode has been sent the new value
          nodeinfo.setBalancerBandwidth(0);
        }
        if (!cmds.isEmpty()) {
          //返回命令组
          return cmds.toArray(new DatanodeCommand[cmds.size()]);
        }
      }
    }就是命名系统类会检查节点block情况，进行命令回复，比如添加需要复制的block请求，无效快的删除请求等等。下面是一个示例//与block命令相关的函数
  BlockCommand getReplicationCommand(int maxTransfers) {
  	//获取待复制的副本block块列表
    List<BlockTargetPair> blocktargetlist = replicateBlocks.poll(maxTransfers);
    //将变量保证在BlockCommand中进行返回
    return blocktargetlist == null? null:
        new BlockCommand(DatanodeProtocol.DNA_TRANSFER, blocktargetlist);
  }因为BlockCommand是DataCommand的子集，也是属于DatanodeCommand。在这里有必要了解一下，datanode执行命令的形式，首先是父类，比较简单一些//DatanodeCommand继承自Writable序列化类，说明命令是被序列化传输的
public abstract class DatanodeCommand implements Writable {
  static class Register extends DatanodeCommand {
    private Register() {super(DatanodeProtocol.DNA_REGISTER);}
    public void readFields(DataInput in) {}
    public void write(DataOutput out) {}
  }

  static class Finalize extends DatanodeCommand {
    private Finalize() {super(DatanodeProtocol.DNA_FINALIZE);}
    public void readFields(DataInput in) {}
    public void write(DataOutput out) {}
  }
  .....
  //action保存了命令操作类型
  private int action;
  
  .....
  
  ///////////////////////////////////////////
  // Writable
  ///////////////////////////////////////////
  //DatanodeCommand将命令操作写在序列化流中
  public void write(DataOutput out) throws IOException {
    out.writeInt(this.action);
  }
  
  public void readFields(DataInput in) throws IOException {
    this.action = in.readInt();
  }
}这里的action很重要，保存的就是命令的类型，同时，注意这些都是可序列化的，用于RPC传输。那么与Block相关的命令在上面做了哪些的改变才使得能把block块列表的信息也传入命令中呢，答案就在下面/****************************************************
 * A BlockCommand is an instruction to a datanode 
 * regarding some blocks under its control.  It tells
 * the DataNode to either invalidate a set of indicated
 * blocks, or to copy a set of indicated blocks to 
 * another DataNode.
 * 
 ****************************************************/
public class BlockCommand extends DatanodeCommand {
  Block blocks[];
  DatanodeInfo targets[][];

  public BlockCommand() {}

  /**
   * Create BlockCommand for transferring blocks to another datanode
   * @param blocktargetlist    blocks to be transferred 
   */
  public BlockCommand(int action, List<BlockTargetPair> blocktargetlist) {
    super(action);

    blocks = new Block[blocktargetlist.size()]; 
    targets = new DatanodeInfo[blocks.length][];
    for(int i = 0; i < blocks.length; i++) {
      BlockTargetPair p = blocktargetlist.get(i);
      blocks[i] = p.block;
      targets[i] = p.targets;
    }
  }

  private static final DatanodeInfo[][] EMPTY_TARGET = {};

  /**
   * Create BlockCommand for the given action
   * @param blocks blocks related to the action
   */
  public BlockCommand(int action, Block blocks[]) {
    super(action);
    this.blocks = blocks;
    this.targets = EMPTY_TARGET;
  }
  ......
  
  //重载序列化写入方法
  public void write(DataOutput out) throws IOException {
    super.write(out);
    out.writeInt(blocks.length);
    //将block块依次序列化写入
    for (int i = 0; i < blocks.length; i++) {
      blocks[i].write(out);
    }
    out.writeInt(targets.length);
    for (int i = 0; i < targets.length; i++) {
      out.writeInt(targets[i].length);
      for (int j = 0; j < targets[i].length; j++) {
        targets[i][j].write(out);
      }
    }
  }
OK，心跳回复命令已经清楚，看看数据节点如何执行命名节点返回的心跳命令然后做出调整。/**
   * Process an array of datanode commands
   * 
   * @param cmds an array of datanode commands
   * @return true if further processing may be required or false otherwise. 
   * 数据节点批量执行操作
   */
  private boolean processCommand(DatanodeCommand[] cmds) {
    if (cmds != null) {
      for (DatanodeCommand cmd : cmds) {
        try {
        	//在命令组中，只要有一条命令执行出错，整个执行过程就算失败
          if (processCommand(cmd) == false) {
            return false;
          }
        } catch (IOException ioe) {
          LOG.warn("Error processing datanode Command", ioe);
        }
      }
    }
    return true;
  }然后是单条命令执行，这才是我们想看到的/**
     * 
     * @param cmd
     * @return true if further processing may be required or false otherwise. 
     * @throws IOException
     * 调用单条命令处理方法
     */
  private boolean processCommand(DatanodeCommand cmd) throws IOException {
    if (cmd == null)
      return true;
    final BlockCommand bcmd = cmd instanceof BlockCommand? (BlockCommand)cmd: null;
    
    //取出命令的action值类型，进行分别判断处理
    switch(cmd.getAction()) {
    case DatanodeProtocol.DNA_TRANSFER:
      // Send a copy of a block to another datanode
      ....
      break;
    case DatanodeProtocol.DNA_INVALIDATE:
      //如果是无效块，则进行blockScanner类扫描删除操作
      //
      // Some local block(s) are obsolete and can be 
      // safely garbage-collected.
      //
      Block toDelete[] = bcmd.getBlocks();
      try {
        if (blockScanner != null) {
          blockScanner.deleteBlocks(toDelete);
        }
        data.invalidate(toDelete);
      } catch(IOException e) {
        checkDiskError();
        throw e;
      }
      myMetrics.incrBlocksRemoved(toDelete.length);
      break;
    case DatanodeProtocol.DNA_SHUTDOWN:
      ....
    case DatanodeProtocol.DNA_REGISTER:
      //如果是注册命令，则调用注册操作
      .....
      break;
    case DatanodeProtocol.DNA_FINALIZE:
      storage.finalizeUpgrade();
      break;
    case UpgradeCommand.UC_ACTION_START_UPGRADE:
      // start distributed upgrade here
      processDistributedUpgradeCommand((UpgradeCommand)cmd);
      break;
    case DatanodeProtocol.DNA_RECOVERBLOCK:
      recoverBlocks(bcmd.getBlocks(), bcmd.getTargets());
      break;
    case DatanodeProtocol.DNA_ACCESSKEYUPDATE:
      LOG.info("DatanodeCommand action: DNA_ACCESSKEYUPDATE");
      if (isBlockTokenEnabled) {
        blockTokenSecretManager.setKeys(((KeyUpdateCommand) cmd).getExportedKeys());
      }
      break;
    case DatanodeProtocol.DNA_BALANCERBANDWIDTHUPDATE:
      .....
    default:
      LOG.warn("Unknown DatanodeCommand action: " + cmd.getAction());
    }
    return true;
  }对每种命令，取出action值类别，进行分别处理。OK，到这里就处理完了前半部分代码所做的事情了，在后面会进行数据块上报的工作，准确的说，这方面的操作就不算是心跳机制里面的过程了，但是都是在一个大循环中进行的。//检测新接收到的block
        // check if there are newly received blocks
        Block [] blockArray=null;
        String [] delHintArray=null;
        synchronized(receivedBlockList) {
          synchronized(delHints) {
            int numBlocks = receivedBlockList.size();
            if (numBlocks > 0) {
              if(numBlocks!=delHints.size()) {
                LOG.warn("Panic: receiveBlockList and delHints are not of the same length" );
              }
              //
              // Send newly-received blockids to namenode
              //
              blockArray = receivedBlockList.toArray(new Block[numBlocks]);
              delHintArray = delHints.toArray(new String[numBlocks]);
            }
          }
        }
        if (blockArray != null) {
          if(delHintArray == null || delHintArray.length != blockArray.length ) {
            LOG.warn("Panic: block array & delHintArray are not the same" );
          }
          //将接收到的新block信息上报
          namenode.blockReceived(dnRegistration, blockArray, delHintArray);
          synchronized (receivedBlockList) {
            synchronized (delHints) {
              for(int i=0; i<blockArray.length; i++) {
                receivedBlockList.remove(blockArray[i]);
                delHints.remove(delHintArray[i]);
              }
            }
          }
        }数据节点进行心跳信息上传，名字节点如何判断节点是否长期没有上报心跳呢，在这之间必然会有监控线程，在命名系统类中，相关的变量/**
   * Stores a set of DatanodeDescriptor objects.
   * This is a subset of {@link #datanodeMap}, containing nodes that are 
   * considered alive.
   * The {@link HeartbeatMonitor} periodically checks for outdated entries,
   * and removes them from the list.
   * 是datanodeMap的子集，保存了节点中存活的节点集合，在HeartbeatMonitor中会被使用
   */
  ArrayList<DatanodeDescriptor> heartbeats = new ArrayList<DatanodeDescriptor>();此变量就代表着现有存活的节点列表/**
   * Periodically calls heartbeatCheck() and updateAccessKey()
   * 心跳监控线程
   */
  class HeartbeatMonitor implements Runnable {
  	//上次心跳的检测时间
    private long lastHeartbeatCheck;
    private long lastAccessKeyUpdate;
    /**
     */
    public void run() {
      while (fsRunning) {
        try {
          long now = now();
          if (lastHeartbeatCheck + heartbeatRecheckInterval < now) {
          	//如果在间隔时间内，做心跳检测
            heartbeatCheck();
            lastHeartbeatCheck = now;
          }
          if (isAccessTokenEnabled && (lastAccessKeyUpdate + accessKeyUpdateInterval < now)) {
            updateAccessKey();
            lastAccessKeyUpdate = now;
          }
        } catch (Exception e) {
          FSNamesystem.LOG.err上面是监控线程的执行方法，在做心跳检测的方法时，作者采用了一种很有远见的想法，采用了故障寻找，故障分离的办法，原因是考虑到分布式系统的负载情况，以及对于系统整体性能的影响，下面是故障寻找/**
   * Check if there are any expired heartbeats, and if so,
   * whether any blocks have to be re-replicated.
   * While removing dead datanodes, make sure that only one datanode is marked
   * dead at a time within the synchronized section. Otherwise, a cascading
   * effect causes more datanodes to be declared dead.
   * 检测是否有任何过期的心跳，移除dead状态的节点
   */
  void heartbeatCheck() {
  	//安全模式下不做任何的检查
    if (isInSafeMode()) {
      // not to check dead nodes if in safemode
      return;
    }
    boolean allAlive = false;
    while (!allAlive) {
      boolean foundDead = false;
      DatanodeID nodeID = null;

      // locate the first dead node.
      //定位寻找第一个dead故障状态的节点
      synchronized(heartbeats) {
        for (Iterator<DatanodeDescriptor> it = heartbeats.iterator();
             it.hasNext();) {
          DatanodeDescriptor nodeInfo = it.next();
          if (isDatanodeDead(nodeInfo)) {
          	//一旦找到，并取出对应消息并跳出循环
            foundDead = true;
            nodeID = nodeInfo;
            break;
          }
        }
      }
然后是处理，但是处理之前还需要在判断一次是否是故障节点，分布式的环境嘛，各种因素影响。// acquire the fsnamesystem lock, and then remove the dead node.
      if (foundDead) {
      	//为了确保同步性，进行加锁操作，进行dead故障状态节点的处理操作
        synchronized (this) {
          synchronized(heartbeats) {
            synchronized (datanodeMap) {
              DatanodeDescriptor nodeInfo = null;
              try {
                nodeInfo = getDatanode(nodeID);
              } catch (IOException e) {
                nodeInfo = null;
              }
              if (nodeInfo != null && isDatanodeDead(nodeInfo)) {
                NameNode.stateChangeLog.info("BLOCK* NameSystem.heartbeatCheck: "
                                             + "lost heartbeat from " + nodeInfo.getName());
                //移除此节点的信息，此方法会调用headtbeat的移除nodeinfo操作
                removeDatanode(nodeInfo);
              }
            }
          }
        }
      }
      //重置标志位
      allAlive = !foundDead;
    }心跳故障处理检测完毕，这种故障处理检测的思想或许对于我们日后自己动手设计大型分布式系统可能会有所启发。全部代码的分析请点击链接https://github.com/linyiqun/hadoop-hdfs,后续将会继续更新HDFS其他方面的代码分析。参考文献《Hadoop技术内部–HDFS结构设计与实现原理》.蔡斌等

版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式： 自己手动写一个工厂模式（整合工厂方法模式和抽象工厂模式）
 工厂模式： 所有工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象的创建过程封装的目的。
工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

抽象工厂模式提供一个接口，用来创建相关或依赖对象的家族，而不需要明确指定具体类。

工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。
抽象工厂使用对象组合： 对象的创建被实现在工厂接口所暴露出来的方法中。抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。


下面是工厂方法的类图




下面是工程的结构图


AbstractFactorys包下的类主要体现抽象工厂模式的运用

factoryMethods 包下的类主要体现工厂方法模式的运用



源代码如下：
先给出 factoryMethods 下的代码
package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

/**
 * 披萨商店抽象类 超类
 * @author Arvon
 *
 */
public abstract class PizzaStore {
	PizzaIngredientFactory ingredientFactory;
	public void orderPizza(String type,PizzaIngredientFactory ingredientFactory){
		Pizza pizza;
		pizza = createPizza(type,ingredientFactory);
		pizza.prepare();
		pizza.bake();
		pizza.cut();
		pizza.box();
	}
	/**
	 * 生产披萨  工厂方法 由子类来实现
	 * @param type
	 * @return
	 */
	public abstract Pizza createPizza(String type,PizzaIngredientFactory ingredientFactory);
	
	
}


package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

/**
 * 芝加哥披萨商店 负责生产披萨
 * @author Administrator
 *
 */
public class ChicagoPizzaStore extends PizzaStore {
	
	@Override
	public Pizza createPizza(String type,PizzaIngredientFactory ingredientFactory) {
		if(type.equals(Constant.CHEESE))
			return new ChicagoStyleCheesePizza(ingredientFactory);
		else if(type.equals(Constant.VEGGIE))
			return new ChicagoStyleVeggiePizza(ingredientFactory);
		else return null;
	}

}




package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

/**
 * 纽约披萨商店 负责生产披萨
 * @author Administrator
 *
 */
public class NYPizzaStroe extends PizzaStore {

	@Override
	public Pizza createPizza(String type, PizzaIngredientFactory ingredientFactory) {
		if(type.equals(Constant.CHEESE))
			return new NYStyleCheesePizza(ingredientFactory);
		else if(type.equals(Constant.VEGGIE))
			return new NYStyleVeggiePizza();
		else return null;
	}
}


package factoryMethods;

import AbstractFactorys.Cheese;
import AbstractFactorys.Veggie;

/**
 * 产品类 超类
 * @author Administrator
 *
 */
public abstract class Pizza {
	String name;
	Veggie veggie;
	Cheese cheese;
	
	
	public abstract void prepare();

	public void bake() {
		System.out.println("Bake for 25 minutes at 350");
		
	}

	public void cut() {
		System.out.println("Cutting the pizza into diagonal slices");
	}

	public void box() {
		System.out.println("Place pizza in official PizzaStore box");
	}

	public void setName(String name) {
		this.name = name;
	}
	
	

}


package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

public class ChicagoStyleCheesePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
	public ChicagoStyleCheesePizza(PizzaIngredientFactory ingredientFactory) {
		super();
		// TODO Auto-generated constructor stub
		name = "ChicagoStyleCheesePizza";
		this.ingredientFactory = ingredientFactory;
	}

	@Override
	public void prepare() {
		
	}
	
}

package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

public class ChicagoStyleVeggiePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
	public ChicagoStyleVeggiePizza(PizzaIngredientFactory ingredientFactory) {
		super();
		// TODO Auto-generated constructor stub
		name = "ChicagoStyleVeggiePizza";
		this.ingredientFactory = ingredientFactory;
	}

	@Override
	public void prepare() {
		// TODO Auto-generated method stub
		cheese = ingredientFactory.createCheese();
		veggie = ingredientFactory.createVeggie();
		System.out.println("Preparing " + name);
		System.out.println(cheese.getName());
		System.out.println(veggie.getName());
	}
	
}


package factoryMethods;

import AbstractFactorys.PizzaIngredientFactory;

public class NYStyleCheesePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
	public NYStyleCheesePizza(PizzaIngredientFactory ingredientFactory) {
		super();
		name = "NYStyleCheesePizza";
		this.ingredientFactory = ingredientFactory;
	}

	@Override
	public void prepare() {
		cheese = ingredientFactory.createCheese();
		veggie = ingredientFactory.createVeggie();
		System.out.println("Preparing " + name);
		System.out.println(cheese.getName());
		System.out.println(veggie.getName());
	}
	
}


package factoryMethods;

public class NYStyleVeggiePizza extends Pizza {

	public NYStyleVeggiePizza() {
		super();
		// TODO Auto-generated constructor stub
		name = "NYStyleVeggiePizza";
	}

	@Override
	public void prepare() {
		// TODO Auto-generated method stub
		
	}

}

package factoryMethods;

public interface Constant {
	public static final String CHEESE = "cheese";
	public static final String VEGGIE = "veggie";
}


接下来是AbstractFactorys包里的类
package AbstractFactorys;
/**
 * 原料生产工厂 抽象工厂
 * @author Administrator
 *
 */
public interface PizzaIngredientFactory {
	public Cheese createCheese();
	public Veggie createVeggie();
	
}


package AbstractFactorys;
/**
 * 原料生产工厂 具体工厂
 * @author Administrator
 *
 */
public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory {

	@Override
	public Cheese createCheese() {
		return new Cheese(this);
	}

	@Override
	public Veggie createVeggie() {
		return new Veggie(this);
	}

}


package AbstractFactorys;
/**
 * 原料生产工厂 具体工厂
 * @author Administrator
 *
 */
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {

	@Override
	public Cheese createCheese() {
		// TODO Auto-generated method stub
		return new Cheese(this);
	}

	@Override
	public Veggie createVeggie() {
		// TODO Auto-generated method stub
		return new Veggie(this);
	}

}


package AbstractFactorys;
/**
 * 原料类 超类
 * @author Administrator
 *
 */
public class Ingredient {
	String name;

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}
	
	
}

package AbstractFactorys;
/**
 * 具体的原料
 * @author Administrator
 *
 */
public class Cheese extends Ingredient {

	public Cheese(PizzaIngredientFactory ingredientFactory) {
		name = "cheese from "+ ingredientFactory.getClass().getSimpleName();
		setName(name);
	}
	
}


package AbstractFactorys;
/**
 * 具体的原料
 * @author Administrator
 *
 */
public class Veggie extends Ingredient {

	public Veggie(PizzaIngredientFactory ingredientFactory) {
		name = "veggie from "+ ingredientFactory.getClass().getSimpleName();
	}

}


测试类
package factoryMethods;

import AbstractFactorys.ChicagoPizzaIngredientFactory;
import AbstractFactorys.NYPizzaIngredientFactory;
import AbstractFactorys.PizzaIngredientFactory;

/**
 * 测试类
 * @author Administrator
 *
 */
public class Test {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		PizzaStore mPizzaStore = new NYPizzaStroe();
		PizzaIngredientFactory ingredientFactory = new NYPizzaIngredientFactory();
		mPizzaStore.orderPizza("cheese", ingredientFactory);
		System.out.println("-----------------------------------");
		ingredientFactory = new ChicagoPizzaIngredientFactory();
		mPizzaStore = new ChicagoPizzaStore();
		mPizzaStore.orderPizza("veggie", ingredientFactory);
		
	}
	

}

测试结果：
Preparing NYStyleCheesePizza
cheese from NYPizzaIngredientFactory
veggie from NYPizzaIngredientFactory
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in official PizzaStore box
-----------------------------------
Preparing ChicagoStyleVeggiePizza
cheese from ChicagoPizzaIngredientFactory
veggie from ChicagoPizzaIngredientFactory
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in official PizzaStore box





版权声明：本文为博主原创文章，未经博主允许不得转载。

HDFS源码分析(六)-----租约
前言在文章开始，先讲个大家都经历过的事--去图书馆借书，当然，喜欢阅读的朋友也许和我一样比较喜欢借书阅读，借书阅读方便是方便，但是唯一不好的地方在于他又期限，就是deadlline，之前在我们学校有规定，如果超期为归还的书不允许借阅另外的书籍，所以要想使自己能接到新的书，就必须先归怀超期的书籍。当然这个经历本身再寻常不过了，但是我想表达的是在HDFS分布式文件系统中的租约机制与此过程有着极强的吻合性，后面的归还书籍相当于租约恢复的操作，下面详细介绍一下什么是租约。租约以及租约相关类租约可简单理解为在短期时间内对于租约持有者也就是客户端一定的权限，例如写文件的凭证。在每次HDFS中进行块的添加，删除操作时候，都会进行租约的核查和更新，以此维护各个文件操作情况。一下列出租约的相关类：1.LeaseManager--租约管理类，可以理解为是一个租约大管家，里面维护了多种映射关系的租约集合列表。2.LeaseManager.Lease--租约实体类，就是租约具体的表现形式类。在下面会详细介绍，此类中的变量和方法。3.FSNamesystem--名字系统类，因为在这个大杂烩的大类中会用到租约相关的方法，也就加入进来。Lease首先从小类开始分析，也就是租约类Lease,他是一个内部类，存在于LeaseManager中。对于租约，首先有明白这样一个概念，租约是凭证，对客户端写操作文件的一种凭证，首先肯定得包含租约持有者变量，其次有租约记录的操作文件列表，当然租约还需要有时间，来记录租约超时的情况，所以类的变量结构如下/************************************************************
   * A Lease governs all the locks held by a single client.
   * For each client there's a corresponding lease, whose
   * timestamp is updated when the client periodically
   * checks in.  If the client dies and allows its lease to
   * expire, all the corresponding locks can be released.
   *************************************************************/
   //每条租约记录信息，只能被单一的客户端占有
  class Lease implements Comparable<Lease> {
    //租约信息客户持有者
    private final String holder;
    //租约最后更新时间
    private long lastUpdate;
    //此租约内所打开的文件，维护一个客户端打开的所有文件
    private final Collection<String> paths = new TreeSet<String>();
  
    /** Only LeaseManager object can create a lease */
    private Lease(String holder) {
      this.holder = holder;
      renew();
    }
.....在这里，Lease类将客户端打开的所有文件维护在了paths类中，然后通过租约持有者的名字进行初始构造函数的构造。然后注意这里有一个renew()方法，他是做租约时间更新的/** Only LeaseManager object can renew a lease */
    //根据租约最后的检测时间
    private void renew() {
      this.lastUpdate = FSNamesystem.now();
    }OK，租约类暂时先了解到这里，跳到下一个租约管理者类LeaseManager.LeaseManager身为一个管理者，内部变量肯定会稍稍多一些/**
 * LeaseManager does the lease housekeeping for writing on files.   
 * This class also provides useful static methods for lease recovery.
 * 
 * Lease Recovery Algorithm
 * 1) Namenode retrieves lease information
 * 2) For each file f in the lease, consider the last block b of f
 * 2.1) Get the datanodes which contains b
 * 2.2) Assign one of the datanodes as the primary datanode p

 * 2.3) p obtains a new generation stamp form the namenode
 * 2.4) p get the block info from each datanode
 * 2.5) p computes the minimum block length
 * 2.6) p updates the datanodes, which have a valid generation stamp,
 *      with the new generation stamp and the minimum block length 
 * 2.7) p acknowledges the namenode the update results

 * 2.8) Namenode updates the BlockInfo
 * 2.9) Namenode removes f from the lease
 *      and removes the lease once all files have been removed
 * 2.10) Namenode commit changes to edit log
 * 租约管理器,包含了与文件租约相关的许多方法
 */
public class LeaseManager {
  public static final Log LOG = LogFactory.getLog(LeaseManager.class);

  private final FSNamesystem fsnamesystem;
  
  //租约软超时时间
  private long softLimit = FSConstants.LEASE_SOFTLIMIT_PERIOD;
  //租约硬超时时间
  private long hardLimit = FSConstants.LEASE_HARDLIMIT_PERIOD;

  //
  // Used for handling lock-leases
  // Mapping: leaseHolder -> Lease
  //租约持有者到租约的映射图,保存在treeMap图中
  private SortedMap<String, Lease> leases = new TreeMap<String, Lease>();
  // Set of: Lease
  //全部租约图
  private SortedSet<Lease> sortedLeases = new TreeSet<Lease>();

  // 
  // Map path names to leases. It is protected by the sortedLeases lock.
  // The map stores pathnames in lexicographical order.
  //路径租约图映射关系
  private SortedMap<String, Lease> sortedLeasesByPath = new TreeMap<String, Lease>();
.....从上往下看，首先是2个超时时间，软超时时间和硬超时时间，这2个超时时间分别运用在了不同的租约场景检测环境中，在后面会做分析。其次，管理者类在这里维护了3种租约映射关系对1.租约持有者到所属租约2.所有租约集合类3.文件路径就是打开文件到租约的映射集合初步分析，作者这么设计的目的是为了方便快速的找出目标租约，以便进行后续操作。这里用到了SortedMap也是为了超找的快速。毕竟如此庞大的分布式系统，租约记录将会非常多，因为实时的操作文件数数目也一定是非常多的。OK，下面再回到类，看看几个与租约操作相关的几个典型方法/** @return the lease containing src */
  //根据路径获取租约
  public Lease getLeaseByPath(String src) {return sortedLeasesByPath.get(src);}从其中一个集合中直接获取，这个很好理解。下面是一个添加新的租约记录方法/**
   * Adds (or re-adds) the lease for the specified file.
   * 添加指定文件的租约信息
   */
  synchronized Lease addLease(String holder, String src) {
    //根据用户名获取其租约
    Lease lease = getLease(holder);
    if (lease == null) {
      //如果租约为空
      lease = new Lease(holder);
      //加入租约集合中
      leases.put(holder, lease);
      sortedLeases.add(lease);
    } else {
      //如果存在此用户的租约,则进行租约更新
      renewLease(lease);
    }
    //加入一条新的路径到租约的映射信息
    sortedLeasesByPath.put(src, lease);
    //在此租约路径映射信息中加入新路径
    lease.paths.add(src);
    return lease;
  }在加入新的租约记录时，要同时同步相应集合的数据。对应的租约移除方法/**
   * Remove the specified lease and src.
   * 移除值指定路径以及租约
   */
  synchronized void removeLease(Lease lease, String src) {
    //移动掉指定路径的映射信息
    sortedLeasesByPath.remove(src);
    //租约内部移除此路径
    if (!lease.removePath(src)) {
      LOG.error(src + " not found in lease.paths (=" + lease.paths + ")");
    }
    
    if (!lease.hasPath()) {
      //根据租约持有者移除指定租约
      leases.remove(lease.holder);
      if (!sortedLeases.remove(lease)) {
        LOG.error(lease + " not found in sortedLeases");
      }
    }
  }实际租约样例下面通过实际的操作文件方法，看看租约在这个过程中发挥的作用。比如在FSNamesystem的一个打开文件操作/**
   * Create a new file entry in the namespace.
   * 
   * @see ClientProtocol#create(String, FsPermission, String, boolean, short, long)
   * 
   * @throws IOException if file name is invalid
   *         {@link FSDirectory#isValidToCreate(String)}.
   * 命名系统打开一个新的文件
   */
  void startFile(String src, PermissionStatus permissions,
                 String holder, String clientMachine,
                 boolean overwrite, boolean createParent, short replication, long blockSize
                ) throws IOException {
    //调用startFileInternal方法
    startFileInternal(src, permissions, holder, clientMachine, overwrite, false,
                      createParent, replication, blockSize);
    getEditLog().logSync();
    if (auditLog.isInfoEnabled() && isExternalInvocation()) {
      final HdfsFileStatus stat = dir.getFileInfo(src);
      logAuditEvent(UserGroupInformation.getCurrentUser(),
                    Server.getRemoteIp(),
                    "create", src, null, stat);
    }
  }继续追踪private synchronized void startFileInternal(String src,
                                              PermissionStatus permissions,
                                              String holder, 
                                              String clientMachine, 
                                              boolean overwrite,
                                              boolean append,
                                              boolean createParent,
                                              short replication,
                                              long blockSize
                                              ) throws IOException {
    if (NameNode.stateChangeLog.isDebugEnabled()) {
      NameNode.stateChangeLog.debug("DIR* NameSystem.startFile: src=" + src
          + ", holder=" + holder
          + ", clientMachine=" + clientMachine
          + ", createParent=" + createParent
          + ", replication=" + replication
          + ", overwrite=" + overwrite
          + ", append=" + append);
    }

    if (isInSafeMode())
      throw new SafeModeException("Cannot create file" + src, safeMode);
    if (!DFSUtil.isValidName(src)) {
      throw new IOException("Invalid file name: " + src);
    }
.....

    if (!createParent) {
      verifyParentDir(src);
    }

    try {
      INode myFile = dir.getFileINode(src);
      //在这里进行租约的恢复操作
      recoverLeaseInternal(myFile, src, holder, clientMachine, false);
     ....因为重新操作了此文件，所以要进行租约的恢复操作//租约恢复操作
  private void recoverLeaseInternal(INode fileInode, 
      String src, String holder, String clientMachine, boolean force)
  throws IOException {
    if (fileInode != null && fileInode.isUnderConstruction()) {
      INodeFileUnderConstruction pendingFile = (INodeFileUnderConstruction) fileInode;
      //
      // If the file is under construction , then it must be in our
      // leases. Find the appropriate lease record.
      //
      //根据客户端名称,取出其租约
      Lease lease = leaseManager.getLease(holder);
      //
      // We found the lease for this file. And surprisingly the original
      // holder is trying to recreate this file. This should never occur.
      //
      if (!force && lease != null) {
        //如果租约记录中已经存在此文件路径,不允许重复创建记录操作
        Lease leaseFile = leaseManager.getLeaseByPath(src);
        if (leaseFile != null && leaseFile.equals(lease)) { 
          throw new AlreadyBeingCreatedException(
                    "failed to create file " + src + " for " + holder +
                    " on client " + clientMachine + 
                    " because current leaseholder is trying to recreate file.");
        }
      }
      //
      // Find the original holder.
      //取出客户端的租约记录
      lease = leaseManager.getLease(pendingFile.clientName);
      if (lease == null) {
        throw new AlreadyBeingCreatedException(
                    "failed to create file " + src + " for " + holder +
                    " on client " + clientMachine + 
                    " because pendingCreates is non-null but no leases found.");
      }
      if (force) {
        // close now: no need to wait for soft lease expiration and 
        // close only the file src
        LOG.info("recoverLease: recover lease " + lease + ", src=" + src +
                 " from client " + pendingFile.clientName);
        //如果设置了强制执行参数,直接进行租约恢复操作
        internalReleaseLeaseOne(lease, src);
      } else {
        //
        // If the original holder has not renewed in the last SOFTLIMIT 
        // period, then start lease recovery.
        //
        //如果没有设置,判断是否软超时,来进行租约恢复
        if (lease.expiredSoftLimit()) {
          LOG.info("startFile: recover lease " + lease + ", src=" + src +
              " from client " + pendingFile.clientName);
          internalReleaseLease(lease, src);
        }
        throw new AlreadyBeingCreatedException(
            "failed to create file " + src + " for " + holder +
            " on client " + clientMachine + 
            ", because this file is already being created by " +
            pendingFile.getClientName() + 
            " on " + pendingFile.getClientMachine());
      }
    }

  }这里就用到了软超时时间。继续调用恢复租约操作/**
   * This is invoked when a lease expires. On lease expiry, 
   * all the files that were written from that dfsclient should be
   * recovered.
   * 进行租约恢复操作
   */
  void internalReleaseLease(Lease lease, String src) throws IOException {
    if (lease.hasPath()) {
      // make a copy of the paths because internalReleaseLeaseOne removes
      // pathnames from the lease record.
      String[] leasePaths = new String[lease.getPaths().size()];
      lease.getPaths().toArray(leasePaths);
      for (String p: leasePaths) {
        internalReleaseLeaseOne(lease, p);
      }
    } else {
      internalReleaseLeaseOne(lease, src);
    }
  }根据租约维护的打开文件列表一条条的恢复/**
   * Move a file that is being written to be immutable.
   * @param src The filename
   * @param lease The lease for the client creating the file
   */
  void internalReleaseLeaseOne(Lease lease, String src) throws IOException {
    assert Thread.holdsLock(this);

    LOG.info("Recovering lease=" + lease + ", src=" + src);

    INodeFile iFile = dir.getFileINode(src);
    if (iFile == null) {
      final String message = "DIR* NameSystem.internalReleaseCreate: "
        + "attempt to release a create lock on "
        + src + " file does not exist.";
      NameNode.stateChangeLog.warn(message);
      throw new IOException(message);
    }
    if (!iFile.isUnderConstruction()) {
      final String message = "DIR* NameSystem.internalReleaseCreate: "
        + "attempt to release a create lock on "
        + src + " but file is already closed.";
      NameNode.stateChangeLog.warn(message);
      throw new IOException(message);
    }

    INodeFileUnderConstruction pendingFile = (INodeFileUnderConstruction) iFile;
    .....
    // start lease recovery of the last block for this file.
    pendingFile.assignPrimaryDatanode();
    //在末尾进行租约的重分配
    Lease reassignedLease = reassignLease(
      lease, src, HdfsConstants.NN_RECOVERY_LEASEHOLDER, pendingFile);
    leaseManager.renewLease(reassignedLease);
  }进行租约重分配，重分配操作很简单，就是先移除老租约，再添加新的租约，然后更新一下时间/**
   * Reassign lease for file src to the new holder.
   * 租约重分配方法,等价于先移除后添加的方法
   */
  synchronized Lease reassignLease(Lease lease, String src, String newHolder) {
    assert newHolder != null : "new lease holder is null";
    if (lease != null) {
      removeLease(lease, src);
    }
    return addLease(newHolder, src);
  }

synchronized void renewLease(Lease lease) {
    if (lease != null) {
      //首先进行列表租约移除
      sortedLeases.remove(lease);
      //更新时间
      lease.renew();
      //再进行添加
      sortedLeases.add(lease);
    }
  }当你要具体操作block块的时候，还会经历租约检测工作，比如下面abandon块操作的时候/**
   * The client would like to let go of the given block
   */
  public synchronized boolean abandonBlock(Block b, String src, String holder
      ) throws IOException {
    //
    // Remove the block from the pending creates list
    //
    NameNode.stateChangeLog.debug("BLOCK* NameSystem.abandonBlock: "
                                  +b+"of file "+src);
    if (isInSafeMode()) {
      throw new SafeModeException("Cannot abandon block " + b +
                                  " for fle" + src, safeMode);
    }
    //移除块操作时进行租约检查,如果出现不符号要求的时候会抛异常
    INodeFileUnderConstruction file = checkLease(src, holder);
    dir.removeBlock(src, file, b);
    NameNode.stateChangeLog.debug("BLOCK* NameSystem.abandonBlock: "
                                    + b
                                    + " is removed from pendingCreates");
    return true;
  }// make sure that we still have the lease on this file.
  private INodeFileUnderConstruction checkLease(String src, String holder) 
                                                      throws IOException {
    INodeFile file = dir.getFileINode(src);
    //继续调用同名方法
    checkLease(src, holder, file);
    return (INodeFileUnderConstruction)file;
  }然后是下面的核心检查方法//下面是租约检查的核心逻辑方法
  private void checkLease(String src, String holder, INode file) 
                                                     throws IOException {
    //如果正在操作的文件不存在,抛异常
    if (file == null || file.isDirectory()) {
      Lease lease = leaseManager.getLease(holder);
      throw new LeaseExpiredException("No lease on " + src +
                                      " File does not exist. " +
                                      (lease != null ? lease.toString() :
                                       "Holder " + holder + 
                                       " does not have any open files."));
    }
    
    //如果文件没有被打开,说明一定没有对应的租约记录存在,也抛异常
    if (!file.isUnderConstruction()) {
      Lease lease = leaseManager.getLease(holder);
      throw new LeaseExpiredException("No lease on " + src + 
                                      " File is not open for writing. " +
                                      (lease != null ? lease.toString() :
                                       "Holder " + holder + 
                                       " does not have any open files."));
    }

    INodeFileUnderConstruction pendingFile = (INodeFileUnderConstruction)file;
    //判断文件所有者和客户端租约持有者是否一致
    if (holder != null && !pendingFile.getClientName().equals(holder)) {
      throw new LeaseExpiredException("Lease mismatch on " + src + " owned by "
          + pendingFile.getClientName() + " but is accessed by " + holder);
    }
  }主要进行了租约持有者与文件所属者名称进行检查，还有文件打开状态的判断。通过抛出异常的方式阻止用户的操作。租约监控在租约管理器内部也有租约线程操作//租约过期监控检测线程
  class Monitor implements Runnable {
    final String name = getClass().getSimpleName();

    /** Check leases periodically. */
    public void run() {
      for(; fsnamesystem.isRunning(); ) {
        synchronized(fsnamesystem) {
          //执行checkLeases方法
          checkLeases();
        }

        try {
          Thread.sleep(2000);
        } catch(InterruptedException ie) {
          if (LOG.isDebugEnabled()) {
            LOG.debug(name + " is interrupted", ie);
          }
        }
      }
    }
  }会进行定期的租约检查操作，并对超时租约进行租约恢复操作  /** Check the leases beginning from the oldest. */
  synchronized void checkLeases() {
    for(; sortedLeases.size() > 0; ) {
      //获取距离目前最晚的租约时间开始
      final Lease oldest = sortedLeases.first();
      //如果最晚的时间是否超过硬超时时间
      if (!oldest.expiredHardLimit()) {
        return;
      }

      //到了这步，说明已经发生租约超时
      LOG.info("Lease " + oldest + " has expired hard limit");

      final List<String> removing = new ArrayList<String>();
      // need to create a copy of the oldest lease paths, becuase 
      // internalReleaseLease() removes paths corresponding to empty files,
      // i.e. it needs to modify the collection being iterated over
      // causing ConcurrentModificationException
      //获取此租约管理的文件路径
      String[] leasePaths = new String[oldest.getPaths().size()];
      oldest.getPaths().toArray(leasePaths);
      for(String p : leasePaths) {
        try {
          //进行租约释放
          fsnamesystem.internalReleaseLeaseOne(oldest, p);
        } catch (IOException e) {
          // 如果是租约释放失败的情况加入移除列表中
          LOG.error("Cannot release the path "+p+" in the lease "+oldest, e);
          removing.add(p);
        }
      }
      
      //进行移除租约记录的remove操作
      for(String p : removing) {
        removeLease(oldest, p);
      }
    }
  }每次从获取最晚的租约记录检测。全部代码的分析请点击链接https://github.com/linyiqun/hadoop-hdfs,后续将会继续更新HDFS其他方面的代码分析。参考文献《Hadoop技术内部–HDFS结构设计与实现原理》.蔡斌等

版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式： 自己手动写一适配器和外观模式
适配器模式： 将一个类的接口，转换成客户所期待的接口，适配器让原本不兼容的类可以合作无间。有两种形式：类适配器和对象适配器。前者需要用到多重继承（java不支持），后者要用到组合。
外观模式： 提供了一个统一的简化的接口，用来访问子系统里的一群接口。外观定义了一个高层接口，让子系统更容易使用。


适配器的类图




适配器的一个简单源码：
package adapter;
/**
 * 鸭子接口
 * @author Arvon
 *
 */
public interface Duck {
	public void quack();
	public void fly();
}

package adapter;
/**
 * 火鸡接口
 * @author Administrator
 *
 */
public interface Turkey {
	public void fly();
	public void goggle();
}

package adapter;
/**
 * 一个伪装成火鸡的鸭 
 * @author Administrator
 *
 */
public class TurkeyAdapter implements Duck {
	private Turkey turkey;
	
	
	public TurkeyAdapter(Turkey turkey) {
		super();
		this.turkey = turkey;
	}

	@Override
	public void quack() {
		// TODO Auto-generated method stub
		turkey.goggle();

	}

	@Override
	public void fly() {
		// TODO Auto-generated method stub
		for(int i=0;i<5;i++)
			turkey.fly();

	}

}



package adapter;

public class MalladDuck implements Duck {

	@Override
	public void quack() {
		// TODO Auto-generated method stub
		System.out.println("i am quacking...");

	}

	@Override
	public void fly() {
		// TODO Auto-generated method stub
		System.out.println("i am flying ...");

	}

}



package adapter;

public class WildTurkey implements Turkey {

	@Override
	public void fly() {
		// TODO Auto-generated method stub
		System.out.println("i am flying short distance...");

	}

	@Override
	public void goggle() {
		// TODO Auto-generated method stub
		System.out.println("i am goggling....");

	}

}


package adapter;

public class AdapterTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Duck duck = new MalladDuck();
		System.out.println(duck.getClass().getSimpleName()+" says...");
		testDuck(duck);
		//将鸭子接口转换成了火鸡接口
		Duck fakeDuck = new TurkeyAdapter(new WildTurkey());
		System.out.println(fakeDuck.getClass().getSimpleName()+" says...");
		testDuck(fakeDuck);
		
		

	}

	private static void testDuck(Duck duck) {
		duck.quack();
		duck.fly();
	}

}

程序输出：
MalladDuck says...
i am quacking...
i am flying ...
TurkeyAdapter says...
i am goggling....
i am flying short distance...
i am flying short distance...
i am flying short distance...
i am flying short distance...
i am flying short distance...



外观模式类图




核心代码：
package facade;
/**
 * 简化了的接口
 * @author Administrator
 *
 */
public class HomeTheaterFacade {
	Amplifier amp;
	Tuner tuner;
	DvdPlayer dvd;
	CdPlayer cd;
	Projector projector;
	TheaterLights lights;
	Screen screen;
	PopcornPopper popper;
	public HomeTheaterFacade(Amplifier amp, Tuner tuner, DvdPlayer dvd, CdPlayer cd, Projector projector,
			TheaterLights lights, Screen screen, PopcornPopper popper) {
		super();
		this.amp = amp;
		this.tuner = tuner;
		this.dvd = dvd;
		this.cd = cd;
		this.projector = projector;
		this.lights = lights;
		this.screen = screen;
		this.popper = popper;
	}
	
	public void watchMovie(String movie) {
		System.out.println("Get ready to watch a movie...");
		popper.on();
		popper.pop();
		lights.dim(10);
		screen.down();
		projector.on();
		projector.wideScreenMode();
		amp.on();
		amp.setDvd(dvd);
		amp.setSurroundSound();
		amp.setVolume(5);
		dvd.on();
		dvd.play(movie);
	}
 
 
	public void endMovie() {
		System.out.println("Shutting movie theater down...");
		popper.off();
		lights.on();
		screen.up();
		projector.off();
		amp.off();
		dvd.stop();
		dvd.eject();
		dvd.off();
	}
	

}


package facade;

public class FacadeTest {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Amplifier amp = new Amplifier("Top-O-Line Amplifier");
		Tuner tuner = new Tuner("Top-O-Line AM/FM Tuner", amp);
		DvdPlayer dvd = new DvdPlayer("Top-O-Line DVD Player", amp);
		CdPlayer cd = new CdPlayer("Top-O-Line CD Player", amp);
		Projector projector = new Projector("Top-O-Line Projector", dvd);
		TheaterLights lights = new TheaterLights("Theater Ceiling Lights");
		Screen screen = new Screen("Theater Screen");
		PopcornPopper popper = new PopcornPopper("Popcorn Popper");
 
		HomeTheaterFacade homeTheater = 
				new HomeTheaterFacade(amp, tuner, dvd, cd, 
						projector, lights, screen, popper);
 
		homeTheater.watchMovie("Raiders of the Lost Ark");
		homeTheater.endMovie();

	}

}


其他的类都是子系统的类 这里就不贴出来啦。
程序的输出：
Get ready to watch a movie...
Popcorn Popper on
Popcorn Popper popping popcorn!
Theater Ceiling Lights dimming to 10%
Theater Screen going down
Top-O-Line Projector on
Top-O-Line Projector in widescreen mode (16x9 aspect ratio)
Top-O-Line Amplifier on
Top-O-Line Amplifier setting DVD player to Top-O-Line DVD Player
Top-O-Line Amplifier surround sound on (5 speakers, 1 subwoofer)
Top-O-Line Amplifier setting volume to 5
Top-O-Line DVD Player on
Top-O-Line DVD Player playing "Raiders of the Lost Ark"
Shutting movie theater down...
Popcorn Popper off
Theater Ceiling Lights on
Theater Screen going up
Top-O-Line Projector off
Top-O-Line Amplifier off
Top-O-Line DVD Player stopped "Raiders of the Lost Ark"
Top-O-Line DVD Player eject
Top-O-Line DVD Player off













版权声明：本文为博主原创文章，未经博主允许不得转载。

Java之旅hibernate（8）——基本关系映射
　　何为关系，何为映射，关系这个词想必大家都不陌生，比如你和老师之间是师生关系，你和父母之间是父子或者父女（母子或者母女关系）。
　　关系是存在某种联系物体之间产生的，什么都是可能的，比如你和工具，你只能使用工具，但是工具不能使用你，这样的关系是单向的，但是换种说法，你拥有工具，工具也属于你，那么这种关系就是双向的了，此外一个人可以拥有多个工具，并且多个工具也可以是属于一个人的，还有就是多个人拥有多个工具，并且多个工具也属于人，根据这些特征，我们将关系分为以下几种：
　　单向关系：
　　one2one,（一对一）
　　many3one（多对一）
　　one2many（一对多）
　　many2many（多对多）
　　双向关系：
　　one2many（一对多）
　　many2many（多对多）
　　one2one（一对一）
　基本映射必备知识
　　必须存在的文件和实体
　　实体类（.java）
　　实体类的存在是基础，因为我们要做的就是将实体类映射成为表，在映射之前先建好实体类，以及主键和各个属性字段。代码如下图：
import java.util.Date;

public class User {

	private String id;
	
	private String name;

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
　　映射文件(*.hbm.xml)
　　映射文件通常是以.hbm.xml为后缀的，比如我们建立一个User的实体，那么我们的映射文件就是User.hbm.xml,将实体映射为表也是在这里进行配置的。配置如下：
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC 
	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="com.bjpowernode.hibernate.User">
		<id name="id">
			<generator class="uuid"/>
		</id>
		<property name="name"/>
		<property name="password"/>
	</class>
</hibernate-mapping>
　　Hibernate的配置文件（hibernate.cfg.xml）
　　当我们建立了实体和映射文件后，下面我们就该进行在配置文件中进行配置了，因为配置文件是我们拿到整个接口和方法的入口，所以在此配置尤为重要。
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
	<session-factory>
		<property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
		<property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate_session</property>
		<property name="hibernate.connection.username">root</property>
		<property name="hibernate.connection.password">bjpowernode</property>
		<property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
		<property name="hibernate.show_sql">true</property>
		
		<mapping resource="com/bjpowernode/hibernate/User.hbm.xml"/>
	</session-factory>
</hibernate-configuration>
　　这里不仅仅配置了数据库的信息，并且也配置了映射文件，从而可以通过工具类将映射文件导入到数据库。
　　工具类
　　这是我们自己手写的工具类，用于将实体类映射成表，并保存到数据库。
import org.hibernate.cfg.Configuration;
import org.hibernate.tool.hbm2ddl.SchemaExport;

/**
 * 将hbm生成ddl
 * @author Administrator
 *
 */
public class ExportDB {

	public static void main(String[] args) {
		
		//默认读取hibernate.cfg.xml文件
		Configuration cfg = new Configuration().configure();
		
		SchemaExport export = new SchemaExport(cfg);
		export.create(true, true);
	}
}
　小结
　　了解了上面的基本信息，那就便于我们对于hibernate的七种映射关系进行理解，下面的文章将进行hibernate七种关系的一一讲解。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Atitit.使用引擎加脚本架构的设计 使用php,js来开发桌面程序。。

Atitit.使用引擎加脚本架构的设计 使用php,js来开发桌面程序。。
 
 
1. 引擎加脚本架构 跨平台，桌面与web的优势
1
2. 架构桌面引擎（java，c#）
2
3. php桌面引擎要点
2
3.1. 运行环境：同时支持cs桌面与web方式
2
3.2. 界面使用html5+css+js实现
2
3.3. Cli接口互操作，与web接口互操作
2
3.4. 其他----------流程
2
3.4.1. Html5界面确定要是有的后台引擎$parser=php c# java js
2
3.4.2. 桌面引擎dispatch
3
3.4.3. 使用cli引擎转发到php
3
3.4.4. phprun.bat
4
3.4.5. Php同时支持web与桌面的参数传递
4
3.4.6. 桌面程序$_GET参数的解析，自定义req引擎
4
3.4.7. 回调js 通过$callback
5
4. 常见问题与最近实践
5
4.1. 使用cmd.exe还是直接bat。。
5
5. 其他的php桌面程序方案
6
6. 参考
6
 
1. 引擎加脚本架构 跨平台，桌面与web的优势
跨平台方面java很不错。但是java需要编译。。如果需要一个桌面程序，需要灵活修改，可以脚本写成的化，就可以考虑引擎加脚本架构 。。。使用php或者js来做桌面后端。。。

作者:: 老哇的爪子 Attilax 艾龙，  EMAIL:1466519819@qq.com

转载请注明来源： http://blog.csdn.net/attilax
 
2. 架构桌面引擎（java，c#）

 
3. php桌面引擎要点
3.1. 运行环境：同时支持cs桌面与web方式
3.2. 界面使用html5+css+js实现
3.3. Cli接口互操作，与web接口互操作
3.4. 其他----------流程
3.4.1. Html5界面确定要是有的后台引擎$parser=php c# java js
使用dwr引擎转换为http param..
最好可以有个总配置要使用什么引擎，也可以单独页面配置不同的引擎。。
 
3.4.2. 桌面引擎dispatch 
Proj.amazon splider
  //供JS调用
        public void sendNSCommand(Object message, Object message2, Object message3, Object message4, Object message5, Object message6, Object message7)
        {
          //  Object[] objs = (Object[])message;
            Console.WriteLine(message);
 
            String meth =(String) message;
            //p822
            string paramsx=((string) message2);
            if (paramsx.Contains("$parser"))
            {
                String r = new php—ParesrX(paramsx).exec().Trim() ;
                Map m = new ParamX().urlParams2Map((string)message2);
                 String callback = (String)m.get("$callback");
                 String js2 = callback + "('" + r + "');";
                 WebBrowser webBrowser1 = (WebBrowser)iocx.getBean("webBrowser1");
                 object[] objects = new object[1];
                 objects[0] = r;
                 Object o = webBrowser1.Document.InvokeScript(callback, objects);
                 Console.WriteLine("==exe js rzt:" + o);
                 return;
            }
 
3.4.3. 使用cli引擎转发到php
 class ParesrX
    {
        private string meth;
 
        public ParesrX(string meth)
        {
            // TODO: Complete member initialization
            this.meth = meth;
 
        }
 
        internal String exec()
        {
            Map m =new  ParamX().urlParams2Map(this.meth);
            if (((String)m.get("$parser")).Equals("php"))
            {
                String urlparams = m.serialize();
                String cmd = "@qut" + pathx.StartupPath() + "/phprun.bat@qut  @qut" + pathx.StartupPath() + "/com.attilax/api.php@qut  @qut" + urlparams + "@qut";
              cmd=cmd.Replace("@qut","\"");
                Console.WriteLine(cmd);
            String r=    new Cmd().RunCmd(cmd);
            return r;
            }
            return "";
 
 
3.4.4. phprun.bat
@d:
 
@"%~dp0php5.3.10\php.exe"  -c "%~dp0php5.3.10\php.ini"  -f %1  %2  %3
 
 
3.4.5. Php同时支持web与桌面的参数传递
/com.attilax/api.php@qut  @qut" + urlparams + "@qut";
Web方式    api.php?urlparams....
 
3.4.6. 桌面程序$_GET参数的解析，自定义req引擎
 if(count($_GET)==0) //cli mode
 {
 
 $param=$argv[1]; 
  $GLOBALS["varx"]["argv"]=$argv ;
 
 $_GET=urlParams2Map($param); 
   $GLOBALS["varx"]["get"]=$_GET ;
  
 
 }
 
 
 
function   urlParams2Map( $params) {
 $o=array();
$a=explode('&',$params);
 $GLOBALS["varx"]["a"]=$a ;
  $GLOBALS["varx"]["params"]=$params;
  foreach( $a as $k2=>$v2 )
  {
 
  $a2=explode("=",$v2);
   $k=$a2[0];
   $v=$a2[1];
   $o[$k]=$v;
  }
   $GLOBALS["varx"]["o"]=$o ;
return $o;

}
 
3.4.7. 回调js 通过$callback
    String callback = (String)m.get("$callback");
                 String js2 = callback + "('" + r + "');";
                 WebBrowser webBrowser1 = (WebBrowser)iocx.getBean("webBrowser1");
                 object[] objects = new object[1];
                 objects[0] = r;
                 Object o = webBrowser1.Document.InvokeScript(callback, objects);
 
4. 常见问题与最近实践
4.1. 使用cmd.exe还是直接bat。。
推荐使用bat方式。。否则cmd.exe 
 
        String cmd = "@qut" + pathx.StartupPath() + "/phprun.bat@qut  @qut" + pathx.StartupPath() + "/com.attilax/api.php@qut  @qut" + urlparams + "@qut";
              cmd=cmd.Replace("@qut","\"");
 
正确的方式是，将 /C 后面所有字符，再加上双引号：
对比两段命令，很多人马上就明白为什么了。

因为，这里相当于有两条命令，并且是嵌套的，外面的命令是：

cmd.exe /C "command"

命令是 cmd.exe，两个参数分别是 /C， "command"，我们这里的 command 是
 
      
5. 其他的php桌面程序方案
php gtk
WinBinder 
 
6. 参考
用PHP开发桌面应用.html
执行 CMD 时，参数加引号常见问题 - 的米-漠石's Blog - 博客频道 - CSDN.NET.html
C#执行DOS命令（CMD命令） - 杨友山 - 博客频道 - CSDN.NET
paip.asp vbs通过CLI命令行调用PHP代码 - attilax的专栏 - 博客频道 - CSDN.NET
paip.执行shell cmd 命令uapi java php python总结 - attilax的专栏 - 博客频道 - CSDN.NET
 



﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

Apache和Tomcat整合（一个Apache 不同域名处理多个不同业务）
一、简介 在项目中，几乎任何一个项目都包括静态资源和动态请求两大部分。特别对于门户网站这样的项目，静态内容资源会更多，我们使用一般的 Tomcat 部署时，Tomcat 对静态资源的处理能力比较慢，至少比 Apache 要慢很多。 为了提高项目的访问速度，降低服务器负载提高性能，我们使用Apache来处理静态资源，把动态资源和请求交给 Tomcat 处理。 当然，在单纯处理并发和静态资源指标方面，Nginx要比Apache好，至于Nginx和Apache的具体区别，以及什么项目使用Nginx、什么项目适合用Apache，异或是使用Nginx加Apache一起使用…… 这个不是本文要探讨的范围，这两个开源项目各有优缺点，大家可以针对自己项目选择合适的方案。 本文就简单的对Apache和Tomcat如何集成，进行实际配置进行说明：apache与tomcat负载集群集成方法有3种jk、jk_proxy、http_proxy二、mod_proxy 和 mod_jk 的比较那么什么时候使用哪一个呢？这依赖于你的架构。如果你已经有了或者需要apache 2.2的功能，那么你可以再mod_proxy和mod_jk直接选择。mod_jk在apache2.2上允许得很好。关键看你需要什么样的功能：mod_proxy--------------优势: 不需要编译和维护一个对立的模块。mod_proxy,mod_proxy_http,mod_proxy_ajp,mod_proxy_balancer已经是apache 2.2+的标准集成部分； 可以使用http、https和AJP协议，即便是在同一个balancer中。劣势: mod_proxy_ajp不支持大于8k的数据包； 只有最基本的负载均衡器； 不支持域模型集群（domain model clustering）mod_jk--------------优势: 先进的负载均衡器； 先进的节点失败侦察功能； 支持大型AJP 数据包劣势: 需要单独维护一个独立的模块；我个人建议是如果有能力维护mod_jk模块的二进制版本，尽量使用mod_jk。mod_proxy一直在更新但还缺少一些mod_jk的功能。但是，如果你需要https和一个简单的负载均衡就是用mod_proxy.三、实践以 mod_jk 为例，使用1个apache 同时支持2个tomcat 不同业务的处理（web和wap）。1、下载安装 Apache （本文忽略） 2、下载安装 Tomcat （本文忽略）3、下载 mod_jk 安装包     下载连接Apache和Tomcat(mod_jk) 的包 tomcat-connectors-1.2.41-src.tar.gz     官网下载地址：http://tomcat.apache.org/download-connectors.cgi4、安装 mod_jk     # cd tomcat-connectors-1.2.41-src/native/
# ./configure --with-apxs=/usr/local/apache2/bin/apxs
# make
# cp ./apache-2.0/mod_jk.so /usr/local/apache2/modules/ #拷贝至Apache指定模块目录
5、配置Apache相关参数文件1) 配置 mod_jk 模块刚刚安装了mod_jk 模块，也已经拷贝到Apache的模块目录中，下面就是让Apache来支持它。需要在Apache的conf目录下新建配置文件：workers.properties #定义Tomcat工作的的配置文件mod_jk.conf #定义mod_jk 的配置文件# cd /usr/local/apache2/conf/# vi mod_jk.conf#指定workers.properties的位置 
JkWorkersFile conf/workers.properties
#指定jk的日志输出文件  		
JkLogFile logs/mod_jk.log
#JkShmFile配置
JkShmFile logs/jk-runtime-status
#指定日志级别		
JkLogLevel info
#指定日志输出的时间戳格式		
JkLogStampFormat "[%a %b %d %H:%M:%S %Y]"
#JkOptions指示发送给SSL密钥大小
JkOptions  +ForwardKeySize +ForwardURICompat -ForwardDirectories
#指定日志中时间戳后面的内容：%w：工作的tomcat实例 %V：目标ip %T：耗时
JkRequestLogFormat "%w %V %T"# vi workers.properties#指定需要工作的tomcat节点，如多个用“,”分割
worker.list=worker_web,worker_wap
####################################################################
worker.worker_web.type=ajp13	#指定worker_web使用ajp13协议与Tomcat进程通讯
worker.worker_web.host=localhost	#指定worker_web的位置，如果不是本机，就配置IP地址
worker.worker_web.port=8009	#指定worker_web的工作端口
worker.worker_web.socket_keepalive=1	#此配置项为当Apache和Tomcat之间有防火墙时，让os每隔多久想未激活的连接发送KEEP_ALIVE信息，防止防火墙切断未激活的网络连接
worker.worker_web.socket_timeout=300	#指定worker_web上的连接在未激活的状况下持续多久，Apache将主动切断

####################################################################
worker.worker_wap.type=ajp13
worker.worker_wap.host=localhost
worker.worker_wap.port=8109
worker.worker_wap.socket_keepalive=1
worker.worker_wap.socket_timeout=3002) 修改 Apache 的主配置文件 httpd.conf 配置多个虚拟主机a) 找到 Include conf/extra/httpd-vhosts.conf 去掉前面的 “#”b) vi conf/extra/httpd-vhosts.conf########################################################
LoadModule jk_module modules/mod_jk.so
Include conf/mod_jk.conf
########################################################
<VirtualHost *:80>
    #ServerAdmin webmaster@dummy-host.example.com
    DocumentRoot "/svcroot/runtime/webstatic/shanhyweb"
    ServerName shanhyweb.example.com
    #ServerAlias www.shanhyweb.example.com
    ErrorLog "logs/shanhyweb-error_log"
    CustomLog "logs/shanhyweb-access_log" common
        <IfModule mod_jk.c>
                #日志输出文件(其他配置也可以重写mod_jk.conf里面的配置)
                JkLogFile logs/mod_jk_shanhyweb.log
                #指URL指向如果有servlet，则让worker_web去处理
                JkMount /servlet/* worker_web
                #指URL为/*.jsp的页面，让worker_web去处理
                JkMount /*.jsp worker_web
                #指URL为/*.do的页面，让worker_web去处理
                JkMount /*.do worker_web
                #指URL为/*.json的页面，让worker_web去处理
                JkMount /*.json worker_web
        </IfModule>
        <Directory "/svcroot/runtime/webstatic/shanhyweb">
                Options FollowSymLinks
                AllowOverride None
                Require all granted
        </Directory>
</VirtualHost>

<VirtualHost *:80>
    #ServerAdmin webmaster@dummy-host.example.com
    DocumentRoot "/svcroot/runtime/webstatic/shanhywap"
    ServerName shanhywap.example.com
    #ServerAlias www.shanhywap.example.com
    ErrorLog "logs/shanhywap-error_log"
    CustomLog "logs/shanhywap-access_log" common
        <IfModule mod_jk.c>
                #日志输出文件(其他配置也可以重写mod_jk.conf里面的配置)
                JkLogFile logs/mod_jk_shanhywap.log
                #指URL指向如果有servlet，则让worker_wap去处理
                JkMount /servlet/* worker_wap
                #指URL为/*.jsp的页面，让worker_wap去处理
                JkMount /*.jsp worker_wap
                #指URL为/*.do的页面，让worker_wap去处理
                JkMount /*.do worker_wap
                #指URL为/*.json的页面，让worker_wap去处理
                JkMount /*.json worker_wap
        </IfModule>
        <Directory "/svcroot/runtime/webstatic/shanhywap">
                Options FollowSymLinks
                AllowOverride None
                Require all granted
        </Directory>
</VirtualHost>配置文件中 /svcroot/runtime/webstatic/shanhyweb 和 /svcroot/runtime/webstatic/shanhywap 分别为web和wap的静态资源目录配置文件中 worker_web 和 worker_wap 为我们2个处理不同业务的 Tomcat6、 配置web的Tomcat 和wap 的Tomcat我在/app/webserver 目录下放了2个tomcat，分别是 apache-tomcat-7.0.63-wap 和 apache-tomcat-7.0.63-web修改 apache-tomcat-7.0.63-wap/conf/server.xml 中的ajp 端口为8109，http端口为 8180，server 端口为8105在  apache-tomcat-7.0.63-wap/conf/server.xml 的最下面的 </Host> 上面一行添加：<Context path="" docBase="/svcroot/runtime/webinterface/shanhywap" reloadable="true" distributable="true"/>在  apache-tomcat-7.0.63-web/conf/server.xml 的最下面的 </Host> 上面一行添加：<Context path="" docBase="/svcroot/runtime/webinterface/shanhyweb" reloadable="true" distributable="true"/>7、重启相关服务重启Apache 服务，并启动web和wap的tomcat 服务。8、测试修改本机 C:\Windows\System32\drivers\etc 目录下的 hosts 文件，在最后添加：192.168.19.130 shanhyweb.example.com192.168.19.130 shanhywap.example.com其中 192.168.19.130 为我们上面配置的Linux 服务的IP地址。服务器上静态资源文件：/svcroot/runtime/webstatic/shanhywap/index.html 内容为 This is my page. ShanhyWap-Static./svcroot/runtime/webstatic/shanhyweb/index.html 内容为 This is my page. ShanhyWeb-Static.服务器上2个Tomcat 配置的项目中的 jsp 测试文件：/svcroot/runtime/webinterface/shanhywap/test.jsp 内容为 ShanhyWap Content./svcroot/runtime/webinterface/shanhyweb/test.jsp 内容为 ShanhyWeb Content.访问地址测试：访问：http://shanhywap.example.com 后网页显示 This is my page. ShanhyWap-Static.访问：http://shanhyweb.example.com 后网页显示 This is my page. ShanhyWeb-Static.访问：http://shanhywap.example.com/test.jsp 后网页显示 ShanhyWap Content.访问：http://shanhywap.example.com/test.jsp 后网页显示 ShanhyWeb Content.9、相关文件最后列出本问整合涉及到的相关文件目录位置：apache 安装目录 /usr/local/apache2apache 相关配置文件：/usr/local/apache2/conf/httpd.conf/usr/local/apache2/conf/mod_jk.conf/usr/local/apache2/conf/workers.properties/usr/local/apache2/conf/extra/httpd-vhosts.confwebserver 的2个Tomcat 目录：/app/webserver/apache-tomcat-7.0.63-wap/app/webserver/apache-tomcat-7.0.63-webwebinterface 程序目录(2个Tomcat分别对应的项目工程) ：/svcroot/runtime/webinterface/shanhyweb-- test.jsp/svcroot/runtime/webinterface/shanhywap-- test.jspwebstatic 静态资源目录/svcroot/runtime/webstatic/shanhyweb-- index.html/svcroot/runtime/webstatic/shanhywap-- index.html************************************************************************题外话说一下我的目录归类，我的 /svcroot 目录目录结构如下：/svcroot-- runtime   -- standalone（存放java程序）   -- webinterface（存放Tomcat对应的项目工程）   -- webstatic（存放项目工程的静态资源）-- workspace   -- build（hudson custom 目录，SVN 代码）       -- shanhyweb-source       -- shanhywap-source       -- shanhyAndroid-source   -- dist（build编译后的文件目录，待发布）-- logs（项目相关logs）--------------------------（完）访问：http://shanhywap.example.com 后网页显示 This is my page. ShanhyWap-Static.访问：http://shanhyweb.example.com 后网页显示 This is my page. ShanhyWeb-Static.

版权声明：本文为博主原创文章，未经博主允许不得转载。

组合(Composite)模式
定义
Composite模式是一种结构型设计模式，它将对象组合成树形结构以表示“部分－整体“的层次结构，并使用户对单个对象和组合对象的使用具有一致性。
动机
当处理树形结构的数据时，我们常常需要区别对待叶子结点和内部结点，这使得代码更加复杂，以至于容易出错。因此，如果有一种方法，可以使我们可以统一处理叶子结点和内部结点，那么，对于我们提高代码的质量是十分有帮助的。 
Composite模式正是这样一种设计模式，它可以使我们以统一的方式去处理叶子结点(单个对象)和内部结点(组合对象)。
适用性
当你想表示“部分－整体“的层次结构，并希望忽略组合对象和单个对象不同，可以使用统一的方式来处理组合结构中的所有对象。
结构

Compenent

所有对象的抽象，包括组合对象和单个对象
声明对象的接口

Leaf

表示单个对象
实现所有的Compent接口

Composite

代表组合对象
实现所有的Compent接口
还包括了对其孩子对象进行操作的接口

例子
在下面的例子中，我们实例一个图形系统。图形可以是椭圆(Ellipse)或者复合图形(CompositeGraphic)，每个图形都可以打印出来，打印接口在Graphic接口中声明。 
这个图形系统是易于扩展的，例如加入矩形，圆形等，也可以加入其他的方法，例如缩放等。
Graphic.java
/** "Component" */
interface Graphic {

    // Prints the graphic.
    public void print();
}
CompositeGraphic.java
/** "Composite" */
import java.util.List;
import java.util.ArrayList;
class CompositeGraphic implements Graphic {

    // Collection of child graphics.
    private List<Graphic> childGraphics = new ArrayList<Graphic>();

    // Prints the graphic.
    public void print() {
        for (Graphic graphic : childGraphics) {
            graphic.print();
        }
    }

    // Adds the graphic to the composition.
    public void add(Graphic graphic) {
        childGraphics.add(graphic);
    }

    // Removes the graphic from the composition.
    public void remove(Graphic graphic) {
        childGraphics.remove(graphic);
    }
}
Ellipse.java
/** "Leaf" */
class Ellipse implements Graphic {

    // Prints the graphic.
    public void print() {
        System.out.println("Ellipse");
    }
}
最后是使用这套图形系统的测试程序。它首先初始化4个椭圆(ellipse1, ellipse2, ellipse3, ellipse4)，然后构造2个复合图形(graphic1, graphic2)，再使用这2个复合图形来构造一个复合图形(graphic)，最后使用Graphic接口(print)来将graphic图形打印出来：
Program.java
/** Client */
public class Program {

    public static void main(String[] args) {
        // Initialize four ellipses
        Ellipse ellipse1 = new Ellipse();
        Ellipse ellipse2 = new Ellipse();
        Ellipse ellipse3 = new Ellipse();
        Ellipse ellipse4 = new Ellipse();

        // Initialize three composite graphics
        CompositeGraphic graphic = new CompositeGraphic();
        CompositeGraphic graphic1 = new CompositeGraphic();
        CompositeGraphic graphic2 = new CompositeGraphic();

        // Composes the graphics
        graphic1.add(ellipse1);
        graphic1.add(ellipse2);
        graphic1.add(ellipse3);

        graphic2.add(ellipse4);

        graphic.add(graphic1);
        graphic.add(graphic2);

        // Prints the complete graphic (four times the string "Ellipse").
        graphic.print();
    }
}
输出：

Ellipse 
  Ellipse 
  Ellipse 
  Ellipse

参考资料

https://en.wikipedia.org/wiki/Composite_pattern
http://www.tutorialspoint.com/design_pattern/composite_pattern.htm
http://baike.baidu.com/view/3591789.htm


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处: http://blog.csdn.net/lihao21

数据设计是程序架构的灵魂
之前开发了一套c语言交互系统，当时设计了业务数据和用户数据，业务数据负责对业务操作的管理，控制数据负责的业务的结果进行管理。实现了模块和全局的解耦。全局对局部的支撑。
昨天晚上看了FFMPEG的数据设计架构，隐隐绝对当时的设计存在一些不足之处。
FFMPEG的数据设计主要分为一下三种：
1、业务数据，在业务运行过程中生成，并提供业务接口支撑，接口为模块抽象出的对外接口。
2、全局数据抽象部分，相当于c++的基类
3、全局数据私有部分，相当于c++的子类
业务运行时，调用业务数据中的支撑接口，实现具体业务。
FFMPEG数据架构是通过业务数据对外暴露业务接口，通过业务数据了解业务过程，通过全局数据实现具体业务功能。
好处为：
1、使用了面向对象技术，易于理解和扩展
2、使用了面向接口编程，低耦合，模块容易复用


通过对比，可以发现之前系统设计的不足之处
1、业务数据没有集成接口，功能过于单一
2、全局数据存在意义不强，需要承载更多的东西
3、无法通过数据清晰展示业务结构
4、模块复用度不高


总结：
1、FFMPEG和交互式系统的不同，上面的不足之处不一定都能够用FFMPEG的设计方式解决，但是其始终面向对象和面向接口的设计思想需要我们深刻理解，并引入。


注：本人设计交互式系统时还未接触过c++，所以系统的面向过程痕迹很重。





版权声明：本文为博主原创文章，未经博主允许不得转载。

3. 蛤蟆的计算机组成原理笔记三系统总线
3. 蛤蟆的计算机组成原理笔记三系统总线
本篇名言：“公正，一定会打倒那些说假话和假作证的人。 --赫拉克利特”
 欢迎转载，转载请标明出处：http://blog.csdn.net/notbaron/article/details/47988545
 
1.  总线
总线是连接各个部件的信息传输线，是 各个部件共享的传输介质。
 
1.1             面向CPU 的双总线结构框图

 
 
 
1.2             单总线结构框图
 

 
 
 
1.3             以存储器为中心的双总线结构框图

 
2.  总线的分类
2.1         片内总线
芯片内部 的总线
 
2.2         系统总线
 
计算机各部件之间 的信息传输线

 
 
3.  总线特性及性能指标
3.1         机械特性
尺寸、形状、管脚数　及　排列顺序 
3.2         电气特性
传输方向 和有效的 电平 范围
3.3         功能特性
每根传输线的 功能,地址,数据,控制
3.4         时间特性
信号的 时序 关系
 
3.5         总线的性能指标
总线宽度
总线带宽
时钟同步/异步
总线复用
信号线数
总线控制方式
其他指标
4.  总线通信


 
 
 
 
 
 
 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

UML基础

UML定义：




    UML全称Unified Modeling Languae（统一建模语言），是一种面向对象的用来设计软件蓝图的可视化建模语言，它支持面向对象系统的分析、设计、实现和交付等各个环节，可以用于系统的理解、设计、浏览、维护和信息控制。




UML的内容：




UML主要包括三大构造块：事物、关系、图。其中各个构造块又分为各种小模块，用图说话：

（1）UML的构成如下： 









（2）UML的重点在UML的构造块当中：









整体介绍完了，接下来简单介绍重要的细节：




（1）事物









（2）关系









（3）图（注意图的作用对象）












基础知识到这里，后续更新更精彩。。。






版权声明：本文为博主原创文章，未经博主允许不得转载。

利用自定义标签实现分块技术
1. 何为分块？
    一个网页通常由几个块组成，现在已经不推荐使用fragment这样的标签。这时利用jsp的自定义标签技术，定义一个自己的标签去执行不同的块，可以有效的实现不同块的逻辑分离，及高效的代码复用。


2.分块的实现步骤。
    1. 写一个block的抽象类 BlockAbstract，包含一个path字段，一个展示分块页面的方法，及一个由子块执行的回调函数。
    2. 写一个BlockTag的标签类，继续SimpleTagSupport，并在doTag方法中获取block并调用其displayBlock方法。
 3. 定义tld文件
 4. 实现HeaderBlock继承BlockAbstract,实现其execute方法，并在其中实现该块的相关逻辑。
5. 在Spring的applicationContext.xml文件中声明出headerBlock块注入path属性。
6. 在jsp页面引用自定义的tag.


3. 使用技术
    自定义标签， 模板方法设计模式， SpringIoc


4.代码实现
 

/** * block的抽换类 */public abstract class BlockAbstract {   public String path;   public String getPath() {      return path;   }   public void setPath(String path) {      this.path = path;   }   public void displayBlock(PageContext pageContext) {      execute(pageContext);      if (path != null && path != "") {         try {            pageContext.include(path);         } catch (Exception e) {            e.printStackTrace();         }      }   }   /**    * 展示块的内容时执行的回调    * @param pageContext    */   protected abstract void execute(PageContext pageContext);}



/** * 分块的tag类 */public class BlockTag extends SimpleTagSupport{   public String getName() {      return name;   }   public void setName(String name) {      this.name = name;   }   private String name;   /**    * 标签的执行方法    * @throws JspException    * @throws IOException    */   @Override   public void doTag() throws JspException, IOException {      PageContext context = (PageContext) this.getJspContext();      ServletContext servletContext = context.getServletContext();      ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);      BlockAbstract block = (BlockAbstract)ctx.getBean(name);      block.displayBlock(context);   }}



<taglib xmlns="http://java.sun.com/xml/ns/j2ee"        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"        xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"        version="2.0">  <description>A tag library exercising SimpleTag handlers.</description>  <tlib-version>1.0</tlib-version>  <short-name>SimpleTagLibrary</short-name>  <uri>/weijiang</uri>  <tag>    <name>block</name>  <!-- 为标签处理器类配一个标签名 -->    <tag-class>com.weijiang.test.BlockTag</tag-class>    <body-content>empty</body-content>    <attribute>      <name>name</name>      <type>java.lang.String</type>    </attribute>  </tag></taglib>



public class HeadBlock extends BlockAbstract{   @Override protected void execute(PageContext pageContext) {      HttpServletRequest request = (HttpServletRequest)pageContext.getRequest();      //这里只是简单的打印一个name属性      request.setAttribute("name", "weijiang");   }}



<beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">  <bean id="blockHead" class="com.weijiang.test.HeadBlock">    <property name="path" value="/header.jsp"></property>  </bean></beans>



<%@ page contentType="text/html;charset=UTF-8" language="java" %><%@taglib prefix="wj" uri="/weijiang"  %><html>  <head>    <title>xx</title>  </head>  <body>    <wj:block name="blockHead"></wj:block>  </body></html>




版权声明：本文为博主原创文章，未经博主允许不得转载。

后端分布式系列：分布式存储－HDFS NameNode 设计实现解析
接前文 分布式存储-HDFS 架构解析，我们总体分析了 HDFS 架构的主要构成组件包括：NameNode、DataNode 和 Client。本文首先进一步解析 HDFS NameNode 的设计和实现要点。
元数据持久化
NameNode 将所有元信息以特定的数据结构组织存放在内存中，对于 namespace 和 replication factor 的信息会进行持久化，而映射关系则不会持久化。因为映射关系是通过 DataNode 启动后定时汇报上来，即使 NameNode 重启后内存信息丢失也可以通过 DataNode 重新汇报获得，而其他元信息则必须通过读取持久化存储来重建内存数据结构。出于性能原因，所有元信息的读取直接从内存中获得，而增删改操作则借鉴来数据库的事务日志技术。每次只变更内存数据结构并记录操作日志，将随机写变为顺序写来提高吞吐能力。
NameNode 使用一个事务日志文件 EditLog 来持久化记录针对文件系统元数据的每一次操作变更。而整个 file system namesapce 文件、文件块和数据节点的映射关系被存储在另一个 FsImage 文件中。当 NameNode 启动时，它读取 FsImage 文件构建元数据的内存数据结构，接着读取 EditLog 文件应用所有的操作事务到内存数据结构中。接着基于最新的内存数据结构重新写一个新的 FsImage 文件到磁盘上，然后清除 EditLog 的内容，因为它上面记录的所有操作日志都已经反应到 FsImage 上了。这个过程称为建立了一个检查点(checkpoint)，当然检查点技术也是数据库里最常用的了。启动过程中 NameNode 会进入一种特殊状态，称为安全模式（Safemode state），它等待 DataNode 报告文件块及其副本的数量并确定哪些文件的副本数量是不足的。
所有上述启动过程完成后，NameNode 才能对外提供服务。
数据分布策略
除了文件系统元数据管理外，NameNode 另一个重要作用是对写入的文件块选择合适 DataNode 来存放，称为 block placement policy。在通常情况下，replication factor（副本数）默认为 3， HDFS 的数据分布策略是将两份副本放在本地机架的两个不同 DataNode 上，最后一个副本放在另外一个机架的一个 DataNode 上。
NameNode 基于机架感知的数据分布策略并未考虑 DataNode 的磁盘空间利用率。这有效避免了将新的文件数据集中放置在一组拥有大量剩余空间的 DataNodes 上，比如新扩容的 DataNodes。这又带来另外一个问题，就是扩容新 DataNode 时导致数据分布的严重不平衡。
为了应对此类情况，HDFS 引入了一个平衡器工具（Balancer），在整个集群平衡磁盘空间利用率。这个工具通过引入设置一个在 0 和 1 之间的阈值来判断整个集群是否达到平衡。
HDFS 对于磁盘均衡的定义如下：

对于每一个 DataNode 其磁盘利用率与整个集群的平均利用率相比不超过设置的阈值偏差。

平衡器工作过程中确保不会减少副本总数，及其分布的机架数。也就是原来三个副本分布在两个机架，被平衡后也还是三个副本分布在两个机架，但可能移动到不同的 DataNode 上了。为了减少网络带宽占用，会尽可能避免机架间拷贝数据。例如：副本 A1 和 A2 在 Rack1，A3 在 Rack2，若平衡器认为 A1 所在 DataNode 磁盘利用率过高，需要移动 A1。在 Rack1 内找不到磁盘利用率低的其他 DataNode，则需要将 A1 移动到 Rack2。实际做法是直接从 Rack2 的 A3 复制一份得到 A4，并删除 Rack1 上的 A1，这样就避免了机架间复制。
复制管理
NameNode 努力确保每一个副本符合配置的 replication factor。假如 DataNode 宕机发生导致一些文件的 block 副本数变少，Namdenode 会发出复制命令给 DataNode，复制出新的副本以保持与配置的副本数一致。当宕机的 DataNode 恢复后重新加入集群后会导致一些文件的副本数超出配置数，NameNode 会检测到并删除多余的副本以节省存储空间。NameNode 维护一个复制优先级队列，对于副本不足的文件 block 按优先级排序，仅剩下一个副本的文件 block 享有最高的复制优先级。
性能设计
除了 NameNode 的单点和重启过程影响可用性外，另一个担忧因素是性能。 
读操作基于内存访问还好，写操作中磁盘是一个瓶颈点。而 NameNode 支持大量 Client 的并发读写，对于大量的并发写操作 NameNode 进行了优化。多线程情况下，当一个线程为保存操作事务日志发起一个 flush-and-sync 到磁盘文件的操作，其他线程只能等待。为了优化此类情况，NameNode 将随机写转换为批量写操作。当一个 NameNode 的线程初始化了一个 flush-and-sync 操作，所有当时的事务操作日志被批量写入文件。其余的线程只需要检查它们的事务是否被保存到了文件而不再需要再发起 flush-and-sync 操作。
总结
上面描述了 NameNode 提供的功能及其设计实现要点，最后我们简单点评下它在架构设计上的权衡考量。首先 NameNode 作为中心节点简化了整体设计，但很显然它也是个单点，会影响可用性。其次 NameNode 将所有元数据存储在内存中，内存的容量决定了整个分布式文件系统能支持文件数量，如果是大量的小文件场景也是个问题。而且 HDFS 基于 java 实现，java 针对大堆内存的 GC 优化也是个麻烦事。再次上面描述的 NameNode 的启动过程看起来就很耗时，特别是在 FsImage 和 EditLog 都很大的情况下。而且在 NameNode 的启动完成前整个 HDFS 是不可用的，所以 NameNode 即使是重启也对整体的可用性有很大影响。
参考
[1] Hadoop Documentation. HDFS Architecture. 
[2] Robert Chansler, Hairong Kuang, Sanjay Radia, Konstantin Shvachko, and Suresh Srinivas. The Hadoop Distributed File System



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Spring学习（三）ioc工厂bean深入理解
一、ioc工厂配置的bean分类：
划分依据：
getBean("xx") 调用某个bean对象返回的对象实例类型是否是class属性指向的类型

1、普通bean
getBean("xxx")  ==  class 属性

2、工厂bean

getBean("xxx")  ！=  class属性  （class属性中指向的是一个工厂类，调用这个bean对象，想要的并不是class属性指向的工厂 ，而是该工厂负责创建的实例对象。）

二、工厂bean的必要性：
  ioc并不是万能的，并不能创建开发过程中涉及到的所有对象，当ioc无法或者不能直接实例化某个对象时，需要一个第三方工厂帮助其实例化该对象，将这个第三方工厂配置在ioc环境下，实现 ioc直接管理的对象(普通对象)  和  第三方工厂创建的对象(ioc无法直接实例的对象)  之间的依赖关系。

  ioc无法实例化什么对象? 
接口类型对象 并且本工程中不允许提供接口的实现类。（因为ioc通过反射机制创建对象，接口不能反射）比如QQ授权登录只提供验证接口、获取天气等

三、在ioc中配置工厂bean的三种方式：
1  静态工厂
2  动态工厂（忽略）
3  实现FactoryBean接口（spring提供的工厂bean根接口）

下面，通过这个例子 来了解1 、 3这两种方式： 
   applicationContext.xml:
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd">
    <!-- 
        使用ioc依赖注入实现LoginAction、UserDaoIf依赖关系

     -->
     <bean id="action" class="com.etoak.action.LoginAction">
        <!-- <property name="dao" ref="fb"></property> -->
        <property name="dao" ref="factory"></property>
     </bean>
     <!-- 
                1 静态工厂 ~ 工厂模式
            factory-method ： 指向工厂类中提供的静态方法
                a  ioc容器会将具备改属性的bean当作工厂bean对待
                b  调用这个工厂bean时，返回的对象实例不在是class属性指向的对象类型
                    而是该工厂自动调用factory-method属性指向的方法（必须是静态的）返回的对象类型
                    所以这里getBean()得到的是UserDaoIf对象
        2 动态工厂(忽略)
      -->
      <bean id="factory" class="com.etoak.factory.DaoFactory" 
            factory-method="getDao"></bean>
      <!-- 
        3 FactoryBean接口
            (UserDaoIf)getBean("fb")
            ioc容器会将所有实现了FactoryBean接口的类作为工厂bean对象
        调用工厂bean时返回的对象实例 是 该工厂自动调用其getObject()返回的对象实例
       -->
      <bean id="fb" class="com.etoak.factory.DaoFactoryBean"></bean>
</beans>

UserDaoIf.java
package com.etoak.dao;
/**
 * 以接口的方式为LoginAction提供登录检查服务
 * 只需要知道LoginAction要实现登录操作需要一个login()方法
 * 不需要知道login()方法如何实现
 * 用到的时候只需要远程调用其他服务器上的实现方法
 * @author D_xiao
 *
 */
public interface UserDaoIf  {
    public boolean login();
}
DaoFactory.java
package com.etoak.factory;

import com.etoak.dao.UserDaoIf;
/**
 * 静态工厂
 * @author D_xiao
 *
 */
public class DaoFactory {
    //UserDaoIf
    private static UserDaoIf dao;
    static{
        dao = new UserDaoIf(){
            public boolean login(){
                //不能实例化具体对象，但能调用远程的东西
                System.out.println("使用webservice技术远程调用其他服务器中的具体实现");
                return true;
            }
        };
    }
    public static UserDaoIf getDao(){
        return dao;
    }
}
DaoFactoryBean.java
package com.etoak.factory;

import org.springframework.beans.factory.FactoryBean;
import com.etoak.dao.UserDaoIf;
/**
 * FactoryBean接口，第三方工厂
 * @author D_xiao
 *
 */
public class DaoFactoryBean implements FactoryBean{

    @Override
    public Object getObject() throws Exception {
        // 当前工厂需要创建的对象实例
        return new UserDaoIf(){
            public boolean login(){
                System.out.println("使用webservice调用其他服务器方法");
                return true;
            }
        };
    }

    @Override
    public Class getObjectType() {
        // 描述当前工厂创建的实例类型
        return UserDaoIf.class;
    }

    @Override
    public boolean isSingleton() {
        // 描述创建的单例状态  单例/ 非单例
        return false;
    }

}

LoginAction.java
package com.etoak.action;

import com.etoak.dao.UserDaoIf;


public class LoginAction {

    private UserDaoIf dao;

    public void setDao(UserDaoIf dao) {
        this.dao = dao;
    }

    public String execute() throws Exception{
        dao.login();
        return "success";
    }
}

Test.java  (测试)
package com.etoak.test;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;

import com.etoak.action.LoginAction;

public class Test {
    public static void main(String[] args) throws Exception{
        ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
          ac = new FileSystemXmlApplicationContext("src/applicationContext.xml");
         LoginAction la = (LoginAction)ac.getBean("action");
         //UserDaoImpl ud = ac.getBean(UserDaoImpl.class);
         la.execute();
    }
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

SSM框架搭建，新手学习中，欢迎指教
1、前言
最近项目中用到了spring+mybatis框架，闲暇之余，自己就想搭一套SSM(spring+springMVC+mybatis)的框架，结果发现并没有自己想象的那么简单，看了网上的很多教程，最多的就是那个用maven搭建的SSM，起初自己也想用maven搭建，后来出现种种问题，就没用，直接用jar包，下次熟练了再用maven搭一个。废话不说，直接开始。
2、版本介绍



3、新建一个web项目SSM



4、引入jar包，附录会有jar包下载地址，这里我的jar包比较多，里面很多是源码包，因为有时自己要看，就导进来了。










5、构建项目包框架，养成好习惯。



6、引入jdbc和log4j属性文件到properties下
jdbc.properties
####################################
# Database ConnectivityProperties
####################################
 
driver=com.mysql.jdbc.Driver
url=jdbc\:mysql\://127.0.0.1\:3306/ssm?useUnicode\=true&amp;characterEncoding\=UTF-8
username=root
password=123456
#\u5B9A\u4E49\u521D\u59CB\u8FDE\u63A5\u6570
initialSize=0
#\u5B9A\u4E49\u6700\u5927\u8FDE\u63A5\u6570
maxActive=20
#\u5B9A\u4E49\u6700\u5927\u7A7A\u95F2
maxIdle=20
#\u5B9A\u4E49\u6700\u5C0F\u7A7A\u95F2
minIdle=1
#\u5B9A\u4E49\u6700\u957F\u7B49\u5F85\u65F6\u95F4
maxWait=60000
 
log4j.properties
#\u5b9a\u4e49LOG\u8f93\u51fa\u7ea7\u522b
log4j.rootLogger=DEBUG,INFO,Console,File
#\u5b9a\u4e49\u65e5\u5fd7\u8f93\u51fa\u76ee\u7684\u5730\u4e3a\u63a7\u5236\u53f0
log4j.appender.Console=org.apache.log4j.ConsoleAppender
log4j.appender.Console.Target=System.out
#\u53ef\u4ee5\u7075\u6d3b\u5730\u6307\u5b9a\u65e5\u5fd7\u8f93\u51fa\u683c\u5f0f\uff0c\u4e0b\u9762\u4e00\u884c\u662f\u6307\u5b9a\u5177\u4f53\u7684\u683c\u5f0f
log4j.appender.Console.layout =org.apache.log4j.PatternLayout
log4j.appender.Console.layout.ConversionPattern=[%-5p]%d{yyyy-MM-dd
HH\:mm\:ss}\:%m%n
 
#\u6587\u4ef6\u5927\u5c0f\u5230\u8fbe\u6307\u5b9a\u5c3a\u5bf8\u7684\u65f6\u5019\u4ea7\u751f\u4e00\u4e2a\u65b0\u7684\u6587\u4ef6
log4j.appender.File = org.apache.log4j.RollingFileAppender
#\u6307\u5b9a\u8f93\u51fa\u76ee\u5f55
log4j.appender.File.File = logs/ssm.log
#\u5b9a\u4e49\u6587\u4ef6\u6700\u5927\u5927\u5c0f
log4j.appender.File.MaxFileSize= 10MB
# \u8f93\u51fa\u6240\u4ee5\u65e5\u5fd7\uff0c\u5982\u679c\u6362\u6210DEBUG\u8868\u793a\u8f93\u51faDEBUG\u4ee5\u4e0a\u7ea7\u522b\u65e5\u5fd7
log4j.appender.File.Threshold =ALL
log4j.appender.File.layout = org.apache.log4j.PatternLayout
log4j.appender.File.layout.ConversionPattern=[%p][%d{yyyy-MM-dd
HH\:mm\:ss}][%c]%m%n
 
log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.Target=System.out
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%d{ABSOLUTE}%5p
%c{1}:%L-
%m%n
 
 
log4j.logger.com.ibatis = DEBUG
log4j.logger.com.ibatis.common.jdbc.SimpleDataSource= 
DEBUG 
log4j.logger.com.ibatis.common.jdbc.ScriptRunner= 
DEBUG 
log4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate= 
DEBUG 
 
log4j.logger.java.sql.ResultSet= INFO
log4j.logger.org.apache = INFO
log4j.logger.java.sql.Connection= DEBUG
log4j.logger.java.sql.Statement= DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
 
 
7、建立spring-mybatis.xml配置文件
这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是 自动扫描，自动注入，配置数据库 。
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd 
                       http://www.springframework.org/schema/context 
                       http://www.springframework.org/schema/context/spring-context-3.1.xsd 
                        http://www.springframework.org/schema/mvc 
                       http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd">
    <context:annotation-config/>
    
    <!-- 自动扫描 -->
    <context:component-scanbase-package="com.ws"/>
    <!-- 引入配置文件 -->
    <beanid="propertyConfigurer"
       class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
       <!-- <propertyname="location" value="classpath:jdbc.properties" />-->
       <propertyname="locations">
           <list>
              <value>classpath:log4j.properties</value>
              <value>classpath:jdbc.properties</value>
           </list>
       </property>
    </bean>
    
    <beanid="dataSource"class="org.apache.commons.dbcp.BasicDataSource"
       destroy-method="close">
       <propertyname="driverClassName"value="${driver}"/>
       <propertyname="url"value="${url}"/>
       <propertyname="username"value="${username}"/>
       <propertyname="password"value="${password}"/>
       <!-- 初始化连接大小 -->
       <propertyname="initialSize"value="${initialSize}"></property>
       <!-- 连接池最大数量 -->
       <propertyname="maxActive"value="${maxActive}"></property>
       <!-- 连接池最大空闲 -->
       <propertyname="maxIdle"value="${maxIdle}"></property>
       <!-- 连接池最小空闲 -->
       <propertyname="minIdle"value="${minIdle}"></property>
       <!-- 获取连接最大等待时间 -->
       <propertyname="maxWait"value="${maxWait}"></property>
    </bean>
 
    <!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件
 -->
    <beanid="sqlSessionFactory"class="org.mybatis.spring.SqlSessionFactoryBean">
       <propertyname="dataSource"ref="dataSource"/>
       <propertyname="configLocation"value="classpath:sqlMapConfig.xml"/>
       <propertyname="typeAliasesPackage"value="com.ws.poi"/>
       <!-- mapper配置路径 -->
       <!-- 自动扫描mapper.xml文件 -->
       <!-- mapper配置路径 -->
       <propertyname="mapperLocations">
           <list>
              <!-- 表示在com.ws.map包或以下所有目录中，以-mapper.xml结尾所有文件
 -->
              <value>classpath:com/ws/mapper/**/*.xml</value>
           </list>
       </property>
    </bean>
 
    <!-- 扫描Mapper中的抽象类 ,实例化之后会自动装配-->
    <beanclass="org.mybatis.spring.mapper.MapperScannerConfigurer">
       <propertyname="basePackage"value="com.ws.mapper"/>
       <propertyname="markerInterface"value="com.ws.mapper.SqlMapper"/>
    </bean>
 
    <!-- (事务管理)transaction manager, use JtaTransactionManager forglobaltx -->
    <beanid="transactionManager"
       class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
       <propertyname="dataSource"ref="dataSource"/>

    </bean>
 
</beans>
 
8、创建数据库ssm，创建表user,再往数据库添加一条记录
CREATE TABLE `user` (
`id` int NULL AUTO_INCREMENT ,
`name` varchar(30) NULL ,
`password` varchar(20) NULL ,
`age` int NULL ,
PRIMARY KEY (`id`)
)
;



9、编写实体类user
package com.ws.poi.user;
 
import java.io.Serializable;
 
/**
 *@descriptionTODO
 *@time 2015-8-18下午2:26:30
 *@authorweis
 *@version 1.0
 **/
public 
class User implements Serializable{
    private 
static final 
long serialVersionUID = 704975107463848089L;
    private Integerid;
    private Stringname;
    private Stringpassword;
    private Integerage;
    public Integer getId() {
       returnid;
    }
    public 
void setId(Integer id) {
       this.id = id;
    }
    public String getName() {
       returnname;
    }
    public 
void setName(String name) {
       this.name = name;
    }
    public String getPassword() {
       returnpassword;
    }
    public 
void setPassword(String password) {
       this.password = password;
    }
    public Integer getAge() {
       returnage;
    }
    public 
void setAge(Integer age) {
       this.age = age;
    }
    
}
10、编写service和service实现类userServiceImpl
UserService：
package com.ws.service.user;
 
import java.util.List;
 
import com.ws.poi.user.User;
 
/**
 *@description TODO
 *@time 2015-8-18 下午2:29:02
 *@author weis
 *@version 1.0
 **/
public interface UserService<T> {
         
         publicUser getUserById(Integer id);
 
         publicList<User> getUserList();
 
}
 
 
UserServiceImpl:
package com.ws.service.user.impl;
 
import java.util.List;
 
import javax.annotation.Resource;
 
import org.springframework.stereotype.Service;
 
import com.ws.dao.user.UserDao;
import com.ws.poi.user.User;
import com.ws.service.user.UserService;
 
/**
 *@description TODO
 *@time 2015-8-18 下午2:29:50
 *@author weis
 *@version 1.0
 **/
@Service
public class UserServiceImpl<T extends User>implements UserService<T> {
         
         @Resource
         privateUserDao<User> dao;
 
         publicUser getUserById(Integer id) {
                   //TODO Auto-generated method stub
                   returndao.getUserById(id);
         }
 
         publicList<User> getUserList() {
                   //TODO Auto-generated method stub
                   returndao.getUserList();
         }
 
}
 
11、编写dao和对应的实现类
UserDao：
package com.ws.dao.user;
 
import java.util.List;
 
import com.ws.poi.user.User;
 
/**
 *@description TODO
 *@time 2015-8-18 下午2:31:15
 *@author weis
 *@version 1.0
 **/
public interface UserDao<T> {
 
         /**
          * 
          * @Description: 
          * @param id
          * @return
          * @return User
          * @author weis
          * @date 2015-8-18下午2:31:33
          */
         publicUser getUserById(Integer id);
 
         publicList<User> getUserList();
 
}
 
UserDaoImpl：
package com.ws.dao.user.impl;
 
import java.util.List;
 
import javax.annotation.Resource;
 
importorg.springframework.stereotype.Repository;
 
import com.ws.dao.user.UserDao;
import com.ws.mapper.user.UserMapper;
import com.ws.poi.user.User;
 
/**
 *@description TODO
 *@time 2015-8-18 下午2:31:58
 *@author weis
 *@version 1.0
 **/
@Repository
public class UserDaoImpl<T extendsUser> implements UserDao<T> {
         
         @Resource
         privateUserMapper<User> mapper;
 
         publicUser getUserById(Integer id) {
                   //TODO Auto-generated method stub
                   returnmapper.getUserById(id);
         }
 
         publicList<User> getUserList() {
                   //TODO Auto-generated method stub
                   returnmapper.getUserList();
         }
 
}
 
12、编写对应的Mapper和mapper.xml文件
UserMapper:
package com.ws.mapper.user;
 
import java.util.List;
 
import com.ws.mapper.SqlMapper;
import com.ws.poi.user.User;
 
/**
 *@description TODO
 *@time 2015-8-18 下午2:33:46
 *@author weis
 *@version 1.0
 **/
public interface UserMapper<T>extends SqlMapper{
 
         /**
          * 
          * @Description: 
          * @param id
          * @return
          * @return User
          * @author weis
          * @date 2015-8-18下午2:33:57
          */
         publicUser getUserById(Integer id);
 
         publicList<User> getUserList();
 
}
user-mapper.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEmapper
PUBLIC "-//mybatis.org//DTDMapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 
<!-- namespace和定义的Mapper接口对应，并实现其中的方法 -->
<mappernamespace="com.ws.mapper.user.UserMapper">
 
    <resultMapid="UserResultMap"type="com.ws.poi.user.User">
       <resultproperty="id"column="id"/>
       <resultproperty="name"column="name"/>
       <resultproperty="password"column="password"/>
       <resultproperty="age"column="age"/>
    </resultMap>
    
    
    <selectid="getUserById"parameterType="int"resultType="User"resultMap="UserResultMap">
       select * from user where id = #{id}
    </select>
 
    <selectid="getUserList"resultMap="UserResultMap"resultType="User">
       select * from user
    </select>
 
 
</mapper>
 
13、所有的mapper继承SqlMapper
package com.ws.mapper;
 
public 
interface SqlMapper{
 
}
 
14、引入sqlMapConfig.xml，主要是为了设置别名，在spring-mybatis.xml中也要配置sqlMapConfig.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEconfiguration
PUBLIC"-//mybatis.org//DTDConfig 3.0//EN"

 "http://mybatis.org/dtd/mybatis-3-config.dtd">
 
<configuration>
    <!-- 配置设置 -->
    <settings>
    <!-- 配置全局性 cache的 (
开 / 
关) default:true -->
       <settingname="cacheEnabled"value="true"/>
       
       <!-- 是否使用懒加载关联对象 同
hibernate中的延迟加载一样  default:true -->
       <settingname="lazyLoadingEnabled"value="true"/>
       
       <!-- [当对象使用延迟加载时属性的加载取决于能被引用到的那些延迟属性,否则,按需加载(需要的是时候才去加载)]
 -->
       <settingname="aggressiveLazyLoading"value="true"/>
       
       <!-- 是否允许单条sql返回多个数据集  (取决于驱动的兼容性)
 default:true -->
       <settingname="multipleResultSetsEnabled"value="true"/>
       
       <!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true-->
       <settingname="useColumnLabel"value="true"/>
       
       <!--允许JDBC生成主键。需要驱动器支持。如果设为了true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false-->
       <settingname="useGeneratedKeys"value="false"/>
       
       <!--指定 MyBatis如何自动映射数据基表的列 NONE：不隐射　PARTIAL:部分 
 FULL:全部-->
       <settingname="autoMappingBehavior"value="PARTIAL"/>
       
       <!-- 这是默认的执行类型
           SIMPLE :简单 
           REUSE:执行器可能重复使用prepared statements语句
           BATCH:执行器可以重复执行语句和批量更新
       -->
       <settingname="defaultExecutorType"value="SIMPLE"/>
       
       <!-- 设置驱动等待数据响应的超时数 默认没有设置-->
       <settingname="defaultStatementTimeout"value="25000"/>
       
       <!-- [是否启用行内嵌套语句  defaut:false]-->
       <settingname="safeRowBoundsEnabled"value="false"/>
       
       <!-- [是否启用 数据中 A_column自动映射到
 java类中驼峰命名的属性 default:fasle] -->
       <settingname="mapUnderscoreToCamelCase"value="false"/>
       
       <!-- 设置本地缓存范围 session:就会有数据的共享  statement:语句范围
 (这样就不会有数据的共享 ) defalut:session -->
       <settingname="localCacheScope"value="SESSION"/>
       
       <!-- 设置但JDBC类型为空时,某些驱动程序要指定值,default:other
 -->
       <settingname="jdbcTypeForNull"value="OTHER"/>
       
       <!-- 设置触发延迟加载的方法  -->
       <settingname="lazyLoadTriggerMethods"value="equals,clone,hashCode,toString"/>
       
    </settings>
 
    <!-- 别名 -->
    <typeAliases>
       <typeAliastype="com.ws.poi.user.User"alias="User"/>
    </typeAliases>
</configuration>
 
15、建立测试类：
package com.junit.test;
 
 
import org.apache.log4j.Logger;
import org.junit.Before;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
importorg.springframework.context.support.ClassPathXmlApplicationContext;
 
import com.ws.poi.user.User;
import com.ws.service.user.UserService;
 
/**
 *@descriptionTODO
 *@time 2015-8-18下午2:42:51
 *@authorweis
 *@version 1.0
 **/
public 
class TestMybatis {
      private 
static Logger logger = Logger.getLogger(TestMybatis.class);
      private ApplicationContextac =null;
      privateUserService<User>userService =
null;
 
      @SuppressWarnings("unchecked")
    @Before
      public 
void before() {
         ac = newClassPathXmlApplicationContext("spring-mybatis.xml");
         userService = 
ac.getBean(UserService.class);
      }
 
      @Test
      public 
void test1() {
        User user = userService.getUserById(1);
         System.out.println(user.getName());
         logger.info("值："+user.getName());
      }}
 
 
 
16、测试结果，成功

 
17、配置spring-mvc.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<beansxmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xsi:schemaLocation="http://www.springframework.org/schema/beans 
                       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd 
                       http://www.springframework.org/schema/context 
                       http://www.springframework.org/schema/context/spring-context-3.1.xsd 
                       http://www.springframework.org/schema/mvc 
                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd">
    <!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器
 -->
    <context:component-scanbase-package="com.ws.controller"/>
    <!--避免IE执行AJAX时，返回JSON出现下载文件
 -->
    <beanid="mappingJacksonHttpMessageConverter"
       class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
       <propertyname="supportedMediaTypes">
           <list>
              <value>text/html;charset=UTF-8</value>
           </list>
       </property>
    </bean>
    <!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射
 -->
    <bean
       class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">
       <propertyname="messageConverters">
           <list>
              <refbean="mappingJacksonHttpMessageConverter"/>   <!--JSON转换器
 -->
           </list>
       </property>
    </bean>
    <!-- 定义跳转的文件的前后缀，视图模式配置-->
    <beanclass="org.springframework.web.servlet.view.InternalResourceViewResolver">
       <!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个可用的url地址
 -->
       <propertyname="prefix"value="/WEB-INF/jsp/"/>
       <propertyname="suffix"value=".jsp"/>
    </bean>
    
    <!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 -->
    <beanid="multipartResolver" 
       class="org.springframework.web.multipart.commons.CommonsMultipartResolver"> 
        <!-- 默认编码 -->
        <propertyname="defaultEncoding"value="utf-8"/> 

        <!-- 文件大小最大值 -->
        <propertyname="maxUploadSize"value="10485760000"/> 

        <!-- 内存中的最大值 -->
        <propertyname="maxInMemorySize"value="40960"/> 

    </bean>
 
</beans>
 
18、配置web.xml
<?xmlversion="1.0"encoding="UTF-8"?>
<web-appxmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://java.sun.com/xml/ns/javaee"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaeehttp://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    version="3.0">
    <display-name>Archetype CreatedWeb Application</display-name>
    <!-- Spring和mybatis的配置文件 -->
    <context-param>
       <param-name>contextConfigLocation</param-name>
       <param-value>classpath:spring-mybatis.xml</param-value>
    </context-param>
    <!-- 编码过滤器 -->
    <filter>
       <filter-name>encodingFilter</filter-name>
       <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
       <async-supported>true</async-supported>
       <init-param>
           <param-name>encoding</param-name>
           <param-value>UTF-8</param-value>
       </init-param>
    </filter>
    <filter-mapping>
       <filter-name>encodingFilter</filter-name>
       <url-pattern>/*</url-pattern>
    </filter-mapping>
    <!-- Spring监听器 -->
    <listener>
       <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <!-- 防止Spring内存溢出监听器 -->
    <listener>
        <listener-class>org.springframework.web.util.IntrospectorCleanupListener</listener-class>
    </listener>
 
    <!-- Spring MVC servlet -->
    <servlet>
       <servlet-name>SpringMVC</servlet-name>
       <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
       <init-param>
           <param-name>contextConfigLocation</param-name>
           <param-value>classpath:spring-mvc.xml</param-value>
       </init-param>
       <load-on-startup>1</load-on-startup>
       <async-supported>true</async-supported>
    </servlet>
    <servlet-mapping>
       <servlet-name>SpringMVC</servlet-name>
       <!-- 此处可以可以配置成*.do，对应struts的后缀习惯
 -->
       <url-pattern>/</url-pattern>
    </servlet-mapping>
    <welcome-file-list>
       <welcome-file>/index.jsp</welcome-file>
    </welcome-file-list>
 
</web-app>
 
19、建UserController
package com.ws.controller.user;
 
import java.util.List;
 
import javax.annotation.Resource;
importjavax.servlet.http.HttpServletRequest;
 
importorg.springframework.stereotype.Controller;
import org.springframework.ui.Model;
importorg.springframework.web.bind.annotation.RequestMapping;
 
import com.ws.poi.user.User;
import com.ws.service.user.UserService;
 
/**
 *@description TODO
 *@time 2015-8-24 下午5:46:55
 *@author weis
 *@version 1.0
 **/
@Controller
@RequestMapping("/user")
public class UserController {
         
         @Resource
         privateUserService<User> service;
         
         @RequestMapping("/showUser")
   public String toIndex(HttpServletRequest request,Model model){  
       User user = this.service.getUserById(1); 
       model.addAttribute("user", user);  
       return "user";  
    }
         
         @RequestMapping("/showUser1")
   public String getUserList(HttpServletRequest request,Model model){  
       List<User> users = this.service.getUserList();
       if(users.size()>0){
                User user = users.get(0);
                model.addAttribute("user",user);  
       }
       return "user";  
    }
         
 
}
 
20、建立测试页面user.jsp。
<%@ 
page language="java"import="java.util.*"pageEncoding="ISO-8859-1"%>
<%
String path =request.getContextPath();
String basePath =request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>
 
<!DOCTYPEHTML
PUBLIC "-//W3C//DTDHTML 4.01 Transitional//EN">
<html>
  <head>
    <basehref="<%=basePath%>">
    
    <title>My JSP 'user.jsp' starting page</title>
    
    <metahttp-equiv="pragma"content="no-cache">
    <metahttp-equiv="cache-control"content="no-cache">
    <metahttp-equiv="expires"content="0">   
    <metahttp-equiv="keywords"content="keyword1,keyword2,keyword3">
    <metahttp-equiv="description"content="This
 is my page">
    <!--
    <link rel="stylesheet"type="text/css"href="styles.css">
    -->
 
  </head>
  
<body> 
    ${user.name}  
  </body>
</html>
 
21、发布项目，访问。


 


至此简易项目环境搭建完成。
 
 
附录：
1、  项目完整框架：


2、  Jar包下载地址：
http://download.csdn.net/detail/weisong530624687/9047435

3、项目下载地址：
http://download.csdn.net/detail/weisong530624687/9046689
 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

2. 蛤蟆的计算机组成原理笔记二发展应用及相关知识
2. 蛤蟆的计算机组成原理笔记二发展应用及相关知识
         本篇名言：“自以为聪明的人往往是没有好下场的。世界上最聪明的人是最老实的人，因为只有老实人才能经得起事实和历史的考验。--周恩来”
         我们来继续看下计算机软硬件的相关知识。
 欢迎转载，转载请标明出处：http://blog.csdn.net/notbaron/article/details/47959409
1.  计算机硬件系统的组成
先来看下，冯·诺依曼计算机硬件框图1
 

运算器（完成算术运算，逻辑运算）
主存储器（存放程序以及数据）
控制器（控制指令的执行序列，根据指令的功能给出实现指令功能所需要的控制信号）
输入设备，能将人能够识别的信息形式转换为机器能够识别的形式
输出设备
         组成框架如下：

 
 
 
1.1             CPU的组成
 1. 控制器
   从内存取出一条指令,并指出下条指令的地址;
    对指令进行译码,产生相应的控制信号;
    指挥并控制CPU,内存和I/O设备之间的数据传送.
 2.运算器
      加工信息.包括:算术运算， 逻辑运算
需要注意：寄存器、总线的位宽/字长。
                具体如下图：

 
1.2             数字技术
l  处理
    CPU, DSP, ASIC
l  传输
    总线(CPU内部、系统总线, I/O总线),  
    网络（LAN，WAN，INTERNET,无线网）
l  存储
     RAM，ROM，FLASH，硬盘，光盘，存储系统（RAID，SAN ，NAS）
 
PS：Moore 定律：微芯片上集成的晶体管数目每三年翻两番
 
 
2.  软件系统
l  计算机硬件是载体，软件是灵魂。
l  可运行的思想和内容的数字化
    思想：算法、规律、办法---程序表达
    内容：图形、图像、数据、声音、文字等
归结为程序和数据（统称二进制表示的信息）
l  软件的核心: 算法
    (一个好的算法可以代替大量的硬件: FFT,MPEG) 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式： 策略模式的实现
1.    策略模式:定义了算法族，分别封装起来，让它们之间可以替换，此模式让算法的变化独立于使用该算法的用户。（利用组合）


类图如下:
 





源代码如下：
package Strategy;
/**
 * 鸭子超类
 * @author Arvon
 *
 */
public abstract class Duck {
	public Duck() {
		super();
		// TODO Auto-generated constructor stub
	}
	 FlyBehavior mFlyBehavior; //has A 组合行为
	 QuackBehavior mQuackBehavior; //has A 组合行为
	public void swim(){
		System.out.println("All ducks float, even decoys!");
	}
	public abstract void display();
	public   void performFly(){
		mFlyBehavior.fly(); //委托给行为类处理
	}
	public   void performQuack(){
		mQuackBehavior.quack(); //委托给行为类处理
	}
	public void setmFlyBehavior(FlyBehavior mFlyBehavior) {
		this.mFlyBehavior = mFlyBehavior;
	}
	public void setmQuackBehavior(QuackBehavior mQuackBehavior) {
		this.mQuackBehavior = mQuackBehavior;
	}
		
	

}


package Strategy;
/**
 * 飞行类鸭子的接口
 * @author Administrator
 *
 */
public interface FlyBehavior {
	public void fly();
}


package Strategy;
/**
 * 叫行为鸭子接口
 * @author Administrator
 *
 */
public interface QuackBehavior {
	public void quack();
}


package Strategy;

public class FlyNoWays implements FlyBehavior {

	@Override
	public void fly() {
		System.out.println("I can't fly");
	}

}

package Strategy;

public class FlyRocketPowered implements FlyBehavior {

	@Override
	public void fly() {
		// TODO Auto-generated method stub
		System.out.println("I'm flying with a rocket");
	}

}


package Strategy;

public class FlyWithWings implements FlyBehavior {

	@Override
	public void fly() {
		System.out.println("I'm flying!!");
	}

}

package Strategy;

public class Quack implements QuackBehavior {

	@Override
	public void quack() {
		// TODO Auto-generated method stub
		System.out.println("Quack");
	}

}

package Strategy;

public class MuteQuack implements QuackBehavior {

	@Override
	public void quack() {
		// TODO Auto-generated method stub
		System.out.println("<< Silence >>");
	}

}

package Strategy;

public class Squeak implements QuackBehavior {

	@Override
	public void quack() {
		System.out.println("Squeak");

	}

}

package Strategy;

public class MallardDuck extends Duck {
	
	
	/**
	 * 申明我是一只用翅膀飞并会嘎嘎叫的鸭子
	 */
	public MallardDuck() {
		super();
		mFlyBehavior = new FlyWithWings();
		mQuackBehavior = new Quack();
	}

	@Override
	public void display() {
		System.out.println("I'm a real Mallard duck");
	}

}


package Strategy;

public class DecoyDuck extends Duck {
	/**
	 * 申明我是一只不会叫也不会飞的鸭子
	 */
	public DecoyDuck() {
		super();
		// TODO Auto-generated constructor stub
		mFlyBehavior = new FlyNoWays();
		mQuackBehavior = new MuteQuack();
	}

	@Override
	public void display() {
		System.out.println("I'm a duck Decoy");

	}

}


package Strategy;

public class ModelDuck extends Duck {

	
	public ModelDuck() {
		super();
		// TODO Auto-generated constructor stub
		mFlyBehavior = new FlyNoWays();
		mQuackBehavior = new Quack();
	}

	@Override
	public void display() {
		System.out.println("I'm a model duck");
	}

}


package Strategy;
/**
 * 测试类
 * @author Administrator
 *
 */
public class MiniDuckSimulator {

	public static void main(String[] args) {
		Duck mallard = new MallardDuck();
		mallard.performFly();
		mallard.performQuack();
		mallard.display();
		
		Duck decoy = new DecoyDuck();
		decoy.performFly();
		decoy.performQuack();
		decoy.display();
		
		Duck model = new ModelDuck();
		model.performFly();;
		model.performQuack();
		model.display();
		//动态地改变鸭子的行为
		model.setmFlyBehavior(new FlyRocketPowered());
		model.performFly();;
		model.performQuack();
		model.display();
	}

}


程序的输出：


I'm flying!!
Quack
I'm a real Mallard duck
I can't fly
<< Silence >>
I'm a duck Decoy
I can't fly
Quack
I'm a model duck
I'm flying with a rocket
Quack
I'm a model duck






版权声明：本文为博主原创文章，未经博主允许不得转载。

JDBC DAO

前言：
JDBC是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC，
很多时候我们有必要了解jdbc怎么访问数据库；
介绍以下几个接口：
Java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现
                在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现
加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名
DriverManager 类是驱动程序管理器类负责管理驱动程序，通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，
因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注
册自身的一个实例
Statement：通过调用 Connection 对象的 createStatement 方法创建该对象，该对象用于执行静态的 SQL 语句，并且返回执行结果
Statement 接口中定义了下列方法用于执行 SQL 语句：
ResultSet excuteQuery(String sql) ,int excuteUpdate(String sql)

PreparedStatement:可以通过调用 Connection 对象的 preparedStatement() 方法获取 PreparedStatement 对象
PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句
PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement
对象的 setXXX() 方法来设置这些参数. setXXX() 方法有两个参数，第一个参数是要设置的 SQL 
语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值
PreparedStatement vs Statement:代码的可读性和可维护性. 
PreparedStatement 能最大可能提高性能：
DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句
在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预
编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行；
在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,
没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存.这样每执
行一次都要对传入的语句编译一次；
(语法检查，语义检查，翻译成二进制命令，缓存)
PreparedStatement 可以防止 SQL 注入 

SQL 注入攻击：SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 
SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法对于 Java 而言，要防范 SQL 注入，
只要用 PreparedStatement 取代 Statement 就可以了

ResultSet:  通过调用 Statement 对象的 excuteQuery() 方法创建该对象;
ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商实现
ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet
对象的 next() 方法移动到下一行

DatabaseMetaData：Java 通过JDBC获得连接以后，得到一个Connection 对象，可以从这个对象获得有关数据库管理
系统的各种信息，包括数据库中的各个表，表中的各个列，数据类型，触发器，存储过程等各方面
的信息。根据这些信息，JDBC可以访问一个实现事先并不了解的数据库。获取这些信息的方法都是
在DatabaseMetaData类的对象上实现的，而DataBaseMetaData对象是在Connection对象上获得的。
DatabaseMetaData 类中提供了许多方法用于获得数据源的各种信息，通过这些方法可以非常详细的
了解数据库的信息：
getURL()：返回一个String类对象，代表数据库的URL。
getUserName()：返回连接当前数据库管理系统的用户名。
isReadOnly()：返回一个boolean值，指示数据库是否只允许读操作。
getDatabaseProductName()：返回数据库的产品名称。
getDatabaseProductVersion()：返回数据库的版本号。
getDriverName()：返回驱动驱动程序的名称。
getDriverVersion()：返回驱动程序的版本号。


案例:以下为基于JDBC DAO层的实现，代码精辟;
/*
 * 文件名：Dao.java
 * 版权：Copyright by www.huawei.com
 * 描述：
 * 修改人：Cuigaochong
 * 修改时间：2015-8-23
 * 跟踪单号：
 * 修改单号：
 * 修改内容：
 */

package com.jdbc.cgc.dao;

import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.commons.beanutils.BeanUtils;

/**
 * <一句话功能简述>JDBC DAO精辟代码 <功能详细描述>
 * 
 * @author 姓名 工号
 * @version [版本号, 2015-8-23]
 * @see [相关类/方法]
 * @since [产品/模块版本]
 */
public class Dao
{
    
    /**
     * <一句话功能简述>获取一个查询 项 <功能详细描述>
     * 
     * @param <E>
     * @param sql
     * @param args
     * @return
     * @see [类、类#方法、类#成员]
     */
    public <E> E getForValue(String sql, Object... args)
    {
        Connection conn = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        
        try
        {
            conn = getConn();
            preparedStatement = conn.prepareStatement(sql);
            for (int i = 0; i < args.length; i++)
            {
                preparedStatement.setObject(i + 1, args[i]);
            }
            resultSet = preparedStatement.executeQuery();
            if (resultSet.next())
            {
                ResultSetMetaData rsmd = preparedStatement.getMetaData();
                String labelName = rsmd.getColumnLabel(1);
                return (E)resultSet.getObject(labelName);
            }
            
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        finally
        {
            releaseSource(preparedStatement, conn, resultSet);
        }
        
        return null;
        
    }
    
    /**
     * <一句话功能简述>查询单条记录数据 <功能详细描述>
     * 
     * @param <T>
     * @param sql
     * @param clazz
     * @param args
     * @return
     * @see [类、类#方法、类#成员]
     */
    public <T> T getForSingle(String sql, Class<T> clazz, Object... args)
    {
        List<T> list = getForList(sql, clazz, args);
        if (0 < list.size())
        {
            return list.get(0);
        }
        return null;
    }
    
    /**
     * <一句话功能简述>查询多条记录数据 <功能详细描述>
     * 
     * @param <T>
     * @param sql
     * @param clazz
     * @param args
     * @return
     * @see [类、类#方法、类#成员]
     */
    public <T> List<T> getForList(String sql, Class<T> clazz, Object... args)
    {
        Connection conn = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        List<T> entryList = null;
        
        try
        {
            // 1：得到结果集
            conn = getConn();
            preparedStatement = conn.prepareStatement(sql);
            
            // 将参数放到preparedStatement的未知参数中
            for (int i = 0; i < args.length; i++)
            {
                preparedStatement.setObject(i + 1, args[i]);
            }
            
            resultSet = preparedStatement.executeQuery();
            // 2:处理结果集得到Map对应的List
            List<Map<String, Object>> list = handleResultSetoToMapList(resultSet);
            
            // 3:将List<Map<String,object>>转化成List<T>
            entryList = transfterMapListToBeanList(clazz, list);
            
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        finally
        {
            releaseSource(preparedStatement, conn, resultSet);
        }
        
        return entryList;
    }
    
    /**
     * <一句话功能简述>数据库的增删改 <功能详细描述>
     * 
     * @param sql
     * @param args
     * @see [类、类#方法、类#成员]
     */
    public void update(String sql, Object... args)
    {
        Connection conn = null;
        PreparedStatement preparedStatement = null;
        ResultSet result = null;
        
        try
        {
            conn = getConn();
            preparedStatement = conn.prepareStatement(sql);
            
            // 将参数放到preparedStatement的未知参数中
            for (int i = 0; i < args.length; i++)
            {
                preparedStatement.setObject(i + 1, args[i]);
            }
            
            result = preparedStatement.executeQuery();
            
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        finally
        {
            releaseSource(preparedStatement, conn, result);
        }
    }
    
    /**
     * <一句话功能简述>将MapList转化成BeanList <功能详细描述>
     * 
     * @param <T>
     * @param clazz
     * @param list
     * @return
     * @throws InstantiationException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     * @see [类、类#方法、类#成员]
     */
    private <T> List<T> transfterMapListToBeanList(Class<T> clazz, List<Map<String, Object>> list)
        throws InstantiationException, IllegalAccessException, InvocationTargetException
    {
        List<T> entryList;
        entryList = new ArrayList<T>();
        if (0 < list.size())
        {
            for (int i = 0; i < list.size(); i++)
            {
                T entity = clazz.newInstance();
                Map<String, Object> map = list.get(i);
                for (Map.Entry<String, Object> tempEntry : map.entrySet())
                {
                    String fieldName = tempEntry.getKey().toLowerCase();
                    Object fieldValues = tempEntry.getValue();
                    // ReflectionUtils.setFieldValue(entity, fieldName, fieldValues);
                    BeanUtils.setProperty(entity, fieldName, fieldValues);
                }
                entryList.add(entity);
            }
        }
        return entryList;
    }
    
    /**
     * <一句话功能简述>将resultSet转化成list<Map<String,Object>> <功能详细描述>
     * 
     * @param resultSet
     * @return
     * @throws SQLException
     * @see [类、类#方法、类#成员]
     */
    private List<Map<String, Object>> handleResultSetoToMapList(ResultSet resultSet)
        throws SQLException
    {
        List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();
        List<String> labelsList = getColumnLabels(resultSet);
        
        while (resultSet.next())
        {
            Map<String, Object> map = new HashMap<String, Object>();
            for (String columnLabel : labelsList)
            {
                Object value = resultSet.getObject(columnLabel);
                map.put(columnLabel, value);
            }
            
            list.add(map);
        }
        return list;
    }
    
    // 以下将很多公用的方法重构 抽取
    
    /**
     * <一句话功能简述>:获取结果集的columnLabel <功能详细描述>
     * 
     * @param rs
     * @return
     * @throws SQLException
     * @see [类、类#方法、类#成员]
     */
    private List<String> getColumnLabels(ResultSet rs)
        throws SQLException
    {
        List<String> labels = new ArrayList<String>();
        ResultSetMetaData metaData = rs.getMetaData();
        for (int i = 0; i < metaData.getColumnCount(); i++)
        {
            //获取列的别名
            labels.add(metaData.getColumnLabel(i + 1));
        }
        
        return labels;
    }
    
    /**
     * <一句话功能简述> 连接数据库 <功能详细描述>
     * 
     * @return
     * @throws Exception
     * @see [类、类#方法、类#成员]
     */
    public Connection getConn()
        throws Exception
    {
        String dirverName = null;
        String jdbcUrl = null;
        String user = null;
        String password = null;
        
        Properties propertoes = new Properties();
        InputStream is = getClass().getClassLoader().getResourceAsStream("jdbc.properties");
        propertoes.load(is);
        
        dirverName = propertoes.getProperty("driver");
        jdbcUrl = propertoes.getProperty("jdbcURL");
        user = propertoes.getProperty("user");
        password = propertoes.getProperty("password");
        
        Class.forName(dirverName);
        
        // 通过DriverManager的getConnection获取数据库连接
        Connection connection = DriverManager.getConnection(jdbcUrl, user, password);
        
        return connection;
    }
    
    /**
     * <一句话功能简述>释放数据库资源 <功能详细描述>
     * 
     * @param statement
     * @param conn
     * @param resultSet
     * @see [类、类#方法、类#成员]
     */
    public void releaseSource(Statement statement, Connection conn, ResultSet resultSet)
    {
        if (null != resultSet)
        {
            try
            {
                resultSet.close();
            }
            catch (SQLException e)
            {
                e.printStackTrace();
            }
        }
        
        if (null != statement)
        {
            try
            {
                statement.close();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
        if (null != conn)
        {
            try
            {
                conn.close();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

利用Struts进行图片上传
利用Struts进行图片上传在struts.xml文件中配置：<!-- 上传文件临时文件位置 -->
<constant name="struts.multipart.saveDir" value="/tmp"/>
<constant name="struts.multipart.maxSize" value="1000000000"/>

package edu.ING.ING_pro_school.school.action;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Date;

import org.apache.struts2.ServletActionContext;


public class SetFaceAction {

  private static final long serialVersionUID =1L;

  private static final int BUFFER_SIZE =16*1024;

  // 页面图片
  private File photoFile;

  // 图片名
  private String photoFileFileName;

  // 图片类型
  private String photoFileContentType;

  private String img;

  public String getImg() {
    return img;
  }

  public void setImg(String img) {
    this.img = img;
  }

  public File getPhotoFile() {
    return photoFile;
  }

  public void setPhotoFile(File photoFile) {
    this.photoFile = photoFile;
  }

  public String getPhotoFileFileName() { return photoFileFileName;
  }

  public void setPhotoFileFileName(String photoFileFileName) {
    this.photoFileFileName = photoFileFileName;
  }

  public String getPhotoFileContentType() {
    return photoFileContentType;
  }

  public void setPhotoFileContentType(String photoFileContentType) {
    this.photoFileContentType = photoFileContentType;
  }

  /*
   * 取得运行时服务器目录
   *
   * @return 服务器根目录
   */

  public String getSavePath() {
    // 如果是从服务器上取就用这个获得系统的绝对路径方法。
    return ServletActionContext.getServletContext().getRealPath("/");
  }

  public String download() throws UnsupportedEncodingException {
    String path = getSavePath() +"\\UploadImages\\"+this.getImg();   System.out.println("path is "+ path);
    BufferedInputStream bis =null;
    BufferedOutputStream bos =null;
    OutputStream fos =null;
    InputStream fis =null;

    String filepath = path;
    System.out.println("文件路径"+ filepath);
    File uploadFile =new File(filepath);
    try {
      fis =new FileInputStream(uploadFile);
      bis =new BufferedInputStream(fis);
      fos = ServletActionContext.getResponse().getOutputStream();
      bos =new BufferedOutputStream(fos);
      // 这个就就是弹出下载对话框的关键代码
      ServletActionContext.getResponse().setHeader("Content-disposition",
          "attachment;filename="+ URLEncoder.encode(path, "gbk"));
      int bytesRead =0;
      // 这个地方的同上传的一样。我就不多说了，都是用输入流进行先读，然后用输出流去写，唯一不同的是我用的是缓冲输入输出流
      byte[] buffer =new byte[8192];
      while ((bytesRead = bis.read(buffer, 0, 8192)) !=-1) {
        bos.write(buffer, 0, bytesRead);
      }
      bos.flush();
      fis.close();
      bis.close();
      fos.close();
      bos.close();
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return null;
  }
/**
 * 上传图片
 * 修改
  * @return
 * @throws Exception
 */
  public String setFace() throws Exception {
    if (null!=this.getPhotoFile()) {
      // 从画面上取得图片文件
      File files =this.getPhotoFile();
      // 文件名 = 文件名 + 日期
      photoFileFileName =new Date().getTime() + photoFileFileName.trim();
      String savePath = getSavePath() +"\\UploadImages\\";
      // 判断保存用文件夹是否存在
      mkdir(savePath);
      // 保存用的数据流生成
      FileOutputStream fos =new FileOutputStream(savePath + photoFileFileName);
      System.out.println(savePath + photoFileFileName);
      // 保存文件
      FileInputStream fis =new FileInputStream(files);
      byte[] buffer =new byte[BUFFER_SIZE];
      int len =0;
      while ((len = fis.read(buffer)) >0) {
        fos.write(buffer, 0, len);
      }
    }
    return"";
  }

  /*
   * 判断保存用文件夹是否存在
   *Java中文网:http://www.javaweb.cc
   * @param path 保存用的文件夹路径
   */
  public void mkdir(String path) {
    File file =new File(path);
    // 如果存在
    if (file.exists()) {
      System.out.println("the dir is exits");
      // 如果不存在，新建
    } else {
      file.mkdir();
      System.out.println("have made a dir");
    }
  }
}

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

iOS UI19_数据库
//
//  Student.h
//  UI19_数据库
//
//  Created by dllo on 15/8/24.
//  Copyright (c) 2015年 zhozhicheng. All rights reserved.
//

#import <Foundation/Foundation.h>

@interface Student : NSObject

@property(nonatomic,copy)NSString *name;
@property(nonatomic,copy)NSString *sex;
@property(nonatomic,copy)NSString *hobby;
@property(nonatomic,assign)NSInteger age;

@end

//
//  dataBaseTool.h
//  UI19_数据库
//
//  Created by dllo on 15/8/24.
//  Copyright (c) 2015年 zhozhicheng. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <sqlite3.h>
#import "Student.h"
@interface dataBaseTool : NSObject
{
    //用来保存数据库对象的地址
    sqlite3 *dbPoint;
}

//为了保证当前数据库在工程里是唯一的,我们用单例方式创建一个数据库工具对象
+(dataBaseTool *)shareDataBaseTool;
//打开数据库
-(void)openDB;
//给数据库创建张表格,table
-(void)createTable;

//插入一个学生
-(void)insertStu:(Student *)stu;
//更新表里的学生
-(void)updateStu:(Student *)stu;
//删除表里学生
-(void)deleteStu:(Student *)stu;
//查询数据库中所有学生表里的数据
-(NSMutableArray *)selectAllStu;
@end

//
//  dataBaseTool.m
//  UI19_数据库
//
//  Created by dllo on 15/8/24.
//  Copyright (c) 2015年 zhozhicheng. All rights reserved.
//

#import "dataBaseTool.h"

@implementation dataBaseTool


+(dataBaseTool *)shareDataBaseTool
{
    static dataBaseTool *tool;
    static dispatch_once_t oneToKen;
    dispatch_once(&oneToKen, ^{
        tool = [[dataBaseTool alloc] init];
    });
    return tool;
}

-(void)openDB
{
    //数据库文件也保存在沙盒的documents文件里,所以先找到沙盒路径
    NSArray *sandBox = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *sandBoxPath = sandBox[0];
    //拼接文件路径,如果系统根据这个文件路径查找的时候有对应的文件则直接打开数据库,如果没有则会创建一个新的数据库
    NSString *documentPath = [sandBoxPath stringByAppendingPathComponent:@"Student.sqlite"];

    int result =sqlite3_open([documentPath UTF8String], &dbPoint);

    if (result == SQLITE_OK) {
        NSLog(@"打开成功");
        NSLog(@"%@",documentPath);

    }
    else{
        NSLog(@"打印失败");
    }
}

-(void)createTable
{
    //primary key 是主键的意思,主键在当前表里数据是唯一的,不能重复,可以唯一表示一条数据,一般是整数
    //autoincrement自增,为了让主键不重复,会让主键采用自增的方式
    //if not exists 如果没有表格才会创建,防止重复创建覆盖之前的数据
    //数据库问题90%是sql语句出问题,所以先保证语句没问题,再放到工程里使用
    NSString *sqlStr = @"create table if not exists stu(number integer primary key autoincrement,name text,sex text,age integer,hobby text)";
    //执行这条sql语句
    int result =sqlite3_exec(dbPoint, [sqlStr UTF8String], nil, nil, nil);
    if (result == SQLITE_OK) {
        NSLog(@"表创建成功");

    }
    else
    {
        NSLog(@"创建失败");
    }
}

-(void)insertStu:(Student *)stu{
    //语句里值的位置要加上单引号
    NSString *sqlStr = [NSString stringWithFormat:@"insert into stu (name, age, sex, hobby) values ('%@', '%ld', '%@', '%@')", stu.name, stu.age, stu.sex, stu.hobby];
    //执行sql语句
    int result = sqlite3_exec(dbPoint, [sqlStr UTF8String], nil, nil, nil);
    if (result == SQLITE_OK) {
        NSLog(@"添加成功");
    }
    else
    {
        NSLog(@"添加失败");
    }

}

-(void)updateStu:(Student *)stu
{
    NSString *sqlStr = [NSString stringWithFormat:@"update stu set sex = '%@', hobby = '%@', age = '%ld' where name = '%@' ", stu.sex, stu.hobby, stu.age, stu.name];
    //执行sql
    int result = sqlite3_exec(dbPoint, [sqlStr UTF8String], nil, nil, nil);
    NSLog(@"%@", sqlStr);
    if (result == SQLITE_OK) {
        NSLog(@"更新成功");
    }
    else
    {
        NSLog(@"更新失败");
        NSLog(@"%d",result);
    }
}

-(void)deleteStu:(Student *)stu
{
    NSString *sqlStr = [NSString stringWithFormat:@"delete from stu where name ='%@' ",stu.name];
    //执行sql
    int result = sqlite3_exec(dbPoint, [sqlStr UTF8String], nil, nil, nil);
    NSLog(@"%@", sqlStr);
    if (result == SQLITE_OK) {
        NSLog(@"删除成功");
    }
    else
    {
        NSLog(@"删除失败");
        NSLog(@"%d",result);
    }

}

-(NSMutableArray *)selectAllStu
{
    //查询的逻辑
    //1.先从本地的数据库中读取某张表里的所有数据
    //2.然后逐条读取,对model进行赋值
    //3.把已经赋值好的model放到数组中,并且返回
    NSString *sqlStr = @"select * from stu";
    //在语句里*是通配符的意思,通过一个*相当于代替了表里所有的字段名
    //接下来需要定义一个跟随指针,他用来遍历数据库表中的每行数据
    sqlite3_stmt *stmt = nil;
    //第三个参数:查询语句字数限制,-1是没有限制
    int result = sqlite3_prepare_v2(dbPoint, [sqlStr UTF8String], -1, &stmt, nil);
    //这个方法相当于把数据库和跟随指针相关联,一同完成查询功能
    //初始化一个用来装学生的数组
    NSMutableArray *stuArr = [NSMutableArray array];
    if (result == SQLITE_OK) {
        NSLog(@"查询成功");
        //开始遍历查询数据库的每一行数据
        while(sqlite3_step(stmt) == SQLITE_ROW){
            //让跟随指针进行遍历查询,如果没有行,才会停止循环
            //满足条件,则逐列读取每一行的数据
            //第二个参数表示当前这列数据在表里的第几列
            const unsigned char *name = sqlite3_column_text(stmt, 1);
            const unsigned char *sex =sqlite3_column_text(stmt, 2);
            int age = sqlite3_column_int(stmt, 3);
            const unsigned char *hobby =sqlite3_column_text(stmt, 4);
            //把列里的数据在进行类型的转换
            NSInteger stuAge = age;
            NSString *stuName = [NSString stringWithUTF8String:(const char *)name];
            NSString *stuSex = [NSString stringWithUTF8String:(const char *)sex];
            NSString *stuHobby = [NSString stringWithUTF8String:(const char *)hobby];
            //给对象赋值,然后把对象放到数组里
            Student *stu = [[Student alloc] init];
            stu.name =stuName;
            stu.hobby =stuHobby;
            stu.age =stuAge;
            stu.sex=stuSex;
            [stuArr addObject:stu];
            [stu release];
        }
    } else {
        NSLog(@"查询失败");
        NSLog(@"%d",result);
    }
    return stuArr;


}



@end


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

C++ 范式工厂

#ifndef TEMPLATE_H
#define TEMPLATE_H
#include <map>
template 
<
class AbstractProduct,
typename IdentifierType,
class ProductCreator = AbstractProduct*(*)(),
template <typename,class>
class FactoryErrorPolicy = DefaultFactoryError
>
class Factory
{
public:
bool Register(const IdentifierType& id ,ProductCreator creator)
{
return associations_.insert(AssocMap::value_type(id,creator)).second;
}


bool UnRegister(const IdentifierType& id)
{
return associations_.erase(id) == 1;
}


AbstractProduct * CreateObject(const IdentifierType& id)
{
typename AssocMap::const_iterator i = associations_.find(id);
if(i != associations_.end())
{
return (i->second)();
}
//handle error
return OnUnknownType(id);
}
private:
typedef std::map<IdentifierType, AbstractProduct> AssocMap;
AssocMap associations_;
};


template <class IdentifierType , class ProductType>
class DefaultFactoryError
{
public:
class Exception:public std::exception
{
public:
Exception(const IdentifierType& unknownId):unknownId_(unknownId){}
virtual const char* what()
{
return "unknown object type passed to Factory";
}
const IdentifierType GetId()
{
return unknownId_;
}


private:
IdentifierType unknownId_;
};
protected:
static ProductType* OnUnknownType(const IdentifierType& id)
{
throw Exception(id);
}
};
#endif
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式： 自己手动写一个装饰者模式
装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供l比继承更有弹性的替代方案。装饰者和被装饰者有相同的超类型，你可以用一个或多个装饰者包装一个对象。既然装饰者和被装饰者有相同的超类型，所以在任何需要原始对象（被装饰者）的场合，可以用装饰过的对象替换它。装饰者可以在所委托被装饰者的行为之前或之后加上自己的行为，已达到特定的目的。对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。


类图：




源代码如下：

package decorator;
/**
 * 饮料的超类
 * @author <span style="font-family: Arial, Helvetica, sans-serif;">Arvon</span>

 *
 */
public abstract class Beverage {
	String description = "Unknown Beverage";
	public String getDescription() {
		return description;
	}
	public abstract float cost(); 
}

package decorator;
/**
 * 一种饮料 被装饰者
 * @author <span style="font-family: Arial, Helvetica, sans-serif;">Arvon</span><pre name="code" class="java">
 * */public class HouseBlend extends Beverage {public HouseBlend() {super();description = "House Blend Coffee";}@Overridepublic float cost() {// TODO Auto-generated method stubreturn 0.89f;}}


package decorator;
/**
 * 佐料装饰类 佐料超类
 * @author Administrator
 *
 */
public abstract class CondimentDecorator extends Beverage {
	public Beverage mBeverage;
	@Override
	public abstract String getDescription();

	@Override
	public abstract float cost();

}




package decorator;
/**
 * 一种佐料 装饰者
 * @author Administrator
 *
 */
public class Milk extends CondimentDecorator {
	
	
	public Milk(Beverage mBeverage) {
		this.mBeverage = mBeverage;
	}

	@Override
	public String getDescription() {
		// TODO Auto-generated method stub
		return "Milk " + mBeverage.getDescription();
	}

	@Override
	public float cost() {
		return .20f + mBeverage.cost();
	}
	
	

}
package decorator;
/**
 * 一种佐料 装饰者
 * @author Administrator
 *
 */
public class Mocha extends CondimentDecorator {
	
	
	public Mocha(Beverage mBeverage) {
		super();
		this.mBeverage = mBeverage;
	}

	@Override
	public String getDescription() {
		// TODO Auto-generated method stub
		return "Mocha "+mBeverage.getDescription();
	}

	@Override
	public float cost() {
		// TODO Auto-generated method stub
		return 1.2f + mBeverage.cost();
	}

}

package decorator;
/**
 * for testing 
 * @author Administrator
 *
 */
public class StarbuzzCoffee {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Beverage mBeverage = new HouseBlend();
		System.out.println(mBeverage.getDescription() 
				+ " $" + mBeverage.cost());
		
		mBeverage = new Milk(mBeverage);
		System.out.println(mBeverage.getDescription() 
				+ " $" + mBeverage.cost());
		mBeverage = new Mocha(mBeverage);
		System.out.println(mBeverage.getDescription() 
				+ " $" + mBeverage.cost());
	}

}


程序的输出: 

House Blend Coffee $0.89
Milk House Blend Coffee $1.09
Mocha Milk House Blend Coffee $2.29

















版权声明：本文为博主原创文章，未经博主允许不得转载。

Design Pattern_Java：Builder Pattern
Design Pattern：Builder Pattern
建造者模式 Builder Pattern
Separate the construction of a complex object from its representation so that the same construction process can create different representations.
将一个复杂对象的构建与它的表示分离，是的同样的构建过程可以创建不同的表示。
抽象建造者角色（Builder）：该角色用于规范产品的各个组成部分，并进行抽象，一般独立于应用程序的逻辑。
public abstract class Builder {

//设置产品的不同部分，以获得不同的产品
public abstract void setPart1();
public abstract void setPart2();
public abstract void setPart3();

//建造产品
public abstract Product builderProduct();
}

具体建造者角色（Concrete Builder）:该角色实现抽象建造者中定义的所有方法，并且返回一个组建好的产品实例。
public class ConcreteBuilder extends Builder{
private Product product=new Product();

//设置产品零件
@Override
public void setPart1() {
    //为product安装部件1
}

@Override
public void setPart2() {
    //为product安装部件2
}

@Override
public void setPart3() {
    //为product安装部件2
}

//建造一个产品
@Override
public Product builderProduct() {
    return product;
}

}

产品角色（Product）：该角色是建造中的复杂对象，一个系统中会有多于一个的产品类，这些产品类并一定有共同的接口，完全可以是不想关联的。
public class Product{
    //产品类的业务处理方法
}

导演者角色（Director）：该角色负责安排已有模块的顺序，然后告诉Builder开始建造。
public class Director{
    private Builder builder=new ConcreteBuilder();

    //构造产品，负责调用各个零件建造方法
    public Product build(){
        builder.setPart1();
        builder.setPart2();
        builder.setPart3();

        return builder.builderProduct();
    }
}

建造者模式的实例
Computer.java
package com.DesignPattern.Creational.Builder;

public abstract class Computer {

    private String type;
    private String cpu;
    private String ram;
    private String hardDisk;
    private String monitor;
    private String os;

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getCpu() {
        return cpu;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public String getRam() {
        return ram;
    }

    public void setRam(String ram) {
        this.ram = ram;
    }

    public String getHardDisk() {
        return hardDisk;
    }

    public void setHardDisk(String hardDisk) {
        this.hardDisk = hardDisk;
    }

    public String getMonitor() {
        return monitor;
    }

    public void setMonitor(String monitor) {
        this.monitor = monitor;
    }

    public String getOs() {
        return os;
    }

    public void setOs(String os) {
        this.os = os;
    }

}

T410.java
package com.DesignPattern.Creational.Builder;

public class T410 extends Computer {

    private String graphicCard;

    public T410() {
        this.setType("ThinkPad T410i");
    }

    public String getGraphicCard() {
        return graphicCard;
    }

    public void setGraphicCard(String graphicCard) {
        this.graphicCard = graphicCard;
    }

    @Override
    public String toString() {
        return "T410 [graphicCard=" + graphicCard + ", getType()=" + getType()
                + ", getCpu()=" + getCpu() + ", getRam()=" + getRam()
                + ", getHardDisk()=" + getHardDisk() + ", getMonitor()="
                + getMonitor() + ", getOs()=" + getOs() + "]";
    }

}

X201.java
package com.DesignPattern.Creational.Builder;

public class X201 extends Computer {

    public X201() {
        this.setType("ThinkPad X201i");
    }

    @Override
    public String toString() {
        return "X201 [getType()=" + getType() + ", getCpu()=" + getCpu()
                + ", getRam()=" + getRam() + ", getHardDisk()=" + getHardDisk()
                + ", getMonitor()=" + getMonitor() + ", getOs()=" + getOs()
                + "]";
    }

}

ComputerBuilder.java
package com.DesignPattern.Creational.Builder;

public interface ComputerBuilder {

    void buildCpu();
    void buildRam();
    void buildHardDisk();
    void buildGraphicCard();
    void buildMonitor();
    void buildOS();

    Computer getResult();
}

T410Builder.java
package com.DesignPattern.Creational.Builder;

public class T410Builder implements ComputerBuilder {

    private T410 computer = new T410();

    @Override
    public void buildCpu() {
        computer.setCpu("i5-450");
    }

    @Override
    public void buildRam() {
        computer.setRam("4GB 1333MHz");
    }

    @Override
    public void buildHardDisk() {
        computer.setHardDisk("500G 7200转");
    }

    @Override
    public void buildGraphicCard() {
        computer.setGraphicCard("Nvidia NVS 3100M");
    }

    @Override
    public void buildMonitor() {
        computer.setMonitor("14英寸 1280*800");
    }

    @Override
    public void buildOS() {
        computer.setOs("Windows 7旗舰版");
    }

    @Override
    public Computer getResult() {
        return computer;
    }

}

X201Builder.java
package com.DesignPattern.Creational.Builder;

public class X201Builder implements ComputerBuilder {

    private X201 computer = new X201();

    @Override
    public void buildCpu() {
        computer.setCpu("i3-350");
    }

    @Override
    public void buildRam() {
        computer.setRam("2GB 1333MHz");
    }

    @Override
    public void buildHardDisk() {
        computer.setHardDisk("250G 5400转");
    }

    @Override
    public void buildGraphicCard() {
        // 无显卡
    }

    @Override
    public void buildMonitor() {
        computer.setMonitor("12英寸 1280*800");
    }

    @Override
    public void buildOS() {
        computer.setOs("Windows 7 Home版");
    }

    @Override
    public Computer getResult() {
        return computer;
    }
}

ComputerDirector.java
package com.DesignPattern.Creational.Builder;

public class ComputerDirector {

    ComputerBuilder builder;
    public T410 constructT410(){
        builder=new T410Builder();
        builder.buildCpu();
        builder.buildRam();
        builder.buildHardDisk();
        builder.buildGraphicCard();
        builder.buildMonitor();
        builder.buildOS();
        return (T410)builder.getResult();
    }
    public X201 constructX210(){
        builder=new X201Builder();
        builder.buildCpu();
        builder.buildRam();
        builder.buildHardDisk();
        builder.buildMonitor();
        builder.buildOS();
        return (X201)builder.getResult();
    }
}

ComputerTest.java
package com.DesignPattern.Creational.Builder;

public class ComputerTest {

    public static void main(String[] args){
        ComputerDirector director=new ComputerDirector();
        Computer t410=director.constructT410();
        System.out.println(t410);
        System.out.println("-------------------------------");
        Computer x201=director.constructX210();
        System.out.println(x201);
    }
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载｜Copyright ©2011-2015,Supernatural, All Rights Reserved.

Selenium+Python+Pycharm进行自动化测试
最近研究新的自动化测试方法，QTP已经用的比较熟练，待开发新的方法，这里做个记录和大家共勉。
1、首先肯定是配置环境了，一步一步来吧，先下载需要的工具：
下载一个python的环境，我这里用的Python3.4，一会我上传上来，大家可以直接下载。最好用3.4以及以上的版本，这样可以不用pip单独安装什么的，可以联网直接安装selenium了。
安装完Python后可以在线进行selenium安装了，首先cmd进入到Python的scripts目录，一般是这样：cd C:\Python34\Scripts
然后在线安装命令：C:\Python34\Scripts>pip install -U selenium
放个图片大家看：

 
这样基本环境就好了，就这样。接下来要下载IEDriver了，因为大部分还是要在ie上跑的，但是selenium默认的是firefox，所以你要下载个IEDriver（这个我也会上传上来），然后放到ie的目录下就可以了。就这么简单。如下图

 
现在可以配置好开发IDE啦，我用的是Pycharm，这个我也上传上来。看看我的安装好的：

 
开发环境也可以了，现在就可以正常用了，我这里用了
browser = webdriver.Ie()
其实你可能不成功的，因为我做了一个修改，在这里（先按住Ctr，然后鼠标左键那个Ie，就进入到下面的页面了），这里就是初始化IEDriver的，给的一个路径而已。
def __init__(self, executable_path='C:\Program Files\Internet Explorer\IEDriverServer.exe', capabilities=None,
下面我把代码都贴出来吧：
from selenium import webdriver

browser = webdriver.Ie()
browser.get("http://www.baidu.com")
browser.find_element_by_id("kw").send_keys("Eric_guodongliang")
browser.find_element_by_id("su").submit()
 
运行后是这个样子：

可以开始用python设计你的自动化用例啦，接下来还要做的事情就是开发自动化框架，光有工具没有框架也驱动不起来啊。
接下来的时间开始着手框架的开发，最终和python+selenium结合起来，自动化就搭建完毕了。
 
希望可以帮助到大家。

版权声明：本文为博主原创文章，未经博主允许不得转载。

java.sql.SQLException: Access denied for user 'Administrator'@'localhost' (using password: YES)
早上在做MyBatis+Spring整合的时候爆了个奇葩的bug
org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Access denied for user 'Administrator'@'localhost' (using password: YES))
### The error may exist in sqlmap/User.xml
### The error may involve test.findUserById
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Access denied for user 'Administrator'@'localhost' (using password: YES))
	at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:75)
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:371)
	at $Proxy5.selectOne(Unknown Source)
	at org.mybatis.spring.SqlSessionTemplate.selectOne(SqlSessionTemplate.java:163)
	at test.lindl.sm.dao.impl.UserDaoImpl.findUserById(UserDaoImpl.java:18)
	at test.lindl.sm.dao.impl.UserDaoImplTest.testFindUserById(UserDaoImplTest.java:24)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:69)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:48)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:292)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Access denied for user 'Administrator'@'localhost' (using password: YES))
### The error may exist in sqlmap/User.xml
### The error may involve test.findUserById
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Access denied for user 'Administrator'@'localhost' (using password: YES))
	at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:26)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:111)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:102)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:66)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:358)
	... 28 more
Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Access denied for user 'Administrator'@'localhost' (using password: YES))
	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:80)
	at org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:81)
	at org.mybatis.spring.transaction.SpringManagedTransaction.getConnection(SpringManagedTransaction.java:67)
	at org.apache.ibatis.executor.BaseExecutor.getConnection(BaseExecutor.java:279)
	at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:72)
	at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:59)
	at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:267)
	at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:137)
	at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:96)
	at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:77)
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:108)
	... 35 more
Caused by: org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Access denied for user 'Administrator'@'localhost' (using password: YES))
	at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1225)
	at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:880)
	at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:111)
	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:77)
	... 45 more
Caused by: java.sql.SQLException: Access denied for user 'Administrator'@'localhost' (using password: YES)
	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1086)
	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4237)
	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4169)
	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:928)
	at com.mysql.jdbc.MysqlIO.proceedHandshakeWithPluggableAuthentication(MysqlIO.java:1750)
	at com.mysql.jdbc.MysqlIO.doHandshake(MysqlIO.java:1290)
	at com.mysql.jdbc.ConnectionImpl.coreConnect(ConnectionImpl.java:2502)
	at com.mysql.jdbc.ConnectionImpl.connectOneTryOnly(ConnectionImpl.java:2535)
	at com.mysql.jdbc.ConnectionImpl.createNewIO(ConnectionImpl.java:2320)
	at com.mysql.jdbc.ConnectionImpl.<init>(ConnectionImpl.java:834)
	at com.mysql.jdbc.JDBC4Connection.<init>(JDBC4Connection.java:46)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at com.mysql.jdbc.Util.handleNewInstance(Util.java:411)
	at com.mysql.jdbc.ConnectionImpl.getInstance(ConnectionImpl.java:416)
	at com.mysql.jdbc.NonRegisteringDriver.connect(NonRegisteringDriver.java:347)
	at org.apache.commons.dbcp.DriverConnectionFactory.createConnection(DriverConnectionFactory.java:38)
	at org.apache.commons.dbcp.PoolableConnectionFactory.makeObject(PoolableConnectionFactory.java:294)
	at org.apache.commons.dbcp.BasicDataSource.validateConnectionFactory(BasicDataSource.java:1247)
	at org.apache.commons.dbcp.BasicDataSource.createDataSource(BasicDataSource.java:1221)
	... 48 more
之前用同一个MySQL都是可以的，现在password=YES ！！
百度虽然很强大，找个解决方案还真不容易，应该很少人会出现同样的。。
既然问题出现在数据库连接上，那就应该找数据库连接相关的配置。


最后问题的解决在配置文件导入上，我这里是
<context:property-placeholder location="classpath:db.properties" /> 
有网友是这样导入的
     <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">  
        <property name="locations">  
            <list>  
                <value>classpath*:db.properties</value>  
            </list>  
        </property>  
    </bean>  换成这样就可以了。



版权声明：本文为博主原创文章，未经博主允许不得转载。如需转载,请注明出处:http://blog.csdn.net/lindonglian

[置顶]
        常规功能和模块自定义系统(cfcmms)—004可自定义的项目

常规功能和模块自定义系统(cfcmms)—004可自定义的项目




可以在前台浏览器里可进行的配置项目如下图：









版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式之策略(Strategy)模式
Strategy模式是一种行为型设计模式，它将算法一个个封装起来，在某一时刻能够互换地使用其中的一个算法。从概念上看，所有这些算法完成的都是相同的工作，只是实现不同而已。
动机
在开发中，我们常常会遇到概念上相同，处理方法不同的任务，例如，对一件商品使用不同的税额计算方法来计算其价格。一般来说，有以下的方法来处理: 

复制和粘贴(一份代码具有两个版本，维护成本大)
使用switch或者if语句，用一个变量指定各种情况(分支会变得越来越长)
函数指针或者委托(无法维持对象的状态)
继承(需求变化时，客户代码仍得更改)

Strategy模式则采用如下办法解决问题：

寻找变化，例如这里的存在变化的算法，将它们封装在一个单独的类中
将这个类包含在另一个类中，即使用组合来取代继承

定义
定义一系列的算法，把它们一个个封装起来，并且使用它们可以相互替换，strategy模式使算法可独立于使用它的客户而变化。
效果
通过从一个抽象类派生实现不同的算法，客户无需关心实际使用的是哪个算法，这样使得加入新的算法十分方便。
结构

Strategy
对算法的接口进行定义，Context类使用这个接口来调用具体算法。Strategy可以是一个抽象类(C++)，或者一个接口(Java)
ConcreteStrategy
实现具体的算法
Context
包含一个Strategy对象的引用，它并不关心这个Strategy对象是ConcreteStrategyA还是ConcreteStrategyB，通过Strategy的AlgorithmInterface()接口来正确调用具体的算法。
Client
客户，与Contex进行交互。通常来说，Client会创建一个ConcreteStartegy并传递给Context，并向Contex发送处理请求。
例子
1. 定义接口Strategy
Strategy.java
public interface Strategy {
   public int doOperation(int num1, int num2);
}
2. 定义具体算法ConcreteStrategy
OperationAdd.java
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}
OperationSubstract.java
public class OperationSubstract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}
OperationMultiply.java
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}
3. 创建Context类
Context.java
public class Context {
   private Strategy strategy;

   public Context(Strategy strategy){
      this.strategy = strategy;
   }

   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}
4. 客户(Client)使用Context类
StrategyPatternDemo.java
public class StrategyPatternDemo {
   public static void main(String[] args) {
      Context context = new Context(new OperationAdd());        
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));

      context = new Context(new OperationSubstract());      
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));

      context = new Context(new OperationMultiply());       
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
   }
}
5. 输出

10 + 5 = 15 
  10 - 5 = 5 
  10 * 5 = 50

参考资料

https://en.wikipedia.org/wiki/Strategy_pattern
http://www.oodesign.com/strategy-pattern.html
http://www.tutorialspoint.com/design_pattern/strategy_pattern.htm
《设计模式解析(第二版)》
http://www.javacodegeeks.com/2013/08/strategy-design-pattern-in-java-example-tutorial.html


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处: http://blog.csdn.net/lihao21

DesignPattern_Java:Prototype Pattern
原型模式 Prototype Pattern
Specify the kinds of objects to create using a prototypical instance,and create new objects by copying this prototype.
用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
Java内置克隆机制：
实现Cloneable接口
覆盖Object的clone()方法。
抽象原型角色（Prototype）：该角色是一个抽象角色，通常有一个Java接口或抽象类实现，给出所有的具体原型类所需的接口。
package com.DesignPattern.Creational.Prototype;

public interface Prototype extends Cloneable {

    //克隆方法
    Prototype clone();
}

具体原型角色（Concrete Prototype）：该角色是被复制的对象，必须实现抽象原型接口。
package com.DesignPattern.Creational.Prototype;

public class ConcretePrototype implements Prototype {

    @Override
    public Prototype clone() {
        try {
            return (Prototype) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }
}

客户角色（Client）：该角色提出创建对象的请求。
package com.DesignPattern.Creational.Prototype;

public class Client {

    public void operation(Prototype example) {
        // 得到example的副本
        Prototype p = example.clone();
    }
}

原型模式的实例
Mail.java
package com.DesignPattern.Creational.Prototype;

public class Mail implements Cloneable {

    private String receiver;
    private String subject;
    private String appellation;
    private String contxt;
    private String tail;

    public Mail(String subject, String contxt) {
        this.subject = subject;
        this.contxt = contxt;
    }

    // 克隆方法
    public Mail clone() {
        Mail mail = null;
        try {
            mail = (Mail) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return mail;
    }

    public String getReceiver() {
        return receiver;
    }

    public void setReceiver(String receiver) {
        this.receiver = receiver;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getAppellation() {
        return appellation;
    }

    public void setAppellation(String appellation) {
        this.appellation = appellation;
    }

    public String getContxt() {
        return contxt;
    }

    public void setContxt(String contxt) {
        this.contxt = contxt;
    }

    public String getTail() {
        return tail;
    }

    public void setTail(String tail) {
        this.tail = tail;
    }

}

ClientDemo.java
package com.DesignPattern.Creational.Prototype;

import java.util.Random;

public class ClientDemo {

    // 发送账单的数量，这个值是从数据库中获得的
    private static int MAX_COUNT = 6;

    public static void main(String[] args) {
        int i = 0;
        // 定义一个邮件对象
        Mail mail = new Mail("Activity", "there are ...");
        mail.setAppellation("copyright");
        while (i < MAX_COUNT) {
            // 克隆邮件
            Mail cloneMail = mail.clone();
            cloneMail.setAppellation(getRandString(5) + "G(M)");
            cloneMail.setReceiver(getRandString(5) + "@" + getRandString(8)
                    + ".com");
            // 发送邮件
            sendMail(cloneMail);
            i++;
        }
    }

    // 发送邮件
    public static void sendMail(Mail mail) {
        System.out.println("标题：" + mail.getSubject() + "\t收件人:"
                + mail.getReceiver() + "\t.....send Success!");
    }

    // 获得指定长度的随机字符串
    public static String getRandString(int maxLength) {
        String source = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
        StringBuffer sb = new StringBuffer();
        Random rand = new Random();
        for (int i = 0; i < maxLength; i++) {
            sb.append(source.charAt(rand.nextInt(source.length())));
        }
        return sb.toString();
    }
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载｜Copyright ©2011-2015,Supernatural, All Rights Reserved.

如何使用Struts 2防止表单重复提交？
用户重复提交表单在某些场合将会造成非常严重的后果。例如，在使用信用卡进行在线支付的时候，如果服务器的响应速度太慢，用户有可能会多次点击提交按钮，而这可能导致那张信用卡上的金额被消费了多次。因此，重复提交表单会对你的系统带来逻辑影响，必须采取一些措施防止这类情况的发生。　　用户重复提交同一个HTML表单的原因有：快速多次点击提交按钮；提交表单后按下浏览器的刷新按钮。　　设置Struts 2的预防表单重复提交的功能　　Struts 2已经内置了能够防止用户重复提交同一个HTML表单的功能。它的工作原理：让服务器生成一个唯一标记，并在服务器和表单里各保存一份这个标记的副本。此后，在用户提交表单的时候，表单里的标记将随着其他请求参数一起发送到服务器，服务器将对他收到的标记和它留存的标记进行比较。如果两者匹配，这次提交的表单被认为是有效的，服务器将对之做出必要的处理并重新设置一个新标记。随后，提交相同的表单就会失败，因为服务器上的标记已经重置。　　Struts 2标签中的token标签，可以用来生成一个独一无二的标记。这个标记必须嵌套在form标签中使用，它会在表单里插入一个隐藏字段并把标记保存到HttpSession对象里。toke标签必须与Token或Token Session拦截器配合使用，两个拦截器都能对token标签进行处理。Token拦截器遇到重复提交表单的情况，会返回一个"invalid.token"结果并加上一个动作级别的错误。Token Session拦截器扩展了Token拦截器并提供了一种更复杂的服务，它采取的做法与Token拦截器不同，它只是阻断了后续的提交，这样用户不提交多少次，就好像只是提交了一次。　　示例：使用Token拦截器预防表单重复提交　　配置struts.xml文件，声明动作    <?xml version="1.0" encoding="UTF-8" ?><!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd">

    <struts>

    <package name="avoidPackage" extends="struts-default">

    <action name="avoid" class="struts2.action.AvoidAction">

    <interceptor-ref name="token"></interceptor-ref>

    <interceptor-ref name="defaultStack"></interceptor-ref>

    <result name="invalid.token">/error.jsp</result>

    <result name="input">/input.jsp</result>

    <result name="success">/output.jsp</result>

    </action>

    </package>

    </struts>
    此时，需要在动作的声明中，为动作添加token拦截器，因为token拦截器不在defaultStack拦截器栈中，注意，需要将拦截器放在拦截器栈的第一位，这是因为判断表单是否被重复提交的逻辑应该在表单处理前。    创建动作类    public class AvoidAction extends ActionSupport {

    private static final long serialVersionUID = 2676453800249807631L;

    private String username;

    private Date birthday;

    public String getUsername（） {

    return username;

    }

    public void setUsername（String username） {

    this.username = username;

    }

    public Date getBirthday（） {

    return birthday;

    }

    public void setBirthday（Date birthday） {

    this.birthday = birthday;

    }

    @Override

    public String execute（）

    {

    try {

    Thread.sleep（4000）；

    } catch （InterruptedException e） {

    e.printStackTrace（）；

    }

    return SUCCESS;

    }

    }
    这个动作逻辑处理为挂起4秒钟，让我们有机会多次点击提交按钮，测试效果。    创建页面：    input.jsp    <s:form action="avoid">

    <s:token>

    </s:token>

    <s:textfield name="username" label="Enter your name"></s:textfield>

    <s:textfield name="birthday" label="Enter your birthday"></s:textfield>

    <s:submit value="submit">

    </s:submit>

    </s:form>
    要使用Struts 2的防止表单重复提交功能，需要在form标签中使用token标签，他会产生一个唯一的标识符，与其他参数一起提交到服务器，服务器会根据token标签所产生的标识符判断表单是否为重复提交的表单，这个功能是由Token拦截器完成的。    error.jsp    <body>    do not duplicate submissions form!    </body>    当表单重复提交，Token拦截器会返回一个"invalid.token"结果，结果将页面转到这个页面，提示用户错误信息。    output.jsp    <body>    Your Name :<s:property value="username"/>    <br />    Your Birthday : <s:property value="birthday"/>    </body>    若没有重复提交表单，那么就显示正确的页面。    测试    在浏览器中输入：http://localhost:8081/AvoidDuplicateSubmissions/input.jsp，得到如下界面    连续多次点击"submit"按钮，查看效果    可以看到，token拦截器的设置生效了，他阻止了表单的重复提交，并给出了错误提示    这次我们只点击一次提交（请重新输入URL，或后退到输入页面后刷新一下，这是因为token的标示在提交一次后已被修改，不刷新标示符是不可能与服务器存留的标示符一致的）    可以看到，表单被正确的处理了。    处理表单重复提交的另一个拦截器是 tokenSession，使用该拦截器与使用token拦截器并没有什么差异只需要，引用该拦截器，其他与token拦截器完全一致    <?xml version="1.0" encoding="UTF-8" ?>

    <!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd">

    <struts>

    <package name="avoidPackage" extends="struts-default">

    <action name="avoid" class="struts2.action.AvoidAction">

    <interceptor-ref name="tokenSession"></interceptor-ref>

    <interceptor-ref name="defaultStack"></interceptor-ref>

    <result name="invalid.token">/error.jsp</result>

    <result name="input">/input.jsp</result>

    <result name="success">/output.jsp</result>

    </action>

    </package>

    </struts>

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

使用 Twitter Storm 处理实时的大数据



Hadoop（大数据分析领域无可争辩的王者）专注于批处理。这种模型对许多情形（比如为网页建立索引）已经足够，但还存在其他一些使用模型，它们需要来自高度动态的来源的实时信息。为了解决这个问题，就得借助 Nathan Marz 推出的 Storm（现在在 Twitter 中称为 BackType）。Storm 不处理静态数据，但它处理预计会连续的流数据。考虑到 Twitter 用户每天生成 1.4 亿条推文 (tweet)，那么就很容易看到此技术的巨大用途。

但 Storm 不只是一个传统的大数据分析系统：它是复杂事件处理 (CEP) 系统的一个示例。CEP 系统通常分类为计算和面向检测，其中每个系统都可通过用户定义的算法在 Storm 中实现。举例而言，CEP 可用于识别事件洪流中有意义的事件，然后实时地处理这些事件。

Nathan Marz 提供了在 Twitter 中使用 Storm 的大量示例。一个最有趣的示例是生成趋势信息。Twitter 从海量的推文中提取所浮现的趋势，并在本地和国家级别维护它们。这意味着当一个案例开始浮现时，Twitter 的趋势主题算法就会实时识别该主题。这种实时算法在 Storm 中实现为 Twitter 数据的一种连续分析。


什么是 “大数据”？

大数据 指的是海量无法通过传统方式管理的数据。互联网范围的数据正在推动能够处理这类新数据的新架构和应用程序的创建。这些架构高度可扩展，且能够跨无限多的服务器并行、高效地处理数据。


Storm 与传统的大数据

Storm 与其他大数据解决方案的不同之处在于它的处理方式。Hadoop 在本质上是一个批处理系统。数据被引入 Hadoop 文件系统 (HDFS) 并分发到各个节点进行处理。当处理完成时，结果数据返回到 HDFS 供始发者使用。Storm 支持创建拓扑结构来转换没有终点的数据流。不同于 Hadoop 作业，这些转换从不停止，它们会持续处理到达的数据。



回页首

大数据实现

Hadoop 的核心是使用 Java™ 语言编写的，但支持使用各种语言编写的数据分析应用程序。最新的应用程序的实现采用了更加深奥的路线，以充分利用现代语言和它们的特性。例如，位于伯克利的加利福尼亚大学 (UC) 的 Spark 是使用 Scala 语言实现的，而 Twitter Storm 是使用 Clojure（发音同 closure）语言实现的。

Clojure 是 Lisp 语言的一种现代方言。类似于 Lisp，Clojure 支持一种功能性编程风格，但 Clojure 还引入了一些特性来简化多线程编程（一种对创建 Storm 很有用的特性）。Clojure 是一种基于虚拟机 (VM) 的语言，在 Java 虚拟机上运行。但是，尽管 Storm 是使用 Clojure 语言开发的，您仍然可以在 Storm 中使用几乎任何语言编写应用程序。所需的只是一个连接到 Storm 的架构的适配器。已存在针对 Scala、JRuby、Perl 和 PHP 的适配器，但是还有支持流式传输到
 Storm 拓扑结构中的结构化查询语言适配器。



回页首

Storm 的关键属性

Storm 实现的一些特征决定了它的性能和可靠性的。Storm 使用 ZeroMQ 传送消息，这就消除了中间的排队过程，使得消息能够直接在任务自身之间流动。在消息的背后，是一种用于序列化和反序列化 Storm 的原语类型的自动化且高效的机制。

Storm 的一个最有趣的地方是它注重容错和管理。Storm 实现了有保障的消息处理，所以每个元组都会通过该拓扑结构进行全面处理；如果发现一个元组还未处理，它会自动从喷嘴处重放。Storm 还实现了任务级的故障检测，在一个任务发生故障时，消息会自动重新分配以快速重新开始处理。Storm 包含比 Hadoop 更智能的处理管理，流程会由监管员来进行管理，以确保资源得到充分使用。



回页首

Storm 模型

Storm 实现了一种数据流模型，其中数据持续地流经一个转换实体网络（参见 图
 1）。一个数据流的抽象称为一个流，这是一个无限的元组序列。元组就像一种使用一些附加的序列化代码来表示标准数据类型（比如整数、浮点和字节数组）或用户定义类型的结构。每个流由一个惟一 ID 定义，这个 ID 可用于构建数据源和接收器 (sink) 的拓扑结构。流起源于喷嘴，喷嘴将数据从外部来源流入
 Storm 拓扑结构中。

图 1. 一个普通的 Storm 拓扑结构的概念性架构


接收器（或提供转换的实体）称为螺栓。螺栓实现了一个流上的单一转换和一个
 Storm 拓扑结构中的所有处理。螺栓既可实现 MapReduce 之类的传统功能，也可实现更复杂的操作（单步功能），比如过滤、聚合或与数据库等外部实体通信。典型的 Storm 拓扑结构会实现多个转换，因此需要多个具有独立元组流的螺栓。喷嘴和螺栓都实现为 Linux® 系统中的一个或多个任务。

可使用 Storm 为词频轻松地实现 MapReduce 功能。如 图
 2 中所示，喷嘴生成文本数据流，螺栓实现 Map 功能（令牌化一个流的各个单词）。来自 “map” 螺栓的流然后流入一个实现 Reduce 功能的螺栓中（以将单词聚合到总数中）。

图 2. MapReduce 功能的简单 Storm 拓扑结构


请注意，螺栓可将数据传输到多个螺栓，也可接受来自多个来源的数据。Storm 拥有流分组 的概念，流分组实现了混排 (shuffling)（随机但均等地将元组分发到螺栓）或字段分组（根据流的字段进行流分区）。还存在其他流分组，包括生成者使用自己的内部逻辑路由元组的能力。

但是，Storm 架构中一个最有趣的特性是有保障的消息处理。Storm 可保证一个喷嘴发射出的每个元组都会处理；如果它在超时时间内没有处理，Storm 会从该喷嘴重放该元组。此功能需要一些聪明的技巧来在拓扑结构中跟踪元素，也是 Storm 的重要的附加价值之一。

除了支持可靠的消息传送外，Storm 还使用 ZeroMQ 最大化消息传送性能（删除中间排队，实现消息在任务间的直接传送）。ZeroMQ 合并了拥塞检测并调整了它的通信，以优化可用的带宽。



回页首

Storm 示例演示

现在让我们通过实现一个简单的 MapReduce 拓扑结构的代码（参见 清单
 1），看一下 Storm 示例。这个示例使用了来自 Nathan 的 Storm 入门工具包（可从 GitHub 获取）（参见 参考资料 获取链接）的巧妙设计的字数示例。此示例演示了 图
 2 中所示的拓扑结构，它实现了一个包含一个螺栓的 map 转换和包含一个螺栓的 reduce 转换。

清单 1. 为图 2 中的 Storm 构建一个拓扑结构

01  TopologyBuilder builder = new TopologyBuilder();
02          
03  builder.setSpout("spout", new RandomSentenceSpout(), 5);
04          
05  builder.setBolt("map", new SplitSentence(), 4)
06           .shuffleGrouping("spout");
07  
08  builder.setBolt("reduce", new WordCount(), 8)
09           .fieldsGrouping("map", new Fields("word"));
10  
11  Config conf = new Config();
12  conf.setDebug(true);
13  
14  LocalCluster cluster = new LocalCluster();
15  cluster.submitTopology("word-count", conf, builder.createTopology());
16  
17  Thread.sleep(10000);
18  
19  cluster.shutdown();


清单 1（添加了行号以供引用）首先使用 TopologyBuilder 声明一个新拓扑结构。接下来在第
 3 行，定义了一个喷嘴（名为 spout），该喷嘴包含一个 RandomSentenceSpout。RandomSentenceSpout 类（也就是 nextTuple 方法）发出
 5 个随机句子的其中一个作为它的数据。setSpout 方法末尾的 5 参数是一个并行性提示（或要为此活动创建的任务数）。

在第 5 和 6 行。我定义了第一个螺栓（或算法转换实体），在本例中为 map（或 split）螺栓。这个螺栓使用 SplitSentence 令牌化输入流并将其作为输出的各个单词发出。请注意，第
 6 行使用了 shuffleGrouping，它定义了对此螺栓（在本例中为
 “spout”）的输入订阅，还将流分组定义为混排。这种混排分组意味着来自喷嘴的输入将混排 或随机分发给此螺栓中的任务（该螺栓已提示具有 4 任务并行性）。

在第 8 和 9 行，我定义了最后一个螺栓，这个螺栓实际上用于 reduce 元素，使用该元素的输入作为 map 螺栓。WordCount 方法实现了必要的字数统计行为（将相似的单词分组到一起，以维护总数），但不是混排的，所以它的输出是一致的。如果有多个任务在实现
 reduce 行为，那么您最终会得到分段的计数，而不是总数。

第 11 和 12 行创建和定义了一个配置对象并启用了 Debug 模式。Config 类包含大量配置可能性（参见 参考资料，获取有关
 Storm 类树的更多信息的链接）。

第 14 和 15 行创建了本地集群（在本例中，用于定义本地模式的用途）。我定义了我的本地集群、配置对象和拓扑结构的名称（可通过builder 类的 createTopology 元素获取）。

最后，在第 17 行，Storm 休眠一段时间，然后在第 19 行关闭集群。请记住，Storm 是一个持续运行的操作系统，所以任务可存在相当长时间，不断处理它们订阅的流上的新元组。

您可在 Storm 入门工具包中了解这个非常简单的实现的更多信息，包括喷嘴和螺栓的细节。



回页首

使用 Storm

Nathan Marz 编写了一组简单易懂的文档，详细介绍了如何安装 Storm 来执行集群模式和本地模式的操作。本地模式无需一个庞大的节点集群，即可使用 Storm。如果需要在一个集群中使用 Storm 但缺乏节点，也可在 Amazon Elastic Compute Cloud (EC2) 中实现一个 Storm 集群。请参见 参考资料 获取每个
 Storm 模式（本地、集群和 Amazon EC2）的参考信息。



回页首

其他开源的大数据解决方案

自 Google 在 2004 年推出 MapReduce 范式以来，已诞生了多个使用原始 MapReduce 范式（或拥有该范式的质量）的解决方案。Google 对 MapReduce 的最初应用是建立万维网的索引。尽管此应用程序仍然很流行，但这个简单模型解决的问题也正在增多。

表 1 提供了一个可用开源大数据解决方案的列表，包括传统的批处理和流式处理应用程序。在将
 Storm 引入开源之前将近一年的时间里，Yahoo! 的 S4 分布式流计算平台已向 Apache 开源。S4 于 2010 年 10 月发布，它提供了一个高性能计算 (HPC) 平台，向应用程序开发人员隐藏了并行处理的复杂性。S4 实现了一个可扩展的、分散化的集群架构，并纳入了部分容错功能。

表 1. 开源大数据解决方案




解决方案

开发商

类型

描述





Storm

Twitter

流式处理

Twitter 的新流式大数据分析解决方案



S4

Yahoo!

流式处理

来自 Yahoo! 的分布式流计算平台



Hadoop

Apache

批处理

MapReduce 范式的第一个开源实现



Spark

UC Berkeley AMPLab

批处理

支持内存中数据集和恢复能力的最新分析平台



Disco

Nokia

批处理

Nokia 的分布式 MapReduce 框架



HPCC

LexisNexis

批处理

HPC 大数据集群






回页首

更多信息

尽管 Hadoop 仍然是宣传最多的大数据分析解决方案，但仍可能存在许多其他的解决方案，每种解决方案都具有不同的特征。我在过去的文章中探讨了 Spark，它纳入了数据集的内存中处理功能（能够重新构建丢失的数据）。但 Hadoop 和 Spark 都专注于大数据集的批处理。Storm 提供了一个新的大数据分析模型，而且因为它最近被开源，所以也引起广泛的关注。

与 Hadoop 不同，Storm 是一个计算系统，它没有包括任何存储概念。这就使得 Storm 能够用在各种各样的上下文中，无论数据是从一个非传统来源动态传入，还是存储在数据库等存储系统中（或者由一个控制器用于对其他一些设备（比如一个交易系统）进行实时操作）都是如此。

请参见 参考资料 获取有关 Storm 的更多信息的链接，了解如何让一个集群正常运行，以及其他大数据分析解决方案（包括批处理和流式处理）。





参考资料

学习


复杂事件处理 是 Storm 以及其他许多解决方案（比如 Yahoo!
 的 S4）实现的模式。Storm 与 S4 之间的一个重要区别在于，Storm 在面对故障时提供了有保障的消息处理，而 S4 可能丢失消息。
Nathan Marz（Storm 背后的重要开发人员）为他的新产品编写了多篇有趣且实用的介绍文章。对 Storm 的最早介绍来自 2011 年 5 月的 Storm
 预览：能够实时处理的 Hadoop - BackType Technology，随后是 8 月推出的 A
 Storm is coming: more details and plans for release。
Storm 维基 提供了有关 Storm、它的理论基础的大量优秀文档，以及有关获取 Storm
 和设置新项目的各种教程。您还将找到一些有关 Storm 的许多方面的实用文档，包括 Storm 在本地模式、集群模式和在 Amazon 上的使用。
Spark，一种快速数据分析替代方案（M. Tim Jones，developerWorks，2011
 年 11 月）介绍了 UC Berkeley 的内存中弹性数据分析平台。
应用程序虚拟化的过去与未来（M.
 Tim Jones，developerWorks，2011 年 5 月）详细介绍了虚拟化在语言抽象方面的使用。Storm 使用基于虚拟机的语言 Clojure 来实现，还使用 Java 技术和许多其他语言来构建它的内部（螺栓）应用程序。
GitHub 上提供了 Storm 的一个 thorough class tree
 exists，详细介绍了 Storm 的类和接口。
Hadoop 已开始解决简单批处理以外的模型。例如，通过调度，Hadoop 可调整其处理数据的方式，以便更多地关注交互性，而不是批量数据处理。在 Hadoop
 中的调度（M. Tim Jones，developerWorks，2011 年 12 月）中了解有关 Hadoop 调度的更多信息。
观看 developerWorks 演示中心，包括面向初学者的产品安装和设置演示，以及为经验丰富的开发人员提供的高级功能。
随时关注 developerWorks 技术活动和网络广播。
访问 developerWorks Open source 专区获得丰富的
 how-to 信息、工具和项目更新以及最受欢迎的文章和教程，帮助您用开放源码技术进行开发，并将它们与
 IBM 产品结合使用。

获得产品和技术


ZeroMQ 是一个智能传输层，用于在可扩展的环境中高效地传递消息。在 ZeroMQ 站点上，您可以了解有关该产品、使用该产品解决问题的方式，以及如何支持此工作的信息。
Apache Zookeeper 是一个推动可靠的分布式协调的开源项目。Storm 使用 Zookeeper 在一个集群中的一组节点中进行协调。
Clojure 是用于实现 Storm 系统的语言。Clojure 是 Rich Hicky 为 Lisp 语言创建的一种最新的衍生语言，可用作一种通用语言，而且还简化了多线程编程。
Apache Hadoop 是 Yahoo! 为 MapReduce
 编程 开发的平台。最近来自 UC Berkeley 的 Spark是一种使用 Scala 开发的弹性、内存型、开源的大数据产品。
除了 Storm，还有其他一些开源的大数据产品。Yahoo!
 S4 是另一个基于流的大数据平台。其他像 Hadoop 一样面向批处理的产品包括 Nokia 的 Disco 项目 和 LexisNexis
 HPCC。
以最适合您的方式 评估 IBM 产品：下载产品试用版、在线试用产品、在云环境中使用产品，或者在 SOA
 沙盒 中花几小时学习如何高效地实现面向服务的体系结构。

讨论


加入 developerWorks 中文社区，developerWorks
 社区是一个面向全球 IT 专业人员，可以提供博客、书签、wiki、群组、联系、共享和协作等社区功能的专业社交网络社区。
加入 IBM
 软件下载与技术交流群组，参与在线交流。



版权声明：本文为博主原创文章，未经博主允许不得转载。

【设计模式】——迭代模式

 
                                 
                                      
            【设计模式】——迭代模式


前言：
 
  迭代，从字面的意思就可以了解到，是一个接着一个。比如公交车上的售票员，在每一个站


过后都会对上来的乘客进行遍历一遍，不会放过一个不买票的乘客，不管你是人，过大的行李，


不管你是中国人还是外国人，不管你是内部员工，甚至哪怕是马上要抓走的小偷，只要是来乘车


的乘客，就必须要买票。同样的道理，当你需要访问一个聚集的对象，而且不管这些对象是什


么，都要遍历的时候，你就应该考虑用迭代器模式。
   
    
   由于不管乘客是什么，售票员的做法始终是相同的，都是从第一个开始，下一个是谁，是否


接受，当前售到那个人，谢谢方法每天他都在做，也就是说，为遍历不同的聚集结果提供如开


始、下一个、师傅结束、当前那一项等统一的接口。  


 迭代模式（Iterator），提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露给对


象的内部表示。


二、从 UML 图来看如下：
   
   

三、实现的代码：
            
                       


  1、Iterator迭代器抽象类：
<span style="font-size:18px;">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 迭代模式
{
    //定义得到开始对象，得到下一个对象，判断是否到结尾，当前对象等等抽象方法，统一接口。
    abstract class Iterator
    {
        public abstract object First(); //定义得到开始对象
        public abstract object Next();  //得到下一个对象
        public abstract bool IsDone();  //判断是否到结尾，
        public abstract object CurrentItem();//统一接口。
    }

}</span>



  2、Aggregate聚集抽象类：
<span style="font-size:18px;">//聚集抽象类
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 迭代模式
{
    //创建迭代器
  abstract  class Aggregate
    {
      public abstract Iterator CreateIterator();
</span>
    }
}

   3、ConcreteIterator 具体迭代器类，继承Iterator：
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 迭代模式
{
    class ConcreteIterator : Iterator
    {
        //定义一个具体聚集对象
        private ConcreteAggregate aggregate;
        private int current = 0;

        //初始化是将具体的聚集对象传人
        public ConcreteIterator(ConcreteAggregate aggregate)
        {
            this.aggregate = aggregate;
        }

        //得到第一个对象
        public override object First()
        {
            return aggregate[0];                    //这个中括号在这什么意思？——这是得到一个聚集对象的方法
        }

        //得到聚集的下一个对象
        public override object Next()
        {
            object ret = null;                      //ret 在这是什么意思？
            current++;
            if (current < aggregate.Count)
            {
                ret = aggregate[current];
            }
            return ret;

        }

        public override bool IsDone()
        {
            return current >= aggregate.Count ? true : false;
        }


        public override object CurrentItem()
        {
            return aggregate[current];
        }

        //判断当前师傅偏历到结尾，到结尾返回True

        //public override bool IsDone();
        //{
        //    return current > = aggregate.Count ? true : false;
        //}

        ////返回当前聚集对象
        //public override object CurrentItem()
        //{
        //    return aggregate[current];
        //}
    }
}


  4、ConcreteAggregate 具体聚集类 继承Aggregate：
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 迭代模式
{
    class ConcreteAggregate : Aggregate
    {

        //声明一个IList泛型变量，用于存放聚合对象，用ArrayList同样可以实现
        private IList<object> items = new List<object>();

        public override Iterator CreateIterator()
        {
            return new ConcreteIterator(this);
        }

        //返回聚集总个数
        public int Count
        {
            get { return items.Count; }
        }



        //声明一个 索引器
        public object this[int index]
        {
            get { return items[index]; }
            set { items.Insert(index, value); }

        }

    }

}
  
  5、客户端代码：
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace 迭代模式
{
    class Program
    {
        static void Main(string[] args)
        {
            ConcreteAggregate a = new ConcreteAggregate(); //公交车 聚集对象
            //新上来乘客，即对象组
            
            a[0] = "大鸟";
            a[1] = "小菜";
            a[2] = "行李";
            a[3] = "公交内部员工";+
            a[4] = "小偷";

            Iterator i = new ConcreteIterator(a);  //售票员处处，先看好上车是哪些人，也即是声明迭代对象

            object item = i.First();


            while (!i.IsDone())  //从第一个乘客开始
            {
                Console.WriteLine("{0} 请买车票！",i.CurrentItem());
                i.Next();

            }
            Console.Read();
        }
    }
}

  
   显示结果：




    
  四、错误小调试；
迭代模式出现的问题：
  
   1、数组的赋值必须从“0” [0]开始，所以，如下是之前的代码，就是从[1] 开始，所以出错，运行不下去，
 <span style="font-size:18px;">a[1] = "大鸟";
a[2] = "小菜";
a[3] = "行李";
a[4] = "公交内部员工";
a[5] = "小偷";</span>


   更改成：
 <span style="font-size:18px;">a[0] = "大鸟";
 a[1] = "小菜";
 a[2] = "行李";
 a[3] = "公交内部员工";
 a[4] = "小偷";</span>


     ——之后问题解决。


2、是非常非常的基本的少敲了代码，所以客户端中的显示没有出来！
  
<span style="font-size:18px;">        Console.WriteLine("{0} 请买车票！",i.CurrentItem());</span>




小结：
    迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器来负


责，这样既可以做到不暴露计划的内部结构，有可以让外部代码透明地访问计划内部数


据。从开头的那个例子就可以看出，那个售票员就是一个了不起​的迭代高手，每一次有


乘客上车，他都数数，统计人数，然后再对整车的乘客进行迭代遍历，不放过任何漏网


之鱼。





版权声明：本文为博主原创文章，未经博主允许不得转载。

ProtocolBuf协议说明
ProtocolBuf知识说明
一段Asn.1的故事:
    记得那是8年前，当我开始从事基于电信2G~3G的增值业务网关、网元开发的时候，我被一个叫Asn.1的编码规则所征服和吸引，但苦于当时自己技术能力有限，对于想写出一套基于Asn.1转C/C++的生成工具而无能为力，无奈之下，只好使用华为给出的一套生成工具，然而，苦逼的是，华为这套工具是要收取服务费的，费用大概在2万左右每年，对于当时的公司来说，其实并不算什么，但年年收费不说，发现有问题时，对于财大气粗的华为来说，并不愿意更改或者根本就鄙视使用者的能力和水平。好吧，自己当时能力确实有限，所以，只能围着这套工具生成器而到处想方设法规避一些问题。
    然而，用了两年之后，公司似乎考虑看着每次支付的费用不多，但年年支付看来还是过于昂贵，可是苦于当时整个公司或者说当时整个软件行业一个针对Asn.1编码规则免费开发的工具，于是，和华为进行一次性的买卖谈判，但没有成功。后来，公司通过多方发力，购买了一套美国一家公司的Asn.1语言转换工具，在我经过一番研究之后，感觉比华为的还要好用一点，于是经过二次封装之后，开始使用。
    后来自以为可以出来闯一番的我，离开了原公司，告别了多年相处的好友和同事，开始闯荡，然而，前进的路比我想想的要曲折好多，直至今日，我也还在闯荡的路上，伤痕累累之外，已经没有了先前的锐气，也失却了往昔的激情，唯一的慰藉就是，依然还走在技术的道路上。
初识ProtocolBuf
    那是在两年前，我进入一个公司，担任公司首席架构师，在设计架构一个综合性大平台的时候，在设计架构业务类的数据传输协议的时候，对于追求数据传输性能和带宽都有严格要求的我，在XML、Json和自定义数据结构之间产生了矛盾，那时的我，对Asn.1念念不忘，但基于公司项目进度，我无暇去实现一套基于Java\c\c++\php\c#的转换工具，无奈的我选择了当时主流的Json，但对于Json，我内心中时时刻刻都有想换掉它的想法。一个偶然的机会，我在面试一个做游戏的程序员时，在问询他如何实现网游数据的高效实时传输而又不对带宽造成太大的压力时，他脱口说出了ProtocolBuf,顿时，我来了兴趣，详细询问了他对于ProtocolBuf的一些情况：“google公司发布的一套开源编码规则，基于二进制流的序列化传输，可以转换成多种编程语言，几乎涵盖了市面上所有的主流编程语言。”
    听完这些，我有一种井底之蛙的感觉，这么好的东西，我怎么就没听说过呢？这简直和Asn.1完全一样呀，优秀到极点的东西为啥用的人不多呢？于是，我马上录用了这个家伙，并开始着手研究其ProtocolBuf来。
详解ProtocolBuf
    在经过一番研究之后，我彻底被其所吸引，于是，我决定立即停掉正在使用的Json，所有业务数据传输全部使用ProtocolBuf协议规则，要求大家加班加点，在一个月之内替换整个业务数据，几乎每天晚上的连续工作到凌晨之后，终于完成，嗯，一切都很好。
ProtocolBuf伪码编写格式
    从开始研究ProtocolBuf开始，我总感觉他是抄袭Asn.1的，因为伪码格式几乎完全一样。都需要先写一个符合格式要求的伪码数据协议并且格式相似，下面是ProtocolBuf的伪码格式,扩展名一般为.pro；
枚举类型数据定义:
//操作类型
enum e_MsgOper_PRO
{
         E_ADD_PRO= 0;                        
         E_DEL_PRO= 1;
         E_MOD_PRO= 2;
}
//用户角色
enum e_RoomRoles_PRO
{
         E_HOST_PRO= 0;                                         //群主
         E_MANGER_PRO= 1;                                  //管理员
         E_NORMAL_PRO= 2;                                  //普通成员
}
通过枚举类型的数据定义来看，有点想C的枚举定义，但是，每个枚举值都是以’;’结束的，并且也不支持typedef而，有点遗憾的是不像C/C++一样，它的枚举值只能大于等于0；为了尽量避免和你的语言内部使用的数据结构发生冲突，最好在Pro文件上加上比较容易识别的后缀，我添加的后缀就是_PRO;
消息类型数据定义:
message HsUserOrderListInfo_Pro                            //用户订单基本信息
{
         requireduint32                                    uOrderID= 1;                                        //订单查询标示;
         optionale_HsOrderState_Pro                   iOrderState= 2;                                   //订单状态ID
         optionalstring                                      szOrderState= 3;                                //订单状态
         optionalstring                                      szOrderType= 4;                                  //订单类型标示;
         optionalstring                                      szOrderTime= 5;                                 //订单生成日期;
}
message HsUserOrderList_Resp_Pro
{
         requirede_HsOperResult_Pro         eOperResult = 1[default = E_HSOPER_SUCCESS_PRO];
         repeatedHsUserOrderListInfo_Pro         Value =2;
}
1、数据类型
Protocol支持的基本数据类型还是比较多的如下表所示：



 N 表示打包的字节并不是固定。而是根据数据的大小或者长度。
   例如int32，如果数值比较小，在0~127时，使用一个字节打包。
   关于枚举的打包方式和uint32相同。
   关于message，类似于C语言中的结构包含另外一个结构作为数据成员一样。
   关于 fixed32 
和int32的区别。fixed32的打包效率比int32的效率高，但是使用的空间一般比int32多。因此一个属于时间效率高，一个属于空间效率高。根据项目的实际情况，一般选择fixed32，如果遇到对传输数据量要求比较苛刻的环境，可以选择int32.
2、字段名称
   字段名称的命名与C、C++、Java等语言的变量命名方式几乎是相同的。
   protobuf建议字段的命名采用以下划线分割的驼峰式。例如 first_name而不是firstName.
3、字段编码值
   有了该值，通信双方才能互相识别对方的字段。当然相同的编码值，其限定修饰符和数据类型必须相同。
   编码值的取值范围为 1~2^32（4294967296）。
   其中 1~15的编码时间和空间效率都是最高的，编码值越大，其编码的时间和空间效率就越低（相对于1-15），当然一般情况下相邻的2个值编码效率的是相同的，除非2个值恰好实在4字节，12字节，20字节等的临界区。比如15和16.
   1900~2000编码值为Google protobuf系统内部保留值，建议不要在自己的项目中使用。
   protobuf 还建议把经常要传递的值把其字段编码设置为1-15之间的值。
   消息中的字段的编码值无需连续，只要是合法的，并且不能在同一个消息中有字段包含相同的编码值。
   建议：项目投入运营以后涉及到版本升级时的新增消息字段全部使用optional或者repeated，尽量不实用required。如果使用了required，需要全网统一升级，如果使用optional或者repeated可以平滑升级。
4、默认值
当在传递数据时，对于required数据类型，如果用户没有设置值，则使用默认值传递到对端。当接受数据是，对于optional字段，如果没有接收到optional字段，则设置为默认值。
编程语言转换
ProtocolBuf支持针对多种语言的数据类型转换，当然还是以Java语言的转换最到位，悲催的C++数据转换竟然抹掉了所有的注释说明，因此，使用ProtocolBuf转换后的C++代码，需要你对着.pro文件去细看，还有就是针对C++语言的支持的一个缺陷是，如果数据内容完全相同，只是消息名称不一样的话，也不支持。转换之后，只需把.h和.cc文件加入到工程中，再引入Protocol的动态库即可。关于ProtocolBuf的转换工具也是开源的，虽然不太好用，但也是可以的，如果实在忍受不了，则自己写一个呗。
ProtocolBuf的缺陷;
ProtcolBuf的出现，可以说很好的解决了我的需求：免费、开源、短小、传输效率高，然而，它也有其自身的缺点：那就是还不够成熟，且数据易读性很差，相对Asn.1来说，因为已经是被纳入到国际标准中，并且使用了很长一段时间，因此根据其编码规则，很容易对传输的16进制数据进行抓包分析，通过相对专业的分析，就可以找出其中的问题，但ProtocolBuf是谷歌自己使用和编写出来的，协议尚未纳入到国际表中中去，仅靠抓包和码流分析，难以发现问题，不过，好在其是开源的，可以根据自己的业务数据，写出一套专门的数据拆分工具来，也可以使用网上已有的数据解析工具；另外一点就是调试比较难，发现有问题，调试起来并不能得心应手，因为转换后的语言信息可读性太差。有利就有弊，自己权衡吧。
附：
（转换后的C++代码和使用方法.h）
#include 
<google/protobuf/generated_message_util.h>
#include 
<google/protobuf/message.h>
#include 
<google/protobuf/repeated_field.h>
#include 
<google/protobuf/extension_set.h>
#include 
<google/protobuf/unknown_field_set.h>
#include 
"enum.pro.pb.h"
// @@protoc_insertion_point(includes)
 
// Internal implementation detail -- do not callthese.
void protobuf_AddDesc_publicmsg_2epro();
void 
protobuf_AssignDesc_publicmsg_2epro();
void 
protobuf_ShutdownFile_publicmsg_2epro();
 
class 
NetConnectReq_PRO_Msg;
class 
NetConnectResp_PRO_MSG;
class 
Net_CommonReq_PRO_MSG;
class 
Net_CommonResp_PRO_MSG;
class 
Net_BaseInfo_PRO;
 
//===================================================================
 
class 
NetConnectReq_PRO_Msg: public ::google::protobuf::Message {
 public:
  NetConnectReq_PRO_Msg();
  virtual~NetConnectReq_PRO_Msg();
 
  NetConnectReq_PRO_Msg(constNetConnectReq_PRO_Msg&from);
 
  inlineNetConnectReq_PRO_Msg& operator=(constNetConnectReq_PRO_Msg&from){
    CopyFrom(from);
    return*this;
  }
 
  inlineconst::google::protobuf::UnknownFieldSet&unknown_fields()const{
    return_unknown_fields_;
  }
 
  inline::google::protobuf::UnknownFieldSet*mutable_unknown_fields(){
    return&_unknown_fields_;
  }
 
  staticconst::google::protobuf::Descriptor*descriptor();
  staticconstNetConnectReq_PRO_Msg&default_instance();
 
  voidSwap(NetConnectReq_PRO_Msg*other);
 
  //implements Message ----------------------------------------------
 
  NetConnectReq_PRO_Msg*New()const;
  voidCopyFrom(const ::google::protobuf::Message&from);
  voidMergeFrom(const ::google::protobuf::Message&from);
  voidCopyFrom(constNetConnectReq_PRO_Msg&from);
  voidMergeFrom(constNetConnectReq_PRO_Msg&from);
  voidClear();
  boolIsInitialized()const;
 
  intByteSize()const;
  boolMergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream*input);
  voidSerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream*output)const;
  ::google::protobuf::uint8*SerializeWithCachedSizesToArray(::google::protobuf::uint8*output)const;
  intGetCachedSize()const {return_cached_size_;}
  private:
  voidSharedCtor();
  voidSharedDtor();
  voidSetCachedSize(intsize)const;
  public:
 
  ::google::protobuf::MetadataGetMetadata()const;
 
  //nested types ----------------------------------------------------
 
  //accessors -------------------------------------------------------
 
  //optional uint32 iMsgFrom = 1;
  inlineboolhas_imsgfrom()const;
  inlinevoidclear_imsgfrom();
  staticconstintkIMsgFromFieldNumber= 1;
  inline::google::protobuf::uint32imsgfrom()const;
  inlinevoidset_imsgfrom(::google::protobuf::uint32value);
 
  //optional uint32 iuserid = 2;
  inlineboolhas_iuserid()const;
  inlinevoidclear_iuserid();
  staticconstintkIuseridFieldNumber= 2;
  inline::google::protobuf::uint32iuserid()const;
  inlinevoidset_iuserid(::google::protobuf::uint32value);
 
  //optional string szAuthInfo = 3;
  inlineboolhas_szauthinfo()const;
  inlinevoidclear_szauthinfo();
  staticconstintkSzAuthInfoFieldNumber= 3;
  inlineconst::std::string&szauthinfo()const;
  inlinevoidset_szauthinfo(const ::std::string&value);
  inlinevoidset_szauthinfo(constchar*value);
  inlinevoidset_szauthinfo(constchar*value,size_tsize);
  inline::std::string*mutable_szauthinfo();
  inline::std::string*release_szauthinfo();
  inlinevoidset_allocated_szauthinfo(::std::string*szauthinfo);
 
  //optional string szCrcInfo = 4;
  inlineboolhas_szcrcinfo()const;
  inlinevoidclear_szcrcinfo();
  staticconstintkSzCrcInfoFieldNumber= 4;
  inlineconst::std::string&szcrcinfo()const;
  inlinevoidset_szcrcinfo(const ::std::string&value);
  inlinevoidset_szcrcinfo(constchar*value);
  inlinevoidset_szcrcinfo(constchar*value,size_tsize);
  inline::std::string*mutable_szcrcinfo();
  inline::std::string*release_szcrcinfo();
  inlinevoidset_allocated_szcrcinfo(::std::string*szcrcinfo);
 
  //@@protoc_insertion_point(class_scope:NetConnectReq_PRO_Msg)
 private:
  inlinevoidset_has_imsgfrom();
  inlinevoidclear_has_imsgfrom();
  inlinevoidset_has_iuserid();
  inlinevoidclear_has_iuserid();
  inlinevoidset_has_szauthinfo();
  inlinevoidclear_has_szauthinfo();
  inlinevoidset_has_szcrcinfo();
  inlinevoidclear_has_szcrcinfo();
 
  ::google::protobuf::UnknownFieldSet_unknown_fields_;
 
  ::google::protobuf::uint32imsgfrom_;
  ::google::protobuf::uint32iuserid_;
  ::std::string*szauthinfo_;
  ::std::string*szcrcinfo_;
 
  mutableint_cached_size_;
  ::google::protobuf::uint32_has_bits_[(4 +31) / 32];
 
  friendvoid protobuf_AddDesc_publicmsg_2epro();
  friendvoidprotobuf_AssignDesc_publicmsg_2epro();
  friendvoidprotobuf_ShutdownFile_publicmsg_2epro();
 
  voidInitAsDefaultInstance();
  staticNetConnectReq_PRO_Msg*default_instance_;
};
(.cpp)
#define 
INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include 
"publicmsg.pro.pb.h"
 
#include 
<algorithm>
 
#include 
<google/protobuf/stubs/common.h>
#include 
<google/protobuf/stubs/once.h>
#include 
<google/protobuf/io/coded_stream.h>
#include 
<google/protobuf/wire_format_lite_inl.h>
#include 
<google/protobuf/descriptor.h>
#include 
<google/protobuf/generated_message_reflection.h>
#include 
<google/protobuf/reflection_ops.h>
#include 
<google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
 
namespace {
 
const ::google::protobuf::Descriptor*NetConnectReq_PRO_Msg_descriptor_=NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetConnectReq_PRO_Msg_reflection_=NULL;
const ::google::protobuf::Descriptor*NetConnectResp_PRO_MSG_descriptor_=NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetConnectResp_PRO_MSG_reflection_=NULL;
const ::google::protobuf::Descriptor*Net_CommonReq_PRO_MSG_descriptor_=NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Net_CommonReq_PRO_MSG_reflection_=NULL;
const ::google::protobuf::Descriptor*Net_CommonResp_PRO_MSG_descriptor_=NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Net_CommonResp_PRO_MSG_reflection_=NULL;
const ::google::protobuf::Descriptor*Net_BaseInfo_PRO_descriptor_=NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Net_BaseInfo_PRO_reflection_= 
NULL;
 
}  //namespace
 
 
void 
protobuf_AssignDesc_publicmsg_2epro(){
  protobuf_AddDesc_publicmsg_2epro();
  const::google::protobuf::FileDescriptor*file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "publicmsg.pro");
  GOOGLE_CHECK(file !=NULL);
  NetConnectReq_PRO_Msg_descriptor_=file->message_type(0);
  staticconstintNetConnectReq_PRO_Msg_offsets_[4]= {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetConnectReq_PRO_Msg,imsgfrom_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetConnectReq_PRO_Msg,iuserid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetConnectReq_PRO_Msg,szauthinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetConnectReq_PRO_Msg,szcrcinfo_),
  };
  NetConnectReq_PRO_Msg_reflection_=
    new::google::protobuf::internal::GeneratedMessageReflection(
      NetConnectReq_PRO_Msg_descriptor_,
      NetConnectReq_PRO_Msg::default_instance_,
      NetConnectReq_PRO_Msg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetConnectReq_PRO_Msg,_has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetConnectReq_PRO_Msg,_unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetConnectReq_PRO_Msg));
使用解析（有删减但不影响阅读）
         NetConnectReq_PRO_Msgreq;                                   //请求消息类
         NetConnectResp_PRO_MSGresp;                    //响应消息类
         req.ParseFromArray(pBody,iBodyLen); //解析出请求消息内容
                   //将用户链路信息加入链接Map表中
         resp.set_eresult(E_OPER_SUCCESS_PRO);
         resp.set_iuserid(req.iuserid());
         resp.set_isrvtime(GetCurrentServerTime());
 
         intiTempBodyLen=resp.ByteSize();
         //响应消息要追加消息头
         intiRespLen=sizeof(CLIENTHEADER)+iTempBodyLen;
         char*pResp=newchar[iRespLen];
         if(NULL ==pResp)
         {
                   sprintf(szLog,"HandleConnectReq ConnectID=[%d], UserID=[%d], New Resp MsgSpaceFailer!",uConnectID,req.iuserid());
                   WRITE_LOG(m_pBaseLog,TYPE_ERR,szLog);
                   return;
         }
 
         memset(pResp, 0,iRespLen);
         if(resp.SerializeToArray(pResp +sizeof(HEADER),iBodyLen))
         {
                   //发送消息至客户端
                   m_pParent->SendMsgToIntf(uConnectID,pResp,iRespLen);
         }

在Linux下安装ProtocolBuf

这个网上有很多说明了，和其他所有的源码安装软解几乎是一样的，都是如下几个步骤：
tar zxvfprotobuf-2.5.0.tar.gz
cd protobuf-2.5.0
./configure --prefix=/usr/
make
sudo make install
/sbin/ldconfig –v
郑重说明，标注红颜色的两句，第一句tar zxvf protobuf-2.5.0.tar.gz针对我提供的这个资源不需要，因为是已经解压过的。第二句：/sbin/ldconfig –v是必须要的，否则，编译自己的源程序是，无法使用其共享库。

为了便于大家使用ProtocolBuf，我特地将下载好的ProtocolBuf版本共享给大家，具体见资源下载信息,资源宝贵，因此需要积分哦。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Linux内核工程导论——内存管理（三）
用户端内核内存参数调整
/proc/sys/vm/ （需要根据内核版本调整）
交换相关
swap_token_timeout
 Thisfile contains valid hold time of swap out protection token. The Linux VM hastoken based thrashing control mechanism and uses the token to preventunnecessary page faults in thrashing situation. The unit of the value issecond. The value would be useful
 to tune thrashing behavior. This tunable wasremoved in 2.6.20 when the algorithm got improved.

swappiness 
swappiness is aparameter which sets the kernel's balance between reclaiming pages from thepage cache and swapping process memory. The default value is 60. If you wantkernel to swap out more process memory and thus cache more file contentsincrease the value.
 Otherwise, if you would like kernel to swap less decreaseit. 
page-cluster 
page-cluster controls the number of pageswhich are written to swap in a single attempt. The swap I/O size. It is alogarithmic value - setting it to zero means "1 page", setting it to1 means "2 pages", setting it to 2 means "4 pages", etc.The default value
 is three (eight pages at a time). There may be some smallbenefits in tuning this to a different value if your workload isswap-intensive.

 
文件缓存相关
vfs_cache_pressure
 Controls the tendency of the kernel to reclaimthe memory which is used for caching of directory and inode objects. At thedefault value of vfs_cache_pressure = 100 the kernel will attempt to reclaimdentries and inodes at a "fair" rate with respect to pagecache
 andswapcache reclaim. Decreasing vfs_cache_pressure causes the kernel to prefer toretain dentry and inode caches. Increasing vfs_cache_pressure beyond 100 causesthe kernel to prefer to reclaim dentries and inodes.
nr_pdflush_threads 
The count of currently-running pdflushthreads. This is a read-only value. 
min_free_kbytes    
This is used toforce the Linux VM to keep a minimum number of kilobytes free. The VM uses thisnumber to compute a pages_min value for each lowmem zone in the system. Eachlowmem zone gets a number of reserved free pages based proportionally on itssize.

dirty_background_ratio    
参数dirty_background_ratio是当所有被更改页面总大小占工作内存超过 一定比例时，pdflush 会开始写回工作。用户可以增加这个比例，以增加页面驻留在内存的时间。

dirty_expire_centisecs   
参数dirty_expire_centisecs控制一个更改过的页面经过多长时间后被认为是过期的、必须被写回的页面。
dirty_ratio     
Contains, as a percentage of total systemmemory, the number of pages at which a process which is generating disk writeswill itself start writing out dirty data.

dirty_writeback_centisecs    
参数dirty_writeback_centisecs 是在pdflash线程周期唤醒的时间间隔。也就是每过一定时间pdflsh就会将修改过得数据回写到磁盘。
drop_caches  
Writing to thiswill cause the kernel to drop clean caches, dentries and inodes from memory,causing that memory to become free. To free pagecache:
echo 1 > /proc/sys/vm/drop_caches
To free dentries and inodes:
echo 2 > /proc/sys/vm/drop_caches
To free pagecache, dentries and inodes:
echo 3 > /proc/sys/vm/drop_caches
As this is a non-destructive operation, anddirty objects are not freeable, the user should run "sync" first inorder to make sure all cached objects are freed. This tunable was added in2.6.16.
laptop_mode 
在“笔记本模式”下，内核更智能的使用 I/O 系统，它会尽量使磁盘处于低能耗的状态下。“笔记本模式”会将许多的 I/O 操作组织在一起，一次完成，而在每次的磁盘 I/O之间是默认长达 10 分钟的非活动期，这样会大大减少磁盘启动的次数。为了完成这么长时间的非活动期，内核就要在一次活动期时完成尽可能多的 I/O 任务。在一次活动期间，要完成大量的预读，然后将所有的缓冲同步。
 
内存分配相关
percpu_pagelist_fraction 
This is thefraction of pages at most (high mark pcp->high) in each zone that areallocated for each per cpu page list. The min value for this is 8. It meansthat we don't allow more than 1/8th of pages in each zone to be allocated inany single per_cpu_pagelist.
 This entry only changes the value of hot per cpupagelists. User can specify a number like 100 to allocate 1/100th of each zoneto each per cpu page list. The batch value of each per cpu pagelist is alsoupdated as a result. It is set to pcp->high / 4. The upper
 limit of batch is(PAGE_SHIFT * 8). The initial value is zero. Kernel does not use this value atboot time to set the high water marks for each per cpu page list.
overcommit_memory 
Controlsovercommit of system memory, possibly allowing processes to allocate (but notuse) more memory than is actually available.
0 - Heuristic overcommit handling. Obviousovercommits of address space are refused. Used for a typical system. It ensuresa seriously wild allocation fails while allowing overcommit to reduce swapusage. root is allowed to allocate slighly more memory in this
 mode. This isthe default.
1 - Always overcommit. Appropriate for somescientific applications.
2 - Don't overcommit. The total addressspace commit for the system is not permitted to exceed swap plus a configurablepercentage (default is 50) of physical RAM. Depending on the percentage you use,in most situations this means a process will not be killed
 while attempting touse already-allocated memory but will receive errors on memory allocation asappropriate.
overcommit_ratio
 Percentage of physical memory size to includein overcommit calculations. Memory allocation limit = swapspace + physmem *(overcommit_ratio / 100) swapspace = total size of all swap areas
physmem = size of physical memory in system
max_map_count   
This filecontains the maximum number of memory map areas a process may have. Memory mapareas are used as a side-effect of calling malloc, directly by mmap andmprotect, and also when loading shared libraries. While most applications needless than a thousand
 maps, certain programs, particularly malloc debuggers, mayconsume lots of them, e.g., up to one or two maps per allocation. The defaultvalue is 65536.

mmap_min_addr     
This fileindicates the amount of address space which a user process will be restrictedfrom mmaping. Since kernel null dereference bugs could accidentally operatebased on the information in the first couple of pages of memory userspaceprocesses should not
 be allowed to write to them.    By default this value is set to 0 and noprotections will be enforced by the security module. Setting this value tosomething like 64k will allow the vast majority of applications to workcorrectly and provide defense in depth
 against future potential kernel bugs.
lowmem_reserve_ratio 
Ratio of totalpages to free pages for each memory zone.
legacy_va_layout   
If non-zero,this sysctl disables the new 32-bit mmap map layout - the kernel will use thelegacy (2.4) layout for all processes
 
其他
block_dump    
参数block_dump使块I / O调试时设置为一个非零的值。如果你想找出哪些过程引起的磁盘旋转（见/proc/sys/vm/laptop_mode），你可以通过设置标志收集信息。设置该标志后，Linux将会以文件的形式报告所有磁盘活动时的读写操作以及所有脏块。这使得它可以解释为什么一个磁盘需要旋转起来，甚至可以增加电池寿命。把block_dump输出写至内核输出，可以使用“dmesg”相关信息。当你使用block_dump和内核日志记录级别，还包括内核调试信息，你可能要关闭klogd，否则block_dump输出将被记录，导致不正常的磁盘活动有。
hugepages_treat_as_movable 
When a non-zerovalue is written to this tunable, future allocations for the huge page poolwill use ZONE_MOVABLE. Despite huge pages being non-movable, we do notintroduce additional external fragmentation of note as huge pages are alwaysthe largest contiguous
 block we care about. Huge pages are not movable so are notallocated from ZONE_MOVABLE by default. However, as ZONE_MOVABLE will alwayshave pages that can be migrated or reclaimed, it can be used to satisfyhugepage allocations even when the system has been
 running a long time. Thisallows an administrator to resize the hugepage pool at runtime depending on thesize of ZONE_MOVABLE.
hugetlb_shm_group   
hugetlb_shm_groupcontains group id that is allowed to create SysV shared memory segment usinghugetlb page
nr_hugepages 
nr_hugepages configures number of hugetlbpage reserved for the system. 
numa_zonelist_order 
This sysctl is only for NUMA. 'Where thememory is allocated from' is controlled by zonelists. In non-NUMA case, azonelist for GFP_KERNEL is ordered as following: ZONE_NORMAL -> ZONE_DMA.This means that a memory allocation request for GFP_KERNEL will get
 memory fromZONE_DMA only when ZONE_NORMAL is not available. In NUMA case, you can think offollowing 2 types of order. Assume 2 node NUMA and below is zonelist ofNode(0)'s GFP_KERNEL:
(A) Node(0) ZONE_NORMAL -> Node(0)ZONE_DMA -> Node(1) ZONE_NORMAL
(B) Node(0) ZONE_NORMAL -> Node(1)ZONE_NORMAL -> Node(0) ZONE_DMA. Type(A) offers the best locality forprocesses on Node(0), but ZONE_DMA will be used before ZONE_NORMAL exhaustion.This increases possibility of out-of-memory (OOM) of ZONE_DMA because ZONE_DMAis
 tend to be small. Type(B) cannot offer the best locality but is more robustagainst OOM of the DMA zone. Type(A) is called as "Node" order. Type(B) is "Zone" order. "Node order" orders the zonelists bynode, then by zone within each node. Specify "[Nn]ode" for
 nodeorder. "Zone Order" orders the zonelists by zone type, then by nodewithin each zone. Specify "[Zz]one" for zone order. Specify"[Dd]efault" to request automatic configuration. Autoconfigurationwill select "node" order in following case:
(1) if the DMA zone does not exist or
(2) if the DMA zone comprises greater than50% of the available memory or
(3) if any node's DMA zone comprisesgreater than 60% of its local memory and the amount of local memory is bigenough. Otherwise, "zone" order will be selected. Default order isrecommended unless this is causing problems for your system/application.
panic_on_oom
 This enables or disables panic onout-of-memory feature. If this is set to 1, the kernel panics whenout-of-memory happens. If this is set to 0, the kernel will kill some rogueprocess, by calling oom_kill(). Usually, oom_killer can kill rogue processesand
 system will survive. If you want to panic the system rather than killingrogue processes, set this to 1. The default value is 0.

stat_interval 
With this tunable you can configure VMstatistics update interval. The default value is 1. This tunable first appearedin 2.6.22 kernel.

vdso_enabled
 Whenthis flag is set, the kernel maps a vDSO page into newly created processes andpasses its address down to glibc upon exec(). This feature is enabled bydefault. vDSO is a virtual DSO (dynamic shared object) exposed by the kernel atsome address in every
 process' memory. It's purpose is to speed up systemcalls. The mapping address used to be fixed (0xffffe000), but starting with2.6.18 it's randomized (besides the security implications, this also helpsdebuggers

 
 
 
相关系统调用API
相关内核调用API
Linux性能工具
性能监控工具

性能测试工具



性能优化工具



版权声明：本文为博主原创文章，未经博主允许不得转载。

There is no Action mapped for namespace [/user] and action name [user!add] associated with context p
使用struts2.3进行动态方法调用时出现：
There is no Action mapped for namespace [/user] and action name [user!add] associated with context path错误，原因是
    （1）DMI可能导致安全问题
    （2）DMI与通配符方法功能有重叠，因此该版本Struts2默认关闭DMI，需要在struts.xml中加一句
<constant name="struts.enable.DynamicMethodInvocation" value="true" /> 来打开动态方法调用。动态方法调用官方推荐的做法是，使用通配符的形式。不要使用actionName!methodName的方式。



        本人尝试用方法2，问题解决！



版权声明：本文为博主原创文章，未经博主允许不得转载。

Spring中IOC编程
一：基本概念
1.ioc(inverse of controll ) 控制反转: 所谓控制反转就是把创建对象(bean),和维护对象(bean)的关系的权利从程序中转移到spring的
容器(applicationContext.xml),而程序本身不再维护.



2.di(dependency injection) 依赖注入: 实际上di和ioc是同一个概念，spring设计者认为di更准确表示spring核心技术


二：ioc编程操作案例
1.项目截图


2.基本代码
package com.cloud.ioc;
public class Student {
private String name;
public Student(){
System.out.println("Student被创建了");
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
}



3.项目配置代码
<?xml version="1.0" encoding="utf-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xmlns:tx="http://www.springframework.org/schema/tx"
xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd">
<!-- 配置bean的scope生命周期 -->
<bean id="student" scope="singleton" class="com.cloud.ioc.Student">
<property name="name" value="Spring"/>
</bean>
</beans>



4.测试代码
public class App1 {
public static void main(String[] args) {
// 从ApplicationContext中获取，获取方式一
//ApplicationContext ac=new ClassPathXmlApplicationContext("com/cloud/ioc/beans.xml");
//获取方式二
ApplicationContext ac=new FileSystemXmlApplicationContext("F:\\java\\Spring1\\src\\com\\cloud\\ioc\\beans.xml");
//获取两个学生比较学生地址
Student s1=(Student) ac.getBean("student");
Student s2=(Student) ac.getBean("student");
//输出结果为com.cloud.ioc.Student@1c5dd582||com.cloud.ioc.Student@1c5dd582
//可知s1和s2是同一个学生
System.out.println(s1+"||"+s2);
//从bean工厂获取,使用BeanFactory获取bean,只是实例化该容器
//容器的bean没有实例化，只有使用getBean获取bean时，才会实时实例化bean
//BeanFactory factory=new XmlBeanFactory(new ClassPathResource("com/cloud/ioc/beans.xml"));
//factory.getBean("student");
}
}



5.测试结果
Student被创建了
com.cloud.ioc.Student@1c5dd582||com.cloud.ioc.Student@1c5dd582






版权声明：博主原创文章，转载请说明出处。http://blog.csdn.net/dzy21

Linux内核工程导论——内存管理（一）
Linux内存管理
概要
物理地址管理
很多小型操作系统，例如eCos，vxworks等嵌入式系统，程序中所采用的地址就是实际的物理地址。这里所说的物理地址是CPU所能见到的地址，至于这个地址如何映射到CPU的物理空间的，映射到哪里的，这取决于CPU的种类（例如mips或arm），一般是由硬件完成的。对于软件来说，启动时CPU就能看到一片物理地址。但是一般比嵌入式大一点的系统，刚启动时看到的已经映射到CPU空间的地址并不是全部的可用地址，需要用软件去想办法映射可用的物理存储资源到CPU地址空间。
       通常CPU可见的地址是有限制的，32位的CPU最多看见4G的物理空间，64位的就更大了。所以目前的应用64位可能不需要考虑物理内存CPU可见物理空间的问题，然而32位的基本都是要考虑的。这就诞生了一个需求：动态映射。
       在linux系统中，例如x86架构，由于CPU可见的3G的空间给了用户程序，内核仅留下了1G，而存储的映射都要映射到这1G的，所以大于1G的内存不实用动态映射都无法访问。
       简单的说，就是当需要一个空白内存页的时候动态的将某个物理内存映射到一个地址，再需要就换下已经使用过的重新映射新的到这个地址。
应用程序地址空间隔离
       另外一个需求是现代的系统通常不止跑一两个程序，而每个程序又都可以看见和操作完整的地址，如此安装别人发布的进程就是一个危险性很高的操作。嵌入式系统的容易处理，但PC机就难以处理这个问题。因此每个程序在程序可见的地址空间隔离是非常必要的。于是有了虚拟的程序地址空间。每个进程见到的地址范围都是一样的，然而其访问同一个地址返回的数据却是不一样的。
申请和释放内存
       无论是用户程序还是内核程序，都需要使用内存，所以如何高效的分配和回收内存就是一个很重要的话题。
       实际的需求中，用户可以申请内存，但申请的内存不一定会使用，因此内核也可以不真实的为其预留内存，只是在其真正使用的时候才分配。这种内核机制叫做over_commit，就是内核可以为应用程序分配大于实际拥有的内存量。
       Linux内核会使用大量的空间缓存磁盘中的文件，这部分内存会用掉几乎所有的可用内存。当用户程序对内存有需求的时候，linux就会回收这部分内存的一部分，用来满足用户需要。所以，在linux程序的眼里，linux系统的可用内存几乎永远为0，然而申请内存又通常可以成功。
       这一些内存针对各个功能的需求而设计的机制共同组成了linux的内存管理机制。离开具体功能的内存管理机制是没有意义的。
       如此，内存管理主要有三个需求：动态的物理内存的管理、隔离的用户地址空间的管理和分配和回收内存。
源代码文件结构

       内存相关的，无论是基础架构还是服务于特定需求的代码都位于mm目录下。相关的头文件位于include/mm下。linux内核发展至今，基本的功能已经夯实，辅助功能越来越多。例如kasan用于内存的错误边界检查等。
 
内存组织方式
X86组织
       Linux内核内存以页为单位，但整体被组织为zone。一共有3个zone，DMA、Normal和High。DMA是由于有的硬件架构的DMA只能访问一部分地址（如intel的DMA只能访问低16M地址），有的系统可用物理内存远远超过了CPU可见的内存空间，如32位的CPU对于4G以上的内存就无法全部静态映射。但是由于linux的虚拟内存机制，内核能使用的所有空间仅有1GB（在一些架构可变）。
一般来说Linux 内核按照 3:1 的比率来划分虚拟内存（X86等）：3 GB 的虚拟内存用于用户空间，1GB 的内存用于内核空间。当然有些体系结构如MIPS使用2:2 的比率来划分虚拟内存：2 GB 的虚拟内存用于用户空间，2 GB 的内存用于内核空间，另外像ARM架构的虚拟空间是可配置（1:3、2:2、3:1）。
以x86为例linux中内核使用3G-4G的线性地址空间，也就是说内核总共只有1G的地址空间可以用来映射物理地址空间。但是，如果内存大于1G的情况下内核态线性地址就不够用了。为此内核引入了一个高端内存的概念，把1G的线性地址空间划分为两部分：小于896M物理地址空间的称之为低端内存，这部分内存的物理地址和3G开始的线性地址是一一对应映射的,也就是说内核使用的线性地址空间（VA）3G--(3G+896M)和物理地址空间（PA）0-896M一一对应，PAGE_OFFSET=0xC0000000；剩下的128M的线性空间用来映射剩下的大于896M的物理地址空间，这也就是我们通常说的高端内存区，这部分空间需要MMU通过TLB表来建立动态的映射关系。
也就是说，在linux下x86的32位系统，真正可以静态映射的内存只有896MB。当内存大于1G时就需要使用高端内存了，否则大于1G的内存就无法使用。所以三个内存的zone，前16MB对应着内核空间的0-16MB，Normal区对应着16-896MB，HIGH区对应着896-1G的动态区，可用大小实际是可变的。从这里我们可以看出如果不需要DMA区（DMA无限制），该区可以删除，如果内存不超过896MB，highmem区也可以删除。
因为内核在响应请求分配空间时是在3个区中都分配的，优先是normal，回收的时候也是3个区都执行回收的。如果能去掉一个区，对于很多内存操作就能节省很多执行代价。
Mips组织
Mips的highmem管理可参见其官方简介：http://www.linux-mips.org/wiki/Highmem
在MIPS32 CPU中不经过MMU转换的内存窗口只有kseg0和kseg1 的512MB的大小，而且这两个内存窗口映射到同一得0~512M的物理地址空间。其余的3G虚拟地址空间需要经过MMU转换成物理地址，这个转换规则是由CPU 厂商实现的。换句话说，在MIPS32 CPU下面访问高于512M的物理地址空间，必须通过MMU地址转换。即按VA=PA+PAGE_OFFSET公式映射的空间最大只有512M，其中PAGE_OFFSET=0x80000000，而在Linux中MIPS32只使用其中的256MB。
 MIPS在higmem使用过程中需要注意两个问题：一是要考虑由higmem带来的整个系统性能和稳定性间的平衡，二是highmem不支持cache aliases。
高端内存
高端内存映射有三种方式：
1.      临时映射空间
固定映射空间是内核线性空间中的一组保留虚拟页面空间，位于内核线性地址的末尾即最高地址部分。其地址编译时确定，用于特定用途（如VSYSCALL系统调用，MIPS的cache着色）。由枚举类型  fixed_addresses决定，内核在FIXADDR_START 到 FIXADDR_TOP 之间
在这个空间中，有一部分用于高端内存的临时映射。这块空间具有如下特点：每个 CPU 占用一块空间；可以用在中断处理函数和可延迟函数的内部，从不阻塞，禁止内核抢占；在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个 page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的 km_type 中。
当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。
接口函数：kmap_atomic/kunmap_atomic。使用从FIX_KMAP_BEGIN到FIX_KMAP_END之间的物理页
2.      长久映射空间
长久映射地址空间是预留的线性地址空间。访问高内存的一种手段。使用方式是先通过alloc_page() 获得了高端内存对应的 page，然后内核从专门为此留出的线性空间分配一个虚拟地址，在 PKMAP_BASE 到 FIXADDR_START 之间。
接口函数：void*kmap(struct*page)、 void kumap(struct*page)
该接口函数在高/低内存都能使用，可以睡眠，数量有限。对于不使用的的 page，及应该时从这个空间释放掉（也就是解除映射关系）。
#definePKMAP_BASE ((FIXADDR_BOOT_START -PAGE_SIZE * (LAST_PKMAP + 1)) & PMD_MASK)
#defineLAST_PKMAP 1024
3.      非连续映射地址空间
非连续映射地址空间适用于为不频繁申请释放内存的情况，这样不会频繁的修改内核页表。总的来说，内核主要在以下情况使用非连续映射地址空间：映射设备的I/O空间；为内核模块分配空间；为交换分区分配空间
每个非连续内存区都对应一个类型为vm_struct 的描述符，通过next字段，这些描述符被插入到一个vmlist链表中。
这种方式下高端内存使用简单，因为通过vmalloc() ，在”内核动态映射空间“申请内存的时候，就可能从高端内存获得页面（参看 vmalloc 的实现），因此说高端内存有可能映射到”内核动态映射空间“中。
接口函数：vmalloc(vfree)：物理内存(调用alloc_page)和线性地址同时申请，物理内存是__GFP_HIGHMEM类型（分配顺序是HIGH, NORMAL ,DMA ）（可见vmalloc不仅仅可以映射HIGHMEM页框，它的主要目的是为了将零散的，不连续的页框拼凑成连续的内核逻辑地址空间... ）；
vmap(vumap)：vmalloc的简化版；
ioremap(iounmap):分配I/O映射空间；
下图简单表达了linux内核对虚拟地址的映射，其中highmem区域用于对高端内存映射

申请和释放内存
       我们知道现代操作系统的内存都是按页划分组织的，可能不同的系统会在页之上添加页组等概念。但是内核内存管理的基本单元是页。所以，最基本的就是内核如何管理页。


启动时内存的申请和释放：bootmem
       Linux启动时的各个模块也有申请和释放内存的需求，但是此时内核的内存模型还没建立好。于是linux就提供了一个专门用在此时的内存接口bootmem，这个接口很简单，以页为单位，简单的搜索满足需求的连续页空间分配，并且可以应对物理上不连续的存储体。
       这个内存机制还有个最广泛使用的技巧，就是分配超大额的连续内存。因为在系统启动前，这个需求是容易满足的，但是启动后，由于模块众多，内存使用频繁换手，物理连续的内存很难得到，在启动时直接通过bootmem接口预留连续的物理内存后续使用是不二的选择。
       内核完全启动后，bootmem机制不再有效。
启动时ioremap：early_ioremap
       启动时ioremap调用还没有就绪，这时就提供一个早期的ioremap调用，叫做early_ioremap。
申请可DMA的内存
       Dmapool
Mempool
       申请内存池
Cma
连续内存分配器。在有这个之前，想要预留一大块连续的内存，基本只能使用bootmem在启动的时候预留，如此预留带来的代价就是linux启动后这部分内存对于内核不可用。而用户预留的内存又不一定一直在使用，导致内存的利用率低。

伙伴算法

       内存在底层是以页为单位分配的，上层一些的分配器如内核的slab，用户控件的malloc等都是在后台先申请了足够的页之后再对用户就行分配。如此后台关于如何申请页就有很多种思路，这些思路的最主要的评价标准有两个：如何最快，如何碎片最少。
       伙伴算法最被广泛使用的，该算法的核心思想是把内存提前分为大小不同的一系列内存块，当申请内存的时候返回最贴近需求内存大小的内存块，没有的合适大小的时候就可能拆分更大的。通过提前的安排，在牺牲内存利用率的前提下，尽可能的实现非碎片化。这个思想也不是一直有效，后来人们还加入了内存页的回收类型属性：可回收、可移动、不可回收。相当于定期的对磁盘进行磁盘整理来让不连续的空闲内存块重新连续起来。由于用户程序使用的内存页都是动态映射来的，所以后台只需要替换一下映射就能实现对用户程序透明的页面置换，所以这种做法的效率也是不错的。
       除了在分配上注意不产生碎片，内核也会定期的回收已经分发出去的页面。合理的分发加上有效的回收构成了linux内核管理的核心。
 
Slab
       内核中有很多常用的结构体,如果使用传统的根据大小进行动态分配,将会频繁的搜索链表,显然使用pool思想更合适.又由于常用结构体有很多,不可能为每一个定义一个池类型,合理的做法应该是尽可能的通用,这个被设计出来的结构体池就是slab内存管理机制.
       slab内存管理机制的得名是由于其将一种结构体的内存池命名为slab,内核中同时存在多个slab,分别是不同的常用结构体的池.为了适应SMP,让每个CPU都管理一系列的独立的slab.
       但是slab在numa上适应能力不行,slub在slab的基础上增加了numa的适应能力,还精简了slab的结构体,提高了slab的效率,但与slab提供的调用接口是一样的.
       二slob则是精简版的slab,增加了内存分配的碎片化概率，本质上是降低了效率,但是需要更少的资源开销(内存和CPU)，所以大部分slob是应用在嵌入式系统中，但是目前的嵌入式系统的计算能力也普遍强大，所以slob基本退出历史舞台。
 
内存策略：policy
       由于numa的出现，让用户程序可以控制自己的内存在哪里申请就有必要了。MPOL_DEFAULT, MPOL_PREFERRED, MPOL_INTERLEAVE和MPOL_BIND，内存策略会从父进程继承。
       使用的内存还可以移动，这是内存的migrate功能。


版权声明：本文为博主原创文章，未经博主允许不得转载。

