《小明的手机不见了？》
 
趋势科技自制的网络安全系列漫画《小广和小明的安全大小事 》首次登场，欢迎大家收看！不仅漫画情节精彩，而且处处都是安全常识哦！下面就为大家奉上第一集精彩漫画咯！看完记得分享给小伙伴儿噢！
 
 
看完漫画，问题来了：
你的智能手机有设屏幕锁吗?
    智能手机是最容易丢失的物品之一，万一落入心怀不轨的人手中，就不只是秘密照片会被外人看到，感到很囧咯。你最该担心的是手机中的联系人信息、网上银行或在线购物等这些服务可能遭到非法使用！
那么假如手机不慎丢失后怎么办呢? 
    设屏幕锁是大家都可以采取的防范措施之一。如果要解除锁定，必须输入事先登录的识别号码等认证信息，这样有助于避免智能手机遭到他人非法使用。
 


 

版权声明：本文为博主原创文章，未经博主允许不得转载。

想访问外网？越狱已不是问题!So Easy！时空隧道邀请码！
首先奉上邀请码：时空隧道邀请码 jXdqLw  (必备的哟！只有邀请码才可以注册这个时空隧道的账户，请大家牢记！)给你推荐一款海外网站加速工具，为科技工作者、海外归国人员、企业团队、外贸工作者提供海外上网服务，永久免费。 下面的网址需要成功越狱之后才可以访问的哟！！国外网址：https://chrome.google.com/webstore/detail/hfinpallhogllbckokkaefjjcjhjpnln国外网址：http://www.suidao.in/invi/jXdqLw国内网址：http://suidao.wuseyi.com/invi/jXdqLw时空隧道邀请码 jXdqLw欢迎大家走进越狱的世界！也许大家都会多少的抱怨国内限制访问外网过于严格，这也不许访问，那也不需访问。那么现在我就为大家奉上  访问外网  的超级简单得教程。相当管用！以图为鉴！  下面开始正式的越狱了！ 首先需要的软件有：谷歌浏览器（必备）其次  谷歌浏览器插件（必备）-----》  时空隧道   链接:http://chromecj.com/productivity/2015-04/419.html  下载时空隧道的压缩包，其中有一个叫做extension.crx的文件,将他拷贝下来，打开谷歌浏览器  打开谷歌浏览器找到菜单中的扩展程序如下面的图片！  随后将之前下载的时空隧道插件拖动到扩展程序的谷歌浏览器界面！如图所示！  这样插件就安装到谷歌浏览器当中了，我们就可以使用时空隧道的插件了！下面就是成功安装插件后的实例图！下面让我们开启时空隧道，准备越狱吧！ 首先我们需要注册时空隧道的账户！同时需要邀请码！再次奉上时空隧道邀请码 jXdqLw  (必备的哟！只有邀请码才可以注册这个时空隧道的账户，请大家牢记！)注册的过程就不需要我详解了吧！大家已经再熟悉不过了吧！ 这样我们注册成功后，我们就可以登陆时空隧道中，我们就可访问我们想访问的外网了！毫无顾虑了！下面感受一下外网的畅快吧！ 最后提醒一下各位，不要忘记激活账户哟！只需要将邮箱内的16位验证码输入到他的验证框里即可激活！不信你试试！   

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

Android文件存储

Android使用文件系统来读取和保存文件的， 相关的包请参照java.io包下面的文件。


1） 选择内部存储(Internal Storage)或者是外部存储(External Storage)
  Android设备有两个存储区域：内部存储和外部存储空间， 顾名思义， 内部存储是跟随android系统的， 外部系统是可拆卸的设备例如SD card等。 
  对于很多Android设备， 即使没有前面所说的外部设备(如SD card)， 系统同样提供在内部存储区域上提供了一块空间作为"外部存储"。因此即使
  没有可拆卸的外设，仍然后两套存储空间可供选择。API对两种外部设备是同样适用的。 下面是两种存储空间的一些特性：
  a. 内部设备(Internal Storage)
  1. 内部设备是一直存在的，并且是一直有效。
  2. 默认情况下，存储在内部设备上的文件只能被自己的app单独访问。
  3. 当卸载app的时候，系统会移除所有的保存在内部设备上的app文件。
  由以上特点可以看出， 内部设备适合保存那些只有自己的app访问的数据和文件。 比如登录后的用户信息， 数据库文件等私密信息。
  b. 外部设备(External Storage)
  1. 外部设备并不保证是一直存在且有效的。比如user可能挂载了外部设备然后移除了它。
  2. 外部设备是"公共区域"， 存储在外部设备上的文件无法控制其私密性，其他app可以读取操作它。
  3. 当卸载app的时候，系统只会移除存储在getExternalFilesDir()文件夹下的文件，其他的文件不会主动移除。 也就是说，会产生垃圾数据。
  对比内部设备， 可以看出外部设备适合存储那些不需要阅读权限的文件。
2） 获取读写权限。
  为了读取外部设备，需要在manifest中添加读写权限：
  <manifest ...>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    ...
  </manifest>
  值得注意的是， 现在所有的app均有能力读取外部设备，并不需要特殊的读权限。 但是在未来的Android版本中，会加入更多的限制。
  因此在你的app中，同样需要添加读权限已防备未来更新版本带来的麻烦。
  <manifest ...>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    ...
  </manifest>
  
  而读写内部设备不需要任何权限。 app拥有读写它的内部存储空间的权利。
3） 存储文件到内部设备
  当需要存储文件到内部空间时，可以通过File类的两种方法来获取存储路径
  getFilesDir()     会返回你的app的内部存储空间的路径
  getCacheDir()     返回你的app的内部存储空间的缓存目录， 如果缓存文件不太需要的话，请及时清理已保证缓存目录的以保证缓存文件不会占用太大空间，
  比如1M， 不然系统有可能在没有警告的情况下直接删除缓存目录下的文件。
  
  如果要在背部设备上创建文件，可以使用如下代码：
  File file = new File(context.getFilesDir(), filename);
  

  相应的，可以使用openFileOutput() 来获取FileOutputStream ， 然后通过它来写文件到内部设备。下面是例子：
String filename = "myfile";
  String string = "Hello world!";
  FileOutputStream outputStream;


  try {
    outputStream = openFileOutput(filename, Context.MODE_PRIVATE);
    outputStream.write(string.getBytes());
    outputStream.close();
  } catch (Exception e) {
    e.printStackTrace();
  }
  
  
  或者是，你同样可以使用createTempFile()来创建文件， 下面的例子是通过url获取文件名，然后保存在缓存目录下：
  public File getTempFile(Context context, String url) {
    File file;
    try {
        String fileName = Uri.parse(url).getLastPathSegment();
        file = File.createTempFile(fileName, null, context.getCacheDir());
    catch (IOException e) {
        // Error while creating file
    }
    return file;
  }

  
  内部设备的目录是以你的包名存储的， 从技术上来说， 如果你把文件保存成readble模式，其他的app可以读取此文件，当然它要知道
  你的包名和你的文件名。其他的app不能浏览你的内部文件夹， 如果你没有把文件属性设置为readable或者writable。
  只要你使用MODE_PRIVATE模式，其他的app就不能访问你的文件。
  
4） 外部存储空间
  因为外部空间是可拆卸的，因此在访问它之前，必须确保其存在。 Android提供了响应的接口来判断外设是否可用。当外设的状态为MEDIA_MOUNTED,即意味着外设可读写。
  下面的代码可以用来检查外设是否可用
  /* Checks if external storage is available for read and write */
  public boolean isExternalStorageWritable() {
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state)) {
        return true;
    }
    return false;
  }


  /* Checks if external storage is available to at least read */
  public boolean isExternalStorageReadable() {
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state) ||
        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
        return true;
    }
    return false;
  }

  
  前面也提到过，外设上的文件也有区别， 有的随着app的卸载会被系统同时删除，有些目下的文件不会同时被删除。
  因此， 根据你的文件的类型，你可以选择将他们保存在不同的目录下：
  共有文件：
  这些文件可同时被其他的app使用，当卸载时，不希望被删除，比如下载的图片，或者使用app拍摄的照片等。
  私有文件：
  你的app的单独使用的文件，在卸载时，希望同时被删除，尽管这些文件能够被其他的app访问，但对用户已经没有价值。例如一些缓存数据。
  
  当你保存共有文件时，可以使用getExternalStoragePublicDirectory()方法来获取外设的根目录，在此根目录上创建新的文件路径。
  这个方法需要指定你需要存储的类型，比如图片或者音乐等。例如：
  
  public File getAlbumStorageDir(String albumName) {
    // Get the directory for the user's public pictures directory. 
    File file = new File(Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created");
    }
    return file;
  }

  
  当你需要存储私有文件时，可以通过getExternalFilesDir()， 同样可以指定需要的类型， 例子如下：
  
  public File getAlbumStorageDir(Context context, String albumName) {
    // Get the directory for the app's private pictures directory. 
    File file = new File(context.getExternalFilesDir(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created");
    }
    return file;
  }

  
  如果不需要指定类型，可以传递null到getExternalFilesDir()中，它返回的是您的应用程序的在外部存储的根目录。
  
  记住两者之间的区别。
  
5） 查询剩余空间
  如果你知道需要保存的文件的大小，你需要保证有足够的空间来存储这些文件。
  可以通过getFreeSpace() 或者 getTotalSpace() 来获取文件的大小。
  
6) 删除文件：
  可以通过File的delete()方法来删除文件。或者通过context.deteleFile(fileName)来删除内部空间的文件。
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

IT行业中的六个肮脏秘密
我们向读者朋友征集在工作中遇到过的最肮脏的IT秘闻——那些来自灰色地带的谎言以及其他人根本意识不到的技术阴暗面。整理工作结束后，我们将这些"秘密"交给相关领域的专家，让他们对其进行分析。其中一部分得到了专家的共鸣，但另一些则未受肯定。IT专业人士往往若无其事地传播灰色谎言、玩弄技术业务的黑色权谋IT专业人士往往对问题背后的真正由来了如指掌——有时候，他们本人就是造成麻烦的罪魁祸首。我们向读者朋友征集在工作中遇到过的最肮脏的IT秘闻——那些来自灰色地带的谎言以及其他人根本意识不到的技术阴暗面。整理工作结束后，我们将这些“秘密”交给相关领域的专家，让他们对其进行分析。其中一部分得到了专家的共鸣，但另一些则未受肯定。系统管理员手中的权力足以成为CIO最恐怖的噩梦？IT员工仍然拿走企业设备？我们保存在云端的数据是否真会不翼而飞？技术支持服务开出的价码算不算高得离谱？通过今天的文章，我们将共同了解当事者与相关专家们的观点。IT肮脏秘密第一条：系统管理员抓着公司的小辫子IT这只黄鼠狼居然成了数据这只肥鸡的守门者任何一位关注过爱德华•斯诺登其人其事的朋友肯定已经了解到，一位系统管理员能够造成怎样的破坏。但即使是IT人士自己可能也无法想象，不受约束的管理员究竟拥有何等惊人的权力与危害性。“对于IT人士而言，根本不存在秘密这回事，”安全服务托管供应商Network Box USA公司CTO Pierluigi Stella表示。“我可以在自己的防火墙上植入探测工具，从而掌握特定计算机上进进出出的任何一个数据包。我能够看到人们在消息当中写下哪些内容、他们访问了哪些互联网站、在Facebook上写了些什么。事实上，道德是惟一一种能够约束IT人士不至于误用或者滥用这种权力的因素。IT人士完全就是存在于我们身边的国安局的缩影。这种情况相当常见，甚至大部分CIO都已经意识到了这一点，数据保护企业SafeNet公司首席战略官Tsion Gonen指出。“我估计九成以上的企业都面临着这样的危机 ，”他表示。“企业安全的可靠性与IT管理员的可信程度密切相关。我们很难准确弄清到底有多少系统管理员正在滥用自己手中的访问权限——但可以肯定的是，数量已经多到足以占据每星期的报纸头条。最可怕的是，安全风险往往来自那些负责为企业员工分配访问权限的家伙。”数据治理方案供应商Varonis公司副总裁David Gibson也认为，管理员一般确实有能力在神不知鬼不觉的情况下进行数据访问，但他提出了相对比较具体的比例数字——50%。他补充称，这样的问题并不只发生在管理员身上——大部分用户都有能力访问超出工作范围之外的更多数据。他表示，要想解决这一难题，方案可以归纳为两个方面：利用“最低权限”模式削弱员工的访问能力；持续对数据访问者进行监控。“企业需要有能力查看哪些员工访问了什么样的数据，这些数据归属于谁以及谁已经访问了其中的哪些文件，”他表示。“以此为基础，IT部门将能够与数据所有者直接接触，从而在削减权限与保持可接受的使用感受之间找到平衡点。”IT肮脏秘密第二条：员工很可能正在“以厂为家”那些“退休”了的IT资产很可能以出人意料的方式焕发第二春陈旧的技术设备很少真正被丢进垃圾桶，它们往往能快速找到自己的新家——有时候，“新家”与IT员工的家会产生交集。“员工盗窃被淘汰的设备早已不是什么新鲜事了，”Retire-IT公司CEO Kyle Marks指出——这是一家专门处理与IT资产有关的欺诈与隐私合规问题的企业。“我还从来没见过任何一位从未将公物占为己有的IT从业者。对于大多数人来说，拿点业已淘汰的设备并不算什么了不起的事情。很多人也不会将此视为安全威胁——一旦设备报废，他们会将其当成可以随意处置的东西。将设备从垃圾堆或者回收站里捡走的最大问题在于，其中很可能还包含有敏感数据。一旦这部分数据遭到曝光，很可能会给公司造成巨大损失，Marks指出。当然，即使没有什么后续麻烦，这样的行为本身也属于盗窃公司财产。“盗窃与欺诈属于很严重的事态，极有可能引发大规模隐私事故，”他补充称。“如果任由这种态势发展下去，无法无天的IT员工很可能将整个企业推向崩溃的边缘。然而在大多数情况下，负责确保所有资产得到妥善处理（即删除所有数据）的主管人士往往是IT部门的一员。企业需要建立一套‘逆向采购’流程，以保证资产遵循正常方式退出自己的工作岗位。”但是不是每一位IT员工都会对陈旧硬件伸出贪婪的双手？某位拒绝公布名字的资深IT资产处置从业者表示，实际情况与Marks所做出的推论相去甚远。“我并不是说盗窃活动并不存在，”他解释道。“我只是想说明，我从未遇到任何一位对陈旧硬件抱有固定处理模式的从业者。”他同时补充称，大部分设备之所以消失不见，主要是由于丢失或者其它一些难以说清的原因——例如被运到了错误的地点。“这听起来有些否定一切的倾向，事实上很多企业都对自身以完全诚实可信的态度提供安全服务、坚持处事方式的做法表示骄傲。”IT肮脏秘密第三条：将数据保存在云中——比你想象的更危险如果跟法律条文扯上关系，世界上任何一种安全机制都将无法保护我们把数据存储在云环境下确实很方便，但我们也很可能需要为这样的便利付出高昂的代价：在如同一团乱麻的法律诉讼当中，我们的数据将不翼而飞。“大多数人并没有意识到当自己的数据被保存在云环境中其他人的系统上、并与其它企业的数据比邻而居时，一旦对方遭遇法律纠纷、我们的数据也可能受到殃及而不得不被公之于众，”IT支持企业CSI集团老总Mike Balter指出。换句话来说，大家的云数据很可能由于针对他人的调查活动而遭受意外牵连——倒霉是惟一的理由，只是因为跟嫌疑方共用了一台服务器、企业就可能遭受严重损失。2012年1月就发生过一个典型案例，当时美国与新西兰当局关闭了Kim Dotcon公司的MegaUpload文件柜。除了确实涉嫌盗版的大量电影资料之外，当局还没收了成千上万来自守法客户的数据且拒绝归还。时至今日，这些可怜的普通用户仍然无法确定自己的数据还能不能被重新找回。“数据遭到扣押的风险是真实存在的，”Touro法律中心商业、法律与技术研究部门主任Jonathan Ezor做出证实。“如果执法部门或者其它政府官员拥有任何法律依据，则完全可以收缴存储设备或者系统——在某些特殊事件中可能需要获得批准——而这些系统中的数据无论是否存在嫌疑，都可能遭到剥夺。总之，任何一家企业的数据在存储于控制范围之外时，都将不可避免地受到某种程度的窥探——至少他人有权访问同一套硬件设备。要想保护自己免受这种最坏状况的影响，用户必须自己的数据到底被保存在哪里、哪些法律条文符合当前情况，云案例企业JumpCloud公司CEO David Campbell表示。“我们的建议是寻找一家能够对服务器及数据的物理位置做同保证的云供应商，例如Amazon，这样大家才能以主动姿态控制未知风险，”他指出。Ezor同时补充称，对数据进行加密能够有效防止获得数据的家伙成功解读其中的内容。另一个好主意是：在手头常备一份数据备份。我们真的不能确定什么时候这就成了企业的最后一根救命稻草。IT肮脏秘密第四条：员工勒紧裤带，老板却开出空头支票搞财务的最苦逼对于几乎任何一家中型或者大型企业来说，采购批准流程拥有两种执行方式，Hawkthorne集团CEO Mike Meikle指出——这是一家高级管理与信息技术咨询企业。首先是官方采购流程——时耗极长、我们需要像马戏团里的小猫小狗那样钻过一个又一个审批“火圈”。除此之外，还有一条特殊的“贵宾畅行版钻石通道”，当然只供少数“特殊人物”使用。“企业高管级别的人士都有自己的采购通道，”他解释称。“对于那些需要花掉IT人士八个月时间的审批流程，这些高管往往在几个星期之内就能搞定——这还是非常保守的估计。我将此称为‘贵宾畅行版钻石通道’。在我所接触过的政府机关或者私营企业当中，没有一个能彻底摆脱这种只存在于背地里的神秘采购途径。”官方流程之所以要刻意为难员工，就是不希望他们花企业的钱，Meikle指出——当然，除非他们能想办法走上这条秘密通道。他同时指出，遗憾的是CIO往往没有资格加入这个贵宾俱乐部，这意味着大型技术采购往往会在没有经过严格的成本分析或者考查IT战略方针的情况下就被敲定。“他们会一起出去吃午饭，供应商则在他们耳边不断灌输甜言蜜语；接下来的事情大家就都知道了：几十万美元被慷慨地抛出，换来另一套移动应用管理方案——这帮家伙根本没意识到企业已经有一套这种方案了，”他愤愤不平地表示。“现在我们有两套移动应用管理方案——要这么多干啥，拿来吃吗？”但事实并不一定如此，某位来自军方及财富百强企业的匿名人士提出反对意见。虽然很多企业确实可能回避了标准采购流程，但其中涉及的往往总是IT部门迫切需要的对象——这么做是不希望把时间浪费在繁文缛节之上，他表示。“非技术高管根本不具备制定大型采购决策所必需的IT知识，”他补充道。“如果某位高级行政人员回避了采购审核流程，执意签署采购订单并要求供应商发货，那么后续出现的一切技术失误都应该通过问责及追溯机制归结到这家伙身上。这就像氪石之于超人——是他们最大的克星。”IT肮脏秘密第五条：在客户支持的天平中站在弱势的一端技术人员只是在玩弄脚本而已相信大家对这样的情景不会感到陌生：我们通过手机与相隔半个地球之外的技术支持人员进行沟通，但在寥寥数语之后我们就发现对方的技术水平根本不行、只是在对客户照本宣科。猜猜怎么着？实际情况很可能正是这样。“IT支持是一种廉价商品，”Strive技术咨询公司总裁Tim Singleton指出——这是一家高端技术支持企业、专为中小型客户提供服务。“大部分能够帮得上忙的工具都不用花钱，计算机对使用者的知识要求也不再像过去那么严苛。我们邻居家的小女孩很可能与技术娴熟的达人一样有能力像IT企业那样解决你的计算机故障。”但也有人认为这样的结论太过武断。虽然某些简单问题确实体现不出技术支持团队的必要性，但在复杂问题方面专业建议仍然不可或缺，企业级远程IT支持方案供应商Bomgar公司服务与支持业务高级副总裁Aramis Alvarez指出。“将IT支持称为‘廉价商品’的不妥之处在于，我们不能对所有技术难题一概而论，”Alvarez表示。“某些基础问题确实能被熟悉技术的普通用户准确诊断，但病毒感染等更为复杂的情况则不行。邻家女孩也许真的具备不少技术知识，但她最终很可能对计算机上的数据造成严重破坏。”最后，我们不得不为了收拾残局而付出更高代价，New York Computer Help公司CEO Joe Silverman补充道——这样的问题往往发生在企业在技术方面偷工减料或者内部IT部门负担过重的情况下。“在日常工作中，我们发现纽约当地有很多办公组织及职能部门在以马马虎虎的态度对待计算机维修工作或者IT岗位——从其它公司拉人、找家庭成员顶替或者招揽半吊子水平的朋友，”他指出。“有时候财务部门的员工也会跑来客串解决计算机问题，但他们往往太忙或者经验不够丰富，无法修复发生故障的硬盘、主板或者电源。如果网络或者服务器发生崩溃，大家真的打算依靠财务员工完成这项工作、还是更信赖拥有二十年从业经验的资深网络工程师？”IT肮脏秘密第六条：我们知道的比你想象的多得多广泛收集数据，掌握全盘信息以为自己正处于国安局的密切监控之下？与消费者营销企业与数据代理商比起来，国安局真的只能算是小儿科。其中最大的黑手就是赌场，前任赌场数据库经理、曾根据个人经历撰写并出版《巧取豪夺：穿越繁荣之城》一书的J. T. Mathis这样说道。“当大家走进赌场时，押下的赌注绝不只是金钱——各位其实是在用自己的个人数据碰运气。”根据Mathis的估算，他前雇主营销数据库中大约包含十万个以上活跃或者非活跃的赌徒姓名。“从踏入赌场的那一刻起，大家的一举一动就处于追踪之下，”Mathis指出。“如果各位坐在一台老虎机前，赌场管理者会知晓你的当前位置、一共拉下过多少次手柄、投下过多少个硬币；他们知道你喜欢在4：30吃饭而且偏爱龙虾拼盘。他们清楚你最喜欢的香烟与酒水品牌、知道你是否在房间内观看色情节目。而在你暑期再度光临时，他们能够一眼洞悉随你一同前来的并非原配妻子，这样员工才能叫对她的名字‘Cindy’而非你太太的名字‘Barbara’。”前任赌场高管、现就职于路易斯安那州立大学的Michael Simon教授证实了Mathis的说法。但他补充称，赌场收集数据的方式与CVS、PetSmart或者Amazon相比并无多大区别。“我现在带的MBA班主攻数据库分析与发掘方向，我们调查过的所有企业都有收集客户信息并根据客户个人习惯提供服务的行为，”他表示。作为《我的游戏人生：前任赌场高管的个人视角》一书的作者，Simon补充称“这已经成为当下的常规商业惯例，而绝非什么不可告人的秘密。举例来说，我带着自己的狗到PetSmart享受特殊产品与服务，他们提供的项目一定符合我的个人消费习惯——我对此感到非常满意。从另一个角度看，PetSmart其实在以非常高效的方式提供我想要的东西、而不是浪费时间为我准备根本不可能接受的东西——例如折扣猫粮或者热带鱼。”但只有一件事有所不同：Mathis于2012年5月被赌场裁掉，但他当时手头仍持有数据库副本。而在尝试将副本还给赌场方面时，他的运气实在有些糟糕——对方拒绝接听他的电话——既然这样，他只好用手头的数据谈谈关于赌博的那些事儿了。

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

IT人必备的设计网址（推荐时空隧道谷歌插件访问外网）
下面是国外的设计网址：访问外国网址需要越狱，越狱的教程请访问下面的网址！http://blog.csdn.net/u011225629/article/details/47960675免费设计资源Freebbble: 网站搜集了来自 Dribbble 的免费素材.Dribbble: 在 Dribbble 中搜索 “freebie” 能找到许多免费的好东西.Graphic Burger: 这里的每一个设计资源都足够精致.Pixel Buddha: 为专业人士准备的设计素材，有免费的好资源，也有收费的进阶版.Premium Pixels: 为创意工作者准备的素材.Fribbble: Dribbble设计师的免费素材，项目由 Gilbert Pellegrom 所策划.Freebiesbug: 最新最热的PSD等设计素材，为设计师而生.365 Psd:每天一款免费的PSD.Dbf: 这里有来自Dribbble和Behance的免费资源.Marvel: 来自著名设计师的免费素材.UI Space: 来自那些炫酷的创意工作者的高品质设计资源.Free Section of Pixeden: 大量免费设计资源.Free Section of Creative Market: 每周一一波免费设计资源.Teehan+Lax: DiOS 8 GUI PSD (iPhone 6).Teehan+Lax: iPad GUI PSD.Freepik: 给每个人的免费平面设计资源.Tech&All: PSD，技术新闻，免费资源，都在这里.Tethr: 最漂亮的iOS UI设计工具.取色Material Palette: 帮你生成并导出Material Design配色模板.New Flat UI Color Picker: 最好的扁平化UI设计配色方案.Flat UI Colors: 漂亮的扁平化配色.Coolors: 超级快的配色方案生成工具.Skala Color: 为设计师和开发者而生的优质取色工具.Couleurs: 帮你抓取和调整屏幕上色彩的简单工具.Material UI Colors: 为Web、Android和iOS而生的 Material ui 配色模板.Colorful Gradients: 计算机自动生成的色阶.Adaptive Backgrounds: 从图像中提取主色.Brand Colors: 知名品牌的配色方案.Paletton: 配色方案设计.0 to 255: 帮助网页设计师找到某一色彩的同色系配色的工具.Colour Lovers: 创建、分享配色和配色方案.Adobe Color CC: 来自Kuler社区的优质配色组合.Bootflat: 来自扁平化设计的完美配色方案.Hex Colorrrs: Hex 转 RGB 转换器.Get UI Colors: 炫酷的UI配色.Coleure: 智能取色工具。Colllor: 配色方案生成工具.Palette for Chrome: 从任意图片生成配色方案的工具.灵感MaterialUp: 每日 Material Design 设计案例.FLTDSGN: 每日更新的最炫酷的扁平化的Web和APP UI设计.Site Inspire: 帮你获取灵感的网页设计案例.UI Cloud: 世界上最大的UI设计数据库.Moodboard: 在这里创建Moodboard，并轻松分享.Crayon: 最全面的营销设计收藏.Land-Book: 产品着陆页图库.Ocean: 设计师共享反馈信息的优质社区.Dribbble: 最炫酷的高品质设计师设计案例分享社区.Behance: 发现并展示充满创意的设计作品.Pttrns: 移动端界面设计模板.Flat UI Design: 扁平化UI设计.Awwwards: 评选最具创意、最创新也最优秀的网页设计作品.The Starter Kit: 为开发者和设计师所准备的设计.One Page Love: 单页设计案例.UI Parade: 设计案例与UI设计工具.The Best Designs: 最佳网页设计.Agile Designers: 为设计师和开发者准备的最佳资源.Niice: 有腔调的搜索引擎.免费图库Stock Up: 免费优质图片的集中地.Pexels: 搜集最佳免费图片的网站.All The Free Stock: 免费的优质图片、视频和图标.Unsplash: 免费的高清图库.Splashbase: 搜索和发现免费的高清图片、视频.Startup Stock Photos: 来这里，发现并创造更大的世界.Jay Mantri: 可以免费并任意使用的优质图片.Moveast: 这里记录了一个葡萄牙小伙的东行之旅.Travel Coffee Book: 分享旅行的每个美丽瞬间.Designers Pics: 免费可商用的高清图片.Death to the Stock Photo: 每月更新的免费图片.Foodie’s Feed: 高清免费的食物图片.Mazwai: 免费高清的视频短片.Jéshoots: 免费的现代风照片.Super Famous: 荷兰交互设计师 Folkert Gorter 的摄影作品.Picography: 免费高清图库.Pixabay: 免费高清图库.Magdeleine: 每日更新的免费高清图库.Snapographic: 可以商用的免费高清图库.Little Visuals: 每周发送7张高清免费图片到你收件箱的网站.Splitshire: 诱人的免费高清图库.New Old Stock: 来自公共档案馆的复古照片.Picjumbo: 完全免费的照片.Life of Pix: 免费高清图库.Gratisography: 免费高清图库.Getrefe: 免费高清图库.IM Free: 免费照片等资源的合集网站.Cupcake: 来自一个摄影师的款待，由 Jonas Nilsson Lee 创建.The Pattern Library: 免费的样式合集.Public Domain Archive: 100%免费的新照片.ISO Republic: 富有创意的高品质图片合集.Stokpic: 完全免费的照片Kaboompics: 获取免费照片的最佳途径.Function: 免费照片合集.MMT: 来自 Jeffrey Betts 的免费照片合集.Paul Jarvis: 免费高分辨率图片.Lock & Stock Photos: 为你准备的高清图片.Raumrot: 免费高分辨率图片.Bucketlistly: 充满创意的免费旅行照片.更多网站: Free Digital Photos | Morguefile | Public Domain Pictures | Stockvault | ImageFree |Rgbstock | Dreamstime | Free Images | Free Range Stock | Free Photos Bank.其他的精选免费照片:→ 来自 Free Goodies for Designers: (here | here | here | here | here | here | here | here | here |here.),→ 来自 Deal Jumbo: (here | here | here | here | here | here | here | here | here | here.),→ 来自 Dribbble: (here | here | here | here | here | here | here | here | here.),→ 来自 Graphic Burger: (here | here | here | here | here | here | here.)免费排版与字体资源TypeGenius: 为你的设计项目挑选最佳的字体组合.Font Squirrel: 100% 免费商用字体.FontFaceNinja: 帮你找到最佳字体的浏览器插件.Google Fonts: 为网页而生的免费开源字体解决方案.Beautiful Web Type: 来自Google Fonts的最佳字体设计.DaFont:可自由下载的字体存档.1001 Free Fonts: 可以随便选择的字体合集.FontPark: 世界上最大的字体存档.Font-to-width: 帮你适配文本宽度的工具.免费图标Fontello: 图标字体生成器.Flat Icon: 帮你在16000+免费矢量图标里搜索有用图标的工具.Material Design Icons: 来自 Google 的750个免费字符合集.Font Awesome:字体和CSS工具.Glyphsearch: 在其他的图标数据库中搜索图标的工具.MakeAppIcon: 一次生成全部尺寸图标的工具.Endless Icons: 充满创意的免费扁平化图标.Ico Moon: 4000+ 免费矢量图标和生成工具.The Noun Project:来自不同艺术家的上千创意图标.Perfect Icons: 社交图标创建工具.Material Design Icons: 750 来自 Google的免费Material Design风格图标.Icon Finder: 免费图标合集网站.Free Round Icons: Doodle Set | Flat Set | Vector Line SetIcon Sweets: 60 免费PS矢量图标.免费实用工具UI Names: 随机生成名字，可以在设计原型中使用.UI Faces: 查找并生成头像，用于UI设计.UI Blurbs: 设计原型时，可以帮你快速生成用户信息.Copy Paste Character: 点击复制工具.Window Resizer: 查看你的设计作品在不同屏幕上的显示效果.→ 生产力工具 ←帮你保持专注的环境音Noisli: 背景音和色彩生成器.Noizio: 帮你放松提高生产力的环境音.Defonic: 将各种环境音合成为旋律的工具.Designers.mx: 设计师的音乐播放列表.Coffitivity: 咖啡馆的环境音，帮你提升效率.防止分心Self Control: Mac: 帮你保持专注的应用.Cold Turkey: Windows: 帮你专注于工作的工具.组织协作Trello: 记录一切的工具.Evernote: 可能作为你一生记录工具的优秀软件.Dropbox: 世界上最优秀的网盘之一Yanado: 在 Gmail 中使用的管理工具.Wetransfer: 免费2GB的上传空间.Drp.io: 免费快速私密易用的图片托管服务.Pocket: 最好的稍后读软件，致力于成为你的图书馆的软件.Mailtoself: 一款iOS插件，让你可以在任何APP中向你的邮箱发笔记.List.ly: 发现并创建优质的列表.Markticle: 在文章中记录阅读进度的工具.远程工作Nomadlist: 那些适宜于远程工作的城市.Where Nomads at: 发现那些全世界范围内远程工作的同行们.Nomad Jobs: 那些最优秀的适宜于远程工作的创业项目.What’s It Like: 帮助旅行者找到最佳出行时机.→ 发现与学习 ←发现工具/初创项目Product Hunt: 最好的新产品策划，每天都有.Angellist: 世界范围内的初创项目.Beta List: 发现并加入属于未来的创业公司.StartupLi.st: 发现，跟踪，推荐初创公司.Startups List: 来自世界各地最佳的初创公司.Erli Bird: 伟大的新产品.协同创造Assembly: 共同创建新思路.CoFoundersLab: 在不同的地方不同的领域寻找你的合伙人.Founder2be:为你的创业公司寻找合伙人LEARNSkillshare: 帮你释放创造力的在线课程和项目.Khan Academy: 面向每个人的世界级免费教程.Coursera: 来自80+世界顶尖教育机构的免费课程.Codecademy: 免费的在线互动式代码学习平台.如何开始你的创业项目: As an Audio Podcast 或者 As Online Course.Startup Notes: 邀请优秀的创业者教你创业.The How: 向优秀的企业家学习Launch This Year: 帮你开始你的在线业务的网站.Closed Club: 查看失败的创业项目从中汲取教训.Startup Talks: 一个视频相关创业项目的合集.Rocketship.fm: 每周一次向成功创业者学习的机会.reSRC.io: 完全免费的在线编程学习的资源.那些还不错的资讯Email1K: 30天课程，让你的订阅邮件列表翻倍.Design for Hackers: 12周在邮件中学会设计.Startup Digest: 你所在领域创业项目的个性化资讯阅读.Mattermark Daily: 为投资人和创始人们准备的资讯.ChargeWhatYou’reWorth: 帮你提升自我价值的免费课程.Product Psychology: 用户行为研究方面的课程.UX Newsletter: 那些关于研究、设计和建筑的传奇.UX Design Weekly: 每周更新的优秀用户体验设计.一些有用的东西Foundrs: 联合创始人股权计算器.Ad Spend Calculator: 我的创业项目是否需要广告?HowMuchToMakeAnApp: 计算移动APP的研发成本.App vs. Website: 你应该制作一个网站还是APP?→ 商业与营销 ←免费的网站+LOGO+托管+发票HTML5 UP: 响应式的HTML5 + CSS3 网站模板.Bootswatch: 免费的Bootstrap主题.Templated: 845 款免费 CSS & HTML5 网站模板合集.WordPress.org | WordPress.com: 国外流行的博客平台（自备梯子）.Strikingly: 令人印象深刻的免费无限制网站托管.Withoomph: 漂亮的LOGO设计.Hipster Logo Generator: 时尚流行专业的LOGO生成工具.Squarespace Free Logo: 这里你可以免费下载低分辨率版本的LOGO.Hive: 世界范围内首款免费使用的云服务.Invoice to me: 免费的发票生成器.Free Invoice Generator: 另一个免费的发票生成器.Slimvoice: 极为简单的发票生成工具.免费的商务/项目名称生成工具The Name App: 为你你的项目找一个好名字Naminum: 发现完美的公司名称.Short Domain Search: 帮你寻找一个简短有力的名称.Wordoid: 帮你的项目找个简短容易记住的名字.Hipster Business Name: Hipster 商务名称生成器.Impossibility: 最佳的名称生成工具.Lean Domain Search: 快速生成网站名称.Domainr: 快速免费名称生成，短URL生成器.博客与写作Hemingway: Hemingway App 让你的写作清晰而醒目.Grammarly: 帮你找到文章中明显的错误.Medium: 来自大家的故事和想法.ZenPen: 为网站而生的轻量级写作工具.Liberio: 借助Google Drive简单快速地发布电子书.Editorial Calendar: 通过拖拽快速简便管理你的博客.Story Wars: 大家协同写故事.Headline Analyzer: 标题情感营销分析工具.WP Hide Post: 控制博客内容可见性的工具.Social Locker: 让用户通过发微博的方式来向你“支付”.Egg Timer: 标记并设定时间以便重复使用.发现内容（趋势、点子）Portent:创意内容生成器.Google Trends: 一种展示搜索趋势的新形式.Buzzsumo: 帮你分析不同内容的最佳展现形式.Hubspot Blog Topic Generator: 定制博客主题.Swayy: 发现最火爆流行的内容.其他: Google+最热 | Twitter 趋势 | Quora | Reddit免费的SEO+网站分析Open Site Explorer: 全面的链接分析工具.Ahrefs: 网站浏览器和反向链接监测工具.Quick Sprout: 为你的网站进行全面的分析.WordPress SEO by Yoast: 拥有一个有着全面优化的Wordpress网站.SEO Site Checkup: 免费帮你检测SEO问题.Hubspot Marketing Grader: 帮你进行营销分级.SimilarWeb: 不论你的网站在哪托管都可以对其进行统计分析.Alexa Ranking: 分析网站，网站排名.SERPs Rank Checker: 免费的关键字排名和SERP检查.网络安全技术(二)
          四，加密技术
        (1)加密算法与解密算法
        1基本流程
        A发送消息“Passwordiswelcome”这样的报文给B，但不希望有第三个人知道这个报文的内容，因此他使用一定
的加密算法，将该报文转换为别人无法识别的密文，这个密文即使在传输的过程中被截获，一般人也无法解密。当B
收到该密文后，使用共同协商的解密算法与密钥，则将该密文转化为原来的报文内容。
        加密与解密的流程示意图：


        2密钥
        加密与解密的操作过程都是在一组密钥的控下进行的，这个密钥可以作为加密算法中可变参数，它的改变可以改
变明文与密文之间的数学函数关系。
        加密的基本思想即是将明文转变为密文，而解密则是将密文转变为明文，这样保证了信息传输的保密性。密钥是
加重密算法中的可变参数，密钥的位数长度决定了加密算法的安全性。传统的密码体制包括对称密码体制和非对称密
码体制。
        (2)对称密码体制
        对称密钥技术即是指加密技术的加密密钥与解密密钥是相同的，或者是有些不同，但同其中一个可以很容易地推
导出另一个。
        对称加密算法中N个用户之间进行加密通信时，则需要N(N-1)个密钥。
        DES算法是一种迭代的分组密码，它的输入与输出都是64，包括一个56位的密钥和附加的8位奇偶校验位。目前比DES算法更安全的对称算法有：IDEA，RC2，RC4与Skipjack等。
       对称密钥技术：


       (3)非对称密码体制
       加密和解密使用不同的密钥，加密密钥为公钥是可以公开的，而解密密钥为私钥是保密的。不可能从任何一个密
钥推导出另一个密钥。因此，非对称密钥技术也被称为公钥加密加技术。
       非对称加密技术中N个用户之间进行通信加密，仅需要n对密钥就可以了。常用的加密算法有RSA算法，DSA算
法，PKCS算法与PGP算法。
       其中最常见的技术即为RSA算法，它的理论基础是数论中大素数分解，它的保密性随着密钥的长度的增加而增
强。但是，现在使用这种算法来加密大量的数据，其实现的速度太慢了，因此该算法现在广泛应用于密钥的分发。
       非对称密钥技术：


       五，防病毒技术
       (1)计算机病毒
       计算机病毒是指计算机程序中的一段可执行程序代理，它可以破坏计算机的功能甚至破坏数据从而影响计算机的
能力。计算机病毒通过对其他程序的修改，可以感染这些程序，使其成为病毒程序的复制，使之很快蔓延开来，很难
根除。
        (2)计算机病毒的特征
        1非授权可执行性
        2隐蔽性
        3传染性
        4潜伏性
        5破坏性
        6可触发性
       (3)计算机病毒分类
       1按破坏性分类
       2按传染方式分类
       3按连接方式分类
       (4)网络病毒
       网络病毒的特征：
       1传播方式多样，传播速度快
       2影响面广
       3破坏性强
       4难以控制
       5病毒变种多样
       6病毒智能化、隐蔽化
       7出现混合病毒
       (5)恶意代码
       1蠕虫
        蠕虫是一个自我包含的程序，它能够传播自身的功能或拷贝自身的片段到其他计算机系统(通常是通过网络连
接)。蠕虫是一种通过网络传播的恶性病毒，它具有病毒的一些共性，如传播性、隐蔽性、破坏性等等。与普通病毒相
比，而蠕虫不使用驻留文件即可在系统之间进行自我复制，它的传染目标是互联网内的所有计算机。
        2木马
       “木马”通常寄生在用户计算机系统中，盗用用户信息，并通过网络发送给黑客。与病毒不同之处在于没有自我复
制功能。“木马”程序是目前比较流行的病毒文件，但是它不会自我繁殖，也并不“刻意”地去感染其他文件，它通过将
自身伪装吸引用户下载执行，向施种木马者提供打开被种者电脑的门户，使施种者可以任意毁坏、窃取被种者的文
件，甚至远程操控被种者的电脑。
       传播途径：电子邮件，软件下载，会话软件。
       六，防病毒软件安装与配置
       (1)网络版防病毒系统结构
       1系统中心
       系统中心实时记录计算机的病毒监控、检测和清除的信息，实现对整个防护系统的自动控制。
       2服务器端
       服务器端为网络服务器操作系统应用而设计。
       3客户端
       客户端对当前工作站上病毒监控、检测和清除，并在需要时向系统中心发送病毒监测报告。
       4管理控制台
       管理控制台是为了网络管理员的应用而设计的，通过它可以集中管理网络上所有已安装的防病毒系统防护软件的计算机。
       管理控制台既可以安装到服务器上也可以安装在客户机上，视网络管理员需要，可以自由安装。
       (2)网络版防病毒系统安装
      对于大多数的网络版的防病毒系统，服务端和客户端通常可以采用本地安装，远程安装，Web安装，脚本安装等
方式进行安装。
       控制台的安装通常有两种方式：通过光盘安装控制台，远程安装控制台。系统管理员可以将管理控制台远程安装
到其他计算机上。
       (3)网络版防病毒系统的主要参数配置
       1系统升级
       从网站升级，上上级中心升级，从网站上下载手动数据包。
       2扫面设置
       3黑白名单设置
       4端口设置
       为了使网络版防病毒软件的通信数据能顺利的通过防火墙，通常系统都会提供用于数据通信端口设置的界面。(非
固定端口)
       七，防火墙技术
        (1)防火墙的主要功能
       1所有的从外部到内部的通信都必须经过它。
       2只有有内部访问策略授权的通信才能被允许通过。
       3系统本身具有很强的高可靠性，具有防攻击能力，保证自身的安全性。
       (2)防火墙的分类
       防火墙在网络之间通过执行控制策略来保护网络系统，防火墙包括硬件和软件两部分。防火墙根据其实现技术可
以分为：包过滤路由器，应用网关，应用代理和状态监测4类。
       1包过滤路由器
       实现包过滤的关键是制定包过滤规则。包过滤路由器分析所接收的包，按照每一条规则加以判断。包过滤规则一
般基于部分或全部的包头内容。例如，源，目的IP地址；协议类型；IP选项内容；源目端口号；TCK ACK标识。
       包过滤路由器的工作原理示意图：
 
        2应用级网关
        可以实现在应用层上对用户身份认证和访问操作分类检查和过滤。只要能够确定应用程序访问控制规则，就可以
采用双宿主主机作为应用级网关，在应用层过滤进出内部网络热定服务的用户请求与响应。
        应用网关的工作原理示意图：
 
        3应用代理
        应用代理完全接管了用户和服务器的访问，隔离了用户主机与被访问服务器之间的数据包的交换通道。
        应用代理的工作原理示意图：
 
         4状态检测
        状态检测能通过状态检测技术，动态地维护各个连接的协议状态。状态检测检测防火墙保留状态连接表，并将进
出网络的数据当成一个个的会话，利用状态表跟踪每一个会话状态。状态检测对每一个包的检查不仅根据规则表，更
考虑了数据包是否符合会话所处的状态，因此提供了完成的对传输层的控制能力。
        对返回受保护网络的数据包进行判断，只有那些响应来自受保护网络的请求的数据包才被放行。对于UP或
者RPC等无连接的协议，检测模块可创建虚会话用来进行跟踪。
        (3)防火墙的系统结构
        1包过滤型结构
        包过滤型结构是通过专用的包过滤路由器或是安装了包过滤功能的普通路器来实现的。包过滤型结构对进出内部
网络的所有信息进行分析，按照一定的安全策略对这些信息进行分析与限制。
       包过滤路由器的数据包转发过程示意图：
 
        2双宿网关结构
        双宿网关结构即是一台装有两块网卡的主机作为防火墙，将外部网络与通部网络实现物理上的隔开。应用级网管
暴露了整个外部网络，人们将处于防火墙的关键部位，运行应用级网管软件的计算机系统成为堡垒主机。
        连接了两个网络的多宿主机称为双宿主机。多宿主机是具有多个网络接口卡的主机，每个接口都可以和一个网
络连接，因为它能在不同的网络之间进行数据交换换，因此也称为网关。双宿网关结构即是一台装有两块网卡的主机
作为防火墙，将外部网络与同部网络实现物理上的隔开。
       双宿网关结构示意图;
 
       3屏蔽主机结构
        屏蔽主机结构将所有的外部主机强制与一个堡垒主机相连，从而不允许它们直接与内部网络的主机相连，因此屏
撇主机结构是由包过滤路由器和堡垒主机组成的。
       4屏蔽子网结构
        屏蔽子网结构使用了两个屏蔽路由器和两个堡垒主机。在该系统中，从外部包过滤路由器开始的部分是由网络系
统所属的单位组建的。属于内部网络，也称为“DMZ网络”。外部包过滤路由器与外部堡垒主机构成了防火墙的过滤
子网；内部包过滤路由器和内部堡垒主机则用于内部网络进行进一步的保护。
        屏蔽子网结构示意图：



版权声明：本文为博主原创文章，未经博主允许不得转载。

OCX 打包 CAB 与 JS 调用详细教程

    最近在做一个 WEB 项目，需要调用 OCX 进行连接读卡器读卡。本来并不想用 OCX 技术，因为 ActiveX 技术是微软出品，这样就导致整个系统只能使用 IE 浏览器(其他浏览器可以通过插件的形式支持 OCX 的调用)。但尝试了很多方法调用客户端 DLL 发现都走不通。最后无奈之下，才打算研究 OCX 技术。
    网上都说 ActiveX 技术很麻烦，会出现各种错误，不做的时候不知道，真正需要研究时候，才发现确实如此。主要问题是，报错和问题的真正原因没有关系或者说关系不大，甚至很多时候没有报错，只有不断尝试。
    言归正传，下面来讲一下如何搞定 OCX。
    首先先声明，本教程只关于 OCX 打包 CAB 和 JS 调用 OCX，这里不探讨如何通过 C++ 写 OCX。因为本人只做 Java 开发，对于C++ 并没有研究。
    开发系统：win8.1 64位
    测试通过系统：win7 64 位、win8.1 64位、xp 32位

  OCX 和 CAB 的关系。

    大家知道，得到 OCX 之后，如果想要调用，首先要注册。在不注册的情况下，没办法调用 OCX 。
    最简单的注册办法是手动注册。手动注册需要在命令行操作。对于开发人员来说，多多少少要和命令行打交道，可能没有问题，不过对于使用我们系统的客户来说，让他进行命令行操作的确不合适。不管我们文档写得多么详细，对客户来说这都是不友好的，而且手动注册也设计到安全性问题。所以就需要在客户不知情的情况下自动对 OCX 注册。这也就是 CAB 的作用。

    手动注册 OCX

    我们假设，OCX 所在的目录是：D:/ocx/xpbutton/xpbutton.ocx
 

    
     通过 regsvr32 xpbutton.ocx ，这样我们就手动注册了 OCX。
     如果想卸载 OCX，我们可以反注册：regsvr32 /u xpbutton.ocx 。
     注册和卸载，我们都需要以管理员身份运行 cmd 控制台。-- 这里特别需要注意！
     如果在注册时候出现下面的错误：
 

    
     1.首先查看是否以管理员身份运行 CMD。
     2.如果还是不行，可以考虑将相应的 OCX 放到系统目录下     
          a). 32 位系统放到 C:\Windows\System32
          b). 64 位系统放到 C:\Windows\SysWOW64
     3.如果还是报错，那可以确定是缺少 DLL 导致的。各位可以下载一个工具：Dependency Walker。
    看这里的教程，看少了哪些 DLL，去网上下载这些 DLL，这些 DLL 就是你必须要和 OCX 一起打包到 CAB
 压缩包里面去的。因为你自己电脑少了，说明客户电脑也同样可能会少这些 DLL。
     这里需要注意的是：首选的是和你系统相同位数的 DLL，肯定不会错，实在找不到 64 位的，才考虑 32 位的版本。
     下载了 DLL 后，将 DLL 存放到上面第二步提到的系统文件夹下面，然后再注册。

     OCX 打包 CAB

     首先下载 OCX 打包签名工具：ocx 打包签名工具，  访问密码 ddb4。





     将需要签名和打包的 OCX 和命令放到相同文件夹。



     制作签名证书：

          在命令行运行下面命令：
         1. 执行命令： makecert.exe -ss xpbutton -n "CN=这里随便" -sv .\xpbutton.pvk -r .\xpbutton.cer



 

        输入三次，密码，查看控制台出现 Succeeded 表示成功。
 


        此时生成文件：xpbutton.cert 和 xpbutton.pvk
 



         2. 运行命令： Cert2Spc.exe .\xpbutton.cer .\xpbutton.spc

          查看控制台，出现 Succeeded 表示成功。
 


         此时会生成文件：xpbutton.spc 



         两条命令结束，我们一共得到三个文件：xpbutton.cer、xpbutton.pvk、xpbutton.spc
 

     对 OCX 进行签名

          打包 CAB 之前，首先需要对 OCX 本身进行签名操作，这一步很重要，如果没做，你可能就犯错了。
          3. 运行命令：signtool signwizard






































        如果想要填写时间戳，可以填写以下地址：http://timestamp.verisign.com/scripts/timstamp.dll





        等待片刻，出现下面提示，则表示对 ocx 签名完成。


        控制台出现：Successfully completed signing wizard:<> 表示成功。



      编写 INF 文件
          INF 文件也是一个重点，如果编写错误，则不能正确打包。（各位可以下载本人编写的 INF 文件，在此基础上进行修改，保证 INF 文件的正确性）
          INF 参考文件下载地址：OCX inf 文件,  访问密码 49de。
       如果打包 CAB 没有问题 ocx 、dll 都会下载到 c:/windows/ocx/ 目录下，方便各位卸载 ocx ，删除 dll 文件。



[version]
signature="$CHICAGO$"
AdvancedINF=2.0

[DefaultInstall]
CopyFiles=files
RegisterOCXs=RegisterFiles

[DefaultUninstall]
cleanup=1
Delfiles=files
UnRegisterOCXs=RegisterFiles

[SourceDisksNames]
1 = %DiskName%, "xpbutton.cab", 1

[SourceDisksFiles]
xpbutton.ocx=1
msvcrtd.dll=1
mfc42d.dll=1
mfco42d.dll=1

[RegisterFiles]
%30%\Windows\ocx\xpbutton.ocx

[DestinationDirs]
files=30, Windows\ocx

[files]
xpbutton.ocx=xpbutton.ocx
msvcrtd.dll=msvcrtd.dll
mfc42d.dll=mfc42d.dll
mfco42d.dll=mfco42d.dll

[xpbutton.ocx]
file=thiscab
clsid={134EE1CC-4B8A-4E74-8C41-F4990065E2E1}
FileVersion=1,0,0,1
RegisterServer=yes

[msvcrtd.dll]
file=thiscab
FileVersion=6.0.8337.0

[mfc42d.dll]
file=thiscab
FileVersion=6.0.8168.0

[mcfo42d.dll]
file=thiscab
FileVersion=6.0.8267.0

[Strings]
DiskName="Windows\ocx"


        以上是本人的 inf 文件。解释几个部分。
           1.这里面添加了 3 个dll，如果各位不需要将 dll 打包到 cab ，则可以参照上面蓝色的部分。如果没有 mcfo42d.dll 则将蓝色的部分全部删除，其余的不动。以此类推。
           2.[xpbutton.ocx]
file=thiscab
clsid={134EE1CC-4B8A-4E74-8C41-F4990065E2E1}
FileVersion=1,0,0,1
RegisterServer=yes 
          进行简单解释：
              file=thiscab 照搬照抄，不解释。由于是 64 位系统，本人测试这么写没问题。
              32 位系统也可以这样写： file-win32-x86=thiscab 
              clsid 这里，最简单的办法是找到 ocx 的来源，询问制作 ocx 作者，他们知道这里应该填写什么。
              如果找不到制作人，也有办法，参照前文手动注册 ocx ，然后查看搜索注册表：xpbutton





           找到左边类似的注册表结构，然后 134EE1CC-4B8A-4E74-8C41-F4990065E2E1 将是我们需要的 clsid 了。
           注意：本人在 C:\Windows\ocx\ 目录下注册的 xpbutton.ocx 文件。所以上面右图地址才会是 C:\Windows\ocx\xpbutton.ocx 
           FileVersion 也是一样，最好的办法，找到 ocx 的来源(开发者)，确定版本号，编写 ocx 时，代码中会有 ocx 对应的版本号。当初和 C 沟通时，看过 ocx 的 C++ 代码，里面有对应的版本信息。这里的版本信息必须和 OCX 的版本信息一致。
RegisterServer=yes 表示下载下来后自动注册此 ocx 。
           大家可以看到我下面的 dll 文件的代码中都没有这一句，意思是 dll 下载下来后不需要注册，如果各位的 dll 也需要注册，对应 dll 区域也需要添加此语句。
          3.对 INF 文件中绿色的部分进行解释
          绿色的部分，表示 dll 的版本号，如何确定 dll 版本号。其实很简单。
          找到对应的 dll 右击，查看属性，这里的文件版本，就是我们需要的版本号，请注意，不是产品版本。 




     OCX 打包 CAB 文件

          4.运行命令：CABARC.EXE -s 6144 n xpbutton.cab xpbutton.ocx xpbutton.inf
          需要解释一下这条命令：是将 xpbutton.ocx xpbutton.inf 文件打包成 xpbutton.cab 文件，如果我们需要将额外的 dll 也打包到 cab 里面，那这样写：CABARC.EXE -s 6144 n xpbutton.cab xpbutton.ocx msvcrtd.dll xpbutton.inf 以此类推。

      对 CAB 文件签名
         对 CAB 文件签名的过程，可以查看上文对 OCX 文件签名的过程，除了第一步此处选择的是 CAB 文件之外。其余步骤完全相同。






    到目前为止，我们已经将 OCX 打包成 CAB ，但是到现在还不行。很多教程都到此为止，其实 OCX 的繁琐远还没有结束。


    JS 调用 OCX（CAB）


     引入 OCX 控件

          新建一个 HTML 文件，我们通过如下方式引入 OCX：


         一项一项解释：
         id="xpButton" 表示此 object 对象的 id 为 xpButton，命名随便都可以，后续会用到。
         classid="clsid:134EE1CC-4B8A-4E74-8C41-F4990065E2E1" 看到这个，应该很熟悉。classid="clsid:这部分照抄，不要改动。只改动冒号 : 后面部分就行了。（本人不小心把 clsid: 这一部分漏掉了，写成了 classid="134EE1CC-4B8A-4E74-8C41-F4990065E2E1"，结果 CAB 文件下载不下来）。注意：千万别漏了 clsid。
         codebase="./xpbutton.cab#version=1,0,0,1" 这一部分代码是告诉浏览器，如果找不到 clsid 为 134EE1CC-4B8A-4E74-8C41-F4990065E2E1 注册表，也就是系统中没有注册过此 xpbutton.ocx ，则去找对应的 xpbutton.cab 文件。这里 "./xpbutton.cab" 意思是和当前 html 存放在同一目录下的
 xpbutton.cab 文件。“./”表示当前路径，也就是 html 所在的路径。后面的 "#version=1,0,0,1" 表示当前 OCX 的版本号，也就是 CAB 压缩包中 INF 文件里面写的 OCX 的版本号（FileVersion）。注意版本号：1,0,0,1 是用逗号 "," 分隔，不是点号 "." ，如果你用了点号 "."，那么恭喜你，你又错了。 
         补充说明：我们遇到过三个版本号
                              1. OCX 编写时，C++ 代码中规定了 OCX 的版本号。
                              2. OCX 打包 CAB 文件时，INF 文件中规定了当前 OCX 的版本号。
                              3. HTML 调用 OCX 时，CODEBASE 表明了需要调用的 OCX 版本号。
          这三个版本号需要一致。
          很有意思的是，如果想要升级 OCX，其实很简单，让 OCX 编写人员升级 OCX，然后我们升级 INF 文件中的版本号，再把相应 HTML 中的版本号也升级。浏览器调用此 HTML 时候，如果发现 CODEBASE 中的版本号升级了，则会自动重新下载 CAB 文件，并重新注册。
          之前，为了测试 OCX 升级后是否本身有问题，手动注册此 OCX ，没有重新打包 CAB，结果每次访问都发现注册的是 CAB 中上一个版本的 OCX。说明只要发现注册过的 OCX 版本和 CAB 版本不一致的情况下，浏览器都会重新下载 CAB，并重新注册。
             这里还要说明一点就是，OCX 被编写出来后。clsid 就固定了。此 OCX 不管注册到哪台电脑上，查看注册表，clsid 都是一样的，不会改变。这也就是为什么我们在 HTML 里面，直接可以写上 clsid 的原因。因为客户下载 CAB ，自动注册后，OCX 的 clsid 就是我们编写 C++ 时候规定的 clsid。


         JS 调用 OCX 方法


          解释以上代码
          1. xpButton.AboutBox() ;
                    xpButton 其实不是凭空出现的，这里的 xpButton 是 <object> 标签的 id，大家看上面的截图可以看到，<object id="xpButton">……</object>。
          2. xpButton.AboutBox() ;
                    AboutBox() 其实是 OCX 中的一个方法。各位如果想要知道此 OCX 中有哪些方法，首选的是找 OCX 开发者，在找不到的情况下，通过 tstcon32 软件，各位可以在这里下载： tstcon32 ActiveX 容器   访问密码 904d。如果不能使用，根据报错提示下载相应
 DLL 即可。（研究 OCX 留下的后遗症，总觉得某些软件会缺少 DLL ）
          3. 为什么要 try catch
                    OCX 的繁琐和摸不着头脑，很重要的原因是，即使调用失败它也不会报错。所以，我们必须要在这里 try catch 手动弹出错误信息。但问题其实也没有那么简单，即使是有报错信息，提示也让人摸不到头脑。
                    注意，各位一定要记得 try catch，不然任何错误都不会有提示。
                    下面总结一下本人遇到的报错信息与真实原因的对应关系，以防止各位各种百度、Google 最后找到的是错误的解决方案。
                    OCX 报错，一般情况下，都是本机测试通过后，部署到服务器或者使用其他人的电脑，发现调用失败。
                    1. [object Error]、Error:找不到成员



                    如果是遇到上面的报错：[object Error] 、Error:找不到成员
                    1.首先确定 C:\Windows\ocx 目录下是否有下载的 OCX 文件（如果各位下载了本教程中的 INF 文件，则到C:\Windows\ocx 目录下去找），如果该目录下没有任何文件或者没有该目录，则就对照上文，查看是否是 INF 文件编写有问题，或者是 HTML 引入 OCX 对象有错误，导致下载失败。
                    2.如果 OCX 文件已下载，则表示虽然 CAB 文件没问题，但 OCX 未注册或者说是注册失败。注册失败的原因，我们首先需要确认是否是缺少 DLL 。如何确认，可以使用上文提到的 Dependency Walker 软件。如果发现确实是少了 DLL，那我们应该重新打包 CAB，将所缺少的 DLL 文件一起打包到 CAB 中。很多时候，我们通过 CAB 自动注册 OCX
 ，大多数情况下是不会报任何的错误的。即使是因为缺少 DLL 没有注册成功，也没有任何提示。本人在很多电脑上测试的结果是，只有一台 Win7，出现了缺少 DLL 的报错示，其他所有电脑都没有任何的错误提示。这里特别需要注意：打包 CAB 文件后，请用多台电脑进行测试，最好测试不同的系统，也尽量可以挑选公司非开发人员的电脑。千万别在自己电脑上测试通过，或者某些 OCX 开发者电脑上测试通过后便认为其没有问题。


                    2. 对象不支持此属性或方法
                    这个错误，在开发的过程中，是必然会遇到的。刚开始，一直以为是调用方式有问题，在尝试了网上能找到的所有其他不同调用方式后发现，并非如此。如果能保证 OCX 的正确性的前提下，此问题的根本原因是因为浏览器对于 OCX 不信任，拦截了 OCX 里面的方法调用。解决此问题的根本办法是修改浏览器设置。 



                         3.修改浏览器安全设置
                     网上可以找到很多浏览器的修改点，其实大部分不需要修改，修改了反而降低了安全性，增加风险。



                         反选“对该区域中的所有站点要求服务器验证(https)”，填上服务器地址，例如：http://192.168.0.61 然后添加，添加完成后，再次勾选"对该区域中的所有站点要求服务器验证(https)"。这一步的操作是保证浏览器信任此站点。






                         此处修改信任站点的安全性级别，将图上的两个，由原来的禁止，修改为提示或者启用。
                         其实在首次访问 CAB 网页前，我们就应该先修改浏览器安全性策略，修改完成后再访问，一般都不会出现什么问题。


        至此，OCX 的相关知识已经全部介绍完毕，此教程应该可以帮助大家少走一些弯路。这也是最近两个星期的研究成果。



        2015.08.26 补充
       1.注意：如果使用了 Java 开发，后台使用了 Spring。则应该在 Web.xml 中添加下面的代码。
  <servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>*.cab</url-pattern>
  </servlet-mapping> 
       上面代码告诉 Spring 不要拦截 *.cab 静态文件。

        2.JSP 引入 CAB 文件
 <div style="display:none;">
 		<object id="readcardOCX" width=400 height=100
                classid="clsid:F6F2B22E-FC89-489F-967B-9676EB269F55"
                 CODEBASE= "${pageContext.request.contextPath}/cab/readcard.cab#version=1,0,0,1"
                ></object>
 </div>
        在工程中引入 CAB 文件，我们需要写 CODEBASE= "${pageContext.request.contextPath}/cab/readcard.cab#version=1,0,0,1"        ${pageContext.request.contextPath} 表示工程名
       cab 文件存放在 webapp/cab 下面





















版权声明：本文为博主原创文章，未经博主允许不得转载。

Linux网络编程--字节序

1 .谈到字节序，那么会有朋友问什么是字节序 
很简单：【例如一个16位的整数，由2个字节组成，8位为一字节，有的系统会将高字节放在内存低的地址上，有的则将低字节放在内存高的地址上，所以存在字节序的问题。】

2 .那么什么是高字节、低字节？ 
也相当简单：【一个16进制整数有两个字节组成，例如：0xA9。 
高字节就是指16进制数的前8位（权重高的8位），如上例中的A。 
低字节就是指16进制数的后8位（权重低的8位），如上例中的9。】 
大于一个字节的变量类型一般有两种表示方法： 
 
例如：变量0xabcd在大端字节序和小端字节型系统中表示方法如图 
 
我们用代码验证一下我们自己的系统是小端还是大端吧 

#include <stdio.h>

/* 联合类型的变量类型，用于测试字节序
*   成员value的高低端字节可以由成员type按字节访问
 */
typedef union{
    unsigned short int value;                               /*短整型变量*/
    unsigned char byte[2];                              /*字符类型*/
}to;

int main(int argc, char *argv)
{   
    to typeorder ;                                      /*一个to类型变量*/
    typeorder.value = 0xabcd;                               /* 将typeorder变量赋值为0xabcd */

    /* 小端字节序检查 */
    if(typeorder.byte[0] == 0xcd && typeorder.byte[1]==0xab){       /*低字节在前*/
        printf("Low endian byte order"
                "byte[0]:0x%x,byte[1]:0x%x\n",
                typeorder.byte[0],
                typeorder.byte[1]); 
    }

    /* 大端字节序检查 */
    if(typeorder.byte[0] == 0xab && typeorder.byte[1]==0xcd){       /*高字节在前*/
        printf("High endian byte order"
                "byte[0]:0x%x,byte[1]:0x%x\n",
                typeorder.byte[0],
                typeorder.byte[1]); 
    }

    return 0;   
}

3 .字节序转换函数介绍 

字节序转换函数的使用：
#include <stdio.h>

/* 联合类型的变量类型，用于测试字节序
*   成员value的高低端字节可以由成员type按字节访问
 */
/* 16位 */
typedef union{
    unsigned short int value;
    unsigned char byte[2];  
}to16;
/* 32位 */
typedef union{
    unsigned long int value;
    unsigned char byte[4];  
}to32;

#define BITS16 16   /*16位*/
#define BITS32 32   /*32位*/
/* 按照字节打印，begin为字节开始，
*  flag为BITS16表示16位，
*  flag为BITS32表示32位， 
*/
void showvalue(unsigned char *begin, int flag)
{
    int num = 0, i = 0;
    if(flag == BITS16){
        num = 2;    
    }else if(flag == BITS32){
        num = 4;    
    }

    for(i = 0; i< num; i++)
    {
        printf("%x ",*(begin+i));   
    }
    printf("\n");
}

int main(int argc, char *argv)
{   
    to16 v16_orig, v16_turn1,v16_turn2; /*一个to16类型变量*/
    to32 v32_orig, v32_turn1,v32_turn2; /*一个to32类型变量*/


    v16_orig.value = 0xabcd;        /* 赋值为0xabcd */
    v16_turn1.value = htons(v16_orig.value);/*第一次转换*/
    v16_turn2.value = ntohs(v16_turn1.value);/*第二次转换*/

    v32_orig.value = 0x12345678;    /* 赋值为0x12345678 */
    v32_turn1.value = htonl(v32_orig.value);/*第一次转换*/
    v32_turn2.value = ntohl(v32_turn1.value);/*第二次转换*/

    /* 打印结果 */
    printf("16 host to network byte order change:\n");  
    printf("\torig:\t");showvalue(v16_orig.byte, BITS16);   /* 16位数值的原始值 */
    printf("\t1 times:");showvalue(v16_turn1.byte, BITS16); /* 16位数值的第一次转换后的值 */
    printf("\t2 times:");showvalue(v16_turn2.byte, BITS16); /* 16位数值的第二次转换后的值 */

    printf("32 host to network byte order change:\n");
    printf("\torig:\t");showvalue(v32_orig.byte, BITS32);   /* 32位数值的原始值 */
    printf("\t1 times:");showvalue(v32_turn1.byte, BITS32); /* 32位数值的第一次转换后的值 */
    printf("\t2 times:");showvalue(v32_turn2.byte, BITS32); /* 32位数值的第二次转换后的值 */


    return 0;   
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        2010到2015，我的6年投资理财经验总结和反思
 2010到2015，我的6年投资理财经验总结和反思0.理财意识和观念2010年，还在读大学。从大二开始，很少去网吧了，其它方面开支也不多。考虑到，未来想搞点什么事情，必须得积累一点资本。很早就意识到，经商做事都是需要资本积累的，对于平民阶层，原始资本积累是个漫长的过程。资本主义也好、资产阶级也好，有钱、有资源，不用从事具体的生产劳动就可以赚钱。相对于那些从事苦逼生产劳动的劳苦大众来说，虽然很不公平，但这就是很难改变的社会法则。总想着有一天，自己也可以富裕起来，不是为了买车买房，而是有钱才更有底气，可以自由潇洒地过日子，不用总是在担心，一年忙活到头，那日子鄙人确实不能接受额。1.银行与定期存款2010年的时候，当时攒了2000元左右的钱，想把它存起来。想来想去，真心没有很好的理财渠道，最终选择了银行定期存款。去银行开户，办理网银，当时选择的是“工商银行”，在学校（武汉科技大学-黄家湖校区）附近的“白沙洲大道-张家湾”。感觉好厉害，还记得是在附近的张家湾。单单是来回公交路费，就花了4元，还花了一上午的坐车排队时间，算算定期1年的收益，3.5%*2000=70元。认真计较一下，但从收益和付出来讲，感觉划不来哦。但是，也有好的地方，一是现金存到银行了，不用担心被偷。二是，定期存款，不会随便取出来，给自己一点“风险准备金”，万一哪天急用钱，还有救兵，总不至于饿死或露宿街头。三是，养成理财意识，从小钱做起。很多人觉得自己钱少，没有必要理财，这真是一种很有道理也很错误的思维。钱少，理财收益会很小，还要花心思去打理，确实让人不爽。错误的地方在于，越是穷人，越是应该“让钱生钱”，不能总是靠苦力劳动获得财富吧，稍微用点心思，一个雪糕、一瓶冰冻绿茶、一顿饭、一个手机、一台电脑的钱就到手了。你不信，反正我是信了，我目前的理财收益，可以买3台电脑。2.股市和股票基金上面也说了，我逐步有了打理钱财的意识。尤其是2010年，在看了“富爸爸”等不少财经理财类的图书后，我更觉得有必要让自己的“财商”牛逼起来。千里之行始于足下。2011年，尝试性地买了股票型基金。手上钱太少了，就把银行定期存款提前赎回了。这时就看出银行定期存款不好的地方了，提前赎回，利息非常少，完全当作活期算，真是坑爹啊，银行就是这么霸道。基金，当时是通过工商银行购买的，申购费率1.5%，赎回费率0.6%。一分钱没赚到，申购费用就花了不少。出于大胆考虑，买的是股票型基金-华夏优势增长和混合型基金-华夏混合成长。之前看了很多专家的分析，认为“股市总体是上涨的，定期买入，即传说中的‘定期理财’”，就每个月买入一定量的份额，这种方式要求长期坚持买入。在现在看来，我真得非常不认可这种做法，感觉太TMD坑爹了。这种理财方式，资金利用率很低，中国股市整体非常坑，08年之后尽是跌。经济增长很快，股市大跌，经济增长很慢，仍然大跌。中国股市就是一个完全的政策市，内幕交易等不合理现象大量存在。也没有多少“投资者”，“投机者”居多。在后来的实践当中，股市大跌的时候，我通常会“买入”，实际合适的时候，我也会选择“卖出”。在2011~2013年，最高投资达到2万（也可能是4万，记不清了），亏损最高的时候是5000元。我初次买入的时候是2011年3000点，毕业工作后，主要是发现股市涨跌比较影响我的心情，同时也没有发现，买股票型基金可以赚钱，就逐步赎回了自己所有的资金。最后算账，账面上基本保本，同比银行定期存款，实际是亏损的，通货膨胀这么严重，意味着大哥我的身价缩水了，还指望着有一天能和小马哥比一比了，这都亏成马了。2012年，我有一个判断，认为“习近平上台，会有一番新景象，股市应该会大涨”。结果，上台后的2012年，印象中就一次涨的比较多，然后又跌回去了，搞毛啊，死心了，就撤了。谁曾想到2014年底~2015年上半年，传说中的“改革牛”这么牛气，错过了，多少有点可惜，要不然大哥我的身价早就翻倍了。呵呵哒，你真以为能翻倍呢，作为一个理智的人，根本就不应该把所有的资金投入到中国这个“政策市”，除非你吃了“豹子胆”。股市的风险极大，你怎么知道什么时候，形势会“急转直下”呢。2015年，有10多天的时间，手头上有点闲钱，看着股市这么涨，就临时买了点，短期持有。第1次买入N元，随后大涨，随后大跌，再次买入N元，最后退出的时候，赚了100元。如果第2次不买入，会赚的更多。从最后结果来看，第2次买入的，是亏损不少的。哥机智啊，在哥全部赎回后，7月份股市连续暴跌，要不亏成马了。想起来，就有点后怕，赎回完全是因为要用钱，而不是预料到股市这么快会连续暴跌这么多。下尿了，再也不玩股票和股票基金了，除非哪天有闲钱同时心里又痒痒了，好了伤疤忘了疼，大家都这样。哦，对了，我还没有伤疤哦，差一点就有了。囧啊~15年买股票，还有另外一个出发点，是为了体验京东金融的服务。11年，是在银行买，也可以在基金官网买，手续费会低一些，京东上买的时候，有活动，免手续费，同时买入M元送N元现金。不免手续费就赚不到100元了，不亏就不错了。总的来说，第1阶段和第2阶段买股票型基金，账面回报都是保本，而且事后让人心惊胆寒。还玩个蛋啊。撤，撤，撤。3.余额宝，活宝啊13年，余额宝牛逼了，快速扩张了大半年，中央和银行没有干它。于是我从最初的“怀疑”到后面的“重仓”。怀疑是有的，银行定期存款利率还没有余额宝高，余额宝虽说是理财产品，但由于是“随存随取”，在老百姓看来，不就相当于活期么。从小规模尝试到重仓，到资金不断进出，最终余额宝收益是2000多元，够买一个不错的手机了。后来逐步理解了，余额宝就是货币型基金，主要用于银行同业拆借，以及短期债券，风险比较小。随后，百度百发等众多理财产品问世，让人应接不暇，处于支付宝的方便性，以及其它“活期类”理财产品收益没啥优势，就一直在搞余额宝了。4.P2P网贷14年回武汉找工作，加上13年和14年互联网金融概念的火爆，就注意到了P2P网贷。感觉这个行业很有价值，实现资金匹配，牛逼，就加入了一个P2P公司，同时投入了不少钱。P2P的利率完全碾压宝宝类，但是风险也大很多，跑路诈骗的P2P平台都成堆了。我还专门加入一个P2P跑路维权群，看着投资者在忙活，真心无奈额。从15年的视角来看，优质的P2P平台是少数，大部分平台没有很大的创新，完全就是把线下放贷搬到线上来嘛。呵呵哒。截至目前，P2P累计为我军创造了5位数的收益，把2台电脑的钱挣回来了。嘿嘿~5.股权众筹最近写过好几篇关于股权众筹的文章，写得很详细了，有兴趣的朋友可以去看看。股权众筹，风险较大，谨慎尝试。6.活期理财随着余额宝等宝宝类产品和P2P网贷的进一步发展和变种，目前有了不少“理财计划”类的理财产品，不少P2P网贷平台可以直接买理财，本质还是放贷债权，还有一些专注理财产品的产品，比如金蛋理财之类的。随存随取，收益率比余额宝高，因此，最近放了点钱进去，如果合适，今后较大的活期钱就放到金蛋理财算了。7.其它京东上买东西，可以用白条，一个月内免息，可以节省不少钱。同样的一笔钱，存到余额宝或者投入到P2P，是可以赚一点的。为此，想尝试性地办理信用卡，去了招商，搞了2次，都没给批。MD，优质客户都看不出来，招行坑爹货啊。京东上的“小金库”和余额宝基本是一种，还有其它的“妈妈理财”之类的，差不多。还曾想过，可以从银行办理贷款，然后投钱到P2P平台，赚利差，网上查过，还真有人这么干。风险点：P2P平台跑路，资金借款还款周期没有处理好难点：网上查询银行贷款流程，太麻烦了，各种资料，搞个信用卡都不给批，借款就算了吧，最后没能成型。美好的心愿，就这么破产了，还是老实做人，过日子吧~8.写在最后以上是我6年的投资理财经验，算是我的N多次尝试，目前没有账面亏损的投资，还是不错的。投资总是有风险的，股市暴跌、平台跑路、借款人不还钱的情况是可能发生的。下一篇计划写“我的投资理财策略”，根据我的经验和现状，说说我的投资理财策略。有兴趣，电话-微信-QQ联系。   小雷FansUnion   QQ：240370818   微信：FansUnion   湖北-武汉-循礼门   2015年8月21日

版权声明：本文为博主原创文章，未经博主允许不得转载。

良心干货｜如何惊呆你的面试官
原文出处： Medium   译文出处：Nextoffer   欢迎分享原创到伯乐头条最能揭示潜力的两项特质。根据几年前流传的一则故事，Google曾将它的Lvl.99数据处理技术应用于面试和业务评价过程，目的是要试着回答一个问题：面试中显示出的哪些特质最能预示其在公司里的成功。对处于事业初期的人事经理来说，答案结果是看一个人讨不讨人喜欢。（宝宝们，如果觉得这不准确或者对这故事有什么要补充的，请尽管喷我。）我不了解Google在这项调查中是否关注面试的其他作用，但凭借多年招聘以及同职场新人共事的经验，我知道我的答案会是什么，并且答案很简单。Are you self-aware, and are you proactive? 你是否有自（zi）我(zhi)意(zhi)识(ming)，是否有前瞻性？哦，当然了，工作能力强的都很引人注意。在交谈中发表一些有思想的见解会让人印象深刻。但如果你刚刚起步，通常人们会认为你还在培养自己的技能。如果你从事设计这一行的时间还不长，那你的作品可能还达不到尽善尽美的水准，或者之前你还从未考虑过产品和市场的贴合度问题。但这都不要紧，有一个问题比这些都重要得多：在学习能力方面，你的潜能如何？如今我共事的一些最出色的设计师，他们在面试的时候并不是技能最高的，但他们有潜力。他们会提问题，会把自己置于一种需要不断拉伸自己的环境中，并且他们会把这设为自己的目标，让自己变得更好。自我意识和前瞻性是一枚硬币的两面。如果你有自我意识，你就会知道自己擅长什么、不擅长什么。如果有你有前瞻性，你就会对此有所行动。 哦，天哪，我是一只盒子里。How do you become more self-aware and proactive?如何让自己变得更有自我意识和前瞻性？这个问题的答案可谓汗牛充栋，从林中冥想到记日记，从列清单到锻炼回旋肌，还有更经常地举手提问等等。为避免泛泛而谈，我将分享一套按部就班的方式，我把它叫作“需要计划时就做这个”计划。我过去从中获益匪浅，希望它也能帮到你。1. 打开一个新的写作窗口（或者如果你是老派写手，就用一支笔和一个Moleskine的笔记本）2. 记下3-5件你拿手的事情。然后再写3-5件你不怎么擅长、但想提高的事。3. 确保你的清单是准确的。问一问经理、老师、导师或是朋友，问他们眼中你最大的优点以及需要改善的地方有哪些。如果他们的回答跟你清单所列的完全不一致，不要灰心，再去问问你信任的其他人，直到与清单上所列的相吻合。4. 关注你的优点。当你读到每一项优点时，点点头并且在意识里牢牢抓住它。这些就是你的超能力。是的，它们是属于你的，看到适当时机就去应用它。想想过去你靠这些优点完成的那些出色的事情，例如你做的那件让每个人都觉得很厉害的事，或者你让一群人在某件事上达成一致的办法，想想下个月你能在哪3件事上发挥你的优点。它们不一定非得是什么大事，但是要具体，这样你可以把它们从清单里划掉。这些事会让你高兴，因为你能把它们做得很好。把你的优势清单贴在你天天都可以看到的明显位置（比如镜子上），因为这些事很棒，你很棒。5. 现在转向你的自我完善清单。对照清单上的每一项，想象自己三年内希望到达哪个程度。闭上眼睛然后真正展开想象，就像是看一段有关未来的你的录像。有没有一位拥有这项技能、让你敬佩、想要模仿的人？你会如何开展你的工作？从现在开始的三年里你会改变哪些事情的做法？未来的你给你什么感觉？你越清晰地看到这些，实现它们就越容易。6. 通过头脑风暴，想出3件自己下个月能做的事，让自己离自己的理想迈进一步。同样地，这里不需要很疯狂或雄心勃勃的计划，只要朝你的目标近一点就可以。例如每周请你的团队成员坐下来帮助你提高X。或者是每天花20分钟练习Y。如果你在制定计划方面遇到障碍，可以考虑和你信任的人坐下来一起完成。从我的经验来看，他们通常很乐意帮忙。7. 坚持你的计划。尽管去做，不过是用一个月时间做6件小事而已，没什么大不了。做一个核对清单，然后体会一下完成后将它们划去的满足感吧。8. 需要时进行重复。如果照着上面的办法做，你就会有所进步。就是这么简单。参加应聘某个职位的面试时，你就说出你的优点。描绘一下你的优点能帮你解决的哪类问题的场景。如果有面试官很明显会注意到的方面，你也可以谈一些你需要改善的方面。例如在分享过去一个项目的时候，不要试着去掩盖那些你不怎么感到自豪的方面。说出你不满意的地方，以及下次你做会有何不同。那些知道自己可以给团队带来什么、并且明白自己希望在哪些方面有所提高的求职者，是我想要共事的那一类人。今天你拥有哪些技能并不那么重要，只要你能很明显地表现出，你是个以后会拥有那些技能的人就行。弄清你所擅长以及不擅长的地方，然后行动起来吧。 本文借鉴：http://blog.jobbole.com/89865/

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

Failed to install metadata  only whitespace content allowed before start tag and not \u0
突然蓝屏，然后重启发现这个玩意已经不行了，编译就出这玩意，什么鬼
后面直接删了.m2目录下相关的：maven-metadata-local.xml 

版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode】SingleNumberII_137
package com.leetCode;

/**
 * Given an array of integers, every element appears three times except for one.
 * Find that single one.
 * 
 * Note: Your algorithm should have a linear runtime complexity. Could you
 * implement it without using extra memory?
 * 
 * @author Zealot
 * @date 2015年7月25日 下午6:16:12
 */
public class SingleNumberII_137 {
	public int singleNumber(int[] nums) {
		int ones = 0, twos = 0;
	    for(int i = 0; i < nums.length; i++){
	        ones = (ones ^ nums[i]) & ~twos;
	        twos = (twos ^ nums[i]) & ~ones;
	    }
	    return ones;
	}
	//遍历数组中每一个元素
	//计算每一个元素中，2进制中每一位加到一个总的数组里边，都加到一起之后，再与3取余，因为除了一个之外，都是出现了3次，只有那一个之出现了不到3次
	//最后数组转成数字
	public int singleNumber2(int[] A) {
        if(A == null || A.length == 0) return 0;
        int[] a = new int[32];
        for(int i = 0; i < A.length; i++) {
            for(int j = 0; j < 32; j++) {
                if((A[i] & (1 << j)) != 0)
                    a[j] = (a[j] + 1) % 3;
            }
        }
        int result = 0;
        for(int i = 0; i < 32; i++) {
            if(a[i] > 0)
                result |= (a[i] << i);
        }
        return result;
    }
	public static void main(String[] args) {
		SingleNumberII_137 s = new SingleNumberII_137();
		int[] nums = {1,2,3,3,3,2,5,2,1,1};
		System.out.println(s.singleNumber2(nums));
//		System.out.println(77>>1);
//		System.out.println(4>>1);
//		System.out.println(Integer.toBinaryString(4).length());
//		System.out.println("123456".length());
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

十年WEB技术发展历程
Ajax03年的时候我上六年级，那时候网吧刚在小县城的角落萌生。传奇，大话西游第一代网游一时风靡。我抱着试一试的心态给了网吧老板两块钱想申请个号玩玩，然后接下来的一个小时我一直在，注，册，账，号。彼时网吧用的512k的带宽，注册的时候，填了一堆信息，提交，页面跳转，嘣，”您填写的信息有误，请重填”。然后跳转回注册页面，以此循环。我现在时常想，如果当时ajax能普及开来，我就可以省2块钱了。那么ajax是什么?首先ajax是一种技术。以往的网页交互方式，用户在点击一个按钮后，比如提交按钮，用户就要等待漫长的数据和服务器的交互，期间用户无法进行任何操作，只能点根烟。而ajax所做的，就是在向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果我们可以再来处理这个事。其实ajax技术早在1998年的时候就已经由微软实现了，然而直到2005年2月，Adaptive Path公司的Jesse James Garrett发表文章"Ajax: A New Approach to Web Applications"，人们读了后觉得哎哟不错哦这个屌，这之后ajax才大规模普及开来。ajax的出现，极大了提高了web的用户体验。时至今日，即使国内IT发展再怎么落后，所有网站的登录注册也已经实现了ajax交互。用户点填写完信息后，页面不用刷新就可以知道信息提交成功与否，哪错改哪。另外ajax作为一种前后端分离的解决方案，也已经被国内大多数不很low的公司所采用，也间接导致了php等网页脚本语言的衰落。jQuery早年的js编程，代码的效率是极其低下的，这点尤其体现在操作dom上，开发者想要给一个按钮添加事件，要写长长一大段重复的代码去获取到这个按钮，再写长长一大段重复的代码去添加事件。尽管老油条会将常用的操作封装起来，但是对于不会封装的新手，这无疑是很痛苦的一件事，尤其再加上各种各样的兼容。2006年，本着拯救菜鸟，让他们do more的宗旨，jquery诞生。jQuery诞生的意义，一是对ie6 7 8 及各种割据一方的浏览器做好了兼容，二是极大简化了dom操作，使开发效率大大提升。jquery很火爆，火爆的有些前端只会写jquery而不会写原生js的程度。时至今日，说jquery write once，see everywhere已经不为过了。jquery的另一个意义（我认为）在于，它催化了人们对前端的兴趣与探索，相比linux，你用很低的成本，就可以写出一个让不懂编程的妹子说欧巴你碉堡了的效果，让人们觉得哎哟（又）不错哦这个屌。此后大量的类库和基于jquey的插件雨后春笋般诞生，前端行业歌舞升平欣欣向荣，网页开发进入一个新时代。Chrome天下武功出谷歌。在ie6,7,8的时代里面，尽管Firefox也缓慢的挑战ie的地位。但和2009年开始Google开始推广的chrome浏览器产生的颠覆性影响比起来，逊色很多。Chrome使用Apple的开源内核webkit，良好的设计标准和市场反应；促进浏览器快速迭代，让IE在windows10中彻底消失。chrome浏览器的推出，将简化前端的入门程度又推进了一步，其自带的调试工具好用又无脑，我们可以利用其轻松的查看网络状态，加载顺序，进行断点调试等，同时谷歌的插件功能，又给开发者提供了极大便利。目前chrome最新版开始采用blink内核，测试版本中，已经可以对css3动画进行追踪和调试。在我还没有想象到的时候，chrome已经实现了它。一句话，没有chrome，就没有新中国，就只能用firefox了。GitHub随着软件项目的迭代加快，项目版本工具也不断的演进，经历CVS, SVN,GIT。到目前为止CVS差不多已经从互联网行业慢慢消失，SVN作为文件和文档存储存在，由linux内核发明人Linus创建的版本工具GIT现在作为代码版本标准。Github依赖于git成为开发人员团队协作的社区！到2015年1月github上已注册的开发人员超过一千万，开源项目几千万。其中2014中国研发者在github上增长最快。你几乎可以在上面找到一切你想要的代码…比如username..password..OAUTHOAuth1或OAuth2与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码）。 产生背景：最常见的服务场景，用户需要使用两个不同企业的服务，登录验证A企业，下载内容；然后登录验证B企业，上传内容到B企业服务，复杂又耗时。无论是用户，还是A、B都会想要互通服务。这就产生了核实身份的需求。旧的用户名、密码机制会造成A/B企业有权限查看甚至修改对方的用户资源。为了达到确认身份、服务互通，Google、Yahoo、Microsoft牵头促使OAuth1.0产生。之后的OAuth2.0是各大互联网企业基于https安全的一次新规划。目前最常见的应用场景主要在授权登录上，如微信、qq、微博等等。JSONJson虽然是2001年就产生的标准，但被广泛应用是在2008年之后各种Ajax应用、iPhone、Android设备流行之后。旧的服务体系多是企业级，所以XML对java型的企业级服务定位有益。但对于流量限制，语义简单的API服务来说，XML庞大、冗余、不易学又占带宽。去年我刚工作的时候，后台给我返回一个数组，没有发言权的我在是要遍历这个数组还是转化为json格式之间纠结了很久。Json的普及，从另一个角度体现了web开发的一个优势，不管你后台是java ruby php还是python，你只要给我一个json格式的接口，我就能撑起整个地球。DJANGO&RAILS敏捷开发打破了项目研发模式。在2010之后的WEB2.0时代，Html5盛行，前端工作被分离出去，PHP那种网页脚本的优势没那么明显，虽然在CMS和论坛模板上依然有优势。Django和Rails的最大优势在于，他让个人或两三个的小团队，实现整套产品成为可能。以Instagram为例，最初两个python工程师用django快速实现了服务端的所有功能，在用户增长时，再将大访问量和大数据量的服务独立出去。尽管现实残酷，rails每况日下，IE8和rails谁先消失只是先后问题，但其提供的解决方案还是被很多后生所效仿。人们都会记得这朵昙花。Bootstrap2011年Twitter开源的网页端GUI框架。jquery兼容了不同浏览器的js部分，bootstrap则兼容了不同浏览器的css部分。甚至于说，作为一个后端开发，你无需了解css，无需前端，无需设计师，只要看一看bootstrap的文档，就可以搭起一个美观大方的后台管理系统。常见类似的GUI框架还有zurb的foundation,google的materialize，百度也曾出过一个名为GMU的移动端框架。就我个人来说，我并不喜欢这些gui框架，尽管他们简化了css，实现了一些很炫酷的效果，尽管我在项目中也用到过这些，尽管我不想承认我是绿茶。这些框架最大的缺点就是，千篇一律，所有的页面都是一个样子，一样的nav，一样的sidebar，一样的表单，连鼠标点上去放个光都一模一样。就像我如果长了三条腿（虽然确实长了三条腿）别人会说我很别致让他们眼前一亮，但如果所有人都长了三条腿，web也就失去其魅力了。另一个缺点是臃肿，一个css就走100多k的流量，其js插件又大都依赖jquery，忍心么。当然，其为了解决响应式提出的栅格化html的思想还是很值得借鉴的。IOS & ANDROID系统的普及2009年之后IOS和Android的快速发展，导致WEB开发发生以下改变：1. html5在移动浏览器上优先实现，Android和IOS设备全面支持html5、CSS3，加速了IE消失。2. 上网随时随地发生。鼠标点击、内容繁复的网页越来越简洁，响应式设计快速流行。3. APP和服务器交互大部分和网页一样基于HTTP协议，webapp，hybrid app的概念被提出。关于webapp，这里简单说下web相比原生的优势。跨平台：常说的一次编译，到处运行免安装：打开浏览器，就能使用快速部署：升级只需在服务器更新代码，而不像客户端需要更新版本超链接：可以与其他网站互连，可以被搜索引擎检索听起来刁刁的，这些优势却经不住推敲。首先，不同系统的用户使用习惯是不同的，ios用户返回按钮习惯在左上角，而安卓用户却习惯在屏幕最下方的位置，产品经理问，那放在哪儿。呵呵哒不知道。其次，曾经看过一个调查报告，问用户更喜欢用客户端还是web端。喜欢客户端的用户远远超过了web端。你问我喜欢什么，我也是喜欢客户端。你问我为什么，我觉得比较有安全感吧，而且更新版本让我觉得很爽，很有存在感，让我知道我并没有被世界遗忘，让我知道你们产品在更新，在为我操心。另外超链接..我一个客户端要你seo干什么。这还没完，webapp的缺点还有一大把，最大的缺点莫过于没有GPU加速，想要实现一个复杂一些动画，真是要了浏览器亲命了。其次网页是单线程的，加载dom时会阻塞js，导致的结果就是，卡。一卡就烦了，烦了就关了，用户减一。而hybrid就不同了，hybrid app的意思是混合原生应用，将需要频繁更新的页面作为web放在远程更新。这是一个靠谱的解决方案，BAT有很多案例，如微信发布的JS SDK，掌上百度和淘宝客户端Android版。当然这里边的坑有很多，有机会，我把我踩过的坑讲给你们听。NodeJS我纠结了一会node属不属于前端范畴的问题。我认为是属于的。解决高并发一直是后台哥哥们乐于讨论的问题，比如咱们的好近实时监控系统，理论上每个连接都会生成一个新线程，每个新线程可能需要 2 MB 配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着用户的增长，咱们希望监控程序支持更多用户，这样，就必须添加更多服务器。当然，这会增加业务成本，尤其是服务器成本。除了成本上升外，还有一个技术问题：用户可能针对每个请求使用不同的服务器，因此，任何共享资源都必须在所有服务器之间共享，到这里，技术就到了瓶颈。node诞生的初衷，就是为了解决这个问题。node解决这个问题的方法是：更改连接到服务器的方式。每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程，并为其分配一些配套内存。nodejs属于服务器端语言，在前后端分离这场圈地运动中是前端的一个有利武器，同时在前端自动化上也提供了大量的可编程工具（grunt,bower,gulp等），淘宝百度对nodejs的热度一直很高，自然而然我认为这是一个趋势。去年美团成立了美团酒店的团队，选择了node作为后台语言，圈走了后台大部分的工作。我在想，前端js加上node再加上对UI的技能需求，以后前端工程师是不是该叫全端工程师了。BIG DATA大数据大概是过去几年最火热的名词，我一大批同学听说数据挖掘年薪30万都嗷嗷嗷去做数据库了。 大多数时候，我们在谈大数据其实都是在谈在海量数据下的数据挖掘、数据分析、智能推荐、实时分析等。不同公司的技术方案不同，我只列两个国内成功的案例：• 京东个性化电商，场景包括基于行为、偏好、地域、时间、好友关系等维度，向不同的用户推荐不同的产品，不同用户搜索产品排序也不同…• 百度地图东莞8小时迁徙图；百度搜索智能提醒• 360手机卫士，电话号码防骚扰功能是通过用户的地域、身份、骚扰趋势，将标记的2.56亿个电话号码选出1000个和用户关联度最高的，写入用户手机的10k的文本里，达到不联网不做任何网络交互的情况下，为用户防骚扰HTML5+CSS3这是这几年被说烂了的一个词，人人都在说HTML5，问HTML5是什么，他们也说不清楚，就是酷，就是炫，就是酷炫。在我看来，HTML5只是一个三人成虎的东西，它吸引的眼球远超过了它提供的功能，HTML5只是提供了一些新的API，就等于一个app从1.0升级到2.0增加了附近的人功能而已。而且其提供的API，也就是在移动端试一试水，在pc端因为兼容的问题，始终不能被明媒正娶。pc端的开发还是以HTML4.0+CSS2为基准渐进增强。至于css3，它最被人关注的动画，也是flash玩剩下的东西。移动端的飞速发展催化了HTML5的发展，HTML5的发展也促使各浏览器趋于标准化。这条标准化路上，微信功不可没，1024，围住神经猫，淘宝十年，LEXUS NX这些融合了大量HTML5+CSS3元素的页面让人印象深刻。此外，微软抛弃IE代号，开发edge，各大浏览器厂商的不断标准化，HTML5草案定稿，ES6草稿的不断实现与完善，前端之路看起来是一条京畿坦途，我充满期待。未来3D页游？WebOS？ 虚拟现实？最后，随着用户硬件性能的提升，网络带宽的越来越粗，传感系统，Retina，WebGL技术的日渐成熟，再加上O2O的蓬勃发展，上边这些会成为现实么？

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

面向对象编程？没有对象你编毛程序！！！
听说你们程序员都是面向对象编程？你没有对象编毛程序!!!   程序员打油诗 　　 　　写字楼里写字间，写字间里程序员;　　程序人员写程序，又拿程序换酒钱。 　　酒醒只在网上坐，酒醉还来网下眠;　　酒醉酒醒日复日，网上网下年复年。 　　但愿老死电脑间，不愿鞠躬老板前;　　奔驰宝马贵者趣，公交自行程序员。 　　别人笑我忒疯癫，我笑自己命太贱;　　不见满街漂亮妹，哪个归得程序员。       程序猿最怕弹出的窗口：“找不到对象。指针为空“ 这辈子做程序员的命宝宝数学很好，2岁就可以从1数到10了。后来，我告诉他0比1还小。今天吃饺子，我说：“宝宝，你数数你想吃几个饺子？”“0，1，2，3。”一边说着一边拿起一个饺子，“这是第0个。”老婆怒吼：“下一代还是做程序员的命！”

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

有理想的程序员必须知道的15件事
作为程序员,要取得非凡成就需要记住的15件事.　　1.走一条不一样的路　　在有利于自己的市场中竞争,如果你满足于"泯然众人矣",那恐怕就得跟那些低工资国家的程序员们同场竞技了.　　2.了解自己的公司　　以我在医院、咨询公司、物流企业以及大技术公司工作的经验来看,这一点所言不虚.　　不同公司的运营模式差异极大.如果你理解企业的运营模式,那你就不一样了!在这家公司中(或者对客户而言),你是参与业务运营的资产,你的工作能直接产生效益!　　3.与最优秀的人为伍　　很早以前,我喜欢打篮球,被分配到一个水平比较高的队里.一开始适应的确很困难,但环境的压力越大(重大比赛),我的长进也就越明显.　　每个领域其实都一样:你周围人的水平(以及对你的期望)越高,你就会变得越优秀.　　4.制造差异　　每年学习一门新编程语言.为什么不呢?不断尝试新事物,你关注的技术种类越多,脚下的路就越宽广,你的职业生涯就会日新月异.不知道几年后java的趋势如何?那就学习clojure.学ruby还是python?这两种语言都可以试试啊.然后你才能知道哪种语言更适合某个特定的项目.看,掌握的语言多了,才能在需要的时候信手拈来吧.　　5.畏惧,是最大的敌人　　还是直接从书中摘一句吧:"在畏惧中做出的职业规划,很可能会让自己后半辈子就一直被'圈禁'在小隔断里,永远不会有创造明天辉煌的时刻.没错,那样是安全,但有意思吗?"　　6.要成为多面手　　如果你掌握了所在领域的知识,那你只能是一名专业人士.用php编程?花点时间设置一台apache服务器,让php和mysql都跑起来.一直在用jquery?试试prototype.你懂了吧.　　7.一个字:做　　别指望别人过来教你该怎么做,出去,自己学着去做!　　8.找一位好老师　　找一位好老师可以让你在学习技术的时候有的放矢.作者给我们讲述了别人是怎么指导他学习的(顺便说一句,作者在这本书里讲了很多个人经历的小故事,他居然从一位演奏家转行来做软件开发!):"好好研究一下目录服务,熟悉一种unix变体,然后再掌握一门脚本语言."　　请记住这句禅宗谚语:"循路觅宗师,形影不相离,师知吾亦知,吾乃成宗师."　　9.主动教会别人　　教会别人是一种最好的学习方式.写一篇博客能帮你搞清楚一个问题.为此,你必须先掌握很多材料,同时还要有条有理地讲给别人听(写作技能).如书中所言:"要想知道自己是不是真的明白,你就讲给别人听听."　　10.实践,实践,再实践(训练)　　只有进行大量实践(花大量的时间)才能掌握某种技术.看的很多,写的很少,遇到问题,改一改,又去读代码……(这样下去是不行的).　　要特别警惕拖延症.其实,往往只要有了开头就好办了.　　自我加压,效果会更好.我曾在一篇博客中提到帕金森定律:紧张的时限可以让你提高工作效率.为什么不把这个定律用到学习上呢,比如说在y时间内学会x?　　11.从小处入手　　每天都取得一项小成果,每天都要坚持做(写在博客上?).这样一来,你只能让自己比昨天更进步,而不能说自己比上星期进步了一点.　　12.享受过程　　关注当下,而不是目标,享受那些在追逐未来目标的途中可能无暇顾及的小胜利.人总要生活在当下.我享受编程的过程,就像享受编程的结果一样.　　13.不要丧失危机感　　越是成功,就越容易犯重大错误.永远不要忘了危机感,特别是要认识到你今天所知道的,到了明天可能就会一文不值.过去的荣耀不能保你永远无虞.　　据书中所说,你最好是要让自己能够"通用",而不要对哪种技术或哪个公司产生依赖.你所掌握的某些技能,甚至你的工作,到了明天都可能会变得毫无价值.因此要不断提高/丰富/扩展自己的技能.　　14.推销自己　　为某个项目贡献自己的一份力量,写一篇博客,共享自己的源代码,成为对某个社区有用的人.　　当然,做这些事可能需要激情,要看你的爱好,但这些事也会间接地推广你的工作成果,证明你的实力,提高你的知名度.　　15.关注市场　　书中还提到了"预警极客",也就是那些始终引领技术发展的人.这些人说过的话往往带有预见性,他们提到事物也许过几天就会成为头条新闻.关注这些人,常看他们的twitter和博客.

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

天下数据：做营销最爱犯的错误是什么？

        最近天下数据天下云—香港云主机上线。为了更好的推广新产品，除了传统的营销方式，在官网上做活动和竞价推广之外。各类营销软文也是络绎不绝。但是软文营销的效果好像并不是多好。这不只是小天面临的问题，而是如今所有营销人都面临的问题。
　　在这个去中心化的社交媒体时代，品牌方对渠道的掌控力变得非常微弱，传播变成一件难度很高的工作，于是勤奋的营销人纷纷想各种办法来加强传播力度，于是我们越发频繁地看到一些奇怪的营销现象：
　　借势营销：前不久范冰冰和李晨宣布在一起了，瞬间无数个品牌都在未经授权的情况下把自己的品牌PS到人家的合影上，然后再牵强地想一句不知所云的话。类似的群体性模仿事件今年我们看到的不要太多，以至于当天津港爆炸事件发生后，发表声明说我们不借势灾难题材做营销竟然成了一种高姿态。难道本来不就应该是如此的吗？
　　自黑营销：在自黑方面，神州专车几乎堪称经典。我不相信神州专车的营销团队预料不到“我怕黑专车”这一轮广告出去会引发舆论的哗然，从而损伤品牌的美誉度，但他们依然选择这么做了。在权衡“到底是要传播广度还是要品牌美誉度”这个问题时，他们选择了前者而放弃了后者，这样做真的值得吗？
　　效颦营销：有些营销人，看到别人的逗逼文章火了，于是就学着也整个逗逼的文章。以去年火爆互联网的“挖掘机技术哪家强”为例，竞相模仿该文案的数不胜数。包括后来出现的转折体自不必说，模仿的人也是一抓一大把。小天自然也没能逃出，也模仿过几篇该类型的文章。看到别人用H5工具了，自己赶紧也赶时髦弄个H5页面。鲁迅先生不是做营销的，可是他都知道“第一个把女人比作鲜花的是天才，第二个是庸才，第三个是蠢材”这个道理。
 　 事实上，在大众媒体时代我们能更多地看到出色的策划，而在社交媒体时代出色的策划反而在变少。这是因为在大众媒体时代，策划的归策划，媒介的归媒介，策划人可以专注于内容而不用去操心传播。
　　而到了社交媒体时代，所有人都知道传播效果取决于内容，于是传播量成了目标，内容成了达成传播量的一种手段，策划人一不小心就容易陷入“点击量挂帅”的工作模式当中。在这样的状态下生产出来的内容，传播量也许是有了，然而对品牌又有何贡献价值呢？如果对品牌没有增益，那传播又有什么卵用呢？
    今天的营销人相比过去的营销人，花在创意方面的时间肯定是更多了，因为越来越多的企业都开始进行内容营销。然而，这并不代表大家更重视策划了，随着传播难度的增加，“面向传播的策划”逐步替代了“面向品牌的策划”。传播本来是为品牌服务的，它不应该成为目的本身，品牌才是目的。举个通俗的例子，唱卡拉OK是好嗓子重要还是好音响重要？肯定是好嗓子更重要，如果嗓子不好，越好的音响越会放大嗓子的缺点。
　　洋洋洒洒写了一大通，其实也是在批评我自己，这些错误小天基本上也都犯过一遍。错误不重要，重要的是在以后的文案写作与传播中该如何去改。我相信认清楚这些问题，也就自然方便对症下药了。
　　

　　



版权声明：本文为博主原创文章，未经博主允许不得转载。

揭秘谷歌网络基础设施十年演变过程
谷歌今天 宣布 ，它想要修复用户家中的 Wi-Fi 网络连接问题，但在公司内部，这家搜索巨头很早以前便在解决远比这 复杂 的网络问题了。为了将构成谷歌数据中心的数十万台机器连接起来，你不能仅仅使用路由器和交换机这些最基本的工具，还要管理在服务器之间流动的所有数据。为此，谷歌一直在开发自己的硬件和软件，今天该公司揭开了它们的神秘面纱，让我们得以一窥其网络基础设施的演变过程。谷歌当前网络基础设施即所谓的“木星”（Jupiter）网络，容量是第一代网络的 100 倍，能以每秒 1 Petabit 的惊人速度提供总对分带宽（total bisection bandwidth）数据。该公司表示，在这种速度下，10 万台服务器可以在不到十分之一秒的时间内，阅读完美国国会图书馆中所有已经扫描的数据。谷歌工程师艾明·瓦达特（Amin Vahdat）今天 写道 ：“对于谷歌的服务来说，这种网络性能始终是巨大的益处。工程师们可以从给各种水平的带宽优化代码的繁杂工作中解脱出来。例如，一开始，在如何处理连接于相同的架顶式交换机（top of rack switch）的服务器的数据本地化和部署上，以及单个交换机故障引发的相关损失上，我们就面临着痛苦的抉择。”但是，谷歌在 10 年前远未达到这种数据处理能力。之后，谷歌收购了视频网站 YouTube，不久后又推出了 Gmail、谷歌地球和谷歌地图之类的产品，所以该公司的需要也在发生着快速转变。以下即是早期服务器网络在 2005 年时的模样：正如谷歌在今天的 文章 中所写，该公司基本上在 2004 年就部署了标准的服务器集群（server cluster），这些 2005 年产的机器也是谷歌在 Firehose 1.1 数据中心架构部署的网络设备的第一个例证。在 2005 年部署的机器的目标是，在 1 万台服务器之间实现 1 Gbps 的对分带宽。为了实现这个目标，谷歌曾试图将交换结构（switching fabric）整合到其自主开发的服务器中，但事实证明“服务器的正常运行时间不及理想状态。”有了 Firehose 1.1 数据中心架构以后，谷歌部署了其第一个定制数据中心集群结构（cluster fabric）。谷歌的工程师今天写道：“根据我们从 FH1.0 了解到的情况，我们不使用常规服务器来存放交换芯片。”相反，谷歌开发了定制式构架，并且转移到所谓的 Clos 数据中心网络构架。到 2008 年，Firehose 1.1 已演变为 WatchTower，后者转而使用 10G 光纤，而非传统的网线。谷歌面向全球的数据中心推出了这个版本的架构。下面即是那些架顶的模样：一年后，WatchTower 又变成了“土星”（Saturn）。WatchTower 的架构可以扩大至 87 Tbps，而“土星”架构则可以在更稠密的架顶下扩大至 207 Tbps。很显然，“土星”很好地满足了谷歌的需要，因为三年以后该公司才向好于“土星”能力的架构转变。谷歌工程师写道：“随着每台服务器的平均带宽要求持续提高，数据中心所有集群的相同带宽也具有了这种需要。随着 40G 标准的硅基结构的问世，我们可以考虑将我们的 Clos 架构扩大至整个数据中心（可归入内集群网络层）。”正是这类架构，现在让谷歌可以将一个数据中心看作是一台巨型计算机，用软件来分配整个网络中所有服务器的计算和存储资源。诚然，“木星”硬件看上去不同于谷歌在打造定制式网络设备上的最早努力，但从许多方面讲，它还证明谷歌迅速采用了 软件定义网络（Software Defined Networking），从而实现了快速创新能力。谷歌今天公布了 四篇论文 ，详细叙述了该公司网络构架的各个方面。由于谷歌往往先于其他公司触及传统硬件和软件构架的极限，所以类似论文常常在谷歌之外的公司引发新一轮创新活动。所有的创业公司都想要创建自己的数据中心，但这是不可能的，其他数据中心运营方肯定会详细研究这些论文，也许会随着时间的推移执行类似的解决方案。当然，他们的用户也会从这种转变中受益。

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

2015 Chinajoy ShowGirl照片合集
2015 ChinaJoy 由于新规，要求此次展览 Showgirl 不能再出现大尺度着装，所以今年的 Showgirl "福利"指数较往年直线下降……虽然今年被称作"史上最严"CJ，但是现场依然颜值爆表。  

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

机器学习算法面试—口述（1）：SVM介绍及常见问题


这个系列是为了应对找工作面试时面试官问的算法问题，所以只是也谢算法的简要介绍，后期会陆续补充关于此算法的常见面试的问题！


首先SVM是支持向量机support vector machine的缩写，它是现在使用比较广泛的一个分类算法（二分类），是一个线性分类器！
当数据是线性可分的时候：
SVM是在空间找一个分类超平面，将数据分开，下面以二维为例



（1） 
（2）
SVM要做的就是找到（1）中间那条线（三维的话是一个面，更高维是一些其他什么的。。。），但是光找到那条线是不够的，因为这样的线是有无数条的（2）。显然（2）中中间的那条要比旁边的那两条要好，因为它与两边的数据的隔得很开，分类时候抗噪性能比旁边那两条要好。那么如何找到中间那条线呢，这就是SVM要解决的问题。



如上图，，，得到，之后转化为最优化的问题，由于直接最大化最大间隔是一个非凸优化问题，将其转换为求最大间隔与||W||的比值（满足的条件是f(x)
 >= 最大间隔），为了计算方便，将最大间隔置为1，这也是我们看到的最终需优化的式子。



显然优化这样的式子，肯定是拉格朗日乘子法，这个式子不太好求，将1/||w||转换为0.5*||w||*||w||，
，令，也即求min(max...),

转化为对偶问题有式子min(max..) >= max(min..)(求这项)，之所以转化为对偶问题，一是两个式子解相仿，而是求解更简便。上面的式子满足KKT条件，求解得到L(w,b,a)是一个关于a的式子。
之后的优化工作就交个了一个叫做SMO（序列最小化算法）。
当数据是线性不可分的情况下，SVM求解分类的超平面是使用核函数。有的数据在低维空间不可分，但是映射到高维空间后它可能是线性可分的，比如，一维线上的点不线性可分，映射到二维（平方函数）就可能可以分开了。但是在映射的时候有一个问题，是一个计算问题，低维空间映射到高维空间，在高维空间上直接计算的话回产生一个维灾难的问题（2->5, 3->19...）。这个地方就引入了核函数，核函数是计算两个向量在隐式映射过后的空间中的内积的函数，通过核函数可以使数据不用在映射后的高维空间中计算，而是在原来的低维空间中计算（在原来的低维空间上做内积）。
以上就是SVM的简要介绍，当然里面很多细节是没有说出来的，毕竟面试刚开始要你介绍你也不会说的很细节不是。不过面试官肯定会问你关于SVM的一些细节知识，只知道个大概是没有用的。
补充一些细节知识：
1、关于松池变量
如下图：




这个图给出了两组超平面的画法，每组两边的超平面都能将数据区分开来，但是离两边的数据点非常近，二中间的那个超平面会错分某些点，但是其具有很好的边界效果。显然中间这个超平面比较好，因为它的鲁棒性很好。
SVM允许数据点在一定程度上偏离超平面，这个反应在约束条件ai中，本来约束条件是ai >= 0，现在约束条件变为：C >= ai >= 0；
松弛变量的引入也就是允许某些点离超平面的距离小于1，也即放弃了这些点的分类精度，惩罚因子决定了对离群点的重视程度，C越大，表示分错某一个点需要付出更大的代价（这个可以一定程度上缓解正负样本数量相差太大的问题）。
2、







版权声明：本文为博主原创文章，未经博主允许不得转载。

机器学习之决策树算法
      机器学习在各个领域都有广泛的应用，特别在数据分析领域有着深远的影响。决策树是机器学习中最基础且应用最广泛的算法模型。本文介绍了机器学习的相关概念、常见的算法分类和决策树模型及应用。通过一个决策树案例，着重从特征选择、剪枝等方面描述决策树的构建，讨论并研究决策树模型评估准则。最后基于
 R 语言和 SPSS 这两个工具，分别设计与实现了决策树模型的应用实例。
机器学习概念 



    机器学习 (Machine Learning) 是近 20 多年兴起的一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。

   机器学习理论主要是设计和分析一些让计算机可以自动学习的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。因为学习算法中涉及了大量的统计学理论，机器学习与统计推断学联系尤为密切，也被称为统计学习理论。在算法设计方面，机器学习理论关注可以实现的、行之有效的学习算法。很多相关问题的算法复杂度较高，而且很难找到固有的规律，所以部分的机器学习研究是开发容易处理的近似算法。

     机器学习在数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA 序列测序、语言与手写识别、战略游戏与机器人运用等领域有着十分广泛的应用。它无疑是当前数据分析领域的一个热点内容。



算法分类
机器学习的算法繁多，其中很多算法是一类算法，而有些算法又是从其他算法中衍生出来的，因此我们可以按照不同的角度将其分类。本文主要通过学习方式和算法类似性这两个角度将机器学习算法进行分类。

学习方式



1、监督式学习：从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集需要包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督式学习算法包括回归分析和统计分类。




2、非监督式学习：与监督学习相比，训练集没有人为标注的结果。常见的非监督式学习算法有聚类。




3、半监督式学习：输入数据部分被标识，部分没有被标识，介于监督式学习与非监督式学习之间。常见的半监督式学习算法有支持向量机。




4、强化学习：在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的强化学习算法有时间差学习。




算法类似性


1、决策树学习：根据数据的属性采用树状结构建立决策模型。决策树模型常常用来解决分类和回归问题。常见的算法包括 CART (Classification And Regression Tree)、ID3、C4.5、随机森林 (Random Forest) 等。




2、回归算法：试图采用对误差的衡量来探索变量之间的关系的一类算法。常见的回归算法包括最小二乘法 (Least Square)、逻辑回归 (Logistic Regression)、逐步式回归 (Stepwise Regression) 等。




3、聚类算法：通常按照中心点或者分层的方式对输入数据进行归并。所有的聚类算法都试图找到数据的内在结构，以便按照最大的共同点将数据进行归类。常见的聚类算法包括 K-Means 算法以及期望最大化算法 (Expectation Maximization) 等。




4、人工神经网络：模拟生物神经网络，是一类模式匹配算法。通常用于解决分类和回归问题。人工神经网络算法包括感知器神经网络 (Perceptron Neural Network) 、反向传递 (Back Propagation) 和深度学习等。

决策树

决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。机器学习中决策树是一个预测模型，它表示对象属性和对象值之间的一种映射，树中的每一个节点表示对象属性的判断条件，其分支表示符合节点条件的对象。树的叶子节点表示对象所属的预测结果。

决策树案例：



图
 1. 决策树案例图



图 1 是一棵结构简单的决策树，用于预测贷款用户是否具有偿还贷款的能力。贷款用户主要具备三个属性：是否拥有房产，是否结婚，平均月收入。每一个内部节点都表示一个属性条件判断，叶子节点表示贷款用户是否具有偿还能力。例如：用户甲没有房产，没有结婚，月收入 5K。通过决策树的根节点判断，用户甲符合右边分支 (拥有房产为“否”)；再判断是否结婚，用户甲符合左边分支 (是否结婚为否)；然后判断月收入是否大于 4k，用户甲符合左边分支
 (月收入大于 4K)，该用户落在“可以偿还”的叶子节点上。所以预测用户甲具备偿还贷款能力。





决策树建立


本文上一节已经讨论如何用一棵决策树进行分类。本节将通过特征选择、剪枝，介绍如何根据已有的样本数据建立一棵决策树。





首先介绍下特征选择。选择一个合适的特征作为判断节点，可以快速的分类，减少决策树的深度。决策树的目标就是把数据集按对应的类标签进行分类。最理想的情况是，通过特征的选择能把不同类别的数据集贴上对应类标签。特征选择的目标使得分类后的数据集比较纯。如何衡量一个数据集纯度，这里就需要引入数据纯度函数。下面将介绍两种表示数据纯度的函数。





信息增益

信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。





假设在样本数据集 D 中，混有 c 种类别的数据。构建决策树时，根据给定的样本数据集选择某个特征值作为树的节点。在数据集中，可以计算出该数据中的信息熵：




图 2. 作用前的信息熵计算公式

其中 D 表示训练数据集，c 表示数据类别数，Pi 表示类别 i 样本数量占所有样本的比例。




对应数据集 D，选择特征 A 作为决策树判断节点时，在特征 A 作用后的信息熵的为 Info(D)，计算如下：





图 3. 作用后的信息熵计算公式





其中 k 表示样本 D 被分为 k 个部分。




信息增益表示数据集 D 在特征 A 的作用后，其信息熵减少的值。公式如下：




图 4. 信息熵差值计算公式





对于决策树节点最合适的特征选择，就是 Gain(A) 值最大的特征。





基尼指数


基尼指数是另一种数据的不纯度的度量方法，其公式为：





图 5. 基尼指数计算公式





其中 c 表示数据集中类别的数量，Pi 表示类别 i 样本数量占所有样本的比例。 从该公式可以看出，当数据集中数据混合的程度越高，基尼指数也就越高。当数据集 D 只有一种数据类型，那么基尼指数的值为最低 0。





如果选取的属性为 A，那么分裂后的数据集 D 的基尼指数的计算公式为：





图 6. 分裂后的基尼指数计算公式





其中 k 表示样本 D 被分为 k 个部分，数据集 D 分裂成为 k 个 Dj 数据集。





对于特征选取，需要选择最小的分裂后的基尼指数。也可以用基尼指数增益值作为决策树选择特征的依据。公式如下：





图 7. 基尼指数差值计算公式





在决策树选择特征时，应选择基尼指数增益值最大的特征，作为该节点分裂条件。




接下来介绍剪枝。在分类模型建立的过程中，很容易出现过拟合的现象。过拟合是指在模型学习训练中，训练样本达到非常高的逼近精度，但对检验样本的逼近误差随着训练次数而呈现出先下降后上升的现象。过拟合时训练误差很小，但是检验误差很大，不利于实际应用。





决策树的过拟合现象可以通过剪枝进行一定的修复。剪枝分为预先剪枝和后剪枝两种。




预先剪枝指在决策树生长过程中，使用一定条件加以限制，使得产生完全拟合的决策树之前就停止生长。预先剪枝的判断方法也有很多，比如信息增益小于一定阀值的时候通过剪枝使决策树停止生长。但如何确定一个合适的阀值也需要一定的依据，阀值太高导致模型拟合不足，阀值太低又导致模型过拟合。





后剪枝是在决策树生长完成之后，按照自底向上的方式修剪决策树。后剪枝有两种方式，一种用新的叶子节点替换子树，该节点的预测类由子树数据集中的多数类决定。




另一种用子树中最常使用的分支代替子树。预先剪枝可能过早的终止决策树的生长，后剪枝一般能够产生更好的效果。但后剪枝在子树被剪掉后，决策树生长的一部分计算就被浪费了。





决策树模型评估


建立了决策树模型后需要给出该模型的评估值，这样才可以来判断模型的优劣。学习算法模型使用训练集 (training set) 建立模型，使用校验集 (test set) 来评估模型。本文通过评估指标和评估方法来评估决策树模型。 评估指标有分类准确度、召回率、虚警率和精确度等。而这些指标都是基于混淆矩阵 (confusion matrix) 进行计算的。



混淆矩阵是用来评价监督式学习模型的精确性，矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例。以二类分类问题为例，如下表所示：

                                       表
 1. 混淆矩阵
   







预测的类








实际的类




类 = 1

类 = 0






类 = 1

TP

FN

P



类 = 0

FP

TN

N






其中

P (Positive Sample)：正例的样本数量。

N(Negative Sample)：负例的样本数量。

TP(True Positive)：正确预测到的正例的数量。

FP(False Positive)：把负例预测成正例的数量。

FN(False Negative)：把正例预测成负例的数量。

TN(True Negative)：正确预测到的负例的数量。

根据混淆矩阵可以得到评价分类模型的指标有以下几种。





分类准确度，就是正负样本分别被正确分类的概率，计算公式为：





图 8. 分类准确度计算公式





召回率，就是正样本被识别出的概率，计算公式为：





图 9. 召回率计算公式





虚警率，就是负样本被错误分为正样本的概率，计算公式为：





图 10. 虚警率计算公式





精确度，就是分类结果为正样本的情况真实性程度，计算公式为：





图 11. 精确度计算公式





评估方法有保留法、随机二次抽样、交叉验证和自助法等。





保留法 (holdout) 是评估分类模型性能的最基本的一种方法。将被标记的原始数据集分成训练集和检验集两份，训练集用于训练分类模型，检验集用于评估分类模型性能。但此方法不适用样本较小的情况，模型可能高度依赖训练集和检验集的构成。





随机二次抽样 (random subsampling) 是指多次重复使用保留方法来改进分类器评估方法。同样此方法也不适用训练集数量不足的情况，而且也可能造成有些数据未被用于训练集。





交叉验证 (cross-validation) 是指把数据分成数量相同的 k 份，每次使用数据进行分类时，选择其中一份作为检验集，剩下的 k-1 份为训练集，重复 k 次，正好使得每一份数据都被用于一次检验集 k-1 次训练集。该方法的优点是尽可能多的数据作为训练集数据，每一次训练集数据和检验集数据都是相互独立的，并且完全覆盖了整个数据集。也存在一个缺点，就是分类模型运行了 K 次，计算开销较大。





自助法 (bootstrap) 是指在其方法中，训练集数据采用的是有放回的抽样，即已经选取为训练集的数据又被放回原来的数据集中，使得该数据有机会能被再一次抽取。用于样本数不多的情况下，效果很好。

决策树建模







在本节中，将通过 R 和 IBM SPSS 两种建模工具分别对其实际案例进行决策树建模。




 R


R是一个用于统计计算及统计制图的优秀的开源软件，也是一个可以从大数据中获取有用信息的绝佳工具。它能在目前各种主流操作系统上安装使用，并且提供了很多数据管理、统计和绘图函数。





下面本节就将使用 R 所提供的强大的函数库来构建一棵决策树并加以剪枝。





清单 1. 构建决策树及其剪枝的 R 代码




根据代码，运行步骤如下：


1、导入需要的函数库。当然如果本地开发环境没有相应的库的话，还需要通过 install.packages 函数对库进行安装。

2、查看本次构建决策树的数据源。stagec 是一组前列腺癌复发的研究数据。

3、通过 rpart 函数构建决策树，以研究癌复发与病人年龄、肿瘤等级、癌细胞比例，癌细胞分裂状况等之间的关系。

4、查看决策树的具体信息。 绘制构建完成的决策树图。

5、通过 prune 函数对该决策树进行适当的剪枝，防止过拟合，使得树能够较好地反映数据内在的规律并在实际应用中有意义。

6、绘制剪枝完后的决策树图。 该案例决策树的拟合结果与剪枝前后的树如下图所示：





图 12. 决策树案例拟合图








图 13. 未剪枝的决策树图








图 14. 剪枝后的决策树图




SPSS


IBM SPSS Modeler 是一个预测分析平台，能够为个人、团队、系统和企业做决策提供预测性信息。它可提供各种高级算法和技术 (包括文本分析、实体分析、决策管理与优化)，帮助您选择可实现更佳成果的操作。




在 SPSS Modeler 中有很多应用实例，其中就包括一个决策树算法模型的案例。此示例使用名为 druglearn.str 的流，此流引用名为 DRUG1n 的数据文件。这些文件可在任何 IBM SPSS Modeler 安装程序的 Demos 目录中找到。操作步骤如下：


1、添加“变量文件”节点 GRUGln，打开该节点，添加 DRUGln 文件。

2、创建新字段 Na_to_K, 通过对 Na 和 K 数据的观察，发现可以用 Na 和 K 的比例来预测药物 Y。

3、添加过滤器 (Discard Fields)，过滤掉原始的字段 Na 和 K，以免在建模算法中重复使用。

4、添加类型节点 (Define Types)，设置字段的角色，将药物字段设置为目标，其他的字段设置为输入。

5、添加 C5.0 节点，使用默认的参数设置。 点击运行，生成一个模型 Drug。

在生成模型
 Drug 以后，我们可以在模型页面中浏览 Drug 模型。打开 Drug 模型以后，可在规则浏览框中以决策树形式显示 C5.0 节点所生成的规则集。还可以通过更复杂的图表形式查看同一决策树。如下图所示：

 
                    

 
                                                                         
图 15. 生成模型的决策树图





结束语









本文也展开讨论了分类算法之间的相互比较和优缺点，特征选择与剪枝各种方法之间的相互比较，各个评估方法的优缺点等。通过这些讨论与分析，能够以更好的方法论来解决实际生产环境下的问题。



同时，决策树只是整个机器学习领域的冰山一角，而机器学习领域又是当前大数据分析领域的热点，因此还有很多很多值得我们去学习、去研究的地方。






版权声明：本文为博主原创文章，未经博主允许不得转载。

回顾：RPC远程过程调用协议
先看看来自百度的这个图，最终可以归纳为这10个步骤。




1.调用客户端句柄；执行传送参数
2.调用本地系统内核发送网络消息
3.消息传送到远程主机
4.服务器句柄得到消息并取得参数
5.执行远程过程
6.执行的过程将结果返回服务器句柄
7.服务器句柄返回结果，调用远程系统内核
8.消息传回本地主机
9.客户句柄由内核接收消息
10.客户接收句柄返回的数据



版权声明：

exlipce mar 创建一个webService项目------》针对axis2
一、下载(1)axis2-1.6.3-bin.zip(解压文件，作为与eclipse配置的文件)
         网址：http://axis.apache.org/axis2/java/core/download.cgi
                (2)axis2-eclipse-codegen-plugin-1.6.2.zip、axis2-eclipse-service-plugin-1.6.2.zip（解压2文件后把                    
                org.apache.axis2.eclipse.codegen.plugin_1.6.2.jar和org.apache.axis2.eclipse.service.plugin_1.6.2.jar
                放到eclipse的安装目录,E:\eclipse\dropins文件夹下）
网址：http://axis.apache.org/axis2/java/core/tools/index.html
二、将eclipse与axis2-1.6.3-bin插件集成
(1)在Eclipse的菜单栏中，Window --> Preferences --> Web Services--> Axis2 Perferences,
            在Axis2 runtime location中选择Axis2解压缩包的位置，设置好后，点"OK"即行。
三、下载axis2.war(该包放在tomcat---->webapps下),这是核心
四、开始创建项目
在eclipse中新建一个Dynamic web project项目，接口名字尽量简单和规范（接口名规范，非常有用！）

五、生成.aar文件到tomcat的webapps\axis2\WEB_INF\services下
（1）wordspace工作区下，单击右键，新建other---->选择Axis2 Wizards ---->Axis2 Service Archiver ---->next

（2）到Service Archiver时，注意class File Location 只能选择到build\classes目录(如F:\eclipse_mar\WebServiceTest\build\classes)


（3）继续next,直到Server Archiver  Generate the Service XML file 
在service name 和 Class name 后面输入对应的名字。注意：Service name是指发布成功后访问的名称
 如http://localhost:8080/axis2/services/ITestService?wsdl红色字体，而Class name则必须填入接口的全路径！
         如：com.interfaces.ITestService ，点击Load 加载成功后即可看到本窗口中的接口中的方法和参数类型！表名已经加载成功！


  (4)下一步，将看到:OUtput file location 和 Output file name ，选择导出路径，一般就导出放在 tomcat\webapps\axis2\WEB-INF\services下
这样方便马上测试，而name可以任意取（只要符合命名规范即可）
 点击finish,则生成.aar文件成功！
（5）start--tomcat--访问刚刚发布的webService，在地址栏输入http://localhost:8080/axis2/services/ITestService?wsdl，即可看见生成的wsdl文件


注意：以上的方式是发布到axis2.war包中，当然我们也可以把生成.aar文件copy到实际应用中；
         同时，也可以使用eclipse的create webservice功能发布我们的webservice，选择axis2生成我们的webservice，
         这样webservice就会部署到我们的应用中了。
以上开发环境：
windows 7 64位 +tomcat 7 64位+jdk1.6 32位 +eclipse mar（最新版本）+axis2.war最新版+axis2.1.6.3.bin最新版+axis2两个插件
可能不同版本使用会有差异。

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        cas+apache ldap
上一篇博客写了关于cas sso单点登录的例子，后来公司又让我整合ldap，今天终于做出来了demo，就把我的例子分享给大家，以后对自己也好查阅，网上关于cas4.0整合apache ldap的帖子实在太少了，本例就是cas4.0+apache ldap,先将这些jar包放入cas中的lib文件夹中  
cas-server-support-ldap-4.0.0.jar  
spring-ldap-core-2.0.2.RELEASE.jar  
ldaptive-1.0.5.jar 
这二者整合主要就是配置deployerConfigContext.xml文件，首先需要的是修改认证入口：
<!--新增ldap认证的入口-->  
06.        <entry key-ref="ldapAuthHandler" value-ref="primaryPrincipalResolver"/>  
然后就是新增ldap中的LDAP配置文件，可以直接把下面的代码拷贝到你的deployerConfigContext.xml，将相应的参数修改成自己的就可以了
<!--ldap认证的入口-->  
    <bean id="ldapAuthHandler"  
          class="org.jasig.cas.authentication.LdapAuthenticationHandler"  
          p:principalIdAttribute="uid"  
          c:authenticator-ref="authenticator">  
        <property name="principalAttributeMap">  
            <map>  
                <!--  
                   | This map provides a simple attribute resolution mechanism.  
                   | Keys are LDAP attribute names, values are CAS attribute names.  
                   | Use this facility instead of a PrincipalResolver if LDAP is  
                   | the only attribute source.  
                   -->  
                 <entry key="uid" value="uid" />  
                 <!-- <entry key="ip_address" value="ip_address" />  
                 <entry key="device_number" value="device_number" />  
                 <entry key="expired_time" value="expired_time" /> -->  
                 <entry key="displayName" value="displayName" />  
            </map>  
        </property>  
    </bean>  
    <bean id="authenticator" class="org.ldaptive.auth.Authenticator"  
              c:resolver-ref="dnResolver"  
              c:handler-ref="authHandler" />  
      <!--  
          | The following DN format works for many directories, but may need to be  
          | customized.  
          -->  
          <!-- 下面uid这些可根据个人的配置不同而修改-->
    <bean id="dnResolver"  
             class="org.ldaptive.auth.FormatDnResolver"  
             c:format="uid=%s,ou=system,dc=com" />   
    <bean id="authHandler" class="org.ldaptive.auth.PooledBindAuthenticationHandler"  
             p:connectionFactory-ref="pooledLdapConnectionFactory" />  
    <bean id="pooledLdapConnectionFactory"  
             class="org.ldaptive.pool.PooledConnectionFactory"  
             p:connectionPool-ref="connectionPool" />          
    <!--连接池-->  
    <bean id="connectionPool"  
             class="org.ldaptive.pool.BlockingConnectionPool"  
             init-method="initialize"  
             p:poolConfig-ref="ldapPoolConfig"  
             p:blockWaitTime="3000"  
             p:validator-ref="searchValidator"  
             p:pruneStrategy-ref="pruneStrategy"  
             p:connectionFactory-ref="connectionFactory" />  
    <bean id="ldapPoolConfig" class="org.ldaptive.pool.PoolConfig"  
             p:minPoolSize="3"  
             p:maxPoolSize="10"  
             p:validateOnCheckOut="true"  
             p:validatePeriodically="true"  
             p:validatePeriod="300" />  
    <bean id="connectionFactory" class="org.ldaptive.DefaultConnectionFactory"  
        p:connectionConfig-ref="connectionConfig" />  
    <bean id="connectionConfig" class="org.ldaptive.ConnectionConfig"  
             p:ldapUrl="ldap://localhost:10389"    
            p:connectTimeout="3000"      
             p:useStartTLS="false" />    
    <bean id="pruneStrategy" class="org.ldaptive.pool.IdlePruneStrategy"  
              p:prunePeriod="300"  
              p:idleTime="600" />  
    <bean id="searchValidator" class="org.ldaptive.pool.SearchValidator" />            
      <!--ldap认证结束-->    
上面这些有些内容可能需要根据个人在客户端工具中的配置不同需要调整，需要调整的地方我已经标注，这时启动服务器，输入： 
http://localhost:8080/cas-server即可进入登陆页面，输入配置过的用户名密码即可访问，由于ldap4.0和之前的版本差别很大，所以配置比较多，而且ldap连接服务器不需要输入用户名密码而是连接uid，根据uid登陆即可，至此cas+apache ldap配置完成 
如下是具体的demo实例，需要的可自行下载

http://download.csdn.net/detail/danruoshui315/9052885


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Netty 源码分析之ByteToMessageDecoder
ByteToMessageDecoder是netty中的一个ChannelHandler，用于将ByteBuf转换成Message，message可以是POJO等等，转换后继续在ChannelPipeline中传递，Decoder和Encoder等设置显示了netty的ChannelPipeline带来的强大的灵活性，并且可以使我们复用很多逻辑代驾，分离职责。
ByteToMessageDecoder继承自ChannelHandlerAdapter,需要开发者实现的是decode方法
protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;
ctx是decode属于的ChannelHandlerContext,in是用来读取的数据，out是我们转换后的对象列表 
一个将Byte转换成Integer的例子
class ByteToIntegerDecoder extends ByteToMessageDecoder{
        @Override
        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
            while(in.readableBytes() > 4){
                out.add(in.readInt());
            }
        }
    }
分析源码中较为关键的channelRead
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (msg instanceof ByteBuf) {
            RecyclableArrayList out = RecyclableArrayList.newInstance();
            try {
                ByteBuf data = (ByteBuf) msg;
                first = cumulation == null;
                if (first) {
                    cumulation = data;
                } else {
                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);
                }
                callDecode(ctx, cumulation, out);
            } catch (DecoderException e) {
                throw e;
            } catch (Throwable t) {
                throw new DecoderException(t);
            } finally {
                if (cumulation != null && !cumulation.isReadable()) {
                    cumulation.release();
                    cumulation = null;
                }
                int size = out.size();

                for (int i = 0; i < size; i ++) {
                    ctx.fireChannelRead(out.get(i));
                }
                out.recycle();
            }
        } else {
            ctx.fireChannelRead(msg);
        }
    }
cumulation是代表累加的byte数据，即上一次decode剩下的byte,cumulator是累加器，默认使用MERGE_CUMULATOR就是使用内存复制来进行累加。累加完之后调用callDecode(ctx, cumulation, out),callDecode中循环调用我们要实现的抽象方法decode(ctx,in,out) 来解码，知道不能继续解。 
在finally中对out列表中的每一个对象调用ctx.fireChannelRead(out.get(i)) 
触发ChannelPipeline后面的ChannelHandler的channelRead事件

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

TCP的三次握手和四次挥手
要搞懂这个首先得了解TCP报文段和及其首部格式，如图：




ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1

SYN ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。

FIN ：即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
序号（seq）：指本报文段所发送的数据的第一个字节的序。例如一个报文段的序号字段是301，携带的数据共有100字节。显然下一个报文段的序号应该从401开始
确认号（ack）：是期望收到对方的下一个数据字节的序号，例如B正确收到了A发过来的一个报文段，其序号是501，数据长度是200，则B期望收到的下一个数据序号是701，于是B把确认号（ack）置为701。
注意：TCP采用的是累积确认，即确认是对所有按序接收的数据的确认，但请注意，接收方返回的确认号是已按序号收到的数据的最高序加1


三次握手：


分析：
         主机A向TCP发出主动打开命令，表明要向某个IP地址的某个端口建立传输连接。主机B向TCP发送一个被动打开命令，准备接受客户端的连接请求，自己处于监听状态。




        B的服务器进程创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程处于LISTEN状态，等待客服端的连接请求。

        A打的TCP客服端进程创建控制块TCB，然后向B发送连接请求报文段。该报文的首部SYN=1，并且假设序号seq=x。TCP规定，该连接请求报文段不携带任何数据，但需要占用一个序号。A发送了连接请求报文后进入SYN-SENT状态。

        B收到A的连接请求报文后，会向A返回连接接受报文。该报文的首部SYN=1，ACK=1，seq=y,ack=x+1。TCP也规定，连接接受报文段也不携带任何数据，但也需要占用一个序号。B发送该报文后立即进入SYN-RECD状态。

        A收到B的连接接受报文后，还需要向B发送一个确认报文段。在该报文中ACK=1，seq=x+1,ack=y+1。TCP规定，在该报文段中可以携带数据，也可不携带数据。但，不携带数据时，不会消耗一个序号，也就会说下一个发送的报文段的序号仍为x+1。该报文段发送成功后，进入ESTAB-LISHED状态，。

       B收到A的确认后，也进入ESTAB-ISHED状态。

思考：为什么是三次呢？

         防止已经失效的连接请求报文段突然传到主机B，因而产生错误。比如A发送的第一个连接请求因为某些原因二滞留时间太长，以致于这次连接都释放了才传到B，本来这就是一个无效的报文段，但B收到此无效的连接请求后，误认为是A发送的新连接请求，于是发确认连接，同意连接。而A并没有要求建立连接，所以不会理睬B发的确认连接，自然不会向B发送数据。但是B一直在等待A发送数据，这样就浪费了许多资源



四次挥手:


分析：


        当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1,  服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。  A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。




思考：

为什么要等待？

       为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）

为什么有保活时间：

        另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？  就是保活时间到了后，B会发送探测信息， 以决定是否释放连接。




版权声明：本文为博主原创文章，未经博主允许不得转载。

王垠：数学和编程


　　好些人来信问我，要成为一个好的程序员，数学基础要达到什么样的程度？十八年前，当我成为大学计算机系新生的时候，也为同样的问题所困扰。面对学数学，物理等学科的同学，我感到自卑。经常有人说那些专业的知识更加精华一些，难度更高一些，那些专业的人毕业之后如果做编程工作，水平其实比计算机系毕业的还要高。直到几年前深入研究程序语言之后，对这个问题我才得到了答案和解脱。由于好多编程新手遇到同样的困扰，所以我想在这里把这个问题详细的阐述一下。
　　数学并不是计算机科学的基础
　　很多人都错误的认为，计算机科学是数学的一个分支，数学是计算机科学的基础，数学是更加博大精深的科学。这些人以为只要学会了数学，编程的事情全都不在话下，然而事实却并非如此。
　　事实其实是这样的：

计算机科学其实根本不是数学，它只不过借用了非常少，非常基础的数学，比高中数学还要容易一点。所谓“高等数学”，在计算机科学里面基本用不上。计算机是比数学更加基础的工具，就像纸和笔一样。计算机可以用来解决数学的问题，也可以用来解决不是数学的问题，比如工程的问题，艺术的问题，经济的问题，社会的问题等等。计算机科学是完全独立的学科。学习了数学和物理，并不能代替对计算机科学的学习。你必须针对计算机科学进行学习，才有可能成为好的程序员。数学家所用的语言，比起常见的程序语言（比如C++，Java）来说，其实是非常落后而糟糕的设计。所谓“数学的美感”，其实大部分是夜郎自大。99% 的数学家都写不出像样的代码。
　　数学是异常糟糕的语言
　　这并不是危言耸听。如果你深入研究过程序语言的理论，就会发现其实数学家们使用的那些符号，只不过是一种非常糟糕的程序语言。数学的理论有些是有用的，然而数学家门用于描述这些理论所用的语言，却是纷繁复杂，缺乏一致性，可组合性（composability），简单性，可用性。这也就是为什么大部分人看到数学就头痛。这不是他们不够聪明，而是数学语言的“设计”有问题。人们学习数学的时候，其实只有少部分时间在思考它的精髓，而大部分时间是在折腾它的语法。
　　举一个非常简单的例子。如果你说x-1表示x的-1 次方（x的倒数），那么f-1表示什么？f的-1 次方，f的倒数？别被数学老师们的教条和借口欺骗啦，他们总是告诉你：“你应该记住这些！” 可是你想过吗：“凭什么！” x-1表示x的-1 次方，而f-1，明明是一模一样的形式，表示的却是函数f的反函数。一个是求幂，一个是反函数，风马不及，却写成一个样子。这样的语言设计混淆不堪，却喜欢以“约定俗成”作为借口。
　　如果你再多看一些数学书，就会发现这只是数学语言几百年累积下来的糟粕的冰山一角。数学书里尽是各种上标下标，带括号的上标下标，x，y，z，a，b，c，f，g，h，各种扭来扭去的希腊字母，希伯来字母…… 斜体，黑体，花体，双影体，……用不同的字体来表示不同的“类型”。很多符号的含义，在不同的子领域里面都不一样。有些人上一门数学课，到最后还没明白那些符号是什么意思。
　　很多人学习微积分都觉得困难，其实问题不在他们，而在于莱布尼兹（Leibniz）。莱布尼兹设计来描述微积分的语言（∫，dx， dy， …），从现代语言设计的角度来看，其实非常之糟糕，可以说是一塌糊涂。我不能怪莱布尼兹，他毕竟是几百年前的人了，他不知道我们现在知道的很多东西。然而古人的设计，现在还不考虑改进，反而当成教条灌输给学生，那就是不思进取了。
　　数学的语言不像程序语言，它的历史太久，没有经过系统的，考虑周全的，统一的设计。各种数学符号的出现，往往是历史上某个数学家有天在黑板上随手画出一些古怪的符号，说这代表什么，那代表什么，…… 然后就定下来了。很多数学家只关心自己那块狭窄的子领域，为自己的理论随便设计出一套符号，完全不管这些是否跟其它子领域的符号相冲突。这就是为什么不同的数学子领域里写出同样的符号，却可以表示完全不同的涵义。在这种意义上，数学的语言跟 Perl（一种非常糟糕的程序语言）有些类似。Perl
 把各种人需要的各种功能，不加选择地加进了语言里面，造成语言繁复不堪，甚至连 Perl 的创造者自己都不能理解它所有的功能。
　　数学的证明，使用的其实也是极其不严格的语言——古怪的符号，加上含糊不清，容易误解的人类语言。如果你知道什么是 Curry-Howard Correspondence 就会明白，其实每一个数学证明都不过是一段代码。同样的定理，可以有许多不同版本的证明（代码）。这些证明有的简短优雅，有的却冗长繁复，像面条一样绕来绕去，没法看懂。你经常在数学证明里面看到“未定义的变量”，证明的逻辑也包含着各种隐含知识，思维跳跃，非常难以理解。很多数学证明，从程序的观点来看，连编译都不会通过，就别提运行了。
　　数学家们往往不在乎证明的优雅性。他们认为只要能证明出定理，你管我的证明简不简单，容不容易看懂呢。你越是看不懂，就越是觉得我高深莫测！这种思潮到了编程的时候就显出弊端了。数学家写代码，往往忽视代码的优雅性，简单性，模块化，可读性，性能，数据结构等重要因素，认为代码只要能算出结果就行。他们把代码当成跟证明一样，一次性的东西，所以他们的代码往往不能满足实际工程的严格要求。
　　编程是一门艺术
　　从上面你也许已经明白了，普通程序员使用的编程语言，就算是 C++ 这样毛病众多的语言，其实也已经比数学家使用的语言高明很多。计算机科学并不是数学的一个分支，它在很大程度上是优于数学，高于数学的。有些数学的基本理论可以被计算机科学所用，然而计算机科学并不是数学的一部分。数学在语言方面带有太多的历史遗留糟粕，它其实是泥菩萨过河，自身难保，它根本解决不了编程中遇到的实际问题。
　　编程真的是一门艺术，因为它符合艺术的各种特征。艺术可以利用科学提供的工具，然而它却不是科学的一部分，它的地位也并不低于科学。和所有的艺术一样，编程能解决科学没法解决的问题，满足人们新的需求，开拓新的世界。所以亲爱的程序员们，别再为自己不懂很多数学而烦恼了。数学并不能帮助你写出好的程序，然而能写出好程序的人，却能更好的理解数学。我建议你们先学编程，再去看数学。

本文最初发表在 王垠的博客，文章内容属作者个人观点，不代表本站立场。



版权声明：本文为博主原创文章，未经博主允许不得转载。

websocket+webrtc+tomcat 实现视频监考功能


         最近几天笔试，发现好多的线上笔试都会有视频监考的功能，个人对其挺感兴趣，所以花了一天时间，研究了一下，写了一个小demo，下面说的有任何纰漏希望大家多多指正，下面开说了，大多数的视频监考就是通过浏览器，获取你电脑上的摄像头，来实现视频监考的功能的，所以相当于你的电脑是客户端，而公司那边是服务器，所以这大体上是一个客户端服务器模式，但是要通过浏览器来做客户端，通过浏览器来做服务端，这时候就要涉及到浏览器和浏览器之间的通信了，但是浏览器和浏览器之间直接通信比较困难，所以还是要用一个中间服务器来做转发，通过中间服务器做好连接后，那么在通信过程中，就是浏览器之间端到端的交互了，就不需要服务器的干预了。

        要实现浏览器器端到端的通信，要用到两项技术一项是webSocket，一项是webRTC，websocket是浏览器和中间服务器做交互的手段，而webRTC是获取视频流和音频流的手段，首先一个浏览器A和一个浏览器B，要做交互，肯定得通过中间服务器C，所以浏览器A和中间服务器C会建立一个连接，而浏览器B和中间服务器同时也会建立一个连接，如果说浏览器A要向浏览器B发送一个字符串，那么A先要通过websocket把字符串发送到中间服务器，而中间服务器会找到，浏览器B对应的webSocket对象，通过这个对象把字符串发送给浏览器B，这就完成了浏览器A与B之间的交互，那么浏览器A与浏览器B之间要建立一个端到端的连接是需要通过这样的方式来实现的。
        上面讲述了，两个浏览器之间的交互过程，对于websocket的知识大家可以上网看看，上面只是基本原理。下面看看webRTC是怎么工作的，在HTML5中，我们可以通过js代码获取到我们本地的视频流，但是我们本地的视频流不是给我们自己看的，是给监考的公司看的，所以我们需要在浏览器之间建立连接，然后把视频流发送过去。这个连接就是webRTC的核心东西了，在浏览器中可以用js代码新建一个WEBRTC的连接，var pc = new webkitRTCPeerConnection(iceServer);
 这条语句就是建立一个连接，也就是代表这个浏览器，那么在另一个浏览器中，我们同样可以建立这样一个连接，但是这连个连接是独立的，他们像是两根管道，这时候需要我们把它链接起来。
        这时A要监考B具体过程如下：
         首先交换浏览器之间的描述信息，像是ip，端口，视频信息，等等的一些信息，这统称为描述信息，那么两个浏览器都有描述信息，首先浏览器A主动向B发起连接，A首先把自己的描述信息（localDescription）加入自己的连接，然后A向B发送一个offer包，这个发送是通过websocket来发送的，发送到服务器，然后服务器转发到B，B收到以后通过offer包可以获得B的描述信息，B把收到的远程描述信息（remoteDescription）加入自己的连接，然后再把自己的本地描述信息，放入自己的连接，再向A发送一个answer包，A接收到answer包以后，可以获得B的描述信息了，这时把B的描述信息，加入到自己的连接中，这样两个浏览器都包含有对方的描述信息，这样就基本完成了两个浏览器之间的连接，接下来就是其他信息的以下交互，主要是为了不仅仅能够在局域网内建立连接，在这些交互做完以后，那么B把自己的视频流加到连接里，这样在A就可以获取视频流了，然后整个通信过程就不需要webSocket的参与了，只是在B下线或者是A下线的时候，或通知中间服务器删除对应的连接。
        下面是我的主要代码：
        服务器java代码，处理浏览器的登录退出，以及消息的转发：
      
public class Admin extends StreamInbound{

	@Override
	protected void onBinaryData(InputStream arg0) throws IOException {
		// TODO Auto-generated method stub
		
	}

	@Override
	protected void onTextData(Reader ir) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader br=new BufferedReader(ir);
		//char[] buf=new char[2000];
		//char[] sbuf=new char[6000];
		//StringBuilder sb=new StringBuilder();
		/*int n=0;
		int index=0;
		while((n=ir.read(buf))>0){
		   System.arraycopy(buf, 0, sbuf, index, n);
		   Arrays.fill(buf, '0');
		   index+=n;
		}*/
		StringBuilder sb=new StringBuilder();
		String temp=null;
		while((temp=br.readLine())!=null){
			sb.append(temp);
		}
		//String[] test=sb.toString().split("\r\n");
		//StringBuilder sb2=new StringBuilder();
		//for(int i=0;i<test.length;i++){
		//  	sb2.append(test[i]);
		//}
		//System.out.println(test.length);
		//System.out.println(sb.toString());
		//System.out.println("转发给了客户端");
		//转发给客户端
		//ConnectionPool.getAdmin().getWsOutbound().writeTextMessage(CharBuffer.wrap(sb.toString().toCharArray()));
	    Map<Long,StreamInbound> map=ConnectionPool.getClientMap();
	    for(Map.Entry<Long, StreamInbound> entry:map.entrySet()){
	    	System.out.println("fawegawergawrehgeahtresathresathreshtrehsr");
	    	
	    	entry.getValue().getWsOutbound().writeTextMessage(CharBuffer.wrap(sb.toString()));
	    }
	}

	@Override
	protected void onClose(int status) {
		// TODO Auto-generated method stub
		//super.onClose(status);
		System.out.println(status);
		if(ConnectionPool.logout()){
		   System.out.println("服务端出去了");
		}else{
			System.out.println("当前没有服务端不能登出");
		}
	}

	@Override
	protected void onOpen(WsOutbound outbound) {
		// TODO Auto-generated method stub
		//super.onOpen(outbound);
		if(ConnectionPool.login(this)){
		   System.out.println("服务端进来了");
		}else{
			System.out.println("当前已有管理员");
		}
	}
	
	

}



public class Server extends WebSocketServlet{
	
	@Override
	protected StreamInbound createWebSocketInbound(String arg0,
			HttpServletRequest req) {
		// TODO Auto-generated method stub
		String info=req.getParameter("info").trim();
		if(info.equals("client")){
			return new Mession(System.currentTimeMillis());
		}else{
			return new Admin();
		}
	}

}public class Mession extends StreamInbound{
	
	private long time;
	public Mession(long time){
		this.time=time;
	}
	
	@Override
	protected void onBinaryData(InputStream arg0) throws IOException {
		System.out.println("get");
		
	}

	@Override
	protected void onTextData(Reader ir) throws IOException {
		/*char[] buf=new char[2000];
		StringBuilder sb=new StringBuilder();
		int n=0;
		while((n=ir.read(buf))>0){
		  
		   sb.append(buf,0,n);
		   Arrays.fill(buf, ' ');
		}*/
		//char[] buf=new char[2000];
		//char[] sbuf=new char[6000];
		//StringBuilder sb=new StringBuilder();
		/*int n=0;
		int index=0;
		while((n=ir.read(buf))>0){
		   System.arraycopy(buf, 0, sbuf, index, n);
		   Arrays.fill(buf, '0');
		   index+=n;
		}*/
		BufferedReader br=new BufferedReader(ir);
		String temp=null;
		StringBuilder sb=new StringBuilder();
		while((temp=br.readLine())!=null){
			sb.append(temp);
		}
		//String[] test=sb.toString().split("\r\n");
		//StringBuilder sb2=new StringBuilder();
		//System.out.println(sb.toString().leng);
		//for(int i=0;i<test.length;i++){
		//  	sb2.append(test[i]);
		//}
		//System.out.println(sb.toString());
		//System.out.println("转发给了客户端");
		//String message=sb.toString();
		
		//转发给服务器
		ConnectionPool.getAdmin().getWsOutbound().writeTextMessage(CharBuffer.wrap(sb.toString()));
		
	}

	@Override
	protected void onClose(int status) {
		// TODO Auto-generated method stub
		//super.onClose(status);
		//移除连接
		ConnectionPool.removeConnection(time);
		System.out.println("connection has closed!!!");
	}

	@Override
	protected void onOpen(WsOutbound outbound) {
		// TODO Auto-generated method stub
		//super.onOpen(outbound);
		//把连接放入池中
		ConnectionPool.addConnection(time, this);
		try {
			System.out.println("向客户端发送了数据");
			outbound.writeTextMessage(CharBuffer.wrap("hello".toCharArray()));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		System.out.println("connection open!!!");
	}
	
	

}
public class ConnectionPool {

	private final static Map<Long,StreamInbound> connections=new HashMap<Long,StreamInbound>();
	
	private static StreamInbound admin=null;
	
	public static Map<Long,StreamInbound> getClientMap(){
		return connections;
	}
	
	public static StreamInbound getAdmin(){
		return admin;
	}
	public static boolean login(StreamInbound admin){
		if(ConnectionPool.admin==null){
			ConnectionPool.admin=admin;
			System.out.println(ConnectionPool.admin.getReadTimeout());
			return true;
		}else{
			return false;
		}
	}
	
	public static boolean logout(){
		if(ConnectionPool.admin==null){
			return false;
		}else{
			ConnectionPool.admin=null;
			return true;
		}
	}
	
	public static void addConnection(long time,StreamInbound connection){
		connections.put(time, connection);
		System.out.println("加入连接");
	}
	
	public static void removeConnection(long time){
		connections.remove(time);
		System.out.println("移动出连接");
	}
	

}

下面是前段js代码和html代码：

server.html

<html>
  <head>
    <title>server</title>
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	<meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
	<meta http-equiv="description" content="This is my page">
	<!--
	<link rel="stylesheet" type="text/css" href="styles.css">
	-->
	<script type="text/javascript">
	   
	 
	function onOpen(event) {
	      document.getElementById('messages').innerHTML
	        = 'Connection established';
	    }
	 
	    function onError(event) {
	    	 document.getElementById('messages').innerHTML
		        += '<br/>'+event.data;
	    }
	    function start() {
	        var webSocket =new WebSocket("ws://localhost:8888/WS/wstest?info=admin");
	  
	 	    webSocket.onopen = function(event) {
	 	      onOpen(event);
	 	    };
	 	    
	 	    webSocket.onerror = function(event) {
	 		      onError(event);
	 		};
	 		
	 		webSocket.onclose=function(event){
	 			//document.getElementById('messages').innerHTML
		        //+= '<br/>'+str(event.data);
		        alert(event.data);
	 		}
	 		 var iceServer = {
	 	            "iceServers": [{
	 	                "url": "stun:stun.l.google.com:19302"
	 	            }]
	 	        };
	        // 创建PeerConnection实例 (参数为null则没有iceserver，即使没有stunserver和turnserver，仍可在局域网下通讯)
	        var pc = new webkitRTCPeerConnection(iceServer);

	        // 发送ICE候选到其他客户端
	       

	        // 如果检测到媒体流连接到本地，将其绑定到一个video标签上输出
	        pc.onaddstream = function(event){
	        	//alert("检测到流");
	            document.getElementById('remoteVideo').src = webkitURL.createObjectURL(event.stream);
	        };

	        // 发送offer和answer的函数，发送本地session描述
	        /*var sendOfferFn = function(desc){
	        	
	            alert(desc.sdp)
	        	//pc.setRemoteDescription(desc);
	           // pc.setLocalDescription(desc);
	            
	            webSocket.send(JSON.stringify({ 
	                "event": "_offer",
	                "data": {
	                    "sdp": desc
	                }
	            }));
	        };*/
	        
	        pc.onicecandidate = function(event){
	            if (event.candidate !== null) {
	                webSocket.send(JSON.stringify({
	                    "event": "_ice_candidate",
	                    "data": {
	                        "candidate": event.candidate
	                    }
	                }));
	            }
	        };
	        var sendAnswerFn = function(desc){
	        
	            pc.setLocalDescription(desc);
	            webSocket.send(JSON.stringify({ 
	                "event": "_answer",
	                "data": {
	                    "sdp": desc
	                }
	            }));
	        };

	        // 获取本地音频和视频流
	       /* navigator.webkitGetUserMedia({
	            "audio": true,
	            "video": true
	        }, function(stream){
	            //绑定本地媒体流到video标签用于输出
	           // document.getElementById('localVideo').src = URL.createObjectURL(stream);
	            //向PeerConnection中加入需要发送的流
	            pc.addStream(stream);
	            //如果是发起方则发送一个offer信令
	            
	            pc.createOffer(sendOfferFn, function (error) {
	               console.log('Failure callback: ' + error);
	            });
	            
	        }, function(error){
	            //处理媒体流创建失败错误
	            console.log('getUserMedia error: ' + error);
	        });
            */
	        //处理到来的信令
	        webSocket.onmessage = function(event){
	        	//alert(event.data)
	        	//document.getElementById('messages').innerHTML
		        //+= '<br/>'+event.data;
		        var jsonstr="'"+event.data+"'"
	            var json = JSON.parse(event.data);
	            console.log('onmessage: ', json);
	            //如果是一个ICE的候选，则将其加入到PeerConnection中，否则设定对方的session描述为传递过来的描述
	            
	            if( json.event == "_ice_candidate" ){
	            	//alert("收到候选");
	                pc.addIceCandidate(new RTCIceCandidate(json.data.candidate));
	               
	            } else {
	               
                   if(json.event == "_offer") {
		               pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp),function(){
		               //pc.setRemoteDescription(null,function(){   
		            	   pc.createAnswer(sendAnswerFn, function (error) {
		                    	alert(error);
		                        console.log('Failure callback: ' + error);
		                    });
		               },function(){
		            	    alert("error");
		                	pc.createAnswer(sendAnswerFn, function (error) {
		                    	alert("error");
		                        console.log('Failure callback: ' + error);
		                    });
		                });
		               
	               }
	               
	               //  pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp,function(){
	                //	alert(1);
	                //}));
	               //  if (isRTCPeerConnection)  
                    //  pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp));  
                  // else  
                   //   pc.setRemoteDescription(pc.SDP_OFFER,  
                    //        new SessionDescription(json.data.sdp.sdp)); 
	               //pc.setRemoteDescription(new RTCSessionDescription(pc.SDP_OFFER,json.data.sdp));
	               //pc.SDP_OFFER
	                //pc.setRemoteDescription(pc.SDP_OFFER,new SessionDescription(json.data.sdp.sdp));
	                // 如果是一个offer，那么需要回复一个answer
	               /* if(json.event == "_offer") {
	                	alert(json.event)
	                    pc.createAnswer(sendAnswerFn, function (error) {
	                    	document.getElementById('messages').innerHTML
	        		        += '<br/>'+error;
	                        console.log('Failure callback: ' + error);
	                    });
	                }*/
	            }
	        };
	    }
	</script>
  </head>
      
  <body>
    <input type="submit" value="Adminlogin" onclick="start()">
    <div id="messages">
    </div>
    <video id="remoteVideo" autoplay="autoplay"></video>
    <video id="localVideo" autoplay></video>
    
  </body>
</html>

contronlled.html


<html>
  <head>
    <title>client</title>
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	<meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
	<meta http-equiv="description" content="This is my page">
	<!--
	<link rel="stylesheet" type="text/css" href="styles.css">
	-->
	<script type="text/javascript">
	    function onOpen(event) {
	      document.getElementById('messages').innerHTML
	        = 'Connection established';
	    }
	 
	    function onError(event) {
	    	 document.getElementById('messages').innerHTML
		        += '<br/>'+event.data;
	    }
	    
	    
	    function start() {
	        var webSocket =new WebSocket("ws://localhost:8888/WS/wstest?info=client");
	 	    webSocket.onopen = function(event) {
	 	      onOpen(event);
	 	    };
	 	 
	 	    webSocket.onerror = function(event) {
	 		      onError(event);
	 		};
	 		webSocket.onclose=function(event){
	 			//document.getElementById('messages').innerHTML
		        //+= '<br/>'+str(event.data);
	 		    alert(event.data)
	 		}
	 		var iceServer = {
	 	            "iceServers": [{
	 	                "url": "stun:stun.l.google.com:19302"
	 	            }]
	 	        };
	        // 创建PeerConnection实例 (参数为null则没有iceserver，即使没有stunserver和turnserver，仍可在局域网下通讯)
	        var pc = new webkitRTCPeerConnection(iceServer);

	       

	        // 发送offer和answer的函数，发送本地session描述
	        var sendOfferFn = function(desc){
	        	
	            pc.setLocalDescription(desc);
	            webSocket.send(JSON.stringify({ 
	                "event": "_offer",
	                "data": {
	                    "sdp": desc
	                }
	            }));
	        };
	        
	        pc.onicecandidate = function(event){
	            if (event.candidate !== null) {
	                webSocket.send(JSON.stringify({
	                    "event": "_ice_candidate",
	                    "data": {
	                        "candidate": event.candidate
	                    }
	                }));
	            }
	        };
	        
	        
	     // 获取本地音频和视频流
	        navigator.webkitGetUserMedia({
	            "audio": true,
	            "video": true
	        }, function(stream){
	            //绑定本地媒体流到video标签用于输出
	           //document.getElementById('localVideo').src = URL.createObjectURL(stream);
	            //向PeerConnection中加入需要发送的流
	            pc.addStream(stream);
	            //如果是发起方则发送一个offer信令
	            pc.createOffer(sendOfferFn, function (error) {
		               console.log('Failure callback: ' + error);
		            });
	        }, function(error){
	            //处理媒体流创建失败错误
	            console.log('getUserMedia error: ' + error);
	        });

	        //处理到来的信令
	        webSocket.onmessage = function(event){
	        	//alert(event.data);
	        	//document.getElementById('messages').innerHTML
		       // += '<br/>'+event.data;
		        var jsonstr="'"+event.data+"'";
	            var json = JSON.parse(event.data);
	            
	            console.log('onmessage: ', json);
	            
	            //如果是一个ICE的候选，则将其加入到PeerConnection中，否则设定对方的session描述为传递过来的描述
	            if( json.event == "_ice_candidate" ){
	            	
	                pc.addIceCandidate(new RTCIceCandidate(json.data.candidate));
	            } else {
	            	//接收到确认符号
	            	if(json.event == "_answer"){
		            	pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp),function(){},function(){});
		            	 // 发送ICE候选到其他客户端
	            	}
	            }
	        };
	    }
	</script>
  </head>
      
  <body>
    <input type="submit" value="clientLogin" onclick="start()">
    <div id="messages">
    </div>
    <video id="remoteVideo" autoplay></video>
   <video id="localVideo" autoplay></video>
  </body>
</html>

上面就是主要的代码了：具体运行流程把这些代码部署到tomcat上，打开监控端浏览器中输入http://localhost:8888/WS/server.html，打开被监控端http://localhost:8888/WS/controlled.html，然后点击监控页面中的AdminLogin按键，先让监控端注册到中间服务器上面，然后点击被监控端的clientLogin按键，然后后浏览器会询问时候开启摄像头，点击开启，等待1到3秒在监控端就可以出现视频画面了。

下面是效果演示图：
        



版权声明：本文为博主原创文章，未经博主允许不得转载。

当前浏览器对HTML5支持状况(全平台)
题记
HTML5test 这个网站专门测试浏览器对HTML5支持状况,只要你的浏览器打开HTML5test这个页面,就会得到一个测评的分数,然后会列出你当前浏览器对哪些特性支持良好,哪些不支持

简易测试
如图:
360极速浏览器测试的(内核是chromium 42) – 极速模式;

我稍微看了下不支持的特性…都是比较少用到的特性…. 所以总体来说,在H5和CSS3下的体验是相当良好的
而我本地的chrome 43 的分数才521 . 还少了两分,可能优化还没做好….最新的44版本,526,在所有浏览器中,对HTML5支持是最为完善的;
IE11和edge(WIN 10下的),我测试了下,,对HTML5的支持还是比较完善的;尤其是EDGE,简直升了一个台阶(相对于IE系列);
IE11:

EDGE

其他的不多说,直接上数据图!!!;

数据对比
PC端


其中支持最为完善是chrome系列
opera改为chromium内核了..所以分数基本一致
出乎意料的是Firefox,W3C标准一直都在最前沿的,对H5的支持竟然不是最高的!!!
IE10以下,H5的体验就差强人意了…只能支持一部分
Safari的老版本比IE老版本系列好太多….

平板


chrome依旧牛逼,稳居第一
其他的大同小异(IE除外)
不过最新的edge挺不错的,不管是移动端还是PC端…大跃进啊~~
所以移动端的兼容性比PC端要好上很多,各种特性任性用!!

手机端


手机端的各大系列浏览器支持都很不错…除了个别很老的系列…

总结

使用chrome系列或者chromium内核的浏览器对HTML5/CSS3支持是比较完善的,
而最新崛起的edge似乎更有看头,能不能消除IE系列的影响就看这货了…或许过上两年,WIN10的比重取代了WIN7的比重…那时候就可以任性的用最新特性写各种特效,各种更人性化的标签; 而不是现在的各种模拟,各种兼容
XP这货总会过去的,死磕怀旧的毕竟是少数,为了更好的体验,人总会往上看的!!

数据时间: 2015-8-24 
来源:  HTML5test

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 5410


CRB and His Birthday
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 625    Accepted Submission(s): 325



Problem Description

Today is CRB's birthday. His mom decided to buy many presents for her lovely son.
She went to the nearest shop with M Won(currency
 unit).
At the shop, there are N kinds
 of presents.
It costs Wi Won
 to buy one present of i-th
 kind. (So it costs k × Wi Won
 to buy k of
 them.)
But as the counter of the shop is her friend, the counter will give Ai × x + Bi candies
 if she buys x(x>0)
 presents of i-th
 kind.
She wants to receive maximum candies. Your task is to help her.
1 ≤ T ≤
 20
1 ≤ M ≤
 2000
1 ≤ N ≤
 1000
0 ≤ Ai, Bi ≤
 2000
1 ≤ Wi ≤
 2000


 


Input

There are multiple test cases. The first line of input contains an integer T,
 indicating the number of test cases. For each test case:
The first line contains two integers M and N.
Then N lines
 follow, i-th
 line contains three space separated integers Wi, Ai and Bi.


 


Output

For each test case, output the maximum candies she can gain.

 


Sample Input

1
100 2
10 2 1
20 1 1


 


Sample Output

21
HintCRB's mom buys 10 presents of first kind, and receives 2 × 10 + 1 = 21 candies. 


 


Author

KUT（DPRK）

 


Source

2015 Multi-University Training Contest 10

 


Recommend

wange2014

 




#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;
#define N 1005
#define INF 0x3f3f3f3f

int n, M, a[N], b[N], w[N];
int d[2 * N];

int main()
{
    int T;
    scanf("%d", &T);
    while(T--)
    {
        scanf("%d%d", &M, &n);
        for(int i = 1; i <= n; i++)
            scanf("%d%d%d", &w[i], &a[i], &b[i]);
            
        memset(d, 0, sizeof d);
        int ans = -INF;
        for(int i = 1; i <= n; i++)
            for(int j = M; j >= w[i]; j--)
                d[j] = max(d[j], d[j - w[i]] + a[i] + b[i]);

        for(int i = 1; i <= n; i++)
            for(int j = w[i]; j <= M; j++)
                d[j] = max(d[j], d[j - w[i]] + a[i]);
        printf("%d\n", d[M]);
    }
}

/*

1
100 2
10 2 1
20 1 1


*/



版权声明：本文为博主原创文章，未经博主允许不得转载。

windows下使用libsvm3.2

一、官方介绍

libsvm主页：https://www.csie.ntu.edu.tw/~cjlin/libsvm/index.html
libsvm介绍文档：http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf
官方关于更有效地使用libsvm的使用说明：http://www.csie.ntu.edu.tw/~cjlin/papers/guide/guide.pdf （非常有必要看）
数据库：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/
关于二分类的实例：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html
关于多分类实例：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multiclass.html
常见问答：http://www.csie.ntu.edu.tw/~cjlin/libsvm/faq.html   （这里可以帮你解决好多疑惑）
实用工具列表：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/ （guide提到的liblinear在此）


二、需要软件

libsvm-3.20：http://www.csie.ntu.edu.tw/~cjlin/libsvm/libsvm-3.20.zip
python-2.7.10：https://www.python.org/ftp/python/2.7.10/python-2.7.10.msi（调用python工具时使用）
gnuplot5.0.1：http://jaist.dl.sourceforge.net/project/gnuplot/gnuplot/5.0.1/gp501-win32-mingw.exe（用绘图展示整个搜索最佳参数过程）



三、训练过程说明
——（以后输入命令以.bat格式存储即可使用）

1、提取数据形式的特征：（类别标签　特征序号：特征值）
1 1:2.111 2:3.567 3:-0.125
．．．
0 1:2.156 2:3.259 3:0.258
．．．
分别将训练样本数据和测试样本数据存成名为train的文件和名为test的文件（仅为了方便区分）

2、对特征数据进行缩放（提高运算效率）
svm-scale -l -1 -u 1 -s rangetrain >train.scale （-1~1表示缩放范围 -l表low -u表up -s表save 将变换后区间存为range  train是原始特征数据 train.scale是缩放后的数据）
svm-scale -r range1test>test.scale（-r 表read 将test的数据按同一range进行缩放）
说明：区间[0,1]和[-1,1]的效果是一样的，只是[0,1]的运算效率更高

3、寻找最优c、g参数
python grid.pytrain.scale（运算结束后,会提供最优参数c和g.比如运算结果是2.0 1.0 96.8922，96.8922为交叉验证准确率）

4、使用最优参数进行训练
svm-train -c 2 -g1train.scale（会生成一个名为train.scale.model文件,文件参数说明见后续补充说明.这里我们使用了默认核函数RBF，一般RBF是效果最好的）

5、拿训练结果进行测试
svm-predict test.scale train.scale.model test.predict（得预测结果test.predict文件以及正确率）




四、补充说明：

1、修改交叉验证
svm-scale -l -1 -u 1 train >train.scale 
svm-train -v 6 train.scale（交叉验证是为了得到更好的参数）
python grid.pytrain.scale
svm-train -c 2 -g 2 train.scale

2、关于/libsvm-3.20/tools/中的easy.py和grid.py
安装完python和gnuplot后,将E:\Program Files\Python,F:\libsvm-3.20\windows,E:\Program Files\gnuplot\bin三个文件夹添加到系统路径里面,修改上两个py文件中关于libsvm的路径和gnuplot的路径.
easy.py中：gnuplot_exe = r"e:\Program Files\gnuplot\bin\gnuplot.exe"
grid.py中：#svmtrain_pathname = r'f:\libsvm-3.20\windows\svm-train.exe'
           self.gnuplot_pathname = r'e:\Program Files\gnuplot\bin\gnuplot.exe'
可以按照guide.pdf，用easy.py测试guide中的实例。guide中实验数据链接：http://www.csie.ntu.edu.tw/~cjlin/papers/guide/data/

3、关于model文件中的参数说明
svm_type c_svc   （svc表用SVM作分类器,svr表用SVM作回归,c_svc 表用异常值惩罚因子C进行不完全分类）
kernel_type rbf     （径向基核,对于大多数情况都是一个较好的选择:d(x,y) = exp(-gamma*|x-y|2））
gamma 0.03125 （核函数的参数）
nr_class 2 （类别数）
total_sv 287 （支持向量总数）
rho 102.102 （判决函数的常数项b）
label 1 0（类标签）
nr_sv 144 143（各个类中落在边界上的向量个数）
SV（SV下面枚举了所有的支持向量）
8192 1:-1 2:-0.688314 3:0.595954 4:0.416735
．．．


4、svmscale.exe参数说明
"-l lower
 : x scaling lower limit (default -1)\n"
"-u upper : x scaling upper limit (default +1)\n"
"-y y_lower y_upper : y scaling limits (default: no y scaling)\n"
"-s save_filename : save
 scaling parameters to save_filename\n"
"-r restore_filename : restore scaling parameters from restore_filename\n"


5、svmtrain.exe的参数列表
"-s svm_type : set type of SVM (default 0)\n"
" 0 -- C-SVC(multi-class classification)\n"
" 1 -- nu-SVC(multi-class classification)\n"
" 2 -- one-class SVM\n"
" 3 -- epsilon-SVR(regression)\n"
" 4 -- nu-SVR(regression)\n"
"-t kernel_type : set type of kernel function (default 2)\n"
" 0 -- linear: u'*v\n"
" 1 -- polynomial: (gamma*u'*v + coef0)^degree\n"
" 2 -- radial basis function: exp(-gamma*|u-v|^2)\n"
" 3 -- sigmoid: tanh(gamma*u'*v + coef0)\n"
" 4 -- precomputed kernel (kernel values in training_set_file)\n"
"-d degree : set degree in kernel function (default 3)\n"
"-g gamma : set gamma in kernel function (default 1/num_features)\n"
"-r coef0 : set coef0 in kernel function (default 0)\n"
"-c cost : set the parameter C of C-SVC, epsilon-SVR, and nu-SVR (default 1)\n"
"-n nu : set the parameter nu of nu-SVC, one-class SVM, and nu-SVR (default 0.5)\n"
"-p epsilon : set the epsilon in loss function of epsilon-SVR (default 0.1)\n"
"-m cachesize : set cache memory size in MB (default 100)\n"
"-e epsilon : set tolerance of termination criterion (default 0.001)\n"
"-h shrinking : whether to use the shrinking heuristics, 0 or 1 (default 1)\n"
"-b probability_estimates : whether to train a SVC or SVR model for probability estimates, 0 or 1 (default 0)\n"
"-wi weight : set the parameter C of class i to weight*C, for C-SVC (default 1)\n"
"-v n: n-fold cross validation mode\n"
"-q : quiet mode (no outputs)\n"



6、常用FAQ
Q1: Is there a program to check if my data are in the correct format? 
The svm-train program in libsvm conducts only a simple check of the input data. To do a detailed check, after libsvm 2.85, you can use the python script tools/checkdata.py. See tools/README for details.

Q2: The output of training C-SVM is like the following. What do they mean? 
optimization finished, #iter = 219 
nu = 0.431030 
obj = -100.877286, rho = 0.424632 
nSV = 132, nBSV = 107 
Total nSV = 132
obj is the optimal objective value of the dual SVM problem. rho is the bias term in the decision function sgn(w^Tx - rho). nSV and nBSV are number of support vectors and bounded support vectors (i.e., alpha_i = C). nu-svm is a somewhat equivalent form of C-SVM
 where C is replaced by nu. nu simply shows the corresponding parameter. More details are in libsvm document.

Q3: Should I use float or double to store numbers in the cache ? 
We have float as the default as you can store more numbers in the cache. In general this is good enough but for few difficult cases (e.g. C very very large) where solutions are huge numbers, it might be possible that the numerical precision is not enough using
 only float.

Q4: Does it make a big difference if I scale each attribute to [0,1] instead of [-1,1]? 
For the linear scaling method, if the RBF kernel is used and parameter selection is conducted, there is no difference. Assume Mi and mi are respectively the maximal and minimal values of the ith attribute. Scaling to [0,1] means
                x'=(x-mi)/(Mi-mi)
For [-1,1],
                x''=2(x-mi)/(Mi-mi)-1.
In the RBF kernel,
                x'-y'=(x-y)/(Mi-mi), x''-y''=2(x-y)/(Mi-mi).
Hence, using (C,g) on the [0,1]-scaled data is the same as (C,g/2) on the [-1,1]-scaled data.
Though the performance is the same, the computational time may be different. For data with many zero entries, [0,1]-scaling keeps the sparsity of input data and hence may save the time.

Q5: My data are unbalanced. Could libsvm handle such problems? 
Yes, there is a -wi options. For example, if you use
> svm-train -s 0 -c 10 -w1 1 -w-1 5 data_file
the penalty for class "-1" is larger. Note that this -w option is for C-SVC only.

Q6: How can I use OpenMP to parallelize LIBSVM on a multicore/shared-memory computer? 
It is very easy if you are using GCC 4.2 or after.
In Makefile, add -fopenmp to CFLAGS.
In class SVC_Q of svm.cpp, modify the for loop of get_Q to:
#pragma omp parallel for private(j) 
for(j=start;j<len;j++)
In the subroutine svm_predict_values of svm.cpp, add one line to the for loop:
#pragma omp parallel for private(i) 
for(i=0;i<l;i++)
kvalue[i] = Kernel::k_function(x,model->SV[i],model->param);
For regression, you need to modify class SVR_Q instead. The loop in svm_predict_values is also different because you need a reduction clause for the variable sum:
#pragma omp parallel for private(i) reduction(+:sum) 
for(i=0;i<model->l;i++)
sum += sv_coef[i] * Kernel::k_function(x,model->SV[i],model->param);
Then rebuild the package. Kernel evaluations in training/testing will be parallelized. An example of running this modification on an 8-core machine using the data set ijcnn1:
8 cores:
%setenv OMP_NUM_THREADS 8
%time svm-train -c 16 -g 4 -m 400 ijcnn1
27.1sec
1 core:
%setenv OMP_NUM_THREADS 1
%time svm-train -c 16 -g 4 -m 400 ijcnn1
79.8sec
For this data, kernel evaluations take 80% of training time. In the above example, we assume you use csh. For bash, use
export OMP_NUM_THREADS=8
instead.
For Python interface, you need to add the -lgomp link option:
$(CXX) -lgomp -shared -dynamiclib svm.o -o libsvm.so.$(SHVER)
For MS Windows, you need to add /openmp in CFLAGS of Makefile.win

Q7: How could I know which training instances are support vectors? 
It's very simple. Since version 3.13, you can use the function
void svm_get_sv_indices(const struct svm_model *model, int *sv_indices)
to get indices of support vectors. For example, in svm-train.c, after
model = svm_train(&prob, &param);
you can add
int nr_sv = svm_get_nr_sv(model);
int *sv_indices = Malloc(int, nr_sv);
svm_get_sv_indices(model, sv_indices);
for (int i=0; i<nr_sv; i++)
printf("instance %d is a support vector\n", sv_indices[i]);
If you use matlab interface, you can directly check
model.sv_indices

Q8: After doing cross validation, why there is no model file outputted ? 
Cross validation is used for selecting good parameters. After finding them, you want to re-train the whole data without the -v option.

Q9: How do I choose the kernel? 
In general we suggest you to try the RBF kernel first. A recent result by Keerthi and Lin ( download paper here) shows that if RBF is used with model selection, then there is no need to consider the linear kernel. The kernel matrix using sigmoid may not be
 positive definite and in general it's accuracy is not better than RBF. (see the paper by Lin and Lin ( download paper here). Polynomial kernels are ok but if a high degree is used, numerical difficulties tend to happen (thinking about dth power of (<1) goes
 to 0 and (>1) goes to infinity).

Q10: I press the "load" button to load data points but why svm-toy does not draw them ? 
The program svm-toy assumes both attributes (i.e. x-axis and y-axis values) are in (0,1). Hence you want to scale your data to between a small positive number and a number less than but very close to 1. Moreover, class labels must be 1, 2, or 3 (not 1.0, 2.0
 or anything else).


Q11：Feature selection tool
This is a simple python script (download 
here) to use F-score for selecting features. To run it, please put it in the sub-directory "tools" of LIBSVM.
Usage: ./fselect.py training_file [testing_file]
Output files: .fscore shows importance of features, .select gives the running log, and .pred gives testing results.
More information about this implementation can be found in Y.-W. Chen and C.-J. Lin,Combining SVMs with various feature selection strategies. To appear in the
 book "Feature extraction, foundations and applications." 2005. This implementation is still preliminary. More comments are very welcome.



Q12：Weights for data instances
Users can give a weight to each data instance. For LIBSVM users, please download the zip file (MATLAB and Python interfaces are included). You
 must store weights in a separated file and specify -W your_weight_file. This setting is different from earlier versions where weights are in the first column of training data.
1)Training/testing sets are the same as those for standard LIBSVM/LIBLINEAR.
2)We do not support weights for test data.
3)All solvers are supported.
4)Matlab/Python interfaces for both LIBSVM/LIBLIENAR are supported.



Q13：Binary-class Cross Validation with Different Criteria
参考文档：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/eval/index.html

版权声明：本文为博主原创文章，未经博主允许不得转载。

《小明的手机不见了？》
 
趋势科技自制的网络安全系列漫画《小广和小明的安全大小事 》首次登场，欢迎大家收看！不仅漫画情节精彩，而且处处都是安全常识哦！下面就为大家奉上第一集精彩漫画咯！看完记得分享给小伙伴儿噢！
 
 
看完漫画，问题来了：
你的智能手机有设屏幕锁吗?
    智能手机是最容易丢失的物品之一，万一落入心怀不轨的人手中，就不只是秘密照片会被外人看到，感到很囧咯。你最该担心的是手机中的联系人信息、网上银行或在线购物等这些服务可能遭到非法使用！
那么假如手机不慎丢失后怎么办呢? 
    设屏幕锁是大家都可以采取的防范措施之一。如果要解除锁定，必须输入事先登录的识别号码等认证信息，这样有助于避免智能手机遭到他人非法使用。
 


 

版权声明：本文为博主原创文章，未经博主允许不得转载。

想访问外网？越狱已不是问题!So Easy！时空隧道邀请码！
首先奉上邀请码：时空隧道邀请码 jXdqLw  (必备的哟！只有邀请码才可以注册这个时空隧道的账户，请大家牢记！)给你推荐一款海外网站加速工具，为科技工作者、海外归国人员、企业团队、外贸工作者提供海外上网服务，永久免费。 下面的网址需要成功越狱之后才可以访问的哟！！国外网址：https://chrome.google.com/webstore/detail/hfinpallhogllbckokkaefjjcjhjpnln国外网址：http://www.suidao.in/invi/jXdqLw国内网址：http://suidao.wuseyi.com/invi/jXdqLw时空隧道邀请码 jXdqLw欢迎大家走进越狱的世界！也许大家都会多少的抱怨国内限制访问外网过于严格，这也不许访问，那也不需访问。那么现在我就为大家奉上  访问外网  的超级简单得教程。相当管用！以图为鉴！  下面开始正式的越狱了！ 首先需要的软件有：谷歌浏览器（必备）其次  谷歌浏览器插件（必备）-----》  时空隧道   链接:http://chromecj.com/productivity/2015-04/419.html  下载时空隧道的压缩包，其中有一个叫做extension.crx的文件,将他拷贝下来，打开谷歌浏览器  打开谷歌浏览器找到菜单中的扩展程序如下面的图片！  随后将之前下载的时空隧道插件拖动到扩展程序的谷歌浏览器界面！如图所示！  这样插件就安装到谷歌浏览器当中了，我们就可以使用时空隧道的插件了！下面就是成功安装插件后的实例图！下面让我们开启时空隧道，准备越狱吧！ 首先我们需要注册时空隧道的账户！同时需要邀请码！再次奉上时空隧道邀请码 jXdqLw  (必备的哟！只有邀请码才可以注册这个时空隧道的账户，请大家牢记！)注册的过程就不需要我详解了吧！大家已经再熟悉不过了吧！ 这样我们注册成功后，我们就可以登陆时空隧道中，我们就可访问我们想访问的外网了！毫无顾虑了！下面感受一下外网的畅快吧！ 最后提醒一下各位，不要忘记激活账户哟！只需要将邮箱内的16位验证码输入到他的验证框里即可激活！不信你试试！   

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

Android文件存储

Android使用文件系统来读取和保存文件的， 相关的包请参照java.io包下面的文件。


1） 选择内部存储(Internal Storage)或者是外部存储(External Storage)
  Android设备有两个存储区域：内部存储和外部存储空间， 顾名思义， 内部存储是跟随android系统的， 外部系统是可拆卸的设备例如SD card等。 
  对于很多Android设备， 即使没有前面所说的外部设备(如SD card)， 系统同样提供在内部存储区域上提供了一块空间作为"外部存储"。因此即使
  没有可拆卸的外设，仍然后两套存储空间可供选择。API对两种外部设备是同样适用的。 下面是两种存储空间的一些特性：
  a. 内部设备(Internal Storage)
  1. 内部设备是一直存在的，并且是一直有效。
  2. 默认情况下，存储在内部设备上的文件只能被自己的app单独访问。
  3. 当卸载app的时候，系统会移除所有的保存在内部设备上的app文件。
  由以上特点可以看出， 内部设备适合保存那些只有自己的app访问的数据和文件。 比如登录后的用户信息， 数据库文件等私密信息。
  b. 外部设备(External Storage)
  1. 外部设备并不保证是一直存在且有效的。比如user可能挂载了外部设备然后移除了它。
  2. 外部设备是"公共区域"， 存储在外部设备上的文件无法控制其私密性，其他app可以读取操作它。
  3. 当卸载app的时候，系统只会移除存储在getExternalFilesDir()文件夹下的文件，其他的文件不会主动移除。 也就是说，会产生垃圾数据。
  对比内部设备， 可以看出外部设备适合存储那些不需要阅读权限的文件。
2） 获取读写权限。
  为了读取外部设备，需要在manifest中添加读写权限：
  <manifest ...>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    ...
  </manifest>
  值得注意的是， 现在所有的app均有能力读取外部设备，并不需要特殊的读权限。 但是在未来的Android版本中，会加入更多的限制。
  因此在你的app中，同样需要添加读权限已防备未来更新版本带来的麻烦。
  <manifest ...>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    ...
  </manifest>
  
  而读写内部设备不需要任何权限。 app拥有读写它的内部存储空间的权利。
3） 存储文件到内部设备
  当需要存储文件到内部空间时，可以通过File类的两种方法来获取存储路径
  getFilesDir()     会返回你的app的内部存储空间的路径
  getCacheDir()     返回你的app的内部存储空间的缓存目录， 如果缓存文件不太需要的话，请及时清理已保证缓存目录的以保证缓存文件不会占用太大空间，
  比如1M， 不然系统有可能在没有警告的情况下直接删除缓存目录下的文件。
  
  如果要在背部设备上创建文件，可以使用如下代码：
  File file = new File(context.getFilesDir(), filename);
  

  相应的，可以使用openFileOutput() 来获取FileOutputStream ， 然后通过它来写文件到内部设备。下面是例子：
String filename = "myfile";
  String string = "Hello world!";
  FileOutputStream outputStream;


  try {
    outputStream = openFileOutput(filename, Context.MODE_PRIVATE);
    outputStream.write(string.getBytes());
    outputStream.close();
  } catch (Exception e) {
    e.printStackTrace();
  }
  
  
  或者是，你同样可以使用createTempFile()来创建文件， 下面的例子是通过url获取文件名，然后保存在缓存目录下：
  public File getTempFile(Context context, String url) {
    File file;
    try {
        String fileName = Uri.parse(url).getLastPathSegment();
        file = File.createTempFile(fileName, null, context.getCacheDir());
    catch (IOException e) {
        // Error while creating file
    }
    return file;
  }

  
  内部设备的目录是以你的包名存储的， 从技术上来说， 如果你把文件保存成readble模式，其他的app可以读取此文件，当然它要知道
  你的包名和你的文件名。其他的app不能浏览你的内部文件夹， 如果你没有把文件属性设置为readable或者writable。
  只要你使用MODE_PRIVATE模式，其他的app就不能访问你的文件。
  
4） 外部存储空间
  因为外部空间是可拆卸的，因此在访问它之前，必须确保其存在。 Android提供了响应的接口来判断外设是否可用。当外设的状态为MEDIA_MOUNTED,即意味着外设可读写。
  下面的代码可以用来检查外设是否可用
  /* Checks if external storage is available for read and write */
  public boolean isExternalStorageWritable() {
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state)) {
        return true;
    }
    return false;
  }


  /* Checks if external storage is available to at least read */
  public boolean isExternalStorageReadable() {
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state) ||
        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
        return true;
    }
    return false;
  }

  
  前面也提到过，外设上的文件也有区别， 有的随着app的卸载会被系统同时删除，有些目下的文件不会同时被删除。
  因此， 根据你的文件的类型，你可以选择将他们保存在不同的目录下：
  共有文件：
  这些文件可同时被其他的app使用，当卸载时，不希望被删除，比如下载的图片，或者使用app拍摄的照片等。
  私有文件：
  你的app的单独使用的文件，在卸载时，希望同时被删除，尽管这些文件能够被其他的app访问，但对用户已经没有价值。例如一些缓存数据。
  
  当你保存共有文件时，可以使用getExternalStoragePublicDirectory()方法来获取外设的根目录，在此根目录上创建新的文件路径。
  这个方法需要指定你需要存储的类型，比如图片或者音乐等。例如：
  
  public File getAlbumStorageDir(String albumName) {
    // Get the directory for the user's public pictures directory. 
    File file = new File(Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created");
    }
    return file;
  }

  
  当你需要存储私有文件时，可以通过getExternalFilesDir()， 同样可以指定需要的类型， 例子如下：
  
  public File getAlbumStorageDir(Context context, String albumName) {
    // Get the directory for the app's private pictures directory. 
    File file = new File(context.getExternalFilesDir(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created");
    }
    return file;
  }

  
  如果不需要指定类型，可以传递null到getExternalFilesDir()中，它返回的是您的应用程序的在外部存储的根目录。
  
  记住两者之间的区别。
  
5） 查询剩余空间
  如果你知道需要保存的文件的大小，你需要保证有足够的空间来存储这些文件。
  可以通过getFreeSpace() 或者 getTotalSpace() 来获取文件的大小。
  
6) 删除文件：
  可以通过File的delete()方法来删除文件。或者通过context.deteleFile(fileName)来删除内部空间的文件。
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

IT行业中的六个肮脏秘密
我们向读者朋友征集在工作中遇到过的最肮脏的IT秘闻——那些来自灰色地带的谎言以及其他人根本意识不到的技术阴暗面。整理工作结束后，我们将这些"秘密"交给相关领域的专家，让他们对其进行分析。其中一部分得到了专家的共鸣，但另一些则未受肯定。IT专业人士往往若无其事地传播灰色谎言、玩弄技术业务的黑色权谋IT专业人士往往对问题背后的真正由来了如指掌——有时候，他们本人就是造成麻烦的罪魁祸首。我们向读者朋友征集在工作中遇到过的最肮脏的IT秘闻——那些来自灰色地带的谎言以及其他人根本意识不到的技术阴暗面。整理工作结束后，我们将这些“秘密”交给相关领域的专家，让他们对其进行分析。其中一部分得到了专家的共鸣，但另一些则未受肯定。系统管理员手中的权力足以成为CIO最恐怖的噩梦？IT员工仍然拿走企业设备？我们保存在云端的数据是否真会不翼而飞？技术支持服务开出的价码算不算高得离谱？通过今天的文章，我们将共同了解当事者与相关专家们的观点。IT肮脏秘密第一条：系统管理员抓着公司的小辫子IT这只黄鼠狼居然成了数据这只肥鸡的守门者任何一位关注过爱德华•斯诺登其人其事的朋友肯定已经了解到，一位系统管理员能够造成怎样的破坏。但即使是IT人士自己可能也无法想象，不受约束的管理员究竟拥有何等惊人的权力与危害性。“对于IT人士而言，根本不存在秘密这回事，”安全服务托管供应商Network Box USA公司CTO Pierluigi Stella表示。“我可以在自己的防火墙上植入探测工具，从而掌握特定计算机上进进出出的任何一个数据包。我能够看到人们在消息当中写下哪些内容、他们访问了哪些互联网站、在Facebook上写了些什么。事实上，道德是惟一一种能够约束IT人士不至于误用或者滥用这种权力的因素。IT人士完全就是存在于我们身边的国安局的缩影。这种情况相当常见，甚至大部分CIO都已经意识到了这一点，数据保护企业SafeNet公司首席战略官Tsion Gonen指出。“我估计九成以上的企业都面临着这样的危机 ，”他表示。“企业安全的可靠性与IT管理员的可信程度密切相关。我们很难准确弄清到底有多少系统管理员正在滥用自己手中的访问权限——但可以肯定的是，数量已经多到足以占据每星期的报纸头条。最可怕的是，安全风险往往来自那些负责为企业员工分配访问权限的家伙。”数据治理方案供应商Varonis公司副总裁David Gibson也认为，管理员一般确实有能力在神不知鬼不觉的情况下进行数据访问，但他提出了相对比较具体的比例数字——50%。他补充称，这样的问题并不只发生在管理员身上——大部分用户都有能力访问超出工作范围之外的更多数据。他表示，要想解决这一难题，方案可以归纳为两个方面：利用“最低权限”模式削弱员工的访问能力；持续对数据访问者进行监控。“企业需要有能力查看哪些员工访问了什么样的数据，这些数据归属于谁以及谁已经访问了其中的哪些文件，”他表示。“以此为基础，IT部门将能够与数据所有者直接接触，从而在削减权限与保持可接受的使用感受之间找到平衡点。”IT肮脏秘密第二条：员工很可能正在“以厂为家”那些“退休”了的IT资产很可能以出人意料的方式焕发第二春陈旧的技术设备很少真正被丢进垃圾桶，它们往往能快速找到自己的新家——有时候，“新家”与IT员工的家会产生交集。“员工盗窃被淘汰的设备早已不是什么新鲜事了，”Retire-IT公司CEO Kyle Marks指出——这是一家专门处理与IT资产有关的欺诈与隐私合规问题的企业。“我还从来没见过任何一位从未将公物占为己有的IT从业者。对于大多数人来说，拿点业已淘汰的设备并不算什么了不起的事情。很多人也不会将此视为安全威胁——一旦设备报废，他们会将其当成可以随意处置的东西。将设备从垃圾堆或者回收站里捡走的最大问题在于，其中很可能还包含有敏感数据。一旦这部分数据遭到曝光，很可能会给公司造成巨大损失，Marks指出。当然，即使没有什么后续麻烦，这样的行为本身也属于盗窃公司财产。“盗窃与欺诈属于很严重的事态，极有可能引发大规模隐私事故，”他补充称。“如果任由这种态势发展下去，无法无天的IT员工很可能将整个企业推向崩溃的边缘。然而在大多数情况下，负责确保所有资产得到妥善处理（即删除所有数据）的主管人士往往是IT部门的一员。企业需要建立一套‘逆向采购’流程，以保证资产遵循正常方式退出自己的工作岗位。”但是不是每一位IT员工都会对陈旧硬件伸出贪婪的双手？某位拒绝公布名字的资深IT资产处置从业者表示，实际情况与Marks所做出的推论相去甚远。“我并不是说盗窃活动并不存在，”他解释道。“我只是想说明，我从未遇到任何一位对陈旧硬件抱有固定处理模式的从业者。”他同时补充称，大部分设备之所以消失不见，主要是由于丢失或者其它一些难以说清的原因——例如被运到了错误的地点。“这听起来有些否定一切的倾向，事实上很多企业都对自身以完全诚实可信的态度提供安全服务、坚持处事方式的做法表示骄傲。”IT肮脏秘密第三条：将数据保存在云中——比你想象的更危险如果跟法律条文扯上关系，世界上任何一种安全机制都将无法保护我们把数据存储在云环境下确实很方便，但我们也很可能需要为这样的便利付出高昂的代价：在如同一团乱麻的法律诉讼当中，我们的数据将不翼而飞。“大多数人并没有意识到当自己的数据被保存在云环境中其他人的系统上、并与其它企业的数据比邻而居时，一旦对方遭遇法律纠纷、我们的数据也可能受到殃及而不得不被公之于众，”IT支持企业CSI集团老总Mike Balter指出。换句话来说，大家的云数据很可能由于针对他人的调查活动而遭受意外牵连——倒霉是惟一的理由，只是因为跟嫌疑方共用了一台服务器、企业就可能遭受严重损失。2012年1月就发生过一个典型案例，当时美国与新西兰当局关闭了Kim Dotcon公司的MegaUpload文件柜。除了确实涉嫌盗版的大量电影资料之外，当局还没收了成千上万来自守法客户的数据且拒绝归还。时至今日，这些可怜的普通用户仍然无法确定自己的数据还能不能被重新找回。“数据遭到扣押的风险是真实存在的，”Touro法律中心商业、法律与技术研究部门主任Jonathan Ezor做出证实。“如果执法部门或者其它政府官员拥有任何法律依据，则完全可以收缴存储设备或者系统——在某些特殊事件中可能需要获得批准——而这些系统中的数据无论是否存在嫌疑，都可能遭到剥夺。总之，任何一家企业的数据在存储于控制范围之外时，都将不可避免地受到某种程度的窥探——至少他人有权访问同一套硬件设备。要想保护自己免受这种最坏状况的影响，用户必须自己的数据到底被保存在哪里、哪些法律条文符合当前情况，云案例企业JumpCloud公司CEO David Campbell表示。“我们的建议是寻找一家能够对服务器及数据的物理位置做同保证的云供应商，例如Amazon，这样大家才能以主动姿态控制未知风险，”他指出。Ezor同时补充称，对数据进行加密能够有效防止获得数据的家伙成功解读其中的内容。另一个好主意是：在手头常备一份数据备份。我们真的不能确定什么时候这就成了企业的最后一根救命稻草。IT肮脏秘密第四条：员工勒紧裤带，老板却开出空头支票搞财务的最苦逼对于几乎任何一家中型或者大型企业来说，采购批准流程拥有两种执行方式，Hawkthorne集团CEO Mike Meikle指出——这是一家高级管理与信息技术咨询企业。首先是官方采购流程——时耗极长、我们需要像马戏团里的小猫小狗那样钻过一个又一个审批“火圈”。除此之外，还有一条特殊的“贵宾畅行版钻石通道”，当然只供少数“特殊人物”使用。“企业高管级别的人士都有自己的采购通道，”他解释称。“对于那些需要花掉IT人士八个月时间的审批流程，这些高管往往在几个星期之内就能搞定——这还是非常保守的估计。我将此称为‘贵宾畅行版钻石通道’。在我所接触过的政府机关或者私营企业当中，没有一个能彻底摆脱这种只存在于背地里的神秘采购途径。”官方流程之所以要刻意为难员工，就是不希望他们花企业的钱，Meikle指出——当然，除非他们能想办法走上这条秘密通道。他同时指出，遗憾的是CIO往往没有资格加入这个贵宾俱乐部，这意味着大型技术采购往往会在没有经过严格的成本分析或者考查IT战略方针的情况下就被敲定。“他们会一起出去吃午饭，供应商则在他们耳边不断灌输甜言蜜语；接下来的事情大家就都知道了：几十万美元被慷慨地抛出，换来另一套移动应用管理方案——这帮家伙根本没意识到企业已经有一套这种方案了，”他愤愤不平地表示。“现在我们有两套移动应用管理方案——要这么多干啥，拿来吃吗？”但事实并不一定如此，某位来自军方及财富百强企业的匿名人士提出反对意见。虽然很多企业确实可能回避了标准采购流程，但其中涉及的往往总是IT部门迫切需要的对象——这么做是不希望把时间浪费在繁文缛节之上，他表示。“非技术高管根本不具备制定大型采购决策所必需的IT知识，”他补充道。“如果某位高级行政人员回避了采购审核流程，执意签署采购订单并要求供应商发货，那么后续出现的一切技术失误都应该通过问责及追溯机制归结到这家伙身上。这就像氪石之于超人——是他们最大的克星。”IT肮脏秘密第五条：在客户支持的天平中站在弱势的一端技术人员只是在玩弄脚本而已相信大家对这样的情景不会感到陌生：我们通过手机与相隔半个地球之外的技术支持人员进行沟通，但在寥寥数语之后我们就发现对方的技术水平根本不行、只是在对客户照本宣科。猜猜怎么着？实际情况很可能正是这样。“IT支持是一种廉价商品，”Strive技术咨询公司总裁Tim Singleton指出——这是一家高端技术支持企业、专为中小型客户提供服务。“大部分能够帮得上忙的工具都不用花钱，计算机对使用者的知识要求也不再像过去那么严苛。我们邻居家的小女孩很可能与技术娴熟的达人一样有能力像IT企业那样解决你的计算机故障。”但也有人认为这样的结论太过武断。虽然某些简单问题确实体现不出技术支持团队的必要性，但在复杂问题方面专业建议仍然不可或缺，企业级远程IT支持方案供应商Bomgar公司服务与支持业务高级副总裁Aramis Alvarez指出。“将IT支持称为‘廉价商品’的不妥之处在于，我们不能对所有技术难题一概而论，”Alvarez表示。“某些基础问题确实能被熟悉技术的普通用户准确诊断，但病毒感染等更为复杂的情况则不行。邻家女孩也许真的具备不少技术知识，但她最终很可能对计算机上的数据造成严重破坏。”最后，我们不得不为了收拾残局而付出更高代价，New York Computer Help公司CEO Joe Silverman补充道——这样的问题往往发生在企业在技术方面偷工减料或者内部IT部门负担过重的情况下。“在日常工作中，我们发现纽约当地有很多办公组织及职能部门在以马马虎虎的态度对待计算机维修工作或者IT岗位——从其它公司拉人、找家庭成员顶替或者招揽半吊子水平的朋友，”他指出。“有时候财务部门的员工也会跑来客串解决计算机问题，但他们往往太忙或者经验不够丰富，无法修复发生故障的硬盘、主板或者电源。如果网络或者服务器发生崩溃，大家真的打算依靠财务员工完成这项工作、还是更信赖拥有二十年从业经验的资深网络工程师？”IT肮脏秘密第六条：我们知道的比你想象的多得多广泛收集数据，掌握全盘信息以为自己正处于国安局的密切监控之下？与消费者营销企业与数据代理商比起来，国安局真的只能算是小儿科。其中最大的黑手就是赌场，前任赌场数据库经理、曾根据个人经历撰写并出版《巧取豪夺：穿越繁荣之城》一书的J. T. Mathis这样说道。“当大家走进赌场时，押下的赌注绝不只是金钱——各位其实是在用自己的个人数据碰运气。”根据Mathis的估算，他前雇主营销数据库中大约包含十万个以上活跃或者非活跃的赌徒姓名。“从踏入赌场的那一刻起，大家的一举一动就处于追踪之下，”Mathis指出。“如果各位坐在一台老虎机前，赌场管理者会知晓你的当前位置、一共拉下过多少次手柄、投下过多少个硬币；他们知道你喜欢在4：30吃饭而且偏爱龙虾拼盘。他们清楚你最喜欢的香烟与酒水品牌、知道你是否在房间内观看色情节目。而在你暑期再度光临时，他们能够一眼洞悉随你一同前来的并非原配妻子，这样员工才能叫对她的名字‘Cindy’而非你太太的名字‘Barbara’。”前任赌场高管、现就职于路易斯安那州立大学的Michael Simon教授证实了Mathis的说法。但他补充称，赌场收集数据的方式与CVS、PetSmart或者Amazon相比并无多大区别。“我现在带的MBA班主攻数据库分析与发掘方向，我们调查过的所有企业都有收集客户信息并根据客户个人习惯提供服务的行为，”他表示。作为《我的游戏人生：前任赌场高管的个人视角》一书的作者，Simon补充称“这已经成为当下的常规商业惯例，而绝非什么不可告人的秘密。举例来说，我带着自己的狗到PetSmart享受特殊产品与服务，他们提供的项目一定符合我的个人消费习惯——我对此感到非常满意。从另一个角度看，PetSmart其实在以非常高效的方式提供我想要的东西、而不是浪费时间为我准备根本不可能接受的东西——例如折扣猫粮或者热带鱼。”但只有一件事有所不同：Mathis于2012年5月被赌场裁掉，但他当时手头仍持有数据库副本。而在尝试将副本还给赌场方面时，他的运气实在有些糟糕——对方拒绝接听他的电话——既然这样，他只好用手头的数据谈谈关于赌博的那些事儿了。

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

IT人必备的设计网址（推荐时空隧道谷歌插件访问外网）
下面是国外的设计网址：访问外国网址需要越狱，越狱的教程请访问下面的网址！http://blog.csdn.net/u011225629/article/details/47960675免费设计资源Freebbble: 网站搜集了来自 Dribbble 的免费素材.Dribbble: 在 Dribbble 中搜索 “freebie” 能找到许多免费的好东西.Graphic Burger: 这里的每一个设计资源都足够精致.Pixel Buddha: 为专业人士准备的设计素材，有免费的好资源，也有收费的进阶版.Premium Pixels: 为创意工作者准备的素材.Fribbble: Dribbble设计师的免费素材，项目由 Gilbert Pellegrom 所策划.Freebiesbug: 最新最热的PSD等设计素材，为设计师而生.365 Psd:每天一款免费的PSD.Dbf: 这里有来自Dribbble和Behance的免费资源.Marvel: 来自著名设计师的免费素材.UI Space: 来自那些炫酷的创意工作者的高品质设计资源.Free Section of Pixeden: 大量免费设计资源.Free Section of Creative Market: 每周一一波免费设计资源.Teehan+Lax: DiOS 8 GUI PSD (iPhone 6).Teehan+Lax: iPad GUI PSD.Freepik: 给每个人的免费平面设计资源.Tech&All: PSD，技术新闻，免费资源，都在这里.Tethr: 最漂亮的iOS UI设计工具.取色Material Palette: 帮你生成并导出Material Design配色模板.New Flat UI Color Picker: 最好的扁平化UI设计配色方案.Flat UI Colors: 漂亮的扁平化配色.Coolors: 超级快的配色方案生成工具.Skala Color: 为设计师和开发者而生的优质取色工具.Couleurs: 帮你抓取和调整屏幕上色彩的简单工具.Material UI Colors: 为Web、Android和iOS而生的 Material ui 配色模板.Colorful Gradients: 计算机自动生成的色阶.Adaptive Backgrounds: 从图像中提取主色.Brand Colors: 知名品牌的配色方案.Paletton: 配色方案设计.0 to 255: 帮助网页设计师找到某一色彩的同色系配色的工具.Colour Lovers: 创建、分享配色和配色方案.Adobe Color CC: 来自Kuler社区的优质配色组合.Bootflat: 来自扁平化设计的完美配色方案.Hex Colorrrs: Hex 转 RGB 转换器.Get UI Colors: 炫酷的UI配色.Coleure: 智能取色工具。Colllor: 配色方案生成工具.Palette for Chrome: 从任意图片生成配色方案的工具.灵感MaterialUp: 每日 Material Design 设计案例.FLTDSGN: 每日更新的最炫酷的扁平化的Web和APP UI设计.Site Inspire: 帮你获取灵感的网页设计案例.UI Cloud: 世界上最大的UI设计数据库.Moodboard: 在这里创建Moodboard，并轻松分享.Crayon: 最全面的营销设计收藏.Land-Book: 产品着陆页图库.Ocean: 设计师共享反馈信息的优质社区.Dribbble: 最炫酷的高品质设计师设计案例分享社区.Behance: 发现并展示充满创意的设计作品.Pttrns: 移动端界面设计模板.Flat UI Design: 扁平化UI设计.Awwwards: 评选最具创意、最创新也最优秀的网页设计作品.The Starter Kit: 为开发者和设计师所准备的设计.One Page Love: 单页设计案例.UI Parade: 设计案例与UI设计工具.The Best Designs: 最佳网页设计.Agile Designers: 为设计师和开发者准备的最佳资源.Niice: 有腔调的搜索引擎.免费图库Stock Up: 免费优质图片的集中地.Pexels: 搜集最佳免费图片的网站.All The Free Stock: 免费的优质图片、视频和图标.Unsplash: 免费的高清图库.Splashbase: 搜索和发现免费的高清图片、视频.Startup Stock Photos: 来这里，发现并创造更大的世界.Jay Mantri: 可以免费并任意使用的优质图片.Moveast: 这里记录了一个葡萄牙小伙的东行之旅.Travel Coffee Book: 分享旅行的每个美丽瞬间.Designers Pics: 免费可商用的高清图片.Death to the Stock Photo: 每月更新的免费图片.Foodie’s Feed: 高清免费的食物图片.Mazwai: 免费高清的视频短片.Jéshoots: 免费的现代风照片.Super Famous: 荷兰交互设计师 Folkert Gorter 的摄影作品.Picography: 免费高清图库.Pixabay: 免费高清图库.Magdeleine: 每日更新的免费高清图库.Snapographic: 可以商用的免费高清图库.Little Visuals: 每周发送7张高清免费图片到你收件箱的网站.Splitshire: 诱人的免费高清图库.New Old Stock: 来自公共档案馆的复古照片.Picjumbo: 完全免费的照片.Life of Pix: 免费高清图库.Gratisography: 免费高清图库.Getrefe: 免费高清图库.IM Free: 免费照片等资源的合集网站.Cupcake: 来自一个摄影师的款待，由 Jonas Nilsson Lee 创建.The Pattern Library: 免费的样式合集.Public Domain Archive: 100%免费的新照片.ISO Republic: 富有创意的高品质图片合集.Stokpic: 完全免费的照片Kaboompics: 获取免费照片的最佳途径.Function: 免费照片合集.MMT: 来自 Jeffrey Betts 的免费照片合集.Paul Jarvis: 免费高分辨率图片.Lock & Stock Photos: 为你准备的高清图片.Raumrot: 免费高分辨率图片.Bucketlistly: 充满创意的免费旅行照片.更多网站: Free Digital Photos | Morguefile | Public Domain Pictures | Stockvault | ImageFree |Rgbstock | Dreamstime | Free Images | Free Range Stock | Free Photos Bank.其他的精选免费照片:→ 来自 Free Goodies for Designers: (here | here | here | here | here | here | here | here | here |here.),→ 来自 Deal Jumbo: (here | here | here | here | here | here | here | here | here | here.),→ 来自 Dribbble: (here | here | here | here | here | here | here | here | here.),→ 来自 Graphic Burger: (here | here | here | here | here | here | here.)免费排版与字体资源TypeGenius: 为你的设计项目挑选最佳的字体组合.Font Squirrel: 100% 免费商用字体.FontFaceNinja: 帮你找到最佳字体的浏览器插件.Google Fonts: 为网页而生的免费开源字体解决方案.Beautiful Web Type: 来自Google Fonts的最佳字体设计.DaFont:可自由下载的字体存档.1001 Free Fonts: 可以随便选择的字体合集.FontPark: 世界上最大的字体存档.Font-to-width: 帮你适配文本宽度的工具.免费图标Fontello: 图标字体生成器.Flat Icon: 帮你在16000+免费矢量图标里搜索有用图标的工具.Material Design Icons: 来自 Google 的750个免费字符合集.Font Awesome:字体和CSS工具.Glyphsearch: 在其他的图标数据库中搜索图标的工具.MakeAppIcon: 一次生成全部尺寸图标的工具.Endless Icons: 充满创意的免费扁平化图标.Ico Moon: 4000+ 免费矢量图标和生成工具.The Noun Project:来自不同艺术家的上千创意图标.Perfect Icons: 社交图标创建工具.Material Design Icons: 750 来自 Google的免费Material Design风格图标.Icon Finder: 免费图标合集网站.Free Round Icons: Doodle Set | Flat Set | Vector Line SetIcon Sweets: 60 免费PS矢量图标.免费实用工具UI Names: 随机生成名字，可以在设计原型中使用.UI Faces: 查找并生成头像，用于UI设计.UI Blurbs: 设计原型时，可以帮你快速生成用户信息.Copy Paste Character: 点击复制工具.Window Resizer: 查看你的设计作品在不同屏幕上的显示效果.→ 生产力工具 ←帮你保持专注的环境音Noisli: 背景音和色彩生成器.Noizio: 帮你放松提高生产力的环境音.Defonic: 将各种环境音合成为旋律的工具.Designers.mx: 设计师的音乐播放列表.Coffitivity: 咖啡馆的环境音，帮你提升效率.防止分心Self Control: Mac: 帮你保持专注的应用.Cold Turkey: Windows: 帮你专注于工作的工具.组织协作Trello: 记录一切的工具.Evernote: 可能作为你一生记录工具的优秀软件.Dropbox: 世界上最优秀的网盘之一Yanado: 在 Gmail 中使用的管理工具.Wetransfer: 免费2GB的上传空间.Drp.io: 免费快速私密易用的图片托管服务.Pocket: 最好的稍后读软件，致力于成为你的图书馆的软件.Mailtoself: 一款iOS插件，让你可以在任何APP中向你的邮箱发笔记.List.ly: 发现并创建优质的列表.Markticle: 在文章中记录阅读进度的工具.远程工作Nomadlist: 那些适宜于远程工作的城市.Where Nomads at: 发现那些全世界范围内远程工作的同行们.Nomad Jobs: 那些最优秀的适宜于远程工作的创业项目.What’s It Like: 帮助旅行者找到最佳出行时机.→ 发现与学习 ←发现工具/初创项目Product Hunt: 最好的新产品策划，每天都有.Angellist: 世界范围内的初创项目.Beta List: 发现并加入属于未来的创业公司.StartupLi.st: 发现，跟踪，推荐初创公司.Startups List: 来自世界各地最佳的初创公司.Erli Bird: 伟大的新产品.协同创造Assembly: 共同创建新思路.CoFoundersLab: 在不同的地方不同的领域寻找你的合伙人.Founder2be:为你的创业公司寻找合伙人LEARNSkillshare: 帮你释放创造力的在线课程和项目.Khan Academy: 面向每个人的世界级免费教程.Coursera: 来自80+世界顶尖教育机构的免费课程.Codecademy: 免费的在线互动式代码学习平台.如何开始你的创业项目: As an Audio Podcast 或者 As Online Course.Startup Notes: 邀请优秀的创业者教你创业.The How: 向优秀的企业家学习Launch This Year: 帮你开始你的在线业务的网站.Closed Club: 查看失败的创业项目从中汲取教训.Startup Talks: 一个视频相关创业项目的合集.Rocketship.fm: 每周一次向成功创业者学习的机会.reSRC.io: 完全免费的在线编程学习的资源.那些还不错的资讯Email1K: 30天课程，让你的订阅邮件列表翻倍.Design for Hackers: 12周在邮件中学会设计.Startup Digest: 你所在领域创业项目的个性化资讯阅读.Mattermark Daily: 为投资人和创始人们准备的资讯.ChargeWhatYou’reWorth: 帮你提升自我价值的免费课程.Product Psychology: 用户行为研究方面的课程.UX Newsletter: 那些关于研究、设计和建筑的传奇.UX Design Weekly: 每周更新的优秀用户体验设计.一些有用的东西Foundrs: 联合创始人股权计算器.Ad Spend Calculator: 我的创业项目是否需要广告?HowMuchToMakeAnApp: 计算移动APP的研发成本.App vs. Website: 你应该制作一个网站还是APP?→ 商业与营销 ←免费的网站+LOGO+托管+发票HTML5 UP: 响应式的HTML5 + CSS3 网站模板.Bootswatch: 免费的Bootstrap主题.Templated: 845 款免费 CSS & HTML5 网站模板合集.WordPress.org | WordPress.com: 国外流行的博客平台（自备梯子）.Strikingly: 令人印象深刻的免费无限制网站托管.Withoomph: 漂亮的LOGO设计.Hipster Logo Generator: 时尚流行专业的LOGO生成工具.Squarespace Free Logo: 这里你可以免费下载低分辨率版本的LOGO.Hive: 世界范围内首款免费使用的云服务.Invoice to me: 免费的发票生成器.Free Invoice Generator: 另一个免费的发票生成器.Slimvoice: 极为简单的发票生成工具.免费的商务/项目名称生成工具The Name App: 为你你的项目找一个好名字Naminum: 发现完美的公司名称.Short Domain Search: 帮你寻找一个简短有力的名称.Wordoid: 帮你的项目找个简短容易记住的名字.Hipster Business Name: Hipster 商务名称生成器.Impossibility: 最佳的名称生成工具.Lean Domain Search: 快速生成网站名称.Domainr: 快速免费名称生成，短URL生成器.博客与写作Hemingway: Hemingway App 让你的写作清晰而醒目.Grammarly: 帮你找到文章中明显的错误.Medium: 来自大家的故事和想法.ZenPen: 为网站而生的轻量级写作工具.Liberio: 借助Google Drive简单快速地发布电子书.Editorial Calendar: 通过拖拽快速简便管理你的博客.Story Wars: 大家协同写故事.Headline Analyzer: 标题情感营销分析工具.WP Hide Post: 控制博客内容可见性的工具.Social Locker: 让用户通过发微博的方式来向你“支付”.Egg Timer: 标记并设定时间以便重复使用.发现内容（趋势、点子）Portent:创意内容生成器.Google Trends: 一种展示搜索趋势的新形式.Buzzsumo: 帮你分析不同内容的最佳展现形式.Hubspot Blog Topic Generator: 定制博客主题.Swayy: 发现最火爆流行的内容.其他: Google+最热 | Twitter 趋势 | Quora | Reddit免费的SEO+网站分析Open Site Explorer: 全面的链接分析工具.Ahrefs: 网站浏览器和反向链接监测工具.Quick Sprout: 为你的网站进行全面的分析.WordPress SEO by Yoast: 拥有一个有着全面优化的Wordpress网站.SEO Site Checkup: 免费帮你检测SEO问题.Hubspot Marketing Grader: 帮你进行营销分级.SimilarWeb: 不论你的网站在哪托管都可以对其进行统计分析.Alexa Ranking: 分析网站，网站排名.SERPs Rank Checker: 免费的关键字排名和SERP检查.网络安全技术(二)
          四，加密技术
        (1)加密算法与解密算法
        1基本流程
        A发送消息“Passwordiswelcome”这样的报文给B，但不希望有第三个人知道这个报文的内容，因此他使用一定
的加密算法，将该报文转换为别人无法识别的密文，这个密文即使在传输的过程中被截获，一般人也无法解密。当B
收到该密文后，使用共同协商的解密算法与密钥，则将该密文转化为原来的报文内容。
        加密与解密的流程示意图：


        2密钥
        加密与解密的操作过程都是在一组密钥的控下进行的，这个密钥可以作为加密算法中可变参数，它的改变可以改
变明文与密文之间的数学函数关系。
        加密的基本思想即是将明文转变为密文，而解密则是将密文转变为明文，这样保证了信息传输的保密性。密钥是
加重密算法中的可变参数，密钥的位数长度决定了加密算法的安全性。传统的密码体制包括对称密码体制和非对称密
码体制。
        (2)对称密码体制
        对称密钥技术即是指加密技术的加密密钥与解密密钥是相同的，或者是有些不同，但同其中一个可以很容易地推
导出另一个。
        对称加密算法中N个用户之间进行加密通信时，则需要N(N-1)个密钥。
        DES算法是一种迭代的分组密码，它的输入与输出都是64，包括一个56位的密钥和附加的8位奇偶校验位。目前比DES算法更安全的对称算法有：IDEA，RC2，RC4与Skipjack等。
       对称密钥技术：


       (3)非对称密码体制
       加密和解密使用不同的密钥，加密密钥为公钥是可以公开的，而解密密钥为私钥是保密的。不可能从任何一个密
钥推导出另一个密钥。因此，非对称密钥技术也被称为公钥加密加技术。
       非对称加密技术中N个用户之间进行通信加密，仅需要n对密钥就可以了。常用的加密算法有RSA算法，DSA算
法，PKCS算法与PGP算法。
       其中最常见的技术即为RSA算法，它的理论基础是数论中大素数分解，它的保密性随着密钥的长度的增加而增
强。但是，现在使用这种算法来加密大量的数据，其实现的速度太慢了，因此该算法现在广泛应用于密钥的分发。
       非对称密钥技术：


       五，防病毒技术
       (1)计算机病毒
       计算机病毒是指计算机程序中的一段可执行程序代理，它可以破坏计算机的功能甚至破坏数据从而影响计算机的
能力。计算机病毒通过对其他程序的修改，可以感染这些程序，使其成为病毒程序的复制，使之很快蔓延开来，很难
根除。
        (2)计算机病毒的特征
        1非授权可执行性
        2隐蔽性
        3传染性
        4潜伏性
        5破坏性
        6可触发性
       (3)计算机病毒分类
       1按破坏性分类
       2按传染方式分类
       3按连接方式分类
       (4)网络病毒
       网络病毒的特征：
       1传播方式多样，传播速度快
       2影响面广
       3破坏性强
       4难以控制
       5病毒变种多样
       6病毒智能化、隐蔽化
       7出现混合病毒
       (5)恶意代码
       1蠕虫
        蠕虫是一个自我包含的程序，它能够传播自身的功能或拷贝自身的片段到其他计算机系统(通常是通过网络连
接)。蠕虫是一种通过网络传播的恶性病毒，它具有病毒的一些共性，如传播性、隐蔽性、破坏性等等。与普通病毒相
比，而蠕虫不使用驻留文件即可在系统之间进行自我复制，它的传染目标是互联网内的所有计算机。
        2木马
       “木马”通常寄生在用户计算机系统中，盗用用户信息，并通过网络发送给黑客。与病毒不同之处在于没有自我复
制功能。“木马”程序是目前比较流行的病毒文件，但是它不会自我繁殖，也并不“刻意”地去感染其他文件，它通过将
自身伪装吸引用户下载执行，向施种木马者提供打开被种者电脑的门户，使施种者可以任意毁坏、窃取被种者的文
件，甚至远程操控被种者的电脑。
       传播途径：电子邮件，软件下载，会话软件。
       六，防病毒软件安装与配置
       (1)网络版防病毒系统结构
       1系统中心
       系统中心实时记录计算机的病毒监控、检测和清除的信息，实现对整个防护系统的自动控制。
       2服务器端
       服务器端为网络服务器操作系统应用而设计。
       3客户端
       客户端对当前工作站上病毒监控、检测和清除，并在需要时向系统中心发送病毒监测报告。
       4管理控制台
       管理控制台是为了网络管理员的应用而设计的，通过它可以集中管理网络上所有已安装的防病毒系统防护软件的计算机。
       管理控制台既可以安装到服务器上也可以安装在客户机上，视网络管理员需要，可以自由安装。
       (2)网络版防病毒系统安装
      对于大多数的网络版的防病毒系统，服务端和客户端通常可以采用本地安装，远程安装，Web安装，脚本安装等
方式进行安装。
       控制台的安装通常有两种方式：通过光盘安装控制台，远程安装控制台。系统管理员可以将管理控制台远程安装
到其他计算机上。
       (3)网络版防病毒系统的主要参数配置
       1系统升级
       从网站升级，上上级中心升级，从网站上下载手动数据包。
       2扫面设置
       3黑白名单设置
       4端口设置
       为了使网络版防病毒软件的通信数据能顺利的通过防火墙，通常系统都会提供用于数据通信端口设置的界面。(非
固定端口)
       七，防火墙技术
        (1)防火墙的主要功能
       1所有的从外部到内部的通信都必须经过它。
       2只有有内部访问策略授权的通信才能被允许通过。
       3系统本身具有很强的高可靠性，具有防攻击能力，保证自身的安全性。
       (2)防火墙的分类
       防火墙在网络之间通过执行控制策略来保护网络系统，防火墙包括硬件和软件两部分。防火墙根据其实现技术可
以分为：包过滤路由器，应用网关，应用代理和状态监测4类。
       1包过滤路由器
       实现包过滤的关键是制定包过滤规则。包过滤路由器分析所接收的包，按照每一条规则加以判断。包过滤规则一
般基于部分或全部的包头内容。例如，源，目的IP地址；协议类型；IP选项内容；源目端口号；TCK ACK标识。
       包过滤路由器的工作原理示意图：
 
        2应用级网关
        可以实现在应用层上对用户身份认证和访问操作分类检查和过滤。只要能够确定应用程序访问控制规则，就可以
采用双宿主主机作为应用级网关，在应用层过滤进出内部网络热定服务的用户请求与响应。
        应用网关的工作原理示意图：
 
        3应用代理
        应用代理完全接管了用户和服务器的访问，隔离了用户主机与被访问服务器之间的数据包的交换通道。
        应用代理的工作原理示意图：
 
         4状态检测
        状态检测能通过状态检测技术，动态地维护各个连接的协议状态。状态检测检测防火墙保留状态连接表，并将进
出网络的数据当成一个个的会话，利用状态表跟踪每一个会话状态。状态检测对每一个包的检查不仅根据规则表，更
考虑了数据包是否符合会话所处的状态，因此提供了完成的对传输层的控制能力。
        对返回受保护网络的数据包进行判断，只有那些响应来自受保护网络的请求的数据包才被放行。对于UP或
者RPC等无连接的协议，检测模块可创建虚会话用来进行跟踪。
        (3)防火墙的系统结构
        1包过滤型结构
        包过滤型结构是通过专用的包过滤路由器或是安装了包过滤功能的普通路器来实现的。包过滤型结构对进出内部
网络的所有信息进行分析，按照一定的安全策略对这些信息进行分析与限制。
       包过滤路由器的数据包转发过程示意图：
 
        2双宿网关结构
        双宿网关结构即是一台装有两块网卡的主机作为防火墙，将外部网络与通部网络实现物理上的隔开。应用级网管
暴露了整个外部网络，人们将处于防火墙的关键部位，运行应用级网管软件的计算机系统成为堡垒主机。
        连接了两个网络的多宿主机称为双宿主机。多宿主机是具有多个网络接口卡的主机，每个接口都可以和一个网
络连接，因为它能在不同的网络之间进行数据交换换，因此也称为网关。双宿网关结构即是一台装有两块网卡的主机
作为防火墙，将外部网络与同部网络实现物理上的隔开。
       双宿网关结构示意图;
 
       3屏蔽主机结构
        屏蔽主机结构将所有的外部主机强制与一个堡垒主机相连，从而不允许它们直接与内部网络的主机相连，因此屏
撇主机结构是由包过滤路由器和堡垒主机组成的。
       4屏蔽子网结构
        屏蔽子网结构使用了两个屏蔽路由器和两个堡垒主机。在该系统中，从外部包过滤路由器开始的部分是由网络系
统所属的单位组建的。属于内部网络，也称为“DMZ网络”。外部包过滤路由器与外部堡垒主机构成了防火墙的过滤
子网；内部包过滤路由器和内部堡垒主机则用于内部网络进行进一步的保护。
        屏蔽子网结构示意图：



版权声明：本文为博主原创文章，未经博主允许不得转载。

OCX 打包 CAB 与 JS 调用详细教程

    最近在做一个 WEB 项目，需要调用 OCX 进行连接读卡器读卡。本来并不想用 OCX 技术，因为 ActiveX 技术是微软出品，这样就导致整个系统只能使用 IE 浏览器(其他浏览器可以通过插件的形式支持 OCX 的调用)。但尝试了很多方法调用客户端 DLL 发现都走不通。最后无奈之下，才打算研究 OCX 技术。
    网上都说 ActiveX 技术很麻烦，会出现各种错误，不做的时候不知道，真正需要研究时候，才发现确实如此。主要问题是，报错和问题的真正原因没有关系或者说关系不大，甚至很多时候没有报错，只有不断尝试。
    言归正传，下面来讲一下如何搞定 OCX。
    首先先声明，本教程只关于 OCX 打包 CAB 和 JS 调用 OCX，这里不探讨如何通过 C++ 写 OCX。因为本人只做 Java 开发，对于C++ 并没有研究。
    开发系统：win8.1 64位
    测试通过系统：win7 64 位、win8.1 64位、xp 32位

  OCX 和 CAB 的关系。

    大家知道，得到 OCX 之后，如果想要调用，首先要注册。在不注册的情况下，没办法调用 OCX 。
    最简单的注册办法是手动注册。手动注册需要在命令行操作。对于开发人员来说，多多少少要和命令行打交道，可能没有问题，不过对于使用我们系统的客户来说，让他进行命令行操作的确不合适。不管我们文档写得多么详细，对客户来说这都是不友好的，而且手动注册也设计到安全性问题。所以就需要在客户不知情的情况下自动对 OCX 注册。这也就是 CAB 的作用。

    手动注册 OCX

    我们假设，OCX 所在的目录是：D:/ocx/xpbutton/xpbutton.ocx
 

    
     通过 regsvr32 xpbutton.ocx ，这样我们就手动注册了 OCX。
     如果想卸载 OCX，我们可以反注册：regsvr32 /u xpbutton.ocx 。
     注册和卸载，我们都需要以管理员身份运行 cmd 控制台。-- 这里特别需要注意！
     如果在注册时候出现下面的错误：
 

    
     1.首先查看是否以管理员身份运行 CMD。
     2.如果还是不行，可以考虑将相应的 OCX 放到系统目录下     
          a). 32 位系统放到 C:\Windows\System32
          b). 64 位系统放到 C:\Windows\SysWOW64
     3.如果还是报错，那可以确定是缺少 DLL 导致的。各位可以下载一个工具：Dependency Walker。
    看这里的教程，看少了哪些 DLL，去网上下载这些 DLL，这些 DLL 就是你必须要和 OCX 一起打包到 CAB
 压缩包里面去的。因为你自己电脑少了，说明客户电脑也同样可能会少这些 DLL。
     这里需要注意的是：首选的是和你系统相同位数的 DLL，肯定不会错，实在找不到 64 位的，才考虑 32 位的版本。
     下载了 DLL 后，将 DLL 存放到上面第二步提到的系统文件夹下面，然后再注册。

     OCX 打包 CAB

     首先下载 OCX 打包签名工具：ocx 打包签名工具，  访问密码 ddb4。





     将需要签名和打包的 OCX 和命令放到相同文件夹。



     制作签名证书：

          在命令行运行下面命令：
         1. 执行命令： makecert.exe -ss xpbutton -n "CN=这里随便" -sv .\xpbutton.pvk -r .\xpbutton.cer



 

        输入三次，密码，查看控制台出现 Succeeded 表示成功。
 


        此时生成文件：xpbutton.cert 和 xpbutton.pvk
 



         2. 运行命令： Cert2Spc.exe .\xpbutton.cer .\xpbutton.spc

          查看控制台，出现 Succeeded 表示成功。
 


         此时会生成文件：xpbutton.spc 



         两条命令结束，我们一共得到三个文件：xpbutton.cer、xpbutton.pvk、xpbutton.spc
 

     对 OCX 进行签名

          打包 CAB 之前，首先需要对 OCX 本身进行签名操作，这一步很重要，如果没做，你可能就犯错了。
          3. 运行命令：signtool signwizard






































        如果想要填写时间戳，可以填写以下地址：http://timestamp.verisign.com/scripts/timstamp.dll





        等待片刻，出现下面提示，则表示对 ocx 签名完成。


        控制台出现：Successfully completed signing wizard:<> 表示成功。



      编写 INF 文件
          INF 文件也是一个重点，如果编写错误，则不能正确打包。（各位可以下载本人编写的 INF 文件，在此基础上进行修改，保证 INF 文件的正确性）
          INF 参考文件下载地址：OCX inf 文件,  访问密码 49de。
       如果打包 CAB 没有问题 ocx 、dll 都会下载到 c:/windows/ocx/ 目录下，方便各位卸载 ocx ，删除 dll 文件。



[version]
signature="$CHICAGO$"
AdvancedINF=2.0

[DefaultInstall]
CopyFiles=files
RegisterOCXs=RegisterFiles

[DefaultUninstall]
cleanup=1
Delfiles=files
UnRegisterOCXs=RegisterFiles

[SourceDisksNames]
1 = %DiskName%, "xpbutton.cab", 1

[SourceDisksFiles]
xpbutton.ocx=1
msvcrtd.dll=1
mfc42d.dll=1
mfco42d.dll=1

[RegisterFiles]
%30%\Windows\ocx\xpbutton.ocx

[DestinationDirs]
files=30, Windows\ocx

[files]
xpbutton.ocx=xpbutton.ocx
msvcrtd.dll=msvcrtd.dll
mfc42d.dll=mfc42d.dll
mfco42d.dll=mfco42d.dll

[xpbutton.ocx]
file=thiscab
clsid={134EE1CC-4B8A-4E74-8C41-F4990065E2E1}
FileVersion=1,0,0,1
RegisterServer=yes

[msvcrtd.dll]
file=thiscab
FileVersion=6.0.8337.0

[mfc42d.dll]
file=thiscab
FileVersion=6.0.8168.0

[mcfo42d.dll]
file=thiscab
FileVersion=6.0.8267.0

[Strings]
DiskName="Windows\ocx"


        以上是本人的 inf 文件。解释几个部分。
           1.这里面添加了 3 个dll，如果各位不需要将 dll 打包到 cab ，则可以参照上面蓝色的部分。如果没有 mcfo42d.dll 则将蓝色的部分全部删除，其余的不动。以此类推。
           2.[xpbutton.ocx]
file=thiscab
clsid={134EE1CC-4B8A-4E74-8C41-F4990065E2E1}
FileVersion=1,0,0,1
RegisterServer=yes 
          进行简单解释：
              file=thiscab 照搬照抄，不解释。由于是 64 位系统，本人测试这么写没问题。
              32 位系统也可以这样写： file-win32-x86=thiscab 
              clsid 这里，最简单的办法是找到 ocx 的来源，询问制作 ocx 作者，他们知道这里应该填写什么。
              如果找不到制作人，也有办法，参照前文手动注册 ocx ，然后查看搜索注册表：xpbutton





           找到左边类似的注册表结构，然后 134EE1CC-4B8A-4E74-8C41-F4990065E2E1 将是我们需要的 clsid 了。
           注意：本人在 C:\Windows\ocx\ 目录下注册的 xpbutton.ocx 文件。所以上面右图地址才会是 C:\Windows\ocx\xpbutton.ocx 
           FileVersion 也是一样，最好的办法，找到 ocx 的来源(开发者)，确定版本号，编写 ocx 时，代码中会有 ocx 对应的版本号。当初和 C 沟通时，看过 ocx 的 C++ 代码，里面有对应的版本信息。这里的版本信息必须和 OCX 的版本信息一致。
RegisterServer=yes 表示下载下来后自动注册此 ocx 。
           大家可以看到我下面的 dll 文件的代码中都没有这一句，意思是 dll 下载下来后不需要注册，如果各位的 dll 也需要注册，对应 dll 区域也需要添加此语句。
          3.对 INF 文件中绿色的部分进行解释
          绿色的部分，表示 dll 的版本号，如何确定 dll 版本号。其实很简单。
          找到对应的 dll 右击，查看属性，这里的文件版本，就是我们需要的版本号，请注意，不是产品版本。 




     OCX 打包 CAB 文件

          4.运行命令：CABARC.EXE -s 6144 n xpbutton.cab xpbutton.ocx xpbutton.inf
          需要解释一下这条命令：是将 xpbutton.ocx xpbutton.inf 文件打包成 xpbutton.cab 文件，如果我们需要将额外的 dll 也打包到 cab 里面，那这样写：CABARC.EXE -s 6144 n xpbutton.cab xpbutton.ocx msvcrtd.dll xpbutton.inf 以此类推。

      对 CAB 文件签名
         对 CAB 文件签名的过程，可以查看上文对 OCX 文件签名的过程，除了第一步此处选择的是 CAB 文件之外。其余步骤完全相同。






    到目前为止，我们已经将 OCX 打包成 CAB ，但是到现在还不行。很多教程都到此为止，其实 OCX 的繁琐远还没有结束。


    JS 调用 OCX（CAB）


     引入 OCX 控件

          新建一个 HTML 文件，我们通过如下方式引入 OCX：


         一项一项解释：
         id="xpButton" 表示此 object 对象的 id 为 xpButton，命名随便都可以，后续会用到。
         classid="clsid:134EE1CC-4B8A-4E74-8C41-F4990065E2E1" 看到这个，应该很熟悉。classid="clsid:这部分照抄，不要改动。只改动冒号 : 后面部分就行了。（本人不小心把 clsid: 这一部分漏掉了，写成了 classid="134EE1CC-4B8A-4E74-8C41-F4990065E2E1"，结果 CAB 文件下载不下来）。注意：千万别漏了 clsid。
         codebase="./xpbutton.cab#version=1,0,0,1" 这一部分代码是告诉浏览器，如果找不到 clsid 为 134EE1CC-4B8A-4E74-8C41-F4990065E2E1 注册表，也就是系统中没有注册过此 xpbutton.ocx ，则去找对应的 xpbutton.cab 文件。这里 "./xpbutton.cab" 意思是和当前 html 存放在同一目录下的
 xpbutton.cab 文件。“./”表示当前路径，也就是 html 所在的路径。后面的 "#version=1,0,0,1" 表示当前 OCX 的版本号，也就是 CAB 压缩包中 INF 文件里面写的 OCX 的版本号（FileVersion）。注意版本号：1,0,0,1 是用逗号 "," 分隔，不是点号 "." ，如果你用了点号 "."，那么恭喜你，你又错了。 
         补充说明：我们遇到过三个版本号
                              1. OCX 编写时，C++ 代码中规定了 OCX 的版本号。
                              2. OCX 打包 CAB 文件时，INF 文件中规定了当前 OCX 的版本号。
                              3. HTML 调用 OCX 时，CODEBASE 表明了需要调用的 OCX 版本号。
          这三个版本号需要一致。
          很有意思的是，如果想要升级 OCX，其实很简单，让 OCX 编写人员升级 OCX，然后我们升级 INF 文件中的版本号，再把相应 HTML 中的版本号也升级。浏览器调用此 HTML 时候，如果发现 CODEBASE 中的版本号升级了，则会自动重新下载 CAB 文件，并重新注册。
          之前，为了测试 OCX 升级后是否本身有问题，手动注册此 OCX ，没有重新打包 CAB，结果每次访问都发现注册的是 CAB 中上一个版本的 OCX。说明只要发现注册过的 OCX 版本和 CAB 版本不一致的情况下，浏览器都会重新下载 CAB，并重新注册。
             这里还要说明一点就是，OCX 被编写出来后。clsid 就固定了。此 OCX 不管注册到哪台电脑上，查看注册表，clsid 都是一样的，不会改变。这也就是为什么我们在 HTML 里面，直接可以写上 clsid 的原因。因为客户下载 CAB ，自动注册后，OCX 的 clsid 就是我们编写 C++ 时候规定的 clsid。


         JS 调用 OCX 方法


          解释以上代码
          1. xpButton.AboutBox() ;
                    xpButton 其实不是凭空出现的，这里的 xpButton 是 <object> 标签的 id，大家看上面的截图可以看到，<object id="xpButton">……</object>。
          2. xpButton.AboutBox() ;
                    AboutBox() 其实是 OCX 中的一个方法。各位如果想要知道此 OCX 中有哪些方法，首选的是找 OCX 开发者，在找不到的情况下，通过 tstcon32 软件，各位可以在这里下载： tstcon32 ActiveX 容器   访问密码 904d。如果不能使用，根据报错提示下载相应
 DLL 即可。（研究 OCX 留下的后遗症，总觉得某些软件会缺少 DLL ）
          3. 为什么要 try catch
                    OCX 的繁琐和摸不着头脑，很重要的原因是，即使调用失败它也不会报错。所以，我们必须要在这里 try catch 手动弹出错误信息。但问题其实也没有那么简单，即使是有报错信息，提示也让人摸不到头脑。
                    注意，各位一定要记得 try catch，不然任何错误都不会有提示。
                    下面总结一下本人遇到的报错信息与真实原因的对应关系，以防止各位各种百度、Google 最后找到的是错误的解决方案。
                    OCX 报错，一般情况下，都是本机测试通过后，部署到服务器或者使用其他人的电脑，发现调用失败。
                    1. [object Error]、Error:找不到成员



                    如果是遇到上面的报错：[object Error] 、Error:找不到成员
                    1.首先确定 C:\Windows\ocx 目录下是否有下载的 OCX 文件（如果各位下载了本教程中的 INF 文件，则到C:\Windows\ocx 目录下去找），如果该目录下没有任何文件或者没有该目录，则就对照上文，查看是否是 INF 文件编写有问题，或者是 HTML 引入 OCX 对象有错误，导致下载失败。
                    2.如果 OCX 文件已下载，则表示虽然 CAB 文件没问题，但 OCX 未注册或者说是注册失败。注册失败的原因，我们首先需要确认是否是缺少 DLL 。如何确认，可以使用上文提到的 Dependency Walker 软件。如果发现确实是少了 DLL，那我们应该重新打包 CAB，将所缺少的 DLL 文件一起打包到 CAB 中。很多时候，我们通过 CAB 自动注册 OCX
 ，大多数情况下是不会报任何的错误的。即使是因为缺少 DLL 没有注册成功，也没有任何提示。本人在很多电脑上测试的结果是，只有一台 Win7，出现了缺少 DLL 的报错示，其他所有电脑都没有任何的错误提示。这里特别需要注意：打包 CAB 文件后，请用多台电脑进行测试，最好测试不同的系统，也尽量可以挑选公司非开发人员的电脑。千万别在自己电脑上测试通过，或者某些 OCX 开发者电脑上测试通过后便认为其没有问题。


                    2. 对象不支持此属性或方法
                    这个错误，在开发的过程中，是必然会遇到的。刚开始，一直以为是调用方式有问题，在尝试了网上能找到的所有其他不同调用方式后发现，并非如此。如果能保证 OCX 的正确性的前提下，此问题的根本原因是因为浏览器对于 OCX 不信任，拦截了 OCX 里面的方法调用。解决此问题的根本办法是修改浏览器设置。 



                         3.修改浏览器安全设置
                     网上可以找到很多浏览器的修改点，其实大部分不需要修改，修改了反而降低了安全性，增加风险。



                         反选“对该区域中的所有站点要求服务器验证(https)”，填上服务器地址，例如：http://192.168.0.61 然后添加，添加完成后，再次勾选"对该区域中的所有站点要求服务器验证(https)"。这一步的操作是保证浏览器信任此站点。






                         此处修改信任站点的安全性级别，将图上的两个，由原来的禁止，修改为提示或者启用。
                         其实在首次访问 CAB 网页前，我们就应该先修改浏览器安全性策略，修改完成后再访问，一般都不会出现什么问题。


        至此，OCX 的相关知识已经全部介绍完毕，此教程应该可以帮助大家少走一些弯路。这也是最近两个星期的研究成果。



        2015.08.26 补充
       1.注意：如果使用了 Java 开发，后台使用了 Spring。则应该在 Web.xml 中添加下面的代码。
  <servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>*.cab</url-pattern>
  </servlet-mapping> 
       上面代码告诉 Spring 不要拦截 *.cab 静态文件。

        2.JSP 引入 CAB 文件
 <div style="display:none;">
 		<object id="readcardOCX" width=400 height=100
                classid="clsid:F6F2B22E-FC89-489F-967B-9676EB269F55"
                 CODEBASE= "${pageContext.request.contextPath}/cab/readcard.cab#version=1,0,0,1"
                ></object>
 </div>
        在工程中引入 CAB 文件，我们需要写 CODEBASE= "${pageContext.request.contextPath}/cab/readcard.cab#version=1,0,0,1"        ${pageContext.request.contextPath} 表示工程名
       cab 文件存放在 webapp/cab 下面





















版权声明：本文为博主原创文章，未经博主允许不得转载。

Linux网络编程--字节序

1 .谈到字节序，那么会有朋友问什么是字节序 
很简单：【例如一个16位的整数，由2个字节组成，8位为一字节，有的系统会将高字节放在内存低的地址上，有的则将低字节放在内存高的地址上，所以存在字节序的问题。】

2 .那么什么是高字节、低字节？ 
也相当简单：【一个16进制整数有两个字节组成，例如：0xA9。 
高字节就是指16进制数的前8位（权重高的8位），如上例中的A。 
低字节就是指16进制数的后8位（权重低的8位），如上例中的9。】 
大于一个字节的变量类型一般有两种表示方法： 
 
例如：变量0xabcd在大端字节序和小端字节型系统中表示方法如图 
 
我们用代码验证一下我们自己的系统是小端还是大端吧 

#include <stdio.h>

/* 联合类型的变量类型，用于测试字节序
*   成员value的高低端字节可以由成员type按字节访问
 */
typedef union{
    unsigned short int value;                               /*短整型变量*/
    unsigned char byte[2];                              /*字符类型*/
}to;

int main(int argc, char *argv)
{   
    to typeorder ;                                      /*一个to类型变量*/
    typeorder.value = 0xabcd;                               /* 将typeorder变量赋值为0xabcd */

    /* 小端字节序检查 */
    if(typeorder.byte[0] == 0xcd && typeorder.byte[1]==0xab){       /*低字节在前*/
        printf("Low endian byte order"
                "byte[0]:0x%x,byte[1]:0x%x\n",
                typeorder.byte[0],
                typeorder.byte[1]); 
    }

    /* 大端字节序检查 */
    if(typeorder.byte[0] == 0xab && typeorder.byte[1]==0xcd){       /*高字节在前*/
        printf("High endian byte order"
                "byte[0]:0x%x,byte[1]:0x%x\n",
                typeorder.byte[0],
                typeorder.byte[1]); 
    }

    return 0;   
}

3 .字节序转换函数介绍 

字节序转换函数的使用：
#include <stdio.h>

/* 联合类型的变量类型，用于测试字节序
*   成员value的高低端字节可以由成员type按字节访问
 */
/* 16位 */
typedef union{
    unsigned short int value;
    unsigned char byte[2];  
}to16;
/* 32位 */
typedef union{
    unsigned long int value;
    unsigned char byte[4];  
}to32;

#define BITS16 16   /*16位*/
#define BITS32 32   /*32位*/
/* 按照字节打印，begin为字节开始，
*  flag为BITS16表示16位，
*  flag为BITS32表示32位， 
*/
void showvalue(unsigned char *begin, int flag)
{
    int num = 0, i = 0;
    if(flag == BITS16){
        num = 2;    
    }else if(flag == BITS32){
        num = 4;    
    }

    for(i = 0; i< num; i++)
    {
        printf("%x ",*(begin+i));   
    }
    printf("\n");
}

int main(int argc, char *argv)
{   
    to16 v16_orig, v16_turn1,v16_turn2; /*一个to16类型变量*/
    to32 v32_orig, v32_turn1,v32_turn2; /*一个to32类型变量*/


    v16_orig.value = 0xabcd;        /* 赋值为0xabcd */
    v16_turn1.value = htons(v16_orig.value);/*第一次转换*/
    v16_turn2.value = ntohs(v16_turn1.value);/*第二次转换*/

    v32_orig.value = 0x12345678;    /* 赋值为0x12345678 */
    v32_turn1.value = htonl(v32_orig.value);/*第一次转换*/
    v32_turn2.value = ntohl(v32_turn1.value);/*第二次转换*/

    /* 打印结果 */
    printf("16 host to network byte order change:\n");  
    printf("\torig:\t");showvalue(v16_orig.byte, BITS16);   /* 16位数值的原始值 */
    printf("\t1 times:");showvalue(v16_turn1.byte, BITS16); /* 16位数值的第一次转换后的值 */
    printf("\t2 times:");showvalue(v16_turn2.byte, BITS16); /* 16位数值的第二次转换后的值 */

    printf("32 host to network byte order change:\n");
    printf("\torig:\t");showvalue(v32_orig.byte, BITS32);   /* 32位数值的原始值 */
    printf("\t1 times:");showvalue(v32_turn1.byte, BITS32); /* 32位数值的第一次转换后的值 */
    printf("\t2 times:");showvalue(v32_turn2.byte, BITS32); /* 32位数值的第二次转换后的值 */


    return 0;   
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        2010到2015，我的6年投资理财经验总结和反思
 2010到2015，我的6年投资理财经验总结和反思0.理财意识和观念2010年，还在读大学。从大二开始，很少去网吧了，其它方面开支也不多。考虑到，未来想搞点什么事情，必须得积累一点资本。很早就意识到，经商做事都是需要资本积累的，对于平民阶层，原始资本积累是个漫长的过程。资本主义也好、资产阶级也好，有钱、有资源，不用从事具体的生产劳动就可以赚钱。相对于那些从事苦逼生产劳动的劳苦大众来说，虽然很不公平，但这就是很难改变的社会法则。总想着有一天，自己也可以富裕起来，不是为了买车买房，而是有钱才更有底气，可以自由潇洒地过日子，不用总是在担心，一年忙活到头，那日子鄙人确实不能接受额。1.银行与定期存款2010年的时候，当时攒了2000元左右的钱，想把它存起来。想来想去，真心没有很好的理财渠道，最终选择了银行定期存款。去银行开户，办理网银，当时选择的是“工商银行”，在学校（武汉科技大学-黄家湖校区）附近的“白沙洲大道-张家湾”。感觉好厉害，还记得是在附近的张家湾。单单是来回公交路费，就花了4元，还花了一上午的坐车排队时间，算算定期1年的收益，3.5%*2000=70元。认真计较一下，但从收益和付出来讲，感觉划不来哦。但是，也有好的地方，一是现金存到银行了，不用担心被偷。二是，定期存款，不会随便取出来，给自己一点“风险准备金”，万一哪天急用钱，还有救兵，总不至于饿死或露宿街头。三是，养成理财意识，从小钱做起。很多人觉得自己钱少，没有必要理财，这真是一种很有道理也很错误的思维。钱少，理财收益会很小，还要花心思去打理，确实让人不爽。错误的地方在于，越是穷人，越是应该“让钱生钱”，不能总是靠苦力劳动获得财富吧，稍微用点心思，一个雪糕、一瓶冰冻绿茶、一顿饭、一个手机、一台电脑的钱就到手了。你不信，反正我是信了，我目前的理财收益，可以买3台电脑。2.股市和股票基金上面也说了，我逐步有了打理钱财的意识。尤其是2010年，在看了“富爸爸”等不少财经理财类的图书后，我更觉得有必要让自己的“财商”牛逼起来。千里之行始于足下。2011年，尝试性地买了股票型基金。手上钱太少了，就把银行定期存款提前赎回了。这时就看出银行定期存款不好的地方了，提前赎回，利息非常少，完全当作活期算，真是坑爹啊，银行就是这么霸道。基金，当时是通过工商银行购买的，申购费率1.5%，赎回费率0.6%。一分钱没赚到，申购费用就花了不少。出于大胆考虑，买的是股票型基金-华夏优势增长和混合型基金-华夏混合成长。之前看了很多专家的分析，认为“股市总体是上涨的，定期买入，即传说中的‘定期理财’”，就每个月买入一定量的份额，这种方式要求长期坚持买入。在现在看来，我真得非常不认可这种做法，感觉太TMD坑爹了。这种理财方式，资金利用率很低，中国股市整体非常坑，08年之后尽是跌。经济增长很快，股市大跌，经济增长很慢，仍然大跌。中国股市就是一个完全的政策市，内幕交易等不合理现象大量存在。也没有多少“投资者”，“投机者”居多。在后来的实践当中，股市大跌的时候，我通常会“买入”，实际合适的时候，我也会选择“卖出”。在2011~2013年，最高投资达到2万（也可能是4万，记不清了），亏损最高的时候是5000元。我初次买入的时候是2011年3000点，毕业工作后，主要是发现股市涨跌比较影响我的心情，同时也没有发现，买股票型基金可以赚钱，就逐步赎回了自己所有的资金。最后算账，账面上基本保本，同比银行定期存款，实际是亏损的，通货膨胀这么严重，意味着大哥我的身价缩水了，还指望着有一天能和小马哥比一比了，这都亏成马了。2012年，我有一个判断，认为“习近平上台，会有一番新景象，股市应该会大涨”。结果，上台后的2012年，印象中就一次涨的比较多，然后又跌回去了，搞毛啊，死心了，就撤了。谁曾想到2014年底~2015年上半年，传说中的“改革牛”这么牛气，错过了，多少有点可惜，要不然大哥我的身价早就翻倍了。呵呵哒，你真以为能翻倍呢，作为一个理智的人，根本就不应该把所有的资金投入到中国这个“政策市”，除非你吃了“豹子胆”。股市的风险极大，你怎么知道什么时候，形势会“急转直下”呢。2015年，有10多天的时间，手头上有点闲钱，看着股市这么涨，就临时买了点，短期持有。第1次买入N元，随后大涨，随后大跌，再次买入N元，最后退出的时候，赚了100元。如果第2次不买入，会赚的更多。从最后结果来看，第2次买入的，是亏损不少的。哥机智啊，在哥全部赎回后，7月份股市连续暴跌，要不亏成马了。想起来，就有点后怕，赎回完全是因为要用钱，而不是预料到股市这么快会连续暴跌这么多。下尿了，再也不玩股票和股票基金了，除非哪天有闲钱同时心里又痒痒了，好了伤疤忘了疼，大家都这样。哦，对了，我还没有伤疤哦，差一点就有了。囧啊~15年买股票，还有另外一个出发点，是为了体验京东金融的服务。11年，是在银行买，也可以在基金官网买，手续费会低一些，京东上买的时候，有活动，免手续费，同时买入M元送N元现金。不免手续费就赚不到100元了，不亏就不错了。总的来说，第1阶段和第2阶段买股票型基金，账面回报都是保本，而且事后让人心惊胆寒。还玩个蛋啊。撤，撤，撤。3.余额宝，活宝啊13年，余额宝牛逼了，快速扩张了大半年，中央和银行没有干它。于是我从最初的“怀疑”到后面的“重仓”。怀疑是有的，银行定期存款利率还没有余额宝高，余额宝虽说是理财产品，但由于是“随存随取”，在老百姓看来，不就相当于活期么。从小规模尝试到重仓，到资金不断进出，最终余额宝收益是2000多元，够买一个不错的手机了。后来逐步理解了，余额宝就是货币型基金，主要用于银行同业拆借，以及短期债券，风险比较小。随后，百度百发等众多理财产品问世，让人应接不暇，处于支付宝的方便性，以及其它“活期类”理财产品收益没啥优势，就一直在搞余额宝了。4.P2P网贷14年回武汉找工作，加上13年和14年互联网金融概念的火爆，就注意到了P2P网贷。感觉这个行业很有价值，实现资金匹配，牛逼，就加入了一个P2P公司，同时投入了不少钱。P2P的利率完全碾压宝宝类，但是风险也大很多，跑路诈骗的P2P平台都成堆了。我还专门加入一个P2P跑路维权群，看着投资者在忙活，真心无奈额。从15年的视角来看，优质的P2P平台是少数，大部分平台没有很大的创新，完全就是把线下放贷搬到线上来嘛。呵呵哒。截至目前，P2P累计为我军创造了5位数的收益，把2台电脑的钱挣回来了。嘿嘿~5.股权众筹最近写过好几篇关于股权众筹的文章，写得很详细了，有兴趣的朋友可以去看看。股权众筹，风险较大，谨慎尝试。6.活期理财随着余额宝等宝宝类产品和P2P网贷的进一步发展和变种，目前有了不少“理财计划”类的理财产品，不少P2P网贷平台可以直接买理财，本质还是放贷债权，还有一些专注理财产品的产品，比如金蛋理财之类的。随存随取，收益率比余额宝高，因此，最近放了点钱进去，如果合适，今后较大的活期钱就放到金蛋理财算了。7.其它京东上买东西，可以用白条，一个月内免息，可以节省不少钱。同样的一笔钱，存到余额宝或者投入到P2P，是可以赚一点的。为此，想尝试性地办理信用卡，去了招商，搞了2次，都没给批。MD，优质客户都看不出来，招行坑爹货啊。京东上的“小金库”和余额宝基本是一种，还有其它的“妈妈理财”之类的，差不多。还曾想过，可以从银行办理贷款，然后投钱到P2P平台，赚利差，网上查过，还真有人这么干。风险点：P2P平台跑路，资金借款还款周期没有处理好难点：网上查询银行贷款流程，太麻烦了，各种资料，搞个信用卡都不给批，借款就算了吧，最后没能成型。美好的心愿，就这么破产了，还是老实做人，过日子吧~8.写在最后以上是我6年的投资理财经验，算是我的N多次尝试，目前没有账面亏损的投资，还是不错的。投资总是有风险的，股市暴跌、平台跑路、借款人不还钱的情况是可能发生的。下一篇计划写“我的投资理财策略”，根据我的经验和现状，说说我的投资理财策略。有兴趣，电话-微信-QQ联系。   小雷FansUnion   QQ：240370818   微信：FansUnion   湖北-武汉-循礼门   2015年8月21日

版权声明：本文为博主原创文章，未经博主允许不得转载。

良心干货｜如何惊呆你的面试官
原文出处： Medium   译文出处：Nextoffer   欢迎分享原创到伯乐头条最能揭示潜力的两项特质。根据几年前流传的一则故事，Google曾将它的Lvl.99数据处理技术应用于面试和业务评价过程，目的是要试着回答一个问题：面试中显示出的哪些特质最能预示其在公司里的成功。对处于事业初期的人事经理来说，答案结果是看一个人讨不讨人喜欢。（宝宝们，如果觉得这不准确或者对这故事有什么要补充的，请尽管喷我。）我不了解Google在这项调查中是否关注面试的其他作用，但凭借多年招聘以及同职场新人共事的经验，我知道我的答案会是什么，并且答案很简单。Are you self-aware, and are you proactive? 你是否有自（zi）我(zhi)意(zhi)识(ming)，是否有前瞻性？哦，当然了，工作能力强的都很引人注意。在交谈中发表一些有思想的见解会让人印象深刻。但如果你刚刚起步，通常人们会认为你还在培养自己的技能。如果你从事设计这一行的时间还不长，那你的作品可能还达不到尽善尽美的水准，或者之前你还从未考虑过产品和市场的贴合度问题。但这都不要紧，有一个问题比这些都重要得多：在学习能力方面，你的潜能如何？如今我共事的一些最出色的设计师，他们在面试的时候并不是技能最高的，但他们有潜力。他们会提问题，会把自己置于一种需要不断拉伸自己的环境中，并且他们会把这设为自己的目标，让自己变得更好。自我意识和前瞻性是一枚硬币的两面。如果你有自我意识，你就会知道自己擅长什么、不擅长什么。如果有你有前瞻性，你就会对此有所行动。 哦，天哪，我是一只盒子里。How do you become more self-aware and proactive?如何让自己变得更有自我意识和前瞻性？这个问题的答案可谓汗牛充栋，从林中冥想到记日记，从列清单到锻炼回旋肌，还有更经常地举手提问等等。为避免泛泛而谈，我将分享一套按部就班的方式，我把它叫作“需要计划时就做这个”计划。我过去从中获益匪浅，希望它也能帮到你。1. 打开一个新的写作窗口（或者如果你是老派写手，就用一支笔和一个Moleskine的笔记本）2. 记下3-5件你拿手的事情。然后再写3-5件你不怎么擅长、但想提高的事。3. 确保你的清单是准确的。问一问经理、老师、导师或是朋友，问他们眼中你最大的优点以及需要改善的地方有哪些。如果他们的回答跟你清单所列的完全不一致，不要灰心，再去问问你信任的其他人，直到与清单上所列的相吻合。4. 关注你的优点。当你读到每一项优点时，点点头并且在意识里牢牢抓住它。这些就是你的超能力。是的，它们是属于你的，看到适当时机就去应用它。想想过去你靠这些优点完成的那些出色的事情，例如你做的那件让每个人都觉得很厉害的事，或者你让一群人在某件事上达成一致的办法，想想下个月你能在哪3件事上发挥你的优点。它们不一定非得是什么大事，但是要具体，这样你可以把它们从清单里划掉。这些事会让你高兴，因为你能把它们做得很好。把你的优势清单贴在你天天都可以看到的明显位置（比如镜子上），因为这些事很棒，你很棒。5. 现在转向你的自我完善清单。对照清单上的每一项，想象自己三年内希望到达哪个程度。闭上眼睛然后真正展开想象，就像是看一段有关未来的你的录像。有没有一位拥有这项技能、让你敬佩、想要模仿的人？你会如何开展你的工作？从现在开始的三年里你会改变哪些事情的做法？未来的你给你什么感觉？你越清晰地看到这些，实现它们就越容易。6. 通过头脑风暴，想出3件自己下个月能做的事，让自己离自己的理想迈进一步。同样地，这里不需要很疯狂或雄心勃勃的计划，只要朝你的目标近一点就可以。例如每周请你的团队成员坐下来帮助你提高X。或者是每天花20分钟练习Y。如果你在制定计划方面遇到障碍，可以考虑和你信任的人坐下来一起完成。从我的经验来看，他们通常很乐意帮忙。7. 坚持你的计划。尽管去做，不过是用一个月时间做6件小事而已，没什么大不了。做一个核对清单，然后体会一下完成后将它们划去的满足感吧。8. 需要时进行重复。如果照着上面的办法做，你就会有所进步。就是这么简单。参加应聘某个职位的面试时，你就说出你的优点。描绘一下你的优点能帮你解决的哪类问题的场景。如果有面试官很明显会注意到的方面，你也可以谈一些你需要改善的方面。例如在分享过去一个项目的时候，不要试着去掩盖那些你不怎么感到自豪的方面。说出你不满意的地方，以及下次你做会有何不同。那些知道自己可以给团队带来什么、并且明白自己希望在哪些方面有所提高的求职者，是我想要共事的那一类人。今天你拥有哪些技能并不那么重要，只要你能很明显地表现出，你是个以后会拥有那些技能的人就行。弄清你所擅长以及不擅长的地方，然后行动起来吧。 本文借鉴：http://blog.jobbole.com/89865/

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

Failed to install metadata  only whitespace content allowed before start tag and not \u0
突然蓝屏，然后重启发现这个玩意已经不行了，编译就出这玩意，什么鬼
后面直接删了.m2目录下相关的：maven-metadata-local.xml 

版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode】SingleNumberII_137
package com.leetCode;

/**
 * Given an array of integers, every element appears three times except for one.
 * Find that single one.
 * 
 * Note: Your algorithm should have a linear runtime complexity. Could you
 * implement it without using extra memory?
 * 
 * @author Zealot
 * @date 2015年7月25日 下午6:16:12
 */
public class SingleNumberII_137 {
	public int singleNumber(int[] nums) {
		int ones = 0, twos = 0;
	    for(int i = 0; i < nums.length; i++){
	        ones = (ones ^ nums[i]) & ~twos;
	        twos = (twos ^ nums[i]) & ~ones;
	    }
	    return ones;
	}
	//遍历数组中每一个元素
	//计算每一个元素中，2进制中每一位加到一个总的数组里边，都加到一起之后，再与3取余，因为除了一个之外，都是出现了3次，只有那一个之出现了不到3次
	//最后数组转成数字
	public int singleNumber2(int[] A) {
        if(A == null || A.length == 0) return 0;
        int[] a = new int[32];
        for(int i = 0; i < A.length; i++) {
            for(int j = 0; j < 32; j++) {
                if((A[i] & (1 << j)) != 0)
                    a[j] = (a[j] + 1) % 3;
            }
        }
        int result = 0;
        for(int i = 0; i < 32; i++) {
            if(a[i] > 0)
                result |= (a[i] << i);
        }
        return result;
    }
	public static void main(String[] args) {
		SingleNumberII_137 s = new SingleNumberII_137();
		int[] nums = {1,2,3,3,3,2,5,2,1,1};
		System.out.println(s.singleNumber2(nums));
//		System.out.println(77>>1);
//		System.out.println(4>>1);
//		System.out.println(Integer.toBinaryString(4).length());
//		System.out.println("123456".length());
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

十年WEB技术发展历程
Ajax03年的时候我上六年级，那时候网吧刚在小县城的角落萌生。传奇，大话西游第一代网游一时风靡。我抱着试一试的心态给了网吧老板两块钱想申请个号玩玩，然后接下来的一个小时我一直在，注，册，账，号。彼时网吧用的512k的带宽，注册的时候，填了一堆信息，提交，页面跳转，嘣，”您填写的信息有误，请重填”。然后跳转回注册页面，以此循环。我现在时常想，如果当时ajax能普及开来，我就可以省2块钱了。那么ajax是什么?首先ajax是一种技术。以往的网页交互方式，用户在点击一个按钮后，比如提交按钮，用户就要等待漫长的数据和服务器的交互，期间用户无法进行任何操作，只能点根烟。而ajax所做的，就是在向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果我们可以再来处理这个事。其实ajax技术早在1998年的时候就已经由微软实现了，然而直到2005年2月，Adaptive Path公司的Jesse James Garrett发表文章"Ajax: A New Approach to Web Applications"，人们读了后觉得哎哟不错哦这个屌，这之后ajax才大规模普及开来。ajax的出现，极大了提高了web的用户体验。时至今日，即使国内IT发展再怎么落后，所有网站的登录注册也已经实现了ajax交互。用户点填写完信息后，页面不用刷新就可以知道信息提交成功与否，哪错改哪。另外ajax作为一种前后端分离的解决方案，也已经被国内大多数不很low的公司所采用，也间接导致了php等网页脚本语言的衰落。jQuery早年的js编程，代码的效率是极其低下的，这点尤其体现在操作dom上，开发者想要给一个按钮添加事件，要写长长一大段重复的代码去获取到这个按钮，再写长长一大段重复的代码去添加事件。尽管老油条会将常用的操作封装起来，但是对于不会封装的新手，这无疑是很痛苦的一件事，尤其再加上各种各样的兼容。2006年，本着拯救菜鸟，让他们do more的宗旨，jquery诞生。jQuery诞生的意义，一是对ie6 7 8 及各种割据一方的浏览器做好了兼容，二是极大简化了dom操作，使开发效率大大提升。jquery很火爆，火爆的有些前端只会写jquery而不会写原生js的程度。时至今日，说jquery write once，see everywhere已经不为过了。jquery的另一个意义（我认为）在于，它催化了人们对前端的兴趣与探索，相比linux，你用很低的成本，就可以写出一个让不懂编程的妹子说欧巴你碉堡了的效果，让人们觉得哎哟（又）不错哦这个屌。此后大量的类库和基于jquey的插件雨后春笋般诞生，前端行业歌舞升平欣欣向荣，网页开发进入一个新时代。Chrome天下武功出谷歌。在ie6,7,8的时代里面，尽管Firefox也缓慢的挑战ie的地位。但和2009年开始Google开始推广的chrome浏览器产生的颠覆性影响比起来，逊色很多。Chrome使用Apple的开源内核webkit，良好的设计标准和市场反应；促进浏览器快速迭代，让IE在windows10中彻底消失。chrome浏览器的推出，将简化前端的入门程度又推进了一步，其自带的调试工具好用又无脑，我们可以利用其轻松的查看网络状态，加载顺序，进行断点调试等，同时谷歌的插件功能，又给开发者提供了极大便利。目前chrome最新版开始采用blink内核，测试版本中，已经可以对css3动画进行追踪和调试。在我还没有想象到的时候，chrome已经实现了它。一句话，没有chrome，就没有新中国，就只能用firefox了。GitHub随着软件项目的迭代加快，项目版本工具也不断的演进，经历CVS, SVN,GIT。到目前为止CVS差不多已经从互联网行业慢慢消失，SVN作为文件和文档存储存在，由linux内核发明人Linus创建的版本工具GIT现在作为代码版本标准。Github依赖于git成为开发人员团队协作的社区！到2015年1月github上已注册的开发人员超过一千万，开源项目几千万。其中2014中国研发者在github上增长最快。你几乎可以在上面找到一切你想要的代码…比如username..password..OAUTHOAuth1或OAuth2与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码）。 产生背景：最常见的服务场景，用户需要使用两个不同企业的服务，登录验证A企业，下载内容；然后登录验证B企业，上传内容到B企业服务，复杂又耗时。无论是用户，还是A、B都会想要互通服务。这就产生了核实身份的需求。旧的用户名、密码机制会造成A/B企业有权限查看甚至修改对方的用户资源。为了达到确认身份、服务互通，Google、Yahoo、Microsoft牵头促使OAuth1.0产生。之后的OAuth2.0是各大互联网企业基于https安全的一次新规划。目前最常见的应用场景主要在授权登录上，如微信、qq、微博等等。JSONJson虽然是2001年就产生的标准，但被广泛应用是在2008年之后各种Ajax应用、iPhone、Android设备流行之后。旧的服务体系多是企业级，所以XML对java型的企业级服务定位有益。但对于流量限制，语义简单的API服务来说，XML庞大、冗余、不易学又占带宽。去年我刚工作的时候，后台给我返回一个数组，没有发言权的我在是要遍历这个数组还是转化为json格式之间纠结了很久。Json的普及，从另一个角度体现了web开发的一个优势，不管你后台是java ruby php还是python，你只要给我一个json格式的接口，我就能撑起整个地球。DJANGO&RAILS敏捷开发打破了项目研发模式。在2010之后的WEB2.0时代，Html5盛行，前端工作被分离出去，PHP那种网页脚本的优势没那么明显，虽然在CMS和论坛模板上依然有优势。Django和Rails的最大优势在于，他让个人或两三个的小团队，实现整套产品成为可能。以Instagram为例，最初两个python工程师用django快速实现了服务端的所有功能，在用户增长时，再将大访问量和大数据量的服务独立出去。尽管现实残酷，rails每况日下，IE8和rails谁先消失只是先后问题，但其提供的解决方案还是被很多后生所效仿。人们都会记得这朵昙花。Bootstrap2011年Twitter开源的网页端GUI框架。jquery兼容了不同浏览器的js部分，bootstrap则兼容了不同浏览器的css部分。甚至于说，作为一个后端开发，你无需了解css，无需前端，无需设计师，只要看一看bootstrap的文档，就可以搭起一个美观大方的后台管理系统。常见类似的GUI框架还有zurb的foundation,google的materialize，百度也曾出过一个名为GMU的移动端框架。就我个人来说，我并不喜欢这些gui框架，尽管他们简化了css，实现了一些很炫酷的效果，尽管我在项目中也用到过这些，尽管我不想承认我是绿茶。这些框架最大的缺点就是，千篇一律，所有的页面都是一个样子，一样的nav，一样的sidebar，一样的表单，连鼠标点上去放个光都一模一样。就像我如果长了三条腿（虽然确实长了三条腿）别人会说我很别致让他们眼前一亮，但如果所有人都长了三条腿，web也就失去其魅力了。另一个缺点是臃肿，一个css就走100多k的流量，其js插件又大都依赖jquery，忍心么。当然，其为了解决响应式提出的栅格化html的思想还是很值得借鉴的。IOS & ANDROID系统的普及2009年之后IOS和Android的快速发展，导致WEB开发发生以下改变：1. html5在移动浏览器上优先实现，Android和IOS设备全面支持html5、CSS3，加速了IE消失。2. 上网随时随地发生。鼠标点击、内容繁复的网页越来越简洁，响应式设计快速流行。3. APP和服务器交互大部分和网页一样基于HTTP协议，webapp，hybrid app的概念被提出。关于webapp，这里简单说下web相比原生的优势。跨平台：常说的一次编译，到处运行免安装：打开浏览器，就能使用快速部署：升级只需在服务器更新代码，而不像客户端需要更新版本超链接：可以与其他网站互连，可以被搜索引擎检索听起来刁刁的，这些优势却经不住推敲。首先，不同系统的用户使用习惯是不同的，ios用户返回按钮习惯在左上角，而安卓用户却习惯在屏幕最下方的位置，产品经理问，那放在哪儿。呵呵哒不知道。其次，曾经看过一个调查报告，问用户更喜欢用客户端还是web端。喜欢客户端的用户远远超过了web端。你问我喜欢什么，我也是喜欢客户端。你问我为什么，我觉得比较有安全感吧，而且更新版本让我觉得很爽，很有存在感，让我知道我并没有被世界遗忘，让我知道你们产品在更新，在为我操心。另外超链接..我一个客户端要你seo干什么。这还没完，webapp的缺点还有一大把，最大的缺点莫过于没有GPU加速，想要实现一个复杂一些动画，真是要了浏览器亲命了。其次网页是单线程的，加载dom时会阻塞js，导致的结果就是，卡。一卡就烦了，烦了就关了，用户减一。而hybrid就不同了，hybrid app的意思是混合原生应用，将需要频繁更新的页面作为web放在远程更新。这是一个靠谱的解决方案，BAT有很多案例，如微信发布的JS SDK，掌上百度和淘宝客户端Android版。当然这里边的坑有很多，有机会，我把我踩过的坑讲给你们听。NodeJS我纠结了一会node属不属于前端范畴的问题。我认为是属于的。解决高并发一直是后台哥哥们乐于讨论的问题，比如咱们的好近实时监控系统，理论上每个连接都会生成一个新线程，每个新线程可能需要 2 MB 配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着用户的增长，咱们希望监控程序支持更多用户，这样，就必须添加更多服务器。当然，这会增加业务成本，尤其是服务器成本。除了成本上升外，还有一个技术问题：用户可能针对每个请求使用不同的服务器，因此，任何共享资源都必须在所有服务器之间共享，到这里，技术就到了瓶颈。node诞生的初衷，就是为了解决这个问题。node解决这个问题的方法是：更改连接到服务器的方式。每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程，并为其分配一些配套内存。nodejs属于服务器端语言，在前后端分离这场圈地运动中是前端的一个有利武器，同时在前端自动化上也提供了大量的可编程工具（grunt,bower,gulp等），淘宝百度对nodejs的热度一直很高，自然而然我认为这是一个趋势。去年美团成立了美团酒店的团队，选择了node作为后台语言，圈走了后台大部分的工作。我在想，前端js加上node再加上对UI的技能需求，以后前端工程师是不是该叫全端工程师了。BIG DATA大数据大概是过去几年最火热的名词，我一大批同学听说数据挖掘年薪30万都嗷嗷嗷去做数据库了。 大多数时候，我们在谈大数据其实都是在谈在海量数据下的数据挖掘、数据分析、智能推荐、实时分析等。不同公司的技术方案不同，我只列两个国内成功的案例：• 京东个性化电商，场景包括基于行为、偏好、地域、时间、好友关系等维度，向不同的用户推荐不同的产品，不同用户搜索产品排序也不同…• 百度地图东莞8小时迁徙图；百度搜索智能提醒• 360手机卫士，电话号码防骚扰功能是通过用户的地域、身份、骚扰趋势，将标记的2.56亿个电话号码选出1000个和用户关联度最高的，写入用户手机的10k的文本里，达到不联网不做任何网络交互的情况下，为用户防骚扰HTML5+CSS3这是这几年被说烂了的一个词，人人都在说HTML5，问HTML5是什么，他们也说不清楚，就是酷，就是炫，就是酷炫。在我看来，HTML5只是一个三人成虎的东西，它吸引的眼球远超过了它提供的功能，HTML5只是提供了一些新的API，就等于一个app从1.0升级到2.0增加了附近的人功能而已。而且其提供的API，也就是在移动端试一试水，在pc端因为兼容的问题，始终不能被明媒正娶。pc端的开发还是以HTML4.0+CSS2为基准渐进增强。至于css3，它最被人关注的动画，也是flash玩剩下的东西。移动端的飞速发展催化了HTML5的发展，HTML5的发展也促使各浏览器趋于标准化。这条标准化路上，微信功不可没，1024，围住神经猫，淘宝十年，LEXUS NX这些融合了大量HTML5+CSS3元素的页面让人印象深刻。此外，微软抛弃IE代号，开发edge，各大浏览器厂商的不断标准化，HTML5草案定稿，ES6草稿的不断实现与完善，前端之路看起来是一条京畿坦途，我充满期待。未来3D页游？WebOS？ 虚拟现实？最后，随着用户硬件性能的提升，网络带宽的越来越粗，传感系统，Retina，WebGL技术的日渐成熟，再加上O2O的蓬勃发展，上边这些会成为现实么？

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

面向对象编程？没有对象你编毛程序！！！
听说你们程序员都是面向对象编程？你没有对象编毛程序!!!   程序员打油诗 　　 　　写字楼里写字间，写字间里程序员;　　程序人员写程序，又拿程序换酒钱。 　　酒醒只在网上坐，酒醉还来网下眠;　　酒醉酒醒日复日，网上网下年复年。 　　但愿老死电脑间，不愿鞠躬老板前;　　奔驰宝马贵者趣，公交自行程序员。 　　别人笑我忒疯癫，我笑自己命太贱;　　不见满街漂亮妹，哪个归得程序员。       程序猿最怕弹出的窗口：“找不到对象。指针为空“ 这辈子做程序员的命宝宝数学很好，2岁就可以从1数到10了。后来，我告诉他0比1还小。今天吃饺子，我说：“宝宝，你数数你想吃几个饺子？”“0，1，2，3。”一边说着一边拿起一个饺子，“这是第0个。”老婆怒吼：“下一代还是做程序员的命！”

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

有理想的程序员必须知道的15件事
作为程序员,要取得非凡成就需要记住的15件事.　　1.走一条不一样的路　　在有利于自己的市场中竞争,如果你满足于"泯然众人矣",那恐怕就得跟那些低工资国家的程序员们同场竞技了.　　2.了解自己的公司　　以我在医院、咨询公司、物流企业以及大技术公司工作的经验来看,这一点所言不虚.　　不同公司的运营模式差异极大.如果你理解企业的运营模式,那你就不一样了!在这家公司中(或者对客户而言),你是参与业务运营的资产,你的工作能直接产生效益!　　3.与最优秀的人为伍　　很早以前,我喜欢打篮球,被分配到一个水平比较高的队里.一开始适应的确很困难,但环境的压力越大(重大比赛),我的长进也就越明显.　　每个领域其实都一样:你周围人的水平(以及对你的期望)越高,你就会变得越优秀.　　4.制造差异　　每年学习一门新编程语言.为什么不呢?不断尝试新事物,你关注的技术种类越多,脚下的路就越宽广,你的职业生涯就会日新月异.不知道几年后java的趋势如何?那就学习clojure.学ruby还是python?这两种语言都可以试试啊.然后你才能知道哪种语言更适合某个特定的项目.看,掌握的语言多了,才能在需要的时候信手拈来吧.　　5.畏惧,是最大的敌人　　还是直接从书中摘一句吧:"在畏惧中做出的职业规划,很可能会让自己后半辈子就一直被'圈禁'在小隔断里,永远不会有创造明天辉煌的时刻.没错,那样是安全,但有意思吗?"　　6.要成为多面手　　如果你掌握了所在领域的知识,那你只能是一名专业人士.用php编程?花点时间设置一台apache服务器,让php和mysql都跑起来.一直在用jquery?试试prototype.你懂了吧.　　7.一个字:做　　别指望别人过来教你该怎么做,出去,自己学着去做!　　8.找一位好老师　　找一位好老师可以让你在学习技术的时候有的放矢.作者给我们讲述了别人是怎么指导他学习的(顺便说一句,作者在这本书里讲了很多个人经历的小故事,他居然从一位演奏家转行来做软件开发!):"好好研究一下目录服务,熟悉一种unix变体,然后再掌握一门脚本语言."　　请记住这句禅宗谚语:"循路觅宗师,形影不相离,师知吾亦知,吾乃成宗师."　　9.主动教会别人　　教会别人是一种最好的学习方式.写一篇博客能帮你搞清楚一个问题.为此,你必须先掌握很多材料,同时还要有条有理地讲给别人听(写作技能).如书中所言:"要想知道自己是不是真的明白,你就讲给别人听听."　　10.实践,实践,再实践(训练)　　只有进行大量实践(花大量的时间)才能掌握某种技术.看的很多,写的很少,遇到问题,改一改,又去读代码……(这样下去是不行的).　　要特别警惕拖延症.其实,往往只要有了开头就好办了.　　自我加压,效果会更好.我曾在一篇博客中提到帕金森定律:紧张的时限可以让你提高工作效率.为什么不把这个定律用到学习上呢,比如说在y时间内学会x?　　11.从小处入手　　每天都取得一项小成果,每天都要坚持做(写在博客上?).这样一来,你只能让自己比昨天更进步,而不能说自己比上星期进步了一点.　　12.享受过程　　关注当下,而不是目标,享受那些在追逐未来目标的途中可能无暇顾及的小胜利.人总要生活在当下.我享受编程的过程,就像享受编程的结果一样.　　13.不要丧失危机感　　越是成功,就越容易犯重大错误.永远不要忘了危机感,特别是要认识到你今天所知道的,到了明天可能就会一文不值.过去的荣耀不能保你永远无虞.　　据书中所说,你最好是要让自己能够"通用",而不要对哪种技术或哪个公司产生依赖.你所掌握的某些技能,甚至你的工作,到了明天都可能会变得毫无价值.因此要不断提高/丰富/扩展自己的技能.　　14.推销自己　　为某个项目贡献自己的一份力量,写一篇博客,共享自己的源代码,成为对某个社区有用的人.　　当然,做这些事可能需要激情,要看你的爱好,但这些事也会间接地推广你的工作成果,证明你的实力,提高你的知名度.　　15.关注市场　　书中还提到了"预警极客",也就是那些始终引领技术发展的人.这些人说过的话往往带有预见性,他们提到事物也许过几天就会成为头条新闻.关注这些人,常看他们的twitter和博客.

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

天下数据：做营销最爱犯的错误是什么？

        最近天下数据天下云—香港云主机上线。为了更好的推广新产品，除了传统的营销方式，在官网上做活动和竞价推广之外。各类营销软文也是络绎不绝。但是软文营销的效果好像并不是多好。这不只是小天面临的问题，而是如今所有营销人都面临的问题。
　　在这个去中心化的社交媒体时代，品牌方对渠道的掌控力变得非常微弱，传播变成一件难度很高的工作，于是勤奋的营销人纷纷想各种办法来加强传播力度，于是我们越发频繁地看到一些奇怪的营销现象：
　　借势营销：前不久范冰冰和李晨宣布在一起了，瞬间无数个品牌都在未经授权的情况下把自己的品牌PS到人家的合影上，然后再牵强地想一句不知所云的话。类似的群体性模仿事件今年我们看到的不要太多，以至于当天津港爆炸事件发生后，发表声明说我们不借势灾难题材做营销竟然成了一种高姿态。难道本来不就应该是如此的吗？
　　自黑营销：在自黑方面，神州专车几乎堪称经典。我不相信神州专车的营销团队预料不到“我怕黑专车”这一轮广告出去会引发舆论的哗然，从而损伤品牌的美誉度，但他们依然选择这么做了。在权衡“到底是要传播广度还是要品牌美誉度”这个问题时，他们选择了前者而放弃了后者，这样做真的值得吗？
　　效颦营销：有些营销人，看到别人的逗逼文章火了，于是就学着也整个逗逼的文章。以去年火爆互联网的“挖掘机技术哪家强”为例，竞相模仿该文案的数不胜数。包括后来出现的转折体自不必说，模仿的人也是一抓一大把。小天自然也没能逃出，也模仿过几篇该类型的文章。看到别人用H5工具了，自己赶紧也赶时髦弄个H5页面。鲁迅先生不是做营销的，可是他都知道“第一个把女人比作鲜花的是天才，第二个是庸才，第三个是蠢材”这个道理。
 　 事实上，在大众媒体时代我们能更多地看到出色的策划，而在社交媒体时代出色的策划反而在变少。这是因为在大众媒体时代，策划的归策划，媒介的归媒介，策划人可以专注于内容而不用去操心传播。
　　而到了社交媒体时代，所有人都知道传播效果取决于内容，于是传播量成了目标，内容成了达成传播量的一种手段，策划人一不小心就容易陷入“点击量挂帅”的工作模式当中。在这样的状态下生产出来的内容，传播量也许是有了，然而对品牌又有何贡献价值呢？如果对品牌没有增益，那传播又有什么卵用呢？
    今天的营销人相比过去的营销人，花在创意方面的时间肯定是更多了，因为越来越多的企业都开始进行内容营销。然而，这并不代表大家更重视策划了，随着传播难度的增加，“面向传播的策划”逐步替代了“面向品牌的策划”。传播本来是为品牌服务的，它不应该成为目的本身，品牌才是目的。举个通俗的例子，唱卡拉OK是好嗓子重要还是好音响重要？肯定是好嗓子更重要，如果嗓子不好，越好的音响越会放大嗓子的缺点。
　　洋洋洒洒写了一大通，其实也是在批评我自己，这些错误小天基本上也都犯过一遍。错误不重要，重要的是在以后的文案写作与传播中该如何去改。我相信认清楚这些问题，也就自然方便对症下药了。
　　

　　



版权声明：本文为博主原创文章，未经博主允许不得转载。

揭秘谷歌网络基础设施十年演变过程
谷歌今天 宣布 ，它想要修复用户家中的 Wi-Fi 网络连接问题，但在公司内部，这家搜索巨头很早以前便在解决远比这 复杂 的网络问题了。为了将构成谷歌数据中心的数十万台机器连接起来，你不能仅仅使用路由器和交换机这些最基本的工具，还要管理在服务器之间流动的所有数据。为此，谷歌一直在开发自己的硬件和软件，今天该公司揭开了它们的神秘面纱，让我们得以一窥其网络基础设施的演变过程。谷歌当前网络基础设施即所谓的“木星”（Jupiter）网络，容量是第一代网络的 100 倍，能以每秒 1 Petabit 的惊人速度提供总对分带宽（total bisection bandwidth）数据。该公司表示，在这种速度下，10 万台服务器可以在不到十分之一秒的时间内，阅读完美国国会图书馆中所有已经扫描的数据。谷歌工程师艾明·瓦达特（Amin Vahdat）今天 写道 ：“对于谷歌的服务来说，这种网络性能始终是巨大的益处。工程师们可以从给各种水平的带宽优化代码的繁杂工作中解脱出来。例如，一开始，在如何处理连接于相同的架顶式交换机（top of rack switch）的服务器的数据本地化和部署上，以及单个交换机故障引发的相关损失上，我们就面临着痛苦的抉择。”但是，谷歌在 10 年前远未达到这种数据处理能力。之后，谷歌收购了视频网站 YouTube，不久后又推出了 Gmail、谷歌地球和谷歌地图之类的产品，所以该公司的需要也在发生着快速转变。以下即是早期服务器网络在 2005 年时的模样：正如谷歌在今天的 文章 中所写，该公司基本上在 2004 年就部署了标准的服务器集群（server cluster），这些 2005 年产的机器也是谷歌在 Firehose 1.1 数据中心架构部署的网络设备的第一个例证。在 2005 年部署的机器的目标是，在 1 万台服务器之间实现 1 Gbps 的对分带宽。为了实现这个目标，谷歌曾试图将交换结构（switching fabric）整合到其自主开发的服务器中，但事实证明“服务器的正常运行时间不及理想状态。”有了 Firehose 1.1 数据中心架构以后，谷歌部署了其第一个定制数据中心集群结构（cluster fabric）。谷歌的工程师今天写道：“根据我们从 FH1.0 了解到的情况，我们不使用常规服务器来存放交换芯片。”相反，谷歌开发了定制式构架，并且转移到所谓的 Clos 数据中心网络构架。到 2008 年，Firehose 1.1 已演变为 WatchTower，后者转而使用 10G 光纤，而非传统的网线。谷歌面向全球的数据中心推出了这个版本的架构。下面即是那些架顶的模样：一年后，WatchTower 又变成了“土星”（Saturn）。WatchTower 的架构可以扩大至 87 Tbps，而“土星”架构则可以在更稠密的架顶下扩大至 207 Tbps。很显然，“土星”很好地满足了谷歌的需要，因为三年以后该公司才向好于“土星”能力的架构转变。谷歌工程师写道：“随着每台服务器的平均带宽要求持续提高，数据中心所有集群的相同带宽也具有了这种需要。随着 40G 标准的硅基结构的问世，我们可以考虑将我们的 Clos 架构扩大至整个数据中心（可归入内集群网络层）。”正是这类架构，现在让谷歌可以将一个数据中心看作是一台巨型计算机，用软件来分配整个网络中所有服务器的计算和存储资源。诚然，“木星”硬件看上去不同于谷歌在打造定制式网络设备上的最早努力，但从许多方面讲，它还证明谷歌迅速采用了 软件定义网络（Software Defined Networking），从而实现了快速创新能力。谷歌今天公布了 四篇论文 ，详细叙述了该公司网络构架的各个方面。由于谷歌往往先于其他公司触及传统硬件和软件构架的极限，所以类似论文常常在谷歌之外的公司引发新一轮创新活动。所有的创业公司都想要创建自己的数据中心，但这是不可能的，其他数据中心运营方肯定会详细研究这些论文，也许会随着时间的推移执行类似的解决方案。当然，他们的用户也会从这种转变中受益。

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

2015 Chinajoy ShowGirl照片合集
2015 ChinaJoy 由于新规，要求此次展览 Showgirl 不能再出现大尺度着装，所以今年的 Showgirl "福利"指数较往年直线下降……虽然今年被称作"史上最严"CJ，但是现场依然颜值爆表。  

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

机器学习算法面试—口述（1）：SVM介绍及常见问题


这个系列是为了应对找工作面试时面试官问的算法问题，所以只是也谢算法的简要介绍，后期会陆续补充关于此算法的常见面试的问题！


首先SVM是支持向量机support vector machine的缩写，它是现在使用比较广泛的一个分类算法（二分类），是一个线性分类器！
当数据是线性可分的时候：
SVM是在空间找一个分类超平面，将数据分开，下面以二维为例



（1） 
（2）
SVM要做的就是找到（1）中间那条线（三维的话是一个面，更高维是一些其他什么的。。。），但是光找到那条线是不够的，因为这样的线是有无数条的（2）。显然（2）中中间的那条要比旁边的那两条要好，因为它与两边的数据的隔得很开，分类时候抗噪性能比旁边那两条要好。那么如何找到中间那条线呢，这就是SVM要解决的问题。



如上图，，，得到，之后转化为最优化的问题，由于直接最大化最大间隔是一个非凸优化问题，将其转换为求最大间隔与||W||的比值（满足的条件是f(x)
 >= 最大间隔），为了计算方便，将最大间隔置为1，这也是我们看到的最终需优化的式子。



显然优化这样的式子，肯定是拉格朗日乘子法，这个式子不太好求，将1/||w||转换为0.5*||w||*||w||，
，令，也即求min(max...),

转化为对偶问题有式子min(max..) >= max(min..)(求这项)，之所以转化为对偶问题，一是两个式子解相仿，而是求解更简便。上面的式子满足KKT条件，求解得到L(w,b,a)是一个关于a的式子。
之后的优化工作就交个了一个叫做SMO（序列最小化算法）。
当数据是线性不可分的情况下，SVM求解分类的超平面是使用核函数。有的数据在低维空间不可分，但是映射到高维空间后它可能是线性可分的，比如，一维线上的点不线性可分，映射到二维（平方函数）就可能可以分开了。但是在映射的时候有一个问题，是一个计算问题，低维空间映射到高维空间，在高维空间上直接计算的话回产生一个维灾难的问题（2->5, 3->19...）。这个地方就引入了核函数，核函数是计算两个向量在隐式映射过后的空间中的内积的函数，通过核函数可以使数据不用在映射后的高维空间中计算，而是在原来的低维空间中计算（在原来的低维空间上做内积）。
以上就是SVM的简要介绍，当然里面很多细节是没有说出来的，毕竟面试刚开始要你介绍你也不会说的很细节不是。不过面试官肯定会问你关于SVM的一些细节知识，只知道个大概是没有用的。
补充一些细节知识：
1、关于松池变量
如下图：




这个图给出了两组超平面的画法，每组两边的超平面都能将数据区分开来，但是离两边的数据点非常近，二中间的那个超平面会错分某些点，但是其具有很好的边界效果。显然中间这个超平面比较好，因为它的鲁棒性很好。
SVM允许数据点在一定程度上偏离超平面，这个反应在约束条件ai中，本来约束条件是ai >= 0，现在约束条件变为：C >= ai >= 0；
松弛变量的引入也就是允许某些点离超平面的距离小于1，也即放弃了这些点的分类精度，惩罚因子决定了对离群点的重视程度，C越大，表示分错某一个点需要付出更大的代价（这个可以一定程度上缓解正负样本数量相差太大的问题）。
2、







版权声明：本文为博主原创文章，未经博主允许不得转载。

机器学习之决策树算法
      机器学习在各个领域都有广泛的应用，特别在数据分析领域有着深远的影响。决策树是机器学习中最基础且应用最广泛的算法模型。本文介绍了机器学习的相关概念、常见的算法分类和决策树模型及应用。通过一个决策树案例，着重从特征选择、剪枝等方面描述决策树的构建，讨论并研究决策树模型评估准则。最后基于
 R 语言和 SPSS 这两个工具，分别设计与实现了决策树模型的应用实例。
机器学习概念 



    机器学习 (Machine Learning) 是近 20 多年兴起的一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。

   机器学习理论主要是设计和分析一些让计算机可以自动学习的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。因为学习算法中涉及了大量的统计学理论，机器学习与统计推断学联系尤为密切，也被称为统计学习理论。在算法设计方面，机器学习理论关注可以实现的、行之有效的学习算法。很多相关问题的算法复杂度较高，而且很难找到固有的规律，所以部分的机器学习研究是开发容易处理的近似算法。

     机器学习在数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA 序列测序、语言与手写识别、战略游戏与机器人运用等领域有着十分广泛的应用。它无疑是当前数据分析领域的一个热点内容。



算法分类
机器学习的算法繁多，其中很多算法是一类算法，而有些算法又是从其他算法中衍生出来的，因此我们可以按照不同的角度将其分类。本文主要通过学习方式和算法类似性这两个角度将机器学习算法进行分类。

学习方式



1、监督式学习：从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集需要包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督式学习算法包括回归分析和统计分类。




2、非监督式学习：与监督学习相比，训练集没有人为标注的结果。常见的非监督式学习算法有聚类。




3、半监督式学习：输入数据部分被标识，部分没有被标识，介于监督式学习与非监督式学习之间。常见的半监督式学习算法有支持向量机。




4、强化学习：在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的强化学习算法有时间差学习。




算法类似性


1、决策树学习：根据数据的属性采用树状结构建立决策模型。决策树模型常常用来解决分类和回归问题。常见的算法包括 CART (Classification And Regression Tree)、ID3、C4.5、随机森林 (Random Forest) 等。




2、回归算法：试图采用对误差的衡量来探索变量之间的关系的一类算法。常见的回归算法包括最小二乘法 (Least Square)、逻辑回归 (Logistic Regression)、逐步式回归 (Stepwise Regression) 等。




3、聚类算法：通常按照中心点或者分层的方式对输入数据进行归并。所有的聚类算法都试图找到数据的内在结构，以便按照最大的共同点将数据进行归类。常见的聚类算法包括 K-Means 算法以及期望最大化算法 (Expectation Maximization) 等。




4、人工神经网络：模拟生物神经网络，是一类模式匹配算法。通常用于解决分类和回归问题。人工神经网络算法包括感知器神经网络 (Perceptron Neural Network) 、反向传递 (Back Propagation) 和深度学习等。

决策树

决策树是附加概率结果的一个树状的决策图，是直观的运用统计概率分析的图法。机器学习中决策树是一个预测模型，它表示对象属性和对象值之间的一种映射，树中的每一个节点表示对象属性的判断条件，其分支表示符合节点条件的对象。树的叶子节点表示对象所属的预测结果。

决策树案例：



图
 1. 决策树案例图



图 1 是一棵结构简单的决策树，用于预测贷款用户是否具有偿还贷款的能力。贷款用户主要具备三个属性：是否拥有房产，是否结婚，平均月收入。每一个内部节点都表示一个属性条件判断，叶子节点表示贷款用户是否具有偿还能力。例如：用户甲没有房产，没有结婚，月收入 5K。通过决策树的根节点判断，用户甲符合右边分支 (拥有房产为“否”)；再判断是否结婚，用户甲符合左边分支 (是否结婚为否)；然后判断月收入是否大于 4k，用户甲符合左边分支
 (月收入大于 4K)，该用户落在“可以偿还”的叶子节点上。所以预测用户甲具备偿还贷款能力。





决策树建立


本文上一节已经讨论如何用一棵决策树进行分类。本节将通过特征选择、剪枝，介绍如何根据已有的样本数据建立一棵决策树。





首先介绍下特征选择。选择一个合适的特征作为判断节点，可以快速的分类，减少决策树的深度。决策树的目标就是把数据集按对应的类标签进行分类。最理想的情况是，通过特征的选择能把不同类别的数据集贴上对应类标签。特征选择的目标使得分类后的数据集比较纯。如何衡量一个数据集纯度，这里就需要引入数据纯度函数。下面将介绍两种表示数据纯度的函数。





信息增益

信息熵表示的是不确定度。均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，分类后的数据集信息熵会比分类前的小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。





假设在样本数据集 D 中，混有 c 种类别的数据。构建决策树时，根据给定的样本数据集选择某个特征值作为树的节点。在数据集中，可以计算出该数据中的信息熵：




图 2. 作用前的信息熵计算公式

其中 D 表示训练数据集，c 表示数据类别数，Pi 表示类别 i 样本数量占所有样本的比例。




对应数据集 D，选择特征 A 作为决策树判断节点时，在特征 A 作用后的信息熵的为 Info(D)，计算如下：





图 3. 作用后的信息熵计算公式





其中 k 表示样本 D 被分为 k 个部分。




信息增益表示数据集 D 在特征 A 的作用后，其信息熵减少的值。公式如下：




图 4. 信息熵差值计算公式





对于决策树节点最合适的特征选择，就是 Gain(A) 值最大的特征。





基尼指数


基尼指数是另一种数据的不纯度的度量方法，其公式为：





图 5. 基尼指数计算公式





其中 c 表示数据集中类别的数量，Pi 表示类别 i 样本数量占所有样本的比例。 从该公式可以看出，当数据集中数据混合的程度越高，基尼指数也就越高。当数据集 D 只有一种数据类型，那么基尼指数的值为最低 0。





如果选取的属性为 A，那么分裂后的数据集 D 的基尼指数的计算公式为：





图 6. 分裂后的基尼指数计算公式





其中 k 表示样本 D 被分为 k 个部分，数据集 D 分裂成为 k 个 Dj 数据集。





对于特征选取，需要选择最小的分裂后的基尼指数。也可以用基尼指数增益值作为决策树选择特征的依据。公式如下：





图 7. 基尼指数差值计算公式





在决策树选择特征时，应选择基尼指数增益值最大的特征，作为该节点分裂条件。




接下来介绍剪枝。在分类模型建立的过程中，很容易出现过拟合的现象。过拟合是指在模型学习训练中，训练样本达到非常高的逼近精度，但对检验样本的逼近误差随着训练次数而呈现出先下降后上升的现象。过拟合时训练误差很小，但是检验误差很大，不利于实际应用。





决策树的过拟合现象可以通过剪枝进行一定的修复。剪枝分为预先剪枝和后剪枝两种。




预先剪枝指在决策树生长过程中，使用一定条件加以限制，使得产生完全拟合的决策树之前就停止生长。预先剪枝的判断方法也有很多，比如信息增益小于一定阀值的时候通过剪枝使决策树停止生长。但如何确定一个合适的阀值也需要一定的依据，阀值太高导致模型拟合不足，阀值太低又导致模型过拟合。





后剪枝是在决策树生长完成之后，按照自底向上的方式修剪决策树。后剪枝有两种方式，一种用新的叶子节点替换子树，该节点的预测类由子树数据集中的多数类决定。




另一种用子树中最常使用的分支代替子树。预先剪枝可能过早的终止决策树的生长，后剪枝一般能够产生更好的效果。但后剪枝在子树被剪掉后，决策树生长的一部分计算就被浪费了。





决策树模型评估


建立了决策树模型后需要给出该模型的评估值，这样才可以来判断模型的优劣。学习算法模型使用训练集 (training set) 建立模型，使用校验集 (test set) 来评估模型。本文通过评估指标和评估方法来评估决策树模型。 评估指标有分类准确度、召回率、虚警率和精确度等。而这些指标都是基于混淆矩阵 (confusion matrix) 进行计算的。



混淆矩阵是用来评价监督式学习模型的精确性，矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例。以二类分类问题为例，如下表所示：

                                       表
 1. 混淆矩阵
   







预测的类








实际的类




类 = 1

类 = 0






类 = 1

TP

FN

P



类 = 0

FP

TN

N






其中

P (Positive Sample)：正例的样本数量。

N(Negative Sample)：负例的样本数量。

TP(True Positive)：正确预测到的正例的数量。

FP(False Positive)：把负例预测成正例的数量。

FN(False Negative)：把正例预测成负例的数量。

TN(True Negative)：正确预测到的负例的数量。

根据混淆矩阵可以得到评价分类模型的指标有以下几种。





分类准确度，就是正负样本分别被正确分类的概率，计算公式为：





图 8. 分类准确度计算公式





召回率，就是正样本被识别出的概率，计算公式为：





图 9. 召回率计算公式





虚警率，就是负样本被错误分为正样本的概率，计算公式为：





图 10. 虚警率计算公式





精确度，就是分类结果为正样本的情况真实性程度，计算公式为：





图 11. 精确度计算公式





评估方法有保留法、随机二次抽样、交叉验证和自助法等。





保留法 (holdout) 是评估分类模型性能的最基本的一种方法。将被标记的原始数据集分成训练集和检验集两份，训练集用于训练分类模型，检验集用于评估分类模型性能。但此方法不适用样本较小的情况，模型可能高度依赖训练集和检验集的构成。





随机二次抽样 (random subsampling) 是指多次重复使用保留方法来改进分类器评估方法。同样此方法也不适用训练集数量不足的情况，而且也可能造成有些数据未被用于训练集。





交叉验证 (cross-validation) 是指把数据分成数量相同的 k 份，每次使用数据进行分类时，选择其中一份作为检验集，剩下的 k-1 份为训练集，重复 k 次，正好使得每一份数据都被用于一次检验集 k-1 次训练集。该方法的优点是尽可能多的数据作为训练集数据，每一次训练集数据和检验集数据都是相互独立的，并且完全覆盖了整个数据集。也存在一个缺点，就是分类模型运行了 K 次，计算开销较大。





自助法 (bootstrap) 是指在其方法中，训练集数据采用的是有放回的抽样，即已经选取为训练集的数据又被放回原来的数据集中，使得该数据有机会能被再一次抽取。用于样本数不多的情况下，效果很好。

决策树建模







在本节中，将通过 R 和 IBM SPSS 两种建模工具分别对其实际案例进行决策树建模。




 R


R是一个用于统计计算及统计制图的优秀的开源软件，也是一个可以从大数据中获取有用信息的绝佳工具。它能在目前各种主流操作系统上安装使用，并且提供了很多数据管理、统计和绘图函数。





下面本节就将使用 R 所提供的强大的函数库来构建一棵决策树并加以剪枝。





清单 1. 构建决策树及其剪枝的 R 代码




根据代码，运行步骤如下：


1、导入需要的函数库。当然如果本地开发环境没有相应的库的话，还需要通过 install.packages 函数对库进行安装。

2、查看本次构建决策树的数据源。stagec 是一组前列腺癌复发的研究数据。

3、通过 rpart 函数构建决策树，以研究癌复发与病人年龄、肿瘤等级、癌细胞比例，癌细胞分裂状况等之间的关系。

4、查看决策树的具体信息。 绘制构建完成的决策树图。

5、通过 prune 函数对该决策树进行适当的剪枝，防止过拟合，使得树能够较好地反映数据内在的规律并在实际应用中有意义。

6、绘制剪枝完后的决策树图。 该案例决策树的拟合结果与剪枝前后的树如下图所示：





图 12. 决策树案例拟合图








图 13. 未剪枝的决策树图








图 14. 剪枝后的决策树图




SPSS


IBM SPSS Modeler 是一个预测分析平台，能够为个人、团队、系统和企业做决策提供预测性信息。它可提供各种高级算法和技术 (包括文本分析、实体分析、决策管理与优化)，帮助您选择可实现更佳成果的操作。




在 SPSS Modeler 中有很多应用实例，其中就包括一个决策树算法模型的案例。此示例使用名为 druglearn.str 的流，此流引用名为 DRUG1n 的数据文件。这些文件可在任何 IBM SPSS Modeler 安装程序的 Demos 目录中找到。操作步骤如下：


1、添加“变量文件”节点 GRUGln，打开该节点，添加 DRUGln 文件。

2、创建新字段 Na_to_K, 通过对 Na 和 K 数据的观察，发现可以用 Na 和 K 的比例来预测药物 Y。

3、添加过滤器 (Discard Fields)，过滤掉原始的字段 Na 和 K，以免在建模算法中重复使用。

4、添加类型节点 (Define Types)，设置字段的角色，将药物字段设置为目标，其他的字段设置为输入。

5、添加 C5.0 节点，使用默认的参数设置。 点击运行，生成一个模型 Drug。

在生成模型
 Drug 以后，我们可以在模型页面中浏览 Drug 模型。打开 Drug 模型以后，可在规则浏览框中以决策树形式显示 C5.0 节点所生成的规则集。还可以通过更复杂的图表形式查看同一决策树。如下图所示：

 
                    

 
                                                                         
图 15. 生成模型的决策树图





结束语









本文也展开讨论了分类算法之间的相互比较和优缺点，特征选择与剪枝各种方法之间的相互比较，各个评估方法的优缺点等。通过这些讨论与分析，能够以更好的方法论来解决实际生产环境下的问题。



同时，决策树只是整个机器学习领域的冰山一角，而机器学习领域又是当前大数据分析领域的热点，因此还有很多很多值得我们去学习、去研究的地方。






版权声明：本文为博主原创文章，未经博主允许不得转载。

回顾：RPC远程过程调用协议
先看看来自百度的这个图，最终可以归纳为这10个步骤。




1.调用客户端句柄；执行传送参数
2.调用本地系统内核发送网络消息
3.消息传送到远程主机
4.服务器句柄得到消息并取得参数
5.执行远程过程
6.执行的过程将结果返回服务器句柄
7.服务器句柄返回结果，调用远程系统内核
8.消息传回本地主机
9.客户句柄由内核接收消息
10.客户接收句柄返回的数据



版权声明：

exlipce mar 创建一个webService项目------》针对axis2
一、下载(1)axis2-1.6.3-bin.zip(解压文件，作为与eclipse配置的文件)
         网址：http://axis.apache.org/axis2/java/core/download.cgi
                (2)axis2-eclipse-codegen-plugin-1.6.2.zip、axis2-eclipse-service-plugin-1.6.2.zip（解压2文件后把                    
                org.apache.axis2.eclipse.codegen.plugin_1.6.2.jar和org.apache.axis2.eclipse.service.plugin_1.6.2.jar
                放到eclipse的安装目录,E:\eclipse\dropins文件夹下）
网址：http://axis.apache.org/axis2/java/core/tools/index.html
二、将eclipse与axis2-1.6.3-bin插件集成
(1)在Eclipse的菜单栏中，Window --> Preferences --> Web Services--> Axis2 Perferences,
            在Axis2 runtime location中选择Axis2解压缩包的位置，设置好后，点"OK"即行。
三、下载axis2.war(该包放在tomcat---->webapps下),这是核心
四、开始创建项目
在eclipse中新建一个Dynamic web project项目，接口名字尽量简单和规范（接口名规范，非常有用！）

五、生成.aar文件到tomcat的webapps\axis2\WEB_INF\services下
（1）wordspace工作区下，单击右键，新建other---->选择Axis2 Wizards ---->Axis2 Service Archiver ---->next

（2）到Service Archiver时，注意class File Location 只能选择到build\classes目录(如F:\eclipse_mar\WebServiceTest\build\classes)


（3）继续next,直到Server Archiver  Generate the Service XML file 
在service name 和 Class name 后面输入对应的名字。注意：Service name是指发布成功后访问的名称
 如http://localhost:8080/axis2/services/ITestService?wsdl红色字体，而Class name则必须填入接口的全路径！
         如：com.interfaces.ITestService ，点击Load 加载成功后即可看到本窗口中的接口中的方法和参数类型！表名已经加载成功！


  (4)下一步，将看到:OUtput file location 和 Output file name ，选择导出路径，一般就导出放在 tomcat\webapps\axis2\WEB-INF\services下
这样方便马上测试，而name可以任意取（只要符合命名规范即可）
 点击finish,则生成.aar文件成功！
（5）start--tomcat--访问刚刚发布的webService，在地址栏输入http://localhost:8080/axis2/services/ITestService?wsdl，即可看见生成的wsdl文件


注意：以上的方式是发布到axis2.war包中，当然我们也可以把生成.aar文件copy到实际应用中；
         同时，也可以使用eclipse的create webservice功能发布我们的webservice，选择axis2生成我们的webservice，
         这样webservice就会部署到我们的应用中了。
以上开发环境：
windows 7 64位 +tomcat 7 64位+jdk1.6 32位 +eclipse mar（最新版本）+axis2.war最新版+axis2.1.6.3.bin最新版+axis2两个插件
可能不同版本使用会有差异。

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        cas+apache ldap
上一篇博客写了关于cas sso单点登录的例子，后来公司又让我整合ldap，今天终于做出来了demo，就把我的例子分享给大家，以后对自己也好查阅，网上关于cas4.0整合apache ldap的帖子实在太少了，本例就是cas4.0+apache ldap,先将这些jar包放入cas中的lib文件夹中  
cas-server-support-ldap-4.0.0.jar  
spring-ldap-core-2.0.2.RELEASE.jar  
ldaptive-1.0.5.jar 
这二者整合主要就是配置deployerConfigContext.xml文件，首先需要的是修改认证入口：
<!--新增ldap认证的入口-->  
06.        <entry key-ref="ldapAuthHandler" value-ref="primaryPrincipalResolver"/>  
然后就是新增ldap中的LDAP配置文件，可以直接把下面的代码拷贝到你的deployerConfigContext.xml，将相应的参数修改成自己的就可以了
<!--ldap认证的入口-->  
    <bean id="ldapAuthHandler"  
          class="org.jasig.cas.authentication.LdapAuthenticationHandler"  
          p:principalIdAttribute="uid"  
          c:authenticator-ref="authenticator">  
        <property name="principalAttributeMap">  
            <map>  
                <!--  
                   | This map provides a simple attribute resolution mechanism.  
                   | Keys are LDAP attribute names, values are CAS attribute names.  
                   | Use this facility instead of a PrincipalResolver if LDAP is  
                   | the only attribute source.  
                   -->  
                 <entry key="uid" value="uid" />  
                 <!-- <entry key="ip_address" value="ip_address" />  
                 <entry key="device_number" value="device_number" />  
                 <entry key="expired_time" value="expired_time" /> -->  
                 <entry key="displayName" value="displayName" />  
            </map>  
        </property>  
    </bean>  
    <bean id="authenticator" class="org.ldaptive.auth.Authenticator"  
              c:resolver-ref="dnResolver"  
              c:handler-ref="authHandler" />  
      <!--  
          | The following DN format works for many directories, but may need to be  
          | customized.  
          -->  
          <!-- 下面uid这些可根据个人的配置不同而修改-->
    <bean id="dnResolver"  
             class="org.ldaptive.auth.FormatDnResolver"  
             c:format="uid=%s,ou=system,dc=com" />   
    <bean id="authHandler" class="org.ldaptive.auth.PooledBindAuthenticationHandler"  
             p:connectionFactory-ref="pooledLdapConnectionFactory" />  
    <bean id="pooledLdapConnectionFactory"  
             class="org.ldaptive.pool.PooledConnectionFactory"  
             p:connectionPool-ref="connectionPool" />          
    <!--连接池-->  
    <bean id="connectionPool"  
             class="org.ldaptive.pool.BlockingConnectionPool"  
             init-method="initialize"  
             p:poolConfig-ref="ldapPoolConfig"  
             p:blockWaitTime="3000"  
             p:validator-ref="searchValidator"  
             p:pruneStrategy-ref="pruneStrategy"  
             p:connectionFactory-ref="connectionFactory" />  
    <bean id="ldapPoolConfig" class="org.ldaptive.pool.PoolConfig"  
             p:minPoolSize="3"  
             p:maxPoolSize="10"  
             p:validateOnCheckOut="true"  
             p:validatePeriodically="true"  
             p:validatePeriod="300" />  
    <bean id="connectionFactory" class="org.ldaptive.DefaultConnectionFactory"  
        p:connectionConfig-ref="connectionConfig" />  
    <bean id="connectionConfig" class="org.ldaptive.ConnectionConfig"  
             p:ldapUrl="ldap://localhost:10389"    
            p:connectTimeout="3000"      
             p:useStartTLS="false" />    
    <bean id="pruneStrategy" class="org.ldaptive.pool.IdlePruneStrategy"  
              p:prunePeriod="300"  
              p:idleTime="600" />  
    <bean id="searchValidator" class="org.ldaptive.pool.SearchValidator" />            
      <!--ldap认证结束-->    
上面这些有些内容可能需要根据个人在客户端工具中的配置不同需要调整，需要调整的地方我已经标注，这时启动服务器，输入： 
http://localhost:8080/cas-server即可进入登陆页面，输入配置过的用户名密码即可访问，由于ldap4.0和之前的版本差别很大，所以配置比较多，而且ldap连接服务器不需要输入用户名密码而是连接uid，根据uid登陆即可，至此cas+apache ldap配置完成 
如下是具体的demo实例，需要的可自行下载

http://download.csdn.net/detail/danruoshui315/9052885


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Netty 源码分析之ByteToMessageDecoder
ByteToMessageDecoder是netty中的一个ChannelHandler，用于将ByteBuf转换成Message，message可以是POJO等等，转换后继续在ChannelPipeline中传递，Decoder和Encoder等设置显示了netty的ChannelPipeline带来的强大的灵活性，并且可以使我们复用很多逻辑代驾，分离职责。
ByteToMessageDecoder继承自ChannelHandlerAdapter,需要开发者实现的是decode方法
protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception;
ctx是decode属于的ChannelHandlerContext,in是用来读取的数据，out是我们转换后的对象列表 
一个将Byte转换成Integer的例子
class ByteToIntegerDecoder extends ByteToMessageDecoder{
        @Override
        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
            while(in.readableBytes() > 4){
                out.add(in.readInt());
            }
        }
    }
分析源码中较为关键的channelRead
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        if (msg instanceof ByteBuf) {
            RecyclableArrayList out = RecyclableArrayList.newInstance();
            try {
                ByteBuf data = (ByteBuf) msg;
                first = cumulation == null;
                if (first) {
                    cumulation = data;
                } else {
                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);
                }
                callDecode(ctx, cumulation, out);
            } catch (DecoderException e) {
                throw e;
            } catch (Throwable t) {
                throw new DecoderException(t);
            } finally {
                if (cumulation != null && !cumulation.isReadable()) {
                    cumulation.release();
                    cumulation = null;
                }
                int size = out.size();

                for (int i = 0; i < size; i ++) {
                    ctx.fireChannelRead(out.get(i));
                }
                out.recycle();
            }
        } else {
            ctx.fireChannelRead(msg);
        }
    }
cumulation是代表累加的byte数据，即上一次decode剩下的byte,cumulator是累加器，默认使用MERGE_CUMULATOR就是使用内存复制来进行累加。累加完之后调用callDecode(ctx, cumulation, out),callDecode中循环调用我们要实现的抽象方法decode(ctx,in,out) 来解码，知道不能继续解。 
在finally中对out列表中的每一个对象调用ctx.fireChannelRead(out.get(i)) 
触发ChannelPipeline后面的ChannelHandler的channelRead事件

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

TCP的三次握手和四次挥手
要搞懂这个首先得了解TCP报文段和及其首部格式，如图：




ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1

SYN ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此,  SYN置1就表示这是一个连接请求或连接接受报文。

FIN ：即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。
序号（seq）：指本报文段所发送的数据的第一个字节的序。例如一个报文段的序号字段是301，携带的数据共有100字节。显然下一个报文段的序号应该从401开始
确认号（ack）：是期望收到对方的下一个数据字节的序号，例如B正确收到了A发过来的一个报文段，其序号是501，数据长度是200，则B期望收到的下一个数据序号是701，于是B把确认号（ack）置为701。
注意：TCP采用的是累积确认，即确认是对所有按序接收的数据的确认，但请注意，接收方返回的确认号是已按序号收到的数据的最高序加1


三次握手：


分析：
         主机A向TCP发出主动打开命令，表明要向某个IP地址的某个端口建立传输连接。主机B向TCP发送一个被动打开命令，准备接受客户端的连接请求，自己处于监听状态。




        B的服务器进程创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程处于LISTEN状态，等待客服端的连接请求。

        A打的TCP客服端进程创建控制块TCB，然后向B发送连接请求报文段。该报文的首部SYN=1，并且假设序号seq=x。TCP规定，该连接请求报文段不携带任何数据，但需要占用一个序号。A发送了连接请求报文后进入SYN-SENT状态。

        B收到A的连接请求报文后，会向A返回连接接受报文。该报文的首部SYN=1，ACK=1，seq=y,ack=x+1。TCP也规定，连接接受报文段也不携带任何数据，但也需要占用一个序号。B发送该报文后立即进入SYN-RECD状态。

        A收到B的连接接受报文后，还需要向B发送一个确认报文段。在该报文中ACK=1，seq=x+1,ack=y+1。TCP规定，在该报文段中可以携带数据，也可不携带数据。但，不携带数据时，不会消耗一个序号，也就会说下一个发送的报文段的序号仍为x+1。该报文段发送成功后，进入ESTAB-LISHED状态，。

       B收到A的确认后，也进入ESTAB-ISHED状态。

思考：为什么是三次呢？

         防止已经失效的连接请求报文段突然传到主机B，因而产生错误。比如A发送的第一个连接请求因为某些原因二滞留时间太长，以致于这次连接都释放了才传到B，本来这就是一个无效的报文段，但B收到此无效的连接请求后，误认为是A发送的新连接请求，于是发确认连接，同意连接。而A并没有要求建立连接，所以不会理睬B发的确认连接，自然不会向B发送数据。但是B一直在等待A发送数据，这样就浪费了许多资源



四次挥手:


分析：


        当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1,  服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。  A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。




思考：

为什么要等待？

       为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）

为什么有保活时间：

        另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？  就是保活时间到了后，B会发送探测信息， 以决定是否释放连接。




版权声明：本文为博主原创文章，未经博主允许不得转载。

王垠：数学和编程


　　好些人来信问我，要成为一个好的程序员，数学基础要达到什么样的程度？十八年前，当我成为大学计算机系新生的时候，也为同样的问题所困扰。面对学数学，物理等学科的同学，我感到自卑。经常有人说那些专业的知识更加精华一些，难度更高一些，那些专业的人毕业之后如果做编程工作，水平其实比计算机系毕业的还要高。直到几年前深入研究程序语言之后，对这个问题我才得到了答案和解脱。由于好多编程新手遇到同样的困扰，所以我想在这里把这个问题详细的阐述一下。
　　数学并不是计算机科学的基础
　　很多人都错误的认为，计算机科学是数学的一个分支，数学是计算机科学的基础，数学是更加博大精深的科学。这些人以为只要学会了数学，编程的事情全都不在话下，然而事实却并非如此。
　　事实其实是这样的：

计算机科学其实根本不是数学，它只不过借用了非常少，非常基础的数学，比高中数学还要容易一点。所谓“高等数学”，在计算机科学里面基本用不上。计算机是比数学更加基础的工具，就像纸和笔一样。计算机可以用来解决数学的问题，也可以用来解决不是数学的问题，比如工程的问题，艺术的问题，经济的问题，社会的问题等等。计算机科学是完全独立的学科。学习了数学和物理，并不能代替对计算机科学的学习。你必须针对计算机科学进行学习，才有可能成为好的程序员。数学家所用的语言，比起常见的程序语言（比如C++，Java）来说，其实是非常落后而糟糕的设计。所谓“数学的美感”，其实大部分是夜郎自大。99% 的数学家都写不出像样的代码。
　　数学是异常糟糕的语言
　　这并不是危言耸听。如果你深入研究过程序语言的理论，就会发现其实数学家们使用的那些符号，只不过是一种非常糟糕的程序语言。数学的理论有些是有用的，然而数学家门用于描述这些理论所用的语言，却是纷繁复杂，缺乏一致性，可组合性（composability），简单性，可用性。这也就是为什么大部分人看到数学就头痛。这不是他们不够聪明，而是数学语言的“设计”有问题。人们学习数学的时候，其实只有少部分时间在思考它的精髓，而大部分时间是在折腾它的语法。
　　举一个非常简单的例子。如果你说x-1表示x的-1 次方（x的倒数），那么f-1表示什么？f的-1 次方，f的倒数？别被数学老师们的教条和借口欺骗啦，他们总是告诉你：“你应该记住这些！” 可是你想过吗：“凭什么！” x-1表示x的-1 次方，而f-1，明明是一模一样的形式，表示的却是函数f的反函数。一个是求幂，一个是反函数，风马不及，却写成一个样子。这样的语言设计混淆不堪，却喜欢以“约定俗成”作为借口。
　　如果你再多看一些数学书，就会发现这只是数学语言几百年累积下来的糟粕的冰山一角。数学书里尽是各种上标下标，带括号的上标下标，x，y，z，a，b，c，f，g，h，各种扭来扭去的希腊字母，希伯来字母…… 斜体，黑体，花体，双影体，……用不同的字体来表示不同的“类型”。很多符号的含义，在不同的子领域里面都不一样。有些人上一门数学课，到最后还没明白那些符号是什么意思。
　　很多人学习微积分都觉得困难，其实问题不在他们，而在于莱布尼兹（Leibniz）。莱布尼兹设计来描述微积分的语言（∫，dx， dy， …），从现代语言设计的角度来看，其实非常之糟糕，可以说是一塌糊涂。我不能怪莱布尼兹，他毕竟是几百年前的人了，他不知道我们现在知道的很多东西。然而古人的设计，现在还不考虑改进，反而当成教条灌输给学生，那就是不思进取了。
　　数学的语言不像程序语言，它的历史太久，没有经过系统的，考虑周全的，统一的设计。各种数学符号的出现，往往是历史上某个数学家有天在黑板上随手画出一些古怪的符号，说这代表什么，那代表什么，…… 然后就定下来了。很多数学家只关心自己那块狭窄的子领域，为自己的理论随便设计出一套符号，完全不管这些是否跟其它子领域的符号相冲突。这就是为什么不同的数学子领域里写出同样的符号，却可以表示完全不同的涵义。在这种意义上，数学的语言跟 Perl（一种非常糟糕的程序语言）有些类似。Perl
 把各种人需要的各种功能，不加选择地加进了语言里面，造成语言繁复不堪，甚至连 Perl 的创造者自己都不能理解它所有的功能。
　　数学的证明，使用的其实也是极其不严格的语言——古怪的符号，加上含糊不清，容易误解的人类语言。如果你知道什么是 Curry-Howard Correspondence 就会明白，其实每一个数学证明都不过是一段代码。同样的定理，可以有许多不同版本的证明（代码）。这些证明有的简短优雅，有的却冗长繁复，像面条一样绕来绕去，没法看懂。你经常在数学证明里面看到“未定义的变量”，证明的逻辑也包含着各种隐含知识，思维跳跃，非常难以理解。很多数学证明，从程序的观点来看，连编译都不会通过，就别提运行了。
　　数学家们往往不在乎证明的优雅性。他们认为只要能证明出定理，你管我的证明简不简单，容不容易看懂呢。你越是看不懂，就越是觉得我高深莫测！这种思潮到了编程的时候就显出弊端了。数学家写代码，往往忽视代码的优雅性，简单性，模块化，可读性，性能，数据结构等重要因素，认为代码只要能算出结果就行。他们把代码当成跟证明一样，一次性的东西，所以他们的代码往往不能满足实际工程的严格要求。
　　编程是一门艺术
　　从上面你也许已经明白了，普通程序员使用的编程语言，就算是 C++ 这样毛病众多的语言，其实也已经比数学家使用的语言高明很多。计算机科学并不是数学的一个分支，它在很大程度上是优于数学，高于数学的。有些数学的基本理论可以被计算机科学所用，然而计算机科学并不是数学的一部分。数学在语言方面带有太多的历史遗留糟粕，它其实是泥菩萨过河，自身难保，它根本解决不了编程中遇到的实际问题。
　　编程真的是一门艺术，因为它符合艺术的各种特征。艺术可以利用科学提供的工具，然而它却不是科学的一部分，它的地位也并不低于科学。和所有的艺术一样，编程能解决科学没法解决的问题，满足人们新的需求，开拓新的世界。所以亲爱的程序员们，别再为自己不懂很多数学而烦恼了。数学并不能帮助你写出好的程序，然而能写出好程序的人，却能更好的理解数学。我建议你们先学编程，再去看数学。

本文最初发表在 王垠的博客，文章内容属作者个人观点，不代表本站立场。



版权声明：本文为博主原创文章，未经博主允许不得转载。

websocket+webrtc+tomcat 实现视频监考功能


         最近几天笔试，发现好多的线上笔试都会有视频监考的功能，个人对其挺感兴趣，所以花了一天时间，研究了一下，写了一个小demo，下面说的有任何纰漏希望大家多多指正，下面开说了，大多数的视频监考就是通过浏览器，获取你电脑上的摄像头，来实现视频监考的功能的，所以相当于你的电脑是客户端，而公司那边是服务器，所以这大体上是一个客户端服务器模式，但是要通过浏览器来做客户端，通过浏览器来做服务端，这时候就要涉及到浏览器和浏览器之间的通信了，但是浏览器和浏览器之间直接通信比较困难，所以还是要用一个中间服务器来做转发，通过中间服务器做好连接后，那么在通信过程中，就是浏览器之间端到端的交互了，就不需要服务器的干预了。

        要实现浏览器器端到端的通信，要用到两项技术一项是webSocket，一项是webRTC，websocket是浏览器和中间服务器做交互的手段，而webRTC是获取视频流和音频流的手段，首先一个浏览器A和一个浏览器B，要做交互，肯定得通过中间服务器C，所以浏览器A和中间服务器C会建立一个连接，而浏览器B和中间服务器同时也会建立一个连接，如果说浏览器A要向浏览器B发送一个字符串，那么A先要通过websocket把字符串发送到中间服务器，而中间服务器会找到，浏览器B对应的webSocket对象，通过这个对象把字符串发送给浏览器B，这就完成了浏览器A与B之间的交互，那么浏览器A与浏览器B之间要建立一个端到端的连接是需要通过这样的方式来实现的。
        上面讲述了，两个浏览器之间的交互过程，对于websocket的知识大家可以上网看看，上面只是基本原理。下面看看webRTC是怎么工作的，在HTML5中，我们可以通过js代码获取到我们本地的视频流，但是我们本地的视频流不是给我们自己看的，是给监考的公司看的，所以我们需要在浏览器之间建立连接，然后把视频流发送过去。这个连接就是webRTC的核心东西了，在浏览器中可以用js代码新建一个WEBRTC的连接，var pc = new webkitRTCPeerConnection(iceServer);
 这条语句就是建立一个连接，也就是代表这个浏览器，那么在另一个浏览器中，我们同样可以建立这样一个连接，但是这连个连接是独立的，他们像是两根管道，这时候需要我们把它链接起来。
        这时A要监考B具体过程如下：
         首先交换浏览器之间的描述信息，像是ip，端口，视频信息，等等的一些信息，这统称为描述信息，那么两个浏览器都有描述信息，首先浏览器A主动向B发起连接，A首先把自己的描述信息（localDescription）加入自己的连接，然后A向B发送一个offer包，这个发送是通过websocket来发送的，发送到服务器，然后服务器转发到B，B收到以后通过offer包可以获得B的描述信息，B把收到的远程描述信息（remoteDescription）加入自己的连接，然后再把自己的本地描述信息，放入自己的连接，再向A发送一个answer包，A接收到answer包以后，可以获得B的描述信息了，这时把B的描述信息，加入到自己的连接中，这样两个浏览器都包含有对方的描述信息，这样就基本完成了两个浏览器之间的连接，接下来就是其他信息的以下交互，主要是为了不仅仅能够在局域网内建立连接，在这些交互做完以后，那么B把自己的视频流加到连接里，这样在A就可以获取视频流了，然后整个通信过程就不需要webSocket的参与了，只是在B下线或者是A下线的时候，或通知中间服务器删除对应的连接。
        下面是我的主要代码：
        服务器java代码，处理浏览器的登录退出，以及消息的转发：
      
public class Admin extends StreamInbound{

	@Override
	protected void onBinaryData(InputStream arg0) throws IOException {
		// TODO Auto-generated method stub
		
	}

	@Override
	protected void onTextData(Reader ir) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader br=new BufferedReader(ir);
		//char[] buf=new char[2000];
		//char[] sbuf=new char[6000];
		//StringBuilder sb=new StringBuilder();
		/*int n=0;
		int index=0;
		while((n=ir.read(buf))>0){
		   System.arraycopy(buf, 0, sbuf, index, n);
		   Arrays.fill(buf, '0');
		   index+=n;
		}*/
		StringBuilder sb=new StringBuilder();
		String temp=null;
		while((temp=br.readLine())!=null){
			sb.append(temp);
		}
		//String[] test=sb.toString().split("\r\n");
		//StringBuilder sb2=new StringBuilder();
		//for(int i=0;i<test.length;i++){
		//  	sb2.append(test[i]);
		//}
		//System.out.println(test.length);
		//System.out.println(sb.toString());
		//System.out.println("转发给了客户端");
		//转发给客户端
		//ConnectionPool.getAdmin().getWsOutbound().writeTextMessage(CharBuffer.wrap(sb.toString().toCharArray()));
	    Map<Long,StreamInbound> map=ConnectionPool.getClientMap();
	    for(Map.Entry<Long, StreamInbound> entry:map.entrySet()){
	    	System.out.println("fawegawergawrehgeahtresathresathreshtrehsr");
	    	
	    	entry.getValue().getWsOutbound().writeTextMessage(CharBuffer.wrap(sb.toString()));
	    }
	}

	@Override
	protected void onClose(int status) {
		// TODO Auto-generated method stub
		//super.onClose(status);
		System.out.println(status);
		if(ConnectionPool.logout()){
		   System.out.println("服务端出去了");
		}else{
			System.out.println("当前没有服务端不能登出");
		}
	}

	@Override
	protected void onOpen(WsOutbound outbound) {
		// TODO Auto-generated method stub
		//super.onOpen(outbound);
		if(ConnectionPool.login(this)){
		   System.out.println("服务端进来了");
		}else{
			System.out.println("当前已有管理员");
		}
	}
	
	

}



public class Server extends WebSocketServlet{
	
	@Override
	protected StreamInbound createWebSocketInbound(String arg0,
			HttpServletRequest req) {
		// TODO Auto-generated method stub
		String info=req.getParameter("info").trim();
		if(info.equals("client")){
			return new Mession(System.currentTimeMillis());
		}else{
			return new Admin();
		}
	}

}public class Mession extends StreamInbound{
	
	private long time;
	public Mession(long time){
		this.time=time;
	}
	
	@Override
	protected void onBinaryData(InputStream arg0) throws IOException {
		System.out.println("get");
		
	}

	@Override
	protected void onTextData(Reader ir) throws IOException {
		/*char[] buf=new char[2000];
		StringBuilder sb=new StringBuilder();
		int n=0;
		while((n=ir.read(buf))>0){
		  
		   sb.append(buf,0,n);
		   Arrays.fill(buf, ' ');
		}*/
		//char[] buf=new char[2000];
		//char[] sbuf=new char[6000];
		//StringBuilder sb=new StringBuilder();
		/*int n=0;
		int index=0;
		while((n=ir.read(buf))>0){
		   System.arraycopy(buf, 0, sbuf, index, n);
		   Arrays.fill(buf, '0');
		   index+=n;
		}*/
		BufferedReader br=new BufferedReader(ir);
		String temp=null;
		StringBuilder sb=new StringBuilder();
		while((temp=br.readLine())!=null){
			sb.append(temp);
		}
		//String[] test=sb.toString().split("\r\n");
		//StringBuilder sb2=new StringBuilder();
		//System.out.println(sb.toString().leng);
		//for(int i=0;i<test.length;i++){
		//  	sb2.append(test[i]);
		//}
		//System.out.println(sb.toString());
		//System.out.println("转发给了客户端");
		//String message=sb.toString();
		
		//转发给服务器
		ConnectionPool.getAdmin().getWsOutbound().writeTextMessage(CharBuffer.wrap(sb.toString()));
		
	}

	@Override
	protected void onClose(int status) {
		// TODO Auto-generated method stub
		//super.onClose(status);
		//移除连接
		ConnectionPool.removeConnection(time);
		System.out.println("connection has closed!!!");
	}

	@Override
	protected void onOpen(WsOutbound outbound) {
		// TODO Auto-generated method stub
		//super.onOpen(outbound);
		//把连接放入池中
		ConnectionPool.addConnection(time, this);
		try {
			System.out.println("向客户端发送了数据");
			outbound.writeTextMessage(CharBuffer.wrap("hello".toCharArray()));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		System.out.println("connection open!!!");
	}
	
	

}
public class ConnectionPool {

	private final static Map<Long,StreamInbound> connections=new HashMap<Long,StreamInbound>();
	
	private static StreamInbound admin=null;
	
	public static Map<Long,StreamInbound> getClientMap(){
		return connections;
	}
	
	public static StreamInbound getAdmin(){
		return admin;
	}
	public static boolean login(StreamInbound admin){
		if(ConnectionPool.admin==null){
			ConnectionPool.admin=admin;
			System.out.println(ConnectionPool.admin.getReadTimeout());
			return true;
		}else{
			return false;
		}
	}
	
	public static boolean logout(){
		if(ConnectionPool.admin==null){
			return false;
		}else{
			ConnectionPool.admin=null;
			return true;
		}
	}
	
	public static void addConnection(long time,StreamInbound connection){
		connections.put(time, connection);
		System.out.println("加入连接");
	}
	
	public static void removeConnection(long time){
		connections.remove(time);
		System.out.println("移动出连接");
	}
	

}

下面是前段js代码和html代码：

server.html

<html>
  <head>
    <title>server</title>
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	<meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
	<meta http-equiv="description" content="This is my page">
	<!--
	<link rel="stylesheet" type="text/css" href="styles.css">
	-->
	<script type="text/javascript">
	   
	 
	function onOpen(event) {
	      document.getElementById('messages').innerHTML
	        = 'Connection established';
	    }
	 
	    function onError(event) {
	    	 document.getElementById('messages').innerHTML
		        += '<br/>'+event.data;
	    }
	    function start() {
	        var webSocket =new WebSocket("ws://localhost:8888/WS/wstest?info=admin");
	  
	 	    webSocket.onopen = function(event) {
	 	      onOpen(event);
	 	    };
	 	    
	 	    webSocket.onerror = function(event) {
	 		      onError(event);
	 		};
	 		
	 		webSocket.onclose=function(event){
	 			//document.getElementById('messages').innerHTML
		        //+= '<br/>'+str(event.data);
		        alert(event.data);
	 		}
	 		 var iceServer = {
	 	            "iceServers": [{
	 	                "url": "stun:stun.l.google.com:19302"
	 	            }]
	 	        };
	        // 创建PeerConnection实例 (参数为null则没有iceserver，即使没有stunserver和turnserver，仍可在局域网下通讯)
	        var pc = new webkitRTCPeerConnection(iceServer);

	        // 发送ICE候选到其他客户端
	       

	        // 如果检测到媒体流连接到本地，将其绑定到一个video标签上输出
	        pc.onaddstream = function(event){
	        	//alert("检测到流");
	            document.getElementById('remoteVideo').src = webkitURL.createObjectURL(event.stream);
	        };

	        // 发送offer和answer的函数，发送本地session描述
	        /*var sendOfferFn = function(desc){
	        	
	            alert(desc.sdp)
	        	//pc.setRemoteDescription(desc);
	           // pc.setLocalDescription(desc);
	            
	            webSocket.send(JSON.stringify({ 
	                "event": "_offer",
	                "data": {
	                    "sdp": desc
	                }
	            }));
	        };*/
	        
	        pc.onicecandidate = function(event){
	            if (event.candidate !== null) {
	                webSocket.send(JSON.stringify({
	                    "event": "_ice_candidate",
	                    "data": {
	                        "candidate": event.candidate
	                    }
	                }));
	            }
	        };
	        var sendAnswerFn = function(desc){
	        
	            pc.setLocalDescription(desc);
	            webSocket.send(JSON.stringify({ 
	                "event": "_answer",
	                "data": {
	                    "sdp": desc
	                }
	            }));
	        };

	        // 获取本地音频和视频流
	       /* navigator.webkitGetUserMedia({
	            "audio": true,
	            "video": true
	        }, function(stream){
	            //绑定本地媒体流到video标签用于输出
	           // document.getElementById('localVideo').src = URL.createObjectURL(stream);
	            //向PeerConnection中加入需要发送的流
	            pc.addStream(stream);
	            //如果是发起方则发送一个offer信令
	            
	            pc.createOffer(sendOfferFn, function (error) {
	               console.log('Failure callback: ' + error);
	            });
	            
	        }, function(error){
	            //处理媒体流创建失败错误
	            console.log('getUserMedia error: ' + error);
	        });
            */
	        //处理到来的信令
	        webSocket.onmessage = function(event){
	        	//alert(event.data)
	        	//document.getElementById('messages').innerHTML
		        //+= '<br/>'+event.data;
		        var jsonstr="'"+event.data+"'"
	            var json = JSON.parse(event.data);
	            console.log('onmessage: ', json);
	            //如果是一个ICE的候选，则将其加入到PeerConnection中，否则设定对方的session描述为传递过来的描述
	            
	            if( json.event == "_ice_candidate" ){
	            	//alert("收到候选");
	                pc.addIceCandidate(new RTCIceCandidate(json.data.candidate));
	               
	            } else {
	               
                   if(json.event == "_offer") {
		               pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp),function(){
		               //pc.setRemoteDescription(null,function(){   
		            	   pc.createAnswer(sendAnswerFn, function (error) {
		                    	alert(error);
		                        console.log('Failure callback: ' + error);
		                    });
		               },function(){
		            	    alert("error");
		                	pc.createAnswer(sendAnswerFn, function (error) {
		                    	alert("error");
		                        console.log('Failure callback: ' + error);
		                    });
		                });
		               
	               }
	               
	               //  pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp,function(){
	                //	alert(1);
	                //}));
	               //  if (isRTCPeerConnection)  
                    //  pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp));  
                  // else  
                   //   pc.setRemoteDescription(pc.SDP_OFFER,  
                    //        new SessionDescription(json.data.sdp.sdp)); 
	               //pc.setRemoteDescription(new RTCSessionDescription(pc.SDP_OFFER,json.data.sdp));
	               //pc.SDP_OFFER
	                //pc.setRemoteDescription(pc.SDP_OFFER,new SessionDescription(json.data.sdp.sdp));
	                // 如果是一个offer，那么需要回复一个answer
	               /* if(json.event == "_offer") {
	                	alert(json.event)
	                    pc.createAnswer(sendAnswerFn, function (error) {
	                    	document.getElementById('messages').innerHTML
	        		        += '<br/>'+error;
	                        console.log('Failure callback: ' + error);
	                    });
	                }*/
	            }
	        };
	    }
	</script>
  </head>
      
  <body>
    <input type="submit" value="Adminlogin" onclick="start()">
    <div id="messages">
    </div>
    <video id="remoteVideo" autoplay="autoplay"></video>
    <video id="localVideo" autoplay></video>
    
  </body>
</html>

contronlled.html


<html>
  <head>
    <title>client</title>
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	<meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
	<meta http-equiv="description" content="This is my page">
	<!--
	<link rel="stylesheet" type="text/css" href="styles.css">
	-->
	<script type="text/javascript">
	    function onOpen(event) {
	      document.getElementById('messages').innerHTML
	        = 'Connection established';
	    }
	 
	    function onError(event) {
	    	 document.getElementById('messages').innerHTML
		        += '<br/>'+event.data;
	    }
	    
	    
	    function start() {
	        var webSocket =new WebSocket("ws://localhost:8888/WS/wstest?info=client");
	 	    webSocket.onopen = function(event) {
	 	      onOpen(event);
	 	    };
	 	 
	 	    webSocket.onerror = function(event) {
	 		      onError(event);
	 		};
	 		webSocket.onclose=function(event){
	 			//document.getElementById('messages').innerHTML
		        //+= '<br/>'+str(event.data);
	 		    alert(event.data)
	 		}
	 		var iceServer = {
	 	            "iceServers": [{
	 	                "url": "stun:stun.l.google.com:19302"
	 	            }]
	 	        };
	        // 创建PeerConnection实例 (参数为null则没有iceserver，即使没有stunserver和turnserver，仍可在局域网下通讯)
	        var pc = new webkitRTCPeerConnection(iceServer);

	       

	        // 发送offer和answer的函数，发送本地session描述
	        var sendOfferFn = function(desc){
	        	
	            pc.setLocalDescription(desc);
	            webSocket.send(JSON.stringify({ 
	                "event": "_offer",
	                "data": {
	                    "sdp": desc
	                }
	            }));
	        };
	        
	        pc.onicecandidate = function(event){
	            if (event.candidate !== null) {
	                webSocket.send(JSON.stringify({
	                    "event": "_ice_candidate",
	                    "data": {
	                        "candidate": event.candidate
	                    }
	                }));
	            }
	        };
	        
	        
	     // 获取本地音频和视频流
	        navigator.webkitGetUserMedia({
	            "audio": true,
	            "video": true
	        }, function(stream){
	            //绑定本地媒体流到video标签用于输出
	           //document.getElementById('localVideo').src = URL.createObjectURL(stream);
	            //向PeerConnection中加入需要发送的流
	            pc.addStream(stream);
	            //如果是发起方则发送一个offer信令
	            pc.createOffer(sendOfferFn, function (error) {
		               console.log('Failure callback: ' + error);
		            });
	        }, function(error){
	            //处理媒体流创建失败错误
	            console.log('getUserMedia error: ' + error);
	        });

	        //处理到来的信令
	        webSocket.onmessage = function(event){
	        	//alert(event.data);
	        	//document.getElementById('messages').innerHTML
		       // += '<br/>'+event.data;
		        var jsonstr="'"+event.data+"'";
	            var json = JSON.parse(event.data);
	            
	            console.log('onmessage: ', json);
	            
	            //如果是一个ICE的候选，则将其加入到PeerConnection中，否则设定对方的session描述为传递过来的描述
	            if( json.event == "_ice_candidate" ){
	            	
	                pc.addIceCandidate(new RTCIceCandidate(json.data.candidate));
	            } else {
	            	//接收到确认符号
	            	if(json.event == "_answer"){
		            	pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp),function(){},function(){});
		            	 // 发送ICE候选到其他客户端
	            	}
	            }
	        };
	    }
	</script>
  </head>
      
  <body>
    <input type="submit" value="clientLogin" onclick="start()">
    <div id="messages">
    </div>
    <video id="remoteVideo" autoplay></video>
   <video id="localVideo" autoplay></video>
  </body>
</html>

上面就是主要的代码了：具体运行流程把这些代码部署到tomcat上，打开监控端浏览器中输入http://localhost:8888/WS/server.html，打开被监控端http://localhost:8888/WS/controlled.html，然后点击监控页面中的AdminLogin按键，先让监控端注册到中间服务器上面，然后点击被监控端的clientLogin按键，然后后浏览器会询问时候开启摄像头，点击开启，等待1到3秒在监控端就可以出现视频画面了。

下面是效果演示图：
        



版权声明：本文为博主原创文章，未经博主允许不得转载。

当前浏览器对HTML5支持状况(全平台)
题记
HTML5test 这个网站专门测试浏览器对HTML5支持状况,只要你的浏览器打开HTML5test这个页面,就会得到一个测评的分数,然后会列出你当前浏览器对哪些特性支持良好,哪些不支持

简易测试
如图:
360极速浏览器测试的(内核是chromium 42) – 极速模式;

我稍微看了下不支持的特性…都是比较少用到的特性…. 所以总体来说,在H5和CSS3下的体验是相当良好的
而我本地的chrome 43 的分数才521 . 还少了两分,可能优化还没做好….最新的44版本,526,在所有浏览器中,对HTML5支持是最为完善的;
IE11和edge(WIN 10下的),我测试了下,,对HTML5的支持还是比较完善的;尤其是EDGE,简直升了一个台阶(相对于IE系列);
IE11:

EDGE

其他的不多说,直接上数据图!!!;

数据对比
PC端


其中支持最为完善是chrome系列
opera改为chromium内核了..所以分数基本一致
出乎意料的是Firefox,W3C标准一直都在最前沿的,对H5的支持竟然不是最高的!!!
IE10以下,H5的体验就差强人意了…只能支持一部分
Safari的老版本比IE老版本系列好太多….

平板


chrome依旧牛逼,稳居第一
其他的大同小异(IE除外)
不过最新的edge挺不错的,不管是移动端还是PC端…大跃进啊~~
所以移动端的兼容性比PC端要好上很多,各种特性任性用!!

手机端


手机端的各大系列浏览器支持都很不错…除了个别很老的系列…

总结

使用chrome系列或者chromium内核的浏览器对HTML5/CSS3支持是比较完善的,
而最新崛起的edge似乎更有看头,能不能消除IE系列的影响就看这货了…或许过上两年,WIN10的比重取代了WIN7的比重…那时候就可以任性的用最新特性写各种特效,各种更人性化的标签; 而不是现在的各种模拟,各种兼容
XP这货总会过去的,死磕怀旧的毕竟是少数,为了更好的体验,人总会往上看的!!

数据时间: 2015-8-24 
来源:  HTML5test

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 5410


CRB and His Birthday
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 625    Accepted Submission(s): 325



Problem Description

Today is CRB's birthday. His mom decided to buy many presents for her lovely son.
She went to the nearest shop with M Won(currency
 unit).
At the shop, there are N kinds
 of presents.
It costs Wi Won
 to buy one present of i-th
 kind. (So it costs k × Wi Won
 to buy k of
 them.)
But as the counter of the shop is her friend, the counter will give Ai × x + Bi candies
 if she buys x(x>0)
 presents of i-th
 kind.
She wants to receive maximum candies. Your task is to help her.
1 ≤ T ≤
 20
1 ≤ M ≤
 2000
1 ≤ N ≤
 1000
0 ≤ Ai, Bi ≤
 2000
1 ≤ Wi ≤
 2000


 


Input

There are multiple test cases. The first line of input contains an integer T,
 indicating the number of test cases. For each test case:
The first line contains two integers M and N.
Then N lines
 follow, i-th
 line contains three space separated integers Wi, Ai and Bi.


 


Output

For each test case, output the maximum candies she can gain.

 


Sample Input

1
100 2
10 2 1
20 1 1


 


Sample Output

21
HintCRB's mom buys 10 presents of first kind, and receives 2 × 10 + 1 = 21 candies. 


 


Author

KUT（DPRK）

 


Source

2015 Multi-University Training Contest 10

 


Recommend

wange2014

 




#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;
#define N 1005
#define INF 0x3f3f3f3f

int n, M, a[N], b[N], w[N];
int d[2 * N];

int main()
{
    int T;
    scanf("%d", &T);
    while(T--)
    {
        scanf("%d%d", &M, &n);
        for(int i = 1; i <= n; i++)
            scanf("%d%d%d", &w[i], &a[i], &b[i]);
            
        memset(d, 0, sizeof d);
        int ans = -INF;
        for(int i = 1; i <= n; i++)
            for(int j = M; j >= w[i]; j--)
                d[j] = max(d[j], d[j - w[i]] + a[i] + b[i]);

        for(int i = 1; i <= n; i++)
            for(int j = w[i]; j <= M; j++)
                d[j] = max(d[j], d[j - w[i]] + a[i]);
        printf("%d\n", d[M]);
    }
}

/*

1
100 2
10 2 1
20 1 1


*/



版权声明：本文为博主原创文章，未经博主允许不得转载。

windows下使用libsvm3.2

一、官方介绍

libsvm主页：https://www.csie.ntu.edu.tw/~cjlin/libsvm/index.html
libsvm介绍文档：http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf
官方关于更有效地使用libsvm的使用说明：http://www.csie.ntu.edu.tw/~cjlin/papers/guide/guide.pdf （非常有必要看）
数据库：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/
关于二分类的实例：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html
关于多分类实例：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multiclass.html
常见问答：http://www.csie.ntu.edu.tw/~cjlin/libsvm/faq.html   （这里可以帮你解决好多疑惑）
实用工具列表：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/ （guide提到的liblinear在此）


二、需要软件

libsvm-3.20：http://www.csie.ntu.edu.tw/~cjlin/libsvm/libsvm-3.20.zip
python-2.7.10：https://www.python.org/ftp/python/2.7.10/python-2.7.10.msi（调用python工具时使用）
gnuplot5.0.1：http://jaist.dl.sourceforge.net/project/gnuplot/gnuplot/5.0.1/gp501-win32-mingw.exe（用绘图展示整个搜索最佳参数过程）



三、训练过程说明
——（以后输入命令以.bat格式存储即可使用）

1、提取数据形式的特征：（类别标签　特征序号：特征值）
1 1:2.111 2:3.567 3:-0.125
．．．
0 1:2.156 2:3.259 3:0.258
．．．
分别将训练样本数据和测试样本数据存成名为train的文件和名为test的文件（仅为了方便区分）

2、对特征数据进行缩放（提高运算效率）
svm-scale -l -1 -u 1 -s rangetrain >train.scale （-1~1表示缩放范围 -l表low -u表up -s表save 将变换后区间存为range  train是原始特征数据 train.scale是缩放后的数据）
svm-scale -r range1test>test.scale（-r 表read 将test的数据按同一range进行缩放）
说明：区间[0,1]和[-1,1]的效果是一样的，只是[0,1]的运算效率更高

3、寻找最优c、g参数
python grid.pytrain.scale（运算结束后,会提供最优参数c和g.比如运算结果是2.0 1.0 96.8922，96.8922为交叉验证准确率）

4、使用最优参数进行训练
svm-train -c 2 -g1train.scale（会生成一个名为train.scale.model文件,文件参数说明见后续补充说明.这里我们使用了默认核函数RBF，一般RBF是效果最好的）

5、拿训练结果进行测试
svm-predict test.scale train.scale.model test.predict（得预测结果test.predict文件以及正确率）




四、补充说明：

1、修改交叉验证
svm-scale -l -1 -u 1 train >train.scale 
svm-train -v 6 train.scale（交叉验证是为了得到更好的参数）
python grid.pytrain.scale
svm-train -c 2 -g 2 train.scale

2、关于/libsvm-3.20/tools/中的easy.py和grid.py
安装完python和gnuplot后,将E:\Program Files\Python,F:\libsvm-3.20\windows,E:\Program Files\gnuplot\bin三个文件夹添加到系统路径里面,修改上两个py文件中关于libsvm的路径和gnuplot的路径.
easy.py中：gnuplot_exe = r"e:\Program Files\gnuplot\bin\gnuplot.exe"
grid.py中：#svmtrain_pathname = r'f:\libsvm-3.20\windows\svm-train.exe'
           self.gnuplot_pathname = r'e:\Program Files\gnuplot\bin\gnuplot.exe'
可以按照guide.pdf，用easy.py测试guide中的实例。guide中实验数据链接：http://www.csie.ntu.edu.tw/~cjlin/papers/guide/data/

3、关于model文件中的参数说明
svm_type c_svc   （svc表用SVM作分类器,svr表用SVM作回归,c_svc 表用异常值惩罚因子C进行不完全分类）
kernel_type rbf     （径向基核,对于大多数情况都是一个较好的选择:d(x,y) = exp(-gamma*|x-y|2））
gamma 0.03125 （核函数的参数）
nr_class 2 （类别数）
total_sv 287 （支持向量总数）
rho 102.102 （判决函数的常数项b）
label 1 0（类标签）
nr_sv 144 143（各个类中落在边界上的向量个数）
SV（SV下面枚举了所有的支持向量）
8192 1:-1 2:-0.688314 3:0.595954 4:0.416735
．．．


4、svmscale.exe参数说明
"-l lower
 : x scaling lower limit (default -1)\n"
"-u upper : x scaling upper limit (default +1)\n"
"-y y_lower y_upper : y scaling limits (default: no y scaling)\n"
"-s save_filename : save
 scaling parameters to save_filename\n"
"-r restore_filename : restore scaling parameters from restore_filename\n"


5、svmtrain.exe的参数列表
"-s svm_type : set type of SVM (default 0)\n"
" 0 -- C-SVC(multi-class classification)\n"
" 1 -- nu-SVC(multi-class classification)\n"
" 2 -- one-class SVM\n"
" 3 -- epsilon-SVR(regression)\n"
" 4 -- nu-SVR(regression)\n"
"-t kernel_type : set type of kernel function (default 2)\n"
" 0 -- linear: u'*v\n"
" 1 -- polynomial: (gamma*u'*v + coef0)^degree\n"
" 2 -- radial basis function: exp(-gamma*|u-v|^2)\n"
" 3 -- sigmoid: tanh(gamma*u'*v + coef0)\n"
" 4 -- precomputed kernel (kernel values in training_set_file)\n"
"-d degree : set degree in kernel function (default 3)\n"
"-g gamma : set gamma in kernel function (default 1/num_features)\n"
"-r coef0 : set coef0 in kernel function (default 0)\n"
"-c cost : set the parameter C of C-SVC, epsilon-SVR, and nu-SVR (default 1)\n"
"-n nu : set the parameter nu of nu-SVC, one-class SVM, and nu-SVR (default 0.5)\n"
"-p epsilon : set the epsilon in loss function of epsilon-SVR (default 0.1)\n"
"-m cachesize : set cache memory size in MB (default 100)\n"
"-e epsilon : set tolerance of termination criterion (default 0.001)\n"
"-h shrinking : whether to use the shrinking heuristics, 0 or 1 (default 1)\n"
"-b probability_estimates : whether to train a SVC or SVR model for probability estimates, 0 or 1 (default 0)\n"
"-wi weight : set the parameter C of class i to weight*C, for C-SVC (default 1)\n"
"-v n: n-fold cross validation mode\n"
"-q : quiet mode (no outputs)\n"



6、常用FAQ
Q1: Is there a program to check if my data are in the correct format? 
The svm-train program in libsvm conducts only a simple check of the input data. To do a detailed check, after libsvm 2.85, you can use the python script tools/checkdata.py. See tools/README for details.

Q2: The output of training C-SVM is like the following. What do they mean? 
optimization finished, #iter = 219 
nu = 0.431030 
obj = -100.877286, rho = 0.424632 
nSV = 132, nBSV = 107 
Total nSV = 132
obj is the optimal objective value of the dual SVM problem. rho is the bias term in the decision function sgn(w^Tx - rho). nSV and nBSV are number of support vectors and bounded support vectors (i.e., alpha_i = C). nu-svm is a somewhat equivalent form of C-SVM
 where C is replaced by nu. nu simply shows the corresponding parameter. More details are in libsvm document.

Q3: Should I use float or double to store numbers in the cache ? 
We have float as the default as you can store more numbers in the cache. In general this is good enough but for few difficult cases (e.g. C very very large) where solutions are huge numbers, it might be possible that the numerical precision is not enough using
 only float.

Q4: Does it make a big difference if I scale each attribute to [0,1] instead of [-1,1]? 
For the linear scaling method, if the RBF kernel is used and parameter selection is conducted, there is no difference. Assume Mi and mi are respectively the maximal and minimal values of the ith attribute. Scaling to [0,1] means
                x'=(x-mi)/(Mi-mi)
For [-1,1],
                x''=2(x-mi)/(Mi-mi)-1.
In the RBF kernel,
                x'-y'=(x-y)/(Mi-mi), x''-y''=2(x-y)/(Mi-mi).
Hence, using (C,g) on the [0,1]-scaled data is the same as (C,g/2) on the [-1,1]-scaled data.
Though the performance is the same, the computational time may be different. For data with many zero entries, [0,1]-scaling keeps the sparsity of input data and hence may save the time.

Q5: My data are unbalanced. Could libsvm handle such problems? 
Yes, there is a -wi options. For example, if you use
> svm-train -s 0 -c 10 -w1 1 -w-1 5 data_file
the penalty for class "-1" is larger. Note that this -w option is for C-SVC only.

Q6: How can I use OpenMP to parallelize LIBSVM on a multicore/shared-memory computer? 
It is very easy if you are using GCC 4.2 or after.
In Makefile, add -fopenmp to CFLAGS.
In class SVC_Q of svm.cpp, modify the for loop of get_Q to:
#pragma omp parallel for private(j) 
for(j=start;j<len;j++)
In the subroutine svm_predict_values of svm.cpp, add one line to the for loop:
#pragma omp parallel for private(i) 
for(i=0;i<l;i++)
kvalue[i] = Kernel::k_function(x,model->SV[i],model->param);
For regression, you need to modify class SVR_Q instead. The loop in svm_predict_values is also different because you need a reduction clause for the variable sum:
#pragma omp parallel for private(i) reduction(+:sum) 
for(i=0;i<model->l;i++)
sum += sv_coef[i] * Kernel::k_function(x,model->SV[i],model->param);
Then rebuild the package. Kernel evaluations in training/testing will be parallelized. An example of running this modification on an 8-core machine using the data set ijcnn1:
8 cores:
%setenv OMP_NUM_THREADS 8
%time svm-train -c 16 -g 4 -m 400 ijcnn1
27.1sec
1 core:
%setenv OMP_NUM_THREADS 1
%time svm-train -c 16 -g 4 -m 400 ijcnn1
79.8sec
For this data, kernel evaluations take 80% of training time. In the above example, we assume you use csh. For bash, use
export OMP_NUM_THREADS=8
instead.
For Python interface, you need to add the -lgomp link option:
$(CXX) -lgomp -shared -dynamiclib svm.o -o libsvm.so.$(SHVER)
For MS Windows, you need to add /openmp in CFLAGS of Makefile.win

Q7: How could I know which training instances are support vectors? 
It's very simple. Since version 3.13, you can use the function
void svm_get_sv_indices(const struct svm_model *model, int *sv_indices)
to get indices of support vectors. For example, in svm-train.c, after
model = svm_train(&prob, &param);
you can add
int nr_sv = svm_get_nr_sv(model);
int *sv_indices = Malloc(int, nr_sv);
svm_get_sv_indices(model, sv_indices);
for (int i=0; i<nr_sv; i++)
printf("instance %d is a support vector\n", sv_indices[i]);
If you use matlab interface, you can directly check
model.sv_indices

Q8: After doing cross validation, why there is no model file outputted ? 
Cross validation is used for selecting good parameters. After finding them, you want to re-train the whole data without the -v option.

Q9: How do I choose the kernel? 
In general we suggest you to try the RBF kernel first. A recent result by Keerthi and Lin ( download paper here) shows that if RBF is used with model selection, then there is no need to consider the linear kernel. The kernel matrix using sigmoid may not be
 positive definite and in general it's accuracy is not better than RBF. (see the paper by Lin and Lin ( download paper here). Polynomial kernels are ok but if a high degree is used, numerical difficulties tend to happen (thinking about dth power of (<1) goes
 to 0 and (>1) goes to infinity).

Q10: I press the "load" button to load data points but why svm-toy does not draw them ? 
The program svm-toy assumes both attributes (i.e. x-axis and y-axis values) are in (0,1). Hence you want to scale your data to between a small positive number and a number less than but very close to 1. Moreover, class labels must be 1, 2, or 3 (not 1.0, 2.0
 or anything else).


Q11：Feature selection tool
This is a simple python script (download 
here) to use F-score for selecting features. To run it, please put it in the sub-directory "tools" of LIBSVM.
Usage: ./fselect.py training_file [testing_file]
Output files: .fscore shows importance of features, .select gives the running log, and .pred gives testing results.
More information about this implementation can be found in Y.-W. Chen and C.-J. Lin,Combining SVMs with various feature selection strategies. To appear in the
 book "Feature extraction, foundations and applications." 2005. This implementation is still preliminary. More comments are very welcome.



Q12：Weights for data instances
Users can give a weight to each data instance. For LIBSVM users, please download the zip file (MATLAB and Python interfaces are included). You
 must store weights in a separated file and specify -W your_weight_file. This setting is different from earlier versions where weights are in the first column of training data.
1)Training/testing sets are the same as those for standard LIBSVM/LIBLINEAR.
2)We do not support weights for test data.
3)All solvers are supported.
4)Matlab/Python interfaces for both LIBSVM/LIBLIENAR are supported.



Q13：Binary-class Cross Validation with Different Criteria
参考文档：https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/eval/index.html

版权声明：本文为博主原创文章，未经博主允许不得转载。

Amazon EC2安装mysql多实例并配置主从复制
1、MySQL安装：
EC2直接使用yum安装mysql很方便：
yum install mysql mysql-server mysql-libs 
此处安装了三个包
完事之后可以直接使用 
service mysqld start 
启动mysql服务
修改root密码： 
mysqladmin -u root -p password “root”
2、使用mysqld_multi安装多实例mysql：
vim /etc/my.cnf  
添加实例的配置信息
[mysqld] 
datadir=/var/lib/mysql 
socket=/var/lib/mysql/mysql.sock 
symbolic-links=0
[mysqld_safe] 
log-error=/var/log/mysqld.log 
pid-file=/var/run/mysqld/mysqld.pid
以上是默认的配置信息，在mysqld下添加如下配置：
#开启慢查询日志， 记录查询过长的 sql 语句，以便于优化
log_slow_queries=/var/log/mysql/mysql-slow.log
#开启 bin-log 日志，不用log-bin=xxx，试验时这样子无法启动mysql服务，不知为何
log-bin
#分配serverid，不要和下面的从服务器冲突即可
server-id=1
在文件最后方添加：
[mysqld_multi] 
mysqld     = /usr/bin/mysqld_safe 
mysqladmin = /usr/bin/mysqladmin 
user       = root 
password   = root
#第二个mysql实例的配置
[mysqld1] 
socket     = /tmp/mysql1.sock 
port       = 3311 
pid-file   = /var/run/mysqld/mysqld1.pid 
log-slow-queries = /var/log/mysql1/slow-query-log   ## mysql slow log 
relay-log        = /var/spool/mysqld1/mysqld-relay-bin   ## relay for replication 
datadir    = /var/lib/mysql1    ## mysql data file folder 
user       = mysql 
log-bin 
server-id=2
保存退出之后执行 
mysql_install_db –user=mysql –datadir=/var/lib/mysql1 
完成第二个实例的初始化
启动该实例服务的方式为： 
mysqld_multi start 1
使用命令查看3311端口是否开启 
netstat -tunlp 
如果有则启动成功
登陆改实例 
mysql -S /tmp/mysql1.sock -uroot -p
修改root密码也要指定sock文件： 
mysqladmin -S/tmp/mysql1.sock -u root -p password “root”
这里用mysql -uroot -p -P3311登陆进去的还是默认的3306端口，所以使用上面的方式登陆
进去之后可以使用 
show variables like ‘%datadir%’; 
查看datadir是否是配置文件中的路径
3、配置主从复制
进入主数据库（默认的3306端口） 
mysql -uroot -proot
查看用户登陆信息 
select user,host from mysql.user;
设置root用户可以从任何地方登陆访问任何表 
grant all on . to root@’%’ identified by ‘root’ with grant option;、
新建一个用户backup用来给从数据库登陆，获取主数据库信息，密码也是backup（这里设置的登陆地址为localhost，如果从数据库在别的机器上需要修改为对应的IP） 
GRANT REPLICATION SLAVE ON . to ‘backup’@’localhost’ identified by ‘backup’; 
使用 
show variables like “%log_%”; 
查看二进制日志是否开启（配置文件中的log-bin），要使用主从复制一定要开启这个
使用 
show master status; 
查看主数据库信息 
File和Position 
这两个信息会在配置从数据库的时候用到
进入从库，执行下列命令进行主库信息配置
change master to master_host=’localhost’,master_user=’backup’,master_password=’backup’,master_log_file=’mysqld-bin.000003’,master_log_pos=107; 
master_host：主库地址（如果不是默认的3306可以使用master_port指定端口信息） 
master_user：上面配置的从库登陆主库的用户 
master_log_file：即主库show master status;中File的值 
master_log_pos：即主库show master status;中Position的值
出现下列错误信息： 
ERROR 1201 (HY000): Could not initialize master info structure; more error messages can be found in the MySQL error log
解决方法：
stop slave; 
reset slave; 
再次错误： 
ERROR 29 (HY000): File ‘/var/spool/mysqld1/mysqld-relay-bin.index’ not found (Errcode: 13)
创建对应的文件并修改权限 
sudo mkdir var/spool/mysqld1 
sudo touch /var/spool/mysqld1/mysqld-relay-bin.index 
sudo chown -R mysql:mysql   /var/spool/mysqld1/
再次reset slave即可
开启从库 
start slave; 
查看状态信息 
show slave status\G
其中的 
Slave_IO_Running: Yes 
Slave_SQL_Running: Yes 
两个必须都为Yes才是成功
若其中提示错误： 
Fatal error: The slave I/O thread stops because master and slave have equal MySQL server ids
则是serverid没配好，可以直接用命令改正
查看当前的server_id 
show variables like ‘server_id’;  
重新设置为其他值 
set global server_id=2; 
在重新启动slave即可
接下来就可以做一些测试工作了，在主库上建立新数据库或者新表或者添加修改记录都会同步到从库中
4、mysql其他一些异常的解决方法
使用mysql出现以下错误： 
mysqladmin: Can’t turn off logging; error: ‘Access denied; you need the SUPER privilege for this operation’的错误
解决方法： 
vim /etc/my.cnf
加入 
skip-grant-tables 
重启服务
进入mysql
use mysql; 
UPDATE user SET Password = password ( ‘pwd’ ) WHERE User = ‘root’ ; 
flush privileges ;
退出之后 
my.cnf改回来 
重启服务
如果没有效果的话 
卸载mysql：
卸载yum -y remove mysql* 
查看是否安装yum list installed mysql* 
删除mysql相关目录 
rm -rf /etc/my.cnf 
rm -rf /var/lib/mysql
之后重新安装mysql
远程登录： 
出现错误 
Host ‘117.29.168.34’ is not allowed to connect to this MySQL server
解决方法： 
root登陆mysql 
执行： 
use mysql; 
update user set host = ‘%’ where user=’root’; 
 flush privileges; 

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

机器学习算法面试—口述（2）：Adaboost算法及常见问题


这个系列是为了应对找工作面试时面试官问的算法问题，所以只是也谢算法的简要介绍，后期会陆续补充关于此算法的常见面试的问题！



AdaBoost是一种迭代算法，针对同一训练集训练处不同的分类器（弱分类器），将前面训练的分类器以某种方式组合起来，组合成一个强分类器。算法是通过改变数据的分布来实现的。每次训练分类器是参考
1、某样本在上个分类器的分类过程中是否被正确分类
2、上个分类器的准确率
AdaBoost是Adaptive Boosting的缩写，Adaptive在于：前一个分类器分错的样本会得到增强，加强后的全体样本会用于下一次分类器的训练，每一轮加入一个新的弱分类器，知道达到某个预定的足够小的的错误率或达到预定的最大迭代次数。
具体点说，AdaBoost的步骤如下：
1、初始化训练数据的权值分布。开始时，权重都赋予一样；
2、训练弱分类器。如果某个样本正确分类，那么其在下一次的分类过程中的权值会被降低，反之则会升高
3、组合成强分类器。增大分类效果好的分类器占的权重，降低分类效果差的分类器占的权重。


（当然，上面的都是一些文字性的东西，比较抽象，比如增大权重到底是怎么做的，这就需要记忆一些公式了）
详细步骤：
1、训练集：(x1, y1), (x2, y2),......, (xn, yn)；刚开始每个样本都赋予一个等值的权重1/n;
2、使用一些特征，得到一个基本分类器，计算其分类的错误率：e = 错误分类 / 样本数，根据得到的错误率可以计算这个分类器在最终的分类中占的权重：a = 1/2 * ln((1-e) / e)；
3、更新数据的权值分布（刚开始时都为1 / n)；



由（2）知e < 0.5，则a > 0，如果错误分类指数a次方大于1，则下次训练时样本的权重会增大，正确分类样本的权值下次会变小。
之后再组合得到的各个弱分类器



从这个式子也可以看出前面（3）中说的增大分类效果好的分类器占的权重，降低分类效果差的分类器占的权重。错误率e越小，a越大，也即在整个分类中占的权重越大。
其实AdaBoost的主要问题在于如何得到各个弱分类器，这就需要对问题有一个充分的理解，弱分类器的获得可以是一些特征的组合得到的结果，也可以是单个特征的结果！一般开始做的时候是将一些强特征或其组合来获得分类器（比如区分人种用肤色这个强特征）。


版权声明：本文为博主原创文章，未经博主允许不得转载。

不想做电视的厨子不是好司机，行业真的“零门槛”？

    电视行业近年来的发展势头不输于智能手机，同后者一样，越来越多企业正视图介入这一领域，除老牌厂商之外，像联想、PPTV甚至是暴风影音都推出了自家的电视，更有像17TV、微鲸电视等名不见经传的产品。每个企业都试图在电视行业分一杯羹，难道电视行业真的已经“零门槛”？




    企业“触电”的几种心态？




    不同企业做智能电视的心态有所不同，在笔者看来，目前进军智能电视领域的企业主要有以下三类，第一类是传统电视厂商；第二类是互联网企业；第三类是手机、PC类硬件厂商。




    传统电视厂商进军智能电视领域很容易理解，毕竟随着行业的变革，传统电视正遭遇越来越大的挑战，这就如同智能手机淘汰功能手机一样。而互联网企业做智能电视的动机主要在于延续其内容和互联网服务的优势，通过智能电视提升用户粘度，实现价值增长。至于手机、PC类硬件厂商，他们做智能电视的主要目的是丰富产品线，从单一终端向多终端的方向迈进。




    不过，在智能电视领域，除极少数企业已经做得比较成熟之外，绝大多数企业仍处于“浑水摸鱼”的阶段。他们对智能电视的理解并不深入，盲目的认为植入一个安卓系统就是智能电视，结果过早的投入这一领域不仅没有获得市场的认可，反而提前透支了未来。因为当市场不接受某个品牌的智能电视时，未来即便他们推出升级产品也很难博得市场的认可。另外，虽然部分厂商已经在积极构筑生态体系，但绝大多数企业的生态体系离成熟仍然遥远。




    智能电视的行业门槛在哪里？




    在上述背景下，智能电视行业出现了前所未有的“混乱”局面，部分厂商为了尽快从激烈的竞争中脱颖而出，选择了打价格战而不是提升产品品质来增强核心竞争力。部分刚推出产品的新兴厂商甚至呈现出咄咄逼人的态势，大有将老牌厂商拍死在沙滩上的意思，那么这种观念对整个电视行业有何影响呢？智能电视的行业门槛又在哪里呢？




    诚然，诸如长虹这种老牌的电视厂商近年来确实遭遇了巨大的挑战，其原因在于老牌厂商对智能电视的行业发展趋势并不敏感，一味的抱残守缺必然会落后于整个时代。但另一方面，老牌厂商也有他们的优势，他们的生产技术及硬件资源储备是后来者很难赶超的，所以，我们看到部分互联网企业也选择和传统电视厂商合作，整合双方优势，共同打造出优质的产品。




    所以，归结起来智能电视的行业门槛主要在于硬件和软件两个层面，硬件指的是产品的硬件配置、外形设计、做工水平等等。软件则指的是操作系统、内容资源、软件资源、用户体验等等。必须同时在两个层面都表现优秀的产品才能在激烈的市场角逐中胜出。




    国内电视厂商应该多学三星电视




    在笔者看来，国内电视厂商在很多方面仍存在不足和欠缺，最为严重的一个问题是，国内电视厂商无论在软件还是硬件方面，大多都缺乏创新与颠覆，没有拿得出手的东西。以智能手机为例，绝大多数厂商主要是靠模仿和借鉴来做产品，通过低价格切入市场，这种策略显然不是核心竞争力的体现，在电视行业我们也能得出相同的结论。因此，在笔者看来，国内电视厂商应该多学学三星电视，这怎么说？




    首先，虽然三星电视已经做得非常优秀，但它仍在不断的寻求创新和突破，不仅在电视的设计和做工上寻求完美，更是通过曲面屏开启了一个全新的时代。另外，在系统层面，众所周知，2015年所有的三星Smart TV都将搭载Tizen操作系统。基于Tizen系统，三星将基于Smart TV平台打造出集应用、系统、标准、服务多位一体的生态体系，最大程度优化产品的用户体验。




    通过上面的分析我们不难看出，未来智能电视的竞争将会是全方位的，除设计和做工之外，技术层面也非常重要。谁能在技术层面投入更多，谁就更有机会占领技术制高点，值得一提的是，三星集团每年投入大量资金进行新技术的研发，强大的技术储备也让三星在智能电视方面拥有了很多傲人的资本，这一点也非常值得国内电视厂商学习。




    再者，在营销方面，三星具备强大的全球营销能力，对智能电视这一新兴产品而言，三星的这种营销能力同样会起到推波助澜的作用。凭借在营销层面的创新和突破，三星电视将拥有更强大的品牌号召力和更高的品牌附加值。

版权声明：本文为博主原创文章，未经博主允许不得转载。

linux 开启独立iptables日志
系统日志配置在CentOS5上叫syslog，而在CentOS6上叫rsyslog，叫增强版的syslog，CentOS5上的配置文件在/etc/syslog.conf下，而CentOS6在/etc/rsyslog.conf下




1. 在rsyslog.conf 添加配置
 /etc/rsyslog.conf中添加不同的日志级别（默认warn(=4））

kern.warning 
    /var/log/iptables.log
kern.debug 
      /var/log/iptables.log

kern.info 
       /var/log/iptables.log
不过推荐全部日志都记录：
  kern.*     /var/log/iptables.log
重启日志配置： /etc/init.d/rsyslogd restart




2. 让日志滚动，这一步是可选的

 vim /etc/logrotate.d/syslog

加入/var/log/iptables









3. 在iptables添加日志选项 

iptables -A INPUT  -j LOG --log-prefix "iptables"

这样就可以记录所有的记录了，只要通过了防火墙都会记录到日志里

iptables -A INPUT  -p tcp -j LOG --log-prefix "iptables icmp warn"


这样就只记录tcp日志

然后保存并重启防火墙配置

iptables-save

iptables-restart












版权声明：本文为博主原创文章，未经博主允许不得转载。

Ubuntu14.04 64 安装nginx之  缺少 libpcre.so.1
安装步骤同12.04
在64位机子上安装nginx以后，运行时提示：


我们安装pere库以后，这个文件在 cd /usr/local/lib/这个目录下，
网上有人说对于64位的机子来说要创建软链接：
sudo  ln -s /usr/local/lib/libpcre.so.1 /lib64   （64位库）
但是还是不行，于是在   /lib    （32位库）下创建链接
sudo
  ln -s /usr/local/lib/libpcre.so.1 /lib

然后运行：cd
 /usr/local/nginx/sbin/
sudo
 ./nginx

sudo netstat
 -ntlp
出现：



版权声明：本文为博主原创文章，未经博主允许不得转载。

网络爬虫：采用“负载均衡”策略来优化网络爬虫
前言：
  这里说的负载均衡并非大家熟悉的网络中的负载均衡。
  只是这里我使用了和负载均衡同样的一种思维来优化程序罢了，其实就是压力分摊。


问题描述：
  对于上一篇《分离生产者和消费者来优化爬虫程序》博客中遗留的问题：线程阻塞。
  当我们的程序运行到一定时间之后，会出现线程池中的500条线程不够用的情况，进而程序长期处于等待的状态。


压力测试实验：
  本实验基于之前的爬虫程序，线程池中的线程最大为320条。下面是对在主线程中以不同时间间隔执行程序的测试结果：
sleep 300ms




sleep 500ms





sleep 1000ms




内存使用状态图：




代码优化逻辑：
1.python代码优化
import sys
reload(sys)
sys.setdefaultencoding('utf8')
from time import clock, sleep
import threading

from list_web_parser import ListWebParser
import get_html_response as geth

def visited_html(html):
    myp = ListWebParser()
    get_html = geth.get_html_response(html)
    myp.feed(get_html)
    link_list = myp.getLinkList()
    myp.close()

    for item in link_list:
        if item[0] and item[1]:
            print item[0], '$#$', item[1]

    global thread_done_flag
    thread_done_flag = True

def count_down():
    start = clock()
    while True:
        sleep(1)
        end = clock()
        if int(end - start) >= 2:
            print 'TIME OUT'
            global thread_done_flag
            thread_done_flag = True
            break

thread_done_flag = False

def start_work(url):
    thread1 = threading.Thread(target=visited_html, args=(url,))
    thread2 = threading.Thread(target=count_down)

    thread1.setDaemon(True)
    thread2.setDaemon(True)

    thread1.start()
    thread2.start()

    while not thread_done_flag:
        ''

if __name__ == "__main__":
    if not sys.argv or len(sys.argv) < 2:
        print 'You leak some arg.'
    start_work(sys.argv[1])  这段代码做了一件事，主线程跟随第一个子线程结束而结束。
  目的是为了让程序在1秒钟之内结束运行，而超过1秒的html解析，我们将抛弃。我想这是合理的。因为我们不可能让Python一直占用我们的线程资源，这样很快线程就会出现阻塞。而且，随着我们解析HTML的线程数的增加。CPU的消耗也很快，这样我们的计算机就会出现卡顿的情况。


2.Java代码优化
public void visittingUrl(String startAddress) {
	    // url 合法性判断
	    if (startAddress == null) {
            return;
        }
	    
	    // 种子url 入库
	    SpiderBLL.insertEntry2DB(startAddress);
	    
	    // 解析种子url
	    PythonUtils.fillAddressQueueByPython(mUnVisitedQueue, startAddress, 0);
	    
		if (mUnVisitedQueue.isQueueEmpty()) {
            System.out.println("Your address cannot get more address.");
            return;
        }
		
        boolean breakFlag = false;
        int index = 0;
        
        startThread();
        
		while (!breakFlag) {
		    
			WebInfoModel model = mUnVisitedQueue.poll();
			if (model == null) {
			    System.out.println("------ 此URL为NULL ------");
                continue;
            }
			
			// 判断此网站是否已经访问过
			if (DBBLL.isWebInfoModelExist(model)) {
			    // 如果已经被访问，进入下一次循环
			    System.out.println("已存在此网站(" + model.getName() + ")");
				continue;
			}
			
			poolQueueFull(mThreadPool);
			
			System.out.println("LEVEL: [" + model.getLevel() + "] NAME: " + model.getName());
			
			mThreadPool.execute(new ParserRunner(mResultSet, model, index++, mResultMap));
			
			SystemBLL.cleanSystem(index);
			
			// 对已访问的address进行入库
			DBBLL.insert(model);
			
			model = null;
			
			SystemBLL.sleep(300);
		}
		
		mThreadPool.shutdown();
	}  Java代码的代码主要体现在，我们每次调用Python进行解析HTML时，都会sleep 300毫秒。这样我们CPU的压力就转移到时间上了。而这300毫秒其实对整体程序的影响不大，算是优点大于缺点吧。



关于上一篇：
1.覆盖equals时总要覆盖hashCode
  我们需要覆盖WebInfoModel的equals和hashCode方法，目的是我们把这个对象保存到HashSet中，需要保证它的唯一性。那么我们就必须自己来写一些唯一性的策略：重写equals方法。而重写equals时，必须要重写hashCode方法。关于这一点，大家可以参看笔者的另一篇博客《Effective
 Java：对于所有对象都通用的方法》
@Override
    public int hashCode() {
        return (name.hashCode() + address.hashCode() + level);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof WebInfoModel)) {
            return false;
        }
        
        if (((WebInfoModel)obj).getName() == name && ((WebInfoModel)obj).getAddress() == address && ((WebInfoModel)obj).getLevel() == level) {
            return true;
        }
        
        return false;
    }
遗留的问题：
1.python无故停止运行




下一步的目标：
1.解决python程序停止运行的Bug
2.分布式
(终于，终于可以开始利用分布式来优化我的蜘蛛程序了。想想还有一点小激动呢 ^_^)

版权声明：本文为博主原创文章，未经博主允许不得转载。http://blog.csdn.net/lemon_tree12138

Tableau如何连接其他电脑上的mysql数据库


在别的电脑上用tableau，如何连接到自己电脑的mysql 数据库， 服务器名、用户名和密码该如何填


首先，需要在mysql中创建一个允许远程连接的账户，例如
mysql> grant all privileges on *.* to username@'%'  identified by 'password';
mysql> flush privileges;
这样就设置好了远程连接的账户，其中username是用户名，password是密码；然后就用改账户的信息在远程连接了。


但是还需要注意检查IP。先判断是不是在同 一个网络之间，你ping 一下它的ip ，看能不能ping通。

这样就有两种情况，第一种：能ping通，说明你们在同一个网络中，可以直接访问。你只要在你的登录用户中的帐号加上可外部访问就可以了...也就是授权.比如你的帐号是root   你可以进入mysql后。














你可以看到,每个帐号对应 的有一列host,这个就是允许登录的主机,如果host为%号,那么就是所有主机都可以登录,包括远程主机.我执行如下
















































那么我的其中一个root的帐号就能被所有的主机访问了..





第二种情况,就是ping 不通,那么你是须要借用其它的工具.可以用花生壳或稻草人这样的ddns工具进行静态化ip.

剩下的按照第一种情况一样,把你的帐号允许远程登录就可以了
















版权声明：本文为博主原创文章，未经博主允许不得转载。

谷歌镜像网站大全-2015-8-25更新
Google镜像网站大全-2015-8-25更新

在特殊的地方和特殊的时间，流畅顺利的打开一个网站也变得如此艰难。

本文将不定期维护更新，删除不能用的，增加新的可用网址。欢迎 Ctrl+D 收藏。列表中有些打不开可能是 DNS污染 的原因，可以参考 DNS劫持 DNS污染 介绍 与 公共DNS 推荐 一文尝试解决。

以下镜像站分原版、非原版和智能跳转。非原版的界面有些改变，搜索结果依然与原版相同。智能跳转是在搜索时自动检测使用可用镜像进行搜索并展示结果。

如果您是以下镜像的作者，并且不希望您的镜像出现在以下列表中，可以联系我移除链接。

原版镜像网站：
https://www.guge163.com/
https://www.guge138.com/
https://www.gugeqq.com/
https://www.higuge.com/
https://www.52guge.com/
https://s.bt.gg/
https://g.yh.gs/
http://g.kvm.la/
https://guge.io/
https://g4w.me/
https://goge.ml/
https://g.wen.lu/
https://cc.rrke.cc/
https://hk.g.net.co/
http://xs.cytbj.com/
http://www.ppx.pw/
https://g.ftfish.com/
https://g.iyism.com/
https://so.xspace.in/
https://luoli.science/
https://g.lightss.org/
http://g.eeload.com/
https://www.booo.so/
http://www.guge.link/
http://carbyne.net.cn/
https://duliziyou.com/
http://g.openibm.com/
http://g.itechzero.com/
https://www.nssjs.com/
https://www.ko50.com/
https://guge.droider.cn/
http://gg.cellmean.com/
https://www.ggncr.com/
http://google.cytbj.com/
https://www.sslpxy.com/
https://gu.sweet360.net/
https://www.57soso.com/
https://www.mnsoso.com/
http://www.gugesou.com/
https://www.xiankaba.club/
http://www.googlestable.cn/
http://google.sidney-aldebaran.me/
http://0s.o53xo.m5xw6z3mmuxgizi.erenta.ru/

非原版：
谷粉搜搜：http://gfsousou.cn/
搜：http://sou.cloudapp.net/
南搜：http://nan.so/sites
快搜：http://www.kuaiso.hk/
谷壳：http://www.googke.me/
蝴蝶：http://www.xiexingwen.com/
搜下看：http://soxiakan.com/
帮我搜：http://www.helpme.so/
谷粉网：http://www.gool.wang/
一哥搜：http://www.egeso.com/
喜乐搜：http://www.xilesou.com/
谷歌婊：http://www.gugebiao.com/
我看到：http://www.wokandao.com/
谷歌363：http://www.g363.com/
谷歌搜索：http://ggss.cc/
快搜谷歌：http://g.banbu.cc/
谷歌镜像：http://sosolu.com/
印象搜索：http://gl.impress.pw/
综合搜索：http://so.ifukua.com/
百度谷歌：http://www.eeeke.com/
翻墙谷歌：http://search.52393.com/
极客搜索：http://www.geekgle.com/
谷粉搜搜：http://gfsoso.hao136.com/
谷歌中国：http://www.google-cn.net/
红杏谷歌：http://www.hxgoogle.com/
中国谷歌：http://www.googleforchina.com/
极速网谷歌：http://google.mjisu.com/
布谷鸟搜索：http://m.wcuckoo.com/search/
Ask：http://home.tb.ask.com/
AOL：http://m.search.aol.com/
5Ask：http://cn.5ask.com/
Avira：https://safesearch.avira.com/
WOW：http://www.wow.com/
Suche：http://suche.web.de/
OpenGG：http://www.opengg.cn/
Randomk：http://gl.randomk.org/
Im Google：http://www.imgoogle.cn/
Disconnect：https://search.disconnect.me/
WebWebWeb：http://webwebweb.com/

智能跳转：

谷大爷：http://g.phvb.cn/
大中华：http://i.forbook.net/
简约谷歌：http://free123.cc/
谷粉恰搜：http://www.qiasou.com/
逆天谷歌：http://www.go2121.com/
最火源码库：http://dian168.cc/google.html

谷歌学术：

http://www.scholarnet.cn/
http://scholar.xilesou.com/
http://xs.cytbj.com/scholar/
http://muzhi.wallpai.com/scholar/
https://duliziyou.com/!scholar.google.com/schhp



版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式之（五）——装饰模式
装饰模式，顾名思义就是对原有的对象进行装饰，添加新的东西。装饰模式可以在不创造更多的子类的模式下，将对象的功能加以扩展。 
讲到装饰模式不得不说，java 的 io 就是有利用装饰模式设计。 
写两句代码就清楚了。 
1、socket编程，读控制台输入的字符，我们会写：
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
2、文件读（写）：
 BufferedReader br = new BufferedReader(new FileReader(file));
这里就使用了装饰模式，这其实就是将 InputStreamReader 对象和 FileReader 用BufferedReader 来进行装饰，然后就会得到了一个具有了缓存buff 功能的流读取方式了。
这里我们稍微总结一下。 
装饰模式需要几个材料才能实现： 
1、 抽象构建角色(Component)：无论是抽象类还是接口，这里是 待装饰对象 和添加的 装饰对象 都需要有一个统一的接口实现（或继承）这样才能真正的实现装饰。（java io中如 InputStream/OutputStream 和Reader/Writer类）。
2、 具体的构建角色(ConcreteComponent)：实现具体的待装饰的对象。我们都需要一个统一的“空白”对象，我们之后是给这个“空白”对象进行装饰，添加功能。（java io中如 FileOutputStream 和 FileInputStream）。
3、装饰角色(Docorator)：统一的装饰对象。这里可以认为是定义需要添加的装饰的一个抽象。这里可以根据 装饰的样式不同 定义不同的子类，在进行添加时互不干扰。（装饰的多变可以有）。
4、具体的装饰角色(ConcreteDecorator):真正意义上的装饰，即添加的功能对象。（java io中如 BufferedOutputStream 和 BufferedInputStream，DataOutputStream 和 DataInputSrtream）。
这里我们来解释下，如图： 

这里 有一个 待装饰 的 ConcreteComponent 只有装饰 Docorator 后才能形成一个整体 Component。 
然而可能我们需要装饰的功能不止一个，这是我们需要将功能 抽象成一个装饰类，然后添加功能时可以根据需要进行添加 装饰A 或者 装饰B 或者两者都加（两者都加和上一层的装饰类似）。
举个例子：
interface Component {
    public void doSth();
}

class ConcreteComponent implements Component {
    @Override
    public void doSth() {
        System.out.println("功能X");
    }
}

class Decorator implements Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void doSth() {
        component.doSth();
    }
}

class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public void doSth() {
        super.doSth();
        System.out.println("功能A");
    }
}

class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public void doSth() {
        super.doSth();
        System.out.println("功能B");
    }
}

public class Test {
    public static void main(String[] args) {
        Component component = new ConcreteDecoratorA(
                              new ConcreteDecoratorB(
                              new ConcreteComponent()));
        component.doSth();
    }
}
运行结果就是在实现自身功能的同时实现了添加的功能。如图： 
 
这里就是先将 B 的的功能装饰上去，然后将 A 的功能装饰上去，这样就形成了新的类，同时实现 X，B，A 的功能。
不过这里的装饰类是比较通常的实现方法，这里也有简洁的实现方式，正如我上面说的那样，比如 ： 
1、直接在 带装饰类 中添加功能时，就不需要接口（抽象类）Component 。只需添加的装饰是带装饰类的子类即可。 
2、装饰添加的只有一个对象功能时我们可以不需要 装饰类的抽象层 Decorator 。
那么现在，我们再回头再看看java 的 io。
public abstract class Reader 

public class BufferedReader extends Reader

public class InputStreamReader extends Reader 

public class FileReader extends InputStreamReader

BufferedReader br = new BufferedReader(new FileReader(file));
我们可以看到 上述 BufferedReader ，InputStreamReader ，FileReader 的祖先都是 Reader。 
然后 FileReader 用 BufferedReader 来装饰就形成了一个具有存储缓冲区的文件流读的功能了。
从上述 讲解的装饰模式可以看出来，这就是使用装饰模式实现功能的添加。让数据以流的形式输入输出，然后存放在缓存区内进行接下来的操作。
只要弄懂了装饰模式的意思，具体的实现可以根据需要实现功能的添加。
水平有限，不吝赐教。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Linux网络编程--字符串IP和二进制IP转换
一：不安全的（不可重入性）inet_xxx()函数族
由于计算机理解的IP都是以二进制形式保存的，那么在网络程序设计中经常会需要字符串IP和二进制IP的转换，linux系统有一组要用于网络地址转换的函数，如下：
       #include <sys/socket.h>
       #include <netinet/in.h>
       #include <arpa/inet.h>

       int inet_aton(const char *cp, struct in_addr *inp);
       //将点分4段式的IP地址转换为结构in_addr值
       in_addr_t inet_addr(const char *cp);
       //将字符串转换为结构in_addr值
       in_addr_t inet_network(const char *cp); 
       //将字符串地址的网络部分转换为结构in_addr值
       char *inet_ntoa(struct in_addr in); 
       //将结构in_addr转为字符串
       struct in_addr inet_makeaddr(int net, int host); 
       //将网络地址和主机地址合成为IP地址，返回值是in_addr值
       in_addr_t inet_lnaof(struct in_addr in); 
       //获得地址的主机部分
       in_addr_t inet_netof(struct in_addr in); 
       //获得地址的网络部分
以上部分函数存在缺陷，例如： 
inet_ntoa函数返回值是一个指向字符串的指针，此内存会在每次调用inet_nota函数的时候被覆盖掉，如果不及时拿走数据就会出现不可预料的错误，因此函数是不安全的，存在某种隐患； 
inet_addr,inet_network函数的返回值是-1时表示错误，占用了地址255.255.255.255的值，存在缺陷，埋下了隐患。 
下面用一段代码介绍使用方法和隐患的部分：
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
    struct in_addr ip,local,network;
    char addr1[]="192.168.1.1";     /* 网络地址字符串 */
    char addr2[]="255.255.255.255";
    char addr3[]="192.16.1";
    char addr[16];
    char *str=NULL,*str2=NULL;


    int err = 0;

    /* 测试函数inet_aton */ 
    err = inet_aton(addr1, &ip);
    if(err){
        printf("inet_aton:string %s value is:0x%x\n",addr1, ip.s_addr); 
    }else{
        printf("inet_aton:string %s  error\n",addr1);   
    }

    /* inet_addr，先测试192.168.1.1，在测试255.255.255.255 */   
    ip.s_addr = inet_addr(addr1);
    if(err != -1){
        printf("inet_addr:string %s value is:0x%x\n",addr1, ip.s_addr); 
    }else{
        printf("inet_addr:string %s  error\n",addr1);
    };
    ip.s_addr = inet_addr(addr2);
    if(ip.s_addr != -1){
        printf("inet_addr:string %s value is:0x%x\n",addr2, ip.s_addr); 
    }else{
        printf("inet_addr:string %s  error\n",addr2);
    };

    /* inet_ntoa，先测试192.168.1.1，在测试255.255.255.255
    *   证明函数的不可重入性
     */
    ip.s_addr = 192<<24|168<<16|1<<8|1;
    str = inet_ntoa(ip);
    ip.s_addr = 255<<24|255<<16|255<<8|255;
    str2 = inet_ntoa(ip);   
    printf("inet_ntoa:ip:0x%x string1 %s,pre is:%s \n",ip.s_addr,str2,str);

    /* 测试函数inet_addr */ 
    ip.s_addr = inet_addr(addr3);
    if(err != -1){
        printf("inet_addr:string %s value is:0x%x\n",addr3, ip.s_addr); 
    }else{
        printf("inet_addr:string %s  error\n",addr3);
    };
    str = inet_ntoa(ip);    
    printf("inet_ntoa:string %s ip:0x%x \n",str,ip.s_addr);

    /* 测试函数inet_lnaof，获得本机地址 */ 
    inet_aton(addr1, &ip);
    local.s_addr = htonl(ip.s_addr);
    local.s_addr = inet_lnaof(ip);
    str = inet_ntoa(local); 
    printf("inet_lnaof:string %s ip:0x%x \n",str,local.s_addr);

    /* 测试函数inet_netof，获得本机地址 */
    network.s_addr = inet_netof(ip);
    printf("inet_netof:value:0x%x \n",network.s_addr);


    return 0;   
}

运行结果： 


二.安全的地址转换函数inet_pton(),inet_ntop()
函数inet_pton(),inet_ntop()都是可以重入的，同时支持多种地址类型，包含IPV4和IPV6。 
函数介绍： 
 
 
下面用一段代码介绍使用方法：
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <string.h>

#define ADDRLEN 16
int main(int argc, char *argv[])
{
    struct in_addr ip;
    char IPSTR[]="192.168.1.1";     /* 网络地址字符串 */
    char addr[ADDRLEN];             /* 保存转换后的字符串IP地址，16个字节大小 */
    const char*str=NULL;    
    int err = 0;                    /* 返回值 */

    /* 测试函数inet_pton转换192.168.1.1为二进制形式 */  
    err = inet_pton(AF_INET, IPSTR, &ip);   /* 将字符串转换为二进制 */
    if(err > 0){
        printf("inet_pton:ip,%s value is:0x%x\n",IPSTR,ip.s_addr);
    }

    /* 测试函数inet_ntop转换192.168.1.1为字符串 */
    ip.s_addr = htonl(192<<24|168<<16|12<<8|255);/*192.168.12.255*/
    /*将二进制网络字节序192.168.12.255转换为字符串*/
    str = (const char*)inet_ntop(AF_INET, (void*)&ip, (char*)&addr[0], ADDRLEN);
    if(str){
        printf("inet_ntop:ip,0x%x is %s\n",ip.s_addr,str);  
    }

    return 0;   
}

运行结果： 
inet_pton:ip,192.168.1.1 value is:0x101a8c0 
inet_ntop:ip,0xff0ca8c0 is 192.168.12.255

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Socket选项的那些事（一）
Socket选项的那些事（一）
今天跟大家分享套接字选项的一些事情，以下就是要详细介绍的东西，通过实际的编程来分享这些东西，有什么问题或者错误欢迎来讨论哈！！！！！

SOL_SOCKET协议族选项（通用地址族选项）
IPPROTO_ TCP和IPPROTO_ IP选项
ioctl（）函数

OK，进入我们今天的分享，先来讲述SOL_SOCKET协议族选项（通用地址族选项）
获取和设置套接字选项
其实在进行网络编程的时候，我们需要经常去查看并且设置套接字的某些特性。例如我们想去设置地址复用，设置读写数据的超时时间，想对读写缓冲区的大小进行调整，其中获得套接字的选项就是getsckopt()函数，那么对应话设置套接字的选项就是sesockopt()函数
介绍一下它们两个
#include<sys/socket.h>

int getsockopt(int s,int level,int optname,void* optval.socklen_t* optlen);
int setsockopt(int s,int level,int optname,void* optval.socklen_t optlen);

用来获取和设置某个套接字相关的选项，选项可能存在于多层协议中，他们总会出现在最上面的套接字层。当对套接字选项进行操作的时候，我们必须给出选项所在的层次与名称，为了操作套接字层的选项，应该将层的值指定为SOL_SOCKET，为了控制其它层的选项，必须给出控制选项的协议类型号。
我们来介绍上面两个函数参数的含义

s：表示将要获取和设置的套接字描述符
level：表示层次
optname：表示选项名
optval：表示操作的内存缓冲区
optlen：表示optval的长度

对于getsockopt，指向用于获取返回值的缓冲区，setsockopt指向设置参数的缓冲区。optval表示第optval的长度。getsockopt，指向socklen_t类型的指针，当用于传入参数时，表示传入optval的实际长度。当用于传出参数时，表示用于保存optval的最大长度。
当用于传出参数时，表示用于保存optval的最大长度。对于setopt函数，optlen表示第四个参数实际的长度，在函数执行成功的时候返回值为0，函数执行失败时返回为-1。同时我们可以根据错误代码来判断错误类型。
getsockopt()函数和setsocktopt()函数错误的代码含义：

EBADF:参数s不是有效的文件描述符
EFAULT:optval指向的内存并非有效的进程空间
EINVAL:在调用setsockopt()函数时，optlen无效
ENOPROTOOPT:指定的协议层不能识别选项
ENOTSOCK:s描述的不是套接字的描述符

按照参数level值的不同，套接字选项可以分为三大类：

通用套接选项：level的值为SOL_SOCKET
IP选项：level的值为IPPROTO_IP
TCP选项：level的值为IPPROTO_TCP

SO_KEEPALIVE选项
SO_KEEPALIVE保持连接选项，2小时没有数据交互，发送探测报文，有三种回应：

回应一个ACK报文
回应一个RST报文
没有回任何回应

使用方法：
就是调用setsockopt进行设置
int optval =1; 
setsockopt(sockfd,SOL_SOCKET,SO_KEEPALIVE,&optval,sizeof(optval));

第二个参数表示通用地址族选项，第三个就表示KEEPALIVE选项
SO_LINGER选项
SO_LINGER缓冲区处理方式选项，主要用于设置TCP连接关闭时的行为方式，它的操作通过一个结构体进行：
struct linger{
int l_onoff; // ￼ 开启（非0）关闭（0
int l_linger; //停留时间
};

根据以上结构体的不同，close调用可能产三种行为
我们介绍一下产生三种行为的不同方式：

l_ onoff等于0，此时SO_ LINGER不起作用，close用默认行为来关闭套接字
l_ onoff不为0，l_ linger为0，close系统调用立即返回，TCP将丢弃发送缓冲区中的残留数据，同时给对方发送一个复位报文段
l_ onoff不为0,l_ linger不为0，那么这个时候close的行为取决于两个条件，第一个条件是被关闭的套接字中的发送缓冲区中是否还有残留的数据，第二个条件就是该套接字是阻塞的还是飞阻塞的。对于阻塞的来说close将等待。如果是非阻塞的将会立即返回。

使用方法：
￼￼￼￼￼￼￼￼￼optval.l_onoff =1;
optval.l_linger =60; 
setsockopt(sockfd,SOL_SOCKET,SO_LINGER,&optval,sizeof(optval));

设置两个参数，然后进行set设置即可。
SO_ RECVBUF和SO_ SNDBUF选型
用于操作发送缓冲区和接收缓冲区的大小，使用的时候我们需要注意两点。

设置TCP/UDP连接的接收/发送缓冲区的含义：在UDP连接中他是无连接，发送缓冲区在数据通过网络发送后就可以丢弃不用保存，而接收缓冲区就需要保存数据，直到客户端进行读取，由于UDP没有流量控制，当缓冲区过小时发送端局部时间内会产生爆发性数据传输，因此在使用UDP时，需要将接收缓冲区设置为比较大的值。而在TCP连接中，接收缓冲区的大小，就是滑动窗口的大小，TCP的接收缓冲区不可能溢出，因为它不允许对方发送超过缓冲区大小的数据
在connect()函数调用之前设置：因为接收缓冲区的大小与滑动窗口的大小是一致的，而滑动窗口的协商是在建立连接的时候通过同步报文获得的。对于客户端来说，接收缓冲区的大小要在connnect系统调用前进行设置，因为connect需要通过同步报文段建立连接，而对于服务器来说，需要在listen之前进行接收缓冲区的大小设置。因为accept函数的返回值是继承了listen描述符属性

SO_ RCVLOWAT和SO_ SNDLOWAT选选型
SO_ RCVLOWAT表示接收超时，SO_ SNDLOWAT表示发送超时，设置是通过一个结构体实现的。
struct  timeval{
   time_t tv_sec;
   sseconds_t tv_usec;
};

SO_ RCVTIMEO和SO_ SNDTIMEO选项
SO_ RCVTIMEO和SO_ SNDTIMEO选项表示TCP接收缓冲区和发送缓冲区的低水位标记，它们一般会被I/O系统复用调用，来判断socket是否可读或者可写。
SO_REUSEADDR选项
表示可以重复使用本地地址和端口吗，这个设置在服务器端经常被使用。设置了SO_ REUSEADDR地址可重用选项，设置此选项可以使用被处于TIME_WAIT状态的连接占用的socket地址：
比如说某个服务器进程占用了TCP服务器的80端口。当再次监听的时候会返回错误。设置了此选项可以解决这个问题。也就是可以共用这个端口。有的时候，我们经常会遇到，当我们非正常退出的时候，这个端口会过一段时间内核才会释放，或者很久都没有被释放，我们无法再次开启服务器，设置了此选项就可以很好的解决这个问题了。
此选项的实际编程演示：
int sock = socket(AF_INET,SOCK_STREAM,0);
assert(sock >=0);
int reuse = 1;

//设置SO_REUSEADDR可复用选项
setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&reuse,sizeof(reuse));


//服务器的长用结构设置
struct sockaddr_in address;
bzero(&address,sizeof(address));
address.sin_family = AF_INET;
inet_pton(AF_INET,ip,&address.sin_addr);
address.sin_port = htons(port);
int ret = bind(sock,(struct sockaddr*)&address,sizeof(address));



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

ZOJ 3891 K-hash 后缀自动机


后缀自动机求不同的串,然后DP.....


K-hash

Time Limit: 2 Seconds      Memory Limit: 131072 KB


K-hash is a simple string hash function. It encodes a string Sconsist of digit characters into a K-dimensional vector (h0, h1, h2,...
 , hK-1). If a nonnegative number xoccurs in S, then we call x is S-holded. And hi is the number of nonnegative numbers which are S-holded and congruent with i modulo K,
 for i from 0 to K-1.
For example, S is "22014" and K=3. There are 12 nonnegative numbers are "22014"-holded: 0, 1, 2, 4, 14, 20, 22, 201, 220, 2014, 2201 and 22014. And three
 of them, 0, 201 and 22014, are congruent with 0 modulo K, so h0=3. Similarly, h1=5 (1, 4, 22, 220 and 2014 are congruent with 1 modulo 3), h2=4(2, 14, 20 and 2201 are congruent with
 2 modulo 3). So the 3-hash of "22014" is (3, 5, 4).
Please calculate the K-hash value of the given string S.
Input
There are multiple cases. Each case is a string S and a integer number K. (S is a string consist of '0', '1', '2', ... , '9' , 0< |S| ≤ 50000,
 0< K≤ 32)

Output
For each case, print K numbers (h0, h1, h2,... , hK-1 ) in one line.
Sample Input
123456789 10
10203040506007 13
12345678987654321 2
112123123412345123456123456712345678123456789 17
3333333333333333333333333333 11

Sample Output
0 1 2 3 4 5 6 7 8 9
3 5 5 4 3 2 8 3 5 4 2 8 4
68 77
57 58 59 53 49 57 60 55 51 45 59 55 53 49 56 42 57
14 0 0 14 0 0 0 0 0 0 0


Author: ZHOU, Yuchen
Source: ZOJ Monthly, July 2023






/* ***********************************************
Author        :CKboss
Created Time  :2015年08月25日 星期二 10时22分16秒
File Name     :ZOJ3891_2.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=100500;

struct SAM_Node
{
	SAM_Node *fa,*next[10];
	int len,id,pos;
	SAM_Node(){}
	SAM_Node(int _len)
	{
		fa=0; len=_len;
		memset(next,0,sizeof(next));
	}
};

SAM_Node SAM_node[maxn],*SAM_root,*SAM_last;
int SAM_size;

SAM_Node *newSAM_Node(int len)
{
	SAM_node[SAM_size]=SAM_Node(len);
	SAM_node[SAM_size].id=SAM_size;
	return &SAM_node[SAM_size++];
}

SAM_Node *newSAM_Node(SAM_Node *p)
{
	SAM_node[SAM_size]=*p;
	SAM_node[SAM_size].id=SAM_size;
	return &SAM_node[SAM_size++];
}

void SAM_init()
{
	SAM_size=1;
	SAM_root=SAM_last=newSAM_Node(0);
	SAM_node[0].pos=0;
}

void SAM_add(int x,int len)
{
	SAM_Node *p=SAM_last,*np=newSAM_Node(p->len+1);
	np->pos=len; SAM_last=np;
	for(;p&&!p->next[x];p=p->fa)
		p->next[x]=np;
	if(!p)
	{
		np->fa=SAM_root;
		return ;
	}
	SAM_Node *q=p->next[x];
	if(q->len==p->len+1)
	{
		np->fa=q;
		return ;
	}
	SAM_Node *nq=newSAM_Node(q);
	nq->len=p->len+1;
	q->fa=nq; np->fa=nq;
	for(;p&&p->next[x]==q;p=p->fa)
		p->next[x]=nq;
}

void SAM_build(char *s)
{
	SAM_init();
	int len=strlen(s);
	for(int i=0;i<len;i++)
		SAM_add(s[i]-'0',i+1);
}


int du[maxn];
int	ans[40];
int dp[maxn][40];

void solve(int K)
{
	memset(du,0,sizeof(du));
	for(int i=1;i<SAM_size;i++)
	{
		for(int j=0;j<10;j++)
		{
			SAM_Node* to=SAM_node[i].next[j];
			if(to!=0) du[to->id]++;
		}
	}
	queue<int> q;
	for(int i=1;i<SAM_size;i++) if(du[i]==0) q.push(i);

	memset(dp,0,sizeof(dp));

	dp[1][0]=1;

	while(!q.empty())
	{
		int u=q.front(); q.pop();

		for(int i=0;i<10;i++)
		{
			SAM_Node* to=SAM_node[u].next[i];

			if(to==0) continue;
			else
			{
				int v=SAM_node[u].next[i]->id;
				du[v]--;
				if(du[v]==0) q.push(v);
				if(u==1&&i==0) continue;
				for(int j=0;j<K;j++)
				{
					dp[v][(j*10+i)%K]+=dp[u][j];
				}
			}
		}
	}
}

char str[maxn];
int k;

int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);


	while(cin>>str>>k)
	{
		SAM_build(str);
		solve(k);

		memset(ans,0,sizeof(ans));

		for(int i=2;i<SAM_size;i++)
			for(int j=0;j<k;j++) ans[j]=ans[j]+dp[i][j];

		for(int i=0,len=strlen(str);i<len;i++) 
		{
			if(str[i]=='0') { ans[0]++; break; }
		}

		for(int i=0;i<k;i++)
			printf("%d%c",ans[i],(i==k-1)?10:32);
	}

    return 0;
}



版权声明：来自: 码代码的猿猿的AC之路 http://blog.csdn.net/ck_boss 

20150824朴素贝叶斯.md
核心就是贝叶斯公式： 
p(x|y) = p(x,y)/p(y) = p(y|x)p(x)/p(y) 
分类原则：在给定的条件下，在哪种分类的概率大，就是哪种分类。

举个小例子： 
两个信封：A1.2个红球，2个黑球，A2.1个红球，2个黑球。 
(1)已知从一个信封里面摸到一个红球，则这个信封是A1信封的概率。 
(2)已知从一个信封里面摸到一个黑球，则这个信封是A1信封的概率。 
P(R)红球的概率，P(B)黑球的概率，A1，A2为两个信封。 
P(A1|R)=P(A1,R)/P(R)=P(R|A1)*P(A1)/(P(R|A1)*P(A1)+P(R|A2)*P(A2)) = 0.5*0.5/(0.5*0.5+1/3*0.5) = 0.6 
P(A1|B)=P(A1,B)/P(B)=P(B|A1)*P(A1)/(P(B|A1)*P(A1)+P(B|A2)*P(A2)) = 0.5*0.5/(0.5*0.5+2/3*0.5) = 3/7

朴素贝叶斯最重要的假设就是，特征相互独立，每个特征同等重要。 
常常以文本分类为例子： 
样本：1000封邮件，已经标记哪些为垃圾邮件，哪些为非垃圾邮件。 
分类目标：给定第1001封邮件，判断是否为垃圾邮件。 
方法：朴素贝叶斯。 
类别：垃圾邮件A1，非垃圾邮件A2。 
将每个邮件的词汇组成词汇表，形成词汇向量，记所有单词数目为N。 
每个邮件m将映射成一个向量(x1,x2,x3…..)，如果某个单词xi在m中出现过，则xi为1。 
利用贝叶斯公式： 
P(A1|x) = P(A1,x)/P(x) = P(x|A1)P(A1)/(p(x|A1)*P(A1)+P(x|A2)*P(A2)) (其中x为单词组成的向量) 
其中P(x|A1)表示在垃圾邮件中x出现的概率，P(A1)表示垃圾邮件的概率，P(x)表示该向量出现的概率。 
其中P(x|A1)=P(x1|A1)*P(x2|A1)*P(x3|A1)…..

由此可求出P(A1|x)，但是在使用中往往会出现几个问题： 
1. 遇到新词需要对P(x1|A1)拉普拉斯平滑。 
2. 由于有众多小数相乘，因此我们需要取对数计算。 
3. 由于每个单词出现次数不同，我们需要将xi从01变为计数。 
4. 我们需要对分类器进行验证，交叉验证。 
5. 如果对象特征不独立，这个使用将从朴素贝叶斯变为贝叶斯网络。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

闪酷：母婴之家转型移动电商的重要推手
　　即携手母婴之家完成其B2B2C特卖系统及跨境电商之后，合作双方正式签署移动端触屏版平台，闪酷（http://www.shanku.so）将通过本次的合作为母婴之家打造完整的移动电商生态链。　　本次签约母婴之家移动端触屏版平台也是闪酷与传统电商企业深度合作的又一成功案例，母婴之家作为目前国内最大的一家母婴类垂直电商平台，在现有的B2C和B2B2C平台基础上，开发移动电商平台也正是为配合不同市场的需求，布局移动端用户市场。　　作为成功服务过近百家大型知名品牌客户的知名电商解决方案提供商，在竞争激烈的市场竞争条件下，闪酷一直深耕电商领域，专注于为传统电商企业的转型发展提供整体的解决方案。闪酷核心软件产品：闪酷B2C云商城系统(SKStore)，整合多销售渠道，打通各终端信息流、物流、财务流等，同一账户即可在PC端、移动 APP、微信等终端，随时登录、随时购物下单付款。 闪酷云商城系统主要包括PC端运营管理系统，PC端商城系统，Android APP商城系统，IOS APP商城系统、微信商城系统等五大系统，形成“一后台管理、多终端布局”模式，全方位协助客户布局线上电商；闪酷B2B2C多店铺商城系统(SKMall)，可为运营方快速搭建平台级多用户商城系统。并可为各个垂直行业提供有针对性的电商解决方案，包括O2O解决方案、跨境电商解决方案、商超电商解决方案、服装鞋帽电商解决方案、电商呼叫中心解决方案、微信分销解决方案等。　　在实体经济相对疲软的大环境下，传统电商企业通过业务形态的创新来突破现有的发展模式瓶颈是大势所趋，创新现有的业务模式才是关键所在，经调查研究，移动端触屏版上线之后，母婴之家将通过移动端流量入口带来50%以上的新增用户，每天新增200万左右的营业额，占领母婴电商行业近60%的市场份额，为保证母婴之家以上转型战略目标的实现，闪酷将前期的战略咨询，需求调研，产品设计方面提供专业化的咨询方案，优化产品的结构系统，业务流程，提升产品的交互友好型，同时在系统建设和维护上提供强大的技术支持和维护服务，确保平台的开发质量和系统的稳定，为系统的运营提供强大的技术支撑。闪酷信息技术（上海）有限公司CEO郝宪玮先生针对本次的合作表现出了强烈的信心，他表示“作为服务过日访问量5000万以上，日订单处理量在100万以上，日交易额10亿元以上，日并发量在2000 UV以上的电商平台企业的技术服务商，相信母婴之家与闪酷的这次强强合作，会给大家带来不一样的体验。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Talk Is Cheap ,Show Me The Code (一)
写在前面 
   结束了在百度的实习，是时候写下校招的总结了，再不写估计很多东西都忘了。在开源社区混迹久了，从别人的学习、求职、工作经历中越发感受到很多的正能量，也本着攒RP的原则，向学弟学妹们，尤其非名校的学弟学妹们传递点正能量，因为博主也是非名校出身，而且在整个求职的过程中能够很明显地感受到名校学生那种得天独厚的优势，同样的实力，名校学生进入BAT等一线互联网企业确实要容易很多，即便技术很水，一样有华为等企业保底，而非名校的可能连简历筛选这关都过不了。博主说这些，并不是为了打击非名校的学生，只是，这些确实是事实，既然无法改变出身，那就只能改变可控的因素，提高自己的技术实力，并放宽自己的心态，对结果看淡点，不要抱怨自己的出身，这样一路走来，你反而会发现：越努力，越幸运！

offer情况 
   由于深圳机会太少，校招前就一直想去广州驻扎，但后来因为实习，一直走不开，而且又考虑到实验室坑爹的考勤规定，就只能呆在深圳了，这样一边要赶实习的项目，一边又要找工作，每天中午还要回实验室考勤，着实累的够呛，还要时不时被某些企业打击，想想，蛋都碎了一地！
    由于实习牵制，而且又非常想留在深圳，可选的互联网公司少之又少，因此主要参加了阿里巴巴、腾讯、百度、中兴通讯、大疆创新这几家企业的校招面试，除了阿里愉快地挂掉了，其他四家都拿到了offer。另外，还意外地收到了网易游戏的笔试通知，据说光简历这关就刷了很多人，有点喜出望外，但因为和腾讯的笔试冲突，且职位被调到了项目管理方向，不太符合自己未来职业发展的定位，就放弃了。拿到腾讯的offer后，就没再参加后面公司的笔试了，主要是考虑到工作地点的问题，而且感觉也没必要刷那么多offer，免得掉人品。总的来说，对这个结果还算满意，一年多的努力总算有了些回报。

自学之路 
   本科在广东某石油化工类二本院校就读，专业是电子信息科学与技术，本科四年，大把时间都花在拿奖学金、做学生工作和参加各种无聊的文艺活动上了，除了能用C和汇编写几个简单的程序控制单片机做些傻逼的工作，其他啥都没学会，到本科毕业，连服务器都没听说过，更不知道数据结构是啥东东，三年宝贵的光阴就这样白白浪费过去了。后来考研，依然对自己没有一个清晰的定位，所以报考的是仍然是通信类专业，但不得不说，这次考研的经历，对我后面的读研生涯产生了极大的影响，它让我坚定了一个很重要的信念：有些目标看似很遥远，但只要你付出足够的努力，这一切总有可能实现。
    读研前的暑假，隐约意识到要提高自己的编程能力，但又不知道往什么方向学，于是在网上查了下，就从图书馆借了本《c primer plus》开始啃，并把后面的习题都敲了一遍，后来开学后，又看了《c和指针》、《c专家编程》（这个没看完），跌跌撞撞总算上了道。
    虽然考研成绩很高，但硕士依然在广东的一所二本院校就读，只是这次学校的名字从学院升级到了大学。来了之后，越发对这里的学术氛围感到失望，终于意识到在这里做所谓的“科研”无疑自毁前程，无奈，只能自救，当时恰好有一个师兄签到了百度地图，便找他聊了下，触动还是蛮大的，这次聊天也彻底坚定了我不做“好学生”的决心。但具体该学什么，往哪个方向发展，依然没有头绪，于是就稀里糊涂地继续学c++，先是看了谭浩强的那本教材（没办法，一点c++基础都没，只能从头开始），后面又看了《c++
 primer》，还借了一本《鸟哥的linux私房菜》，看了一半，也装了个ubuntu系统来玩，这些自学的时间都是逃课换来的，想想如果当时本科就这么搞，现在也不至于这么菜了！
    转眼研一的第一学期都快结束了，想想要确定一个未来工作的方向了，老这么漫无目的地瞎折腾，总不是办法。在网上查了好几天，最终决定搞移动端，原因很简单：需求量大，就业机会多，而且当下很多互联网创业项目都集中在移动端，未来几年应该依然是主流，买不起Mac和Iphone，那只能搞Android了。接下来，便是各种自学，先是花了一个月时间，入门Java，后面边学边做Android，还跟同学申请了一个学校挑战杯的Android项目，没办法，谁让自己当初觉悟低，错过了三年大好的光阴，好在现在意识到，还为时不晚。
    由于研二规定要进实验室，于是研一第二学期刚开学，便琢磨着出去找个Android开发的实习，无奈实在太菜，面了七八家公司，全被拒之门外，尤其跑去珠海面试魅族的时候，面试官问我Json是啥，我说不知道，结果被鄙视的一览无余，说我连本科生都不如，回来后郁闷了两天。后来误打误撞去了意法半导体实习，用PHP帮他们做ERP系统的二次开发，说白了，就是打杂，而且是一个人打杂，遇到不会的还没人问，感觉没学到啥东西，不过实习的间隙，依然在学习Android，并完善了之前的项目，同时进一步巩固了Java基础，学习数据结构与算法，并抽空看了一遍刚出版的《大数据时代》。暑假还尝试了一次创业，不过赚了点小钱就收手了，主要是火候还不够，而且也找不到真正志同道合的人，现在想想，当时确实有些浮躁了，还是先去一线互联网公司沉淀几年比较靠谱。
    研一就这么浑浑噩噩地过了，真正在技术上有质的飞跃是研二这一年，由于导师放羊式管理，这一年有了很多自由的时间，于是一边做项目，一边看书，从Java语言，到虚拟机，再到网络协议，算法，看了很多经典的计算机书籍，另外还涉猎了一些大数据处理方面的知识，获益匪浅。但学习的过程还是很曲折的，主要是实验室有着各种坑爹的规定，而且学习氛围不是一般的差，当然这些都已成过去，也不想吐槽太多，总之，能不呆在实验室，就尽量去其他地方，就这样，为了能安静高效地学习，我打了一年的游击战。比较庆幸的是，十月份在CSDN上看到了江南烟雨的校招面经，于是决定坚持写技术博客，事实证明，这确实是一件有百利而无一害的事情，通过写博客，在社区上结识了很多志同道合的小伙伴和技术上精益求精的前辈，从这些素未谋面的人身上学到了很多，感受到了满满的正能量。
    另外一件对我找工作帮助很大的事情，是8月下旬拿到了百度LBS研发部的实习offer，考虑到毕业后想留在深圳，便决定去实习，很庆幸这次没有打杂，刚去第二天，就参与到了实际产品的项目开发中，短短两个月，学到了很多东西。
    接下来，便是校招了，校招高峰期虽然只有不到两个月，但真正关键的是校招前的那一两年，甚至三五年，你所付出的努力。博主在社区里看到很多默默付出，最后在校招期间爆发的人，当然也会有人悠哉了三年，一样拿到了不错的offer，只是人可幸运一时，总不至幸运一世，所以脚踏实地，才能有所作为。

校招流水账 
   下面按照面试的先后顺序大致记录下这次校招的经历，但不会牵涉到具体的面试问题，这个根据每个人的简历和方向肯定会有所不同。

阿里巴巴 
   阿里之于我，只有一句话可以形容：阿里虐我千万遍，我待阿里如初恋。
    第一次面阿里是3月份的实习生内推，当时加了一个淘宝技术部的内推群，无奈水平太渣，又超级紧张，而且还莫名其妙地被分了一个C/C++面试官，聊了不到二十分钟，就顺利地挂掉了，不过也没有太在意，因为当时一直觉得BAT对我来说，是很遥远的事情。
    第二次面阿里是7月底的校招提前批内推，这次找的师兄内推，师兄在阿里巴巴国际部，但我却被推到了无线事业部（后来在百度实习才知道，内推其实就是在内网上把你的简历挂上去，供内部一些有需要的部门来选，如果有部门选中，就由这个部门的人来面试，通过的话，便会进入这个部门，如果没有部门选中，那就没有面试机会），内推后的第二天，就接到了电话面试，上来就是各种Android源码分析、Android性能调优、Java高级并发的知识，勉强撑住了，可是面试官死揪着一点不放，聊到性能调优，一定要我有一些调优前后对性能分析得出的数字指标作为支撑，聊到Java的高级并发特性，一定要我在实际的项目中有用到，我说没做过服务端的并发项目，只写过一些Demo，估计面试对我无语了，问到，也就是说你只是看过书或者只是学过这方面的知识，对吧？我说可以这么说吧。然后，面试就这么纠结地结束了，本以为挂了，面完刷了下状态，结果一面通过。一周后二面，二面让我去阿里在深圳的办公点，跟杭州的技术官视频面，刚一上来就感觉面试官杀气很重，心想接下来肯定是一场恶战，果不其然，面试官连我简历都没看，上来就是自我介绍，然后揪着项目问，各种细节，项目的功能延伸，最后居然延伸到了服务器端的架构设计，前面还好，到后面真的是各种拙计，意料之中的结果，挂了！回来后郁闷了整整一周，后来跟北大一哥们聊天，提醒了我，我搞客户端的，怎么后面问了这么多服务端的东西，这不对啊，再后来，正式校招面阿里前，Rowandjj给我发了个手机淘宝技术架构演变之路的演讲链接，打开一看，主讲人正是二面挂我的面试官（花名：无锋），再看了下他的简介，顿觉高山仰止，只能说挂的我心服口服。
    第三次面阿里是正式校招，由于内推挂掉了，只能从头再来，在线笔试顺利通过，面试预约到了9月17号中午，当时正在百度实习，不过恰好项目已经提测，活没那么多了，就跟leader请了三天假来准备阿里的面试。没想到去了广州后遇到了一个奇葩的面试官，确切地说，是UC的面试官，上来就让我讲项目，讲的时候还一直在夸我，讲完后，问他有什么问题要问没，他说没有，做的挺好的，结束后，还跟我握了下手，出来后我觉得铁定过了，心里正得意时，校园大使过来跟我说，我今天的面试结束了，我越想越觉得不对劲，就找机会去问了下面试官原因，结果不问还好，问了后，我的三观完全被颠覆了，面试官说我项目做得太深，在工作中会拖延项目进度，又说大牛都不写博客，让我不要老是写博客，看博客之类的，要多花些时间看书，书才是精华，我顿时觉得心中万匹草泥马踏过，好吧，只能认栽了。后来自己总结了下，面试的时候还是比较紧张，而且项目讲的有点混乱，估计这才是真正被刷掉的原因。由于实在心有不甘，我就一直找机会霸面，后来跟负责校招的HR千磨万蹭，终于答应把我的简历拿给其他面试官看下，但是被告知只能霸面开发测试，虽然一直比较排斥做开发测试，但这个时候哪还顾得了这么多，别人能给机会都谢天谢地了。后面面试就比较顺利了，问题多偏向于JVM，从一面一直到HR面，感觉挺好，而且二面面试官一直在跟我介绍他们UC的部门，还问我想不想去UC，面完后，我又开始做美梦了，可是HR面之后，再无消息，不知道是因为我二面时一直强调想做移动端和想去无线事业部的原因，还是因为我是后来霸面的原因，总之到现在都没有任何消息，估计连备胎都不是，直接被鄙视了。
    为了最后一次进军阿里的机会，我做了很多的准备，面试前一直觉得很有希望，怎奈再次折戟。被阿里打击后，我一度开始怀疑自己的能力，越想越觉得找份好工作不容易，郁闷了两天后，索性接下来的面试不再做任何准备（实际上，也没有时间准备，因为项目赶的太紧），放空身心，一切随缘，大不了最后去小公司，反而是这种心态，让我顺利通过了后面公司的面试。


大疆创新（拿到offer） 
   参加大疆创新的的面试纯属偶然，它们的校招行程上根本没有深圳站，是HR在内推网上看到了我的简历，让我过去他们公司面试的，由于当时想多花点时间准备阿里的面试，就借口项目太赶，没时间去，没想，面完阿里回来后，HR又发短信让我去面试，也许这就是缘分。由于不是在校招线路上参加的应聘，因此没有笔试，只有一轮面试，CTO直接面，上来就是四道算法题，前两道都是《剑指offer》上的题改编过来的，后面两道则完全没见过，感觉有点超长发挥了，四道题目都做到了最有优，面试官很满意，后面就继续问了下项目，又问了Android屏幕适配，URL去重，MD5等等，基本答的还不错，面完后说直接让HR给我发校招offer，还问我对薪资的期望，我说不能低于10k。后来，offer发下来，待遇远高于我的预期，不比BAT差，而且公司发展势头正猛，也是一个不错的选择，只是毕竟不是互联网公司，所以我还是拿它来保底。

中兴通讯（拿到offer） 
   中兴今年第一次在我学校大规模招人，这放在以前，估计连简历筛选这关都过不了。相对来说，中兴的offer拿的是最容易的，23号下午宣讲，晚上笔试，感觉题目没啥区分度，会的大家基本都会，不会的应该也差不多都不会。凌晨一点多收到一面的短信，在ZTE总部，也就是学校旁边，去了之后，先跟负责校招的家贵模拟面了下，他觉得我不错，就推荐我参加蓝剑计划（这个其实也就是意思一下，博主跟蓝剑计划差的还很远），还把我的面试安排在了前面，当时真的感觉受宠若惊。一面二对一面试，基本没问太深的技术问题，面试官对我在百度的实习很感兴趣，问了很多，只是都无关技术，很顺利地通过了一面，同样是凌晨一点多收到的二面短信，二面还在同一个房间，只是面试官换了，同样二对一面试，这次完全没问技术，各种综合问题，大概二十多分钟，面试结束，又是凌晨一点多，收到了offer短信，要第二天拿三方去签约，工作地点，职位任选，直接拒了。
    说到中兴，不得不提华为，华为在深圳地区的校招12号就开始了，之前一直听闻华为面试各种水，就想先拿华为来保底，没想到直接把我学校鄙视了，深圳地区只要北大、清华、哈工大深研院和中科院四所学校的，已无力吐槽。

百度（拿到offer） 
   第一次参加百度的面试是研二的时候，当时跟在师兄师姐后面打酱油，参加了百度的校招笔试，一不小心过了，只是算法基础太薄弱，一面就被刷了。
    第二次参加百度的面试是8月下旬拿到实习offer那次，在内推网上投的，直接在工作地点面，一面先是聊项目，重点聊了下项目中涉及到的图片异步加载、缓存策略、线程池、ListView性能优化、分页加载等，又聊到Android消息队列模型，深入到了源码层面，后面问了些操作系统、排序算法、设计模式以及虚拟机和语言方面的基础知识，基本都答上来了。一面后直接二面，二面面试官明显年纪大了很多，上来就围绕着项目问，各种如何实现，因为确实做过，基本都答上来了，后面还扯到了一些开源框架，基本点到为止，二面面试官也是后来入职后带我的师傅，在工作上给了我很多指导。二面后直接三面，三面就比较轻松了，聊了下学习和实习的一些情况，就结束了，三面面试官是我后来的leader，当时刚好从北京出差来深圳。面完后的当天晚上接到了一个010的电话，谈offer的细节，虽然仅仅是一个实习offer，但还是蛮激动的，因为当时刚被阿里打击完，这个offer多少给了我点自信，至少证明自己身上还是有些值得肯定的地方的。
    第三次参加百度的面试是正式校招。由于校招启动时，才刚实习了一个月，而且我们组移动端又不是特别缺人，leader就让我先参加百度的校招。9月20号在哈工大深研院参加的笔试，感觉做的还不错，24号上午一面，一面全是算法，很多都是《剑指offer》和《编程之美》上的题目，当然，也有没见过的，比如面试官拿百度地图出了道题目，基本都答出来了。下午1点，直接二面，二面先聊了下项目，然后问了很多Android、Java方面的知识，基本都深入到了Framework层和JDK层面，有一些没能回答这么深，最后让设计一个类似于微信的客户端架构，刚开始完全没有思路，后来在面试官的引导下，渐渐有了眉目，重点要考虑清楚代码的分层和解耦策略，这点也是在实习时实实在在感受到的。下午5点左右三面，三面依然是技术面，但相对比较轻松些了，聊了下百度实习的项目，项目中遇到的最大的挑战，如何解决等等，然后写了个c的字符串拷贝函数，要考虑异常情况，后面就是各种聊职业规划、人生理想。
    本以为百度的offer能拿的很顺利，没想到是拿的最纠结的。主要是百度今年有点太坑了，深圳移动软件研发岗今年一个名额都没有（深圳地区负责招聘的HR后来跟我说的），官网上却赫然写着10个名额，所以即便三面通过（当然，三面也会刷人），进入offer池，依然不会有经理来选，最后，只有两种结果：调北京、没offer。国庆后收到了调剂北京的邮件，但实在不想去帝都，幸而leader答应从北京其他组调过来一个名额给我，这才有了百度深圳的offer。
    我觉得能拿到百度offer，实习应该有很大帮助，因为深圳移动软件研发和软件研发这两个岗刷人特别严重，所以，机遇真的很重要。

腾讯（拿到offer） 
   因为想留在深圳，又想学习做产品，腾讯无疑是最好的选择。腾讯在深圳地区的校招很晚才开始，27号笔试，10月9号上午在腾讯大厦一面，上来先是问各种基础知识，从操作系统，到计算机网络，再到数据结构与算法，Android基础、Java基础、JVM、性能优化。。。广而不深，都答上来了，很多地方在回答的时候，我特地深入解释了下原因，后面聊项目，这个面了几家公司，都聊烂了，不在话下，最后写了个算法题，《剑指offer》的原题。10月11号上午二面，二面时，已经看不到几个人了，其中有一些还是从外地赶过来的，还有一些是在广州挂了，又来深圳参加的，估计大家都是很想在深圳发展，二面给我感觉有点压力面的样子，这是面完后才意识到的，面试官问任何问题都问的很深，很细，而且话很多，不给你反驳的余地，感觉回答的一般般，面完后心里一直没底，不过当天晚上收到了HR面的短信通知，HR面是电话面，主要问些家庭情况，职业发展，个人性格方面的问题。面完后的第三天，收到了腾讯的offer，分到了自己所报的事业群，也刚好被分到了自己一直想去的部门，皆大欢喜，只是待遇上比百度稍低，当然，这些已经不是重点要考虑的因素了。


一些不错的面经
    看过不少面经，有一些总结的很不错，很具有指导意义，推荐给大家。
    Linux C/C++后台开发方向（华科一硕士）：
     http://blog.csdn.net/xiajun07061225/article/details/12844801
    Java分布式后台开发方向（北大一哥们）：
     http://idlemind.sinaapp.com/2014/05/01/intern/
    Android移动端开放方向（华科一哥们）：
     http://blog.csdn.net/u011843634/article/details/25710305
    综合研发类（北航一硕士）：
     http://blog.csdn.net/hackbuteer1/article/details/8501605
    算法学习之路（同上）：
     http://zh.lucida.me/blog/on-learning-algorithms/



一些感悟

    从3月份的实习生招聘开始，到现在，一路跌跌撞撞，总算有了着落，总结下其中切身体会到的一些感悟。
    1、基础很重要。这个相信大家都深有体会。
    2、项目要深入。做项目不能浅尝辄止，这个参加过面试的人应该都会有所体会。
    3、心态很重更要。跟高考一样，面试中心态不好，会很影响临场的发挥。
    4、细节决定成败。从基础到项目，这个都会有所体现。
    5、坚持写博客。虽然面试到现在，只有一个面试官看了我的博客，但写博客真的是一件有百利而无一害的事情。
    6、凡事要讲究缘分。有些时候，有些事，确实要看缘分，所以把心放宽些，不要刻意放大一些痛苦。
    7、付出总会有所收获，问题的关键在于你是否坚持的足够久。认识的一些付出了很多努力的小伙伴，虽然也是一路磕磕绊绊，但最终都有了比较好的结果。


    最后，希望这篇博文能够给那些像我一样菜的学渣们一些盼头。 


http://blog.csdn.net/ns_code/article/details/40408397 


版权声明：本文为博主原创文章，未经博主允许不得转载。

Webpower中国区发布《2015年中国酒店旅游行业邮件营销市场报告》

全球领先的多渠道智能化营销服务机构Webpower于近日发布《2015年中国酒店旅游行业邮件营销市场报告》。报告显示，该行业国内EDM平均送达率为96.76%，平均独立打开率为7.17%，平均独立点击打开率为11.13%，平均独立点击送达率为0.80%。总体而言，酒店旅游行业邮件营销各项指标表现出一定程度的理性上升。（数据覆盖时间：2014年7月至2015年6月，如无特别说明，以下引用Webpower中国区的数据来源，均为此段时间节点）

市场环境的深刻变革，也为酒店旅游行业的营销方式带来全面的挑战。传统的媒介广告投放效果大大弱于互联网广告。邮件作为互联网市场营销中的一种渠道，一直以产品的天然契合度成为酒店旅游行业的标配营销方式之一，有效扮演企业CRM角色。Webpower中国区结合自身客户体量及客户服务情况，从邮件营销的多个维度为酒店旅游行业的市场营销者们进行相关数据解读，希望能为诸位带来营销技能的新飞跃。



从酒店旅游行业整年EDM表现折线图来看，2014年12月平均独立打开率达到7.56%，平均独立点击送达率达到1.75%，平均独立点击打开率达到23.10%之高，达到一年中的峰值。Webpower中国区认为，这与旅游行业的季节性和假期性特点分不开，伴随酒店旅游行业竞争日趋理性以及行业整体稳定性的到来，我们认为邮件营销对酒店旅游行业的市场营销应用潜力是极大的。



在Webpower中国区研究的整个样本量中，酒店旅游行业在邮件营销表现上突出的TOP3企业的平均独立打开率为17.93%，是该行业基准值的近2.50倍；平均独立点击打开率为15.61%，是该行业基准值约1.40倍；平均独立点击送达率为2.80%，是该行业基准值的3.5倍。

除了常规的EDM指数能客观定量地反映邮件营销现状。Webpower中国区也对酒店旅游行业展开其他维度的数据分析，引导市场营销人员关注邮件发送的各个细节。比如对酒店旅游行业用户打开、点击邮件的时间、设备等行为进行分析，发现邮件发送的黄金时间点。



根据Webpower中国区的调研数据显示，8点到11点之间，用户的打开率分别为12.51%，13.29%，12.77%，11.64%,点击率达到1.62%，1.99%，1.64%，1.40%；其次是13点到17点，用户的打开率分别为10.00%，11.40%，11.54%，11.59%,10.07%；点击率达到1.06%，1.31%，1.32%，1.31%，1.12%。邮件最高打开率和点击率的时间点分别集中在8点到11点，13点到17点之间邮件打开和点击率的呈现相对均衡的高峰。这表明8点到11点，13点到17点是酒店旅游行业用户更愿意阅读邮件的黄金时间段，是酒店旅游企业开展邮件营销活动的最佳时机，在一定程度上也增加了邮件转化率的概率。



Webpower中国区对酒店旅游行业的邮件阅读设备也展开了调研。我们发现在近一半的邮件通过智能手机打开,57.23%的邮件通过PC端打开。Mobile端近乎要追赶到PC端。而具体到邮件阅读的移动设备偏好度，逾30.22%的邮件阅读是通过iOS设备。智能手机和平板电脑构成了酒店旅游行业邮件阅读的重要媒介平台。

同时，Webpower中国区对数家企业做了为期两个月及以上的相关邮件体验，此次报告中选取了四家企业真实的邮件营销案例（下载完整报告可查看）。



移动互联网的发展为在线旅游产业带来新的发展契机，两者天然的契合特质促进酒店旅游产业的全面升级。伴随在线旅游用户向移动端的迁移，在线旅游移动端市场将保持高速发展。目前，用户对在线旅游产品的运用主要集中在旅游信息搜索、旅游产品预订以及对相应产品和服务的跟踪，随着用户需求不断细分，产品和服务的差异化将是未来在线旅游移动端市场竞争的关键。在旅行中和旅行后的服务体验一定程度上，是未来酒店旅游行业白热化竞争的关键，各家将在服务能力和覆盖范围上均有所提高。

但不乏一些企业出于对行业大趋势的洞察，只注重移动端的营销，比如仅仅在短信、微信渠道吸引用户的注意力就是不成熟的营销观念，一直以来短信渠道受国家政策监管影响业务波动较大。因而只把它们作为营销渠道是俨然不够的，邮件渠道是必要且必须的补充。许可式邮件营销是在尊重个人隐私基础上衍生的网络营销手段，企业收集并维护更高质量的邮件列表是开展邮件营销的前提。

针对酒店旅游行业的特点，相关企业不妨有针对性地对邮件产品线做升级规划，比如在邮件中延伸客服功能，让系统邮件在预订流程和支付环节等层面优化用户体验，让更优秀的路线推荐、攻略指导、团购信息等期刊与促销邮件引导用户消费，让更贴心的关怀类邮件与用户维系情感上的沟通。针对性地满足用户多维度全方位个性化的需求，维护与客户的长期接触。同时多渠道打造品牌形象与口碑，这种复合式体验若能在整个产品和服务周期中体现，将切实转化为企业收入，并培养客户忠诚度。适应行业的深化发展，更智慧的市场营销是酒店旅游行业理性有序竞争的开始。



点击下载完整报告，了解酒店旅游行业邮件营销应用状况及优秀的邮件营销策略。

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 4875 逃生

逃生
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2467    Accepted Submission(s): 692



Problem Description

糟糕的事情发生啦，现在大家都忙着逃命。但是逃命的通道很窄，大家只能排成一行。

现在有n个人，从1标号到n。同时有一些奇怪的约束条件，每个都形如：a必须在b之前。
同时，社会是不平等的，这些人有的穷有的富。1号最富，2号第二富，以此类推。有钱人就贿赂负责人，所以他们有一些好处。

负责人现在可以安排大家排队的顺序，由于收了好处，所以他要让1号尽量靠前，如果此时还有多种情况，就再让2号尽量靠前，如果还有多种情况，就让3号尽量靠前，以此类推。

那么你就要安排大家的顺序。我们保证一定有解。

 


Input

第一行一个整数T(1 <= T <= 5),表示测试数据的个数。
然后对于每个测试数据，第一行有两个整数n(1 <= n <= 30000)和m(1 <= m <= 100000)，分别表示人数和约束的个数。

然后m行，每行两个整数a和b，表示有一个约束a号必须在b号之前。a和b必然不同。

 


Output

对每个测试数据，输出一行排队的顺序，用空格隔开。

 


Sample Input

1
5 10
3 5
1 4
2 5
1 2
3 4
1 4
2 3
1 5
3 5
1 2


 


Sample Output

1 2 3 4 5题目：要在限制条件的条件下，按照财富值排序，如果正常的写顺序一定不对，还有数据30000用map和map+队列都不太好，
      所以反向建边 +倒序输出，数据的话，就用队列+邻接表处理级即可！
      #include<stdio.h>
#include<string.h>
#include<iostream>
#include<algorithm>
using namespace std;
#include<queue>
#define N 30010
int indegree[N],top=0;
int n,m,t,head[N];
struct line 
{
    int u,v,next;
}edge[100010];
void topo()
{
    int i,s=0,j,top=0,a[N];
    priority_queue<int ,vector<int>,less<int> >Q;
    for(i=n;i>=1;i--)
     {
         if(indegree[i]==0)
         {
             Q.push(i);
         }
     }
     while(!Q.empty() )
     {
        top=Q.top() ;
        Q.pop() ;
        a[s++]=top;
        indegree[top]=-1;
        for(i=head[top];i!=-1;i=edge[i].next )//与top相连的入度减一 
        {
            int t=edge[i].v ;
            indegree[t]--;
            if(indegree[t]==0)
            Q.push(t); 
        }
     }
     for(i=s-1;i>=0;i--)//倒序输出 
     {
         if(i!=0)
         printf("%d ",a[i]);
         else
         printf("%d\n",a[i]);
     }
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&m);
        top=0;
        memset(indegree,0,sizeof(indegree));
        memset(head,-1,sizeof(head));
        while(m--)
        {
        int a,b;
        scanf("%d%d",&a,&b);//反向建边 
        edge[top].v=a;
        edge[top].next =head[b];
        head[b]=top++;
        indegree[a]++;
        }
        topo();
    }
    return 0;
} 


版权声明：本文为博主原创文章，未经博主允许不得转载。

Memcached之客户端-xmemcached(5)
高性能Java memcached客户端——Xmemcached发布2.0.0版本，主要改进如下：



    性能优化，在测试中文本协议实现有接近10%的性能提升。    批量获取key如果包含相同的key，会缓存反序列化后的对象，减少重复反序列化的CPU开销。    修复getStats没办法获取cache dump的Bug，感谢machao9email。    修复ONE_AT_A_TIME没有正确处理无符号数的Bug，感谢spudone。    使用纳秒时间戳作为namespace值，避免高并发下的namespace值冲突。 

Maven依赖: 

<dependency>
	<groupId>com.googlecode.xmemcached</groupId>
	<artifactId>xmemcached</artifactId>
	<version>2.0.0</version>
</dependency>
Spring + Xmemcached
<pre name="code" class="java">	<bean name="memcachedClient"
		class="net.rubyeye.xmemcached.utils.XMemcachedClientFactoryBean">
		<property name="servers">
			<!-- 服务器列表，格式：（ip：端口 ip：端口），多个以空格分割 -->
			<value>10.0.1.75:12000 10.0.1.76:12000 10.0.1.77:12000</value>
		</property>
		<!-- 和servers对应的节点的权重,weights是用来调节Memcached的负载，设置的权重越高，该Memcached节点存储的数据将越多，所承受的负载越大。 -->
		<property name="weights">
			<list>
				<value>1</value>
				<value>2</value>
				<value>3</value>
			</list>
		</property>

		<!-- nio连接池大小,默认一个Memcached节点只有一个连接池，通常条件是没有问题的。但是在典型的高并发环境下,nio的单连接也会遇到性能瓶颈。可通过调整连接池数量,<br> 
			当建立了多个连接到同一个Memcached节点，由于连接之间是不同步的，因此你的应用需要自己保证数据更新的同步 -->
		<property name="connectionPoolSize">
			<value>1</value>
		</property>

		<!-- 与服务器节点个数一致,密码不允许有空格 -->
		<property name="authInfoMap">
			<map>
				<entry key-ref="serverA">
					<bean class="net.rubyeye.xmemcached.auth.AuthInfo"
						factory-method="typical">
						<constructor-arg index="0">
							<value>memcached</value>
						</constructor-arg>
						<constructor-arg index="1">
							<value>123456</value>
						</constructor-arg>
					</bean>
				</entry>
				<entry key-ref="serverB">
					<bean class="net.rubyeye.xmemcached.auth.AuthInfo"
						factory-method="typical">
						<constructor-arg index="0">
							<value>memcached</value>
						</constructor-arg>
						<constructor-arg index="1">
							<value>123456</value>
						</constructor-arg>
					</bean>
				</entry>
				<entry key-ref="serverC">
					<bean class="net.rubyeye.xmemcached.auth.AuthInfo"
						factory-method="typical">
						<constructor-arg index="0">
							<value>memcached</value>
						</constructor-arg>
						<constructor-arg index="1">
							<value>123456</value>
						</constructor-arg>
					</bean>
				</entry>
			</map>
		</property>

		<!-- 分布策略，KetamaMemcachedSessionLocator(一致性哈希,增加主机时降低未命中率问题的解决); 
		还有实现了：ArrayMemcachedSessionLocator；ElectionMemcachedSessionLocator；
		LibmemcachedMemcachedSessionLocator；PHPMemcacheSessionLocator -->
		<property name="sessionLocator">
			<bean class="net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator" />
		</property>
		<!-- 序列化转换器 -->
		<property name="transcoder">
			<bean class="net.rubyeye.xmemcached.transcoders.SerializingTranscoder" />
		</property>
		<!-- IoBuffer分配器(内容写入memcached时的内存控制策略) -->
		<property name="bufferAllocator">
			<bean class="net.rubyeye.xmemcached.buffer.SimpleBufferAllocator" />
		</property>
		<!-- 协议工厂net.rubyeye.xmemcached.command.BinaryCommandFactory(二进制),TextCommandFactory(文本),KestrelCommandFactory(可靠获取),本应用配置二进制方式 -->
		<property name="commandFactory">
			<bean class="net.rubyeye.xmemcached.command.BinaryCommandFactory" />
		</property>
	</bean>

	<bean name="serverA" class="java.net.InetSocketAddress">
		<constructor-arg>
			<value>10.0.1.75</value>
		</constructor-arg>
		<constructor-arg>
			<value>12000</value>
		</constructor-arg>
	</bean>

	<bean name="serverB" class="java.net.InetSocketAddress">
		<constructor-arg>
			<value>10.0.1.76</value>
		</constructor-arg>
		<constructor-arg>
			<value>12000</value>
		</constructor-arg>
	</bean>

	<bean name="serverC" class="java.net.InetSocketAddress">
		<constructor-arg>
			<value>10.0.1.77</value>
		</constructor-arg>
		<constructor-arg>
			<value>12000</value>
		</constructor-arg>
	</bean>


调用


@Resource
public MemcachedClient memcachedClient;

    public void testString() {
        try {
            for (int i = 1024; i < 1024 * 2; i++) {
                memcachedClient.set("zy" + i, 0, i);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

更多Memcached操作，请查看Memcached之存储命令(2)，然后在Xmemcached客户端找对应的方法。
Java API调用
查看：https://github.com/killme2008/xmemcached

        @Test
	public void javaExample() throws MemcachedException, InterruptedException, TimeoutException, IOException {
		XMemcachedClientBuilder builder = new XMemcachedClientBuilder(AddrUtil.getAddresses("localhost:11211"));
		builder.setCommandFactory(new BinaryCommandFactory());
		builder.setCommandFactory(new KestrelCommandFactory());
		XMemcachedClient client = (XMemcachedClient) builder.build();

		client.setPrimitiveAsString(true);

		client.addServer("10.0.1.75:12000 10.0.1.76:12000");
		client.removeServer("10.0.1.75:12000 10.0.1.76:12000");

		// get operation
		String name = client.get("test");

		// set add replace append prepend gets
		client.add("hello", 0, "dennis");
		client.replace("hello", 0, "dennis");
		client.append("hello", " good");
		client.prepend("hello", "hello ");
		GetsResponse response = client.gets("hello");
		long cas = response.getCas();
		Object value = response.getValue();

		// incr decr
		client.set("a", 0, "1");
		client.incr("a", 4);
		client.decr("a", 4);

		// cas
		client.cas("a", 0, new CASOperation() {
			@Override
			public int getMaxTries() {
				return 1; // max try times
			}

			@Override
			public Object getNewValue(long currentCAS, Object currentValue) {
				System.out.println("current value " + currentValue);
				return 3; // return new value to update
			}
		});

		// flush_all
		client.flushAll();

		// stats
		Map<InetSocketAddress, Map<String, String>> result = client.getStats();

		// get server versions
		Map<InetSocketAddress, String> version = client.getVersions();

		// bulk get
		List<String> keys = new ArrayList<String>();
		keys.add("hello");
		keys.add("test");
		Map<String, Object> map = client.get(keys);
	}
常见问题
如果启动的协议是二进制的，必须在Spring配置文件指定（xmemcached默认的协议是：net.rubyeye.xmemcached.command.TextCommandFactory），不然会打印如下异常：
net.rubyeye.xmemcached.exception.MemcachedException: Session has been closed
    at net.rubyeye.xmemcached.impl.MemcachedTCPSession.destroy(MemcachedTCPSession.java:111)
    at net.rubyeye.xmemcached.impl.MemcachedHandler.onSessionClosed(MemcachedHandler.java:164)
    at com.google.code.yanf4j.core.impl.AbstractSession.onClosed(AbstractSession.java:306)
    at com.google.code.yanf4j.core.impl.AbstractSession.close(AbstractSession.java:294)
    at com.google.code.yanf4j.nio.impl.NioTCPSession.decode(NioTCPSession.java:311)
    at com.google.code.yanf4j.nio.impl.NioTCPSession.decodeAndDispatch(NioTCPSession.java:237)
    at com.google.code.yanf4j.nio.impl.NioTCPSession.readFromBuffer(NioTCPSession.java:207)
    at com.google.code.yanf4j.nio.impl.AbstractNioSession.onRead(AbstractNioSession.java:196)
    at com.google.code.yanf4j.nio.impl.AbstractNioSession.onEvent(AbstractNioSession.java:341)
    at com.google.code.yanf4j.nio.impl.SocketChannelController.dispatchReadEvent(SocketChannelController.java:56)
    at com.google.code.yanf4j.nio.impl.NioController.onRead(NioController.java:157)
    at com.google.code.yanf4j.nio.impl.Reactor.dispatchEvent(Reactor.java:323)
    at com.google.code.yanf4j.nio.impl.Reactor.run(Reactor.java:180)常见问题会持续更新。。。


版权声明：本文为博主原创文章，未经博主允许不得转载。

Memcached之Window和Linux安装（1）

Window安装Memecached
windows下使用memcached，直接在网上下载memcached.exe即可。



Linux安装Memecached

1，首先下载Memached安装包：http://www.memcached.org/files/memcached-1.4.22.tar.gz


2，另外，Memcache用到了libevent这个库用于Socket的处理，所以还需要安装libevent。（如果系统已经安装了libevent，可以不用安装）

yum install libevent libevent-devel -y
3，[root@bicloud75 memcached-1.4.22]# ./configure --prefix=/home/memcached
4，[root@bicloud75 memcached-1.4.22]# make
5，[root@bicloud75 memcached-1.4.22]# make
 install


[root@bicloud75 memcached]# cd
 /home/memcached
[root@bicloud75 memcached]# ll
总用量 12
drwxr-xr-x. 2 root root 4096 3月  12 18:47 bin
drwxr-xr-x. 3 root root 4096 3月  12 18:47 include
drwxr-xr-x. 3 root root 4096 3月  12 18:47 share

安装成功！



启动Memcached


/home/memcached/bin/memcached -d -m 10 -u root -p 12000 -c 256 -P /tmp/memcached.pid





选项

含义说明



-d

指定memcached进程作为一个守护进程启动



-m <num>

指定分配给memcached使用的内存，单位是MB



-u <username>

运行memcached的用户



-l <ip_addr>

监听的服务器IP地址，如果有多个地址的话，使用逗号分隔，格式可以为“IP地址:端口号”，例如：-l 指定192.168.0.184:19830,192.168.0.195:13542；端口号也可以通过-p选项指定



-p <num>

Memcached监听的端口，要保证该端口号未被占用



-c <num>

设置最大运行的并发连接数，默认是1024



-R <num>

为避免客户端饿死（starvation），对连续达到的客户端请求数设置一个限额，如果超过该设置，会选择另一个连接来处理请求，默认为20



-k

设置锁定所有分页的内存，对于大缓存应用场景，谨慎使用该选项



-P

保存memcached进程的pid文件



-s <file>

指定Memcached用于监听的UNIX socket文件



-a <perms>

设置-s选项指定的UNIX socket文件的权限（默认是：0700）



-U <num>

指定监听UDP的端口，默认11211，0表示关闭



-M

当内存使用超出配置值时，禁止自动清除缓存中的数据项，此时Memcached不可以，直到内存被释放



-r

设置产生core文件大小



-f <factor>

用于计算缓存数据项的内存块大小的乘数因子，默认是1.25



-n

为缓存数据项的key、value、flag设置最小分配字节数，默认是48



-C

禁用CAS



 -c


  最大同时连接（默认值：1024）




-h

打印版本信息和帮助信息。



-V


打印版本信息。





-v

输出警告和错误信息。



-vv

打印信息比-v更详细：不仅输出警告和错误信息，也输出客户端请求和响应信息



-vvv

打印信息比-vv还要详细，打印Memcached内部状态。



-i

打印libevent和Memcached的licenses信息



-t <threads>

指定用来处理请求的线程数，默认为4



-D <char>

用于统计报告中Key前缀和ID之间的分隔符，默认是冒号“:”



-L

尝试使用大内存分页（pages）



-B <proto>

指定使用的协议，默认行为是自动协商（autonegotiate），可能使用的选项有auto、ascii、binary。



-b


设置阻塞队列的限制，默认是1024



-I <size>

覆盖默认的SLAB页大小，默认是1M



-A


  启用ASCII“关机”命令




-F

禁用flush_all命令



-o <options>

指定逗号分隔的选项，一般用于用于扩展或实验性质的选项




停止Memcached

可以通过Linux的如下命令查询到Memcached的进程号：

ps -ef | grep memcached


然后杀掉Memcached服务进程：
kill-9 <PID>
在有些场景下，Memcached因为服务器宕机，我们需要在服务器重启的时候自动启动Memcached时，可以将Memcached启动添加到/etc/rc.d/rc.local中，这样服务器启动的时候就能启动Memcached了，
在/etc/rc.d/rc.local添加加入一行，如下：
/home/memcached/bin/memcached -d -m 10 -u root -p 12000 -c 256 -P /tmp/memcached.pid


版权声明：本文为博主原创文章，未经博主允许不得转载。

Memcached之存储命令(2)
telnet连接到Memcached服务器以后，可以使用很多命令，比如：get，gets，set，touch，delete，add，replace，append，prepend，incr，decr，cas，flush_all，version，quit等等

Memcached存储命令的格式：

<command name> <key> <flags> <exptime> <bytes>
<data block>

参数说明如下：




<command name>

set/add/replace



<key>

查找关键字



<flags>

客户机使用它存储关于键值对的额外信息



<exptime>

该数据的存活时间，0表示永远



<bytes>

存储字节数



<data block>

存储的数据块（可直接理解为key-value结构中的value）



添加命令

set
使用set不管什么情况都会把数据存到Memcached，即set命令既有添加的作用也有更新的作用。


set fish 7 0 8
12312312
STORED

add
只有当Key在Memcached不存在的时候才会添加。

//key不存在的情况下
add fish 0 0 7
1234567
STORED
//key已经存在的情况下
add fish 0 0 7
1234567
NOT_STORED


replace
只有当Key存在的时候才替换

//Key存在的情况下，replace成功
replace fish 0 0 8
12345678
STORED
<pre name="code" class="java">//Key不存在的情况下，replace不成功
replace fish1 0 0 8 12345678NOT_STORED



touch
更新Memcached中Key对应的值的过期时间。

//key：exp不存在
touch exp 2000
NOT_FOUND
//key：fish存在
touch fish 2000
TOUCHED

prepend
在一个已经存在的数据值（value）上追加，是在数据值的前面追加。

//Key:fish2不存在，不会存储
prepend fish2 0 0 2
12
NOT_STORED
//set Key:fish2
set fish2 0 0 2
12
STORED
//在Key：fish2的前面追加字符串“12”
prepend fish2 0 0 2
12
STORED
//查看值
get fish2
VALUE fish2 0 4
1212
END


append
在一个已经存在的数据值（value）上追加，是在数据值的后面追加。
incr
计数命令，可以在原来已经存在的数字上进行累加求和，计算并存储新的数值。


//key：fish3设置值为“b”
set fish3  0 0 1
b
STORED
//在key：fish3的基础上加2，因为fish3是字符类型，所以报错。
incr fish3 2
CLIENT_ERROR cannot increment or decrement non-numeric value
//修改fish3的值为2
replace fish3 0 0 1
2
STORED
//fish3加2
incr fish3 2
4


decr
计数命令，可以在原来已经存在的数字上进行减法计算，计算并存储新的数值。


删除命令

delete

删除指定key的值

//不存在
delete fish1
NOT_FOUND
//存在
delete fish
DELETED
获取命令
get

get命令的Key可以表示一个或者多个键，键之间以空格隔开

get fish fish1
VALUE fish 0 7
1234567
VALUE fish1 0 1
1
END
gets
gets和get一样，Key可以表示一个或者多个键，键之间以空格隔开。唯一的区别是gets会打印出各个Key变化的版本。


gets fish fish1
VALUE fish 0 7 7
1234567
VALUE fish1 0 1 8
1
END

cas

cas即checked and set的意思，当最后一个参数和gets所获取的参数匹配时才能存储，否则返回“EXISTS”。


cas fish 0 0 2 8
12
EXISTS
//VALUE fish 0 7 7，索引存储成功。
cas fish 0 0 2 7
22
STORED

其他
flush_all


flush_all
OK

version


version
VERSION 1.4.22




telnet退不出去怎么办？
很简单先Ctrl+]，然后quit退出telnet

^]
telnet> quit
Connection closed.


版权声明：本文为博主原创文章，未经博主允许不得转载。

Solr 配置文件之core.properties、solr.xml和Config Sets

从5.0开始，solr采用了自动发现模式（discovery，区别于传统模式legacy），Solr会自动找到安装目录中、或solr_home中的配置文件：core.properties，并根据里面的name属性来初始化相对于的core。solr.xml中仍然会定义一些配置参数，但是core本身不会定义在这个文件中。



Solr会递归搜索所有solr和solr_home目录和子目录，当在一个目录中发现core.properties后，就停止搜索当前目录的所有子目录，转向下一个同级目录搜索。所以，下面两个配置只有第一个生效：


./cores/core1/core.properties

./cores/core1/coremore/core5/core.properties
而下面三个配置，都会生效：


./cores/somecores/core1/core.properties

./cores/somecores/core2/core.properties

./cores/othercores/core3/core.properties


一个core.properties文件代表一个core。文件的内容可以是空的，这个时候，solr会把该文件所在的目录作为name，比如跟./cores/core1/core.properties对应的core name就是core1；instanceDir就是./cores/core1；dataDir就是./cores/core1/data，等等。


core.properties配置参数：


name：SolrCore的名字config：该core的配置文件名字，缺省是solrconfig.xmlschema：schema文件的名字，缺省是schema.xmldataDir：索引文件的存放位置，相对于instanceDir的相对路径，缺省是“data”configSet：configSet的名字properties：该core的额外属性文件的路径和名字，可以是绝对路径、或相对于instanceDir的相对路径transient：如果是true，当solr达到transientCacheSize这个限定时，这个core会被卸载（unload）；缺省是false，即使用LRU原则卸载。SolrCloud模式下true是不推荐的loadOnStartup：缺省是true，就是在solr启动的时候启动该core。SolrCloud模式下false是不推荐的coreNodeName：只在SolrCloud的情况下使用，是这个replica所在的node的标识。这个名字缺省是自动生成的。这个配置的名字可以在以后需要替换一个自动生成的名字的时候使用，比如使用一个新机器（新的hostname和port）替换一个坏机器的时候ulogDir：存放update log的绝对或相对路径（SolrCloud）shard：这个core所归属的shard（SolrCloud）collection：这个core所属的collection名字（SolrCloud）
roles：SolrCloud的一个保留参数，未来可能会用到，或用户用了做一些自己的标记

另外，用户还可以定义自己的属性，以作为其他配置文件的变量。


solr.xml配置标签：


<solrcloud/>：定义几个跟SolrCloud相关的参数，当solr启动参数带有-DzkRun 或 -DzkHost时，这个标签才生效<logging/>：定义跟日志相关的配置参数<shardHandlerFactory/>：配置自定义的shard handler




Config Sets：
在multicore的solr实例中，可以利用config set来提供统一的配置文件给各个core共享。这个可以通过在configSetBaseDir目录下创建一个目录来实现，该目录的结构如下：
/<configSetBaseDir>
    /configset1
        /conf
            /schema.xml
            /solrconfig.xml
    /configset2
        /conf
            /schema.xml
            /solrconfig.xml
缺省的configSetBaseDir就是$SOLR_HOME/configsets，也可以在solr.xml中指定这个目录。


非SolrCloud模式下，可以通过CoreAdmin API，把configset作为参数来创建一个新的core，比如：
http://<solr>/admin/cores?action=CREATE&name=mycore&instanceDir=path/to/instanc e&configSet=configset2


如果是SolrCloud模式下，配置信息是从zookeeper数据库中获取的。








版权声明：本文为原创文章，转载请注明转自Clement-Xu的csdn博客。

机器学习算法面试—口述（3）：贝叶斯分类器


这个系列是为了应对找工作面试时面试官问的算法问题，所以只是也谢算法的简要介绍，后期会陆续补充关于此算法的常见面试的问题！



贝叶斯分类器的原理其实很简单，知道了贝叶斯公式基本上就知道了贝叶斯分类器的工作原理。对于一个待分类项，求出此项出现的条件下哪个类别的概率大，就判定为哪类，仅次而已。其实贝叶斯分类器是建立在错误的理论上建立起来的分类器，没错就是错误的理论，它假定事物之间是没有联系的（马克思告诉我们，这是不可能的。。。），从而大大的简化了计算。
算法的过程如下：
首先核心的是贝叶斯公式：P(B | A) = P(A, B) / P(B) = P(A | B) * P(A) / P(B)；从而将P(B | A)转化为P(A | B) 。
设X = {a1, a2, ... , am}, a为x的一个属性，C = {y1, y2,..., yn}，为类别。计算P(y1| X), P(y2| X), ...., P(yn|
 X)哪个大，哪个大就判定为哪个类别。问题的关键就是求P(y1| X), P(y2| X), ...., P(yn| X)，但是直接求是求不出来的，这时就要靠贝叶斯公式了。
首先可以统计某个类别出现时给个属性出现的概率
P(a1|
 y1), P(a2| y1), ...., P(am| y1)

P(a1|
 y2), P(a2| y2), ...., P(am| y2)

.........................................................
P(a1|
 yn), P(a2| yn), ...., P(am| yn)

之后利用朴素贝叶斯的思想 + 贝叶斯公式
P(yi | X) = P(X|yi)*P(yi) / P(X),是要比较这个式子的结果谁的大，分母都是一样的，所以只需要比较P(X|yi)*P(yi) ，其中P(yi) 可以通过训练数据统计出来，P(X|yi)用朴素贝叶斯的理论求出来P(X|yi)
 = P(a1| yi)  * P(a2| yi) * .... * P(am| yi)
整个这个过程就是贝叶斯的思想了。
整个过程存在两个问题
1、分母为0，可以使用拉普拉斯校准；
2、概率连乘后过小，可以使用对数表示；
3、朴素贝叶斯理论错误，改用贝叶斯网络；


现在简要说下贝叶斯网络，贝叶斯网络是由有向无环图（DAG）和条件概率表组成，DAG中每个节点表示一个随机变量，是一个可以直接观测或则隐藏的变量，有向边表示随机变量的条件依赖，条件概率表中给出了DAG中边的依赖程度。
贝叶斯网络的一个核心的性质是：一个节点在给定了前驱节点的值后，此节点独立于任何非直接前驱节点。
之后的计算和前面的贝叶斯分类器差不多。
贝叶斯网络的关键在于如何训练网络，即如何得到DAG以及条件概率表，这是一个NP问题，贝叶斯网络的训练一般是用梯度下降法，而网络的拓扑结构一般由专家解决（这是资料上说的，我也没做过这个。。。）。



版权声明：本文为博主原创文章，未经博主允许不得转载。

天下数据：浅析90创业者的吹牛之道

如今，“吹牛”几乎成为互联网创业者的必备技能之一。当余佳文这个名字因为“一亿元”利润的一年之约再一次出现在大众视野时，舆论导向再次将90后创业者的诚信问题引到风口浪尖。就说最近小天家推出的天下云—香港云主机，广告写的多么好多么好，但是水分我相信也是有一点点的。
虽然提倡“大众创业、万众创新”，但现有资金规模和渠道比较狭窄给新一代创业者带来更大的竞争压力。对比过去的互联网创业者，创业群体人数变大但成功率并没有明显提高。这给创业者带来不少压力。同时，互联网创业对企业发展速度要求更高。
新一代创业者表现出鲜明个性，不怯场、不惧表达自己的观点和意见，因此当他们感受到这种创业的压力，自然选择一条更为容易的捷径。
吹牛能为创业者提供企业起步所需要的一切：关注度以及资金。但是同时，他们也面临吹牛被戳破所带来的诚信危机，这是一把双刃剑，而选择的权利永远把握在创业者手中。
为什么“吹”?
创业者吹牛，更大程度来自于竞争的压力以及对于创业成功的焦虑。舆论以及投资人让他们信奉一个“真理”：谦虚越谦越虚，吹牛越吹越牛。但是，达不到目标之后往往带来更大的焦虑。
在许多创业者看来，“吹牛”不完全出自本能，而多了“被逼上梁山”的意味。
中国就业促进会发布的《网络创业就业统计和大学生网络创业就业研究报告》显示，全国有超过千万的网络创业就业人数。其中，80、90后青年群体成为网络创业的绝对主体，大学生网络创业人数达到600多万。
然而，即便是在浙江等创业氛围较好的城市，中国大学毕业生创业成功率也不足5%。项目众多，但好的投资机构并不多，巨大的竞争压力使一些创业者选择比较轻松的路径。这时，一个好的故事不但能吸引公众目光，为产品带来更多用户，还能为企业带来源源不断的热钱。
   “互联网的资本都是追求速度的，而互联网的企业很多又是整合资源型的，看谁整合得快、整合得多，不断有人在追问你的发展，许多人就会开始夸大成绩。”一位垂直细分服务APP开发者告诉记者。
余佳文曾经豪言一年之内挣到一亿元给员工，熟悉创业阶段的人都知道这事难度非常大，近乎不可能。
百度公布的调查问卷显示，35%的受访大学生在18~22岁尝试第一次创业。
大学生创业与传统创业者不同，企业起步阶段并不具备盈利能力，很多企业甚至连盈利模式都不清晰。众所周知，引人入胜的故事能吸引公众的关注为产品积累人气。投资大学生创业者，投资人看重的是激情和梦想，并不要求企业有具体的盈利模式，企业都是一边拿着投资人的钱，一边研究盈利模式。
在初期，股权投资成为初创互联网企业主要的资金来源。从投资者的角度，企业越受关注，退出的渠道就更加多样，也更有保障。
   “有时投资人也会帮忙吹牛，有些投资人是看噱头的，投入少量资金包装一下继续忽悠另一些人来投资让项目增值，A轮忽悠B轮，找下家。”上述创业者说道。
超级课程表推出之后先后进行几轮融资，但产品本身并没有具体盈利，据了解，目前，线上社交以及课程表并不收取任何费用，同时产品本身并没有广告能够产生费用，那么半年5000万的利润更大的可能是投资人所投资金。
这一年，我们看到太多动辄上千万的融资、太多上百万的活跃用户，看到很多宣传与产品现实的落差。夸大而不能落实的言论不仅伤害了企业本身，也伤害了90后创业者这个群体。
新一代创业者多少在互联网前辈身上学到“吹牛”的本领，然而最早成长起来的互联网企业，如阿里、乐视等的“吹”更多是一种鼓吹，而不是毫无根据的吹嘘。吹牛与真牛的评判标准在于最后能否实现。创业者如果选择在公司起步阶段就吹牛，那么后果很可能是影响投资机构对公司或者创业者的印象，而这种影响像滚雪球一样越滚越大，最后对公司后期融资也会造成影响。
　　


版权声明：本文为博主原创文章，未经博主允许不得转载。

机器学习算法面试—口述（4）：决策树
这个系列是为了应对找工作面试时面试官问的算法问题，所以只是也谢算法的简要介绍，后期会陆续补充关于此
算法的常见面问题！
决策树是一种依托于策略抉择而建立起来的树，是一种依托于分类、训练上的预测树，根据已知，预测和分类未来。
决策树的建立是不断的使用数据的特征将数据分类的过程，主要的问题在于如何选择划分的特征；
常用的几种决策树算法有ID3、C4.5、CART等；其中ID3使用的是信息熵增益选大的方法划分数据，C4.5是使用增益率选大的方法划分数据，CART使用的是基尼指数选小的划分方法；
ID3：
该算法是以信息论为基础，以信息熵和信息增益度为衡量标准，从而实现对数据的归纳分类。ID3算法往往偏向于选择取值较多的属性，而在很多情况下取值较多的属性并不总是最重要的属性。而且ID3算法不能处理具有连续值的属性，也不能处理具有缺失数据的属性。
  具体怎么算可以看一个例子：http://wenku.baidu.com/link?url=V_-Eh4p8UVaV93xT2MKUlbDVT1k1b9khZNa1hJOb1Fx0mNTDaLYLNqs4Chlz5nErVTtRG7V60RzPggzuZk26gyocFYXbliZhZ7VjDFqjfHe
C4.5：
  使用的是增益率的划分方法，是ID3的一个改进，具有较高的准确率且可以处理连续属性。在构造树的过程中进行剪枝，使用的是悲观剪枝法（使用错误率来评估）！在构造树的过程中需要对树进行多次顺序扫描和排序，因此效率比较低，并且C4.5只适用于能够滞留于内存的数据集。
具体怎么算可以看一个例子：http://blog.csdn.net/xuxurui007/article/details/18045943
    关于树的剪枝，可以参考：http://blog.csdn.net/woshizhouxiang/article/details/17679015
CART：
    使用基尼指数的划分准则；通过在每个步骤最大限度降低不纯洁度，CART能够处理孤立点以及能够对空缺值进行处理。
    树划分的终止条件：1、节点达到完全纯度； 2、树的深度达到用户所要深度
      3、节点中样本的数量属于用户指定的个数；
    树的剪枝方法是代价复杂性的剪枝方法；
    具体见：http://blog.csdn.net/tianguokaka/article/details/9018933



版权声明：本文为博主原创文章，未经博主允许不得转载。

计算机网络——计算机网络和因特网

1、通信网络
1）电路交换：通信前先拨号，构建直通通路
2）分组交换（不是包交换）：不用拨号，存储转发交换
3）虚拟电路交换：介于两者间，中间设备ATM存储后再转发，本质存储转发 

2、网络架构（Internet是瘦内核，胖端系统；电话、手机是胖内核，瘦端系统）
1）内核：路由器（构成mesh），交换机 
2）边缘：应用，所有服务都位于边缘 
3）通信链路 

3、通信模式
C/S模式、对等模式、混合模式 

4、交换模型
电路交换、分组交换(按需使用、路由器具有存储并转发分组的队列、统计复用) 
1）分组交换优点：
     带宽共享，按需使用
     更简单高效，代价更小
     突发数据支持较好
     承载用户量多
     交换技术 
2）分组交换缺点：每到节点都要存储再转发，速度慢，不适合实时通讯 

5、协议：报文命令，格式和收发报文的动作。
协议={语法，语义，规则}

6、网络接入
有线：ADSL、光纤入户、ISDN、HFC
无线：Wi-Fi、GPRS、CDMA、3G、4G

7、ADSL：非对称数字用户线
1）上下行链路带宽不一致，下行快一些
2）频分复用
3）不共享带宽
4）需使用调制解调器（促进抗干扰，传送远）
5）远距离串行通信
6）带宽与距离成反比

8、HFC：混合光纤同轴电缆
1）带宽大于ADSL
2）需要电缆调制解调器
3）若干用户共享一个路由器

9、带宽：线两端交换设备的能力。

10、物理媒介
①双绞线：数字性好，抗干扰能力强，上限带宽高。每英寸绞的圈数越多，抗干扰能力越好。
②同轴电缆
③光纤：安全性高，信号衰减低，不受电子干扰，差错率低 。

11、无线媒介
微波通信、Wi-Fi、卫星通信、CDPD

10、四种包交换延时
1）节点处理延时：检查位差错，决定输出链路。
2）传送延时=包大小/路由器带宽
3）传播延时=距离/光速
4）排队延时 ：若路由器缓存满，则丢包

11、丢包
1）路由上的丢包
①队列满，被动丢包
②TTL满，主动丢包
2）接收端丢包：接收端缓存满
3）网卡丢包：差错检验 

12、协议栈 五层 
应用层(PDU：报文) 
传输层(段)
网络层(包/数据报)
数据链路层(帧)
物理层(位)：第一层

13、分组交换和电路交换的区别
分组交换的通信线路并不专用于源与目的地间的信息传输。在要求数据按先后顺序且以恒定速率快速传输的情况下，使用电路交换是较为理想的选择。
因此，当传输实时数据时，诸如音频和视频；或当服务质量QOS要求较高时，通常使用电路交换网络。
分组交换在数据传输方面具有更强的效能，可以预防传输过程(如E-mail信息和Web页面)中的延迟和抖动现象,分组交换网的突出优点是可以在一条电路上同时开放多条虚电路，为多个用户同时使用，网络具有动态路由功能和先进的误码纠错功能，网络性能最佳。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Solr 配置文件之solrconfig.xml
顾名思义，solrconfig.xml主要是配置跟自身相关的参数，比如：



为建索引和搜索等请求配置Request Handler为某些事件配置listener，以触发执行某些代码为HTTP请求配置Request Dispatcher配置Admin Web为分布式的复制配置相关的参数




这个配置文件位于每个collection的conf/中，在server/solr/configsets/目录下有一些例子可以参考。


solrconfig.xml配置文件支持使用变量，格式如下：
${propertyname[:option default value]}
冒号后面的是缺省值，冒号前面的值可以来自于：


JVM的-D参数，比如：bin/solr start -Dpropertyname=none.properties等配置文件，比如solrcore.properties、core.properties等文件



<lib/>标签：


用途：配置插件的jar包，比如指定中文分词器jar包的位置注意事项：被依赖的包配置在前面



<requestHandler/>标签：


用途：配置Solr处理各种请求（搜索/select、更新索引/update、等）的各种参数主要参数：

name：作为HTTP请求路径的一部分，比如：http://localhost:8983/solr/gettingstarted/select?q=solrclass：处理请求的类initParams：可选。引用<initParams>标签中的配置
<lst name="defaults">：定义各种缺省的配置，比如缺省的parser、缺省返回条数




例子：
 <requestHandler name="/select" class="solr.SearchHandler">
    <lst name="defaults"> 
      <str name="echoParams">explicit</str>
          <str name="defType">edismax</str>
      <int name="rows">10</int>
    </lst>
  </requestHandler>


几种常用的Request Handler


SearchHandlers：用于处理搜索请求UpdateRequestHandlers：用于更新索引DataImportHandlers：用于从数据库导入数据



例子：
<requestHandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler">
  <lst name="defaults">
    <str name="config">data-config.xml</str>
  </lst>
</requestHandler>


<initParams/>标签：



用途：为一些requestHandlers定义通用的配置，以便在一个地方修改后，所有地方都生效主要参数：

path：指明该配置应用于哪些请求路径，多个 的话用逗号分开，可以用通配符（*表示一层子路径，**表示无限层）name：如果不指定path，可以指定一个name，然后在<requestHander>配置中可以引用这个name


例子（配置一个缺省的df）：
  <initParams path="/update/**,/query,/select,/tvrh,/elevate,/spell,/browse">
    <lst name="defaults">
      <str name="df">_text_</str>
    </lst>
  </initParams>


如果配置name，在<requestHander>中引用的例子：
<requestHandler name="/dump1" class="DumpRequestHandler"  initParams="myParams"/>


<updateHandler/>标签：


用途：定义一些更新索引相关的参数，比如定义commit的时机主要参数：

autoCommit：定义自动commit的触发条件。如果没配置这个参数，则每次都必须手动commit

maxDocsmaxTime（毫秒）openSearcher：autoCommit结束后，是否开启一个新的searcher让更改生效。缺省为false
autoSoftCommit：定义自动softCommit的触发条件。相关参数同autoCommitlistener：配置事件监听器

event：监听哪个事件，比如：event="postCommit", event="postOptimize"class：处理的类，可以是自己的实现类。如果是RunExecutableListener，可以配置下面的参数：

exe：可执行文件，包括Solr Home的相对路径和文件名dir：工作目录，缺省是“.”wait： 调用者是否等待可执行文件执行结束，缺省是trueargs：传递给可执行文件的参数env：其他所需要的环境变量

updateLog：配置log的保存路径、等

dir：保存路径numRecordsToKeep：一个log保存的记录数，缺省为100maxNumLogsToKeep：log的数量，缺省为10numVersionBuckets：追踪max version的bucket数量（？），缺省为65535





配置这些参数要考虑到搜索的准确度和性能的平衡。^_^


注：commit和softCommit：


commit：正式提交、对索引的修改会被保存到永久存储中（比如磁盘），会比较耗时softCommit：软提交，对索引的修改会被立即应用到工作中的索引中，即立即生效，但没有保存进磁盘



<query/>标签：



用途：配置Solr如何处理和返回搜索的相关参数主要参数：

filterCache：当搜索带有“fq”参数时，使用这个配置，它保存未经过排序的所有文档

class：实现类，有三种：solr.search.LRUCache, solr.search.FastLRUCache, solr.search.LFUCachesize：最大保存的记录数量initialSize：初始数量autowarmCount：新Index Searcher启动的时候从旧的Index Searcher缓存拷贝过来的数据量
queryResultCache：存储最终的搜索结果（排序后的、有范围的文档id）

class：实现类，有三种：solr.search.LRUCache, solr.search.FastLRUCache, solr.search.LFUCachesize：最大保存的记录数量initialSize：初始数量autowarmCount：新Index Searcher启动的时候从旧的Index Searcher缓存拷贝过来的数据量maxRamMB：最大分配的容量（兆）
documentCache：缓存Lucene Document对象（就是每个文档的fields）

class：实现类，有三种：solr.search.LRUCache, solr.search.FastLRUCache, solr.search.LFUCachesize：最大保存的记录数量initialSize：初始数量autowarmCount：因为Lucene的内部文档 id 是临时的，所以这个缓存不应该被auto-warm，这个值应该为“0”
cache：配置自定义的缓存，通过SolrIndexSearcher类的getCache()方法和name参数调用这个缓存

name：被调用时的标识其他参数同上
maxBooleanClauses：BooleanQuery的最大子句数量enableLazyFieldLoading：没有知道被请求的field是否懒加载，true/falseuseFilterForSortedQuery：如果不是按照score排序，是否从filterCache中获取数据queryResultWindowSize：配合queryResultCache使用，缓存一个超集。如果搜索请求第10到19条记录，而这个参数是50，那么会缓存0到49条记录queryResultMaxDocsCached：queryResultCache缓存的最大文档数量useColdSearcher：但一个新searcher正在warm-up的时候，新请求是使用旧是searcher（true）还是等待新的search（false）maxWarmingSearchers：定义同时在warn-up的searcher的最大数量listener：监听一些事件并指定处理的类，比如在solr启动时加载一些数据到缓存中，相关参数：

event：被监听的事件，比如：firstSearcher是第一个searcher启动、也就是solr启动的事件，newSearcher是当已经有searcher在运行的时候有新searcher启动的事件class：处理类name：="queries"就是需要处理的是query

lst, name：针对哪些搜索条件需要处理






<requestDispatcher/>标签：



用途：控制Solr HTTP RequestDispatche r响应请求的方式，比如：是否处理/select url、是否支持对流的处理、上传文件的大小、如何处理带有cache头的HTTP请求、等等主要参数：

handleSelect：true/false，如果是false，则由requestHandler来处理/select请求。因为现在的requestHandler中/select是标配，所以这里应该填falserequestParsers：

enableRemoteStreaming：是否接受流格式的内容，缺省为turemultipartUploadLimitInKB：multi-part POST请求，上传文件的大小上限（K）formdataUploadLimitInKB：HTTP POST的form data大小上限（K）addHttpRequestToContext：原始的HttpServletRequest对象是否应该被包含在SolrQueryRequest的httpRequest中……一般自定义的插件使用这个参数……
httpCaching：如何处理带有cache control头的HTTP请求

nerver304：如果设为true（开发阶段），则就算所请求的内容没被修改，也不会返回304，并且下面两个参数会失效lastModFrom：最后修改时间的计算方式，openTime：Searcher启动的时刻；dirLastMod：索引更新的时刻etagSeed：HTTP返回的ETag头内容cacheControl：HTTP返回的Cache-Control头内容





<updateProcessor/>和<updateProcessorChain/>标签：


用途：配置处理update请求的处理器、处理器链。如果不配置的话，Solr会使用缺省的三个处理器：

LogUpdateProcessorFactory：追踪和记录日志DistributedUpdateProcessorFactory：分流update请求到不同的node，比如SolrCloud的情况下把请求分配给一个shard的leader，然后把更新应用到所有replica中RunUpdateProcessorFactory：调用Solr的内部API执行update操作
如果需要自定义update处理器：

updateProcessor：

class：负责处理的类name：名字，给updateProcessorChain引用是使用
updateProcessorChain：

name：自己的名字标记processor：指定updateProcessor的name，多个的话用逗号“,”分开





相关名词：


Solr缓存：跟整个Index Searcher的生命周期对应，没有超时被清理掉的机制，只会在容量满了的时候被清理Index Searcher：负责处理搜索。当一个新的searcher启动的时候会从当前searcher拷贝缓存数据（warming），当前searcher的结束条件：它正在处理的request已经完成、缓存拷贝已经完成LRU缓存：清理缓存的时候，优先清理掉最近不用的那些数据（Least Recently Used）LFU缓存：清理缓存的时候，优先清理掉使用次数最少的那些数据（Least Frequently Used）












版权声明：本文为原创文章，转载请注明转自Clement-Xu的csdn博客。

Memcached之stats命令(3)
telnet连接到Memcached服务器以后，可以使用很多命令，比如：get，gets，set，touch，delete，add，replace，append，prepend，incr，decr，cas，flush_all，version，quit等等
还有就是该篇要讲的stats命令，该命令可以获取到memcached服务器的相关信息。
stats

[root@bicloud75 memcached-1.4.22]# telnet 127.0.0.1 12000
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
stats
STAT pid 17357  //memcached服务进程的进程ID
STAT uptime 1569  //从启动到当前所经过的时间，单位是秒。
STAT time 1439175334 //服务器当前的unix时间戳
STAT version 1.4.22  //memcache版本
STAT libevent 1.4.13-stable  //libevent版本
STAT pointer_size 64  //当前操作系统的指针大小（32位系统一般是32bit,64就是64位操作系统）
STAT rusage_user 0.027995  //进程的累计用户时间
STAT rusage_system 0.023996  //进程的累计系统时间
STAT curr_connections 5  //当前打开着的连接数
STAT total_connections 9  //表示从memcached服务启动到当前时间，系统打开过的连接的总数。
STAT connection_structures 6  //表示从memcached服务启动到当前时间，被服务器分配的连接结构的数量
STAT reserved_fds 20
STAT cmd_get 2  //get命令的请求次数
STAT cmd_set 5  //set命令的请求次数
STAT cmd_flush 0  //flush_all命令的请求次数
STAT cmd_touch 0  //touch命令的请求次数
STAT get_hits 1  //表示get数据命中的次数。
STAT get_misses 1  //表示get数据未命中的次数。
STAT delete_misses 0  //表示delete数据未命中的次数。
STAT delete_hits 0  //表示delete数据命中的次数。
STAT incr_misses 0  //表示incr数据未命中的次数。
STAT incr_hits 0  //表示incr数据命中的次数。
STAT decr_misses 0  //表示decr数据未命中的次数。
STAT decr_hits 0  //表示decr数据命中的次数。
STAT cas_misses 0  //表示cas数据未命中的次数。
STAT cas_hits 0  //表示cas数据命中的次数。
STAT cas_badval 0  //cas操作找到key，但版本过期，没有设置成功
STAT touch_hits 0  //表示touch数据命中的次数。
STAT touch_misses 0  //表示touch数据未命中的次数。
STAT auth_cmds 0  //认证命令处理的次数
STAT auth_errors 0 //认证失败的次数
STAT bytes_read 1248  //从网络读取的总的字节数。
STAT bytes_written 4118  //发送到网络的总的字节数。
STAT limit_maxbytes 10485760  //memcached服务缓存允许使用的最大字节数。这里为67108864字节，也就是是64M.与我们启动memcached服务设置的大小一致。
STAT accepting_conns 1  //服务器是否达到过最大连接（0/1）
STAT listen_disabled_num 0  //失效的监听数
STAT threads 4  //被请求的工作线程的总数量。
STAT conn_yields 0
STAT hash_power_level 16
STAT hash_bytes 524288
STAT hash_is_expanding 0
STAT malloc_fails 0
STAT bytes 73  //已用的缓存空间大小
STAT curr_items 1  //当前存储的数据总数
STAT total_items 1  //总共缓存的keyvalue数，包括过期删除的
STAT expired_unfetched 0  //连接操作主动放弃数目
STAT evicted_unfetched 0
STAT evictions 0  //为获取空闲内存而删除的items数（分配给memcache的空间用满后需要删除旧的items来得到空间分配给新的items)
STAT reclaimed 0  //已过期的数据条目来存储新数据的数目(回收再利用的条目)
STAT crawler_reclaimed 0
STAT lrutail_reflocked 0
END

stats命令有几个二级子项，说明如下表所示：




命令

含义说明



stats slabs

显示各个slab的信息，包括chunk的大小、数目、使用情况等



stats items

显示各个slab中item的数目和最老item的年龄（最后一次访问距离现在的秒数）



stats detail [on|off|dump]

设置或者显示详细操作记录；
参数为on，打开详细操作记录；
参数为off，关闭详细操作记录；
参数为dump，显示详细操作记录（每一个键值get、set、hit、del的次数）



stats malloc

打印内存分配信息



stats sizes

打印缓存使用信息



stats reset

重置统计信息



stats slabs
显示各个slab的信息，包括chunk的大小、数目、使用情况等

stats slabs
STAT 1:chunk_size 96              //当前slab每个chunk的大小
STAT 1:chunks_per_page 10922      //每个Page有多少个chunk
STAT 1:total_pages 1              //分配给当前slab的page总数
STAT 1:total_chunks 10922         //当前slab最多能够存放的chunk数，应该等于chunck_per_page * total_page
STAT 1:used_chunks 1              //使用了多少个chunk
STAT 1:free_chunks 10921          //过期数据空出的chunk里还没有被使用的chunk数
STAT 1:free_chunks_end 0          //新分配的但是还没有被使用的chunk数
STAT 1:mem_requested 74           //请求存储在该slab的字节数
STAT 1:get_hits 2
STAT 1:cmd_set 4
STAT 1:delete_hits 0
STAT 1:incr_hits 0
STAT 1:decr_hits 0
STAT 1:cas_hits 0
STAT 1:cas_badval 0
STAT 1:touch_hits 0
STAT active_slabs 1
STAT total_malloced 1048512
END

stats items
显示各个slab中item的数目和最老item的年龄(最后一次访问距离现在的秒数)

stats items
STAT items:2:number 1                //item的数量            
STAT items:2:age 1428                //年龄
STAT items:2:evicted 0               
STAT items:2:evicted_nonzero 0
STAT items:2:evicted_time 0
STAT items:2:outofmemory 0
STAT items:2:tailrepairs 0
STAT items:2:reclaimed 0
STAT items:2:expired_unfetched 0
STAT items:2:evicted_unfetched 0
STAT items:2:crawler_reclaimed 0
STAT items:2:lrutail_reflocked 0
STAT items:4:number 1
STAT items:4:age 1793
STAT items:4:evicted 0
STAT items:4:evicted_nonzero 0
STAT items:4:evicted_time 0
STAT items:4:outofmemory 0
STAT items:4:tailrepairs 0
STAT items:4:reclaimed 0
STAT items:4:expired_unfetched 0
STAT items:4:evicted_unfetched 0
STAT items:4:crawler_reclaimed 0
STAT items:4:lrutail_reflocked 0
END

stats sizes
返回存储在cache中的总体大小及item数目


stats sizes
STAT 128 1    //大小为128的chunk有1个item
STAT 192 1    //大小为192的chunk有1个item
END


版权声明：本文为博主原创文章，未经博主允许不得转载。

Memcached之你真正理解LRU吗(4)
众所周知，Memcached使用的是LRU（Least Recently Used最近最少使用）算法来回收缓存，将那些属于LRU的数据移出内存，从而腾出空间来加载另外的数据。那么Memcached的最近最少使用算法是怎么实现的呢？也许很多人都会回答：不就是在内存满了的情况下，把最近最少使用的Key替换掉，然后插入新的Key-Value键值对吗？其实不然，下面我们来深入的分析Memcached的LRU的内部实现，在分析LRU之前，让我们先了解一下Memcached的内部原理。
Memcached的内存分配
Memcached是采用Slab Allocator机制分配、管理内存，首先，我们必须理解三个概念：




Slab    


相同Chunk大小的集合，一个Slab包含多个Page，一个Page（默认是1M）包含多个Chunk，Chunk就是最终存放数据的地方。




Page  


Page默认是1M，一个Page包含多个Chunk。




Chunk    


默认情况下Chunk的大小是：96，随着指定的增长因子变化（参数 -f <factor>）




Slab Allocator机制是将分配给Memcached的内存，切分成若干个Slab，每个Slab下的Page的大小默认是1M，也就是说，如果一个Slab占用了50M的内存的话，在默认的情况下就有50个Page。在Memcached启动的时候是没有活动的Slab的，在插入数据的时候，如果Chunk不够用才会申请Slab，一旦分配了内存就不会释放，重复利用。
具体如图所示：





Memcached缓存原理
Memcached根据收到的数据的大小，选择最适合数据大小的Slab（如下图）。 Memcached中保存着slab内空闲chunk的列表，根据该列表选择chunk，然后将数据缓存于其中。



Memcached的内存浪费：
将100字节的数据缓存到128字节的chunk中，剩余的28字节就浪费了（如下图）：


了解了上面的一些Memcached基础概念之后，我们接下来说一下Memcached LRU的原理。

Memcache LRU：
首先我们要知道：
1，Memcached的LRU算法针对每个Slab执行，而不是针对整体。 

2，数据只会存在指定的Slab中，即使该Slab已经满了，而且更大的Slab有空间，这种情况会在指定的Slab执行LRU算法，因为数据不会被存放到更大的Slab中。

一个Slab会有多个Page，一个page默认是1M，启动Memcached会预分配1M，当1M的数据满之后，如果有新数据进来，那么会重新分配一个Page给这个slab，但是Memcached是有内存上限的，如果不能申请Page的话，这时候就要针对这个Slab再利用LRU算法剔除掉最近最少使用的数据了。


注：
所有的Slab都会分配一个Page，就算超出了-m参数指定的内存大小。
过期的数据如果没被显式调用get，也要占用空间。因为LRU是针对双向链表前面的数据，每个Slab由两个指针来维护该双向链表，即heads和tails指针，分别指向最老的数据和最新的数据。这就可能导致没有过期的数据被踢。



一种有效缓解使用LRU的方法是：
1，避免大对象

如果系统上只有及个别几个大对象的话，会浪费内存空间，因为Slab申请了Page是不能释放内存的，及个别大对象会导致Slab申请了内存资源而得不到充分的利用。

2，调整增长因子
根据项目的需求调整增长因子，使内存充分利用。


总而言之，言而总之，就是让内存充分利用。避免Slab中的Chunk虚位以待。



参考文档：（以下的资料可以认真看一下，虽然有点老，对了解Memcached还是很有帮助的）
http://blog.charlee.li/memcached-001/
http://blog.charlee.li/memcached-002/
http://blog.charlee.li/memcached-003/
http://blog.charlee.li/memcached-004/
http://blog.charlee.li/memcached-005/


版权声明：本文为博主原创文章，未经博主允许不得转载。

初识nginx之准备工作


版权声明：本文为博主原创文章，未经博主允许不得转载。

网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用
前言：
  最近被网络爬虫中的去重策略所困扰。使用一些其他的“理想”的去重策略，不过在运行过程中总是会不太听话。不过当我发现了BloomFilter这个东西的时候，的确，这里是我目前找到的最靠谱的一种方法。
  如果，你说URL去重嘛，有什么难的。那么你可以看完下面的一些问题再说这句话。



关于BloomFilter：
  Bloom filter 是由 Howard Bloom 在 1970 年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员。如果检测结果为是，该元素不一定在集合中；但如果检测结果为否，该元素一定不在集合中。因此Bloom filter具有100%的召回率。这样每个检测请求返回有“在集合内（可能错误）”和“不在集合内（绝对不在集合内）”两种情况，可见
 Bloom filter 是牺牲了正确率以节省空间。



以前的去重策略：
1.想到过的URL去重策略

在数据库中创建字段的UNIQUE属性在数据库中创建一个唯一的索引，在插入数据之前检查待插入的数据是否存在使用Set或HashSet保存数据，确保唯一使用Map或是一个定长数组记录某一个URL是否被访问过



2.以上去重策略存在的问题
  （1）对于在数据库中创建字段的UNIQUE属性， 的确是可以避免一些重复性操作。不过在多次MySQL报错之后，程序可能会直接崩溃，因此这种方式不可取
  （2）如果我们要在每一次插入数据之前都去检查待插入的数据是否存在，这样势必会影响程序的效率
  （3）这种方式是我在第一次尝试的时候使用的，放弃继续使用的原因是：OOM。当然，这里并不是程序的内存泄露，而程序中真的有这么多内存需要被占用（因为从待访问队列中解析出来的URL要远比它本身要多得多）
  （4）在前几篇博客中，我就有提到使用Map对象来保存URL的访问信息。不过，现在我要否定它。因为，在长时间运行之后，Map也是会占用大量的内存。只不过，会比第3种方式要小一些。下面是使用Map<Integer, Integer>去重，在长时间运行中内存的使用情况：
  



BloomFilter的使用：
1.一般情况下BloomFilter使用内存的情况：
  



2.爬虫程序中BloomFilter使用内存的情况（已运行4小时）：
  

3.程序结构图
  

 

4.BloomFilter的一般使用
  此处关于BloomFilter的Java代码部分，参考于：http://www.cnblogs.com/heaad/archive/2011/01/02/1924195.html
  如果你看了上面的文章，相信你已经了解到布隆过滤器的空间复杂度是S(n)=O(n)。关于这一点，相信你已经从上面的内存使用情况中了解到了这一点。那么以下会是一些相关的Java代码展示。而在查重过程也很有效率，时间复杂度是T(n)=O(1)。


BloomFilter.java


import java.util.BitSet;

public class BloomFilter {
    
    /* BitSet初始分配2^24个bit */
    private static final int DEFAULT_SIZE = 1 << 25;
    
    /* 不同哈希函数的种子，一般应取质数 */
    private static final int[] seeds = new int[] { 5, 7, 11, 13, 31, 37, 61 };
    
    private BitSet bits = new BitSet(DEFAULT_SIZE);
    
    /* 哈希函数对象 */
    private SimpleHash[] func = new SimpleHash[seeds.length];

    public BloomFilter() {
        for (int i = 0; i < seeds.length; i++) {
            func[i] = new SimpleHash(DEFAULT_SIZE, seeds[i]);
        }
    }

    // 将字符串标记到bits中
    public void add(String value) {
        for (SimpleHash f : func) {
            bits.set(f.hash(value), true);
        }
    }

    // 判断字符串是否已经被bits标记
    public boolean contains(String value) {
        if (value == null) {
            return false;
        }
        
        boolean ret = true;
        for (SimpleHash f : func) {
            ret = ret && bits.get(f.hash(value));
        }
        
        return ret;
    }

    /* 哈希函数类 */
    public static class SimpleHash {
        private int cap;
        private int seed;

        public SimpleHash(int cap, int seed) {
            this.cap = cap;
            this.seed = seed;
        }

        // hash函数，采用简单的加权和hash
        public int hash(String value) {
            int result = 0;
            int len = value.length();
            for (int i = 0; i < len; i++) {
                result = seed * result + value.charAt(i);
            }
            return (cap - 1) & result;
        }
    }
}     
Test.java



public class Test {

    private final String[] URLS = {
            "http://www.csdn.net/",
            "http://www.baidu.com/",
            "http://www.google.com.hk",
            "http://www.cnblogs.com/",
            "http://www.zhihu.com/",
            "https://www.shiyanlou.com/",
            "http://www.google.com.hk",
            "https://www.shiyanlou.com/",
            "http://www.csdn.net/"
    };
    
    private void testBloomFilter() {
        BloomFilter filter = new BloomFilter();
        for (int i = 0; i < URLS.length; i++) {
            if (filter.contains(URLS[i])) {
                System.out.println("contain: " + URLS[i]);
                continue;
            }
            
            filter.add(URLS[i]);
        }
    }

    public static void main(String[] args) {
        Test t = new Test();
        t.testBloomFilter();
    }
}

                    

5.BloomFilter在爬虫中过滤重复的URL

public class ParserRunner implements Runnable {

    private SpiderSet mResultSet = null;
    private WebInfoModel mInfoModel = null;
    private int mIndex;
    private final boolean DEBUG = false;
    
    private SpiderBloomFilter mFlagBloomFilter = null;
    
    public ParserRunner(SpiderSet set, WebInfoModel model, int index, SpiderBloomFilter filter) {
        mResultSet = set;
        mInfoModel = model;
        mIndex = index;
        mFlagBloomFilter = filter;
    }
    
    
    @Override
    public void run() {
        long t = System.currentTimeMillis();

        SpiderQueue tmpQueue = new SpiderQueue();
        PythonUtils.fillAddressQueueByPython(tmpQueue, mInfoModel.getAddress(), mInfoModel.getLevel());
        
        WebInfoModel model = null;
        while (!tmpQueue.isQueueEmpty()) {
            model = tmpQueue.poll();
            if (model == null || mFlagBloomFilter.contains(model.getAddress())) {
                continue;
            }
            
            mResultSet.add(model);
            mFlagBloomFilter.add(model.getAddress());
        }
        
        tmpQueue = null;
        model = null;
        
        System.err.println("Thread-" + mIndex + ", UsedTime-" + (System.currentTimeMillis() - t) + ", SetSize = " + mResultSet.size());
        t = 0;
    }

    @SuppressWarnings("unused")
    private void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}  如果你看过我之前的博客，那么上面的这一段代码相信你会比较熟悉。

  这段代码的功能是：生产者。从待访问队列中消费一个model，然后调用Python生产链接的列表Queue，并将生成的列表Queue offer到结果SpiderSet中。




版权声明：本文为博主原创文章，未经博主允许不得转载。http://blog.csdn.net/lemon_tree12138

