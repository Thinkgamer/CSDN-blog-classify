【SDOI2014】【BZOJ3534】重建
Description
T国有N个城市，用若干双向道路连接。一对城市之间至多存在一条道路。 
    在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。 
    辛运的是，此前T国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有N-1条，且能联通所有城市的概率。
Input
输入的第一行包含整数N。 
  接下来N行，每行N个实数，第i+l行，列的数G[i][j]表示城市i与j之 
间仍有道路联通的概率。 
    输入保证G[i][j]=G[j][i]，且G[i][j]=0；G[i][j]至多包含两位小数。
Output
输出一个任意位数的实数表示答案。
你的答案与标准答案相对误差不超过10^(-4)即视为正确。

Sample Input
3

0 0.5 0.5

0.5 0 0.5

0.5 0.5 0

Sample Output
0.375

HINT
1 < N < =50
数据保证答案非零时，答案不小于10^-4
Source
Round 1 Day 2
看起来好像直接对输入的矩阵计算一下行列式的值就可以了… 
可以个[哔——]! 
根本不对! 
做不出来题到处问: 
 
 
 
哔—— 
最后找到了gty大哥的blog… 
好详细真是感人至深QwQ 
让我们来看看正确的姿势… 
令矩阵里的元素P(i,j)=1−P(i,j)P(i,j)=1-P(i,j),记一个tmp=∏(1−P(i,j))tmp=\prod(1-P(i,j)) 
计算新的矩阵的行列式的值再乘上这个tmp得到答案… 
不明白为什么这样吧>_< 
其实我也不是很明白…

我们似乎可以通过令G(i,j)=P(i,j)来得到答案。且慢！要知道这道题目对于一棵生成树来说，它的期望应该为∏(i,j)∈EP(i,j)∏(i,j)∉E(1−P(i,j))。正确的方法应该为令G(i,j)=P(i,j)1−P(i,j)，最后求出|det(G)|后再乘以tmp=∏(1−P(i,j))\prod{(i,j)\in E}P(i,j)\prod{(i,j)\notin E}(1-P(i,j))。正确的方法应该为令G(i,j)=\frac{P(i,j)}{1-P(i,j)}，最后求出|det(G)|后再乘以tmp=\prod (1-P(i,j))，得到的即为正确答案。

所以就是这样(终于明白一些了) 
要注意1−P(i,j)1-P(i,j)有可能等于零,这时候要手动把它变成eps 
以及P(i,j)P(i,j)和P(j,i)P(j,i)乘一个就行了…别乘多了…
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 100
#define eps 1e-9
using namespace std;
int n;
double G[MAXN][MAXN];
double tmp=1;
double Gauss()
{
    double ret=1;
    for (int i=1;i<n;i++)
    {
        int now=i;
        for (int j=i+1;j<n;j++) now=fabs(G[now][i])<fabs(G[j][i])?j:now;
        if (now!=i)
            for (int j=1;j<n;j++)   swap(G[now][j],G[i][j]);
        for (int j=i+1;j<n;j++)     
        {
            double temp=G[j][i]/G[i][i];
            for (int k=i;k<n;k++)   G[j][k]-=G[i][k]*temp;
        }
        if (fabs(G[i][i])<eps)  return 0;
        ret*=G[i][i];
    }
    return fabs(ret)*tmp;
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
        {
            scanf("%lf",&G[i][j]);
            double t=fabs(1-G[i][j])<eps?eps:1-G[i][j];
            if (i<j)    tmp*=t;
            G[i][j]/=t;
        }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            if (i!=j)   G[i][i]-=G[i][j];
    printf("%.10f\n",Gauss());
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【NOI2015】【BZOJ4199】品酒大会
Description
Input
Output
Sample Input
Sample Output
HINT
Source 
BZOJ无题面233 
反正网上一堆自己下载叭>_< 
对反串建SAM然后DP 
第一问和AHOI2013差异完全一样 
具体解法: 
设Ans1[i]为lcp恰为i的后缀对数，Ans2[i]为lcp恰为i的后缀的价值乘积的最大值 
建出SAM后，记录子树中后缀个数、价值的最大值、价值的最小值，然后O(n)DP即可 
在SAM里DP完记得最后统计到Ans1和Ans2里去 
size会爆int…一开始开的int一直WAWAWAWA…
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 600100
#define LL long long
#define MAXINT 1ll<<60
using namespace std;
int n,top;
LL A[MAXN];
char ch[MAXN];
LL Ans1[MAXN],Ans2[MAXN];
struct edge
{
    int to;
    edge *next;
}e[MAXN<<1],*prev[MAXN];
void insert(int u,int v)
{
    e[++top].to=v;e[top].next=prev[u];prev[u]=&e[top];
}
void in(LL &x)
{
    char ch=getchar();x=0;int flag=1;
    while (!(ch>='0'&&ch<='9')) flag=ch=='-'?-1:1,ch=getchar();
    while (ch>='0'&&ch<='9')    x=x*10+ch-'0',ch=getchar();x*=flag;
}
struct sam
{
    int cnt,last,p,q,np,nq;
    int a[MAXN][26],len[MAXN],fa[MAXN];
    LL maxn[MAXN],minn[MAXN],ans1[MAXN],ans2[MAXN],size[MAXN];
    sam()
    {
        last=++cnt;
    }
    void insert(int c,int x)
    {
        p=last;last=np=++cnt;len[np]=len[p]+1;size[np]=1;maxn[np]=minn[np]=A[x];
        while (!a[p][c]&&p) a[p][c]=np,p=fa[p];
        if (!p) fa[np]=1;
        else
        {
            q=a[p][c];
            if (len[q]==len[p]+1)   fa[np]=q;
            else
            {
                nq=++cnt;len[nq]=len[p]+1;maxn[cnt]=-MAXINT;minn[cnt]=MAXINT;
                memcpy(a[nq],a[q],sizeof(a[q]));
                fa[nq]=fa[q];fa[q]=fa[np]=nq;
                while (a[p][c]==q)  a[p][c]=nq,p=fa[p];
            }
        }
    }
}sam;
void dfs(int x)
{
    for (edge *i=prev[x];i;i=i->next)
    {
        dfs(i->to);
        sam.ans1[x]+=sam.size[x]*sam.size[i->to];
        sam.size[x]+=sam.size[i->to];
        if (sam.maxn[x]!=-MAXINT)
            sam.ans2[x]=max(sam.ans2[x],sam.maxn[i->to]*sam.maxn[x]);
        if (sam.minn[x]!=MAXINT)
            sam.ans2[x]=max(sam.ans2[x],sam.minn[i->to]*sam.minn[x]);
        sam.maxn[x]=max(sam.maxn[x],sam.maxn[i->to]);
        sam.minn[x]=min(sam.minn[x],sam.minn[i->to]);
    }
}
int main()
{
    freopen("savour.in","r",stdin);
    freopen("savour.out","w",stdout);
    scanf("%d",&n);
    scanf("%s",ch);sam.maxn[1]=-MAXINT;sam.minn[1]=MAXINT;
    for (int i=1;i<=n;i++)  in(A[i]);
    for (int i=n;i;i--) sam.insert(ch[i-1]-'a',i);
    for (int i=0;i<=sam.cnt;i++)    sam.ans2[i]=-MAXINT;
    for (int i=1;i<=sam.cnt;i++)    insert(sam.fa[i],i);
    dfs(1);
    for (int i=0;i<n;i++)   Ans2[i]=-MAXINT;
    for (int i=1;i<=sam.cnt;i++)    Ans1[sam.len[i]]+=sam.ans1[i],Ans2[sam.len[i]]=max(Ans2[sam.len[i]],sam.ans2[i]);
    for (int i=n-2;i>=0;i--)
    {
        Ans1[i]+=Ans1[i+1];
        if (Ans1[i+1])  Ans2[i]=max(Ans2[i],Ans2[i+1]);
    }
    for (int i=0;i<n;i++)   printf("%lld %lld\n",Ans1[i],Ans1[i]?Ans2[i]:0);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【Ahoi2005】【BZOJ1968】COMMON 约数研究
Description
 
Input
只有一行一个整数 N（0 < N < 1000000）。 
Output
只有一行输出，为整数M，即f(1)到f(N)的累加和。 
Sample Input
3

Sample Output
5

HINT
Source
Day2 
傻逼题233 
求∑ni=1⌊ni⌋\sum_{i=1}^n \lfloor \frac n i\rfloor
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,sum;
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)  sum+=n/i;
    cout<<sum;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【模板整合】【及时更新】【天坑】计算几何模板
计算几何模板要写的内容真多… 
我写烦了…先写这些放上来吧…
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define MAXDBL 1e20
#define eps 1e-9
#define pi acos(-1)
using namespace std;
struct point
{
    double x,y;
    point(double _x=0,double _y=0):
        x(_x),y(_y){}
    bool operator <(const point& a)const
    {
        return x==a.x?y<a.y:x<a.x;
    }
};
typedef point Vector;
Vector operator +(Vector A,Vector B)//向量加减乘除  
{
    return Vector(A.x+B.x,A.y+B.y);
}
Vector operator -(Vector A,Vector B)
{
    return Vector(A.x-B.x,A.y-B.y);
}
Vector operator *(Vector A,double k)
{
    return Vector(A.x*k,A.y*k);
}
Vector operator /(Vector A,double k)
{
    return Vector(A.x/k,A.y/k);
}
bool operator ==(Vector A,Vector B)
{
    return fabs(A.x-B.x)<eps&&fabs(A.y-B.y)<eps;
}
double sqr(double x)
{
    return x*x;
}
double dis(point a,point b)//点距离 
{
    return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}
point point_sym(point A,point B)//A关于B的对称点 
{
    return point(2*B.x-A.x,2*B.y-A.y);
}
double dot(Vector a,Vector b)//向量点积 
{
    return a.x*b.x+a.y*b.y;
}
double cross(Vector a,Vector b)//叉积 
{
    return a.x*b.y-a.y*b.x;
}
double Area(point a,point b,point c)//面积 
{
    Vector A=b-a,B=b-c;
    return fabs(cross(A,B))/2;
}
double len(Vector A)//向量长度 
{
    return sqrt(sqr(A.x)+sqr(A.y));
}
double angle(Vector A,Vector B)//求夹角
{
    return acos(dot(A,B)/len(A)/len(B));
}
Vector rot(Vector A,double rad)//向量逆时针旋转rad弧度 
{
    return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));
}
Vector normal(Vector A)//逆时针旋转90度的单位向量 
{
    double l=len(A);
    return Vector(-A.y/l,A.x/l);
}
Vector unit(Vector A)//基于原向量的单位向量 
{
    double l=len(A);
    return A/l;
}
struct line
{
    point p;Vector v;//直线经过的点和直线的方向向量 
    line(point _p=point(0,0),Vector _v=Vector(0,0)):
        p(_p),v(_v){}
};
bool on_left(line l,point p)//点在直线左边/右边 
{
    return cross(l.v,p-l.p)>0;
}
point line_cross(line a,line b)//直线交点 
{
    Vector u=A.p-B.p;
    double t=Cross(B.v,u)/Cross(A.v,B.v);
    return A.p+A.v*t;
};
double dis_point_line(point A,line B)//点到直线距离 
{
    point a=B.p,b=B.p+B.v;
    Vector u=A-a,v=b-a;
    return fabs(cross(u,v))/len(v);
};
struct circle
{
    point p;double r;
    circle(point _p,double _r):
        p(_p),r(_r){}
    point Point(double rad)
    {
        return Point(p.x+r*cos(rad),p.y+r*sin(rad));
    }
};
vector<point> line_cross_circle(line l,circle c)//直线和圆的交点 
{
    line dia(C.p,normal(l.v));
    point inter=line_cross(dia,l);
    double d=dis_point_line(inter,dia);
    if (c.r-d<0)    return vector<point>();
    double  Len=sqrt(sqr(c.r)-sqr(d));
    vector<point> V;
    V.push_back(inter-unit(l.v)*Len);
    V.push_back(inter+unit(l.v)*len);
}
int convexhull(point *p,int n,point *ch)//求凸包 
{
    sort(p+1,p+n+1);
    int top=0,tmp;
    for (int i=1;i<=n;i++)
    {
        while (top>1&&cross(ch[top-1]-ch[top-2],p[i]-ch[top-2])<=0) top--;
        ch[++top]=p[i];
    }
    tmp=top;
    for (int i=n-1;i>=1;i--)
    {
        while (top>tmp&&cross(ch[top-1]-ch[top-2],p[i]-ch[top-2])<=0)   top--;
        ch[++top]=p[i];
    }
    return top;
}
double ch_area(point *ch,int n)//凸包面积 
{
    double ret=0;
    for (int i=1;i<n;i++)   ret+=Area(ch[1],ch[i],ch[i+1]);
    return ret;
}
double ch_cir(point *ch,int n)//凸包周长
{
    double ret=0;
    for (int i=1;i<n;i++)   ret+=dis(ch[i],ch[i+1]);
    ret+=dis(ch[n],ch[1]);
    return ret;
}

int main()
{

}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【BZOJ2555】SubString
Description
懒得写背景了，给你一个字符串init，要求你支持两个操作

(1):在当前字符串的后面插入一个字符串

(2):询问字符串s在当前字符串中出现了几次？(作为连续子串)

你必须在线支持这些操作。

Input
第一行一个数Q表示操作个数

第二行一个字符串表示初始字符串init

接下来Q行，每行2个字符串Type,Str 

Type是ADD的话表示在后面插入字符串。

Type是QUERY的话表示询问某字符串在当前字符串中出现了几次。

为了体现在线操作，你需要维护一个变量mask，初始值为0


读入串Str之后，使用这个过程将之解码成真正询问的串TrueStr。
询问的时候，对TrueStr询问后输出一行答案Result
然后mask = mask xor Result  
插入的时候，将TrueStr插到当前字符串后面即可。

HINT:ADD和QUERY操作的字符串都需要解压
Output
Sample Input
2



A



QUERY B



ADD BBABBBBAAB

Sample Output
0

HINT
40 % 的数据字符串最终长度 <= 20000，询问次数<= 1000，询问总长度<= 10000
100 % 的数据字符串最终长度 <= 600000，询问次数<= 10000,询问总长度<= 3000000
新加数据一组–2015.05.20
Source
Ctsc模拟赛By 洁妹
看题后想到 
SAM+LCT 
(其实完全是听学长讲课时候知道的)(划掉这句话) 
刚开始觉得可能会很长写了写发现不是很长也就不到150行 
对SAM的Parent树建LCT,给每个状态一个权值 
然后就可以通过统计LCT的权值来统计出现次数了. 
一开始习惯性的在makeroot时候写了打上rev标记但是WA了? 
不知道为什么 
删掉之后又做了做微调发现自己又是RE又是TLE 
最后开大了数据范围就A了. 
这个题上经历了WA,RE,TLE,MLE真是感人至深.人生百态 
 
 
WA多了怂了一波开小号A了… 
但是还是非常慢! 
但是还是非常慢! 
但是还是非常慢! 
很重要所以说三遍! 
竟然跑了14sQAQ
最后还是觉得真是蛮难调的…
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 3000010
using namespace std;
int Q;
char ch[MAXN],s[MAXN];
string chars;
int top,sta[MAXN];
int mask,ans;
void gets(int mask)
{
    scanf("%s",s);
    chars=s;
    int len=chars.length();
    for (int j=0;j<len;j++) 
    {
        mask=(mask*131+j)%len;
        char t=chars[j];
        chars[j]=chars[mask];
        chars[mask]=t;
    }
}
struct lct
{
    int ch[2],fa,flag,w;
    bool rev;
}tree[MAXN];
void modify(int x,int delta)
{
    if (x)  tree[x].w+=delta,tree[x].flag+=delta;
}
void push_down(int x)
{
    if (tree[x].flag)
    {
        modify(tree[x].ch[0],tree[x].flag);modify(tree[x].ch[1],tree[x].flag);
        tree[x].flag=0;
    }
}
bool is_root(int x)
{
    return tree[tree[x].fa].ch[0]!=x&&tree[tree[x].fa].ch[1]!=x;
}
void rot(int x)
{
    int y=tree[x].fa,z=tree[y].fa,l,r;
    l=(tree[y].ch[1]==x);r=l^1;
    if (!is_root(y))    tree[z].ch[tree[z].ch[1]==y]=x;
    tree[y].fa=x;tree[x].fa=z;tree[tree[x].ch[r]].fa=y;
    tree[y].ch[l]=tree[x].ch[r];tree[x].ch[r]=y;
}
void Splay(int x)
{
    sta[++top]=x;
    for (int i=x;!is_root(i);i=tree[i].fa)  sta[++top]=tree[i].fa;
    while (top) push_down(sta[top--]);
    while (!is_root(x))
    {
        int y=tree[x].fa,z=tree[y].fa;
        if (!is_root(y))
        {
            if ((tree[y].ch[0]==x)^(tree[z].ch[0]==y))  rot(x);
            else    rot(y);
        }
        rot(x);
    }
}
void access(int x)
{
    for (int i=0;x;i=x,x=tree[x].fa)    Splay(x),tree[x].ch[1]=i;
}
void make_root(int x)
{
    access(x);Splay(x);//tree[x].rev^=1;
}
void link(int x,int y)
{
    tree[x].fa=y;make_root(y);modify(y,tree[x].w);
}
void cut(int x)
{
    make_root(x);modify(tree[x].ch[0],-tree[x].w);tree[tree[x].ch[0]].fa=0;tree[x].ch[0]=0;
}
struct sam
{
    int cnt,last,p,q,np,nq;
    int a[MAXN][26],len[MAXN],fa[MAXN];
    sam()
    {
        last=++cnt;
    }
    void insert(int c)
    {
        p=last;last=np=++cnt;len[np]=len[p]+1;tree[np].w=1;
        while (!a[p][c]&&p) a[p][c]=np,p=fa[p];
        if (!p) fa[np]=1,link(np,1);
        else
        {
            q=a[p][c];
            if (len[q]==len[p]+1)   fa[np]=q,link(np,q);
            else
            {
                nq=++cnt;len[nq]=len[p]+1;
                memcpy(a[nq],a[q],sizeof(a[q]));
                fa[nq]=fa[q];link(nq,fa[q]);
                fa[q]=fa[np]=nq;cut(q);link(q,nq);link(np,nq);
                while (a[p][c]==q)  a[p][c]=nq,p=fa[p];
            }
        }
    }
    int getans()
    {
        gets(mask);
        int st=1,Len=chars.length();
        for (int i=0;i<Len;i++)
            if (!(st=a[st][chars[i]-'A']))  return 0;
        Splay(st);
        return tree[st].w;
    }
}sam;
int main()
{
    scanf("%d",&Q);scanf("%s",ch);
    int len=strlen(ch);
    for (int i=0;i<len;i++) sam.insert(ch[i]-'A');
    while (Q--)
    {
        scanf("%s",ch);
        if (ch[0]=='A')
        {
            gets(mask);
            len=chars.length();
            for (int i=0;i<len;i++) sam.insert(chars[i]-'A');
        }
        else
        {
            ans=sam.getans();mask^=ans;
            printf("%d\n",ans);
        }
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【Cactus仙人掌图】仙人掌基础知识学习笔记
首先膜一下vfk领先全球的动态仙人掌栽培技术… 
然后谢谢Time-Machine学长在暑假集训时候讲了仙人掌DP. 
然后感觉听得并不是很懂…所以再来对着论文学一遍顺便写一写例题代码 
这一篇主要先学仙人掌的基础(定义和性质什么的)
————————————线 割 分 是 我 >w<———————————————– 
什么是仙人掌? 
仙人掌是不含自环的,一条边最多属于一个简单环的无向连通图. 
从定义不难看出树其实也是仙人掌的一种,也就是说这几个概念的关系大概是: 
树是一种特殊的仙人掌,仙人掌是一类特殊的无向连通图. 
从图片来观察一下. 
 
这也是个仙人掌↓ 
 
那么我们现在就知道怎样来区分仙人掌和非仙人掌了
对于树我们都很熟悉,那么能不能想办法把仙人掌看成一棵树呢? 
办法是有的.仙人掌上最讨厌的就是环.但是我们注意到仙人掌上不可能存在环与其他环有重边,这就好办了,我们可以把环看成类似树上的节点的东西,只是这个节点包含了更大的信息量.(注意只是类似,和真正树上的节点是不一样的!)
仿照树相关的定义,我们可以对仙人掌定义仙人掌上的节点的父亲和环的父亲. 
对于仙人掌上的节点,它的父亲是可能存在多种可能的.如果它到根的路径上与它相邻的是一条简单路径而不是环,那么这个节点的父亲和平常树上节点的父亲是没什么区别的, 它的父亲是它到根的简单路径上经历的第二个点.那么如果它到根节点路径上与它相邻的是个环,则将其到根的路径上经历的第一条边所在的环当做其父亲. 
对于环,我们将它的父亲定义为一个环上离根最近的点. 
相对的那么就出现了儿子关系了. 
对于仙人掌上的节点,它的儿子显然可以是环可以是普通节点. 
但是对于环的儿子,则是环上除掉这个环的父亲以外的其他所有节点.
区别于普通树,对仙人掌而言环上的节点除了父亲之外还存在父亲节点和母亲节点(为什么要起这种名字好容易搞混啊…) 
环上节点的父亲节点和母亲节点指这个点在环上相邻的那两个点. 
(一定不要搞混啦>_<)
怎样进行仙人掌的遍历和节点信息的确定呢? 
依然是从根节点开始DFS. 
如果我们将要访问一个节点,而这个节点之前还没有被访问过,那么我们直接把这个节点的父亲设为当前节点就行了.(从环和节点的父亲的定义上看这样显然没问题) 
那么如果我们将要访问的那个节点已经被访问过了呢?显然这时候出现了环. 
那么就有两种情况: 
现在我们假设我们正在访问的节点为x,将要访问的那个节点为y 
那么如果x的第一次被访问时间比y早,那么这证明y所在的环已经被我们访问过了,就不需要再单独对y处理什么. 
如果x的第一次被访问时间比y晚,则说明x在一个以y为父亲的环上,此时再遍历整个环标记一下父亲节点母亲节点. 
至此,整个仙人掌遍历完成,同时仙人掌上所有节点的父子父母信息都已经处理了出来.

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5400(Arithmetic Sequence-暴力找区间)

Arithmetic Sequence
Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 937    Accepted Submission(s): 411


Problem Description
A sequence b1,b2,⋯,bn
 are called (d1,d2)-arithmetic
 sequence if and only if there exist i(1≤i≤n)
 such that for every j(1≤j<i),bj+1=bj+d1
 and for every j(i≤j<n),bj+1=bj+d2.

Teacher Mai has a sequence a1,a2,⋯,an.
 He wants to know how many intervals [l,r](1≤l≤r≤n)
 there are that al,al+1,⋯,ar
 are (d1,d2)-arithmetic
 sequence.

 

Input
There are multiple test cases.

For each test case, the first line contains three numbers 
n,d1,d2(1≤n≤105,|d1|,|d2|≤1000),
 the next line contains n
 integers a1,a2,⋯,an(|ai|≤109).

 

Output
For each test case, print the answer.

 

Sample Input

5 2 -2
0 2 0 -2 0
5 2 3
2 3 3 3 3

 

Sample Output

12
5

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9

 

Recommend
wange2014   |   We have carefully selected several similar problems for you:  5421 5420 5419 5418 5417 
 


暴力找区间








#include<bits/stdc++.h> 
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i>=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define Forpiter(x) for(int &p=iter[x];p;p=next[p])  
#define Lson (x<<1)
#define Rson ((x<<1)+1)
#define MEM(a) memset(a,0,sizeof(a));
#define MEMI(a) memset(a,127,sizeof(a));
#define MEMi(a) memset(a,128,sizeof(a));
#define INF (2139062143)
#define F (100000007)
#define MAXN (1000000+10)
typedef long long ll;
ll mul(ll a,ll b){return (a*b)%F;}
ll add(ll a,ll b){return (a+b)%F;}
ll sub(ll a,ll b){return (a-b+llabs(a-b)/F*F+F)%F;}
void upd(ll &a,ll b){a=(a%F+b%F)%F;}
int n;
ll d1,d2,a[MAXN],b[MAXN];
 
int main()
{
//	freopen("E.in","r",stdin);
	
	while(cin>>n>>d1>>d2)
	{
		For(i,n) scanf("%lld",&a[i]);
		
		For(i,n-1) b[i]=a[i+1]-a[i];
	//	For(i,n-1) cout<<b[i]<<' ';cout<<endl;
	
		if (d1==d2)
		{
			ll sz=1,ans=0;
			Fork(i,2,n) if (a[i]-a[i-1]==d1) sz++; else ans+=sz*(sz+1)/2,sz=1;
			if (sz) ans+=sz*(sz+1)/2;
			cout<<ans<<endl; 
		} else {
			ll sz=1,ans=0; bool flag=0;
			Fork(i,2,n)
			{
				if (!flag)
				{
					if (a[i]-a[i-1]==d1) sz++;
					else if (a[i]-a[i-1]==d2) sz++,flag=1;
					else ans+=sz*(sz+1)/2,sz=1,flag=0;
				}
				else
				{
					if (a[i]-a[i-1]==d2) sz++;
					else if (a[i]-a[i-1]==d1) ans+=sz*(sz+1)/2-1,sz=2,flag=0;
					else ans+=sz*(sz+1)/2,sz=1,flag=0;
				}
			}if (sz) ans+=sz*(sz+1)/2;
			cout<<ans<<endl; 
			
		} 
		
	
	}
	
		
	return 0;
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

最小树形图 之 朱刘算法【模板】
定义：一个有向图，存在从某个点为根的，可以到达所有点的一个最小生成树，则它就是最小树形图。




朱刘算法实现过程： 【在选出入边集后（看步骤1），若有向图中不存在有向环，说明该图就是最小树形图】


1，选入边集——找到除root点之外，每一个点的所有入边中权值最小的，用数组in[]记录下这个最小权值，用pre[]记录到达该点的前驱；（若图中存在独立点，最小树形图是不存在的，所以在该步骤结束后，要判断一下）
2，找有向环，并用数组id[]记录节点所属环的编号。
3，找到环后，缩点，并更新权值。（感觉和SCC缩点差不多吧）
4，以环数为下一次查找的点数，继续执行上述操作，直到没有环 或者 判定出不存在最小树形图为止。




给个图：








详看代码，有详细注释：点的编号是从0开始的



/*
最小树形图
朱刘算法模板
时间复杂度O(nm)
数据为int型
*/
#include <cstdio>
#include <cstring>
#include <algorithm>
#define MAXN 1010
#define MAXM 1000000+10
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cost;
};
Edge edge[MAXM];
int pre[MAXN];//存储父节点
int vis[MAXN];//标记作用
int id[MAXN];//id[i]记录节点i所在环的编号
int in[MAXN];//in[i]记录i入边中最小的权值
int zhuliu(int root, int n, int m, Edge *edge)//root根 n点数 m边数
{
    int res = 0, u, v;
    while(1)
    {
        for(int i = 0; i < n; i++)
            in[i] = INF;//初始化
        for(int i = 0; i < m; i++)
        {
            Edge E = edge[i];
            if(E.from != E.to && E.cost < in[E.to])
            {
                pre[E.to] = E.from;//记录前驱
                in[E.to] = E.cost;//更新
            }
        }
        for(int i = 0; i < n; i++)
            if(i != root && in[i] == INF)
                return -1;//有其他孤立点 则不存在最小树形图
        //找有向环
        int tn = 0;//记录当前查找中 环的总数
        memset(id, -1, sizeof(id));
        memset(vis, -1, sizeof(vis));
        in[root] = 0;//根
        for(int i = 0; i < n; i++)
        {
            res += in[i];//累加
            v = i;
            //找图中的有向环 三种情况会终止while循环
            //1,直到出现带有同样标记的点说明成环
            //2,节点已经属于其他环
            //3,遍历到根
            while(vis[v] != i && id[v] == -1 && v != root)
            {
                vis[v] = i;//标记
                v = pre[v];//一直向上找
            }
            //因为找到某节点属于其他环  或者 遍历到根  说明当前没有找到有向环
            if(v != root && id[v] == -1)//必须上述查找已经找到有向环
            {
                for(int u = pre[v]; u != v; u = pre[u])
                    id[u] = tn;//记录节点所属的 环编号
                id[v] = tn++;//记录节点所属的 环编号  环编号累加
            }
        }
        if(tn == 0) break;//不存在有向环
        //可能存在独立点
        for(int i = 0; i < n; i++)
            if(id[i] == -1)
                id[i] = tn++;//环数累加
        //对有向环缩点  和SCC缩点很像吧
        for(int i = 0; i < m; i++)
        {
            v = edge[i].to;
            edge[i].from = id[edge[i].from];
            edge[i].to = id[edge[i].to];
            //<u, v>有向边 
            //两点不在同一个环 u到v的距离为 边权cost - in[v]
            if(edge[i].from != edge[i].to)
                edge[i].cost -= in[v];//更新边权值 继续下一条边的判定
        }
        n = tn;//以环总数为下次操作的点数 继续执行上述操作 直到没有环
        root = id[root];
    }
    return res;
}
int main()
{
    int N, M;//N个点 M条有向边
    while(scanf("%d%d", &N, &M) != EOF)
    {
        getMap();//建图  注意去除自环  自己到自己的权值为无穷大
        int ans = zhuliu(0, N, M, edge);
        if(ans == -1)
            printf("-1\n");//不存在
        else
            printf("%d\n", ans);
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

java多线程（一）Race Condition现象及产生的原因
转载请注明出处http://blog.csdn.net/xingjiarong/article/details/47603813 
什么是Race Condition
首先，什么是Race Condition呢，Race Condition中文翻译是竞争条件，是指多个进程或者线程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关的现象。换句话说，就是线程或进程之间访问数据的先后顺序决定了数据修改的结果，这种现象在多线程编程中是经常见到的。
Race Condition 实例
class MyThread implements Runnable {
    /**
     * 计算类型，1表示减法，其他的表示加法
     */
    private int type;

    public MyThread(int type) {
        this.type = type;
    }

    public void run() {
        if (type == 1)
            for (int i = 0; i < 10000; i++)
                Test.num--;
        else
            for (int i = 0; i < 10000; i++)
                Test.num++;
    }
}

public class Test {

    public static int num = 1000000;

    public static void main(String[] args) {

        Thread a = new Thread(new MyThread(1));
        Thread b = new Thread(new MyThread(2));

        a.start();
        b.start();

        /*
         * 主线程等待子线程完成，然后再打印数值
         */
        try {
            a.join();
            b.join();
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(num);
    }

}

上边的程序非常简单。就是用两个线程同时操作和修改同一个数据，一个线程希望把num加10000，另一个线程希望把num减小10000，根据我们的计算，一个数加上10000，再减去10000，相当于没有变化，所以结果应该等于他自身。但是这只是我们的想象，事实真的是这样吗？大家可以运行一下上边的程序，你会吃惊的发现，结果并不是1000000，再多运行几次，是不是每次的结果都不一样。 
没错，这就是产生了Race Condition，有两个线程，同时操作num这个变量，并且操作的结果与访问的顺序有关（这个不是我们控制的，而是由操作系统控制的,我们只能看到每次的结果都不一样）。
Race Condition 产生的原因
现在我们已经看到了Race Condition现象了，那么它是怎么产生的呢？先不要急切的说，你不是说了吗，是由于访问顺序不同造成的。我想说，学习新知识一定要追根溯源，要真正的弄明白，那么在硬件或者操作系统层面上，这一现象发生的原因是什么呢？
首先，我们来看一张图。

我们知道，在操作系统中，操作系统程序为每个线程分配了单独的寄存器和程序计数器。在上边的图中，我一共分成了三列，其中第一列表示线程一的操作过程，第二列表示线程二的操作过程，第三列表示内存中的结果。图中前两列的写着数字的小方框表示该线程所使用的寄存器，数字表示该寄存器中的值。第三列的小方框表示内存中的 一个存储单元，数值表示内存中存储的数值。
现在，我们来看一下操作的过程。(这里是简化了的示意过程，真正的过程要复杂的多)开始时，数据都是放在内存中的，所以通过LOAD指令，将num加载到寄存器中，接着执行相应的操作指令，这里分别为ADD（加1） SUB（减1）指令，指令执行结束后，结果是存储在相应的寄存器中的，这时内存中的数值还没有发生变化。最后执行STORE指令之后，寄存器中的数值被存储到内存中。
小方框从上到下的顺序表示线程1和线程2交替执行的过程。首先，线程1读取了内存中num的值，然后换到线程2执行，先读取了内存中num的数值，然后执行减1操作，最后将结果写回内存中，这时内存中的数据变成了999999，但是这一个变化线程1是看不到的，因为这一变化发生在线程1读取num的值之后。其实这时线程1读取到的数据已经是不正确的数据了，这是产生Race Condition的根本原因。然后线程1接着执行未执行完的指令，加1操作，最后将1000001写会内存，这是产生Race Condition的直接原因，它将线程2的结果给覆盖掉了。
这就是Race Condition产生的原因，大家是不是真正的明白了呢？。
当然Race Condition这种现象是不好的，所以我们会通过各种途径来避免产生Race Condition。在接下来的博客里，我会为大家介绍如果在java的多线程编程中避免出现Race Condition 以及多线程的同步和互斥的内容，希望与大家一起学习一起进步，请大家继续关注我的博客，如果大家支持我的话，就顶我一下吧。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处，查看原文章，请访问：http://blog.csdn.net/xingjiarong

【SHOI2008】【BZOJ1023】cactus仙人掌图
Description
如果某个无向连通图的任意一条边至多只出现在一条简单回路（simple cycle）里，我们就称这张图为仙人图（cactus）。所谓简单回路就是指在图上不重复经过任何一个顶点的回路。 

举例来说，上面的第一个例子是一张仙人图，而第二个不是——注意到它有三条简单回路：（4，3，2，1，6，5，4）、（7，8，9，10，2，3，7）以及（4，3，7，8，9，10，2，1，6，5，4），而（2，3）同时出现在前两个的简单回路里。另外，第三张图也不是仙人图，因为它并不是连通图。显然，仙人图上的每条边，或者是这张仙人图的桥（bridge），或者在且仅在一个简单回路里，两者必居其一。定义在图上两点之间的距离为这两点之间最短路径的距离。定义一个图的直径为这张图相距最远的两个点的距离。现在我们假定仙人图的每条边的权值都是1，你的任务是求出给定的仙人图的直径。
Input
输入的第一行包括两个整数n和m（1≤n≤50000以及0≤m≤10000）。其中n代表顶点个数，我们约定图中的顶点将从1到n编号。接下来一共有m行。代表m条路径。每行的开始有一个整数k（2≤k≤1000），代表在这条路径上的顶点个数。接下来是k个1到n之间的整数，分别对应了一个顶点，相邻的顶点表示存在一条连接这两个顶点的边。一条路径上可能通过一个顶点好几次，比如对于第一个样例，第一条路径从3经过8，又从8返回到了3，但是我们保证所有的边都会出现在某条路径上，而且不会重复出现在两条路径上，或者在一条路径上出现两次。
Output
只需输出一个数，这个数表示仙人图的直径长度。
Sample Input
15 3
9 1 2 3 4 5 6 7 8 3
7 2 9 10 11 12 13 10
5 2 14 9 15 10  8
10 1
10 1 2 3 4 5 6 7 8 9 10 
Sample Output
9 
HINT
对第一个样例的说明：如图，6号点和12号点的最短路径长度为8，所以这张图的直径为8。

【注意】使用Pascal语言的选手请注意：你的程序在处理大数据的时候可能会出现栈溢出。如果需要调整栈空间的大小，可以在程序的开头填加一句：{$M 5000000}，其中5000000即指代栈空间的大小，请根据自己的程序选择适当的数值。
做法我在那个仙人掌DP的学习笔记里写了 
记得要拆环成两倍长度序列所以数组要开大一倍
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 50010
using namespace std;
int n,m,top;
int ans;
int k,u,v;
int Top;
int deep[MAXN<<1],dfn[MAXN<<1],fa[MAXN<<1],minn[MAXN<<1];
int f[MAXN<<1],a[MAXN<<1];
int que[MAXN<<1],head,tail;//维护一个单调队列 
struct edge
{
    int to;
    edge *next;
}e[MAXN<<2],*prev[MAXN];
inline void insert(int u,int v)
{
    e[++top].to=v;e[top].next=prev[u];prev[u]=&e[top];
}
inline void in(int &x)
{
    char ch=getchar();x=0;int flag=1;
    while (!(ch>='0'&&ch<='9')) flag=ch=='-'?-1:1,ch=getchar();
    while (ch>='0'&&ch<='9')    x=x*10+ch-'0',ch=getchar();x*=flag;
}
inline void dp(int root,int x)
{
    int tot=deep[x]-deep[root]+1,temp=tot;
    for (int i=x;i!=root;i=fa[i])   a[temp--]=f[i];
    a[temp]=f[root];
    for (int i=1;i<=tot;i++)    a[i+tot]=a[i];//把环拆开 
    que[1]=1;head=tail=1;//head,tail分别对应区间端点 
    for (int i=2;i<=2*tot;i++)
    {
        while (head<=tail&&i-que[head]>tot/2)   head++;
        ans=max(ans,a[i]+i+a[que[head]]-que[head]);
        while (head<=tail&&a[que[tail]]-que[tail]<=a[i]-i)  tail--;
        que[++tail]=i;
    }
    for (int i=2;i<=tot;i++)
        f[root]=max(f[root],a[i]+min(i-1,tot-i+1));
}
inline void dfs(int x)
{
    dfn[x]=minn[x]=++Top;
    for (edge *i=prev[x];i;i=i->next)
    {
        if (i->to==fa[x])   continue;
        if (!dfn[i->to])//没有访问过 
        {
            fa[i->to]=x;deep[i->to]=deep[x]+1;
            dfs(i->to);
            minn[x]=min(minn[x],minn[i->to]);
        }   
        else    minn[x]=min(minn[x],dfn[i->to]);
        if (dfn[x]<minn[i->to])
        {
            ans=max(ans,f[x]+f[i->to]+1);
            f[x]=max(f[x],f[i->to]+1);
        }
    }
    for (edge *i=prev[x];i;i=i->next)
        if (fa[i->to]!=x&&dfn[x]<dfn[i->to])    dp(x,i->to);
}
int main()
{
    in(n);in(m);
    for (int i=1;i<=m;i++)
    {
        in(k);in(u);
        for (int j=2;j<=k;j++)  in(v),insert(u,v),insert(v,u),u=v;
    }
    dfs(1);
    printf("%d\n",ans);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【HAOI2011】【BZOJ2299】向量
Description
给你一对数a,b，你可以任意使用(a,b), (a,-b), (-a,b), (-a,-b), (b,a), (b,-a), (-b,a), (-b,-a)这些向量，问你能不能拼出另一个向量(x,y)。
说明：这里的拼就是使得你选出的向量之和为(x,y)
Input
第一行数组组数t，(t<=50000)
接下来t行每行四个整数a,b,x,y  (-2*109<=a,b,x,y<=2*109)
Output
t行每行为Y或者为N，分别表示可以拼出来，不能拼出来
Sample Input
3
2 1 3 3
1 1 0 1
1 0 -2 3
Sample Output
Y
N
Y
HINT
样例解释：
第一组：(2,1)+(1,2)=(3,3)
第三组：(-1,0)+(-1,0)+(0,1)+(0,1)+(0,1)=(-2,3)
一眼题. 
一开始会想到和同余有关或者是高斯消元 
后来发现高斯消元不靠谱果然同余是对的. 
可以发现能做的选择可以拼凑出的向量只有那么有限的几种. 
有可能一个不用,有可能用几种拼凑一下. 
但是发现 
(x+a,y+b),(x+b,y+a)这样的似乎只会用一次?(不会证明但是好像挺对的) 
使用贝祖定理进行验证用或者不用.
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define LL long long
using namespace std;
int T;
LL a,b,x,y;
LL d;
void in(LL &x)
{
    char ch=getchar();x=0;int flag=1;
    while (!(ch>='0'&&ch<='9')) flag=ch=='-'?-1:1,ch=getchar();
    while (ch>='0'&&ch<='9')    x=x*10+ch-'0',ch=getchar();x*=flag;
}
LL gcd(LL a,LL b)
{
    return !b?a:gcd(b,a%b);
}
bool check(LL x,LL y)
{
    return x%d==0&&y%d==0;
}
int main()
{
    scanf("%d",&T);
    while (T--)
    {
        in(a);in(b);in(x);in(y);
        d=gcd(2*a,2*b);
        if (check(x,y)||check(x+a,y+b)||check(x+b,y+a)||check(x+a+b,y+a+b)) puts("Y");
        else    puts("N");
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

struts2学习笔记——03
使用paramsPrepareParamsStack拦截器站后的运行流程
  1)paramsPrepareParamsStack和defaultStack一样都是拦截器栈，而struts-default包默认使用的是defaultStack
  2)可以在struts配置文件中通过以下方式修改使用的默认拦截器栈
  <default-interceptor-ref name="paramsPrepaareParamsStack"></default-interceptor-ref>
  3）paramsPrepareParamsStack拦截器在于 ： params--》modelDriven-》params
 所以先把请求的参数赋值给action对应的属性，在根据赋给action的那个属性值决定压倒之战栈顶的对象，之后再为栈顶对象的属性赋值。

对于edit操作而言：
1：先为employeeAction的employeeID赋值
2：根据employee从数据库中加载对应的对象，并放入到值站的栈顶
3：在为栈顶对象的employee赋值
4：吧栈顶对象的属性回显在表单中


关于回显：struts表单标签会从值站中获取对象的属性值进行回显。
Struts2类型转换：
http没有类型的概念，每一项表单输入只可能是字符串或字符串数组


ActionContext.getContext().getValueStack.push(object)把当前对象放入栈顶
struts2表单标签的name值可以被复位属性的属性：name=mgr.name ,name=mgr.age;
全局的类型转换器可以正常工作！
国际化的目标
1）如何配置国际化资源文件

资源文件加载的顺序如何那？离当前action较近的将被优先加载


2）如何在页面上和action中访问国际化资源文件的value值
 1.在action类中，若action实现了textProvider接口，则可以调用getText()方法获取value值
    通过继承actionSupport的方式
2.页面上可以使用s:text标签，对应表单标签可以使用表单标签的key属性值
  若有占位符，则可以使用s:text标签的s:param标签来填充占位符
 若当前页面来自于action则可以直接访问action中的属性值
可以利用标签和ognl表达式直接访问值站中的属性值对象站和map站








3）实现通过超链接切换语言。



关键在于知道struts框架是如何确定local对象




通过阅读I18N拦截器











声明时验证：
































版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5399(Too Simple-判定映射)

Too Simple
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 1035    Accepted Submission(s): 353


Problem Description
Rhason Cheung had a simple problem, and asked Teacher Mai for help. But Teacher Mai thought this problem was too simple, sometimes naive. So she ask you for help.

Teacher Mai has m
 functions f1,f2,⋯,fm:{1,2,⋯,n}→{1,2,⋯,n}(that
 means for all x∈{1,2,⋯,n},f(x)∈{1,2,⋯,n}).
 But Rhason only knows some of these functions, and others are unknown.

She wants to know how many different function series 
f1,f2,⋯,fm
 there are that for every i(1≤i≤n),f1(f2(⋯fm(i)))=i.
 Two function series f1,f2,⋯,fm
 and g1,g2,⋯,gm
 are considered different if and only if there exist 
i(1≤i≤m),j(1≤j≤n),fi(j)≠gi(j).

 

Input
For each test case, the first lines contains two numbers
n,m(1≤n,m≤100).

The following are m
 lines. In i-th
 line, there is one number −1
 or n
 space-separated numbers.

If there is only one number −1,
 the function fi
 is unknown. Otherwise the j-th
 number in the i-th
 line means fi(j).

 

Output
For each test case print the answer modulo 
109+7.

 

Sample Input

3 3
1 2 3
-1
3 2 1

 

Sample Output

1
HintThe order in the function series is determined. What she can do is to assign the values to the unknown functions. 

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9

 

Recommend
wange2014   |   We have carefully selected several similar problems for you:  5421 5420 5419 5418 5417 
 


已知函数有一个不是双射，必定无解
若所有函数均已知，直接判断
否则，只要有一个 -1, 那么必能构造出解
有k个-1，前k-1个随便排 ，最后那个就能推出 ans=(n!)^(k-1)






#include<bits/stdc++.h> 
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i>=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define Forpiter(x) for(int &p=iter[x];p;p=next[p])  
#define Lson (x<<1)
#define Rson ((x<<1)+1)
#define MEM(a) memset(a,0,sizeof(a));
#define MEMI(a) memset(a,127,sizeof(a));
#define MEMi(a) memset(a,128,sizeof(a));
#define INF (2139062143)
#define F (1000000007)
#define MAXN (100+10)

typedef long long ll;
ll mul(ll a,ll b){return (a*b)%F;}
ll add(ll a,ll b){return (a+b)%F;}
ll sub(ll a,ll b){return (a-b+llabs(a-b)/F*F+F)%F;}
void upd(ll &a,ll b){a=(a%F+b%F)%F;}
int n,m;
bool b[MAXN];
int f[MAXN][MAXN];
int g[MAXN];
int main()
{
//	freopen("D.in","r",stdin);
	
	while(cin>>n>>m) {
		int cnt=0; bool flag=0;
		For(i,m)
		{
			MEM(b)
			int p;
			scanf("%d",&p);
			if (p==-1) { ++cnt;continue;}
			else f[i][1]=p;
			b[p]=1;
			Fork(j,2,n) {
				scanf("%d",&p);f[i][j]=p;
				if (!b[p]) b[p]=1; else flag=1;
			}
		}
		
		if (flag) {
			puts("0");continue;
		}	
		
		if (!cnt) {
			For(i,n) g[i]=i;
			ForD(i,m) 
				For(j,n) g[j]=f[i][g[j]];
			bool flag=0;
			For(i,n) if (g[i]^i) flag=1;
			if (flag) puts("0");else puts("1");
			continue;
		}
		
		if (cnt==1)
		{
			puts("1");
			continue;
		}
		
		ll ans=1,p2=1;
		For(i,n) p2=mul(p2,i);
		For(i,cnt-1) ans=mul(p2,ans);
		cout<<ans<<endl;
		
		
	}	
	
	return 0;
}











版权声明：本文为博主原创文章，未经博主允许不得转载。

java多线程（六）深入理解volitale关键字
转载请注明出处：http://blog.csdn.net/xingjiarong/article/details/47945849 
我们继续来讨论java的多线程编程，今天我们一起来学习一下java多线程中的另一个关键字——volitale。
一、java内存模型与多线程编程中的三个感念
1、原子性
原子性是指一些操作或者全都执行，要么或者全都不执行，整个操作作为一个整体是不可分割的，例如，一个银行中有两个账户A，B，现在要从A账户中转账500元到B账户，那么一共可以分为两个步骤： 
1、从A账户取出500元：A = A - 500； 
2、向B账户存入500元：B = B + 500； 
这两个步骤作为一个整体，要么全部执行要么全部都不执行，如果只执行步骤一，那么A账户就会莫名其妙的丢失500元，B账户却什么都没有收到。
在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
例如：
i = 3;
i = i+3;
i++;
i = j;
这四条语句只有第一条语句是原子的，是基本的赋值操作。其他的三条语句，看似是赋值的原子操作，实际上却是由多个步骤构成的。比如i++这条语句是由i，i+1,i=i+1这三条语句构成的，每一个语句都是原子的，但是合起来就不是原子的了。
2、可见性
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。例如：
//线程1
i = 10;
i = i+3;


//线程2
j=i;
在java中每个线程都有自己的线程栈，当一个线程执行需要数据时，会到内存中将需要的数据复制到自己的线程栈中，然后对线程栈中的副本进行操作，再操作完成后再将数据写回到内存中。
例如：线程1将i的值读到自己的线程栈中，然后对i进行了加3操作，但是这一操作并没有被及时的写回到内存中，所以线程2在执行时看到的i的值仍然是3，这就是可见性的问题。
java提供的volitale关键字可以保证数据的可见性。
3、有序性
有序性：即程序执行的顺序按照代码的先后顺序执行。我们写代码会有一个先后的顺序，但是那仅仅是我们看到的顺序，但是当编译器编译时会进行指令重排，于是代码的执行顺序有可能和我们想的不一样。例如：
int i = 0;              
boolean flag = false; //语句3
i = 1;                //语句1  
flag = true;          //语句2
语句1和语句2的执行顺序改变一下对程序的结果并没有什么影响，所以这时可能会改变这两条指令的顺序。那么语句2会不会在语句3之前执行呢，答案是不会呢，因为语句2用到了语句3声明的变量，这时编译器会限制语句的执行顺序来保证程序的正确性。
在单线程中，改变指令的顺序可能不会产生不良后果，但是在多线程中就不一定了。例如：
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
由于语句1和语句2没有数据依赖性，所以编译器可能会将两条指令重新排序，如果先执行语句2，这时线程1被阻塞，然后线程2的while循环条件不满足，接着往下执行，但是由于context没有赋值，于是会产生错误。
二、volitale关键字的作用
volitale关键字保证了可见性和一定程度上的有序性，但是不能保证原子性。
1、volitale关键字保证可见性
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　2）禁止进行指令重排序。
　　先看一段代码，假如线程1先执行，线程2后执行：
//线程1
boolean stop = false;
while(!stop){
    doSomething();
}

//线程2
stop = true;
　　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。
　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。
　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。
　　但是用volatile修饰之后就变得不一样了：
　　第一：使用volatile关键字会强制将修改的值立即写入主存；
　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效；
　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。
　　那么线程1读取到的就是最新的正确的值。
2、volitale关键字不能保证原子性
从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？
　　下面看一个例子： 
　　
public class Test {
    public volatile int inc = 0;

    public void increase() {
        inc++;
    }

    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }

        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。
　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。
　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。
　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：
　　假如某个时刻变量inc的值为10，
　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；
　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。
　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。
　　那么两个线程分别进行了一次自增操作后，inc只增加了1。
　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。
　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。
3、volitale关键字在一定程度上保证有序性
在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。
　　volatile关键字禁止指令重排序有两层意思：
　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
　　可能上面说的比较绕，举个简单的例子：
//x、y为非volatile变量
//flag为volatile变量

x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
　　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。
　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。
　　那么我们回到前面举的一个例子：
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
　　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。
　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。
参考：http://www.cnblogs.com/dolphin0520/p/3920373.html

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处，查看原文章，请访问：http://blog.csdn.net/xingjiarong

【LeetCode-面试算法经典-Java实现】【202-Happy Number（开心数字）】
【202-Happy Number（开心数字）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Write an algorithm to determine if a number is “happy”. 
　　A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. 
　　Example: 19 is a happy number
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

题目大意
　　对任意一个正整数，不断求个数位上数字的平方和，若最终收敛为1，则该数字为happy number，否则程序可能从某个数开始陷入循环。 

解题思路
　　对这个数字的每个数位求平方和，如果如和为1或者平方和是之前出现过的就不进行求和，根据最后的结果判断是不是一个开心数字。 

代码实现
算法实现类
mport java.util.HashSet;

public class Solution {
    public boolean isHappy(int n) {
        if (n < 1) {
            return false;
        }

        // 用于保存中间出现的结果
        HashSet<Integer> set = new HashSet<>(32);

        int tmp;
        int newN;

        // n不为1，并且n的值不能重复出现，否则会死循环
        while (n != 1 && !set.contains(n)) {
            set.add(n);
            newN = 0;
            while (n > 0) {
                tmp = n % 10;
                n /= 10;
                newN += tmp * tmp;
            }

            n = newN;
        }

        return n == 1;
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47997637】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

java多线程（五）synchronized关键字修饰代码块
转载请注明出处：http://blog.csdn.net/xingjiarong/article/details/47916703 
在上一篇博客中我们介绍了synchronized关键字修饰方法的用法，我们接着介绍synchronized关键字。除了修饰方法之外，还可以修饰代码块，一共有以下5种用法。
一、this
synchronized（this）{
    //互斥代码
}
这里的this指的是执行这段代码的对象，synchronized得到的锁就是this这个对象的锁，这种写法等价于我们上一篇博客中讨论的：
public synchronized void func（）{
    //互斥代码
}
二、A.class
synchronized（A.class）{
    //互斥代码
}
这里A.class得到的是A这类，所以synchronized关键字得到的锁是类的锁，这种方法同下面的方法功能是相同的：
public static synchronized void fun(){
    //互斥代码
}
所有需要类的锁的方法等不能同时执行，但是它和需要某个对象的锁的方法或者是不需要任何锁的方法可以同时执行。
三、object.getClass()
synchronized（object.getClass）{
    //互斥代码
}
这种方法一般情况下同第二种是相同，但是出现继承和多态时，得到的结果却是不相同的。所以一般情况下推荐使用A.class的方式。
四、object
synchronized（object）{
    //互斥代码
}
这里synchronized关键字拿到的锁是对象object的锁，所有需要这个对象的锁的方法都不能同时执行。
public class Trans {
private Object lock = new Object();

    public void printNum(int num){
        synchronized (lock) {
            System.out.print(Thread.currentThread());  
            for(int i=0;i<25;i++){  
                System.out.print(i+" ");  
            }  
            System.out.println();
        }          
    }


}

class MyThread implements Runnable {  
    private Trans trans;  
    private int num;  

    public MyThread(Trans trans, int num) {  
        this.trans = trans;  
        this.num = num;  
    }  

    public void run() {  
        while (true)  
        {  
            trans.printNum(num);  
            try {  
                Thread.sleep(500);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
        }  

    }  
}

public class Test {  


    public static void main(String[] args) {  

        Trans t = new Trans();  
        Trans t1 = new Trans();  
        Thread a = new Thread(new MyThread(t, 1));  
        Thread b = new Thread(new MyThread(t1, 2));  

        a.start();  
        b.start();  

    }  

}
在上边的例子中试图使用这种方法达到互斥方法打印方法，但是事实是这样做是没有效果的，因为每个Trans对象都有自己的Object对象，这两个对象都有自己的锁，所以两个线程需要的是不同锁，两个锁之间没有任何相互作用，所以不会起到互斥作用。
五、static object
上边的代码稍作修改就可以起到互斥作用，将Trans类中Object对象的声明改为下面这样：
private static Object lock = new Object();
这样不同的类使用的就是同一个object对象，需要的锁也是同一个锁，就可以达到互斥的效果了。
经过两篇博客的介绍，我们详细的讨论了synchronized关键字的用法，看似非常复杂，其实抓住要点之后还是很好区分的，只要看synchronized获得的是哪个对象或者类的锁就行啦，其他需要这个锁的方法都不能同时执行，不需要这个锁的方法都能同时执行。
最后还要告别一个误区，相信大家都不会再犯这种错误了，synchronized锁住的是一个对象或者类（其实也是对象），而不是方法或者代码段。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处，查看原文章，请访问：http://blog.csdn.net/xingjiarong

HDU 5402(Travelling Salesman Problem-构造矩阵对角最长不相交路径)

Travelling Salesman Problem
Time Limit: 3000/1500 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 898    Accepted Submission(s): 327
Special Judge

Problem Description
Teacher Mai is in a maze with 
n
 rows and m
 columns. There is a non-negative number in each cell. Teacher Mai wants to walk from the top left corner
(1,1)
 to the bottom right corner (n,m).
 He can choose one direction and walk to this adjacent cell. However, he can't go out of the maze, and he can't visit a cell more than once.

Teacher Mai wants to maximize the sum of numbers in his path. And you need to print this path.

 

Input
There are multiple test cases.

For each test case, the first line contains two numbers 
n,m(1≤n,m≤100,n∗m≥2).

In following n
 lines, each line contains m
 numbers. The j-th
 number in the i-th
 line means the number in the cell (i,j).
 Every number in the cell is not more than 104.

 

Output
For each test case, in the first line, you should print the maximum sum.

In the next line you should print a string consisting of "L","R","U" and "D", which represents the path you find. If you are in the cell
(x,y),
 "L" means you walk to cell (x,y−1),
 "R" means you walk to cell (x,y+1),
 "U" means you walk to cell (x−1,y),
 "D" means you walk to cell (x+1,y).

 

Sample Input

3 3
2 3 3
3 3 3
3 3 2

 

Sample Output

25
RRDLLDRR

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9

 

Recommend
wange2014   |   We have carefully selected several similar problems for you:  5421 5420 5419 5418 5417 
 




当n,m有一个奇数时，‘S形’可全取。
否则至少要少取一个，
如果少取(mx,my) ，当mx+my为偶数时，必然有一个与(mx,my)相邻的不能取
否则必能全取剩下的，（‘S形’+特判2行‘长城形’)










#include<bits/stdc++.h> 
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i>=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define Forpiter(x) for(int &p=iter[x];p;p=next[p])  
#define Lson (x<<1)
#define Rson ((x<<1)+1)
#define MEM(a) memset(a,0,sizeof(a));
#define MEMI(a) memset(a,127,sizeof(a));
#define MEMi(a) memset(a,128,sizeof(a));
#define INF (2139062143)
#define F (100000007)
#define MAXN (100+10)
typedef long long ll;
ll mul(ll a,ll b){return (a*b)%F;}
ll add(ll a,ll b){return (a+b)%F;}
ll sub(ll a,ll b){return (a-b+llabs(a-b)/F*F+F)%F;}
void upd(ll &a,ll b){a=(a%F+b%F)%F;}
int n,m;
ll a[MAXN][MAXN];
int main()
{
//	freopen("Travelling.in","r",stdin);
	
	while(cin>>n>>m) {
		ll sum=0,mi=INF;int mx,my;
		For(i,n) For(j,m) {
			scanf("%lld",&a[i][j]),sum+=a[i][j];
			if (mi>a[i][j]&&(i+j)%2==1)
				mi=min(mi,a[i][j]),mx=i,my=j;
		}
		if (n%2==0&&m%2==0)
		{
			cout<<sum-mi<<endl;	
			
			if (mx%2==1) {
				For(i,mx-1) 
				{
					if (i&1) {For(j,m-1) putchar('R');}
					else {For(j,m-1) putchar('L'); }
					if (i<n) putchar('D');
				}

				int tx=mx,ty=1;
				int p=0;
				For(j,m)
				{
					if (my==j) {if (j<m) putchar('R');continue;}
					if (p==0) printf("D");
					else printf("U");
					p^=1;
					if (j<m) putchar('R');
				}
				Fork(i,mx+2,n) 
				{
					putchar('D');
					if ((i&1)^1) {For(j,m-1) putchar('R');}
					else {For(j,m-1) putchar('L'); }
				}
			}
			
			if (my%2==1) {
				For(i,my-1) 
				{
					if (i&1) {For(j,n-1) putchar('D'); }
					else {For(j,n-1) putchar('U'); }
					if (i<m) putchar('R');
				}
			
				int tx=1,ty=my;
				int p=0;
				For(j,n)
				{
					if (mx==j) {if (j<n) putchar('D');continue;}
					if (p==0) printf("R");
					else printf("L");
					p^=1;
					if (j<n) putchar('D');
				}
				
				Fork(i,my+2,m) 
				{
					putchar('R');
					if ((i&1)^1) {For(j,n-1) putchar('D'); }
					else {For(j,n-1) putchar('U'); }
				}
			}
			
			
		} 
		else {
			cout<<sum<<endl;
			if (n%2) {
				For(i,n) 
				{
					if (i&1) {For(j,m-1) putchar('R');}
					else {For(j,m-1) putchar('L'); }
					if (i<n) putchar('D');
				}
			} else {
				For(i,m) 
				{
					if (i&1) {For(j,n-1) putchar('D'); }
					else {For(j,n-1) putchar('U'); }
					if (i<m) putchar('R');
				}
			}
		}
		cout<<endl;
	}
	
	return 0;
}













版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode-面试算法经典-Java实现】【201-Bitwise AND of Numbers Range（范围数位与结果）】
【201-Bitwise AND of Numbers Range（范围数位与结果）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. 
　　For example, given the range [5, 7], you should return 4. 

题目大意
　　 给一个范围，返回这个范围中所有的数按位相与最后的结果。 

解题思路
　　当m!=n，那么最末位必定等0，因为[m, n]必定包含奇偶数，相与最末位等0。可以将m，n都右移一位，记为mk、 nk，这样就相当于将[m, n]之间的所有的数都右移动了一位，当mk=nk的时候，说明之前[m, n]之间的数右移一位后是相等的，右移后的数作AND操作，结果还是m(=n)，所以操作就可以停止了记录右移的次数，offset，m>>offset即为所求结果 

代码实现
算法实现类
public class Solution {

    public int rangeBitwiseAnd(int m, int n) {
        int offset = 0;

        while (m != n) {
            m >>= 1;
            n >>= 1;
            offset++;
        }

        return m << offset;
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47997613】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode-面试算法经典-Java实现】【203-Remove Linked List Elements（删除单链表中的元素）】
【203-Remove Linked List Elements（删除单链表中的元素）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Remove all elements from a linked list of integers that have value val. 
　　Example 
　　Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6 
　　Return: 1 --> 2 --> 3 --> 4 --> 5 

题目大意
　　给定一值val，在单链表中删除值为val的结点。 

解题思路
　　在链表头添加一个结点，对链表进遍历和删除操作。 

代码实现
链表结点类
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
算法实现类
public class Solution {

    public ListNode removeElements(ListNode head, int val) {
        ListNode root = new ListNode(1);
        root.next = head;
        // 调于记录要处理的元素的前驱结点
        ListNode prev = root;

        // prev.next表示要处理的结点
        while (prev.next != null) {
            // 要处理的结点是要删除的结点
            if (prev.next.val == val) {
                // 对结点进行删除操作
                prev.next = prev.next.next;
            }
            // 当前处理的节点不需要删除，prev移动到下一个结点
            else {
                prev = prev.next;
            }
        }

        // 返回新的根结点
        return root.next;
    }
}

评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47997657】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

C#  json  一维数组  和  二维数组的转换
1.首先你要下载一个HttpHelper     下载地址：http://pan.baidu.com/s/1dDJd0Xz
2.Post提交方式：string json = h.PostPage(地址,参数,);
3.例子如下：
 一维数组   
解析：JObject newobj = JObject.Parse(json);


例： 
newobj["字段名"].ToString();



说明：一维数组不需要循环 直接运用就行了


二维数组
解析： JArray ja = (JArray)JsonConvert.DeserializeObject(json);


例：for (int i = 0; i < ja.Count; i++)
                {
                    local_order order = new local_order();
                    order.code = ja[i]["code"].ToString();
                    order.name = ja[i]["name"].ToString();
                    order.cellphone = ja[i]["cellphone"].ToString();
                    order.address = ja[i]["address"].ToString();
                    order.pickup_begin = ja[i]["pickup_begin"].ToString();
                    order.pickup_end = ja[i]["pickup_end"].ToString();
                    order.price_url = ja[i]["price_url"].ToString();
                    list.Add(order);
                }说明：二维数组需要循环得出




总结：大家要是有什么不明白的俩系我：QQ：703856523     邮箱：703856523@qq.com



版权声明：本文为博主原创文章，未经博主允许不得转载。

【bzoj2049】【SDOI2008】【Cave 洞穴勘测】
2049: [Sdoi2008]Cave 洞穴勘测
Time Limit: 10 Sec  Memory Limit: 259 MB 
Submit: 4803  Solved: 2137 
[Submit][Status][Discuss] 
Description
辉辉热衷于洞穴勘测。某天，他按照地图来到了一片被标记为JSZX的洞穴群地区。经过初步勘测，辉辉发现这片区域由n个洞穴（分别编号为1到n）以及若干通道组成，并且每条通道连接了恰好两个洞穴。假如两个洞穴可以通过一条或者多条通道按一定顺序连接起来，那么这两个洞穴就是连通的，按顺序连接在一起的这些通道则被称之为这两个洞穴之间的一条路径。洞穴都十分坚固无法破坏，然而通道不太稳定，时常因为外界影响而发生改变，比如，根据有关仪器的监测结果，123号洞穴和127号洞穴之间有时会出现一条通道，有时这条通道又会因为某种稀奇古怪的原因被毁。辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示：如果监测到洞穴u和洞穴v之间出现了一条通道，终端机上会显示一条指令 Connect u v 如果监测到洞穴u和洞穴v之间的通道被毁，终端机上会显示一条指令 Destroy u v 经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧”。辉辉希望能随时通过终端机发出指令 Query u v，向监测仪询问此时洞穴u和洞穴v是否连通。现在你要为他编写程序回答每一次询问。已知在第一条指令显示之前，JSZX洞穴群中没有任何通道存在。
Input
第一行为两个正整数n和m，分别表示洞穴的个数和终端机上出现过的指令的个数。以下m行，依次表示终端机上出现的各条指令。每行开头是一个表示指令种类的字符串s（”Connect”、”Destroy”或者”Query”，区分大小写），之后有两个整数u和v (1≤u, v≤n且u≠v) 分别表示两个洞穴的编号。
Output
对每个Query指令，输出洞穴u和洞穴v是否互相连通：是输出”Yes”，否则输出”No”。（不含双引号）
Sample Input
样例输入1 cave.in
200 5
Query   123 127
Connect 123 127
Query   123 127
Destroy 127 123
Query   123 127
样例输入2 cave.in
3   5
Connect 1   2
Connect 3   1
Query   2   3
Destroy 1   3
Query   2   3
Sample Output
样例输出1 cave.out
No
Yes
No
样例输出2 cave.out
Yes
No
HINT
数据说明 10%的数据满足n≤1000, m≤20000 20%的数据满足n≤2000, m≤40000 30%的数据满足n≤3000, m≤60000 40%的数据满足n≤4000, m≤80000 50%的数据满足n≤5000, m≤100000 60%的数据满足n≤6000, m≤120000 70%的数据满足n≤7000, m≤140000 80%的数据满足n≤8000, m≤160000 90%的数据满足n≤9000, m≤180000 100%的数据满足n≤10000, m≤200000 保证所有Destroy指令将摧毁的是一条存在的通道本题输入、输出规模比较大，建议c\c++选手使用scanf和printf进行I\O操作以免超时
lct模板题。
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=10010;
int n,m;
struct LCT{
    int fa[N],ch[N][2],rev[N],road[N];
    bool check_root(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
    int check_same(int x){return x==ch[fa[x]][1];}
    void pushdown(int x){
        int l=ch[x][0],r=ch[x][1];
        if(rev[x]){
            rev[x]^=1;
            rev[l]^=1;
            rev[r]^=1;
            swap(ch[x][0],ch[x][1]);
        }
    }
    void rotate(int x){
        int y=fa[x],z=fa[y],l,r;
        l=(ch[y][0]==x?0:1); r=l^1;
        if(!check_root(y)){
            if(ch[z][0]==y) ch[z][0]=x;
            else ch[z][1]=x;
        }
        fa[x]=z;fa[y]=x;fa[ch[x][r]]=y;
        ch[y][l]=ch[x][r];ch[x][r]=y;
    }
    void splay(int x){
        int i,top=0,y,z;
        road[++top]=x;
        for(i=x;!check_root(i);i=fa[i]) road[++top]=fa[i];
        for(i=top;i;--i) pushdown(road[i]);
        while(!check_root(x)){
            y=fa[x];z=fa[y];
            if(!check_root(y)){
                if(check_same(x)==check_same(y)) rotate(y);
                else rotate(x);
            }
            rotate(x);
        }
    }
    void access(int x){int y=0;while(x){splay(x);ch[x][1]=y;y=x;x=fa[x];}}
    void make_root(int x){access(x);splay(x);rev[x]^=1;}
    void link(int x,int y){make_root(x);fa[x]=y;access(x);}
    void cut(int x,int y){make_root(x);access(y);splay(y);ch[y][0]=fa[x]=0;}
    int find(int x){
        access(x); splay(x);
        while(ch[x][0]) x=ch[x][0];
        return x;
    }
}T;
char ch[10];
int main()
{
    int i,x,y;
    scanf("%d%d",&n,&m);
    while(m--){
        scanf("%*c%s%d%d",&ch,&x,&y);
        if(ch[0]=='C') T.link(x,y);
        if(ch[0]=='D') T.cut(x,y);
        if(ch[0]=='Q'){
            if(T.find(x)==T.find(y)) printf("Yes\n");
            else printf("No\n");
        }
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 1061 青蛙的约会(拓展的欧几里得)
Description
两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。
我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。

Input
输入只包括一行5个整数x，y，m，n，L，其中x≠y < 2000000000，0 < m、n < 2000000000，0 < L < 2100000000。
Output
输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行"Impossible"
Sample Input
1 2 3 4 5
Sample Output
4


由给定的关系有公式『  （x-y）+T*(m-n)=p*l  』可得出a,b,c的值然后进行exgcd和取模运算,
由于X，Y在局部全局都有结果WA了好几次。。。


#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define LL long long
#define inf 0x3f3f3f3f
using namespace std;
LL x,y;
LL exgcd(LL a,LL b)
{
    if(!b)
    {
        y=0;
        x=1;
        return a;
    }
    LL d=exgcd(b,a%b);
    LL g=x;
    x=y;
    y=g-y*(a/b);
    return d;
}
LL mod(LL a,LL b)
{
    if(a>=0)
        return a%b;
    else
        return a%b+b;
}
int main()
{
    LL n,m,k,i,j,l,a,b,d,x1,y1,c;
    while(~scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l))
    {
        a=n-m;
        b=l;
        c=x-y;
        d=exgcd(a,b);
        if(c%d)
        {
            printf("Impossible\n");
            continue;
        }
        b/=d;//为了使b变小，加速运行
        x=mod(x*c/d,b);//a*x=(恒等)bmod(n)
        printf("%lld\n",x);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

【从此不怕强制在线】二进制分组学习笔记
总是遇到分治被强制在线卡真是令人不爽>_< 
那我们就用二进制分组大法来破掉他的强制在线! 
二进制分组大法是什么咧= = 
(学习自许昊然《浅谈数据结构题的几个非经典解法》) 
我们把一个数拆成2的x次幂数的和的形式 
比如: 
17=16(4)+1(0) 
18=16(4)+2(1) 
23=16(4)+4(2)+2(1)+1(0) 
于是在分治算法中我们就有了这样一种做法: 
比如有一个题他使用x^lastans这种手段来实现强制在线 
同时如果去掉强制在线的话这个题目可以分治 
(也就是所谓的满足”修改独立性质”但是没有办法分治) 
那么我们就根据他的操作数目把这些操作中的全部修改操作按二进制分组划分成logn组 
把这些修改操作加上线段树来进行维护. 
假设我们可以在线处理查询操作 
对于每个查询操作只需要对分出的那些组每组全都查询一遍. 
那么执行一个修改操作或者新增一个修改操作,会使后面所有修改操作发生变化,这会改变修改操作的数目,会使得当前分组不合理,因此我们暴力的增加出一个分组/删除一个分组. 
(其实看这些并不能看懂什么意思…我们来看看他在论文答辩里面里的样例) 
忽略半平面的部分叭! 
 
 
 
贴这些就能看懂了… 
那么根据经(yao)验(chuan) 
这东西的复杂度是O(nlog2n)O(nlog^2n)的 
Q:为什么? 
A:我不会!窝萌来看看论文! 
反正我看了之后感觉跟哔了狗一样!!!! 
 
以及关于二进制分组的扩展三进制分组和N进制分组.. 
还是省省吧= = 
原文的意思随着进制数升高,这样会让查询复杂度莫名变高 
但是修改的复杂度变低了. 
(另外为什么我最近总喜欢说哔了狗了QAQ)

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 3376 Matrix Again and hdoj 2686 Matrix 【最大费用最大流】






Matrix Again
Time Limit: 5000/2000 MS (Java/Others)    Memory Limit: 102400/102400 K (Java/Others)
Total Submission(s): 3453    Accepted Submission(s): 1017



Problem Description

Starvae very like play a number game in the n*n Matrix. A positive integer number is put in each area of the Matrix.
Every time starvae should to do is that choose a detour which from the top left point to the bottom right point and than back to the top left point with the maximal values of sum integers that area of Matrix starvae choose. But from the top to the bottom can
 only choose right and down, from the bottom to the top can only choose left and up. And starvae can not pass the same area of the Matrix except the start and end..
Do you know why call this problem as “Matrix Again”? AS it is like the problem 2686 of HDU.

 


Input

The input contains multiple test cases.
Each case first line given the integer n (2<=n<=600) 
Then n lines, each line include n positive integers. (<100)

 


Output

For each test case output the maximal values starvae can get.
 


Sample Input

2
10 3
5 10
3
10 3 3
2 5 3
6 7 10
5
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
5 6 7 8 9

 


Sample Output

28
46
80

 









无语死了，TLE到死。还好最后用G++卡过了，C++死活过不了。


两道题意一样，就是数据卡的不一样！！！
题意：给你一个N*N的矩阵，每个元素代表该处的权值。要求每个点只能走一次，左上角和右下角可以走两次但该处的权值只能获取一次。问你从左上角走到右下角（只能向下或右移动），再从右下角回到左上角（只能向上或左移动）所能得到的最大权值。


思路：把所有元素虚拟成N*N个点，把可达关系当做一条边，可走次数作为边的容量，权值当做边的费用。问题就变成了最大费用最大流。


建图：设置超级源点sink，超级汇点source
1，把所有点i拆分左点i 和 右点i + N*N，i到i+N*N建边，容量为1（只有当i为起点或者终点时容量才为2），费用为点权。
2，sink连接左上角的左点，容量为2，费用0；
3，右下角右点连接source，容量为2，费用0；
4，所有可达关系，即对于坐标(x, y) 向(x+1, y)和(x, y+1)建边（边界需要讨论），容量为1（至少1可以大于1），费用0。
最后跑一遍最大费用最大流后，减去起点权值和终点权值（我们多算了一次）就ok了。理解最小费用后求解最大费用很简单的，只需要把SPFA过程改为查找S-T的最大费用路径。


AC代码： 可以过这两个题



#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
#include <stack>
#include <algorithm>
#define MAXN 800000+10
#define MAXM 4000000+10
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cap, flow, cost, next;
};
Edge edge[MAXM];
int head[MAXN], edgenum;
int pre[MAXN], dist[MAXN];
bool vis[MAXN];
int N;
int Map[610][610];
int sink, source;
void init()
{
    edgenum = 0;
    memset(head, -1, sizeof(head));
}
void addEdge(int u, int v, int w, int c)
{
    edge[edgenum].from = u;
    edge[edgenum].to = v;
    edge[edgenum].cap = w;
    edge[edgenum].flow = 0;
    edge[edgenum].cost = c;
    edge[edgenum].next = head[u];
    head[u] = edgenum++;
    edge[edgenum].from = v;
    edge[edgenum].to = u;
    edge[edgenum].cap = 0;
    edge[edgenum].flow = 0;
    edge[edgenum].cost = -c;
    edge[edgenum].next = head[v];
    head[v] = edgenum++;
}
int point(int x, int y)
{
    return (x-1)*N + y;
}
void getMap()
{
    int k = N*N;
    sink = 0; source = 2*k+1;
    for(int i = 1; i <= N; i++)
    {
        for(int j = 1; j <= N; j++)
        {
            scanf("%d", &Map[i][j]);
            if(i == 1 && j == 1 || i == N && j == N)
                addEdge(point(i, j), point(i, j) + k, 2, Map[i][j]);//起点和终点 容量为2 费用为点权
            else
                addEdge(point(i, j), point(i, j) + k, 1, Map[i][j]);//左点连右点 容量为1 费用为点权
            if(i < N)
                addEdge(point(i, j)+k, point(i+1, j), 1, 0);//右点 连 左点 容量为1 费用0
            if(j < N)
                addEdge(point(i, j)+k, point(i, j+1), 1, 0);
        }
    }
    addEdge(sink, 1, 2, 0);//超级源点 连起点的左点 容量2 费用为0
    addEdge(point(N, N)+k, source, 2, 0);//终点的右点 连超级汇点 容量2 费用为0
}
bool SPFA(int s, int t)
{
    queue<int> Q;
    memset(dist, -INF, sizeof(dist));
    memset(vis, false, sizeof(vis));
    memset(pre, -1, sizeof(pre));
    dist[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            Edge E = edge[i];
            if(dist[E.to] < dist[u] + E.cost && E.cap > E.flow)//最大费用 且 无满流路径
            {
                dist[E.to] = dist[u] + E.cost;
                pre[E.to] = i;
                if(!vis[E.to])
                {
                    vis[E.to] = true;
                    Q.push(E.to);
                }
            }
        }
    }
    return pre[t] != -1;
}
void MCMF(int s, int t, int &cost, int &flow)
{
    cost = flow = 0;
    while(SPFA(s, t))
    {
        int Min = INF;
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            Edge E = edge[i];
            Min = min(Min, E.cap-E.flow);
        }
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost += edge[i].cost * Min;
        }
        flow += Min;
    }
}
int main()
{
    while(scanf("%d", &N) != EOF)
    {
        init();
        getMap();
        int cost, flow;
        MCMF(sink, source, cost, flow);
        cost -= Map[1][1] + Map[N][N];//多算了起点和终点的值
        printf("%d\n", cost);
    }
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

zoj 3885 The Exchange of Items 【最小费用最大流】
The Exchange of Items

Time Limit: 2 Seconds      Memory Limit: 65536 KB

Bob lives in an ancient village, where transactions are done by one item exchange with another. Bob is very clever and he knows what items will become more valuable later on. So, Bob
 has decided to do some business with villagers.
At first, Bob has N kinds of items indexed from 1 to N, and each item has Ai. There are M ways to exchanges items. For the ith
 way (Xi, Yi), Bob can exchange one Xith item to oneYith item, vice versa. Now Bob wants that his ith item has exactly Bi, and he wonders
 what the minimal times of transactions is.
Input
There are multiple test cases. 
For each test case: the first line contains two integers: N and M (1 <= N, M <= 100).
The next N lines contains two integers: Ai and Bi (1 <= Ai, Bi <= 10,000).
Following M lines contains two integers: Xi and Yi (1 <= Xi, Yi <= N).
There is one empty line between test cases.
Output
For each test case output the minimal times of transactions. If Bob could not reach his goal, output -1 instead.
Sample Input
2 1
1 2
2 1
1 2

4 2
1 3
2 1
3 2
2 3
1 2
3 4

Sample Output
1
-1


Author: FENG, Jingyi
Source: ZOJ Monthly, July 2017




题意：Bob有N种物品，已知每种物品有Ai个，现在他想换成Bi个。给出有M种交换方式<Xi，Yi>（表示Xi物品和Yi物品可以互相转换）。问你——Bob达成目标所需要的最小交换次数，若不可能达成目标输出-1。


思路：最小费用最大流。记录目标状态的总流量sum，判断流入汇点的总流量是否等于sum。若等于说明目标状态可达，输出最小费用，反之不可达，输出-1。


建图：设置超级源点sink，超级汇点source。
1，sink向所有物品建边，容量为物品的初始数目，费用为0；
2，所有物品向source建边，容量为物品的目标数目，费用为0；
3，M种转换关系建双向边，容量为INF（为了能够达到目标状态，我们可以任意选择该边的流量），费用为1。
再跑一遍最小费用最大流，若最后的最大流flow等于目标状态的总流量则输出最小费用cost，反之输出-1。




AC代码：

#include <cstdio>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <algorithm>
#define MAXN 110
#define MAXM 1000
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cap, flow, cost, next;
};
Edge edge[MAXM];
int head[MAXN], edgenum;
int pre[MAXN], dist[MAXN];
bool vis[MAXN];
int sink, source;//超级源点 超级汇点
int N, M;
int sum;//记录目标状态总流量
void init()
{
    edgenum = 0;
    memset(head, -1, sizeof(head));
}
void addEdge(int u, int v, int w, int c)
{
    Edge E1 = {u, v, w, 0, c, head[u]};
    edge[edgenum] = E1;
    head[u] = edgenum++;
    Edge E2 = {v, u, 0, 0, -c, head[v]};
    edge[edgenum] = E2;
    head[v] = edgenum++;
}
void getMap()
{
    int a, b;
    sum = 0;
    sink = 0, source = N+1;
    for(int i = 1; i <= N; i++)
    {
        scanf("%d%d", &a, &b);
        addEdge(sink, i, a, 0);//超级源点连i 容量为a 费用为0
        addEdge(i, source, b, 0);//i连超级汇点 容量为b 费用为0
        sum += b;//记录目标状态总流量
    }
    for(int i = 1; i <= M; i++)
        scanf("%d%d", &a, &b),
        addEdge(a, b, INF, 1), addEdge(b, a, INF, 1);//互建边 容量无穷大 费用1
}
bool SPFA(int s, int t)
{
    queue<int> Q;
    memset(dist, INF, sizeof(dist));
    memset(vis, false, sizeof(vis));
    memset(pre, -1, sizeof(pre));
    dist[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            Edge E = edge[i];
            if(dist[E.to] > dist[u] + E.cost && E.cap > E.flow)
            {
                dist[E.to] = dist[u] + E.cost;
                pre[E.to] = i;
                if(!vis[E.to])
                {
                    vis[E.to] = true;
                    Q.push(E.to);
                }
            }
        }
    }
    return pre[t] != -1;
}
void MCMF(int s, int t, int &cost, int &flow)
{
    cost = flow = 0;
    while(SPFA(s, t))
    {
        int Min = INF;
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            Edge E = edge[i];
            Min = min(Min, E.cap - E.flow);
        }
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost += edge[i].cost * Min;
        }
        flow += Min;
    }
}
int main()
{
    while(scanf("%d%d", &N, &M) != EOF)
    {
        init();
        getMap();
        int cost, flow;
        MCMF(sink, source, cost, flow);
        if(flow == sum)//若流入汇点的总流量 等于 目标状态总流量 说明可行
            printf("%d\n", cost);
        else
            printf("-1\n");
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

MVVM设计模式基础知识--NotificationObject类（Prism框架）
在博客“MVVM设计模式基础知识–INotifyPropertyChanged接口”一文中，已经谈到了INotifyPropertyChanged接口。 
今天我们来谈一下NotificationObject类。
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 
但是设计模式不是一成不变的，每个人的理解也有所不同。譬如说MVVM设计模式，如果不需要ICommand接口，很多人就习惯将Model和ViewModel合二为一。这次很多人会采用的是继承NotificationObect类而不是继承INotifyPropertyChanged接口。
譬如说在Prism框架(Prism是一个超轻量的开源框架，前身是Angel ，现在改名为 Prism)中，有一个NotificationChanged类，位于Microsoft.Practices.Prism.ViewModel命名空间下，而NotificationObject类是继承INotifyPropertyChanged接口。
下面通过.NET Reflector查看Microsoft.Practices.Prism.ViewModel中的NotificationObject类。 
源码如下：
public abstract class NotificationObject : INotifyPropertyChanged
{
    // Events
    [field: NonSerialized]
    public event PropertyChangedEventHandler PropertyChanged;

    // Methods
    protected NotificationObject()
    {
    }

    protected void RaisePropertyChanged<T>(Expression<Func<T>> propertyExpression)
    {
        string propertyName = PropertySupport.ExtractPropertyName<T>(propertyExpression);
        this.RaisePropertyChanged(propertyName);
    }

    protected virtual void RaisePropertyChanged(string propertyName)
    {
        PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
        if (propertyChanged != null)
        {
            propertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    protected void RaisePropertyChanged(params string[] propertyNames)
    {
        if (propertyNames == null)
        {
            throw new ArgumentNullException("propertyNames");
        }
        foreach (string str in propertyNames)
        {
            this.RaisePropertyChanged(str);
        }
    }
}

NotificationObject类的使用：
public class PatientInfoViewModel : NotificationObject
{
    public static string m_PatID = "";
    public string PatID
    {
        get { return m_PatID; }
        set
        {
            if (!value.Equals(m_PatID))
            {
                m_PatID = value;
                this.RaisePropertyChanged(() => this.PatID);
            }
        }
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

每天五个java相关面试题（9）--java基础详解篇1
接下来会系统的总结java基础，然后过两天会开始从新开始复习前端并更新和总结一些关于前端的基础知识和面试题，嗯嗯我是一个想走前端的后端java工程师啊哈哈。马上开学大四了，lz我要加油啦~
接下来的面试题会学习我们班小伙伴的好学习方法，一个个刨根问底了，理清楚里面涉及到的知识点。
一、面向对象的特征有哪些方面
答： 
1.抽象： 
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。
2.继承： 
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装： 
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。
4.多态性： 
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。（静态多态是方法重载，动态多态是方法重写）
上面回答中涉及的知识点：
1、封装具体就是三步：第一步是设置对象属性私有化，第二步是创建赋值和取值方法（就是我们常说的get/set方法），第三步在赋值和取值方法中，加入对属性的存取限制（俗称校验）。
2、继承父类一定需要实现父类的方法嘛？ 
如果父类是抽象类，并且有抽象方法，那么子类必须重写父类的抽象方法，或者子类声明为抽象类。如果父类是个普通类，那么不是必须重写父类的方法。
3、何为抽象类？ 
使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。“抽象方法”,属于一种不完整的方法，只含有一个声明，没有方法主体。（类似于接口）。
4、在继承的时候我们有时候需要重写父类的方法，那么重写和重载的区别是什么？ 
重写的方法名，参数数目相同，参数类型兼容，重载的方法名相同，参数列表不同。 
重写的方法修饰符大于等于父类的方法，重载和修饰符无关。 
这里希望大家知道一个词语方法签名 就是由方法名称和一个参数列表（方法的参数的顺序和类型）组成。
二、Collection 和 Collections的区别。
答： 
Collection是集合类的上级接口，继承与他的接口主要有Set 和List. 
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
上面回答中涉及的知识点：
1、Collection接口在Java 类库中有有哪些具体的实现？ 
java.util.Collection 是一个集合接口。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 
 Collection 
├List 
│├LinkedList 
│├ArrayList 
│└Vector 
│　└Stack 
└Set 
2、java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，内部封装了很多对各种集合的搜索、排序、线程安全化等操作，比如对一个list数组内的值进行排序，只需要Collections.sort(list);  即可。
三、String 、StringBuilder、Stringbu和StringBuffer的区别
答： 
String和StringBuffer和StringBuilder，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用 StringBuffers来动态构造字符数据。StringBuffer和StringBuilder类功能基本相似，主要区别在于StringBuffer类的方法是多线程、安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。
上面回答中涉及的知识点：
1、什么是线程安全？ 
线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
四、运行时异常与一般异常有何异同?
答： 
Java提供了两类主要的异常:runtime exception （运行时异常）和checked exception （检查异常）。检查异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。
但是另外一种异常：运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。我们不需要进行捕获。
上面回答中涉及的知识点：
1、说出你常见的五种异常？ 
这个题我们老师说很容易被问到，所有大家可以挑选几个自己记下来，我这里也自己挑选几个了。

java.lang.nullpointerexception（”空指针异常”）
java.lang.classnotfoundexception（”指定的类不存在”，这里主要考虑一下类的名称和路径是否正确即可）
java.lang.arithmeticexception（”数学运算异常”，比如程序中出现了除以零这样的运算就会出这样的异常）
java.lang.arrayindexoutofboundsexception（”数组下标越界”）
java.lang.illegalargumentexception（”方法的参数错误”）

五、ArrayList,Vector为什么增、删慢，查、改快？而LinkedList查、改、慢，增、删快？
答： 
ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。 
而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。请多多指教~

关于最大费用最大流的一类问题  【小谈】


引子：给你一个N*M的矩阵，对应N*M个点，且每个点都有一定的点权。当第一次到达某个位置时，我们可以获得该位置的点权且只能获取这一次。现在让你从左上角出发，每次只能向下或者向右走~~~。 


当然是有限制的走
问题一：每个点只能走一次（除了起点和终点可以走多次），问你从左上角到右下角走两次所获取的最大权值和。
问题二：每个点无限走，问你从左上角到右下角走K次获取的最大权值和。


声明下，我要说的是建图，而不是怎么写代码。
这两种问题想了好久，姑且分享一下我的见解。错误的地方欢迎指正！！！O(∩_∩)O~~








我们默认把一个点 可以拆为 左点 和 右点（网络流解决问题很常用的手段，这里不细说）。
明确一下————当选择A点的左点或者右点时，都说明你选择了走A这个点。


情况一：每个点只能走一次（除了起点和终点可以走多次），问你走2次获取的最大权值和。


1，对可达边<u, v>的处理，注意是有向边
我们会考虑四种情况，题目要求————每个点只能走一次。所以我们如果选择走一个点就必须要获取它的点权，只有这样才能得到最大权值和。
如图：


首先明确我们在左点时，只有一种选择————就是到达右点，只有这样才能保证选择一个点必须要获取该点的点权。
这样的话只有选择U右到V左，才能保证获取两个点的点权。


(1)u的左点连v的左点，说明不获取u的点权而获取v的点权，不符合。
(2)u的左点连v的右点，说明既不获取u的点权也不获取v的点权，不符合。
(3)u的右点连v的左点，说明既获取u的点权又获取v的点权，符合。
(4)u的右点连v的右点，说明获取u的点权而不获取v的点权，不符合。
因此，我们只能建(3)这一条边。边的容量为1或者其他值，因为前一条边已经限制了流量最大为1，所以只要容量大于或等于1就行了。
获取点权这一点我说的可能不是很合适，建议自己模拟一下，好好思考。当然若有严重的bug，欢迎指正。


2，拆点
我们要保证超级源点到起点的2个流量能够传进来（因为我们要走两次，所以超级源点到起点的流量为2），并且终点到超级汇点的流量尽可能的传出去，这样才能最大化获得的权值和。
所以我们在拆点的时候，对起点和终点的处理是————建立容量为2的边，对其它点的处理————建立容量为1的边（访问后不能再访问）。 
因为若起点和终点拆成容量为1的边，那我们在起点的时候就只有一个选择：向上走或者向下走，在终点时只能选择是由上面的点传到终点还是由左边的点传入终点，这样的话就相当于求走一次的最大权值和，显然这样建图是不对的。

对于该问题的解决方案：建立超级源点sink，超级汇点source。
1，sink向起点左点建边，容量为2，费用为0；
2，拆点，起点、终点拆成容量为2的边，其他点拆成容量为1的边，费用为点权；
3，<u, v>可达边，则u的右点指向v的左点，容量为1，费用为0；
4，终点右点向source建边，容量为2，费用为0.
建好边，跑一次最大费用最大流，因为我们多算了一次起点和终点的点权，所以最后求出的最大费用要减去起点和终点的点权。




情况二：每个点无限走，问你从左上角到右下角走K次获取的最大权值和。




1，我们对可达边<u, v>处理，还是那句话————当选择一个点的左点或者右点时，都说明你选择了走这个点。
我们会考虑四种情况，题目要求————每个点可以走多次。所以我们如果选择一个点并不意味着一定要获取它的点权
如图：


显然有上面4种方式，因为我们不考虑是否获取点权。这就是说，当到达左点时，不一定非要选择到右点。 
当然这只是<u, v>边的情况，u每次可以选择向下走或者向右走，这样每一个点都会有8种选择（不考虑特殊的边界点）。
(1)u的左点连v的左点，说明不获取u的点权而获取v的点权，符合。
(2)u的左点连v的右点，说明既不获取u的点权也不获取v的点权，符合。
(3)u的右点连v的左点，说明既获取u的点权又获取v的点权，符合。
(4)u的右点连v的右点，说明获取u的点权而不获取v的点权，符合。
因此，我们可以建(1)(2)(3)(4)这四条边，边的容量为无穷大，因为我们可以任意选择经过该边的流量（不超过K的前提下），只要它能使最权值和最大化就行了。


2，拆点

如果我们可以走一个点多次，那么不管怎么样，从一个点出发只会有8种方式下传流量给另一个点（这里我们不考虑那些特殊的边界点）。我们会发现，在上述建边的前提下，已经包括了所有将流量传入下一点的方式。
这样的话我们只需要把每个点拆分成容量为1的边、并且保证超级源点到起点以及终点到超级汇点的边的容量为K————就可以保证最后的结果取的是走K次的最大权值和。





对于该问题的解决方案：设置超级源点sink，超级汇点source
1，sink向起点左点建边，容量为K，费用为0；
2，拆点，每个点拆为容量为1，费用为点权的边；
3，<u, v>可达关系建四条边，这样的话对于非特殊边界点则可以建8条边（下、右都要建），边的容量为INF，费用为0；
4，终点到source建边，容量为K，费用为0。
最后跑一次最大费用最大流，结果就是最大权值和。






版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA 题目1223 - Editor（后缀数组求出现次数超过两次的最长子串的长度）
Mr. Kim is a professional programmer. Recently he wants to design a new editor which has as many functions as possible. Most editors support a simple search function that finds one occurrence (or all occurrences
 successively) of a query pattern string in the text.
He observed that the search function in commercial editors does nothing if no query pattern is given. His idea of a new search function regards each substring of the given text as a query
 pattern string itself and his new function finds another occurrence in the text. The problem is that there can be occurrences of many substrings in the text. So, Mr. Kim decides that the new function finds only occurrences of the longest
 substring in the text in order to remedy the problem. A formal definition of the search function is as follows:
Given a text string S , find the longest substring in text string S such that the substring appears at least twice. The two occurrences are allowed
 to overlap.

Input 
Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the
 input. For each test case, a text string S is given in one line. For every string, the length is less than or equal to 5,000 and the alphabet  is
 the set of lowercase English characters.

Output 
Your program is to write to standard output. Print exactly one line for each test case. Print the length of the longest substring in text string S such that the substring appears
 at least twice.

Sample Input 

3 
abcdefghikjlmn 
abcabcabc 
abcdabcabb


Sample Output 

0 
6 
3做这么多后缀数组题以来，这个应该是最水的了吧ac代码0ms过#include<stdio.h>              
#include<string.h>              
#include<algorithm>              
#include<iostream>             
#define min(a,b) (a>b?b:a)          
#define max(a,b) (a>b?a:b)       
#define N 1000005         
using namespace std;            
char str[5010];          
int sa[5010],Rank[5010],rank2[5010],height[5010],c[5010],*x,*y,s[5010],k;   
void cmp(int n,int sz)        
{        
    int i;        
    memset(c,0,sizeof(c));        
    for(i=0;i<n;i++)        
        c[x[y[i]]]++;        
    for(i=1;i<sz;i++)        
        c[i]+=c[i-1];        
    for(i=n-1;i>=0;i--)        
        sa[--c[x[y[i]]]]=y[i];        
}        
void build_sa(char *s,int n,int sz)        
{        
    x=Rank,y=rank2;        
    int i,j;        
    for(i=0;i<n;i++)        
        x[i]=s[i],y[i]=i;        
    cmp(n,sz);        
    int len;        
    for(len=1;len<n;len<<=1)        
    {        
        int yid=0;        
        for(i=n-len;i<n;i++)        
        {        
            y[yid++]=i;        
        }        
        for(i=0;i<n;i++)        
            if(sa[i]>=len)        
                y[yid++]=sa[i]-len;        
            cmp(n,sz);        
        swap(x,y);        
        x[sa[0]]=yid=0;        
        for(i=1;i<n;i++)        
        {        
            if(y[sa[i-1]]==y[sa[i]]&&sa[i-1]+len<n&&sa[i]+len<n&&y[sa[i-1]+len]==y[sa[i]+len])        
                x[sa[i]]=yid;        
            else        
                x[sa[i]]=++yid;        
        }        
        sz=yid+1;        
        if(sz>=n)        
            break;        
    }        
    for(i=0;i<n;i++)        
        Rank[i]=x[i];        
}        
void getHeight(char *s,int n)        
{        
    int k=0;        
    for(int i=0;i<n;i++)        
    {        
        if(Rank[i]==0)        
            continue;        
        k=max(0,k-1);        
        int j=sa[Rank[i]-1];        
        while(s[i+k]==s[j+k])        
            k++;        
        height[Rank[i]]=k;        
    }        
}   
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%s",str);
		int ans=0;
		int n=strlen(str);
		build_sa(str,n+1,128);
		getHeight(str,n);
		for(int i=1;i<=n;i++)
			ans=max(ans,height[i]);
		printf("%d\n",ans);
	}
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

老生常谈之widows下link错误
         由于之前一直从事linux下的嵌入式开发，对于windows下的工程环境配置，lib链接，dll链接等等都不是很敏感。经过一些时间的摸索和实践，基本的一些配置选项都玩得差不多了。对于常见的错误都能知道怎么去下手解决，但最近把项目把移植到64位操作上，重新编译所有的dll的时候。发现几个link问题还是不能很快的解决，几个链接的错误摸索了好几天，最后都是因为配置问题引起的，各种郁闷，原来VS下面果真没有linux来的那般方便。跑偏了，言归正传，总结一下遇到的几种比较典型link的错误，1、查看库的引导路径以及库的名称，如果是导入DLL的话，注意DLL导出接口的lib库文件。配置如下：                                           左边配置好需要的路径，右边加载需要的库文件的名称即可。一般情况下如果配置好上面的情况并且在工程目录加入dll的话，程序就能正常运行了,这也是大多数论坛上回复很多人link错误的答案。但是有时候其他的配置没有匹配的话，也会link错误的。2、注意宽字节问题。先来看看我自己链接时候的错误       出现这个错误的时候，刚开始我也是莫名其妙的，因为我对于第一条中提到的配置问题，我都已经设置好了，确认没有问题的。后来怀疑编译这个开源的时候没有成功导出接口，所以又借助Depends看了下，如下图： 发现接口也都成功导出了呀，并没有什么问题。后来思量再三，问了下老大，结果他看了半天也是无从下手。后面没有办法，老大竟然对比了函数导出名称后面的数字竟然发现是不同的，我也仔细看了，红色框框部分，确实不同，姜果然是老的辣，一语击中要害。原来我生成的dll设置了宽字节，而链接这个dll的时候不需要没有，导致出现链接不上，又来修改了设置如下：修改后，编译连接成功。纠结了蛮久的问题终于解决。这也是link错误的一个比较隐藏的错误。当然在其中还有另外两个地方的设置，也会引起link的错误的。3、字节编码的设置问题   4、RunTime Library的设置问题 各个选项的具体说明可以参考David的博客，说的比较清楚，这里的设置问题也会引起link错误。            最后总结下，link错误千千万，很多情况都会出现各种纠结的link问题，遇到问题不要急躁，细心仔细对比，首先确认链接问题，然后是否成功导出，查看导出和调用接口差异，确认各个可能引起链接错误的配置信息等等，一步一步缩小范围。

版权声明：本文为博主原创文章，未经博主允许不得转载。

【SDOI2014】【BZOJ3534】重建
Description
T国有N个城市，用若干双向道路连接。一对城市之间至多存在一条道路。 
    在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。 
    辛运的是，此前T国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有N-1条，且能联通所有城市的概率。
Input
输入的第一行包含整数N。 
  接下来N行，每行N个实数，第i+l行，列的数G[i][j]表示城市i与j之 
间仍有道路联通的概率。 
    输入保证G[i][j]=G[j][i]，且G[i][j]=0；G[i][j]至多包含两位小数。
Output
输出一个任意位数的实数表示答案。
你的答案与标准答案相对误差不超过10^(-4)即视为正确。

Sample Input
3

0 0.5 0.5

0.5 0 0.5

0.5 0.5 0

Sample Output
0.375

HINT
1 < N < =50
数据保证答案非零时，答案不小于10^-4
Source
Round 1 Day 2
看起来好像直接对输入的矩阵计算一下行列式的值就可以了… 
可以个[哔——]! 
根本不对! 
做不出来题到处问: 
 
 
 
哔—— 
最后找到了gty大哥的blog… 
好详细真是感人至深QwQ 
让我们来看看正确的姿势… 
令矩阵里的元素P(i,j)=1−P(i,j)P(i,j)=1-P(i,j),记一个tmp=∏(1−P(i,j))tmp=\prod(1-P(i,j)) 
计算新的矩阵的行列式的值再乘上这个tmp得到答案… 
不明白为什么这样吧>_< 
其实我也不是很明白…

我们似乎可以通过令G(i,j)=P(i,j)来得到答案。且慢！要知道这道题目对于一棵生成树来说，它的期望应该为∏(i,j)∈EP(i,j)∏(i,j)∉E(1−P(i,j))。正确的方法应该为令G(i,j)=P(i,j)1−P(i,j)，最后求出|det(G)|后再乘以tmp=∏(1−P(i,j))\prod{(i,j)\in E}P(i,j)\prod{(i,j)\notin E}(1-P(i,j))。正确的方法应该为令G(i,j)=\frac{P(i,j)}{1-P(i,j)}，最后求出|det(G)|后再乘以tmp=\prod (1-P(i,j))，得到的即为正确答案。

所以就是这样(终于明白一些了) 
要注意1−P(i,j)1-P(i,j)有可能等于零,这时候要手动把它变成eps 
以及P(i,j)P(i,j)和P(j,i)P(j,i)乘一个就行了…别乘多了…
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 100
#define eps 1e-9
using namespace std;
int n;
double G[MAXN][MAXN];
double tmp=1;
double Gauss()
{
    double ret=1;
    for (int i=1;i<n;i++)
    {
        int now=i;
        for (int j=i+1;j<n;j++) now=fabs(G[now][i])<fabs(G[j][i])?j:now;
        if (now!=i)
            for (int j=1;j<n;j++)   swap(G[now][j],G[i][j]);
        for (int j=i+1;j<n;j++)     
        {
            double temp=G[j][i]/G[i][i];
            for (int k=i;k<n;k++)   G[j][k]-=G[i][k]*temp;
        }
        if (fabs(G[i][i])<eps)  return 0;
        ret*=G[i][i];
    }
    return fabs(ret)*tmp;
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
        {
            scanf("%lf",&G[i][j]);
            double t=fabs(1-G[i][j])<eps?eps:1-G[i][j];
            if (i<j)    tmp*=t;
            G[i][j]/=t;
        }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            if (i!=j)   G[i][i]-=G[i][j];
    printf("%.10f\n",Gauss());
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【NOI2015】【BZOJ4199】品酒大会
Description
Input
Output
Sample Input
Sample Output
HINT
Source 
BZOJ无题面233 
反正网上一堆自己下载叭>_< 
对反串建SAM然后DP 
第一问和AHOI2013差异完全一样 
具体解法: 
设Ans1[i]为lcp恰为i的后缀对数，Ans2[i]为lcp恰为i的后缀的价值乘积的最大值 
建出SAM后，记录子树中后缀个数、价值的最大值、价值的最小值，然后O(n)DP即可 
在SAM里DP完记得最后统计到Ans1和Ans2里去 
size会爆int…一开始开的int一直WAWAWAWA…
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 600100
#define LL long long
#define MAXINT 1ll<<60
using namespace std;
int n,top;
LL A[MAXN];
char ch[MAXN];
LL Ans1[MAXN],Ans2[MAXN];
struct edge
{
    int to;
    edge *next;
}e[MAXN<<1],*prev[MAXN];
void insert(int u,int v)
{
    e[++top].to=v;e[top].next=prev[u];prev[u]=&e[top];
}
void in(LL &x)
{
    char ch=getchar();x=0;int flag=1;
    while (!(ch>='0'&&ch<='9')) flag=ch=='-'?-1:1,ch=getchar();
    while (ch>='0'&&ch<='9')    x=x*10+ch-'0',ch=getchar();x*=flag;
}
struct sam
{
    int cnt,last,p,q,np,nq;
    int a[MAXN][26],len[MAXN],fa[MAXN];
    LL maxn[MAXN],minn[MAXN],ans1[MAXN],ans2[MAXN],size[MAXN];
    sam()
    {
        last=++cnt;
    }
    void insert(int c,int x)
    {
        p=last;last=np=++cnt;len[np]=len[p]+1;size[np]=1;maxn[np]=minn[np]=A[x];
        while (!a[p][c]&&p) a[p][c]=np,p=fa[p];
        if (!p) fa[np]=1;
        else
        {
            q=a[p][c];
            if (len[q]==len[p]+1)   fa[np]=q;
            else
            {
                nq=++cnt;len[nq]=len[p]+1;maxn[cnt]=-MAXINT;minn[cnt]=MAXINT;
                memcpy(a[nq],a[q],sizeof(a[q]));
                fa[nq]=fa[q];fa[q]=fa[np]=nq;
                while (a[p][c]==q)  a[p][c]=nq,p=fa[p];
            }
        }
    }
}sam;
void dfs(int x)
{
    for (edge *i=prev[x];i;i=i->next)
    {
        dfs(i->to);
        sam.ans1[x]+=sam.size[x]*sam.size[i->to];
        sam.size[x]+=sam.size[i->to];
        if (sam.maxn[x]!=-MAXINT)
            sam.ans2[x]=max(sam.ans2[x],sam.maxn[i->to]*sam.maxn[x]);
        if (sam.minn[x]!=MAXINT)
            sam.ans2[x]=max(sam.ans2[x],sam.minn[i->to]*sam.minn[x]);
        sam.maxn[x]=max(sam.maxn[x],sam.maxn[i->to]);
        sam.minn[x]=min(sam.minn[x],sam.minn[i->to]);
    }
}
int main()
{
    freopen("savour.in","r",stdin);
    freopen("savour.out","w",stdout);
    scanf("%d",&n);
    scanf("%s",ch);sam.maxn[1]=-MAXINT;sam.minn[1]=MAXINT;
    for (int i=1;i<=n;i++)  in(A[i]);
    for (int i=n;i;i--) sam.insert(ch[i-1]-'a',i);
    for (int i=0;i<=sam.cnt;i++)    sam.ans2[i]=-MAXINT;
    for (int i=1;i<=sam.cnt;i++)    insert(sam.fa[i],i);
    dfs(1);
    for (int i=0;i<n;i++)   Ans2[i]=-MAXINT;
    for (int i=1;i<=sam.cnt;i++)    Ans1[sam.len[i]]+=sam.ans1[i],Ans2[sam.len[i]]=max(Ans2[sam.len[i]],sam.ans2[i]);
    for (int i=n-2;i>=0;i--)
    {
        Ans1[i]+=Ans1[i+1];
        if (Ans1[i+1])  Ans2[i]=max(Ans2[i],Ans2[i+1]);
    }
    for (int i=0;i<n;i++)   printf("%lld %lld\n",Ans1[i],Ans1[i]?Ans2[i]:0);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【Ahoi2005】【BZOJ1968】COMMON 约数研究
Description
 
Input
只有一行一个整数 N（0 < N < 1000000）。 
Output
只有一行输出，为整数M，即f(1)到f(N)的累加和。 
Sample Input
3

Sample Output
5

HINT
Source
Day2 
傻逼题233 
求∑ni=1⌊ni⌋\sum_{i=1}^n \lfloor \frac n i\rfloor
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,sum;
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)  sum+=n/i;
    cout<<sum;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【模板整合】【及时更新】【天坑】计算几何模板
计算几何模板要写的内容真多… 
我写烦了…先写这些放上来吧…
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define MAXDBL 1e20
#define eps 1e-9
#define pi acos(-1)
using namespace std;
struct point
{
    double x,y;
    point(double _x=0,double _y=0):
        x(_x),y(_y){}
    bool operator <(const point& a)const
    {
        return x==a.x?y<a.y:x<a.x;
    }
};
typedef point Vector;
Vector operator +(Vector A,Vector B)//向量加减乘除  
{
    return Vector(A.x+B.x,A.y+B.y);
}
Vector operator -(Vector A,Vector B)
{
    return Vector(A.x-B.x,A.y-B.y);
}
Vector operator *(Vector A,double k)
{
    return Vector(A.x*k,A.y*k);
}
Vector operator /(Vector A,double k)
{
    return Vector(A.x/k,A.y/k);
}
bool operator ==(Vector A,Vector B)
{
    return fabs(A.x-B.x)<eps&&fabs(A.y-B.y)<eps;
}
double sqr(double x)
{
    return x*x;
}
double dis(point a,point b)//点距离 
{
    return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}
point point_sym(point A,point B)//A关于B的对称点 
{
    return point(2*B.x-A.x,2*B.y-A.y);
}
double dot(Vector a,Vector b)//向量点积 
{
    return a.x*b.x+a.y*b.y;
}
double cross(Vector a,Vector b)//叉积 
{
    return a.x*b.y-a.y*b.x;
}
double Area(point a,point b,point c)//面积 
{
    Vector A=b-a,B=b-c;
    return fabs(cross(A,B))/2;
}
double len(Vector A)//向量长度 
{
    return sqrt(sqr(A.x)+sqr(A.y));
}
double angle(Vector A,Vector B)//求夹角
{
    return acos(dot(A,B)/len(A)/len(B));
}
Vector rot(Vector A,double rad)//向量逆时针旋转rad弧度 
{
    return Vector(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));
}
Vector normal(Vector A)//逆时针旋转90度的单位向量 
{
    double l=len(A);
    return Vector(-A.y/l,A.x/l);
}
Vector unit(Vector A)//基于原向量的单位向量 
{
    double l=len(A);
    return A/l;
}
struct line
{
    point p;Vector v;//直线经过的点和直线的方向向量 
    line(point _p=point(0,0),Vector _v=Vector(0,0)):
        p(_p),v(_v){}
};
bool on_left(line l,point p)//点在直线左边/右边 
{
    return cross(l.v,p-l.p)>0;
}
point line_cross(line a,line b)//直线交点 
{
    Vector u=A.p-B.p;
    double t=Cross(B.v,u)/Cross(A.v,B.v);
    return A.p+A.v*t;
};
double dis_point_line(point A,line B)//点到直线距离 
{
    point a=B.p,b=B.p+B.v;
    Vector u=A-a,v=b-a;
    return fabs(cross(u,v))/len(v);
};
struct circle
{
    point p;double r;
    circle(point _p,double _r):
        p(_p),r(_r){}
    point Point(double rad)
    {
        return Point(p.x+r*cos(rad),p.y+r*sin(rad));
    }
};
vector<point> line_cross_circle(line l,circle c)//直线和圆的交点 
{
    line dia(C.p,normal(l.v));
    point inter=line_cross(dia,l);
    double d=dis_point_line(inter,dia);
    if (c.r-d<0)    return vector<point>();
    double  Len=sqrt(sqr(c.r)-sqr(d));
    vector<point> V;
    V.push_back(inter-unit(l.v)*Len);
    V.push_back(inter+unit(l.v)*len);
}
int convexhull(point *p,int n,point *ch)//求凸包 
{
    sort(p+1,p+n+1);
    int top=0,tmp;
    for (int i=1;i<=n;i++)
    {
        while (top>1&&cross(ch[top-1]-ch[top-2],p[i]-ch[top-2])<=0) top--;
        ch[++top]=p[i];
    }
    tmp=top;
    for (int i=n-1;i>=1;i--)
    {
        while (top>tmp&&cross(ch[top-1]-ch[top-2],p[i]-ch[top-2])<=0)   top--;
        ch[++top]=p[i];
    }
    return top;
}
double ch_area(point *ch,int n)//凸包面积 
{
    double ret=0;
    for (int i=1;i<n;i++)   ret+=Area(ch[1],ch[i],ch[i+1]);
    return ret;
}
double ch_cir(point *ch,int n)//凸包周长
{
    double ret=0;
    for (int i=1;i<n;i++)   ret+=dis(ch[i],ch[i+1]);
    ret+=dis(ch[n],ch[1]);
    return ret;
}

int main()
{

}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【BZOJ2555】SubString
Description
懒得写背景了，给你一个字符串init，要求你支持两个操作

(1):在当前字符串的后面插入一个字符串

(2):询问字符串s在当前字符串中出现了几次？(作为连续子串)

你必须在线支持这些操作。

Input
第一行一个数Q表示操作个数

第二行一个字符串表示初始字符串init

接下来Q行，每行2个字符串Type,Str 

Type是ADD的话表示在后面插入字符串。

Type是QUERY的话表示询问某字符串在当前字符串中出现了几次。

为了体现在线操作，你需要维护一个变量mask，初始值为0


读入串Str之后，使用这个过程将之解码成真正询问的串TrueStr。
询问的时候，对TrueStr询问后输出一行答案Result
然后mask = mask xor Result  
插入的时候，将TrueStr插到当前字符串后面即可。

HINT:ADD和QUERY操作的字符串都需要解压
Output
Sample Input
2



A



QUERY B



ADD BBABBBBAAB

Sample Output
0

HINT
40 % 的数据字符串最终长度 <= 20000，询问次数<= 1000，询问总长度<= 10000
100 % 的数据字符串最终长度 <= 600000，询问次数<= 10000,询问总长度<= 3000000
新加数据一组–2015.05.20
Source
Ctsc模拟赛By 洁妹
看题后想到 
SAM+LCT 
(其实完全是听学长讲课时候知道的)(划掉这句话) 
刚开始觉得可能会很长写了写发现不是很长也就不到150行 
对SAM的Parent树建LCT,给每个状态一个权值 
然后就可以通过统计LCT的权值来统计出现次数了. 
一开始习惯性的在makeroot时候写了打上rev标记但是WA了? 
不知道为什么 
删掉之后又做了做微调发现自己又是RE又是TLE 
最后开大了数据范围就A了. 
这个题上经历了WA,RE,TLE,MLE真是感人至深.人生百态 
 
 
WA多了怂了一波开小号A了… 
但是还是非常慢! 
但是还是非常慢! 
但是还是非常慢! 
很重要所以说三遍! 
竟然跑了14sQAQ
最后还是觉得真是蛮难调的…
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 3000010
using namespace std;
int Q;
char ch[MAXN],s[MAXN];
string chars;
int top,sta[MAXN];
int mask,ans;
void gets(int mask)
{
    scanf("%s",s);
    chars=s;
    int len=chars.length();
    for (int j=0;j<len;j++) 
    {
        mask=(mask*131+j)%len;
        char t=chars[j];
        chars[j]=chars[mask];
        chars[mask]=t;
    }
}
struct lct
{
    int ch[2],fa,flag,w;
    bool rev;
}tree[MAXN];
void modify(int x,int delta)
{
    if (x)  tree[x].w+=delta,tree[x].flag+=delta;
}
void push_down(int x)
{
    if (tree[x].flag)
    {
        modify(tree[x].ch[0],tree[x].flag);modify(tree[x].ch[1],tree[x].flag);
        tree[x].flag=0;
    }
}
bool is_root(int x)
{
    return tree[tree[x].fa].ch[0]!=x&&tree[tree[x].fa].ch[1]!=x;
}
void rot(int x)
{
    int y=tree[x].fa,z=tree[y].fa,l,r;
    l=(tree[y].ch[1]==x);r=l^1;
    if (!is_root(y))    tree[z].ch[tree[z].ch[1]==y]=x;
    tree[y].fa=x;tree[x].fa=z;tree[tree[x].ch[r]].fa=y;
    tree[y].ch[l]=tree[x].ch[r];tree[x].ch[r]=y;
}
void Splay(int x)
{
    sta[++top]=x;
    for (int i=x;!is_root(i);i=tree[i].fa)  sta[++top]=tree[i].fa;
    while (top) push_down(sta[top--]);
    while (!is_root(x))
    {
        int y=tree[x].fa,z=tree[y].fa;
        if (!is_root(y))
        {
            if ((tree[y].ch[0]==x)^(tree[z].ch[0]==y))  rot(x);
            else    rot(y);
        }
        rot(x);
    }
}
void access(int x)
{
    for (int i=0;x;i=x,x=tree[x].fa)    Splay(x),tree[x].ch[1]=i;
}
void make_root(int x)
{
    access(x);Splay(x);//tree[x].rev^=1;
}
void link(int x,int y)
{
    tree[x].fa=y;make_root(y);modify(y,tree[x].w);
}
void cut(int x)
{
    make_root(x);modify(tree[x].ch[0],-tree[x].w);tree[tree[x].ch[0]].fa=0;tree[x].ch[0]=0;
}
struct sam
{
    int cnt,last,p,q,np,nq;
    int a[MAXN][26],len[MAXN],fa[MAXN];
    sam()
    {
        last=++cnt;
    }
    void insert(int c)
    {
        p=last;last=np=++cnt;len[np]=len[p]+1;tree[np].w=1;
        while (!a[p][c]&&p) a[p][c]=np,p=fa[p];
        if (!p) fa[np]=1,link(np,1);
        else
        {
            q=a[p][c];
            if (len[q]==len[p]+1)   fa[np]=q,link(np,q);
            else
            {
                nq=++cnt;len[nq]=len[p]+1;
                memcpy(a[nq],a[q],sizeof(a[q]));
                fa[nq]=fa[q];link(nq,fa[q]);
                fa[q]=fa[np]=nq;cut(q);link(q,nq);link(np,nq);
                while (a[p][c]==q)  a[p][c]=nq,p=fa[p];
            }
        }
    }
    int getans()
    {
        gets(mask);
        int st=1,Len=chars.length();
        for (int i=0;i<Len;i++)
            if (!(st=a[st][chars[i]-'A']))  return 0;
        Splay(st);
        return tree[st].w;
    }
}sam;
int main()
{
    scanf("%d",&Q);scanf("%s",ch);
    int len=strlen(ch);
    for (int i=0;i<len;i++) sam.insert(ch[i]-'A');
    while (Q--)
    {
        scanf("%s",ch);
        if (ch[0]=='A')
        {
            gets(mask);
            len=chars.length();
            for (int i=0;i<len;i++) sam.insert(chars[i]-'A');
        }
        else
        {
            ans=sam.getans();mask^=ans;
            printf("%d\n",ans);
        }
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【Cactus仙人掌图】仙人掌基础知识学习笔记
首先膜一下vfk领先全球的动态仙人掌栽培技术… 
然后谢谢Time-Machine学长在暑假集训时候讲了仙人掌DP. 
然后感觉听得并不是很懂…所以再来对着论文学一遍顺便写一写例题代码 
这一篇主要先学仙人掌的基础(定义和性质什么的)
————————————线 割 分 是 我 >w<———————————————– 
什么是仙人掌? 
仙人掌是不含自环的,一条边最多属于一个简单环的无向连通图. 
从定义不难看出树其实也是仙人掌的一种,也就是说这几个概念的关系大概是: 
树是一种特殊的仙人掌,仙人掌是一类特殊的无向连通图. 
从图片来观察一下. 
 
这也是个仙人掌↓ 
 
那么我们现在就知道怎样来区分仙人掌和非仙人掌了
对于树我们都很熟悉,那么能不能想办法把仙人掌看成一棵树呢? 
办法是有的.仙人掌上最讨厌的就是环.但是我们注意到仙人掌上不可能存在环与其他环有重边,这就好办了,我们可以把环看成类似树上的节点的东西,只是这个节点包含了更大的信息量.(注意只是类似,和真正树上的节点是不一样的!)
仿照树相关的定义,我们可以对仙人掌定义仙人掌上的节点的父亲和环的父亲. 
对于仙人掌上的节点,它的父亲是可能存在多种可能的.如果它到根的路径上与它相邻的是一条简单路径而不是环,那么这个节点的父亲和平常树上节点的父亲是没什么区别的, 它的父亲是它到根的简单路径上经历的第二个点.那么如果它到根节点路径上与它相邻的是个环,则将其到根的路径上经历的第一条边所在的环当做其父亲. 
对于环,我们将它的父亲定义为一个环上离根最近的点. 
相对的那么就出现了儿子关系了. 
对于仙人掌上的节点,它的儿子显然可以是环可以是普通节点. 
但是对于环的儿子,则是环上除掉这个环的父亲以外的其他所有节点.
区别于普通树,对仙人掌而言环上的节点除了父亲之外还存在父亲节点和母亲节点(为什么要起这种名字好容易搞混啊…) 
环上节点的父亲节点和母亲节点指这个点在环上相邻的那两个点. 
(一定不要搞混啦>_<)
怎样进行仙人掌的遍历和节点信息的确定呢? 
依然是从根节点开始DFS. 
如果我们将要访问一个节点,而这个节点之前还没有被访问过,那么我们直接把这个节点的父亲设为当前节点就行了.(从环和节点的父亲的定义上看这样显然没问题) 
那么如果我们将要访问的那个节点已经被访问过了呢?显然这时候出现了环. 
那么就有两种情况: 
现在我们假设我们正在访问的节点为x,将要访问的那个节点为y 
那么如果x的第一次被访问时间比y早,那么这证明y所在的环已经被我们访问过了,就不需要再单独对y处理什么. 
如果x的第一次被访问时间比y晚,则说明x在一个以y为父亲的环上,此时再遍历整个环标记一下父亲节点母亲节点. 
至此,整个仙人掌遍历完成,同时仙人掌上所有节点的父子父母信息都已经处理了出来.

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5400(Arithmetic Sequence-暴力找区间)

Arithmetic Sequence
Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 937    Accepted Submission(s): 411


Problem Description
A sequence b1,b2,⋯,bn
 are called (d1,d2)-arithmetic
 sequence if and only if there exist i(1≤i≤n)
 such that for every j(1≤j<i),bj+1=bj+d1
 and for every j(i≤j<n),bj+1=bj+d2.

Teacher Mai has a sequence a1,a2,⋯,an.
 He wants to know how many intervals [l,r](1≤l≤r≤n)
 there are that al,al+1,⋯,ar
 are (d1,d2)-arithmetic
 sequence.

 

Input
There are multiple test cases.

For each test case, the first line contains three numbers 
n,d1,d2(1≤n≤105,|d1|,|d2|≤1000),
 the next line contains n
 integers a1,a2,⋯,an(|ai|≤109).

 

Output
For each test case, print the answer.

 

Sample Input

5 2 -2
0 2 0 -2 0
5 2 3
2 3 3 3 3

 

Sample Output

12
5

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9

 

Recommend
wange2014   |   We have carefully selected several similar problems for you:  5421 5420 5419 5418 5417 
 


暴力找区间








#include<bits/stdc++.h> 
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i>=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define Forpiter(x) for(int &p=iter[x];p;p=next[p])  
#define Lson (x<<1)
#define Rson ((x<<1)+1)
#define MEM(a) memset(a,0,sizeof(a));
#define MEMI(a) memset(a,127,sizeof(a));
#define MEMi(a) memset(a,128,sizeof(a));
#define INF (2139062143)
#define F (100000007)
#define MAXN (1000000+10)
typedef long long ll;
ll mul(ll a,ll b){return (a*b)%F;}
ll add(ll a,ll b){return (a+b)%F;}
ll sub(ll a,ll b){return (a-b+llabs(a-b)/F*F+F)%F;}
void upd(ll &a,ll b){a=(a%F+b%F)%F;}
int n;
ll d1,d2,a[MAXN],b[MAXN];
 
int main()
{
//	freopen("E.in","r",stdin);
	
	while(cin>>n>>d1>>d2)
	{
		For(i,n) scanf("%lld",&a[i]);
		
		For(i,n-1) b[i]=a[i+1]-a[i];
	//	For(i,n-1) cout<<b[i]<<' ';cout<<endl;
	
		if (d1==d2)
		{
			ll sz=1,ans=0;
			Fork(i,2,n) if (a[i]-a[i-1]==d1) sz++; else ans+=sz*(sz+1)/2,sz=1;
			if (sz) ans+=sz*(sz+1)/2;
			cout<<ans<<endl; 
		} else {
			ll sz=1,ans=0; bool flag=0;
			Fork(i,2,n)
			{
				if (!flag)
				{
					if (a[i]-a[i-1]==d1) sz++;
					else if (a[i]-a[i-1]==d2) sz++,flag=1;
					else ans+=sz*(sz+1)/2,sz=1,flag=0;
				}
				else
				{
					if (a[i]-a[i-1]==d2) sz++;
					else if (a[i]-a[i-1]==d1) ans+=sz*(sz+1)/2-1,sz=2,flag=0;
					else ans+=sz*(sz+1)/2,sz=1,flag=0;
				}
			}if (sz) ans+=sz*(sz+1)/2;
			cout<<ans<<endl; 
			
		} 
		
	
	}
	
		
	return 0;
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

最小树形图 之 朱刘算法【模板】
定义：一个有向图，存在从某个点为根的，可以到达所有点的一个最小生成树，则它就是最小树形图。




朱刘算法实现过程： 【在选出入边集后（看步骤1），若有向图中不存在有向环，说明该图就是最小树形图】


1，选入边集——找到除root点之外，每一个点的所有入边中权值最小的，用数组in[]记录下这个最小权值，用pre[]记录到达该点的前驱；（若图中存在独立点，最小树形图是不存在的，所以在该步骤结束后，要判断一下）
2，找有向环，并用数组id[]记录节点所属环的编号。
3，找到环后，缩点，并更新权值。（感觉和SCC缩点差不多吧）
4，以环数为下一次查找的点数，继续执行上述操作，直到没有环 或者 判定出不存在最小树形图为止。




给个图：








详看代码，有详细注释：点的编号是从0开始的



/*
最小树形图
朱刘算法模板
时间复杂度O(nm)
数据为int型
*/
#include <cstdio>
#include <cstring>
#include <algorithm>
#define MAXN 1010
#define MAXM 1000000+10
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cost;
};
Edge edge[MAXM];
int pre[MAXN];//存储父节点
int vis[MAXN];//标记作用
int id[MAXN];//id[i]记录节点i所在环的编号
int in[MAXN];//in[i]记录i入边中最小的权值
int zhuliu(int root, int n, int m, Edge *edge)//root根 n点数 m边数
{
    int res = 0, u, v;
    while(1)
    {
        for(int i = 0; i < n; i++)
            in[i] = INF;//初始化
        for(int i = 0; i < m; i++)
        {
            Edge E = edge[i];
            if(E.from != E.to && E.cost < in[E.to])
            {
                pre[E.to] = E.from;//记录前驱
                in[E.to] = E.cost;//更新
            }
        }
        for(int i = 0; i < n; i++)
            if(i != root && in[i] == INF)
                return -1;//有其他孤立点 则不存在最小树形图
        //找有向环
        int tn = 0;//记录当前查找中 环的总数
        memset(id, -1, sizeof(id));
        memset(vis, -1, sizeof(vis));
        in[root] = 0;//根
        for(int i = 0; i < n; i++)
        {
            res += in[i];//累加
            v = i;
            //找图中的有向环 三种情况会终止while循环
            //1,直到出现带有同样标记的点说明成环
            //2,节点已经属于其他环
            //3,遍历到根
            while(vis[v] != i && id[v] == -1 && v != root)
            {
                vis[v] = i;//标记
                v = pre[v];//一直向上找
            }
            //因为找到某节点属于其他环  或者 遍历到根  说明当前没有找到有向环
            if(v != root && id[v] == -1)//必须上述查找已经找到有向环
            {
                for(int u = pre[v]; u != v; u = pre[u])
                    id[u] = tn;//记录节点所属的 环编号
                id[v] = tn++;//记录节点所属的 环编号  环编号累加
            }
        }
        if(tn == 0) break;//不存在有向环
        //可能存在独立点
        for(int i = 0; i < n; i++)
            if(id[i] == -1)
                id[i] = tn++;//环数累加
        //对有向环缩点  和SCC缩点很像吧
        for(int i = 0; i < m; i++)
        {
            v = edge[i].to;
            edge[i].from = id[edge[i].from];
            edge[i].to = id[edge[i].to];
            //<u, v>有向边 
            //两点不在同一个环 u到v的距离为 边权cost - in[v]
            if(edge[i].from != edge[i].to)
                edge[i].cost -= in[v];//更新边权值 继续下一条边的判定
        }
        n = tn;//以环总数为下次操作的点数 继续执行上述操作 直到没有环
        root = id[root];
    }
    return res;
}
int main()
{
    int N, M;//N个点 M条有向边
    while(scanf("%d%d", &N, &M) != EOF)
    {
        getMap();//建图  注意去除自环  自己到自己的权值为无穷大
        int ans = zhuliu(0, N, M, edge);
        if(ans == -1)
            printf("-1\n");//不存在
        else
            printf("%d\n", ans);
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

java多线程（一）Race Condition现象及产生的原因
转载请注明出处http://blog.csdn.net/xingjiarong/article/details/47603813 
什么是Race Condition
首先，什么是Race Condition呢，Race Condition中文翻译是竞争条件，是指多个进程或者线程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关的现象。换句话说，就是线程或进程之间访问数据的先后顺序决定了数据修改的结果，这种现象在多线程编程中是经常见到的。
Race Condition 实例
class MyThread implements Runnable {
    /**
     * 计算类型，1表示减法，其他的表示加法
     */
    private int type;

    public MyThread(int type) {
        this.type = type;
    }

    public void run() {
        if (type == 1)
            for (int i = 0; i < 10000; i++)
                Test.num--;
        else
            for (int i = 0; i < 10000; i++)
                Test.num++;
    }
}

public class Test {

    public static int num = 1000000;

    public static void main(String[] args) {

        Thread a = new Thread(new MyThread(1));
        Thread b = new Thread(new MyThread(2));

        a.start();
        b.start();

        /*
         * 主线程等待子线程完成，然后再打印数值
         */
        try {
            a.join();
            b.join();
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(num);
    }

}

上边的程序非常简单。就是用两个线程同时操作和修改同一个数据，一个线程希望把num加10000，另一个线程希望把num减小10000，根据我们的计算，一个数加上10000，再减去10000，相当于没有变化，所以结果应该等于他自身。但是这只是我们的想象，事实真的是这样吗？大家可以运行一下上边的程序，你会吃惊的发现，结果并不是1000000，再多运行几次，是不是每次的结果都不一样。 
没错，这就是产生了Race Condition，有两个线程，同时操作num这个变量，并且操作的结果与访问的顺序有关（这个不是我们控制的，而是由操作系统控制的,我们只能看到每次的结果都不一样）。
Race Condition 产生的原因
现在我们已经看到了Race Condition现象了，那么它是怎么产生的呢？先不要急切的说，你不是说了吗，是由于访问顺序不同造成的。我想说，学习新知识一定要追根溯源，要真正的弄明白，那么在硬件或者操作系统层面上，这一现象发生的原因是什么呢？
首先，我们来看一张图。

我们知道，在操作系统中，操作系统程序为每个线程分配了单独的寄存器和程序计数器。在上边的图中，我一共分成了三列，其中第一列表示线程一的操作过程，第二列表示线程二的操作过程，第三列表示内存中的结果。图中前两列的写着数字的小方框表示该线程所使用的寄存器，数字表示该寄存器中的值。第三列的小方框表示内存中的 一个存储单元，数值表示内存中存储的数值。
现在，我们来看一下操作的过程。(这里是简化了的示意过程，真正的过程要复杂的多)开始时，数据都是放在内存中的，所以通过LOAD指令，将num加载到寄存器中，接着执行相应的操作指令，这里分别为ADD（加1） SUB（减1）指令，指令执行结束后，结果是存储在相应的寄存器中的，这时内存中的数值还没有发生变化。最后执行STORE指令之后，寄存器中的数值被存储到内存中。
小方框从上到下的顺序表示线程1和线程2交替执行的过程。首先，线程1读取了内存中num的值，然后换到线程2执行，先读取了内存中num的数值，然后执行减1操作，最后将结果写回内存中，这时内存中的数据变成了999999，但是这一个变化线程1是看不到的，因为这一变化发生在线程1读取num的值之后。其实这时线程1读取到的数据已经是不正确的数据了，这是产生Race Condition的根本原因。然后线程1接着执行未执行完的指令，加1操作，最后将1000001写会内存，这是产生Race Condition的直接原因，它将线程2的结果给覆盖掉了。
这就是Race Condition产生的原因，大家是不是真正的明白了呢？。
当然Race Condition这种现象是不好的，所以我们会通过各种途径来避免产生Race Condition。在接下来的博客里，我会为大家介绍如果在java的多线程编程中避免出现Race Condition 以及多线程的同步和互斥的内容，希望与大家一起学习一起进步，请大家继续关注我的博客，如果大家支持我的话，就顶我一下吧。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处，查看原文章，请访问：http://blog.csdn.net/xingjiarong

【SHOI2008】【BZOJ1023】cactus仙人掌图
Description
如果某个无向连通图的任意一条边至多只出现在一条简单回路（simple cycle）里，我们就称这张图为仙人图（cactus）。所谓简单回路就是指在图上不重复经过任何一个顶点的回路。 

举例来说，上面的第一个例子是一张仙人图，而第二个不是——注意到它有三条简单回路：（4，3，2，1，6，5，4）、（7，8，9，10，2，3，7）以及（4，3，7，8，9，10，2，1，6，5，4），而（2，3）同时出现在前两个的简单回路里。另外，第三张图也不是仙人图，因为它并不是连通图。显然，仙人图上的每条边，或者是这张仙人图的桥（bridge），或者在且仅在一个简单回路里，两者必居其一。定义在图上两点之间的距离为这两点之间最短路径的距离。定义一个图的直径为这张图相距最远的两个点的距离。现在我们假定仙人图的每条边的权值都是1，你的任务是求出给定的仙人图的直径。
Input
输入的第一行包括两个整数n和m（1≤n≤50000以及0≤m≤10000）。其中n代表顶点个数，我们约定图中的顶点将从1到n编号。接下来一共有m行。代表m条路径。每行的开始有一个整数k（2≤k≤1000），代表在这条路径上的顶点个数。接下来是k个1到n之间的整数，分别对应了一个顶点，相邻的顶点表示存在一条连接这两个顶点的边。一条路径上可能通过一个顶点好几次，比如对于第一个样例，第一条路径从3经过8，又从8返回到了3，但是我们保证所有的边都会出现在某条路径上，而且不会重复出现在两条路径上，或者在一条路径上出现两次。
Output
只需输出一个数，这个数表示仙人图的直径长度。
Sample Input
15 3
9 1 2 3 4 5 6 7 8 3
7 2 9 10 11 12 13 10
5 2 14 9 15 10  8
10 1
10 1 2 3 4 5 6 7 8 9 10 
Sample Output
9 
HINT
对第一个样例的说明：如图，6号点和12号点的最短路径长度为8，所以这张图的直径为8。

【注意】使用Pascal语言的选手请注意：你的程序在处理大数据的时候可能会出现栈溢出。如果需要调整栈空间的大小，可以在程序的开头填加一句：{$M 5000000}，其中5000000即指代栈空间的大小，请根据自己的程序选择适当的数值。
做法我在那个仙人掌DP的学习笔记里写了 
记得要拆环成两倍长度序列所以数组要开大一倍
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define MAXN 50010
using namespace std;
int n,m,top;
int ans;
int k,u,v;
int Top;
int deep[MAXN<<1],dfn[MAXN<<1],fa[MAXN<<1],minn[MAXN<<1];
int f[MAXN<<1],a[MAXN<<1];
int que[MAXN<<1],head,tail;//维护一个单调队列 
struct edge
{
    int to;
    edge *next;
}e[MAXN<<2],*prev[MAXN];
inline void insert(int u,int v)
{
    e[++top].to=v;e[top].next=prev[u];prev[u]=&e[top];
}
inline void in(int &x)
{
    char ch=getchar();x=0;int flag=1;
    while (!(ch>='0'&&ch<='9')) flag=ch=='-'?-1:1,ch=getchar();
    while (ch>='0'&&ch<='9')    x=x*10+ch-'0',ch=getchar();x*=flag;
}
inline void dp(int root,int x)
{
    int tot=deep[x]-deep[root]+1,temp=tot;
    for (int i=x;i!=root;i=fa[i])   a[temp--]=f[i];
    a[temp]=f[root];
    for (int i=1;i<=tot;i++)    a[i+tot]=a[i];//把环拆开 
    que[1]=1;head=tail=1;//head,tail分别对应区间端点 
    for (int i=2;i<=2*tot;i++)
    {
        while (head<=tail&&i-que[head]>tot/2)   head++;
        ans=max(ans,a[i]+i+a[que[head]]-que[head]);
        while (head<=tail&&a[que[tail]]-que[tail]<=a[i]-i)  tail--;
        que[++tail]=i;
    }
    for (int i=2;i<=tot;i++)
        f[root]=max(f[root],a[i]+min(i-1,tot-i+1));
}
inline void dfs(int x)
{
    dfn[x]=minn[x]=++Top;
    for (edge *i=prev[x];i;i=i->next)
    {
        if (i->to==fa[x])   continue;
        if (!dfn[i->to])//没有访问过 
        {
            fa[i->to]=x;deep[i->to]=deep[x]+1;
            dfs(i->to);
            minn[x]=min(minn[x],minn[i->to]);
        }   
        else    minn[x]=min(minn[x],dfn[i->to]);
        if (dfn[x]<minn[i->to])
        {
            ans=max(ans,f[x]+f[i->to]+1);
            f[x]=max(f[x],f[i->to]+1);
        }
    }
    for (edge *i=prev[x];i;i=i->next)
        if (fa[i->to]!=x&&dfn[x]<dfn[i->to])    dp(x,i->to);
}
int main()
{
    in(n);in(m);
    for (int i=1;i<=m;i++)
    {
        in(k);in(u);
        for (int j=2;j<=k;j++)  in(v),insert(u,v),insert(v,u),u=v;
    }
    dfs(1);
    printf("%d\n",ans);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【HAOI2011】【BZOJ2299】向量
Description
给你一对数a,b，你可以任意使用(a,b), (a,-b), (-a,b), (-a,-b), (b,a), (b,-a), (-b,a), (-b,-a)这些向量，问你能不能拼出另一个向量(x,y)。
说明：这里的拼就是使得你选出的向量之和为(x,y)
Input
第一行数组组数t，(t<=50000)
接下来t行每行四个整数a,b,x,y  (-2*109<=a,b,x,y<=2*109)
Output
t行每行为Y或者为N，分别表示可以拼出来，不能拼出来
Sample Input
3
2 1 3 3
1 1 0 1
1 0 -2 3
Sample Output
Y
N
Y
HINT
样例解释：
第一组：(2,1)+(1,2)=(3,3)
第三组：(-1,0)+(-1,0)+(0,1)+(0,1)+(0,1)=(-2,3)
一眼题. 
一开始会想到和同余有关或者是高斯消元 
后来发现高斯消元不靠谱果然同余是对的. 
可以发现能做的选择可以拼凑出的向量只有那么有限的几种. 
有可能一个不用,有可能用几种拼凑一下. 
但是发现 
(x+a,y+b),(x+b,y+a)这样的似乎只会用一次?(不会证明但是好像挺对的) 
使用贝祖定理进行验证用或者不用.
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define LL long long
using namespace std;
int T;
LL a,b,x,y;
LL d;
void in(LL &x)
{
    char ch=getchar();x=0;int flag=1;
    while (!(ch>='0'&&ch<='9')) flag=ch=='-'?-1:1,ch=getchar();
    while (ch>='0'&&ch<='9')    x=x*10+ch-'0',ch=getchar();x*=flag;
}
LL gcd(LL a,LL b)
{
    return !b?a:gcd(b,a%b);
}
bool check(LL x,LL y)
{
    return x%d==0&&y%d==0;
}
int main()
{
    scanf("%d",&T);
    while (T--)
    {
        in(a);in(b);in(x);in(y);
        d=gcd(2*a,2*b);
        if (check(x,y)||check(x+a,y+b)||check(x+b,y+a)||check(x+a+b,y+a+b)) puts("Y");
        else    puts("N");
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

struts2学习笔记——03
使用paramsPrepareParamsStack拦截器站后的运行流程
  1)paramsPrepareParamsStack和defaultStack一样都是拦截器栈，而struts-default包默认使用的是defaultStack
  2)可以在struts配置文件中通过以下方式修改使用的默认拦截器栈
  <default-interceptor-ref name="paramsPrepaareParamsStack"></default-interceptor-ref>
  3）paramsPrepareParamsStack拦截器在于 ： params--》modelDriven-》params
 所以先把请求的参数赋值给action对应的属性，在根据赋给action的那个属性值决定压倒之战栈顶的对象，之后再为栈顶对象的属性赋值。

对于edit操作而言：
1：先为employeeAction的employeeID赋值
2：根据employee从数据库中加载对应的对象，并放入到值站的栈顶
3：在为栈顶对象的employee赋值
4：吧栈顶对象的属性回显在表单中


关于回显：struts表单标签会从值站中获取对象的属性值进行回显。
Struts2类型转换：
http没有类型的概念，每一项表单输入只可能是字符串或字符串数组


ActionContext.getContext().getValueStack.push(object)把当前对象放入栈顶
struts2表单标签的name值可以被复位属性的属性：name=mgr.name ,name=mgr.age;
全局的类型转换器可以正常工作！
国际化的目标
1）如何配置国际化资源文件

资源文件加载的顺序如何那？离当前action较近的将被优先加载


2）如何在页面上和action中访问国际化资源文件的value值
 1.在action类中，若action实现了textProvider接口，则可以调用getText()方法获取value值
    通过继承actionSupport的方式
2.页面上可以使用s:text标签，对应表单标签可以使用表单标签的key属性值
  若有占位符，则可以使用s:text标签的s:param标签来填充占位符
 若当前页面来自于action则可以直接访问action中的属性值
可以利用标签和ognl表达式直接访问值站中的属性值对象站和map站








3）实现通过超链接切换语言。



关键在于知道struts框架是如何确定local对象




通过阅读I18N拦截器











声明时验证：
































版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5399(Too Simple-判定映射)

Too Simple
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 1035    Accepted Submission(s): 353


Problem Description
Rhason Cheung had a simple problem, and asked Teacher Mai for help. But Teacher Mai thought this problem was too simple, sometimes naive. So she ask you for help.

Teacher Mai has m
 functions f1,f2,⋯,fm:{1,2,⋯,n}→{1,2,⋯,n}(that
 means for all x∈{1,2,⋯,n},f(x)∈{1,2,⋯,n}).
 But Rhason only knows some of these functions, and others are unknown.

She wants to know how many different function series 
f1,f2,⋯,fm
 there are that for every i(1≤i≤n),f1(f2(⋯fm(i)))=i.
 Two function series f1,f2,⋯,fm
 and g1,g2,⋯,gm
 are considered different if and only if there exist 
i(1≤i≤m),j(1≤j≤n),fi(j)≠gi(j).

 

Input
For each test case, the first lines contains two numbers
n,m(1≤n,m≤100).

The following are m
 lines. In i-th
 line, there is one number −1
 or n
 space-separated numbers.

If there is only one number −1,
 the function fi
 is unknown. Otherwise the j-th
 number in the i-th
 line means fi(j).

 

Output
For each test case print the answer modulo 
109+7.

 

Sample Input

3 3
1 2 3
-1
3 2 1

 

Sample Output

1
HintThe order in the function series is determined. What she can do is to assign the values to the unknown functions. 

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9

 

Recommend
wange2014   |   We have carefully selected several similar problems for you:  5421 5420 5419 5418 5417 
 


已知函数有一个不是双射，必定无解
若所有函数均已知，直接判断
否则，只要有一个 -1, 那么必能构造出解
有k个-1，前k-1个随便排 ，最后那个就能推出 ans=(n!)^(k-1)






#include<bits/stdc++.h> 
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i>=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define Forpiter(x) for(int &p=iter[x];p;p=next[p])  
#define Lson (x<<1)
#define Rson ((x<<1)+1)
#define MEM(a) memset(a,0,sizeof(a));
#define MEMI(a) memset(a,127,sizeof(a));
#define MEMi(a) memset(a,128,sizeof(a));
#define INF (2139062143)
#define F (1000000007)
#define MAXN (100+10)

typedef long long ll;
ll mul(ll a,ll b){return (a*b)%F;}
ll add(ll a,ll b){return (a+b)%F;}
ll sub(ll a,ll b){return (a-b+llabs(a-b)/F*F+F)%F;}
void upd(ll &a,ll b){a=(a%F+b%F)%F;}
int n,m;
bool b[MAXN];
int f[MAXN][MAXN];
int g[MAXN];
int main()
{
//	freopen("D.in","r",stdin);
	
	while(cin>>n>>m) {
		int cnt=0; bool flag=0;
		For(i,m)
		{
			MEM(b)
			int p;
			scanf("%d",&p);
			if (p==-1) { ++cnt;continue;}
			else f[i][1]=p;
			b[p]=1;
			Fork(j,2,n) {
				scanf("%d",&p);f[i][j]=p;
				if (!b[p]) b[p]=1; else flag=1;
			}
		}
		
		if (flag) {
			puts("0");continue;
		}	
		
		if (!cnt) {
			For(i,n) g[i]=i;
			ForD(i,m) 
				For(j,n) g[j]=f[i][g[j]];
			bool flag=0;
			For(i,n) if (g[i]^i) flag=1;
			if (flag) puts("0");else puts("1");
			continue;
		}
		
		if (cnt==1)
		{
			puts("1");
			continue;
		}
		
		ll ans=1,p2=1;
		For(i,n) p2=mul(p2,i);
		For(i,cnt-1) ans=mul(p2,ans);
		cout<<ans<<endl;
		
		
	}	
	
	return 0;
}











版权声明：本文为博主原创文章，未经博主允许不得转载。

java多线程（六）深入理解volitale关键字
转载请注明出处：http://blog.csdn.net/xingjiarong/article/details/47945849 
我们继续来讨论java的多线程编程，今天我们一起来学习一下java多线程中的另一个关键字——volitale。
一、java内存模型与多线程编程中的三个感念
1、原子性
原子性是指一些操作或者全都执行，要么或者全都不执行，整个操作作为一个整体是不可分割的，例如，一个银行中有两个账户A，B，现在要从A账户中转账500元到B账户，那么一共可以分为两个步骤： 
1、从A账户取出500元：A = A - 500； 
2、向B账户存入500元：B = B + 500； 
这两个步骤作为一个整体，要么全部执行要么全部都不执行，如果只执行步骤一，那么A账户就会莫名其妙的丢失500元，B账户却什么都没有收到。
在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。
例如：
i = 3;
i = i+3;
i++;
i = j;
这四条语句只有第一条语句是原子的，是基本的赋值操作。其他的三条语句，看似是赋值的原子操作，实际上却是由多个步骤构成的。比如i++这条语句是由i，i+1,i=i+1这三条语句构成的，每一个语句都是原子的，但是合起来就不是原子的了。
2、可见性
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。例如：
//线程1
i = 10;
i = i+3;


//线程2
j=i;
在java中每个线程都有自己的线程栈，当一个线程执行需要数据时，会到内存中将需要的数据复制到自己的线程栈中，然后对线程栈中的副本进行操作，再操作完成后再将数据写回到内存中。
例如：线程1将i的值读到自己的线程栈中，然后对i进行了加3操作，但是这一操作并没有被及时的写回到内存中，所以线程2在执行时看到的i的值仍然是3，这就是可见性的问题。
java提供的volitale关键字可以保证数据的可见性。
3、有序性
有序性：即程序执行的顺序按照代码的先后顺序执行。我们写代码会有一个先后的顺序，但是那仅仅是我们看到的顺序，但是当编译器编译时会进行指令重排，于是代码的执行顺序有可能和我们想的不一样。例如：
int i = 0;              
boolean flag = false; //语句3
i = 1;                //语句1  
flag = true;          //语句2
语句1和语句2的执行顺序改变一下对程序的结果并没有什么影响，所以这时可能会改变这两条指令的顺序。那么语句2会不会在语句3之前执行呢，答案是不会呢，因为语句2用到了语句3声明的变量，这时编译器会限制语句的执行顺序来保证程序的正确性。
在单线程中，改变指令的顺序可能不会产生不良后果，但是在多线程中就不一定了。例如：
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
由于语句1和语句2没有数据依赖性，所以编译器可能会将两条指令重新排序，如果先执行语句2，这时线程1被阻塞，然后线程2的while循环条件不满足，接着往下执行，但是由于context没有赋值，于是会产生错误。
二、volitale关键字的作用
volitale关键字保证了可见性和一定程度上的有序性，但是不能保证原子性。
1、volitale关键字保证可见性
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
　　2）禁止进行指令重排序。
　　先看一段代码，假如线程1先执行，线程2后执行：
//线程1
boolean stop = false;
while(!stop){
    doSomething();
}

//线程2
stop = true;
　　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。
　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。
　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。
　　但是用volatile修饰之后就变得不一样了：
　　第一：使用volatile关键字会强制将修改的值立即写入主存；
　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效；
　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。
　　那么线程1读取到的就是最新的正确的值。
2、volitale关键字不能保证原子性
从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？
　　下面看一个例子： 
　　
public class Test {
    public volatile int inc = 0;

    public void increase() {
        inc++;
    }

    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }

        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。
　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。
　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。
　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：
　　假如某个时刻变量inc的值为10，
　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；
　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。
　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。
　　那么两个线程分别进行了一次自增操作后，inc只增加了1。
　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。
　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。
3、volitale关键字在一定程度上保证有序性
在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。
　　volatile关键字禁止指令重排序有两层意思：
　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
　　可能上面说的比较绕，举个简单的例子：
//x、y为非volatile变量
//flag为volatile变量

x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
　　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。
　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。
　　那么我们回到前面举的一个例子：
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
　　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。
　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。
参考：http://www.cnblogs.com/dolphin0520/p/3920373.html

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处，查看原文章，请访问：http://blog.csdn.net/xingjiarong

【LeetCode-面试算法经典-Java实现】【202-Happy Number（开心数字）】
【202-Happy Number（开心数字）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Write an algorithm to determine if a number is “happy”. 
　　A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. 
　　Example: 19 is a happy number
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

题目大意
　　对任意一个正整数，不断求个数位上数字的平方和，若最终收敛为1，则该数字为happy number，否则程序可能从某个数开始陷入循环。 

解题思路
　　对这个数字的每个数位求平方和，如果如和为1或者平方和是之前出现过的就不进行求和，根据最后的结果判断是不是一个开心数字。 

代码实现
算法实现类
mport java.util.HashSet;

public class Solution {
    public boolean isHappy(int n) {
        if (n < 1) {
            return false;
        }

        // 用于保存中间出现的结果
        HashSet<Integer> set = new HashSet<>(32);

        int tmp;
        int newN;

        // n不为1，并且n的值不能重复出现，否则会死循环
        while (n != 1 && !set.contains(n)) {
            set.add(n);
            newN = 0;
            while (n > 0) {
                tmp = n % 10;
                n /= 10;
                newN += tmp * tmp;
            }

            n = newN;
        }

        return n == 1;
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47997637】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

java多线程（五）synchronized关键字修饰代码块
转载请注明出处：http://blog.csdn.net/xingjiarong/article/details/47916703 
在上一篇博客中我们介绍了synchronized关键字修饰方法的用法，我们接着介绍synchronized关键字。除了修饰方法之外，还可以修饰代码块，一共有以下5种用法。
一、this
synchronized（this）{
    //互斥代码
}
这里的this指的是执行这段代码的对象，synchronized得到的锁就是this这个对象的锁，这种写法等价于我们上一篇博客中讨论的：
public synchronized void func（）{
    //互斥代码
}
二、A.class
synchronized（A.class）{
    //互斥代码
}
这里A.class得到的是A这类，所以synchronized关键字得到的锁是类的锁，这种方法同下面的方法功能是相同的：
public static synchronized void fun(){
    //互斥代码
}
所有需要类的锁的方法等不能同时执行，但是它和需要某个对象的锁的方法或者是不需要任何锁的方法可以同时执行。
三、object.getClass()
synchronized（object.getClass）{
    //互斥代码
}
这种方法一般情况下同第二种是相同，但是出现继承和多态时，得到的结果却是不相同的。所以一般情况下推荐使用A.class的方式。
四、object
synchronized（object）{
    //互斥代码
}
这里synchronized关键字拿到的锁是对象object的锁，所有需要这个对象的锁的方法都不能同时执行。
public class Trans {
private Object lock = new Object();

    public void printNum(int num){
        synchronized (lock) {
            System.out.print(Thread.currentThread());  
            for(int i=0;i<25;i++){  
                System.out.print(i+" ");  
            }  
            System.out.println();
        }          
    }


}

class MyThread implements Runnable {  
    private Trans trans;  
    private int num;  

    public MyThread(Trans trans, int num) {  
        this.trans = trans;  
        this.num = num;  
    }  

    public void run() {  
        while (true)  
        {  
            trans.printNum(num);  
            try {  
                Thread.sleep(500);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
        }  

    }  
}

public class Test {  


    public static void main(String[] args) {  

        Trans t = new Trans();  
        Trans t1 = new Trans();  
        Thread a = new Thread(new MyThread(t, 1));  
        Thread b = new Thread(new MyThread(t1, 2));  

        a.start();  
        b.start();  

    }  

}
在上边的例子中试图使用这种方法达到互斥方法打印方法，但是事实是这样做是没有效果的，因为每个Trans对象都有自己的Object对象，这两个对象都有自己的锁，所以两个线程需要的是不同锁，两个锁之间没有任何相互作用，所以不会起到互斥作用。
五、static object
上边的代码稍作修改就可以起到互斥作用，将Trans类中Object对象的声明改为下面这样：
private static Object lock = new Object();
这样不同的类使用的就是同一个object对象，需要的锁也是同一个锁，就可以达到互斥的效果了。
经过两篇博客的介绍，我们详细的讨论了synchronized关键字的用法，看似非常复杂，其实抓住要点之后还是很好区分的，只要看synchronized获得的是哪个对象或者类的锁就行啦，其他需要这个锁的方法都不能同时执行，不需要这个锁的方法都能同时执行。
最后还要告别一个误区，相信大家都不会再犯这种错误了，synchronized锁住的是一个对象或者类（其实也是对象），而不是方法或者代码段。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处，查看原文章，请访问：http://blog.csdn.net/xingjiarong

HDU 5402(Travelling Salesman Problem-构造矩阵对角最长不相交路径)

Travelling Salesman Problem
Time Limit: 3000/1500 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 898    Accepted Submission(s): 327
Special Judge

Problem Description
Teacher Mai is in a maze with 
n
 rows and m
 columns. There is a non-negative number in each cell. Teacher Mai wants to walk from the top left corner
(1,1)
 to the bottom right corner (n,m).
 He can choose one direction and walk to this adjacent cell. However, he can't go out of the maze, and he can't visit a cell more than once.

Teacher Mai wants to maximize the sum of numbers in his path. And you need to print this path.

 

Input
There are multiple test cases.

For each test case, the first line contains two numbers 
n,m(1≤n,m≤100,n∗m≥2).

In following n
 lines, each line contains m
 numbers. The j-th
 number in the i-th
 line means the number in the cell (i,j).
 Every number in the cell is not more than 104.

 

Output
For each test case, in the first line, you should print the maximum sum.

In the next line you should print a string consisting of "L","R","U" and "D", which represents the path you find. If you are in the cell
(x,y),
 "L" means you walk to cell (x,y−1),
 "R" means you walk to cell (x,y+1),
 "U" means you walk to cell (x−1,y),
 "D" means you walk to cell (x+1,y).

 

Sample Input

3 3
2 3 3
3 3 3
3 3 2

 

Sample Output

25
RRDLLDRR

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9

 

Recommend
wange2014   |   We have carefully selected several similar problems for you:  5421 5420 5419 5418 5417 
 




当n,m有一个奇数时，‘S形’可全取。
否则至少要少取一个，
如果少取(mx,my) ，当mx+my为偶数时，必然有一个与(mx,my)相邻的不能取
否则必能全取剩下的，（‘S形’+特判2行‘长城形’)










#include<bits/stdc++.h> 
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i>=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define Forpiter(x) for(int &p=iter[x];p;p=next[p])  
#define Lson (x<<1)
#define Rson ((x<<1)+1)
#define MEM(a) memset(a,0,sizeof(a));
#define MEMI(a) memset(a,127,sizeof(a));
#define MEMi(a) memset(a,128,sizeof(a));
#define INF (2139062143)
#define F (100000007)
#define MAXN (100+10)
typedef long long ll;
ll mul(ll a,ll b){return (a*b)%F;}
ll add(ll a,ll b){return (a+b)%F;}
ll sub(ll a,ll b){return (a-b+llabs(a-b)/F*F+F)%F;}
void upd(ll &a,ll b){a=(a%F+b%F)%F;}
int n,m;
ll a[MAXN][MAXN];
int main()
{
//	freopen("Travelling.in","r",stdin);
	
	while(cin>>n>>m) {
		ll sum=0,mi=INF;int mx,my;
		For(i,n) For(j,m) {
			scanf("%lld",&a[i][j]),sum+=a[i][j];
			if (mi>a[i][j]&&(i+j)%2==1)
				mi=min(mi,a[i][j]),mx=i,my=j;
		}
		if (n%2==0&&m%2==0)
		{
			cout<<sum-mi<<endl;	
			
			if (mx%2==1) {
				For(i,mx-1) 
				{
					if (i&1) {For(j,m-1) putchar('R');}
					else {For(j,m-1) putchar('L'); }
					if (i<n) putchar('D');
				}

				int tx=mx,ty=1;
				int p=0;
				For(j,m)
				{
					if (my==j) {if (j<m) putchar('R');continue;}
					if (p==0) printf("D");
					else printf("U");
					p^=1;
					if (j<m) putchar('R');
				}
				Fork(i,mx+2,n) 
				{
					putchar('D');
					if ((i&1)^1) {For(j,m-1) putchar('R');}
					else {For(j,m-1) putchar('L'); }
				}
			}
			
			if (my%2==1) {
				For(i,my-1) 
				{
					if (i&1) {For(j,n-1) putchar('D'); }
					else {For(j,n-1) putchar('U'); }
					if (i<m) putchar('R');
				}
			
				int tx=1,ty=my;
				int p=0;
				For(j,n)
				{
					if (mx==j) {if (j<n) putchar('D');continue;}
					if (p==0) printf("R");
					else printf("L");
					p^=1;
					if (j<n) putchar('D');
				}
				
				Fork(i,my+2,m) 
				{
					putchar('R');
					if ((i&1)^1) {For(j,n-1) putchar('D'); }
					else {For(j,n-1) putchar('U'); }
				}
			}
			
			
		} 
		else {
			cout<<sum<<endl;
			if (n%2) {
				For(i,n) 
				{
					if (i&1) {For(j,m-1) putchar('R');}
					else {For(j,m-1) putchar('L'); }
					if (i<n) putchar('D');
				}
			} else {
				For(i,m) 
				{
					if (i&1) {For(j,n-1) putchar('D'); }
					else {For(j,n-1) putchar('U'); }
					if (i<m) putchar('R');
				}
			}
		}
		cout<<endl;
	}
	
	return 0;
}













版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode-面试算法经典-Java实现】【201-Bitwise AND of Numbers Range（范围数位与结果）】
【201-Bitwise AND of Numbers Range（范围数位与结果）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. 
　　For example, given the range [5, 7], you should return 4. 

题目大意
　　 给一个范围，返回这个范围中所有的数按位相与最后的结果。 

解题思路
　　当m!=n，那么最末位必定等0，因为[m, n]必定包含奇偶数，相与最末位等0。可以将m，n都右移一位，记为mk、 nk，这样就相当于将[m, n]之间的所有的数都右移动了一位，当mk=nk的时候，说明之前[m, n]之间的数右移一位后是相等的，右移后的数作AND操作，结果还是m(=n)，所以操作就可以停止了记录右移的次数，offset，m>>offset即为所求结果 

代码实现
算法实现类
public class Solution {

    public int rangeBitwiseAnd(int m, int n) {
        int offset = 0;

        while (m != n) {
            m >>= 1;
            n >>= 1;
            offset++;
        }

        return m << offset;
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47997613】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode-面试算法经典-Java实现】【203-Remove Linked List Elements（删除单链表中的元素）】
【203-Remove Linked List Elements（删除单链表中的元素）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Remove all elements from a linked list of integers that have value val. 
　　Example 
　　Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6 
　　Return: 1 --> 2 --> 3 --> 4 --> 5 

题目大意
　　给定一值val，在单链表中删除值为val的结点。 

解题思路
　　在链表头添加一个结点，对链表进遍历和删除操作。 

代码实现
链表结点类
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
算法实现类
public class Solution {

    public ListNode removeElements(ListNode head, int val) {
        ListNode root = new ListNode(1);
        root.next = head;
        // 调于记录要处理的元素的前驱结点
        ListNode prev = root;

        // prev.next表示要处理的结点
        while (prev.next != null) {
            // 要处理的结点是要删除的结点
            if (prev.next.val == val) {
                // 对结点进行删除操作
                prev.next = prev.next.next;
            }
            // 当前处理的节点不需要删除，prev移动到下一个结点
            else {
                prev = prev.next;
            }
        }

        // 返回新的根结点
        return root.next;
    }
}

评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47997657】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

C#  json  一维数组  和  二维数组的转换
1.首先你要下载一个HttpHelper     下载地址：http://pan.baidu.com/s/1dDJd0Xz
2.Post提交方式：string json = h.PostPage(地址,参数,);
3.例子如下：
 一维数组   
解析：JObject newobj = JObject.Parse(json);


例： 
newobj["字段名"].ToString();



说明：一维数组不需要循环 直接运用就行了


二维数组
解析： JArray ja = (JArray)JsonConvert.DeserializeObject(json);


例：for (int i = 0; i < ja.Count; i++)
                {
                    local_order order = new local_order();
                    order.code = ja[i]["code"].ToString();
                    order.name = ja[i]["name"].ToString();
                    order.cellphone = ja[i]["cellphone"].ToString();
                    order.address = ja[i]["address"].ToString();
                    order.pickup_begin = ja[i]["pickup_begin"].ToString();
                    order.pickup_end = ja[i]["pickup_end"].ToString();
                    order.price_url = ja[i]["price_url"].ToString();
                    list.Add(order);
                }说明：二维数组需要循环得出




总结：大家要是有什么不明白的俩系我：QQ：703856523     邮箱：703856523@qq.com



版权声明：本文为博主原创文章，未经博主允许不得转载。

【bzoj2049】【SDOI2008】【Cave 洞穴勘测】
2049: [Sdoi2008]Cave 洞穴勘测
Time Limit: 10 Sec  Memory Limit: 259 MB 
Submit: 4803  Solved: 2137 
[Submit][Status][Discuss] 
Description
辉辉热衷于洞穴勘测。某天，他按照地图来到了一片被标记为JSZX的洞穴群地区。经过初步勘测，辉辉发现这片区域由n个洞穴（分别编号为1到n）以及若干通道组成，并且每条通道连接了恰好两个洞穴。假如两个洞穴可以通过一条或者多条通道按一定顺序连接起来，那么这两个洞穴就是连通的，按顺序连接在一起的这些通道则被称之为这两个洞穴之间的一条路径。洞穴都十分坚固无法破坏，然而通道不太稳定，时常因为外界影响而发生改变，比如，根据有关仪器的监测结果，123号洞穴和127号洞穴之间有时会出现一条通道，有时这条通道又会因为某种稀奇古怪的原因被毁。辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示：如果监测到洞穴u和洞穴v之间出现了一条通道，终端机上会显示一条指令 Connect u v 如果监测到洞穴u和洞穴v之间的通道被毁，终端机上会显示一条指令 Destroy u v 经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧”。辉辉希望能随时通过终端机发出指令 Query u v，向监测仪询问此时洞穴u和洞穴v是否连通。现在你要为他编写程序回答每一次询问。已知在第一条指令显示之前，JSZX洞穴群中没有任何通道存在。
Input
第一行为两个正整数n和m，分别表示洞穴的个数和终端机上出现过的指令的个数。以下m行，依次表示终端机上出现的各条指令。每行开头是一个表示指令种类的字符串s（”Connect”、”Destroy”或者”Query”，区分大小写），之后有两个整数u和v (1≤u, v≤n且u≠v) 分别表示两个洞穴的编号。
Output
对每个Query指令，输出洞穴u和洞穴v是否互相连通：是输出”Yes”，否则输出”No”。（不含双引号）
Sample Input
样例输入1 cave.in
200 5
Query   123 127
Connect 123 127
Query   123 127
Destroy 127 123
Query   123 127
样例输入2 cave.in
3   5
Connect 1   2
Connect 3   1
Query   2   3
Destroy 1   3
Query   2   3
Sample Output
样例输出1 cave.out
No
Yes
No
样例输出2 cave.out
Yes
No
HINT
数据说明 10%的数据满足n≤1000, m≤20000 20%的数据满足n≤2000, m≤40000 30%的数据满足n≤3000, m≤60000 40%的数据满足n≤4000, m≤80000 50%的数据满足n≤5000, m≤100000 60%的数据满足n≤6000, m≤120000 70%的数据满足n≤7000, m≤140000 80%的数据满足n≤8000, m≤160000 90%的数据满足n≤9000, m≤180000 100%的数据满足n≤10000, m≤200000 保证所有Destroy指令将摧毁的是一条存在的通道本题输入、输出规模比较大，建议c\c++选手使用scanf和printf进行I\O操作以免超时
lct模板题。
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=10010;
int n,m;
struct LCT{
    int fa[N],ch[N][2],rev[N],road[N];
    bool check_root(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
    int check_same(int x){return x==ch[fa[x]][1];}
    void pushdown(int x){
        int l=ch[x][0],r=ch[x][1];
        if(rev[x]){
            rev[x]^=1;
            rev[l]^=1;
            rev[r]^=1;
            swap(ch[x][0],ch[x][1]);
        }
    }
    void rotate(int x){
        int y=fa[x],z=fa[y],l,r;
        l=(ch[y][0]==x?0:1); r=l^1;
        if(!check_root(y)){
            if(ch[z][0]==y) ch[z][0]=x;
            else ch[z][1]=x;
        }
        fa[x]=z;fa[y]=x;fa[ch[x][r]]=y;
        ch[y][l]=ch[x][r];ch[x][r]=y;
    }
    void splay(int x){
        int i,top=0,y,z;
        road[++top]=x;
        for(i=x;!check_root(i);i=fa[i]) road[++top]=fa[i];
        for(i=top;i;--i) pushdown(road[i]);
        while(!check_root(x)){
            y=fa[x];z=fa[y];
            if(!check_root(y)){
                if(check_same(x)==check_same(y)) rotate(y);
                else rotate(x);
            }
            rotate(x);
        }
    }
    void access(int x){int y=0;while(x){splay(x);ch[x][1]=y;y=x;x=fa[x];}}
    void make_root(int x){access(x);splay(x);rev[x]^=1;}
    void link(int x,int y){make_root(x);fa[x]=y;access(x);}
    void cut(int x,int y){make_root(x);access(y);splay(y);ch[y][0]=fa[x]=0;}
    int find(int x){
        access(x); splay(x);
        while(ch[x][0]) x=ch[x][0];
        return x;
    }
}T;
char ch[10];
int main()
{
    int i,x,y;
    scanf("%d%d",&n,&m);
    while(m--){
        scanf("%*c%s%d%d",&ch,&x,&y);
        if(ch[0]=='C') T.link(x,y);
        if(ch[0]=='D') T.cut(x,y);
        if(ch[0]=='Q'){
            if(T.find(x)==T.find(y)) printf("Yes\n");
            else printf("No\n");
        }
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 1061 青蛙的约会(拓展的欧几里得)
Description
两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。
我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。

Input
输入只包括一行5个整数x，y，m，n，L，其中x≠y < 2000000000，0 < m、n < 2000000000，0 < L < 2100000000。
Output
输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行"Impossible"
Sample Input
1 2 3 4 5
Sample Output
4


由给定的关系有公式『  （x-y）+T*(m-n)=p*l  』可得出a,b,c的值然后进行exgcd和取模运算,
由于X，Y在局部全局都有结果WA了好几次。。。


#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define LL long long
#define inf 0x3f3f3f3f
using namespace std;
LL x,y;
LL exgcd(LL a,LL b)
{
    if(!b)
    {
        y=0;
        x=1;
        return a;
    }
    LL d=exgcd(b,a%b);
    LL g=x;
    x=y;
    y=g-y*(a/b);
    return d;
}
LL mod(LL a,LL b)
{
    if(a>=0)
        return a%b;
    else
        return a%b+b;
}
int main()
{
    LL n,m,k,i,j,l,a,b,d,x1,y1,c;
    while(~scanf("%lld%lld%lld%lld%lld",&x,&y,&m,&n,&l))
    {
        a=n-m;
        b=l;
        c=x-y;
        d=exgcd(a,b);
        if(c%d)
        {
            printf("Impossible\n");
            continue;
        }
        b/=d;//为了使b变小，加速运行
        x=mod(x*c/d,b);//a*x=(恒等)bmod(n)
        printf("%lld\n",x);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

【从此不怕强制在线】二进制分组学习笔记
总是遇到分治被强制在线卡真是令人不爽>_< 
那我们就用二进制分组大法来破掉他的强制在线! 
二进制分组大法是什么咧= = 
(学习自许昊然《浅谈数据结构题的几个非经典解法》) 
我们把一个数拆成2的x次幂数的和的形式 
比如: 
17=16(4)+1(0) 
18=16(4)+2(1) 
23=16(4)+4(2)+2(1)+1(0) 
于是在分治算法中我们就有了这样一种做法: 
比如有一个题他使用x^lastans这种手段来实现强制在线 
同时如果去掉强制在线的话这个题目可以分治 
(也就是所谓的满足”修改独立性质”但是没有办法分治) 
那么我们就根据他的操作数目把这些操作中的全部修改操作按二进制分组划分成logn组 
把这些修改操作加上线段树来进行维护. 
假设我们可以在线处理查询操作 
对于每个查询操作只需要对分出的那些组每组全都查询一遍. 
那么执行一个修改操作或者新增一个修改操作,会使后面所有修改操作发生变化,这会改变修改操作的数目,会使得当前分组不合理,因此我们暴力的增加出一个分组/删除一个分组. 
(其实看这些并不能看懂什么意思…我们来看看他在论文答辩里面里的样例) 
忽略半平面的部分叭! 
 
 
 
贴这些就能看懂了… 
那么根据经(yao)验(chuan) 
这东西的复杂度是O(nlog2n)O(nlog^2n)的 
Q:为什么? 
A:我不会!窝萌来看看论文! 
反正我看了之后感觉跟哔了狗一样!!!! 
 
以及关于二进制分组的扩展三进制分组和N进制分组.. 
还是省省吧= = 
原文的意思随着进制数升高,这样会让查询复杂度莫名变高 
但是修改的复杂度变低了. 
(另外为什么我最近总喜欢说哔了狗了QAQ)

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 3376 Matrix Again and hdoj 2686 Matrix 【最大费用最大流】






Matrix Again
Time Limit: 5000/2000 MS (Java/Others)    Memory Limit: 102400/102400 K (Java/Others)
Total Submission(s): 3453    Accepted Submission(s): 1017



Problem Description

Starvae very like play a number game in the n*n Matrix. A positive integer number is put in each area of the Matrix.
Every time starvae should to do is that choose a detour which from the top left point to the bottom right point and than back to the top left point with the maximal values of sum integers that area of Matrix starvae choose. But from the top to the bottom can
 only choose right and down, from the bottom to the top can only choose left and up. And starvae can not pass the same area of the Matrix except the start and end..
Do you know why call this problem as “Matrix Again”? AS it is like the problem 2686 of HDU.

 


Input

The input contains multiple test cases.
Each case first line given the integer n (2<=n<=600) 
Then n lines, each line include n positive integers. (<100)

 


Output

For each test case output the maximal values starvae can get.
 


Sample Input

2
10 3
5 10
3
10 3 3
2 5 3
6 7 10
5
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
5 6 7 8 9

 


Sample Output

28
46
80

 









无语死了，TLE到死。还好最后用G++卡过了，C++死活过不了。


两道题意一样，就是数据卡的不一样！！！
题意：给你一个N*N的矩阵，每个元素代表该处的权值。要求每个点只能走一次，左上角和右下角可以走两次但该处的权值只能获取一次。问你从左上角走到右下角（只能向下或右移动），再从右下角回到左上角（只能向上或左移动）所能得到的最大权值。


思路：把所有元素虚拟成N*N个点，把可达关系当做一条边，可走次数作为边的容量，权值当做边的费用。问题就变成了最大费用最大流。


建图：设置超级源点sink，超级汇点source
1，把所有点i拆分左点i 和 右点i + N*N，i到i+N*N建边，容量为1（只有当i为起点或者终点时容量才为2），费用为点权。
2，sink连接左上角的左点，容量为2，费用0；
3，右下角右点连接source，容量为2，费用0；
4，所有可达关系，即对于坐标(x, y) 向(x+1, y)和(x, y+1)建边（边界需要讨论），容量为1（至少1可以大于1），费用0。
最后跑一遍最大费用最大流后，减去起点权值和终点权值（我们多算了一次）就ok了。理解最小费用后求解最大费用很简单的，只需要把SPFA过程改为查找S-T的最大费用路径。


AC代码： 可以过这两个题



#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
#include <stack>
#include <algorithm>
#define MAXN 800000+10
#define MAXM 4000000+10
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cap, flow, cost, next;
};
Edge edge[MAXM];
int head[MAXN], edgenum;
int pre[MAXN], dist[MAXN];
bool vis[MAXN];
int N;
int Map[610][610];
int sink, source;
void init()
{
    edgenum = 0;
    memset(head, -1, sizeof(head));
}
void addEdge(int u, int v, int w, int c)
{
    edge[edgenum].from = u;
    edge[edgenum].to = v;
    edge[edgenum].cap = w;
    edge[edgenum].flow = 0;
    edge[edgenum].cost = c;
    edge[edgenum].next = head[u];
    head[u] = edgenum++;
    edge[edgenum].from = v;
    edge[edgenum].to = u;
    edge[edgenum].cap = 0;
    edge[edgenum].flow = 0;
    edge[edgenum].cost = -c;
    edge[edgenum].next = head[v];
    head[v] = edgenum++;
}
int point(int x, int y)
{
    return (x-1)*N + y;
}
void getMap()
{
    int k = N*N;
    sink = 0; source = 2*k+1;
    for(int i = 1; i <= N; i++)
    {
        for(int j = 1; j <= N; j++)
        {
            scanf("%d", &Map[i][j]);
            if(i == 1 && j == 1 || i == N && j == N)
                addEdge(point(i, j), point(i, j) + k, 2, Map[i][j]);//起点和终点 容量为2 费用为点权
            else
                addEdge(point(i, j), point(i, j) + k, 1, Map[i][j]);//左点连右点 容量为1 费用为点权
            if(i < N)
                addEdge(point(i, j)+k, point(i+1, j), 1, 0);//右点 连 左点 容量为1 费用0
            if(j < N)
                addEdge(point(i, j)+k, point(i, j+1), 1, 0);
        }
    }
    addEdge(sink, 1, 2, 0);//超级源点 连起点的左点 容量2 费用为0
    addEdge(point(N, N)+k, source, 2, 0);//终点的右点 连超级汇点 容量2 费用为0
}
bool SPFA(int s, int t)
{
    queue<int> Q;
    memset(dist, -INF, sizeof(dist));
    memset(vis, false, sizeof(vis));
    memset(pre, -1, sizeof(pre));
    dist[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            Edge E = edge[i];
            if(dist[E.to] < dist[u] + E.cost && E.cap > E.flow)//最大费用 且 无满流路径
            {
                dist[E.to] = dist[u] + E.cost;
                pre[E.to] = i;
                if(!vis[E.to])
                {
                    vis[E.to] = true;
                    Q.push(E.to);
                }
            }
        }
    }
    return pre[t] != -1;
}
void MCMF(int s, int t, int &cost, int &flow)
{
    cost = flow = 0;
    while(SPFA(s, t))
    {
        int Min = INF;
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            Edge E = edge[i];
            Min = min(Min, E.cap-E.flow);
        }
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost += edge[i].cost * Min;
        }
        flow += Min;
    }
}
int main()
{
    while(scanf("%d", &N) != EOF)
    {
        init();
        getMap();
        int cost, flow;
        MCMF(sink, source, cost, flow);
        cost -= Map[1][1] + Map[N][N];//多算了起点和终点的值
        printf("%d\n", cost);
    }
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

zoj 3885 The Exchange of Items 【最小费用最大流】
The Exchange of Items

Time Limit: 2 Seconds      Memory Limit: 65536 KB

Bob lives in an ancient village, where transactions are done by one item exchange with another. Bob is very clever and he knows what items will become more valuable later on. So, Bob
 has decided to do some business with villagers.
At first, Bob has N kinds of items indexed from 1 to N, and each item has Ai. There are M ways to exchanges items. For the ith
 way (Xi, Yi), Bob can exchange one Xith item to oneYith item, vice versa. Now Bob wants that his ith item has exactly Bi, and he wonders
 what the minimal times of transactions is.
Input
There are multiple test cases. 
For each test case: the first line contains two integers: N and M (1 <= N, M <= 100).
The next N lines contains two integers: Ai and Bi (1 <= Ai, Bi <= 10,000).
Following M lines contains two integers: Xi and Yi (1 <= Xi, Yi <= N).
There is one empty line between test cases.
Output
For each test case output the minimal times of transactions. If Bob could not reach his goal, output -1 instead.
Sample Input
2 1
1 2
2 1
1 2

4 2
1 3
2 1
3 2
2 3
1 2
3 4

Sample Output
1
-1


Author: FENG, Jingyi
Source: ZOJ Monthly, July 2017




题意：Bob有N种物品，已知每种物品有Ai个，现在他想换成Bi个。给出有M种交换方式<Xi，Yi>（表示Xi物品和Yi物品可以互相转换）。问你——Bob达成目标所需要的最小交换次数，若不可能达成目标输出-1。


思路：最小费用最大流。记录目标状态的总流量sum，判断流入汇点的总流量是否等于sum。若等于说明目标状态可达，输出最小费用，反之不可达，输出-1。


建图：设置超级源点sink，超级汇点source。
1，sink向所有物品建边，容量为物品的初始数目，费用为0；
2，所有物品向source建边，容量为物品的目标数目，费用为0；
3，M种转换关系建双向边，容量为INF（为了能够达到目标状态，我们可以任意选择该边的流量），费用为1。
再跑一遍最小费用最大流，若最后的最大流flow等于目标状态的总流量则输出最小费用cost，反之输出-1。




AC代码：

#include <cstdio>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <algorithm>
#define MAXN 110
#define MAXM 1000
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cap, flow, cost, next;
};
Edge edge[MAXM];
int head[MAXN], edgenum;
int pre[MAXN], dist[MAXN];
bool vis[MAXN];
int sink, source;//超级源点 超级汇点
int N, M;
int sum;//记录目标状态总流量
void init()
{
    edgenum = 0;
    memset(head, -1, sizeof(head));
}
void addEdge(int u, int v, int w, int c)
{
    Edge E1 = {u, v, w, 0, c, head[u]};
    edge[edgenum] = E1;
    head[u] = edgenum++;
    Edge E2 = {v, u, 0, 0, -c, head[v]};
    edge[edgenum] = E2;
    head[v] = edgenum++;
}
void getMap()
{
    int a, b;
    sum = 0;
    sink = 0, source = N+1;
    for(int i = 1; i <= N; i++)
    {
        scanf("%d%d", &a, &b);
        addEdge(sink, i, a, 0);//超级源点连i 容量为a 费用为0
        addEdge(i, source, b, 0);//i连超级汇点 容量为b 费用为0
        sum += b;//记录目标状态总流量
    }
    for(int i = 1; i <= M; i++)
        scanf("%d%d", &a, &b),
        addEdge(a, b, INF, 1), addEdge(b, a, INF, 1);//互建边 容量无穷大 费用1
}
bool SPFA(int s, int t)
{
    queue<int> Q;
    memset(dist, INF, sizeof(dist));
    memset(vis, false, sizeof(vis));
    memset(pre, -1, sizeof(pre));
    dist[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            Edge E = edge[i];
            if(dist[E.to] > dist[u] + E.cost && E.cap > E.flow)
            {
                dist[E.to] = dist[u] + E.cost;
                pre[E.to] = i;
                if(!vis[E.to])
                {
                    vis[E.to] = true;
                    Q.push(E.to);
                }
            }
        }
    }
    return pre[t] != -1;
}
void MCMF(int s, int t, int &cost, int &flow)
{
    cost = flow = 0;
    while(SPFA(s, t))
    {
        int Min = INF;
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            Edge E = edge[i];
            Min = min(Min, E.cap - E.flow);
        }
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost += edge[i].cost * Min;
        }
        flow += Min;
    }
}
int main()
{
    while(scanf("%d%d", &N, &M) != EOF)
    {
        init();
        getMap();
        int cost, flow;
        MCMF(sink, source, cost, flow);
        if(flow == sum)//若流入汇点的总流量 等于 目标状态总流量 说明可行
            printf("%d\n", cost);
        else
            printf("-1\n");
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

MVVM设计模式基础知识--NotificationObject类（Prism框架）
在博客“MVVM设计模式基础知识–INotifyPropertyChanged接口”一文中，已经谈到了INotifyPropertyChanged接口。 
今天我们来谈一下NotificationObject类。
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 
但是设计模式不是一成不变的，每个人的理解也有所不同。譬如说MVVM设计模式，如果不需要ICommand接口，很多人就习惯将Model和ViewModel合二为一。这次很多人会采用的是继承NotificationObect类而不是继承INotifyPropertyChanged接口。
譬如说在Prism框架(Prism是一个超轻量的开源框架，前身是Angel ，现在改名为 Prism)中，有一个NotificationChanged类，位于Microsoft.Practices.Prism.ViewModel命名空间下，而NotificationObject类是继承INotifyPropertyChanged接口。
下面通过.NET Reflector查看Microsoft.Practices.Prism.ViewModel中的NotificationObject类。 
源码如下：
public abstract class NotificationObject : INotifyPropertyChanged
{
    // Events
    [field: NonSerialized]
    public event PropertyChangedEventHandler PropertyChanged;

    // Methods
    protected NotificationObject()
    {
    }

    protected void RaisePropertyChanged<T>(Expression<Func<T>> propertyExpression)
    {
        string propertyName = PropertySupport.ExtractPropertyName<T>(propertyExpression);
        this.RaisePropertyChanged(propertyName);
    }

    protected virtual void RaisePropertyChanged(string propertyName)
    {
        PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
        if (propertyChanged != null)
        {
            propertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    protected void RaisePropertyChanged(params string[] propertyNames)
    {
        if (propertyNames == null)
        {
            throw new ArgumentNullException("propertyNames");
        }
        foreach (string str in propertyNames)
        {
            this.RaisePropertyChanged(str);
        }
    }
}

NotificationObject类的使用：
public class PatientInfoViewModel : NotificationObject
{
    public static string m_PatID = "";
    public string PatID
    {
        get { return m_PatID; }
        set
        {
            if (!value.Equals(m_PatID))
            {
                m_PatID = value;
                this.RaisePropertyChanged(() => this.PatID);
            }
        }
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

每天五个java相关面试题（9）--java基础详解篇1
接下来会系统的总结java基础，然后过两天会开始从新开始复习前端并更新和总结一些关于前端的基础知识和面试题，嗯嗯我是一个想走前端的后端java工程师啊哈哈。马上开学大四了，lz我要加油啦~
接下来的面试题会学习我们班小伙伴的好学习方法，一个个刨根问底了，理清楚里面涉及到的知识点。
一、面向对象的特征有哪些方面
答： 
1.抽象： 
抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。
2.继承： 
继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3.封装： 
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。
4.多态性： 
多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。（静态多态是方法重载，动态多态是方法重写）
上面回答中涉及的知识点：
1、封装具体就是三步：第一步是设置对象属性私有化，第二步是创建赋值和取值方法（就是我们常说的get/set方法），第三步在赋值和取值方法中，加入对属性的存取限制（俗称校验）。
2、继承父类一定需要实现父类的方法嘛？ 
如果父类是抽象类，并且有抽象方法，那么子类必须重写父类的抽象方法，或者子类声明为抽象类。如果父类是个普通类，那么不是必须重写父类的方法。
3、何为抽象类？ 
使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。“抽象方法”,属于一种不完整的方法，只含有一个声明，没有方法主体。（类似于接口）。
4、在继承的时候我们有时候需要重写父类的方法，那么重写和重载的区别是什么？ 
重写的方法名，参数数目相同，参数类型兼容，重载的方法名相同，参数列表不同。 
重写的方法修饰符大于等于父类的方法，重载和修饰符无关。 
这里希望大家知道一个词语方法签名 就是由方法名称和一个参数列表（方法的参数的顺序和类型）组成。
二、Collection 和 Collections的区别。
答： 
Collection是集合类的上级接口，继承与他的接口主要有Set 和List. 
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
上面回答中涉及的知识点：
1、Collection接口在Java 类库中有有哪些具体的实现？ 
java.util.Collection 是一个集合接口。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。 
 Collection 
├List 
│├LinkedList 
│├ArrayList 
│└Vector 
│　└Stack 
└Set 
2、java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，内部封装了很多对各种集合的搜索、排序、线程安全化等操作，比如对一个list数组内的值进行排序，只需要Collections.sort(list);  即可。
三、String 、StringBuilder、Stringbu和StringBuffer的区别
答： 
String和StringBuffer和StringBuilder，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用 StringBuffers来动态构造字符数据。StringBuffer和StringBuilder类功能基本相似，主要区别在于StringBuffer类的方法是多线程、安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。
上面回答中涉及的知识点：
1、什么是线程安全？ 
线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
四、运行时异常与一般异常有何异同?
答： 
Java提供了两类主要的异常:runtime exception （运行时异常）和checked exception （检查异常）。检查异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch。
但是另外一种异常：运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。我们不需要进行捕获。
上面回答中涉及的知识点：
1、说出你常见的五种异常？ 
这个题我们老师说很容易被问到，所有大家可以挑选几个自己记下来，我这里也自己挑选几个了。

java.lang.nullpointerexception（”空指针异常”）
java.lang.classnotfoundexception（”指定的类不存在”，这里主要考虑一下类的名称和路径是否正确即可）
java.lang.arithmeticexception（”数学运算异常”，比如程序中出现了除以零这样的运算就会出这样的异常）
java.lang.arrayindexoutofboundsexception（”数组下标越界”）
java.lang.illegalargumentexception（”方法的参数错误”）

五、ArrayList,Vector为什么增、删慢，查、改快？而LinkedList查、改、慢，增、删快？
答： 
ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。 
而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。请多多指教~

关于最大费用最大流的一类问题  【小谈】


引子：给你一个N*M的矩阵，对应N*M个点，且每个点都有一定的点权。当第一次到达某个位置时，我们可以获得该位置的点权且只能获取这一次。现在让你从左上角出发，每次只能向下或者向右走~~~。 


当然是有限制的走
问题一：每个点只能走一次（除了起点和终点可以走多次），问你从左上角到右下角走两次所获取的最大权值和。
问题二：每个点无限走，问你从左上角到右下角走K次获取的最大权值和。


声明下，我要说的是建图，而不是怎么写代码。
这两种问题想了好久，姑且分享一下我的见解。错误的地方欢迎指正！！！O(∩_∩)O~~








我们默认把一个点 可以拆为 左点 和 右点（网络流解决问题很常用的手段，这里不细说）。
明确一下————当选择A点的左点或者右点时，都说明你选择了走A这个点。


情况一：每个点只能走一次（除了起点和终点可以走多次），问你走2次获取的最大权值和。


1，对可达边<u, v>的处理，注意是有向边
我们会考虑四种情况，题目要求————每个点只能走一次。所以我们如果选择走一个点就必须要获取它的点权，只有这样才能得到最大权值和。
如图：


首先明确我们在左点时，只有一种选择————就是到达右点，只有这样才能保证选择一个点必须要获取该点的点权。
这样的话只有选择U右到V左，才能保证获取两个点的点权。


(1)u的左点连v的左点，说明不获取u的点权而获取v的点权，不符合。
(2)u的左点连v的右点，说明既不获取u的点权也不获取v的点权，不符合。
(3)u的右点连v的左点，说明既获取u的点权又获取v的点权，符合。
(4)u的右点连v的右点，说明获取u的点权而不获取v的点权，不符合。
因此，我们只能建(3)这一条边。边的容量为1或者其他值，因为前一条边已经限制了流量最大为1，所以只要容量大于或等于1就行了。
获取点权这一点我说的可能不是很合适，建议自己模拟一下，好好思考。当然若有严重的bug，欢迎指正。


2，拆点
我们要保证超级源点到起点的2个流量能够传进来（因为我们要走两次，所以超级源点到起点的流量为2），并且终点到超级汇点的流量尽可能的传出去，这样才能最大化获得的权值和。
所以我们在拆点的时候，对起点和终点的处理是————建立容量为2的边，对其它点的处理————建立容量为1的边（访问后不能再访问）。 
因为若起点和终点拆成容量为1的边，那我们在起点的时候就只有一个选择：向上走或者向下走，在终点时只能选择是由上面的点传到终点还是由左边的点传入终点，这样的话就相当于求走一次的最大权值和，显然这样建图是不对的。

对于该问题的解决方案：建立超级源点sink，超级汇点source。
1，sink向起点左点建边，容量为2，费用为0；
2，拆点，起点、终点拆成容量为2的边，其他点拆成容量为1的边，费用为点权；
3，<u, v>可达边，则u的右点指向v的左点，容量为1，费用为0；
4，终点右点向source建边，容量为2，费用为0.
建好边，跑一次最大费用最大流，因为我们多算了一次起点和终点的点权，所以最后求出的最大费用要减去起点和终点的点权。




情况二：每个点无限走，问你从左上角到右下角走K次获取的最大权值和。




1，我们对可达边<u, v>处理，还是那句话————当选择一个点的左点或者右点时，都说明你选择了走这个点。
我们会考虑四种情况，题目要求————每个点可以走多次。所以我们如果选择一个点并不意味着一定要获取它的点权
如图：


显然有上面4种方式，因为我们不考虑是否获取点权。这就是说，当到达左点时，不一定非要选择到右点。 
当然这只是<u, v>边的情况，u每次可以选择向下走或者向右走，这样每一个点都会有8种选择（不考虑特殊的边界点）。
(1)u的左点连v的左点，说明不获取u的点权而获取v的点权，符合。
(2)u的左点连v的右点，说明既不获取u的点权也不获取v的点权，符合。
(3)u的右点连v的左点，说明既获取u的点权又获取v的点权，符合。
(4)u的右点连v的右点，说明获取u的点权而不获取v的点权，符合。
因此，我们可以建(1)(2)(3)(4)这四条边，边的容量为无穷大，因为我们可以任意选择经过该边的流量（不超过K的前提下），只要它能使最权值和最大化就行了。


2，拆点

如果我们可以走一个点多次，那么不管怎么样，从一个点出发只会有8种方式下传流量给另一个点（这里我们不考虑那些特殊的边界点）。我们会发现，在上述建边的前提下，已经包括了所有将流量传入下一点的方式。
这样的话我们只需要把每个点拆分成容量为1的边、并且保证超级源点到起点以及终点到超级汇点的边的容量为K————就可以保证最后的结果取的是走K次的最大权值和。





对于该问题的解决方案：设置超级源点sink，超级汇点source
1，sink向起点左点建边，容量为K，费用为0；
2，拆点，每个点拆为容量为1，费用为点权的边；
3，<u, v>可达关系建四条边，这样的话对于非特殊边界点则可以建8条边（下、右都要建），边的容量为INF，费用为0；
4，终点到source建边，容量为K，费用为0。
最后跑一次最大费用最大流，结果就是最大权值和。






版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA 题目1223 - Editor（后缀数组求出现次数超过两次的最长子串的长度）
Mr. Kim is a professional programmer. Recently he wants to design a new editor which has as many functions as possible. Most editors support a simple search function that finds one occurrence (or all occurrences
 successively) of a query pattern string in the text.
He observed that the search function in commercial editors does nothing if no query pattern is given. His idea of a new search function regards each substring of the given text as a query
 pattern string itself and his new function finds another occurrence in the text. The problem is that there can be occurrences of many substrings in the text. So, Mr. Kim decides that the new function finds only occurrences of the longest
 substring in the text in order to remedy the problem. A formal definition of the search function is as follows:
Given a text string S , find the longest substring in text string S such that the substring appears at least twice. The two occurrences are allowed
 to overlap.

Input 
Your program is to read from standard input. The input consists of T test cases. The number of test cases T is given in the first line of the
 input. For each test case, a text string S is given in one line. For every string, the length is less than or equal to 5,000 and the alphabet  is
 the set of lowercase English characters.

Output 
Your program is to write to standard output. Print exactly one line for each test case. Print the length of the longest substring in text string S such that the substring appears
 at least twice.

Sample Input 

3 
abcdefghikjlmn 
abcabcabc 
abcdabcabb


Sample Output 

0 
6 
3做这么多后缀数组题以来，这个应该是最水的了吧ac代码0ms过#include<stdio.h>              
#include<string.h>              
#include<algorithm>              
#include<iostream>             
#define min(a,b) (a>b?b:a)          
#define max(a,b) (a>b?a:b)       
#define N 1000005         
using namespace std;            
char str[5010];          
int sa[5010],Rank[5010],rank2[5010],height[5010],c[5010],*x,*y,s[5010],k;   
void cmp(int n,int sz)        
{        
    int i;        
    memset(c,0,sizeof(c));        
    for(i=0;i<n;i++)        
        c[x[y[i]]]++;        
    for(i=1;i<sz;i++)        
        c[i]+=c[i-1];        
    for(i=n-1;i>=0;i--)        
        sa[--c[x[y[i]]]]=y[i];        
}        
void build_sa(char *s,int n,int sz)        
{        
    x=Rank,y=rank2;        
    int i,j;        
    for(i=0;i<n;i++)        
        x[i]=s[i],y[i]=i;        
    cmp(n,sz);        
    int len;        
    for(len=1;len<n;len<<=1)        
    {        
        int yid=0;        
        for(i=n-len;i<n;i++)        
        {        
            y[yid++]=i;        
        }        
        for(i=0;i<n;i++)        
            if(sa[i]>=len)        
                y[yid++]=sa[i]-len;        
            cmp(n,sz);        
        swap(x,y);        
        x[sa[0]]=yid=0;        
        for(i=1;i<n;i++)        
        {        
            if(y[sa[i-1]]==y[sa[i]]&&sa[i-1]+len<n&&sa[i]+len<n&&y[sa[i-1]+len]==y[sa[i]+len])        
                x[sa[i]]=yid;        
            else        
                x[sa[i]]=++yid;        
        }        
        sz=yid+1;        
        if(sz>=n)        
            break;        
    }        
    for(i=0;i<n;i++)        
        Rank[i]=x[i];        
}        
void getHeight(char *s,int n)        
{        
    int k=0;        
    for(int i=0;i<n;i++)        
    {        
        if(Rank[i]==0)        
            continue;        
        k=max(0,k-1);        
        int j=sa[Rank[i]-1];        
        while(s[i+k]==s[j+k])        
            k++;        
        height[Rank[i]]=k;        
    }        
}   
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%s",str);
		int ans=0;
		int n=strlen(str);
		build_sa(str,n+1,128);
		getHeight(str,n);
		for(int i=1;i<=n;i++)
			ans=max(ans,height[i]);
		printf("%d\n",ans);
	}
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

老生常谈之widows下link错误
         由于之前一直从事linux下的嵌入式开发，对于windows下的工程环境配置，lib链接，dll链接等等都不是很敏感。经过一些时间的摸索和实践，基本的一些配置选项都玩得差不多了。对于常见的错误都能知道怎么去下手解决，但最近把项目把移植到64位操作上，重新编译所有的dll的时候。发现几个link问题还是不能很快的解决，几个链接的错误摸索了好几天，最后都是因为配置问题引起的，各种郁闷，原来VS下面果真没有linux来的那般方便。跑偏了，言归正传，总结一下遇到的几种比较典型link的错误，1、查看库的引导路径以及库的名称，如果是导入DLL的话，注意DLL导出接口的lib库文件。配置如下：                                           左边配置好需要的路径，右边加载需要的库文件的名称即可。一般情况下如果配置好上面的情况并且在工程目录加入dll的话，程序就能正常运行了,这也是大多数论坛上回复很多人link错误的答案。但是有时候其他的配置没有匹配的话，也会link错误的。2、注意宽字节问题。先来看看我自己链接时候的错误       出现这个错误的时候，刚开始我也是莫名其妙的，因为我对于第一条中提到的配置问题，我都已经设置好了，确认没有问题的。后来怀疑编译这个开源的时候没有成功导出接口，所以又借助Depends看了下，如下图： 发现接口也都成功导出了呀，并没有什么问题。后来思量再三，问了下老大，结果他看了半天也是无从下手。后面没有办法，老大竟然对比了函数导出名称后面的数字竟然发现是不同的，我也仔细看了，红色框框部分，确实不同，姜果然是老的辣，一语击中要害。原来我生成的dll设置了宽字节，而链接这个dll的时候不需要没有，导致出现链接不上，又来修改了设置如下：修改后，编译连接成功。纠结了蛮久的问题终于解决。这也是link错误的一个比较隐藏的错误。当然在其中还有另外两个地方的设置，也会引起link的错误的。3、字节编码的设置问题   4、RunTime Library的设置问题 各个选项的具体说明可以参考David的博客，说的比较清楚，这里的设置问题也会引起link错误。            最后总结下，link错误千千万，很多情况都会出现各种纠结的link问题，遇到问题不要急躁，细心仔细对比，首先确认链接问题，然后是否成功导出，查看导出和调用接口差异，确认各个可能引起链接错误的配置信息等等，一步一步缩小范围。

版权声明：本文为博主原创文章，未经博主允许不得转载。

八大算法一一道来
1. 插入排序
1.1 基本思想：
任意一个待排序序列，都可以看做由有序部分和无序部分组成，只是开始的时候，有序部分只包含一个元素，而无序部分包含了N-1个元素。插入排序的思想就是：从无序部分一个一个地取出元素，并将其插入到有序部分中，随着插入排序的进行，有序部分变长，无序部分变短，直到整个序列都变成有序的。举个简单的例子，假设待排序序列为{5,3,2,6}，我们需要将它进行从小到大的排序，开始的时候有序部分为{5}，无序部分为{3,2,6}：
第一趟排序操作：从{3,2,6}中取出3，将之插入有序部分中，有序部分变成了{3,5}，无序部分变成了{2,6}； 
第二趟排序操作：从{2,6}中取出2，将之插入到有序部分，有序部分变成了{2,3,5}，无序部分变成了{6}； 
第三趟排序操作：从{6}中取出6，插入到有序部分中，有序部分变成了{2,3,5,6}，排序完成。
对于插入排序而言，影响性能的操作主要是“插入”，因为我们要把一个元素插入到一个有序序列中，并保持该序列继续有序。根据“插入”方法的不同，又有了“直接插入排序”、“折半插入排序”等。所谓的直接插入就是将待插入的元素与有序序列中的元素一个个进行比较，找到合适的位置进行插入，所谓的折半插入就是将待排序的元素与有序序列的中间元素进行比较，若大于该中间元素，就在有序序列的后半段继续寻找合适的位置，否则就在有序序列的前半段继续寻找合适的位置。显然，折半插入的效率更高。不过需要注意的是，折半插入只是能更有效率地找到合适的插入位置，如果序列存放在数组中，那么插入会引起数组中其他元素的向后移动，而折半插入并不能减少移动的次数，所以其时间复杂度仍为O(n2n^{2})。
1.2 直接插入排序
void insertSort(int x[],int N){
    for(int i=1; i<=N-1; i++){
        //直接查找x[i]应该被插入的位置
        int j = i-1;
        while(j>=0 && x[j]>x[i]) j--;
        j += 1;  // 现在j就是合适的位置

        for(int p=i-1;p>=j;p--) x[p+1] = x[p]; //向后移动元素
        x[j] = x[i]; // 将x[i]插入到了合适的位置
    }
}
1.3 折半插入排序：
void binarySort(int x[],int N){
    for(int i=1;i<=N-1;i++){
        //折半查找合适的位置
        int low = 0,high = i-1;
        int mid = (low+high)/2;
        while(low<=high){
            if(x[mid]<=x[i]) low = mid+1;
            else high = mid-1;
        }
        // while结束后low就是合适的插入位置
        //接下来的步骤同上
        for(int p=i-1;p>=low;p--) x[p+1] = x[p]; //向后移动元素
        x[low] = x[i]; // 将x[i]插入到了合适的位置
    }
}
直接插入排序在什么情况下效率最高呢？当然是原序列已经从小到大排序好了，这时内层循环就不用执行了，此时时间复杂度为O(NN)。倒是折半插入的效率略有下降，因为它还得“机械地”找合适的位置。那啥时候效率最低呢？当原序列从大到小排序好了，此时内层循环要完完整整地执行完，所以时间复杂度为O(N2N^{2})。
1.4 稳定性
直接插入排序和折半插入排序都是稳定的排序算法，所谓稳定，就是当两个元素相等时，排序后的先后顺序与排序前的先后顺序一致。不过，不是所有的插入排序都是稳定的，如希尔排序。
希尔排序的基本思想是将原序列看成几个子序列，比如原序列为原序列{1,5,31,32,6,71,5,3_{1},3_{2},6,7}，其中下标表示相同元素在原序列中的先后顺序：X表示我们在操作的时候不考虑该位置的元素。
第一个子序列就是第1、3、5个元素，即{1,X,31,X,6,X1,X,3_{1},X,6,X}， 
第二个子序列就是第2、4、6个元素，即{X,5,X,32,X,7X,5,X,3_{2},X,7}，
对第一个子序列的排序结果为{1,X,31,X,6,X1,X, 3_{1},X,6,X}，正好没变 
对第二个子序列的排序结果为{X,32,X,5,X,7X,3_{2},X,5,X,7}
所以整体看来，排序后的序列为{1,32,31,5,6,71,3_{2},3_{1},5,6,7}，显然，改变了相同元素的先后顺序，所以希尔排序是不稳定的。希尔排序有个“增量”的概念，上面的例子中，其增量为2。
希尔排序的目的是通过对子序列进行排序，使得原序列比之前稍微有序一点，然后我们就可以对这个“稍微有序一点”的序列进行普通的插入排序，因为插入排序对有序序列更有效率一点，而子序列的长度较短，也可以用比较有效率的方式进行排序。
希尔排序的时间复杂度比较复杂，取决于增量，比O(N2N^2)好，可以达到O(N^N^1.5)))，具体可以参考其他文献。
2. 交换排序
与插入排序不同，交换排序的主要操作是“交换”，所以不需要大规模的移动元素。举个简单的例子，比如要把序列 {3,1,2} 按从小到大的顺序排列，我们先比较3与1，因为 1<3，所以将两者交换得到 {1,3,2}，再比较3与2，因为2<3，所以将两者进行交换，得到{1,2,3}，这样就完成了排序。
2.1 冒泡排序
最简单的交换排序是冒泡排序，举个简单例子，比如要把数组 x[6] （下标从0~5）按照从小到大的顺序排列，第一趟排序的效果就是把最小的元素放在x[0]处，具体操作如下：
第一趟排序： 
1、比较x[4]和x[5]，如果x[4]>x[5]，则将两者交换(tmp = x[4]; x[4]=x[5]; x[5]=tmp)，否则不交换； 
2、比较x[3]和x[4]，如果x[3]>x[4]，则将两者交换(tmp = x[3]; x[3]=x[4]; x[4]=tmp)，否则不交换； 
…… 
5、比较x[0]和x[1]，如果x[0]>x[1]，则将两者交换(tmp = x[0]; x[0]=x[1]; x[1]=tmp)，否则不交换；
这样经过5次比较后，最小的元素就被交换到了x[0]处，接着进行第二趟排序，结果就是将次小的元素放在了x[1]处，接着进行第三趟排序…… 五趟排序后，序列就变成有序的了。
代码如下（设序列为x[N]，N为序列的长度）：
void bubbleSort(int x[],int N){
    for(int i=0;i<=N-2;i++){
        for(int j=N-1;j>i;j--){
            if(x[j]>x[j-1]){
                int temp = x[j];
                x[j] = x[j-1];
                x[j-1] = temp;
            }
        }
    }
}
总结一下：冒泡排序要进行N-1趟排序，平均每趟排序需要进行N/2次比较操作，所以时间复杂度为O(N2N^{2})。冒泡排序是一种稳定的排序算法（大家试试就知道了:)）。
2.2 快速排序 
改善性能的基本思路是尽量减少重复的操作，比如减少“比较”操作，对于冒泡排序而言，经过一趟排序后，无序部分仍然像之前那样“无序”，所以上一趟排序对下一趟排序带来的好处太少，导致下一趟排序仍需要进行很多操作。下面将要讨论的快速排序估计就是受到了类似的启发。
快速排序的第一趟排序不是把最大的元素放在序列的末端，而是把第一个元素放在序列的合适位置，同时保证该位置前边的元素均小于第一个元素，该位置后边的元素均不小于第一个元素。第二趟排序呢，思路一样，只是分别就处理刚刚生成的两个子序列，递归算法很容易就实现了。以第一趟排序为例，假设输入的序列为 x[N]
void quickSort(int x[],int low,int high){
    if(low>=high) return ;

    int temp = x[low]

    //给temp寻找合适的位置
    int i = low, j = high;
    while(i<j){
        while(i<j && x[j]>temp) j--;
        if(i<j){x[i] = x[j]; i++;}

        while(i<j && x[i]<=temp) i++;
        if(i<j){x[j] = x[i]; j--;}
    }
    //while循环结束后，i=j就是合适的位置
    x[i] = temp;

    quickSort(x,low,i-1);
    quickSort(x,i+1,high);
}
一般情况下，每趟排序会将原序列分成两个子序列，所以需要进行log2(n)log_{2}(n)趟排序（当子序列的长度为1时就不用继续递归了），每趟排序还是需要处理那n个元素，所以需要进行 O(nn) 次操作，所以平均意义下的时间复杂度为O(nlog2(n)nlog_{2}(n))。最差的情况是什么呢？当原序列已经有序时，这时无法二分原序列，所以递归深度变成了N，所以时间复杂度变成了O(N2N^2)。因为采用了递归，每次函数调用会发生压栈操作，就会占用一定数量的栈空间，又因为递归深度为log2(n)log_{2}(n)，所以会发生O(log2(n))log_{2}(n))次压栈，所以算法的空间复杂度为O(log2(n))log_{2}(n))。快速排序是一种不稳定的排序算法，举个简单例子，原序列为{5,31,4,6,7,325,3_{1},4,6,7,3_{2}}，第一趟排序的结果是{32,31,4,5,6,7,3_{2},3_{1},4,5,6,7,}，显然，相同元素的先后顺序被打乱了。
3. 选择排序
选择排序的基本思想是： 第一趟排序选择一个最小的元素放在序列的前端，第二趟排序选择一个次小的元素放在第二的位置……所以在选择排序中，每趟排序的效果跟冒泡排序是一样的，只是做法有点区别。
3.1 简单选择排序 
简单选择排序是这样操作的，给定一个序列 x[N]，第一趟排序是从 1~N-1 个元素中选一个最小的，假如下标为k，则将 x[0] 与 x[k] 交换，第二趟排序是从 2~N-1 中选择一个最小的，假如下标为p，则将 x[1] 与 x[p] 交换……不难发现，对于一个长度为N的序列，需要进行 N-1 趟排序，平均每趟排序要进行 N/2 次比较，所以时间复杂度为 O(N2N^2)，又每趟排序仅需要一个临时变量来存放最小元素的下标，以及一个临时变量用于交换元素，所以空间复杂度为O(1)。代码如下：
void selectSort(int x[],int N){
    for(int i=0;i<=N-2;i++){
        int min = i;
        for(int j=i+1;j<=N-1;j++){
            if(x[j])<x[min]) min=j;
        }

        //交换x[i]与x[min]
        int temp = x[i];
        x[i] = x[min];
        x[min] = temp;
    }
}
简单选择排序是一种不稳定的排序算法，举个简单例子，原序列为{31,32,2,1,6,7,8,93_{1},3_{2},2,1,6,7,8,9}，第一趟排序的结果是{1,32,2,31,6,7,8,91,3_{2},2,3_{1},6,7,8,9}，第二趟排序的结果是{1,2,32,31,6,7,8,91,2,3_{2},3_{1},6,7,8,9}，显然是不稳定的。
3.2 堆排序 
简单选择排序的上一趟排序仍然不能给下一趟排序带来更多的好处，堆排序的第 ii 趟排序也会选出序列中的第 ii 小的元素，但是堆排序的上一趟排序会给下一趟排序省下不少操作。 
堆排序把序列看成了一颗完全二叉树，比如有序列{16,14,16,8,7,9,3,2,4,1}，对应到完全二叉树如下，x[i]的子节点分别是x[2i+1]和x[2i+2]： 
 
 
 
对于有n个节点的完全二叉树，树的高度为⌈log2(n+1)⌉\lceil{log_{2}(n+1)}\rceil。最后一个有子节点的节点为 x[⌊n/2⌋−1][\lfloor{n/2}\rfloor-1]。对于上图而言，就是 x[4]（5号节点）。
堆排序的基本思想就是保证每个节点都要比它的子节点大（这就是所谓的最大堆），那么根节点就是序列中最大的元素，所以建立一个最大堆的过程，就是第一趟排序，选出了最大的元素，将该元素与序列末端的元素交换后，再调整 x[0~n-2] 对应的堆，使之仍然为一个最大堆，这样就选出了第二大的元素，以此类推…..尽管这样仍然需要进行 n-1 趟排序，但是每趟排序（第一趟排序除外）中执行的比较次数与树深成正比，即O(log2(n)log_{2}(n))，所以时间复杂度为O(nlog2(n)nlog_{2}(n))。
堆排序的基本操作是下沉，假设上图中的最大堆是第一次排序的结果，然后我们就需要把最大元素（即根元素）放在序列的末端，所以将”16”与”1”做了交换，这样根元素变成了”1”，显然破坏的最大堆的性质，所以我们要将这个”1”向下沉，直到它沉到了合适的位置，代码如下：
void downAdjust(int x[],int N,int root){
    int left_child = 2*root+1;
    int right_child = left_child+1;

    //找到较大的子节点
    if(left_child>=N) return ; //没有子节点就直接返回

    int larger_child = left_child;
    if(right_child<=N-1 && x[right_child]>x[left_child]) larger_child = right_child;

    if(x[larger_child]<=x[root]) return ;
    else {//将跟节点与较大的子节点交换
        int temp = x[root];
        x[root] = x[larger_child];
        x[larger_child] = temp;
        //递归第调整子树
        downAdjust(x,N,larger_child);
    }
}
建堆的过程中，就是从下到上，一层一层的处理节点：
1、首先处理倒数第二层，将这一层的节点与它们的子节点进行比较，如果小于子节点，就与子节点交换位置；
2、然后处理倒数第三层，将这一层的节点与它们的子节点进行比较（倒数第二层），如果小于子节点，就与子节点交换位置，同时，”交换“改变了倒数第二层的节点，所以要保证以倒数第二层节点为根节点的子树依然具有最大堆的性质，需要进行一个下沉调整；
3、然后处理倒数第四层……
所以每处理一层，不仅仅要比较自己与子节点的大小，也要保证以子节点为根的子树也满足最大堆的性质，建堆的代码如下：
void createHeap(int x[],int N){
    for(int i=N/2-1;i>=0;i--) downAdjust(x,N,i);
}
堆排序的代码如下：
void heapSort(int x[],int N){
    heapCreate(x,0,n); //建堆
    for(int i=N-1; i>0; i--){
        swap(x[0],x[i]);  //交换根元素与序列末端的元素
        downAdjust(x,i+1,0);
    }
}
在堆排序中，建堆是比较耗时的操作，但也是O(n)的量级，之后的调整的时间复杂度仅为O(log2(n)log_{2}(n))。堆排序是一种不稳定的排序算法。
4. 归并排序
归并排序的思想是把序列分成两个子序列，分别对两个子序列排序后，再把它们合并在一起，大家或许注意到之前的快速排序也会将原序列分为两个子序列（一般而言），所以归并排序的性能与快速排序差不多，但是归并排序一定会把原序列分成两个子序列，而快速排序不一定，所以归并排序的最差性能比快速排序好，付出的代价就是增加了空间复杂度。
归并排序的代码如下：
void mergeSort(int x[],int low,int high){
    if(low>=high) return ;

    int mid = (low+high)/2;
    //一分为二地处理两个子序列
    mergeSort(x,low,mid);
    mergeSort(x,mid+1,high);

    //合并两个子序列，需要额外的空间
    int *p = new int[high-low+1];
    int i = low, j = mid+1, k = 0;
    while(i<=mid+1 && j<=high){
        if(x[i]<=x[j]) {p[k] = x[i];i++;k++;}
        else {p[k] = x[j];j++;k++;}
    }

    while(i<=mid+1) {p[k] = x[i]; i++;k++;}
    while(j<=high) {p[k] = x[j];j++;k++}

    //复制回原序列中
    for(k=0;k<=high-low;k++) x[low+k] = p[k];
}
归并排序是稳定的排序方式，因为排序过程中不涉及“大跨度的元素交换”。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

SPOJ 题目913QTREE2 - Query on a tree II（Link Cut Tree 查询路径第k个点）

QTREE2 - Query on a tree II


no tags 



You are given a tree (an undirected acyclic connected graph) with N nodes, and edges numbered 1, 2, 3...N-1. Each edge has an integer value
 assigned to it, representing its length.
We will ask you to perfrom some instructions of the following form:

DIST a b : ask for the distance between node a and node b
orKTH a b k : ask for the k-th node on the path from node a to node b
Example:
N = 6 
1 2 1 // edge connects node 1 and node 2 has cost 1 
2 4 1 
2 5 2 
1 3 1 
3 6 2 

Path from node 4 to node 6 is 4 -> 2 -> 1 -> 3 -> 6 
DIST 4 6 : answer is 5 (1 + 1 + 1 + 2 = 5) 
KTH 4 6 4 : answer is 3 (the 4-th node on the path from node 4 to node 6 is 3) 


Input
The first line of input contains an integer t, the number of test cases (t <= 25). t test cases follow.
For each test case:

In the first line there is an integer N (N <= 10000)In the next N-1 lines, the i-th line describes the i-th edge: a line with three integers a b c denotes an edge between a,b of
 cost c (c <= 100000)The next lines contain instructions "DIST a b" or "KTH a b k"The end of each test case is signified by the string "DONE".
There is one blank line between successive tests.

Output
For each "DIST" or "KTH" operation, write one integer representing its result.
Print one blank line after each test.

Example
Input:
1

6
1 2 1
2 4 1
2 5 2
1 3 1
3 6 2
DIST 4 6
KTH 4 6 4
DONE

Output:
5
3题目大意：DIST 4 6询问4 到6的距离，KTH 4 6 4，询问4 到6经过的第4个点ac代码
#include<stdio.h>   
#include<string.h>   
#include<stdlib.h>   
#include<queue>   
#include<iostream>   
#define MAXN 10010
using namespace std;  
int head[10010],cnt,vis[10010];  
struct s  
{  
    int u,v,w,next;  
}edge[10010<<1];  
struct LCT    
{    
    int bef[10010],pre[10010],next[10010][2],key[10010],sum[10010],belong[10010],num[10010];  
    void init()    
    {    
        memset(pre,0,sizeof(pre));  
        memset(next,0,sizeof(next));    
    }  
    void pushup(int x)  
    {  
        sum[x]=key[x]+sum[next[x][1]]+sum[next[x][0]];  
		num[x]=num[next[x][1]]+num[next[x][0]]+1;
    }  
    void rotate(int x,int kind)    
    {    
        int y,z;    
        y=pre[x];    
        z=pre[y];    
        next[y][!kind]=next[x][kind];    
        pre[next[x][kind]]=y;    
        next[z][next[z][1]==y]=x;    
        pre[x]=z;    
        next[x][kind]=y;    
        pre[y]=x;  
        pushup(y);  
    }    
    void splay(int x)    
    {    
        int rt;    
        for(rt=x;pre[rt];rt=pre[rt]);    
        if(x!=rt)    
        {    
            bef[x]=bef[rt];    
            bef[rt]=0;    
            while(pre[x])    
            {    
                if(next[pre[x]][0]==x)    
                {    
                    rotate(x,1);    
                }    
                else    
                    rotate(x,0);    
            }    
            pushup(x);  
        }    
    }   
    void access(int x)    
    {    
        int fa;    
        for(fa=0;x;x=bef[x])    
        {    
            splay(x);    
            pre[next[x][1]]=0;    
            bef[next[x][1]]=x;    
            next[x][1]=fa;    
            pre[fa]=x;    
            bef[fa]=0;    
            fa=x;    
            pushup(x);  
        }    
    }  
    int query(int x,int y)  
    {  
        access(y);  
        for(y=0;x;x=bef[x])  
        {  
            splay(x);  
            if(!bef[x])  
                return sum[y]+sum[next[x][1]];  
            pre[next[x][1]]=0;  
            bef[next[x][1]]=x;  
            next[x][1]=y;  
            pre[y]=x;  
            bef[y]=0;  
            y=x;  
            pushup(x);  
        }  
    } 
	int select(int x,int k)
	{
		while(num[next[x][0]]+1!=k)
		{
			if(num[next[x][0]]+1>k)
				x=next[x][0];
			else
			{
				k-=num[next[x][0]]+1;
				x=next[x][1];
			}
		}
		return x;
	}
	int KTH(int y,int x,int k)
	{
		access(y);  
        for(y=0;x;x=bef[x])  
        {  
            splay(x);  
            if(!bef[x])  
			{
				if(num[next[x][1]]+1==k)
					return x;
				else
					if(num[next[x][1]]+1>k)
						return select(next[x][1],num[next[x][1]]-k+1);
					return select(y,k-num[next[x][1]]-1);
			}
            pre[next[x][1]]=0;  
            bef[next[x][1]]=x;  
            next[x][1]=y;  
            pre[y]=x;  
            bef[y]=0;  
            y=x;  
            pushup(x);  
        } 
	}
}lct;
void add(int u,int v,int w)  
{  
    edge[cnt].u=u;  
    edge[cnt].v=v;  
    edge[cnt].w=w;  
    edge[cnt].next=head[u];  
    head[u]=cnt++;  
}  
void bfs(int u)  
{  
    int i,y;  
    queue<int>q;  
    memset(vis,0,sizeof(vis));  
    vis[u]=1;  
    q.push(u);  
    while(!q.empty())  
    {  
        u=q.front();  
        q.pop();  
        for(int i=head[u];i!=-1;i=edge[i].next)  
        {  
            int v=edge[i].v;  
            if(!vis[v])  
            {  
                lct.bef[v]=u;  
                lct.key[v]=lct.sum[v]=edge[i].w;  
                vis[v]=1;  
                q.push(v);  
            }  
        }  
    }  
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,i;
		scanf("%d",&n);
		cnt=0;
		memset(head,-1,sizeof(head));
		for(i=1;i<n;i++)
		{
			int u,v,w;
			scanf("%d%d%d",&u,&v,&w);
			add(u,v,w);
			add(v,u,w);
		}
		lct.init();
		bfs(1);
		char op[10];
		while(scanf("%s",op)!=EOF)
		{
			if(!strcmp(op,"DONE"))
				break;
			if(op[0]=='D')
			{
				int x,y;
				scanf("%d%d",&x,&y);
				printf("%d\n",lct.query(x,y));
			}
			else
			{
				int x,y,z;
				scanf("%d%d%d",&x,&y,&z);
				printf("%d\n",lct.KTH(x,y,z));
			}
		}
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

模拟JDK动态代理类的实现
问题： 
要理解动态代理及其优点，我们先从这样一个问题入手，比如现在我们有UserDao这样一个接口，里面有addUser()方法，同时有一个UserDaoImpl类实现了该接口，具体实现了addUser()方法，现在我要实现在该方法前后记录日志的功能，有什么解决办法呢？

在源代码上直接修改。第一反应肯定是直接在源码上添加该功能，但是如果我的需求变成在所有的DaoImpl包里的类的所有的方法都添加记录日志的功能，那再去每一个都添加，工作量大，代码的重用率也不高，而且有的时候你可能没有源代码，所以该方法不考虑。
继承。写一个类继承UserDaoImpl类，再重写addUser()方法，在方法的前后实现记录日志。

public class ExtendsImpl1 extends UserDaoImpl {
    @Override
    public void addUser() {
        //模拟记录日志
        System.out.println("开始记录日志......");

        super.addUser();

        System.out.println("记录日志结束。");
    }
}
这样是可以完成功能。但是缺点有三：1.Java只支持单继承，这意味着该类在没法继承别的类，2.比如我现在功能拓展为先记录日志，在处理事务？如果按照继承的思路只能在一个ExtendsImpl2继承ExtendsImpl1在外面在包装上一层事务处理的代码。如果现在我要求先处理事务在记录日志，那我又要在重新写两个类……到这里大家就可以看出弊端，我有N多种功能，每种功能之间有不同的组合，那我们要写的类的数量就很多了，因此该方法也不推荐。

聚合。我们写一个专门记录日志的类，同时该类实现了UserDao这个接口，同时在构造方法给该类传递一个该接口变量，再覆盖的addUser方法中通过实例化不同的接口实例变量来调用addUser方法。结构如下：

public class LogProxy implements UserDao{
    UserDao u ;
    public LogProxy(UserDao u) {
        super();
        this.u = u;
    }
    @Override
    public void addUser() {
        //模拟记录日志
        System.out.println("开始记录日志......");
        u.addUser();
        System.out.println("记录日志结束。");
    }
}

public class TransacProxy  implements UserDao{
    UserDao u ;
    public TransacProxy(UserDao u) {
        super();
        this.u = u;
    }
    @Override
    public void addUser() {
        //模拟事务
        System.out.println("transaction begin......");
        u.addUser();
        System.out.println("transaction commit.");
    }
}
假如现在我要增加事务功能，同时实现和日志功能的组合，只需要创建实现事务和日志的两个类的对象，并互相包装即可，因为这两个类都实现了USerDao接口，并持有一个该接口类型的变量。LogProxy log =  new LogProxy(userDao);TransacProxy trac = new TransacProxy(log);就是完成先记录日志，在处理事务。TransacProxy trac = new TransacProxy(userDao);LogProxy log =  new LogProxy(trac);完成先处理事务，在记录日志。
public static void main(String[] args) {
        UserDao userDao = new UserDaoImpl();
        //先记录日志，在处理事务
        //LogProxy log =  new LogProxy(userDao);
        //TransacProxy trac = new TransacProxy(log);
        //完成先处理事务，在记录日志
        TransacProxy trac = new TransacProxy(userDao);
        LogProxy log =  new LogProxy(trac);
        log.addUser();
    }
多种功能的组合的时候，道理一样。这个时候LogProxy就可以看成是UserDaoImpl的一个代理。继承的思路基本接近动态代理的思路了，只是现在LogProxy只是UserDaoImpl类的addUser方法的日志代理类，我现在想把它写成任意接口任意方法的日志代理类，这时候就要用到动态代理了。 
动态代理 
自己写了个两个类模拟Java动态代理的实现，即可实现对任意接口的任意方法的AOP，只注重实现思路，并没实现细节，默认被切入点的被代理的方法是无参的（有参数反射依然可以实现，默认无参只是为了说明问题）。比如我现在要在任意接口的所有方法执行时统计方法执行的时间，即在每个方法执行前后获得系统时间取差值即为执行时间。首先做一个接口InvocationHandler，他的实现类TimeHandler中的invoke方法根据传递进来的被代理对象和方法，用反射执行该方法，并在方法执行前后统计时间；
public interface InvocationHandler {

    public void invoke(Method m)  throws Exception ;
}

public class TimeHandler implements InvocationHandler {
    //被代理对象
    Object target;

    public TimeHandler(Object target) {
        super();
        this.target = target;
    }

    @Override
    public void invoke(Method m) throws Exception {
        long start = System.currentTimeMillis();
        System.out.println("starttime:" + start);
        //接收代理类传递过来的方法
        m.invoke(target);
        long end = System.currentTimeMillis();
        System.out.println("time:" + (end-start));
    }

}
第2个类Proxy，是一个动态产生代理的类，在newProxyInstance()方法中，只需要你传递接口的Class和你需要的InvocationHandler实现类，通过拼接字符串,该字符串通过FileWriter写入到一个Java文件中去，该Java类就是我们的时间代理类，该类会调用InvocationHandler对象的invoke（Method method）方法，就会实现每个方法的时间统计功能。我们会将该代理类手动编译，使用classLoader加载，通过反射返回被代理接口类型的对象。
public class Proxy {

    public static Object newProxyInstance(Class inter , InvocationHandler handler) throws Exception{
        String methodStr="";
        String rt = "\r\n";
        Method[] methods = inter.getMethods();
        for(Method m : methods){
        /*  methodStr +="@Override"+rt+
                        "public void "+m.getName()+"() {"+rt+
                            "    long start = System.currentTimeMillis();" + rt +
                            "    System.out.println(\"starttime:\" + start);" + rt +
                            "    t.move();" + rt +
                            "    long end = System.currentTimeMillis();" + rt +
                            "    System.out.println(\"time:\" + (end-start));" + rt +
                        "}";*/
            methodStr +="@Override"+rt+
                    "public void "+m.getName()+"() {"+rt+
                        "java.lang.reflect.Method method;"+rt+
                        "try {"+rt+
                        "method = "+inter.getName()+".class.getMethod(\""+m.getName()+"\");"+rt+
                        "h.invoke(this , method);"+rt+
                        "} catch (Exception e) {"+rt+
                        "e.printStackTrace();"+rt+
                        "}"+rt+
                    "}";
        }
        String src = 
            "package com.proxy;" +  rt +
            "public class $proxy1 implements "+inter.getName()+ "{" + rt +
            "    public $proxy1(InvocationHandler h) {" + rt +
            "        super();" + rt +
            "        this.h = h;" + rt +
            "    }" + rt +

            "    InvocationHandler h;" + rt +
                methodStr+rt+
            "}";
        String filePath = System.getProperty("user.dir")+"\\src\\com\\proxy\\$proxy1.java";
        File file = new File(filePath);
        FileWriter fw = new FileWriter(file);
        fw.write(src);
        fw.flush();
        fw.close();

        //compile
        JavaCompiler javaCompile = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileMgr = javaCompile.getStandardFileManager(null, null, null);
        Iterable units = fileMgr.getJavaFileObjects(filePath);
        CompilationTask t = javaCompile.getTask(null, fileMgr, null, null, null, units);
        t.call();
        fileMgr.close();

        //load into memory and create an instance
        URL[] urls = new URL[] {new URL("file:/"+System.getProperty("user.dir")+"/src/")};
        URLClassLoader ul = new URLClassLoader(urls);
        Class c = ul.loadClass("com.proxy.$proxy1");

        //反射
        Constructor constructor = c.getConstructor(InvocationHandler.class);
        Object object = constructor.newInstance(handler);
        return object;
    }
}

自动生成的Java代理对象如下：
package com.proxy;
public class $proxy1 implements com.test.UserManager{
    public $proxy1(InvocationHandler h) {
        super();
        this.h = h;
    }
    InvocationHandler h;
    @Override
    public void addUsers() {
        java.lang.reflect.Method method;
        try {
            method = com.test.UserManager.class.getMethod("addUsers");
            h.invoke(method);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
该类就是自动生成的代理类，跟聚合时使用的代理有点像，只是那个被代理类对代理类是透明的，被代理对象在TimeHandler中声明，并通过反射，将被代理对象的方法交给TimeHandler来做。如此，我们便可代理任何借口的任意方法，比如下面我要在实现了Moveable接口的Tank类里面的方法统计时间，只需如下操作：
public class Client {
    public static void main(String[] args) throws Exception {
        Moveable t = new Tank();
        InvocationHandler h = new TimeHandler(t);
        Moveable moveable = (Moveable)Proxy.newProxyInstance(Moveable.class, h);
        moveable.move();
    }

}
Java动态代理技术的强大由此可见一斑！

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【平面图转对偶图】【最短路】【Beijing 2006】【bzoj 1001】狼抓兔子
1001: [BeiJing2006]狼抓兔子
Time Limit: 15 Sec  Memory Limit: 162 MB
Submit: 13409  Solved: 3191

Description
现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形： 
 
左上角点为(1,1),右下角点为(N,M)(上图中N=4,M=5).有以下三种类型的道路 1:(x,y)<==>(x+1,y) 2:(x,y)<==>(x,y+1) 3:(x,y)<==>(x+1,y+1) 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦.
Input
第一行为N,M.表示网格的大小，N,M均小于等于1000.接下来分三部分第一部分共N行，每行M-1个数，表示横向道路的权值. 第二部分共N-1行，每行M个数，表示纵向道路的权值. 第三部分共N-1行，每行M-1个数，表示斜向道路的权值. 输入文件保证不超过10M
Output
输出一个整数，表示参与伏击的狼的最小数量.
Sample Input
3 4
5 6 4
4 3 1
7 5 3
5 6 7 8
8 7 6 5
5 5 5
6 6 6

Sample Output
14

HINT
2015.4.16新加数据一组，可能会卡掉从前可以过的程序。

题解：
是一道论文题——>浅析最大最小定理在信息学竞赛中的应用 
第一眼看上去以为是裸的网络流，后来发现复杂度有些吃翔。。但是发现有不少人都用网络流水过了。。 
然后去学了一下平面图转对偶图，发现非常神奇，详见论文所说，这里就不多说了。
Code：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 2001000
#define inf 0x7fffffff

struct Edge{
    int v,next,k;
}edge[N<<2];
int n,m,ans,num=0,S,T,head[N],dis[N],q[N*5];
bool vis[N];

int in(){
    int x=0; char ch=getchar();
    while (ch<'0' || ch>'9') ch=getchar();
    while (ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}

void add(int u,int v,int k){
    edge[++num].v=v; edge[num].k=k;
    edge[num].next=head[u]; head[u]=num;
}

void spfa(){
    int h=0,t=1;
    memset(dis,127/3,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[S]=0,vis[S]=1,q[h]=S;
    while (h<t){
        int u=q[h]; vis[u]=0; h++;
        if (h>=N*5) h=0,t=1;
        for (int i=head[u]; i; i=edge[i].next){
            int v=edge[i].v;
            if (dis[v]>dis[u]+edge[i].k){
                dis[v]=dis[u]+edge[i].k;
                if (!vis[v]) vis[v]=1,q[t++]=v;
            }
        }
    }
    ans=dis[T];
}

void build(){
    S=0,T=((n-1)*(m-1))<<1|1;
    for (int i=1; i<=n; i++)
        for (int j=1; j<m; j++){
            int x=in(),u,v;
            if (i==1) u=S,v=j;
            else if (i==n) u=((i-2)<<1|1)*(m-1)+j,v=T;
            else u=((i-2)<<1|1)*(m-1)+j,v=((i-1)<<1)*(m-1)+j;
            add(u,v,x),add(v,u,x);
        }
    for (int i=1; i<n; i++)
        for (int j=1; j<=m; j++){
            int x=in(),u,v;
            if (j==1) u=((i-1)<<1|1)*(m-1)+1,v=T;
            else if (j==m) u=S,v=((i-1)<<1|1)*(m-1);
            else u=((i-1)<<1)*(m-1)+j-1,v=((i-1)<<1|1)*(m-1)+j;
            add(u,v,x),add(v,u,x);
        }
    for (int i=1; i<n; i++)
        for (int j=1; j<m; j++){
            int x=in(),u,v;
            u=((i-1)<<1)*(m-1)+j,v=((i-1)<<1|1)*(m-1)+j;
            add(u,v,x),add(v,u,x);
        }
}

int main(){
    n=in(),m=in();

    if (n==1 || m==1){
        if (n>m) swap(n,m);
        ans=inf;
        for (int i=1; i<m; i++){
            int x=in();
            ans=min(ans,x);
        }
        if (ans==inf) ans=0;
        printf("%d\n",ans);
        return 0;
    }

    build(); spfa();

    printf("%d\n",ans);
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 3342 Legal or Not

Legal or Not

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)

Total Submission(s): 6097    Accepted Submission(s): 2839




Problem Description

ACM-DIY is a large QQ group where many excellent acmers get together. It is so harmonious that just like a big family. Every day,many "holy cows" like HH, hh, AC, ZT, lcc, BF, Qinz and so on chat on-line to exchange their ideas. When someone has questions,
 many warm-hearted cows like Lost will come to help. Then the one being helped will call Lost "master", and Lost will have a nice "prentice". By and by, there are many pairs of "master and prentice". But then problem occurs: there are too many masters and too
 many prentices, how can we know whether it is legal or not?

We all know a master can have many prentices and a prentice may have a lot of masters too, it's legal. Nevertheless，some cows are not so honest, they hold illegal relationship. Take HH and 3xian for instant, HH is 3xian's master and, at the same time, 3xian
 is HH's master,which is quite illegal! To avoid this,please help us to judge whether their relationship is legal or not. 

Please note that the "master and prentice" relation is transitive. It means that if A is B's master ans B is C's master, then A is C's master.

 


Input

The input consists of several test cases. For each case, the first line contains two integers, N (members to be tested) and M (relationships to be tested)(2 <= N, M <= 100). Then M lines follow, each contains a pair of (x, y) which means x is y's master and
 y is x's prentice. The input is terminated by N = 0.
TO MAKE IT SIMPLE, we give every one a number (0, 1, 2,..., N-1). We use their numbers instead of their names.

 


Output

For each test case, print in one line the judgement of the messy relationship.
If it is legal, output "YES", otherwise "NO".

 


Sample Input

3 2
0 1
1 2
2 2
0 1
1 0
0 0


 


Sample Output

YES
NO题意：判断是否成环即可！#include<stdio.h>
#include<string.h>
#define N 150
int n,m;
int map[N][N],queue[N],in[N];
void topo()
{
    int i,m,j;
    for(j=0;j<n;j++)
    {
        int m=300;
      for(i=0;i<n;i++)//判断入度为零 
       {
               if(in[i]==0)
               {
               m=i;
               break;
               }
       }
       if(m==300)//入度都不为零，则表示有环！ 
       {
       printf("NO\n");
       return ;
       }
       in[m]=-1;
       for(i=0;i<n;i++)//与M相连的入度减一 
        {
        if(map[m][i]==1)
        in[i]--;
        }
    }
    printf("YES\n");
    return ;
}
int main()
{
    while(scanf("%d%d",&n,&m),n,m)
    {
        memset(map,0,sizeof(map));
        memset(in,0,sizeof(in));
        int i,j;
        for(i=0;i<m;i++)
         {
             int a,b;
             scanf("%d%d",&a,&b);
             if(map[a][b]!=1)// 避免重边 
             {
             map[a][b]=1;
             in[b]++;
            }
         }
         topo();
    }
}


 

版权声明：本文为博主原创文章，未经博主允许不得转载。

去哪网实习总结：windows下配置JavaWeb环境、开发helloworld、发布系统（附截图，绝对详细）（JavaWeb）



本来是以做数据挖掘的目的进去哪网的，结构却成了系统开发。。。

不过还是比较认真的做了三个月，老师很认同我的工作态度和成果。。。

实习马上就要结束了，总结一下几点之前没有注意过的变成习惯和问题，分享给大家。




同时打个广告：去哪网内审部招JavaWeb开发实习生，时间非常自由，每周一天、周六周日甚至都可以，时间充裕的小伙伴给我留言啊，挣个零花钱，还能长点经验。。。。（保研的、想工作的大四狗最合适不过了。。。）









参考：http://blog.csdn.net/wangqiuyun/article/details/8953940




0、准备软件：

在D:\JavaTools下，准备






一、安装JDK

1、讲JDA装在D:\JavaTools\jdk1.6.0_20下面。安装JDK过程中会自动运行安装jre，将jre装在D:\JavaTools\jre6下面。

2、环境变量配置：右击“我的电脑”，点击“属性”；选择“高级”选项卡，点击“环境变量”； 在“系统变量”中，设置2项属性，JAVA_HOME和Path，若已存在则点击“编辑”，不存在则点击“新建”；一般Path都是已经存在的。


3、配置如下：

JAVA_HOME
D:\JavaTools\jdk1.6.0_20
Path
%JAVA_HOME%\bin;

注意：Path的变量值一般加到原来值的前面，用分号隔开。

4、验证安装成功与否：

“开始”－>;“运行”，键入“cmd”；键入命令“java -version”，“java”，“javac”几个命令，出现画面，说明环境变量配置成功。






二、安装tomcat

1、.zip的压缩包直接解压即可。

2、验证安装：打开浏览器，键入http://localhost:8080/，如果出现一下页面即安装成功：






解压后的tomcat下面的目录结构是这样的：

bin:存放tomcat启动和关闭命令的路径

conf:存放tomcat的配置文件，所有的配置文件都放在这里 

lib:存放tomcat服务的核心类库文件jar文件



webapps:该路径用于部署web应用

3. 解压后发现在bin文件夹下双击startut.bat启动tomcat，双击shoutdown.bat 就可以关闭 tomcat 了。










三、eclipse安装与配置

1、直接解压到D:\eclipse；

2、运行eclipse，设置workspace为默认目录：

3、接着进行eclipse配置，先是jre，一般此项已经配置好的，如下图（windows-->preferences）：



4、然后是web应用服务器配置，步骤如下图：





点击Add。。。





选中Tomcat v6.0，然后Next。。。


选中Tomcat的安装路径D:\JavaTools\tomcat6.0.44，及默认的jre，Finish即可。







四、MySQL安装与配置


参考：http://blog.csdn.net/wangqiuyun/article/details/8953940





五、新建第一个工程


file-->new-->other-->web-->Dynamic Web project-->next-->下图：



next-->next-->finish，得到如下工程：




选中WebContent，右键new-->JSP File，命名为index.jsp，finish即可。

在index.jsp的body标签中输入你想要显示的内容：“index.jsp==>hello world”，然后：




跳出下面页面：




此时：报错信息The superclass "javax.servlet.http.HttpServlet"
 was not found on the Java Build Path

http://blog.csdn.net/fei20072050104/article/details/21785565，

具体的解决方法：



1、右击web工程-》属性或Build Path-》Java Build Path->Libraries-> Add Libray...->Server Runtime
 -》Tomcat Server

2、切换到Java Build Path界面中的Orader and
 Export，选择Tomcat。



效果图如下：










六、导出工程到服务器：


右键Demo项目-----export-----WAR file-------Destination选为C:\Users\username\Desktop\Demo.war，点击finish。

把Demo.war复制到D:\JavaTools\tomcat6.0.44\webapps下，并到D:\JavaTools\tomcat6.0.44\bin运行startup.bat，最后在浏览器地址栏输入http://localhost:8080/Demo/demo.jsp，显示出demo.jsp中的内容，到此一个完整的java
 web结束。










如果是让局域网其他电脑可以访问网站，则开始------输ipconfig，查看ip

http://ip:8080/project/index.jsp










至此，去哪儿网实习结束。。。。。

其他总结：



去哪网实习总结：JavaWeb中文传参乱码问题的解决（JavaWeb）


去哪网实习总结：JavaWeb配置404页面（JavaWeb）


去哪网实习总结：JAVA读XML文件节点信息（JavaWeb）

去哪网实习总结：递归构建“流程执行顺序”的XML文件（JavaWeb）


去哪网实习总结：已完毕，但是网页上有错误（JavaWeb）


去哪网实习总结：JavaWeb中使用jquery提交表单（JavaWeb）


去哪网实习总结：easyui在JavaWeb中的使用，以datagrid为例（JavaWeb）


去哪网实习总结：java读写excel表格（JavaWeb）


去哪网实习总结：定时发送邮件（JavaWeb）

去哪网实习总结：开发定时任务（JavaWeb）



去哪网实习总结：如何有效减少对数据库的访问（JavaWeb）


去哪网实习总结：如何获取Web项目的根目录（JavaWeb）

去哪网实习总结：怎样配置数据库连接（JavaWeb）
  




版权声明：本文为博主原创文章，未经博主允许不得转载。

【C语言探索之旅】第三部分第三课：SDL开发游戏之显示图像









内容简介

1、第三部分第三课： SDL开发游戏之显示图像

2、第三部分第四课预告： SDL开发游戏之事件处理





第三部分第三课：SDL开发游戏之显示图像




上一课中，我们学习了如何加载SDL库（SDL_Init），释放SDL库（SDL_Quit），如何打开一个窗口（Window），如何使用表面（Surface）。





这些都是SDL库最最基本的操作。暂时，我们只会给窗口自带的表面上点颜色，好像挺乏味的。




这一课我们来学习如何插入图片。上一课我们说过，SDL中绘制图样需要在Surface上进行。Surface就好像一个画板。所以，我们来学习如何在Surface上“贴上”图片。





然而，SDL的库默认只能载入BMP格式的图片，那我们要载入其他格式（PNG，JPG，GIF等）的图片怎么办呢？




我们就需要使用到SDL_image这个SDL的插件（或称扩展）。我们会学习如何给SDL库安装插件。




还将学习如何设置图片的透明度。




老的SDL版本一般是1.2版，但是目前已经不再怎么更新了吧。SDL官网最新的稳定版本（截止2015年8月13日）是SDL2.0.3，有人说2.0.4版也快发布了。




SDL1.2到SDL2.0，是一个很大的飞跃，增加了很多新的元素，性能也增强了很多。




不过可惜的是SDL2的API不向后兼容，不过一般来说SDL1.2编写的程序要迁移到SDL2.0，改动是不太大的。官网也有migration（迁移）的教程贴（全是英语，又一次“论学好英语对编程的帮助”，虽不是必须，但做编程不会英语是很可惜的）：

http://wiki.libsdl.org/MigrationGuide




推荐一个不错的百度贴吧：SDL吧

http://tieba.baidu.com/f?kw=sdl&ie=utf-8




如果你英语还不错，那么SDL官网的WiKi毫无疑问是最好的老师了，所有你想知道的SDL的知识几乎都在WiKi里：

http://wiki.libsdl.org/




注：小编会在Mac OS下的XCode上用SDL2来编写演示下面的课程。其他平台（Windows，Linux等）类似，就是环境配置略有不同，也会讲解如何配置。SDL具有可移植性。





加载BMP格式的图片





加载图片是开发游戏很基本很重要的一点，因为游戏中的精灵（sprite）是由一张张图片构成的。





基础的SDL库是比较简单的，为了节省代码量，它只支持加载一种图片格式：BMP，这种图片的后缀是 .bmp。





虽然我们平时用的图片格式是PNG和JPG居多，但是BMP也是一种常用的格式。




BMP取自位图BitMaP的缩写，也称为DIB（与设备无关的位图），是微软视窗图形子系统（Graphics Device Interface）内部使用的一种位图图形格式，它是微软视窗平台上的一个简单的图形文件格式。




BMP文件通常是不压缩的，所以它们通常比同一幅图像的压缩图像文件格式要大很多。例如，一个800×600的24位几乎占据1.4MB空间。因此它们通常不适合在因特网或者其他低速或者有容量限制的媒介上进行传输。但是BMP文件被电脑读取也快一些，毕竟不需要解压缩这一步。




但是也不要担心，正如开头我们所说，我们可以通过给SDL添加一个插件SDL_image，获得加载其他各种图片格式的能力。





加载BMP图片





要加载BMP图片，在SDL中我们只需要调用SDL_LoadBMP函数。





函数原型如下：



SDL_Surface* SDL_LoadBMP(const char* file)





这个函数很简单，只有一个参数，就是一个字符串，指明要加载的BMP图片的路径。




返回值则是一个SDL_Surface的指针。




我们就来加载下面这个BMP图像试试吧（下面的图片是JPG格式的，因为BMP格式太大，有1.4MB，所以我制作成了JPG格式，小很多。大家可以下载这个图片，然后转存为BMP格式，或者用自己的图片）:










代码如下：



#include <SDL2/SDL.h>
#include <unistd.h>

/* 窗口宽和高 */
#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600
/* 窗口标题 */
#define WINDOW_TITLE "SDL窗口"
/* 窗口 */
SDL_Window* window = NULL;
/* 窗口自带的表面（Surface） */
SDL_Surface* screen = NULL;
/* 加载BMP图片后返回的表面 */
SDL_Surface* image = NULL;

int main(int argc, char* args[])
{
   if(SDL_Init(SDL_INIT_VIDEO) < 0) {  // 如果初始化SDL失败
       printf("SDL2 不能被初始化，SDL2_Error : %s\n", SDL_GetError());
   } else {
      // 创建宽800像素，高600像素的窗口。
       window = SDL_CreateWindow(WINDOW_TITLE,
                                 SDL_WINDOWPOS_CENTERED,
                                 SDL_WINDOWPOS_CENTERED,
                                 WINDOW_WIDTH,
                                 WINDOW_HEIGHT,
                                 SDL_WINDOW_SHOWN);
      // 取得窗口自带的表面
       screen = SDL_GetWindowSurface(window);
      // 加载BMP图片
       image = SDL_LoadBMP("/Users/enmingxie/Desktop/TestSDL2/ubuntu.bmp");
     
      // 将BMP图片的表面贴到窗口自带的表面上
       SDL_BlitSurface(image, NULL, screen, NULL);
      // 刷新窗口表面
       SDL_UpdateWindowSurface(window);
       
   }
   pause();  // 暂停
   
   SDL_FreeSurface(image);    // 释放BMP图片表面
   SDL_DestroyWindow(window);  // 释放窗口
   SDL_Quit();   // 释放SDL
   
   return 0;
}








运行结果如下图所示：











我们的BMP图片的原始像素是800 x 600，所以正好填充满整个窗口（窗口也是 800 x 600）。




上面代码通过注释应该不难理解，不过我们还是讲一下其中的一个函数SDL_BlitSurface。




这个函数的作用是将一个表面贴到另一个表面上。




我们创建一个窗口（window）后，窗口自带一个表面，可以由SDL_GetWindowSurface取得。这个表面如果不做设定，默认是没有颜色的（也就是黑色）。如果把这个表面看成一张黑色的纸面，那么我们还可以创建很多其他大大小小的纸面（Surface），黏贴到这张纸面上。




函数原型如下：



int SDL_BlitSurface(SDL_Surface* src, const SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect)





这个函数接受四个参数：








src



源表面，也就是要黏贴的那个表面






srcrect



一个SDL_Rect结构体，代表了黏贴的表面的位置和宽高；如果设定为NULL，那么就是拷贝整个表面





dst



目的表面，也就是被黏贴的那个表面





dstrect



一个SDL_Rect结构体，代表了被贴的表面的位置和宽高；如果设定为NULL即可，那就是从表面左上角开始拷贝








返回值：


0 ：如果黏贴成功。

一个负值：代表错误信息，如果失败。可以调用SDL_GetError函数来获得错误信息。





顺便介绍一下SDL_Rect结构体的定义：




Rect是rectangle的前四个字母，就是英语“矩形”的意思。所以SDL_Rect就是SDL的矩形的结构体定义。




在SDL源代码中，此结构体的定义如下：



typedef struct{
  Sint16 x, y;
  Uint16 w, h;
} SDL_Rect;





这个结构体包含四个参数：









x



矩形的左上角的横坐标值





y



矩形的左上角的纵坐标值





w



矩形的宽





h



矩形的高








给应用添加图标




通常我们创建一个应用程序（游戏也是一种应用程序），都会给它添加自定义的图标。一般我们都说图标是icon，是英语“图标”的意思。




如果没有添加图标，那么应用被添加到桌面或者是任务栏时都会是空白的，很难看。一般来说，添加的图标也会显示在打开应用时的窗口的左上角，增加美观度。





那么我们如何给窗口添加图标呢？




用SDL_SetWindowIcon函数就可以。




函数原型如下：



void SDL_SetWindowIcon(SDL_Window* window, SDL_Surface* icon)





这个函数没有返回值，接受两个参数，第一个参数不难理解，就是要添加图标的那个窗口，第二个参数是加载图标的图片后返回的表面。




第二个参数的类型又是SDL_Surface* 这个指针，所以我们可以用加载BMP图像来得到图标所对应的那个表面。




我们要添加的图标如下：










完整代码如下：



#include <SDL2/SDL.h>
#include <unistd.h>

/* 窗口宽和高 */
#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600
/* 窗口标题 */
#define WINDOW_TITLE "SDL窗口"
/* 窗口 */
SDL_Window* window = NULL;
/* 窗口自带的表面（Surface） */
SDL_Surface* screen = NULL;
/* 加载BMP图片后返回的表面 */
SDL_Surface* image = NULL;
/* 加载图标后返回的表面 */
SDL_Surface* icon = NULL;

int main(int argc, char* args[])
{
   if(SDL_Init(SDL_INIT_VIDEO) < 0) {  // 如果初始化SDL失败
       printf("SDL2 不能被初始化，SDL2_Error : %s\n", SDL_GetError());
   } else {
       // 创建宽800像素，高600像素的窗口。
       window = SDL_CreateWindow(WINDOW_TITLE,
                                 SDL_WINDOWPOS_CENTERED,
                                 SDL_WINDOWPOS_CENTERED,
                                 WINDOW_WIDTH,
                                 WINDOW_HEIGHT,
                                 SDL_WINDOW_SHOWN);
       // 加载图标的图片
       icon = SDL_LoadBMP("/Users/enmingxie/Desktop/TestSDL2/mushroom.bmp");
       // 设置窗口图标
       SDL_SetWindowIcon(window, icon);
       
       // 取得窗口自带的表面
       screen = SDL_GetWindowSurface(window);
       
       // 加载BMP图片
       image = SDL_LoadBMP("/Users/enmingxie/Desktop/TestSDL2/ubuntu.bmp");
       
       // 将BMP图片的表面贴到窗口自带的表面上
       SDL_BlitSurface(image, NULL, screen, NULL);
       
       // 刷新窗口表面
       SDL_UpdateWindowSurface(window);
   }
   pause();  // 暂停
   
   SDL_FreeSurface(image);     // 释放BMP图片表面
   SDL_DestroyWindow(window);  // 释放窗口
   SDL_Quit();   // 释放SDL
   
   return 0;
}








运行一下代码。




在Mac OS中，虽然在xCode中运行时不会在窗口左上角产生图标，但是应用的图标是会改变成这只萌萌的大蘑菇的（再看我，再看我就把你吃掉...）：










如果是在Windows中，那么是会在窗口左上角出现这个蘑菇的图标的。





使用SDL_image插件，加载更多类型图片





SDL默认只支持加载BMP类型的图片，虽说这种类型的图片在游戏开发中可以使游戏加载更快（不需要对图片进行解压缩），但是今天我们在网络上传播时一般使用JPG，PNG，GIF等图片格式。




SDL存在不少插件，这些插件就好像平时我们用浏览器，例如Chrome，火狐之类，也会有add-on（称为扩展或插件），我们只需要安装到浏览器，就能获得额外的功能。SDL的基本功能虽然很强大，但是如果有了更多插件的配合，则威力更甚。





SDL的一些插件的汇总页面：

http://www.libsdl.org/projects/




在这个页面，有一个项目，SDL_image，就是我们此处要使用的插件：




只要安装了这个插件，那么SDL在BMP图片格式以外，还可以支持：GIF, JPEG, LBM, PCX, PNG, PNM, TGA, TIFF, WEBP, XCF, XPM, XV 这些图片格式。




我们来到SDL_image的主页：

http://www.libsdl.org/projects/SDL_image/




我们所要安装的包是Development Libraries对应的那个，不是Runtime Binaries对应的那个。Development Libraries是英语“开发库”的意思，就是我们做开发的时候需要用到的库。Runtime Binaries是英语“运行时二进制文件”的意思，是安装以后可以供运行应用的安装包，只用于运行，不用与开发。





Windows下安装SDL_image插件





一般在Windows中我们使用SDL做开发，会用到的IDE是Codeblocks或者Visual C++（也包含在Visual Studio中）。




Codeblocks安装SDL_image插件









下载那个 SDL2_image-devel-2.0.0-mingw.tar.gz 的文件，解压。





打开你的SDL项目，点击菜单栏中的 项目->属性



点击 Project's Build Options... 按钮







添加 -lSDL2_image




然后，如果系统是32位Windows的，则把对应的那些DLL文件都放到 C:\WINDOWS\SYSTEM32 文件夹下；如果是64位Windows系统，则把对应的那些DLL文件都放到 C:\Windows\SysWOW64 文件夹下。





Visual C++安装SDL_image插件










下载那个 SDL2_image-devel-2.0.0-VC.zip的文件，解压。





打开你的SDL项目，点击 项目 -> 属性：



























然后，如果系统是32位Windows的，则把对应的那些DLL文件都放到 C:\WINDOWS\SYSTEM32 文件夹下；如果是64位Windows系统，则把对应的那些DLL文件都放到 C:\Windows\SysWOW64 文件夹下。




小编我发现了，Windows下面开发SDL是最麻烦的... 在Linux和Mac OS X下SDL的各种配置都没有Windows下面那么麻烦，也是醉了。





怪不得好多读者在Windows下一直配置SDL2不成功，而且64位Windows和32位Windows的配置也有差异，Win XP，Win 7和Win8什么的也有差异。





Linux下安装SDL_image插件




如果你使用的是Ubuntu，Fedora，CentOS之类常用的Linux发行版，那么安装很简单。只需要用命令行来安装即可：





Debian一族或Ubuntu中安装SDl_image插件：


sudo apt-get install libsdl2-image-dev


Redhat一族或Fedora或CentOS中安装SDl_image插件：


sudo yum install SDL2_image-devel






如果你的Linux发行版没有如上所示的包管理软件可以帮你快速安装SDL_image插件，那也不要急，你可以下载其源码，自己编译，安装：





下载源代码
去SDL_image的页面，下载那个 Source 下面的随意一个，一般推荐下载tar.gz的那个：




解压文件


（如果下载的是那个zip文件，那么也可以用对应解压软件解压）

tar zxvf SDL_image-2.0.0.tar.gz


编译源码



cd SDL_image-2.0.0
./configure
make


安装



sudo make install







Mac下安装SDL_image插件










下载Development Libraries（不是Runtime Binaries）下的那个 SDL2_image-2.0.0.dmg 文件。




打开Finder，也可以随便打开哪个文件夹，同时按下 Cmd + Shift + G这三个键，就会打开一个对话框，输入 /Library/Frameworks










点击“前往”，就到了 /Library/Frameworks 这个文件夹中。




双击下载的SDL2_image-2.0.0.dmg文件，会解压为如下所示：










将其中的 SDL2_image.framework 这个文件拷贝到/Library/Frameworks 这个文件夹中，会让你输入管理员密码。输入后，确定，拷贝完毕：










然后进入你的xCode中的SDL的项目，点击项目名称，就会显示设置页。可以看到Link Binary With Libraries 那栏目前只有一个SDL2.framework（此前我们创建SDL2的项目时添加的），我们需要添加 SDL2_image.framework。点击那个加号，如下图：











点击+号之后会弹出如下窗口，点击 Add Others：










然后用老方法，同时按下 Cmd + Shift + G这三个键，就会打开一个对话框，输入 /Library/Frameworks










点击Go，进入/Library/Frameworks，选择SDL2_image.framework，点击Open；或者双击SDL2_image.framework文件也可以：










SDL2_image.framework就添加到我们xCode的SDL项目的链接库中了，可以看到多了一项：

















如何调用SDL_image的内容





要想调用SDL_image库的内容，其实很简单，只需要在程序的开头处插入一个预处理命令：




Linux或者Windows平台如下：
#include <SDL/SDL_image.h>





Mac OS X与其他平台不一样，使用：
#include <SDL2_image/SDL_image.h>





加载图片




一般来说，只需要使用一个函数即可：IMG_Load，这个函数可以接受任意格式（只要是SDL_image支持的格式）的图片作为参数。




函数原型：
SDL_Surface* IMG_Load(const char *file)





可以看到与之前加载BMP图片的SDL_LoadBMP函数是很类似的。唯一的参数就是图片的路径，返回值也是一个SDL_Surface指针。




我们来试着加载一个PNG格式的图片（以Mac OS X下为例，所以如果是其他平台，记得将代码中的#include <SDL2_image/SDL_image.h> 改为 #include <SDL/SDL_image.h>）：




我们要载入的PNG图片如下：











代码如下：



#include <unistd.h>
#include <SDL2/SDL.h>
#include <SDL2_image/SDL_image.h>

/* 窗口宽和高 */
#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600
/* 窗口标题 */
#define WINDOW_TITLE "SDL窗口"
/* 窗口 */
SDL_Window* window = NULL;
/* 窗口自带的表面（Surface） */
SDL_Surface* screen = NULL;
/* 加载BMP图片后返回的表面 */
SDL_Surface* image = NULL;
/* 加载图标后返回的表面 */
SDL_Surface* icon = NULL;
/* 加载PNG图片后返回的表面 */
SDL_Surface* pngImage = NULL;
/* PNG图片的矩形：左上角横、纵坐标，宽，高 */
SDL_Rect positionPNG;

int main(int argc, char* args[])
{
   if(SDL_Init(SDL_INIT_VIDEO) < 0) {  // 如果初始化SDL失败
       printf("SDL2 不能被初始化，SDL2_Error : %s\n", SDL_GetError());
   } else {
       // 创建宽800像素，高600像素的窗口。
       window = SDL_CreateWindow(WINDOW_TITLE,
                                 SDL_WINDOWPOS_CENTERED,
                                 SDL_WINDOWPOS_CENTERED,
                                 WINDOW_WIDTH,
                                 WINDOW_HEIGHT,
                                 SDL_WINDOW_SHOWN);
       // 加载图标的图片
       icon = SDL_LoadBMP("/Users/enmingxie/Desktop/TestSDL2/mushroom.bmp");
       // 设置窗口图标
       SDL_SetWindowIcon(window, icon);
       
       // 取得窗口自带的表面
       screen = SDL_GetWindowSurface(window);
       
       // 加载BMP图片
       image = SDL_LoadBMP("/Users/enmingxie/Desktop/TestSDL2/ubuntu.bmp");
       
       // 将BMP图片的表面贴到窗口自带的表面上
       SDL_BlitSurface(image, NULL, screen, NULL);
       
       // 加载PNG图片
       pngImage = IMG_Load("/Users/enmingxie/Desktop/TestSDL2/frog.png");
       
       // 设置PNG图片的矩形
       positionPNG.x = 125; // 左上角横坐标
       positionPNG.y = 100; // 左上角纵坐标
       positionPNG.w = 150; // 宽150像素
       positionPNG.h = 193; // 宽193像素
       
       // 将PNG图片的表面贴到窗口自带的表面上
       SDL_BlitSurface(pngImage, NULL, screen, &positionPNG);
       
       // 刷新窗口表面
       SDL_UpdateWindowSurface(window);
   }
   pause();  // 暂停
   
   SDL_FreeSurface(image);     // 释放BMP图片表面
   SDL_DestroyWindow(window);  // 释放窗口
   SDL_Quit();   // 释放SDL
   
   return 0;
}





运行，结果如下：











图片的透明度




设置图片的透明度（transparency）在开发游戏中十分常用。因为当我们有好多表面一张贴着一张时，有时候就需要设置某一些图片背景透明，不然会很难看。




有两种设置透明度的方式：





Color Keying：也就是采用设置三原色的方式，对图片的红，绿，蓝分别设置。使用函数：SDL_SetColorKey
函数原型：int SDL_SetColorKey(SDL_Surface* surface, int flag, Uint32 key)





surface



要更改的图片对应的表面指针





flag



如果是SDL_TRUE，则激活color key设置；如果是 SDL_FALSE，则不能设置color key





key



透明度像素




代码样例：

上面的代码将图片的蓝色完全变成透明，也就是完全抹去。大家可以用背景为蓝色的图片试一下。

SDL_Surface* loadedSurface = IMG_Load("图片路径");
SDL_SetColorKey(loadedSurface, SDL_TRUE, SDL_MapRGB(loadedSurface->format, 0, 0, 0xFF ));
}


Alpha混合：英语是Alpha Blending。使用函数SDL_SetSurfaceAlphaMod。
函数原型：
int SDL_SetSurfaceAlphaMod(SDL_Surface* surface, Uint8 alpha)





surface



要更改的图片对应的表面指针






alpha



alpha值，0~255之间的整数值。255表示完全不透明；0表示完全透明；所以数值从255到0透明度依次递增










总结





SDL中可以在Surface（表面）上载入图片，默认SDL只能载入BMP格式的图片。

我们可以安装SDL_image这个第三方库或者插件，使得SDL除了默认的BMP图片格式外，还能加载很多其他图片格式。

我们可以用SDL_SetColorKey来设置图片上某一种（几种）颜色的透明（也就是不显示）。

我们可以用SDL_SetSurfaceAlphaMod来设置图片整体的透明度，从255~0的整数范围内取值。255表示完全不透明，0表示完全透明（图片消失）。






第三部分第四课预告：




今天的课就到这里，一起加油吧。

下一次我们学习：  SDL开发游戏之事件处理

版权声明：本文为博主原创文章，转载请务必注明出处，否则追究法律责任。

【Cactus仙人掌图】仙人掌DP学习笔记
我们从例题入手来考虑仙人掌上DP的一般规律叭.
Ex 1.仙人掌上的单源最短路问题 
联想树上最短路,由于路径的唯一性可以直接做一遍O(n)的搜索.但是仙人掌上显然不具备路径的唯一性这种性质. 
那么我们是否需要像对待一般的无向连通图一样使用最短路算法呢? 
其实并不需要. 
首先一遍DFS处理出仙人掌的结构关系. 
然后我们从起点开始DP,假设当前DP到节点为x,那么枚举x的每一个儿子.如果该儿子节点是一个普通节点,那么我们直接可以得到起点到这个节点的距离.如果该儿子节点是个环,则枚举环上每一个节点v,求出v到起点距离,再从v开始DP. 
同样是一个O(n)的DP.比起无脑跑最短路优越到不知道哪里去了!
Ex 2.求仙人掌的直径 
对于有边权和无边权的情况我们一起处理.(无边权当成边权为1) 
依然先考虑树的情况.对于树的直径,我们可以使用树形DP,对每个节点求出其深度和以其为根的子树的最大深度,然后每个节点不同儿子的最大深度+次大深度即为答案. 
那么仙人掌也是类似的. 
首先还是一次DFS处理出仙人掌的结构. 
先提出一个子仙人掌的概念,子仙人掌x为删掉节点x到根的所有简单路径上的边后x所在的连通块. 
在处理出仙人掌结构之后,我们对每个节点处理出其子仙人掌的最大深度. 
对于一个节点,依然可以使用不同儿子的最大深度+次大深度来更新答案. 
对于一个环,可以用环上每对节点的最大深度加上这对节点之间的最短路长度来更新答案. 
此时我们有两个方法来解决: 
1.枚举环上的一个节点,那么如果存在一个节点与当前节点的最短路是从当前节点出发顺时针走,这两个节点一定对应着环上的一个区间.而且不难发现,如果我们当前枚举的节点顺时针移动,这个区间的终点也会同样顺时针移动.处理这种两个端点都单调移动的RMQ问题，可以用单调队列来维护. 
2.我们从环的父亲开始,按向下走哪边比较近,把环分成两个部分.可以发现,这两部分内部点对的最短路一定在内部.因此对于每个结点，它在另一部分最短路是顺时针走的一定是一个前缀，最短路是逆时针走的是一个后缀，直接处理前缀max和后缀max即可。
根据这两个例题我们可以看出,除了要DFS处理仙人掌结构是一定的以外,仙人掌上非环点的DP其实和树上DP是基本一样的,在处理仙人掌DP时候比树上DP多的就是怎样处理环上的点. 
通常仙人掌上的DP都与距离有关,因此我们可以从上面两个例题中获取灵感来推广到更多问题.

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode-面试算法经典-Java实现】【204-Count Primes（统计质数）】
【204-Count Primes（统计质数）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Description: 
　　Count the number of prime numbers less than a non-negative number, n. 

题目大意
　　统计小于非负整数n的素数的个数。 

解题思路
　　使用见埃拉托色尼筛法。 

代码实现
算法实现类
public class Solution {

    public int countPrimes(int n) {

        if (n <= 1) {
            return 0;
        }

        // 默认所有的元素值都会设置为false
        boolean[] notPrime = new boolean[n];
        notPrime[0] = true;
        notPrime[1] = true;

        for (int i = 2; i * i < n; i++) {
            // 如果i是一个质数，i将i的倍数设置为非质数
            // 如是i是一个合数，则它必定已经设置为true了，因为是从2开始处理的
            if (!notPrime[i]) {
                for (int j = 2 * i; j < n; j += i) {
                    notPrime[j] = true;
                }
            }
        }

        // 统计质数的个数
        int result = 0;
        for (boolean b : notPrime) {
            if (!b) {
                result++;
            }
        }

        return result;
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/48021413】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu2768
链接：点击打开链接
题意：t组数据，c只猫，d只狗，v个人，v行每行有两个单词，单词的首字母代表动物的种类，第一个单词代表喜欢第二个代表不喜欢，问最大能满足多少个人，具体看样例，第一组数据C1 D1||D1 C1第一个人喜欢Cat1不喜欢Dog1，第二个人喜欢Dog1不喜欢Cat1，因此只能满足一个人，输出1
代码：#include <iostream>
#include <string.h>
#include <stdio.h>
#include <algorithm>
using namespace std;
struct node{
    int cat,dog;
}p1[505],p2[505];
int c,d,v,num1,num2;
int s[505][505],vis[505],match[505];
int dfs(int x){
    int i,j;
    for(i=1;i<num2;i++){
        if(!vis[i]&&s[x][i]){
            vis[i]=1;
            if(!match[i]||dfs(match[i])){
                match[i]=x;
                return 1;
            }
        }
    }
    return 0;
}
int hungarian(){
    int i,sum;
    sum=0;
    for(i=1;i<num1;i++){
        memset(vis,0,sizeof(vis));
        if(dfs(i))
        sum++;
    }
    return sum;
}                                       //匈牙利算法模板
int main(){                             //将喜欢猫的人放在左边的集合里喜欢狗的放在右面
    int i,j,t,a,b;                      //将产生矛盾的连在一起再用v减掉，因此用到二分图
    char ch;                            //匹配也就是匈牙利算法
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%d",&c,&d,&v);
        num1=num2=1;
        for(i=1;i<=v;i++){
            scanf(" %c%d %c%d",&ch,&a,&ch,&b);
            if(ch=='D'){                //喜欢猫的
                p1[num1].cat=a;
                p1[num1++].dog=b;
            }
            else{                       //喜欢狗的
                p2[num2].cat=b;
                p2[num2++].dog=a;
            }
        }
        memset(s,0,sizeof(s));
        memset(match,0,sizeof(match));
        for(i=1;i<num1;i++)
        for(j=1;j<num2;j++)
        if(p1[i].cat==p2[j].cat||p1[i].dog==p2[j].dog)
        s[i][j]=1;
        printf("%d\n",v-hungarian());
    }
    return 0;
}

﻿﻿


版权声明：本文为博主原创文章，未经博主允许不得转载。

如何去掉MyEclipse对JS等文件的验证
最近在做一个MyEclipse项目发现我的js文件可以正常运行，但是就是在js文件中有报错，但却不影响运行，搞得项目上面有个小红叉十分碍眼。众所周知，MyEclipse对js等文件的验证是十分严格的，所以我就在网上找了几种方法来解决这个问题。 
  1、选中当前工程，右键单击properties，弹出properties界面 
  2、然后选择MyEclipse—>validation—>Excluded Resource下找到不需要验证的文件或者文件夹 
  3、在不需要验证的文件或者文件夹前打勾 
  4、点击OK即可

解决MyEclipse提示“Cannot return from outside a function or method” 
  1、在MyEclipse菜单栏window —>preferences —>myeclipse —>validation —>javascript validator for Js    files 把Bulid 复选框的勾去掉 就可以了 
  2、在所建立的工程项目上右键单击，找到myeclipse–>Exclude Form Validation单击一下，打上√号，js的错误就没了！

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

poj 3422 Kaka's Matrix Travels 【最大费用最大流】【好题】

Kaka's Matrix Travels




Time Limit: 1000MS
 
Memory Limit: 65536K


Total Submissions: 8729
 
Accepted: 3498




Description

On an N × N chessboard with a non-negative number in each grid, Kaka starts his matrix travels with SUM = 0. For each travel, Kaka moves one rook from the left-upper grid to the right-bottom one, taking care that the rook moves
 only to the right or down. Kaka adds the number to SUM in each grid the rook visited, and replaces it with zero. It is not difficult to know the maximum SUM Kaka can obtain for his first travel. Now Kaka is wondering what is the maximum SUM he
 can obtain after his Kth travel. Note the SUM is accumulative during the K travels.

Input

The first line contains two integers N and K (1 ≤ N ≤ 50, 0 ≤ K ≤ 10) described above. The following N lines represents the matrix. You can assume the numbers in the matrix are no more than 1000.

Output

The maximum SUM Kaka can obtain after his Kth travel.

Sample Input
3 2
1 2 3
0 2 1
1 4 2

Sample Output
15




题意：给你一个N*N的矩阵，每个位置都有一定的点权，当你走到一个位置时，你可以获取该位置的点权。现在一个人要从左上角到右下角走K次，每次只能选择向下走或者向右走，问你走K次所能获得的最大权值和。 要求——每个点可以无限走，但点权只能获取一次。


我写了一个关于这类问题的讲解：点我


建图如下：设置超级源点sink，超级汇点source。


1，sink向起点左点建边，容量为K，费用为0；

2，拆点，每个点拆为容量为1，费用为点权的边；

3，<u, v>可达关系建边u左->v左、u左->v右、u右->v左、u右->v右。边的的容量为INF，费用为0；

4，终点到source建边，容量为K，费用为0。

最后跑一次最大费用最大流，结果就是最大权值和。






AC代码：


#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
#include <stack>
#define MAXN 5000+10
#define MAXM 1000000+10
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cap, flow, cost, next;
};
Edge edge[MAXM];
int head[MAXN], edgenum;
int dist[MAXN], pre[MAXN];
bool vis[MAXN];
int sink, source;
int N, K;
int Map[60][60];
void init()
{
    edgenum = 0;
    memset(head, -1, sizeof(head));
}
void addEdge(int u, int v, int w, int c)
{
    Edge E1 = {u, v, w, 0, c, head[u]};
    edge[edgenum] = E1;
    head[u]= edgenum++;
    Edge E2 = {v, u, 0, 0, -c, head[v]};
    edge[edgenum] = E2;
    head[v]= edgenum++;
}
int point(int x, int y)
{
    return (x-1) * N + y;
}
void getMap()
{
    int t = N*N;
    sink = 0, source = 2*t+1;
    for(int i = 1; i <= N; i++)
    {
        for(int j = 1; j <= N; j++)
        {
            scanf("%d", &Map[i][j]);
            addEdge(point(i, j), point(i, j) + t, 1, Map[i][j]);//拆点
            if(i < N)//四种情况
            {
                addEdge(point(i, j) + t, point(i+1, j), INF, 0);
                addEdge(point(i, j) + t, point(i+1, j) + t, INF, 0);
                addEdge(point(i, j), point(i+1, j), INF, 0);
                addEdge(point(i, j), point(i+1, j) + t, INF, 0);
            }
            if(j < N)//四种情况
            {
                addEdge(point(i, j) + t, point(i, j+1), INF, 0);
                addEdge(point(i, j) + t, point(i, j+1) + t, INF, 0);
                addEdge(point(i, j), point(i, j+1), INF, 0);
                addEdge(point(i, j), point(i, j+1) + t, INF, 0);
            }
        }
    }
    addEdge(sink, point(1, 1), K, 0);
    addEdge(point(N, N) + t, source, K, 0);
}
bool SPFA(int s, int t)
{
    queue<int> Q;
    memset(dist, -INF, sizeof(dist));
    memset(vis, false, sizeof(vis));
    memset(pre, -1, sizeof(pre));
    dist[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            Edge E = edge[i];
            if(dist[E.to] < dist[u] + E.cost && E.cap > E.flow)
            {
                dist[E.to] = dist[u] + E.cost;
                pre[E.to] = i;
                if(!vis[E.to])
                {
                    vis[E.to] = true;
                    Q.push(E.to);
                }
            }
        }
    }
    return pre[t] != -1;
}
void MCMF(int s, int t, int &cost, int &flow)
{
    cost = flow = 0;
    while(SPFA(s, t))
    {
        int Min = INF;
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            Edge E = edge[i];
            Min = min(Min, E.cap-E.flow);
        }
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost += edge[i].cost * Min;
        }
        flow += Min;
    }
}
int main()
{
    while(scanf("%d%d", &N, &K) != EOF)
    {
        init();
        getMap();
        int cost, flow;
        MCMF(sink, source, cost, flow);
        printf("%d\n", cost);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode-面试算法经典-Java实现】【205-Isomorphic Strings（同构字符串）】
【205-Isomorphic Strings（同构字符串）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Given two strings s and t, determine if they are isomorphic. 
　　Two strings are isomorphic if the characters in s can be replaced to get t. 
　　All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. 
　　For example, 
　　Given "egg", "add", return true. 
　　Given "foo", "bar", return false. 
　　Given "paper", "title", return true. 

题目大意
　　给定两个字符串s和t，判断它们是否是同构的。如果字符串s可以通过字符替换的方式得到字符串t，则称s和t是同构的。字符的每一次出现都必须被其对应字符所替换，同时还需要保证原始顺序不发生改变。两个字符不能映射到同一个字符，但是字符可以映射到其本身。 

解题思路
　　【只要s和t满足一一映射就可以了】 
　　使用一个哈希表map维护两个字符串中字符的映射关系，同时用一个set保存映射的值。(s[i], t[i])，如是s[i]键没有在map中出现过并且t[i]没有在set中出现过，就加入到映射关系中，t[i]值已经出现过，说明是多对一映射，不符合返回false。s[i]键如果已经出现过，设为s[k]，对应的映射值为t[k]),即s[i]==s[k],则找出s[k]的对对应值t[k]，如果t[i]!=t[k],说明一个同一个字符存在两个不同的映射，两个字符串不是同构的，返回false，继续处理下一个字符，直到结束。 

代码实现
算法实现类
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class Solution {

    public boolean isIsomorphic(String s, String t) {

        // 两个字符串都为空
        if (s == null && t == null) {
            return true;
        }
        // 只有一个为空
        else if (s == null || t == null) {
            return false;
        }
        // 两个字符串的长度都为0
        else if (s.length() == 0 && t.length() == 0) {
            return true;
        }
        // 两个字符串的长度不相等
        else if (s.length() != t.length()) {
            return false;
        }

        // 保存映射关系 
        Map<Character, Character> map = new HashMap<>(s.length());
        Set<Character> set = new HashSet<>(t.length());
        char sChar;
        char tChar;
        for (int i = 0; i < s.length(); i++) {
            sChar = s.charAt(i);
            tChar = t.charAt(i);

            // 键未出现过，就保存映射关系
            if (!map.containsKey(sChar)) {
                if (set.contains(tChar)) {
                    return false;
                } else {
                    map.put(s.charAt(i), t.charAt(i));
                    set.add(tChar);
                }
            }
            // 如是键已经出现过
            else {

                // 原先的键映射的值是map.get(sChar)，现在要映射的值是tChar
                // 如果两个值不相等，说明已经映射了两次，不符合，返回false
                if (map.get(sChar) != tChar) {
                    return false;
                }
            }
        }
        return true;
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/48021425】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【bzoj2595】【WC2008】【游览计划】
2595: [Wc2008]游览计划
Time Limit: 10 Sec  Memory Limit: 256 MBSec  Special Judge 
Submit: 849  Solved: 344 
[Submit][Status][Discuss] 
Description 
 
 
Input
第一行有两个整数，N和 M，描述方块的数目。  
接下来 N行， 每行有 M 个非负整数， 如果该整数为 0， 则该方块为一个景点； 
否则表示控制该方块至少需要的志愿者数目。 相邻的整数用 （若干个） 空格隔开， 
行首行末也可能有多余的空格。
Output
由 N + 1行组成。第一行为一个整数，表示你所给出的方案 
中安排的志愿者总数目。  
接下来 N行，每行M 个字符，描述方案中相应方块的情况：  
z  ‘_’（下划线）表示该方块没有安排志愿者；  
z  ‘o’（小写英文字母o）表示该方块安排了志愿者；  
z  ‘x’（小写英文字母x）表示该方块是一个景点；  
注：请注意输出格式要求，如果缺少某一行或者某一行的字符数目和要求不 
一致（任何一行中，多余的空格都不允许出现） ，都可能导致该测试点不得分。
Sample Input
4 4  
0 1 1 0  
2 5 5 1  
1 5 5 1  
0 1 1 0
Sample Output
6  
xoox  
___o  
___o  
xoox
HINT
对于100%的数据，N,M,K≤10，其中K为景点的数目。输入的所有整数均在[0,2^16]的范围内
Source
Ljcc930提供SPJ
这个东西好像叫斯坦纳树。 
大体的思路是这样的：我们需要做两种dp 
第一个是一个状压，我们将每个景点是否到达的压成二进制，然后dp一下。 
p为k的子集：f[i][j][k]=f[i][j][p|b[i][j]]+f[i][j][(k-p)|b[x][y]] 
我们可以这样去枚举子集：for(p=k;p;p=k&(p-1)) 
再对于每一个状态k，我们求完状压之后，再写一个类似于spfa的dp，用之前状压求出的数组去向各个方向更新。 
设xx=x+xi[i],yy=y+yi[i]; 
f[xx][yy][k|b[xx][yy]]=f[x][y][k]+a[xx][yy] 
其实这个东西的复杂度巨高无比，应该没有什么卵用吧。
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
#define inf 210000000
struct S{int x,y,k;};
S use,pre[15][15][1<<11],q[1000000];
int n,m,tot=0,f[15][15][1<<11],a[15][15],b[15][15],ans[15][15],h,t;
int xi[4]={-1,0,0,1},yi[4]={0,-1,1,0};
bool check[15][15][1<<11];
void spfa(int k)
{
    int xx,yy,i;
    while(h<=t){
        S now=q[h];
        check[now.x][now.y][k]=true;
        for(i=0;i<4;i++){
            xx=now.x+xi[i];yy=now.y+yi[i];
            if(xx<=n&&xx>=1&&yy<=m&&yy>=1&&f[now.x][now.y][k]+a[xx][yy]<f[xx][yy][now.k|b[xx][yy]]){
                f[xx][yy][now.k|b[xx][yy]]=f[now.x][now.y][k]+a[xx][yy];
                use.x=now.x;use.y=now.y;use.k=k;
                pre[xx][yy][now.k|b[xx][yy]]=use;
                if(now.k|b[xx][yy]==k&&check[xx][yy][k]){
                    check[xx][yy][k]=false;
                    t+=1;q[t].x=xx;q[t].y=yy;q[t].k=k;
                }
            }
        }
        h+=1;
    }
}
void find(int x,int y,int k)
{
    if(!x||!y) return ;
    S now=pre[x][y][k];
    if(!a[x][y]) ans[x][y]=3;
    else ans[x][y]=2;
    find(now.x,now.y,now.k);
    if(now.x==x&&now.y==y)
      find(x,y,(k-now.k)|b[x][y]);
}
int main()
{
    int i,j,k,now,p,xx,yy;
    scanf("%d%d",&n,&m);
    memset(f,127/3,sizeof(f));
    memset(check,1,sizeof(check));  
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++){
        scanf("%d",&a[i][j]);
        if(!a[i][j]){
          tot+=1;
          f[i][j][1<<(tot-1)]=0;
          b[i][j]=1<<(tot-1);
        }
        f[i][j][0]=a[i][j];
        ans[i][j]=1;
      }
    for(k=1;k<=(1<<tot)-1;++k){
        h=1;t=0;
        for(i=1;i<=n;++i)
          for(j=1;j<=m;++j){
            if(!a[i][j]&&!(k&b[i][j])) continue;
            for(p=k;p;p=k&(p-1))
              if(f[i][j][k]>f[i][j][p|b[i][j]]+f[i][j][(k-p)|b[i][j]]-a[i][j]){
                f[i][j][k]=f[i][j][p|b[i][j]]+f[i][j][(k-p)|b[i][j]]-a[i][j];
                use.x=i;use.y=j;use.k=p|b[i][j];
                pre[i][j][k]=use;
              }
            if(f[i][j][k]<inf){
                check[i][j][k]=true;
                t+=1;q[t].x=i;q[t].y=j;q[t].k=k;
            }
          }
        spfa(k);
    }
    int minn=inf;
    for(i=1;i<=n;++i)
      for(j=1;j<=m;++j)
        if(!a[i][j]&&minn>f[i][j][(1<<tot)-1]){
            minn=f[i][j][(1<<tot)-1];
            xx=i;yy=j;
        }
    printf("%d\n",minn);
    find(xx,yy,(1<<tot)-1);
    for(i=1;i<=n;++i){
        for(j=1;j<=m;++j){
            if(ans[i][j]==1) printf("_");
            if(ans[i][j]==2) printf("o");
            if(ans[i][j]==3) printf("x");
        }
        printf("\n");
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

poj 2455 Secret Milking Machine 【二分 + 最大流】 【1到N不重复路径不少于T条时，求被选中路径上的最大边权值 的最小值】

Secret Milking Machine




Time Limit: 1000MS
 
Memory Limit: 65536K


Total Submissions: 10620
 
Accepted: 3110




Description

Farmer John is constructing a new milking machine and wishes to keep it secret as long as possible. He has hidden in it deep within his farm and needs to be able to get to the machine without being detected. He must make a total of T (1 <= T <= 200) trips to
 the machine during its construction. He has a secret tunnel that he uses only for the return trips. 

The farm comprises N (2 <= N <= 200) landmarks (numbered 1..N) connected by P (1 <= P <= 40,000) bidirectional trails (numbered 1..P) and with a positive length that does not exceed 1,000,000. Multiple trails might join a pair of landmarks. 

To minimize his chances of detection, FJ knows he cannot use any trail on the farm more than once and that he should try to use the shortest trails. 

Help FJ get from the barn (landmark 1) to the secret milking machine (landmark N) a total of T times. Find the minimum possible length of the longest single trail that he will have to use, subject to the constraint that he use no trail more than once. (Note
 well: The goal is to minimize the length of the longest trail, not the sum of the trail lengths.) 

It is guaranteed that FJ can make all T trips without reusing a trail.
Input

* Line 1: Three space-separated integers: N, P, and T 

* Lines 2..P+1: Line i+1 contains three space-separated integers, A_i, B_i, and L_i, indicating that a trail connects landmark A_i to landmark B_i with length L_i.
Output

* Line 1: A single integer that is the minimum possible length of the longest segment of Farmer John's route.
Sample Input
7 9 2
1 2 2
2 3 5
3 7 5
1 4 1
4 3 1
4 5 7
5 7 1
1 6 3
6 7 3
Sample Output
5
Hint
Farmer John can travel trails 1 - 2 - 3 - 7 and 1 - 6 - 7. None of the trails travelled exceeds 5 units in length. It is impossible for Farmer John
 to travel from 1 to 7 twice without using at least one trail of length 5. 

Huge input data,scanf is recommended.


好久没有1A了。。。


题意：给你一个N个点（编号从1到N）和M条边的无向图以及每条边的权值。要求从1到N至少要有T条边不重复的路径，让你在满足这个前提下求出所有路径（当然是选出的那些边不重复的路径，不算没有选上的）上的最大边权值的 最小值。题目保证从1到N至少会有T条边不重复的路径，也就是说，题目一定有解。


思路：二分枚举所有被选中路径上 最大边权值mid，判断在mid值的限制下从1到N是否存在至少T条边不重复的路径。
边不重复的路径数目可以用最大流求解——枚举原图中所有无向边，若边权不大于mid，就将该边加进新图且边的容量为1。最后从1到N跑一下最大流就行了。




AC代码：

#include <cstdio>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <algorithm>
#define MAXN 200+10
#define MAXM 1600000+10
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cap, flow, next;
};
Edge edge[MAXM], Redge[MAXM];
int head[MAXN], edgenum, Rhead[MAXN], Redgenum;
int dist[MAXN], cur[MAXN];
bool vis[MAXN];
int N, M, T;
struct Node
{
    int from, to, val, next;
};
Node node[MAXM];
int Head[MAXN], nodenum;
void addNode(int u, int v, int w)
{
    Node E = {u, v, w, Head[u]};
    node[nodenum] = E;
    Head[u] = nodenum++;
}
int Max;//记录最大边权
void input()
{
    memset(Head, -1, sizeof(Head));
    nodenum = 0;
    Max = 0;
    int a, b, c;
    for(int i = 1; i <= M; i++)
    {
        scanf("%d%d%d", &a, &b, &c);
        Max = max(Max, c);//更新
        addNode(a, b, c);
        addNode(b, a, c);
    }
}
void init()
{
    edgenum = 0;
    memset(head, -1, sizeof(head));
}
void addEdge(int u, int v, int w)
{
    Edge E1 = {u, v, w, 0, head[u]};
    edge[edgenum] = E1;
    head[u] = edgenum++;
    Edge E2 = {v, u, 0, 0, head[v]};
    edge[edgenum] = E2;
    head[v] = edgenum++;
}
void getMap(int mid)
{
    for(int i = 0; i < nodenum; i++)
    {
        if(node[i].val <= mid)//小于或等于限制
            addEdge(node[i].from, node[i].to, 1);//加入新图
    }
}
bool BFS(int s, int t)
{
    queue<int> Q;
    memset(dist, -1, sizeof(dist));
    memset(vis, false, sizeof(vis));
    dist[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            Edge E = edge[i];
            if(!vis[E.to] && E.cap > E.flow)
            {
                dist[E.to] = dist[u] + 1;
                vis[E.to] = true;
                if(E.to == t) return true;
                Q.push(E.to);
            }
        }
    }
    return false;
}
int DFS(int x, int a, int t)
{
    if(x == t || a == 0) return a;
    int flow = 0, f;
    for(int &i = cur[x]; i != -1; i = edge[i].next)
    {
        Edge &E = edge[i];
        if(dist[E.to] == dist[x] + 1 && (f = DFS(E.to, min(a, E.cap-E.flow), t)) > 0)
        {
            edge[i].flow += f;
            edge[i^1].flow -= f;
            flow += f;
            a -= f;
            if(a == 0) break;
        }
    }
    return flow;
}
int Maxflow(int s, int t)
{
    int flow = 0;
    while(BFS(s, t))
    {
        memcpy(cur, head, sizeof(head));
        flow += DFS(s, INF, t);
    }
    return flow;
}
int main()
{
    while(scanf("%d%d%d", &N, &M, &T) != EOF)
    {
        input();
        int left = 0, right = Max, ans = Max;
        while(right >= left)//二分查找
        {
            int mid = (left + right) >> 1;
            init();
            getMap(mid);
            if(Maxflow(1, N) >= T)//判断是否存在T条边不重复的路径
            {
                ans = min(ans, mid);//更新
                right = mid - 1;
            }
            else
                left = mid + 1;
        }
        printf("%d\n", ans);
    }
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 4427 Math Magic （2012年长春现场赛H题）
1.题目描述：点击打开链接
2.解题思路：本题要求寻找k个正整数，它们的和恰好是N，它们的LCM恰好是M的解的个数。可以设置一个三维的dp来解决。用dp(i,j,k)表示选择i个数，它们的和恰好是j，它们的LCM恰好是k的个数。那么答案就是dp(k,n,m)。不过这里介绍一种利用状态压缩思想求解的方法。


通过题意可以发现，N,M的范围都比较小，不超过1000，而1000之内的所有数的不同素因子的种类数目不超过4个，这是因为2*3*5*7<1000,而2*3*5*7*11>1000。考虑到素因子种类数非常少的特点，我们可以考虑状态压缩。设dp(i,j,s)表示选择i个数，它们的和恰好是j，它们的不同素因子（这里考虑的素因子都是它的幂次恰好和M分解后对应的幂次相等的那个素因子）构成的集合为s时的解的个数。可以利用刷表法来求解，刷新公式如下：
dp(i,j+d[i],k|s[i])=dp(i,j+d[i],k|s[i])+dp(i-1,j,k);
上式中，d[i]表示M的第i个约数，s[i]表示第i个约数的“合格”的素因子构成的集合。假设M一共有L种不同的素因子，那么，k个整数的LCM恰好等于M就等价于dp(k,N,2^L-1)。2^L-1就是这L种素因子构成的集合的全集。这样，本题便可以被顺利的解决。
3.代码：
#include<iostream>
#include<algorithm>
#include<cassert>
#include<string>
#include<sstream>
#include<set>
#include<bitset>
#include<vector>
#include<stack>
#include<map>
#include<queue>
#include<deque>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cctype>
#include<functional>
#pragma comment(linker, "/STACK:1024000000,1024000000")
using namespace std;

#define me(s)  memset(s,0,sizeof(s))
#define rep(i,n) for(int i=0;i<(n);i++)
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef pair <int, int> P;

const int MOD=1e9+7;

const int N=1050;

int dp[110][N][1<<4];
int primes[N];
int vis[N];
int idx;


void init() //筛素数
{
    me(vis);
    int m=sqrt(N+0.5);
    for(int i=2;i<=m;i++)
        if(!vis[i])
        for(int j=i*i;j<N;j+=i)
        vis[j]=1;
    for(int i=2;i<N;i++)
        if(!vis[i])
        primes[idx++]=i;
}

int main()
{
    init();
    int n,m,k;
    int num[5],p[5],d[233],type[233]; //p[i]表示M的第i个素因子，num[i]表示该素因子的幂次，d[i]表示M的第i个约数，type[i]表示第i个约数的“合格的”素因子构成的集合
    int l,tot;                        //l表示M一共有l种不同的素因子，tot表示M一共有tot个约数
    while(~scanf("%d%d%d",&n,&m,&k))
    {
        l=0;
        for(int i=0,j=m;primes[i]<=j;i++)//对M进行分解
            if(j%primes[i]==0)
        {
            p[l]=primes[i];
            num[l]=0;
            while(j%primes[i]==0)j/=primes[i],num[l]++;
            l++;
        }
        tot=0;
        for(int i=1;i<=m;i++) //寻找M的所有约数
            if(m%i==0)
        {
            d[tot]=i;
            type[tot]=0;
            int tmp=i,cnt;
            for(int j=0;j<l;j++)
                if(tmp%p[j]==0)
            {
                cnt=0;
                while(tmp%p[j]==0)tmp/=p[j],cnt++;
                if(cnt==num[j])  //如果该约数分解后，某一项的幂次和M对应的幂次相等，说明是一个合法的素因子，加入集合
                    type[tot]|=1<<j;
            }
            tot++;
        }
        int up=1<<l; //up表示M的不同素因子构成的全集
        me(dp);
        for(int i=0;i<tot&&d[i]<=n;i++)
            dp[1][d[i]][type[i]]=1;  //刷新时候需要的基础的解
        for(int i=2;i<=k;i++)
            for(int j=1;j<=n;j++)
            for(int k=0;k<up;k++)//枚举所有集合
            if(dp[i-1][j][k])
            for(int kk=0;kk<tot&&d[kk]+j<=n;kk++)//枚举所有可能的约数，进行刷新
            dp[i][j+d[kk]][k|type[kk]]=( dp[i][j+d[kk]][k|type[kk]]+dp[i-1][j][k])%MOD;
        printf("%d\n",dp[k][n][up-1]);
    }
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

spring-mvc @responseBody注解返回中文乱码解决
在项目中能设置UTF-8基本都设置了，通过ajax请求后台的springmvc后返回中文字符串，页面显示？？？，解决办法是： 
在方法中添加：produces = “text/html;charset=UTF-8”。 
具体添加位置如下：
@RequestMapping(value="/getpersonLimitItemNameByDeptIdAndSglcheckid", 
produces = "text/html;charset=UTF-8")
    @ResponseBody
    public String getpersonLimitItemNameByDeptIdAndSglcheckid(
            HttpServletRequest request) {
在ajax添加 
 contentType:’application/x-www-form-urlencoded; charset=UTF-8’不起任何作用。

如果使用了@ResponseBody注解，springMVC会自动把对象转化为json字符串，而不用将对象转成json字符串然后再返回。比如可以用如下的写法：
@RequestMapping("/testObj")
    @ResponseBody
    public WebResult responseJsonObj(HttpServletRequest request) {
        WebResult wr = new WebResult();
        wr.setFlag(0);
        wr.setMsg("测试");
        return wr;
    }
返回的json字符串格式为：
{"flag":0,"data":[],"o":null,"msg":"测试"}
以下为个人在网上查找的资料得出来的猜测： 
如果将对象转化为字符串再返回和直接返回的对象，对springMVC而言是不同的代码处理，一个默认编码为ISO-8859-1，另一个为UTF-8.所有导致乱码。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

树状数组学习资料1



1 一维树状数组


  1 什么是树状数组
       树状数组是一个查询和修改复杂度都为log(n)的数据结构，假设数组A[1..n]，那么查询A[1]+...+A[n]的时，间是log级别的，而且是一个在线的数据结构。

  2 树状数组作用
       我们经常会遇到动态连续和查询问题，给定n个元素A[1~N]，让我们求sum[L,R] = A[L]+...+A[R]，或者更改A[i]的值。

       假设数据很小的时候，那么我们利用暴力就可以搞定，这个时候更改A[i]的复杂度为O(1)，但是求和的复杂度为O(n)，如果有m次求和就是O(n*m)，但是m很大的时候这个方法显然是不能够满足效率的要求。这个时候我们引入树状数组，树状数组的求和和更新都是O(logN)，所以大大的降低了复杂度。





  3 具体分析


     1 建立树状数组就是先把A[] 和 C[]清空，然后假设有n个数那么就是做n次的update()操作就是建立树状数组，所以总的时间复杂度为O(nlogn)。

     2 设原数组为A[1..N]，树状数组为c[1..N]，其中c[k] = A[k-(2^t)+1] + ... + A[k]。比如c[6] = A[5] + A[6]。

        假设 A为被计数数组，C为树状数组（计数）

        0000 0001：C1 = A1
        0000 0010：C2 = A1 + A2
        0000 0011：C3 = A3
        0000 0100：C4 = A1 + A2 + A3 + A4
        0000 0101：C5 = A5
        0000 0110：C6 = A5 + A6
        0000 0111：C7 = A7
        0000 1000：C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8
        ...
        0001 0000：C16 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8+ A9 + A10 + A11 + A12 + A13 + A14 + A15+ A16




     3 也就是说，把k表示成二进制1***10000，那么c[k]就是A[1***00001] + A[1***00010] + ... + A[1***10000] 这一段数的和。




     4 设一个函数lowbit(k)为取得k的最低非零位，容易发现，根据上面的表示方法，从A[1]到A[k]的所有数的总和即为
        sum[k] = c[k] + c[k-lowestbit(k)] + c[k-lowestbit(k)-lowestbit(k-lowestbit(k))] + ... 于是可以在logk的时间内求出sum[k]。




     5 当数组中某元素发生变化时，需要改动的c值是c[k],c[k+lowestbit(k)], c[k+lowestbit(k)+lowestbit(k+lowestbit(k))] ... 这个复杂度是logN (N为最大范围)




     6 如果题目要求sum[L , R] = sum[R]-sum[L-1]
        sum[L-1] = A[1]+A[2]+...+A[L-1]
        sum[R] = A[1]+A[2]+...+A[L]+...+A[R]
        sum[R]-sum[L-1] = A[L]+A[L+2]+...+A[R]





     7 树状数组的下标严格从1开始，所以如果出现0的情况要注意加1.(因为lowbit(0)是0所以如果出现为0的时候会进入无限循环中) , 树状数组中的每个元素至少含有它本身的一个值。







2 二维树状数组

   1 二维树状数组说白了就是每一维都是树状数组


      问题：一个由数字构成的大矩阵，能进行两种操作
                1 对矩阵里的某个数加上一个整数（可正可负）
                2 查询某个子矩阵里所有数字的和,要求对每次查询，输出结果。

   2 一维树状数组很容易扩展到二维，在二维情况下:数组A[][]的树状数组定义为：
     C[x][y] = ∑ a[i][j], 其中，x-lowbit(x) + 1 <= i <= x , y-lowbit(y) + 1 <= j <= y.

   3 例：举个例子来看看C[][]的组成。
             设原始二维数组为：
　         A[][]={{a11,a12,a13,a14,a15,a16,a17,a18,a19},
                       {a21,a22,a23,a24,a25,a26,a27,a28,a29},
                       {a31,a32,a33,a34,a35,a36,a37,a38,a39}，
                       {a41,a42,a43,a44,a45,a46,a47,a48,a49}};
             那么它对应的二维树状数组C[][]呢？

      记:
             B[1]={a11,a11+a12,a13,a11+a12+a13+a14,a15,a15+a16,...} 这是第一行的一维树状数组
             B[2]={a21,a21+a22,a23,a21+a22+a23+a24,a25,a25+a26,...} 这是第二行的一维树状数组
             B[3]={a31,a31+a32,a33,a31+a32+a33+a34,a35,a35+a36,...} 这是第三行的一维树状数组
             B[4]={a41,a41+a42,a43,a41+a42+a43+a44,a45,a45+a46,...} 这是第四行的一维树状数组

      那么：
             C[1][1] = a11 , C[1][2] = a11+a12 , C[1][3] = a13 , C[1][4] = a11 + a12 + a13 + a14 , c[1][5]=a15.这是A[][]第一行的一维树状数组

              C[2][1] = a11 + a21 , C[2][2] = a11 + a12 + a21 + a22 , C[2][3] = a13 + a23 , C[2][4] = a11 + a12 + a13 + a14 + a21 + a22 + a23 + a24 这是A[][]数组第一行与第二行相加后的树状数组

              C[3][1] = a31 , C[3][2] = a31 + a32 , C[3][3] = a33 , C[3][4] = a31 + a32 + a33 + a34 , C[3][5] = a35 , C[3][6]=a35+a36,...这是A[][]第三行的一维树状数组

              C[4][1] = a11 + a21 + a31 + a41 , C[4][2] = a11 + a12 + a21 + a22 + a31 + a32 + a41 + a42 ，这是A[][]数组第一行+第二行+第三行+第四行后的树状数组








3  树状数组的两类操作

    1 单点更新，区间求和

       1 一维树状数组，单点更新，区间求和

       比如要更新点x ，x点的值加上val即调用add(x , val) ， 求区间[1 , x]的和即为getSum(x)
 
int lowbit(int x){
    return x&(-x);
}

int getSum(int x){
    int sum = 0;
    while(x){
        sum += treeNum[x];
        x -= lowbit(x);
    }
    return sum;
}

void add(int x , int val){
    while(x < MAXN){
         treeNum[x] += val;
         x += lowbit(x);
    }
}
 2 二维树状数组，单点更新，区间求和



       比如要更新点(x , y) ，(x , y)点的值加上val即调用add(x , y , val) ， 求矩形[1 , 1] - [x , y]的和即为getSum(x , y)

 如上图求矩形的面积为getSum(x2 , y2)-getSum(x1-1,y2)-getSum(x2,y1-1)+getSum(x1-1 , y1-1)

int lowbit(int x){
    return x&(-x);
}

int getSum(int x , int y){
    int sum = 0;
    for(int i = x ; i > 0 ; i -= lowbit(i))
       for(int j = y ; j > 0 ; j -= lowbit(j))
           sum += treeNum[i][j];
    return sum;
}

void add(int x , int y , int val){
    for(int i = x ; i < MAXN ; i += lowbit(i))
       for(int j = y ; j < MAXN ; j += lowbit(j))
           treeNum[i][j] += val;
}





    2 区间更新，单点求和  


         1 一维树状数组

        更改区间[x , y]，区间[x , y]里面的每个数全部加上val , 查询点k的值

        区间[x , y]加上val相当于点x加上val , 点y+1减去val，那么求k点的值就等于[1,k]的和
int lowbit(int x){
    return x&(-x);
}

int getSum(int x){
    int sum = 0;
    while(x){
        sum += treeNum[x];
        x -= lowbit(x);
    }
    return sum;
}

void add(int x , int val){
    while(x < MAXN){
         treeNum[x] += val;
         x += lowbit(x);
    }
}

void solve(){
    // 把区间[x , y]每一点加上val
    add(x , val);
    add(y+1 , -val);
    // 计算点k的值
    int num = getSum(k);
}






2 二维树状数组



     更改矩形[x1 , y1] - [x2 , y2]，[x1 , y1] - [x2 , y2]里面的每个数全部加上val , 查询点(x , y)的值


矩形[x1 , y1] - [x2 , y2]里面的每一个元素加上val相当于点(x1 , y1)加上val , 点(x1 , y2+1)减去val，点(x2+1 , y1)减去val ， 点(x2+1 , y2+1)加上val。那么求某个点(x
 , y)的值即求[1 , 1] - [x , y]的和


int lowbit(int x){
    return x&(-x);
}

int getSum(int x , int y){
    int sum = 0;
    for(int i = x ; i > 0 ; i -= lowbit(i))
       for(int j = y ; j > 0 ; j -= lowbit(j))
           sum += treeNum[i][j];
    return sum;
}

void add(int x , int y , int val){
    for(int i = x ; i < MAXN ; i += lowbit(i))
       for(int j = y ; j < MAXN ; j += lowbit(j))
           treeNum[i][j] += val;
}

void solve(){
     // 矩形[x1 , y1]-[x2 , y2]每个点加上val
     add(x1 , y1 , val); 
     add(x2+1 , y1 , -val); 
     add(x1 , y2+1 , -val); 
     add(x2+1 , y2+1 , val); 
     // 求点(x , y)的值
     int num = getSum(x , y);
}


5 常用的技巧

   假设初始化数组每个点的值为1，那么我们知道对于一维的树状数组来说，我们知道treeNum[i] = lowbit(i) . 对于二维树状数组来说treeNum[i][j] = lowbit(i)*lowbit(j)
void init(){
    // 一维
    memset(treeNum , 0 , sizeof(treeNum));
    for(int i = 1 ; i < MAXN ; i++){
        num[i] =1;
        treeNum[i] = lowbit(i);
    }
    
    // 二维
    memset(treeNum , 0 , sizeof(treeNum));
    for(int i = 1 ; i < MAXN ; i++){
       for(int j = 1 ; j < MAXN ; j++){
           num[i][j] = 1;
           treeNum[i][j] = lowbit(i)*lowbit(j);
       }
    }
}









版权声明：本文为博主原创文章，未经博主允许不得转载。

Qt入门学习——Qt快速入门（vim纯代码编写）
写代码前，先需搭建环境，详情请看：《Qt 5.4.2 ubuntu环境搭建》。


一个简单空白窗口
打开终端，通过vim first_qt.cpp新建文件，由于Qt代码为C++代码，所以，新建文件的后缀为.cpp。




代码内容如下：

#include <QApplication>
#include <QWidget>

int main(int argc, char *argv[])
{
	QApplication app(argc, argv); //初始化
	
	QWidget w;
	w.show();
	
	app.exec(); //主事件循环
	
	return 0;
}
写完代码后，我们需要通过g++编译器（C++编译器）把此代码编译为可执行程序，但由于此代码使用的函数不是C++标准库，而是Qt库，编译时需要指定其所依赖的Qt库，这样比较麻烦。我们可以利用Qt提供的qmake工具来编译Qt的源代码。



qmake所在目录：




配置环境变量，PATH添加qmake路径：
1）复制qmake所在的目录


2）在 ~/.bashrc 或/etc/profile 脚本最后的位置添加如下代码（/home/mike/Qt5.4.2/5.4/gcc_64/bin 为qmake所在目录，不同环境有所差异）：
export PATH=/home/mike/Qt5.4.2/5.4/gcc_64/bin:$PATH






3）运行脚本文件，让设置的环境变量立马生效（source ~/.bashrc），通过which qmake 查看是否设置成功：




接下来，我们通过qmake工程先自动生成工程文件，再通过工程文件生成Makefile，再通过make解析Makefile的指令把源代码编译成可执行程序：
1）生成所需工程文件：qmake -project
qmake工具会根据当前目录源代码自动生成一个后缀为.pro的工程文件，文件名字和当前目录名相同。




打开工程文件，其内容如下：




工程文件简单分析：

1）TEMPLATE：为建立目标文件而采用何种模板。

app, 为建立一个Qt应用程序创建 Makefile文件;
lib, 为建立应用程序库而创建 Makefile 文件。

2）TARGET：描述了目标文件的名称(即可执行文件名)。默认＝.pro文件名称＝工程目录名。
3）INCLUDEPATH：描述了编译该工程时编译器需要搜索的头文件的路径。
4）#：注释代码
5）HEADERS：告诉编译器，.h 文件路径及其文件文件（这里没有使用到）。
6）SOURCES：告诉编译器, 源代码（.cpp文件）文件路径及其文件名字。
7）FORMS：添加 designer 生成的 .ui 文件（这里没有使用到）。


此工程文件缺少一个很重要的东西：模块的添加。Qt 5 定义了多个模块，每个模块包含相对独立的库文件并实现各自的功能，如果不在工程文件添加相应模块，就算代码编写正确，编译时也会提示很多函数或类未定义。而这里，我们写的代码主要涉及到图形界面，故需在工程文件添加 QtWidgets 模块：QT
 += widgets。




2)根据工程文件用qmake命令生成Makefile：qmake




3)使用生成的Makefile编译源代码：make



4)运行可执行程序：./qt




Qt代码基本框架介绍
我们以后写Qt代码时基本上都看到这个一个框架：



1）包含所需头文件：通常和使用到的类同名，Qt的类名通常以‘Q’开头。


2）初始化：创建一个QApplication对象并将用户输入参数传递给它，每一个Qt GUI应用程序都有且只有一个QApplication对象，而且是在定义其他对象之前定义（即是说，通常main（）中的第一句话通常都是：QApplication
 app(argc, argv)；）。它主要用于管理Qt GUI应用程序的控制流程和主要的设置选项，是每个Qt GUI应用程序所必需的。


3）主事件循环：app.exec()是每个Qt应用程序都要调用的函数。程序运行停在这里等待事件(如键盘事件或鼠标事件)的发生，等待用户来操作窗口。


而我们写的代码又是什么意思呢？

QWidget w; //QWidget是Qt窗口基类，根据QWidget创建一个对象w，既是说w是一个窗口对象。
w.show();//窗口创建默认是隐藏的，需要调用show()才能显示出来


Qt程序的外观通常是由各个不同的类的对象组成。



父窗口添加子部件
接下来，我们在原来的空白窗口上添加一个按钮，这里通过指定父对象的方式实现，其流程如下：

1）创建所需按钮
2）按钮指定窗口为其父对象，即按钮放在窗口上
3）显示按钮



修改后的代码如下：

#include <QApplication>
#include <QWidget>
#include <QPushButton> //按钮所需头文件

int main(int argc, char *argv[])
{
	QApplication app(argc, argv); //初始化
	
	QWidget w;
	w.show();
	
	//新增的代码
	//创建一个内容为"^_^"的按钮，需要头文件：#include <QPushButton>
	QPushButton button("^_^"); 
	
	//按钮指定窗口为其父对象，即按钮放在窗口上
	button.setParent(&w);
	
	button.show(); //显示按钮
	
	
	app.exec(); //主事件循环
	
	return 0;
}
接下来，敲make重新编译代码，运行结果如下：





A部件指定B部件为其父对象，我们看到的直接效果为A部件放在B部件的上面，其实，指定父对象还有如下作用：

1）父对象show的时候会递归调用其所有子对象，让它们都显示出来。

2）父对象被销毁时会递归销毁其所有的子对象，让内存管理更加的简单。



指定父对象主要有两种方式：1）调用setParent()函数 2）创建新部件时通过给构造函数传参指定。


完善后的代码如下：

#include <QApplication>
#include <QWidget>
#include <QPushButton> //按钮所需头文件

int main(int argc, char *argv[])
{
	QApplication app(argc, argv); //初始化
	
	QWidget w;
	
	//创建一个内容为"^_^"的按钮，需要头文件：#include <QPushButton>
	//通过给构造函数传参指定w为其父对象
	QPushButton button("^_^", &w); 

	w.show(); //显示父窗口，父窗口上的部件也会跟着显示
	
	app.exec(); //主事件循环
	
	return 0;
}
程序运行效果和上面一样。


Qt标准程序结构分析
我们写Qt程序，基本上不可能只有一个.cpp文件，也不可能把所有的代码都放在main()中，通常我们需要分文件。


下面的例子由 
main.cpp mywidget.cpp mywidget.h 组成：




main.cpp内容如下：

#include <QApplication>
#include "mywidget.h"//自定义类的头文件

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MyWidget w; //创建MyWidget的对象
    w.show();

    return a.exec();
}
mywidget.h内容如下：

#ifndef MYWIDGET_H
#define MYWIDGET_H

#include <QWidget>
#include <QPushButton>//按钮所需头文件

//MyWidget公有继承于QWidget，既是说MyWidget也是一个窗口类
class MyWidget : public QWidget
{
public:
    MyWidget(QWidget *parent = 0);//参数主要用于给基类构造函数传参
    ~MyWidget(); //析构函数
	
	QPushButton button;//定义一个按钮对象
	
};

#endif // MYWIDGET_H


mywidget.cpp内容如下：

#include "mywidget.h"

//构造函数
MyWidget::MyWidget(QWidget *parent)
    : QWidget(parent)//通过参数列表给基类构造函数传参
{
	button.setText("^_^"); //设置按钮的内容"^_^"
	
	//指定父对象
	//this指向主函数( main() )的对象w
	//最终button放在w窗口的上面
	button.setParent(this);
}

//析构函数
MyWidget::~MyWidget()
{

}

程序结构说明：


1）main.cpp 内创建MyWidget的对象
2）mywidget.h 内声名函数、变量及其它的类的对象或对象指针
3）mywidget.cpp 内进行函数实现、创建对象
4）一般窗口类都要继承QWidget



程序运行结果如下：


本教程示例代码下载请点击此链接：http://download.csdn.net/detail/tennysonsky。



版权声明：本博客文章，大多是本人整理编写，或在网络中收集，转载请注明出处！！

【LeetCode-面试算法经典-Java实现】【206-Reverse Linked List（反转一个单链表）】
【206-Reverse Linked List（反转一个单链表）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Reverse a singly linked list. 

题目大意
　　反转单链表。 

解题思路
　　使用头插法。 

代码实现
结点类
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}
算法实现类
public class Solution {

    public ListNode reverseList(ListNode head) {
        // 头结点
        ListNode root = new ListNode(0);
        ListNode nextNode;
        while (head != null) {
            nextNode = head.next;
            head.next = root.next;
            root.next = head;
            head = nextNode;
        }

        return root.next;
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/48021429】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu5412--CRB and Queries（整体二分）
题目链接：点击打开链接
题目大意：给出n个数的初始序列，有两种操作，1 l v将第l个数换成v，2 l r k 问在区间[l,r]内的第k大是多少，并输出
经典的题目，但是树状数组+主席树（TLE）伸展树（MLE），听说他们用的块状链表，zhazha表示不会，后来补题，发现整体二分是一个好方法。
首先，这个整体二分是将数据范围和操作放到一起，不断二分数据的范围，可以得到有某些操作可以被完成，有某些操作不可以被完成。
例如：当前数据范围的区间是[l,r]，那么mid = (l+r)/2 ，所有修改操作如果修改的数小于等于mid，那么就是可以被完成的，那么就修改数，否则就是不能被完成的。对于查询操作，如果查询到的范围内的数的个数x小于k，那么要查询的数是不在区间[1,5]内的，所以这个操作是不会再[l,mid]中被完成，将该操作的k改为k-x。否则就会在[l,mid]内被完成。按照数据范围向下二分得到[l,mid],[mid+1,r]，将能被完成的操作放入左区间，不能完成的操作放入右区间。（注意放到同一区间的的操作的相对顺序是不能被改变的），这样最终的查询操作都会被确定到一个数值，这个数值就是要输出的值。
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std ;
#define maxn 300100
struct node{
    int type, l, r, v , ans;
}p[maxn];
int c[maxn], n, q, cnt, max1;
int a[maxn];
int id1[maxn], id2[maxn];
void p_add(int type, int l,int r, int v) {
    p[cnt].type = type;
    p[cnt].l = l; p[cnt].r = r;
    p[cnt].v = v;
    id1[cnt] = cnt;
    cnt++;
}
int lowbit(int x) {
    return x & -x ;
}
void add(int i,int k) {
    while( i <= n ) {
        c[i] += k ;
        i += lowbit(i) ;
    }
}
int sum(int i) {
    int num = 0 ;
    while( i ) {
        num += c[i] ;
        i -= lowbit(i) ;
    }
    return num ;
}
void solve(int L, int R, int low, int high) {
    if( L > R ) return;
    if( low == high ) {
        while(L <= R) {
            if( p[ id1[L] ].type == 2 ) p[ id1[L] ].ans = low;
            L++;
        }
        return ;
    }
    int i, j, num, l = L, r = R;
    int mid = (low + high)/2;
    for(i = L; i <= R; i++) {
        j = id1[i];
        if( p[j].type == 2 ) {
            num = sum(p[j].r) - sum(p[j].l-1);
            if( num < p[j].v ) {
                p[j].v -= num;
                id2[r--] = j;
            }
            else
                id2[l++] = j;
        }
        else {
            if( p[j].v <= mid ) {
                add(p[j].l,p[j].type);
                id2[l++] = j;
            }
            else
                id2[r--] = j;
        }
    }
    for(i = L; i <= R; i++) {
        j = id1[i];
        if( p[j].type != 2 && p[j].v <= mid ) add(p[j].l,-p[j].type);
    }
    for(i = L; i < l; i++)
        id1[i] = id2[i];
    for(r = R; i <= R; r--, i++)
        id1[i] = id2[r];
    solve(L,l-1,low,mid);
    solve(l,R,mid+1,high);
}
int main() {
    int i, j, type, l, r, v;
    while( scanf("%d", &n) != EOF ) {
        memset(c,0,sizeof(c));
        cnt = max1 = 0;
        for(i = 1; i <= n; i++) {
            scanf("%d", &a[i]);
            p_add(1, i, i, a[i]);
            max1 = max(max1, a[i]);
        }
        scanf("%d", &q);
        while( q-- ) {
            scanf("%d", &type);
            if( type == 1 ) {
                scanf("%d %d", &l, &v);
                p_add(-1, l, l, a[l]);
                a[l] = v;
                p_add(1, l, l, a[l]);
                max1 = max(max1, a[l]);
            }
            else {
                scanf("%d %d %d", &l, &r, &v);
                p_add(2, l, r, v);
            }
        }
        solve(0,cnt-1,0,max1) ;
        for(i = 0; i < cnt; i++) {
            if( p[i].type == 2 )
                printf("%d\n", p[i].ans);
        }
    }
    return 0 ;
}



版权声明：转载请注明出处：http://blog.csdn.net/winddreams

重温java基础
Java标识符Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。关于Java标识符，有以下几点需要注意：所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始首字符之后可以是任何字符的组合关键字不能用作标识符标识符是大小写敏感的合法标识符举例：age、$salary、_value、__1_value非法标识符举例：123abc、-salaryJava修饰符Java语言提供了很多修饰符，主要分为以下两类访问修饰符修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明： public class className {
   // ...
}
private boolean myFlag;
static final double weeks = 9.5;
protected static final int BOXWIDTH = 42;
public static void main(String[] arguments) {
   // 方法体
}访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java支持4种不同的访问权限。 1、默认的，也称为default，在同一包内可见，不使用任何修饰符。使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为public。 2、私有的，以private修饰符指定，在同一类内可见。私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。 3、共有的，以public修饰符指定，对所有类可见。被声明为public的类、方法、构造方法和接口能够被任何其他类访问。如果几个相互访问的public类分布在不用的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。 4、受保护的，以protected修饰符指定，对同一包内的类和所有子类可见。被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。Protected访问修饰符不能修饰类和接口，方法和成员变量能够声明为protected，但是接口的成员变量和成员方法不能声明为protected。子类能访问Protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。 请注意以下方法继承的规则：父类中声明为public的方法在子类中也必须为public。父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。父类中默认修饰符声明的方法，能够在子类中声明为private。父类中声明为private的方法，不能够被继承。非访问修饰符Static修饰符静态变量：Static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量能被声明为static变量。 静态方法：Static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 Final修饰符Final变量：Final变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。但是final对象里的数据可以被改变。也就是说final对象的引用不能改变，但是里面的值可以改变。Final修饰符通常和static修饰符一起使用来创建类常量。 Final方法：类中的Final方法可以被子类继承，但是不能被子类修改。声明final方法的主要目的是防止该方法的内容被修改。 Final类：Final类不能被继承，没有类能够继承final类的任何特性。 Abstract修饰符抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。抽象类可以包含抽象方法和非抽象方法。 抽象方法：抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成final和strict。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 Synchronized修饰符Synchronized关键字声明的方法同一时间只能被一个线程访问。Synchronized修饰符可以应用于四个访问修饰符。 Transient修饰符序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile修饰符Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。Java变量Java中主要有如下几种类型的变量局部变量只在特定的过程或函数中可以访问的变量，被称为局部变量。与局部变量相对应的，是全局变量。全局变量就是从定义的位置起，作用域覆盖整个程序范围的变量。局部变量可以和全局变量重名，但是局部变量会屏蔽全局变量。在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。一旦退出方法，构造函数或块中的变量将被销毁。访问修饰符不能用于局部变量。局部变量在堆栈级别内部实现。局部变量要先赋值，再进行运算，而实例变量均已经赋初值。（这是局部变量和实例变量的一大区别）全局变量（成员变量）其中实例变量、类变量、常量都是属于成员变量的，成员变量又被称为全局变量java类的成员变量有俩种：一种是被static关键字修饰的变量，叫类变量或者静态变量；另一种没有static修饰，为实例变量。在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。静态变量均有默认值，数字默认为0，布尔值默认为false，对象默认为null public class Test {
      //以下四个变量都是成员变量（全局变量）
      int num ;              //属于基本数据类型的实例变量
      Integer obj ; //属于引用数据类型的实例变量
      static char ch = 'A';    //类变量（静态变量）
      final double constant= 12.6; //属于常量的实例变量
     
      public void display(){
             //以下两个属于该方法的局部变量，必须先赋值才能使用，作用范围仅限于函数体之内
             int age = 1;
             String name = "Tom";
             System.out.println("name:"+name+";age: "+age);
      }
     
     
      public static void main(String[] args){
             System.out.println(num); //这句会报错，因为num变量属于实例变量，只有将Test实例化之后才能使用
             System.out.println(Test.ch);  //这句则不会报错，因为ch属于类变量，不用实例化Test也能使用
            
             Test test = new Test();
             System.out.println(test.num);  //num为基本数据类型，打印出的默认值为0
             System.out.println(test.obj);  //obj为引用数据类型，打印出的默认值为null
      }
 
}Java数据类型内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。基本数据类型注意：下面提到的默认值都是对于全局变量而言的，java平台不会给局部变量赋予默认值，使用没有赋值的局部变量会报错。 Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 byte： byte数据类型是8位、有符号的，以二进制补码表示的整数；包装类：java.lang.Byte最小值：Byte.MIN_VALUE=-128(-27)最大值：Byte.MAX_VALUE=127(27-1)默认值：0；byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；例子：byte a = 100，byte b = -50。 short：short数据类型是16位、有符号的以二进制补码表示的整数包装类：java.lang.Short最小值：Short.MIN_VALUE=-32768(-215)最大值：Short.MAX_VALUE=32767(215-1)Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；默认值：0；例子：short s = 1000，short r = -20000。 int：int数据类型是32位、有符号的以二进制补码表示的整数；包装类：java.lang.Integer最小值：Integer.MIN_VALUE=-2147483648(-231)最大值：Integer.MAX_VALUE=2147483647(231-1)一般地整型变量默认为int类型；默认值：0；例子：int a = 100000,int b = -200000。 long：long数据类型是64位、有符号的以二进制补码表示的整数；包装类：java.lang.Long最小值：Long.MIN_VALUE=-9223372036854775808(-263)最大值：Long.MAX_VALUE=9223372036854775807(263-1)这种类型主要使用在需要比较大整数的系统上；默认值：0L；例子： long a = 100000L，int b =-200000L。 float：float数据类型是单精度、32位、符合IEEE 754标准的浮点数；float在储存大型浮点数组的时候可节省内存空间；包装类：java.lang.Float最小值：Float.MIN_VALUE=1.4E-45最大值：Float.MAX_VALUE=3.4028235E38默认值：0.0f；浮点数不能用来表示精确的值，如货币；例子：float f1 = 234.5f。 double：double数据类型是双精度、64位、符合IEEE 754标准的浮点数；浮点数的默认类型为double类型；double类型同样不能表示精确的值，如货币；包装类：java.lang.Double最小值：Double.MIN_VALUE=4.9E-324最大值：Double.MAX_VALUE=1.7976931348623157E308默认值:  0.0f；例子：double d1 = 123.4。 boolean：boolean数据类型表示一位的信息；只有两个取值：true和false；这种类型只作为一种标志来记录true/false情况；默认值是false；例子：boolean one = true。 char：char类型是一个单一的16位Unicode字符；包装类：java.lang.Character最小值是’\u0000’（即为0）；最大值是’\uffff’（即为65,535）；char数据类型可以储存任何字符；例子：char letter = ‘A’。 实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类java.lang.Void，不过我们无法直接对它们进行操作。String并不是基本数据类型，但是我们可以把它当做基本类型来用 java的整型变量（byte、short、int、long）都可以用八进制、十六进制来表示，八进制必须以0为前缀，十六进制必须以0x为前缀，比如十进制的26分别用八进制、十六进制来表示：八进制：032十六进制：0x1a引用数据类型引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。String、数组都是引用数据类型。所有引用类型的默认值都是null。一个引用变量可以用来引用与任何与之兼容的类型。例子：Animal animal =new Animal(“giraffe”)。 字符串和数组类型应用很广，从某种程度上来讲，可以将之看作基本数据类型字符串和数组都可以不用new关键字来创建：String str = "String Test";int [] arr = {1,2,3};  //int arr[] = {1,2,3}等价也可以显式地创建：String str = new String(“String Test”);int [] arr = new int[]{1,2,3};自动装箱与拆箱（Autoboxing and Unboxing）自动装箱是java编译器在基本数据类型跟与之对应的包装类之间的自动转换。比如，将一个int类型的数据转换成Integer就叫自动装箱，与之相反的转换则成为自动拆箱。例如：Character ch = ‘a’;  //实际上相当于执行代码: Character ch = new Character (‘a’);再例如：List<Integer> li = new ArrayList<>();
for (int i = 1;i < 50; i += 2){
    li.add(i); 
}代码中List容器内的元素声明为Integer类型，而我们加入的却是int类型，但是编译器并不会报错，是因为编译器自动将int转换成了Integer类型，编译器在运行时将上面的代码转化为下面的形式：List<Integer>li = new ArrayList<>();
for (int i = 1;i < 50; i += 2){
    li.add(Integer.valueOf(i)); 
}同样地，编译器也会在需要的时候将包装类型自动转换成与之对应的基本类型。例如：public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i: li)
        if (i % 2 == 0)
            sum += i;
        return sum;
}我们知道，“%”与“+=”运算符是不能应用于Integer类型的，只适用于基本类型，但是上面的代码不会报错，就是因为编译器将Integer转换成了int类型，代码转换成了下面的形式：public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i: li)
        if (i.intValue() % 2 == 0)
            sum += i.intValue();
        return sum;
}java的自动装箱与拆箱在以下两种情况下会发生：（1）传入方法的实际参数类型与方法中声明的参数类型不一致时（2）变量的数据类型与赋值的数据类型不一致这种转换仅限于八种基本类型与对应的包装类之间。 转义字符\n         换行 (0x0a)\r         回车 (0x0d)\f         换页符(0x0c)\b         退格 (0x08)\s         空格 (0x20)\t         制表符\"         双引号\'          单引号\\         反斜杠\ddd      八进制字符 (ddd)\uxxxx   16进制Unicode字符 (xxxx)Java运算符算术运算符算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。 实例假设整数变量A的值为10，变量B的值为20： +     加法 - 相加运算符两侧的值      A + B等于30-      减法 - 左操作数减去右操作数  A – B等于-10*     乘法 - 相乘操作符两侧的值      A * B等于200/      除法 - 左操作数除以右操作数  B / A等于2％   取模 - 右操作数除左操作数的余数        B%A等于0+ +  自增 - 操作数的值增加1    B + +等于21- -    自减 - 操作数的值减少1    B - -等于19关系运算符实例整数变量A的值为10，变量B的值为20： ==   检查如果两个操作数的值是否相等，如果相等则条件为真。       （A == B）为假(非真)。!=    检查如果两个操作数的值是否相等，如果值不相等则条件为真。      (A != B) 为真。>    检查左操作数的值是否大于右操作数的值，如果是那么条件为真。  （A> B）非真。<    检查左操作数的值是否小于右操作数的值，如果是那么条件为真。  （A <B）为真。> =  检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。    （A> = B）为假。<=   检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。    （A <= B）为真。位运算符＆   按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。    （A＆B），得到12，即0000 1100|     按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。    （A | B）得到61，即 0011 1101^     按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。  （A ^ B）得到49，即 0011 0001〜   按位补运算符翻转操作数的每一位。     （〜A）得到-60，即1100 0011<<         按位左移运算符。左操作数按位左移右操作数指定的位数。       A << 2得到240，即 1111 0000>>         按位右移运算符。左操作数按位右移右操作数指定的位数。       A >> 2得到15即 1111>>>       按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。       逻辑运算符假设布尔变量A为真，变量B为假 &&  称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。      （A &&B）为假。| |   称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。     （A | | B）为真。！   称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。        ！（A&& B）为真。&与&&的区别java中&和&&的区别，&和&&虽然都是逻辑运算符，都是判断两边为真，则语句成立，但是在运行的时候，还是有差别的，下面举例来说明。 public class Test1{
    public static void main(String[] args){
        int i=3;
        if((i++>5)&(i++<9)){
            System.out.println(i);
            System.out.println("恭喜，执行完了条件语句！");
        }
           System.out.println(i);
    }
}打印结果为：5从条件判断语句来看，是不成立的，但是i是自加了两次，由初始值3变成5。public class Test2{
    public static void main(String[] args){
        int i=3;
        if((i++>5)&&(i++<9)){
            System.out.println(i);
            System.out.println("恭喜，执行完了条件语句！");
        }   
        System.out.println(i);
    }
}打印结果：4从条件判断语句来看是不成立的，变量i只自加了一次。 &和&&都是逻辑运算符，都是判断两边同时真则为真，否则为假；但是&&当第一个条件不成之后，后面的条件都不执行了，而&则还是继续执行，直到整个条件语句执行完为止。如&&例子中的i++>5被执行了，而i++<9并没有被执行，这就是他们的差别。&例子中的i++>5和i++<9都被执行了。赋值运算符=     简单的赋值运算符，将右操作数的值赋给左侧操作数     C = A + B将把A + B得到的值赋给C+ =  加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数      C + = A等价于C = C + A- =   减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数      C - = A等价于C = C - A* =  乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数      C * = A等价于C = C * A/ =   除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数      C / = A等价于C = C / A（％）=       取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数     C％= A等价于C = C％A<< =       左移位赋值运算符  C << = 2等价于C = C << 2>> =       右移位赋值运算符  C >> = 2等价于C = C >> 2＆=        按位与赋值运算符  C＆= 2等价于C = C＆2^ =  按位异或赋值操作符     C ^ = 2等价于C = C ^ 2| =  按位或赋值操作符  C | = 2等价于C = C | 2条件运算符（?:）条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。variable x =(expression) ? value if true : value if falseinstanceOf 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 instanceof运算符使用格式如下：( Object/reference/ variable ) instanceOf (class/interface type)如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。Java面向对象基础Java继承继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承可以理解为一个对象从另一个对象获取属性的过程。如果类A是类B的父类，而类B是类C的父类，我们也称C是A的子类，类C是从类A继承而来的。在Java中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类继承中最常使用的两个关键字是extends和implements。所有Java的类均是由java.lang.Object类继承而来的，所以Object是所有类的祖先类，而除了Object外，所有类必须有一个父类。Java 重写(Override)与重载(Overload)重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心重写重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。当需要在子类中调用父类的被重写方法时，要使用super关键字。 重写的原则：参数列表必须完全与被重写方法的相同；返回类型必须完全与被重写方法的返回类型相同；访问权限不能比父类中被重写的方法的访问权限更高。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。声明为final的方法不能被重写。声明为static的方法不能被重写，但是能够被再次声明。如果一个方法不能被继承，那么该方法不能被重写。子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。构造方法不能被重写。 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 重载规则：被重载的方法必须改变参数列表；被重载的方法可以改变返回类型；被重载的方法可以改变访问修饰符；被重载的方法可以声明新的或更广的检查异常；方法能够在同一个类中或者在一个子类中被重载。Java多态多态是同一个行为具有多个不同表现形式或形态的能力。多态性是对象多种表现形式的体现。比如我们说"宠物"这个对象，它就有很多不同的表达或实现，比如有小猫、小狗、蜥蜴等等。那么我到宠物店说"请给我一只宠物"，服务员给我小猫、小狗或者蜥蜴都可以，我们就说"宠物"这个对象就具备多态性。public interface Vegetarian{}
public class Animal{}
public class Deer extends Animal implements Vegetarian{}因为Deer类具有多重继承，所以它具有多态性。以上实例解析如下： 一个 Deer IS-A（是一个） Animal一个 Deer IS-A（是一个）Vegetarian一个 Deer IS-A（是一个） Deer一个 Deer IS-A（是一个）Object在Java中，所有的对象都具有多态性，因为任何对象都能通过IS-A测试的类型和Object类。访问一个对象的唯一方法就是通过引用型变量。引用型变量只能有一种类型，一旦被声明，引用型变量的类型就不能被改变了。引用型变量不仅能够被重置为其他对象，前提是这些对象没有被声明为final。还可以引用和它类型相同的或者相兼容的对象。它可以声明为类类型或者接口类型。当我们将引用型变量应用于Deer对象的引用时，下面的声明是合法的：Deer d = newDeer();
Animal a = d;
Vegetarian v =d;
Object o = d;所有的引用型变量d,a,v,o都指向堆中相同的Deer对象。 虚方法看一个实例：public class Fother{
      public void say(String name){
             System.out.println(“Hello !”+name+”---FromFather”);
      };
}
 
public class Child extends Fother{
      //覆写父类的方法
      public void say(String name){
             System.out.println(“Hello ! ”+name+”---From Child”);
      };
}
 
Father person1 =new Child();
Child person2 =new Child();
person1.say(“Jack”);
person2.say(“Rose”);打印出的结果为：Hello ! Jack---From ChildHello ! Rose---From Child上例中，我们实例化了两个Child对象，分别以Father和Child类型来引用它。person1.say(“Jack”)表面上是调用了person1（Father类型）的方法，但是它实际上是一个虚拟方法。以Father类型引用的变量person1调用say方法时，实际上并不是调用Father类中的say方法，而是Child类中的say 方法。该行为被称为虚拟方法调用。Java封装     在面向对象程式设计方法中，封装（英语：Encapsulation）是指，一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。Java接口接口（Interface），在Java编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。接口与类的区别：接口不能用于实例化对象。接口没有构造方法。接口中所有的方法必须是抽象方法。接口不能包含成员变量，除了static和final变量。接口不是被类继承了，而是要被类实现。接口支持多重继承。 如果一个接口没有加public修饰符，该接口默认只能被同一包中的类访问，接口可以同时继承多个父接口，这与类的单一继承机制不同接口中所有的常量都是隐式地声明为public static finalJava抽象类在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。Number类及其子类基本数据类型“包装”类抽象类 Number 是 BigDecimal、BigInteger、Byte、Double、Float、Integer、Long 和 Short 类的超类。 Number 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法。即必须实现以下六种方法：byte byteValue()          以 byte 形式返回指定的数值。 double doubleValue()           以 double 形式返回指定的数值。 float floatValue()           以 float 形式返回指定的数值。 int intValue()           以 int 形式返回指定的数值。 long longValue()          以 long 形式返回指定的数值。 short shortValue()           以 short 形式返回指定的数值。就是说，Number的各种子类之间是可以相互转换的，当然中间可能会涉及到相关的舍入或取整。有一个问题需要弄清楚：Byte类是byte的包装类，Integer是int的包装类，其他以此类推。int是一种java的原始数据类型，而Integer是一种java的引用数据类型。作为实例变量的时候，未赋值的情况下，int型数据默认为0，而Integer类型的默认值为null。Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。 比如有下面两个变量：int a = 12;
Integer b = 12;  //相当于Integer b = new Integer(12)针对a只能做一些加减乘除之类的运算，而b则可以使用Integer类提供的各种方法来进行操作。从本质上来讲，b是Integer的一个对象，而a不是。Number的每个子类都提供了数字和字符串之间的转换方法，下面是Integer的相关方法，其余子类与之类似static Integer decode(String nm)           将 String 解码为 Integer。static int parseInt(String s)           将字符串参数作为有符号的十进制整数进行解析。 static int parseInt(String s, int radix)           使用第二个参数指定的基数（二进制，八进制，十六进制，甚至三进制、二十进制都可以），将字符串参数解析为有符号的整数。static String toString(int i)           返回一个表示指定整数的 String 对象。 static String toString(int i, int radix)           返回用第二个参数指定基数表示的第一个参数的字符串表示形式。static Integer valueOf(int i)           返回一个表示指定的 int 值的 Integer 实例。 static Integer valueOf(String s)           返回保存指定的 String 的值的 Integer 对象。 static Integer valueOf(String s, int radix)           返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取的值。static String toBinaryString(int i)           以二进制（基数 2）无符号整数形式返回一个整数参数的字符串表示形式。 static String toHexString(int i)           以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式。 static String toOctalString(int i)           以八进制（基数 8）无符号整数形式返回一个整数参数的字符串表示形式。Integer类中还有四个静态变量，其余子类与之类似static int MAX_VALUE           表示 int 类型能够表示的最大值。 static int MIN_VALUE           表示 int 类型能够表示的最小值。 static int SIZE           用来以二进制补码形式表示 int 值的比特位数。返回32static Class<Integer> TYPE           表示基本类型 int 的 Class 实例。返回int 在Number的子类中都含有一对方法，用于将字符串转换为数字，是parseXXXX()与valueOf()。但是两者是有区别的。例如：String num = “123”;
Integer a =Integer.valueOf(num);  //返回的是一个Integer对象
int b =Integer.parseInt(num);  //返回的是一个int型数据BigInteger类不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。BigInteger 提供所有 Java 的基本整数操作（加减乘除等基本运算），并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。内置常量：static BigInteger ONE           BigInteger 的常量 1。 static BigInteger TEN           BigInteger 的常量 10。 static BigInteger ZERO           BigInteger 的常量 0。构造方法：BigInteger(String val)           将 BigInteger 的十进制字符串表示形式转换为 BigInteger。BigInteger(String val, int radix)           将指定基数的 BigInteger 的字符串表示形式转换为BigInteger。方法摘要： BigInteger abs()           返回其值是此 BigInteger 的绝对值的BigInteger。 BigInteger add(BigInteger val)           返回其值为 (this + val) 的 BigInteger。  BigInteger divide(BigInteger val)           返回其值为 (this / val) 的 BigInteger。  BigInteger[] divideAndRemainder(BigIntegerval)           返回包含 (this / val) 后跟 (this %val) 的两个 BigInteger 的数组。 BigInteger gcd(BigInteger val)           返回一个 BigInteger，其值是abs(this) 和 abs(val) 的最大公约数。 boolean isProbablePrime(int certainty)           如果此 BigInteger 可能为素数，则返回true，如果它一定为合数，则返回 false。 BigInteger max(BigInteger val)           返回此 BigInteger 和 val 的最大值。  BigInteger min(BigInteger val)           返回此 BigInteger 和 val 的最小值。  BigInteger mod(BigInteger m)           返回其值为 (this mod m) 的 BigInteger。  BigInteger modInverse(BigInteger m)           返回其值为 (this-1 mod m) 的 BigInteger。  BigInteger modPow(BigInteger exponent,BigInteger m)           返回其值为 (thisexponentmod m) 的 BigInteger。 BigInteger multiply(BigInteger val)           返回其值为 (this * val) 的 BigInteger。  BigInteger negate()           返回其值是 (-this) 的 BigInteger。  BigInteger nextProbablePrime()           返回大于此 BigInteger 的可能为素数的第一个整数。  BigInteger pow(int exponent)           返回其值为 (thisexponent)的 BigInteger。 BigInteger remainder(BigInteger val)           返回其值为 (this % val) 的 BigInteger。 BigInteger subtract(BigInteger val)           返回其值为 (this - val) 的 BigInteger。 在这里需要对取余和取模做一下区分，求模运算与求余运算不同取余运算时，得到的结果符号永远与被除数相同，跟除数的符号无关。例如：             BigInteger a1 = newBigInteger("16");
             BigInteger b1 = newBigInteger("12");
            
             BigInteger a2 = newBigInteger("16");
             BigInteger b2 = newBigInteger("-12");
            
             System.out.println(a1.remainder((b1)));  //结果为4
             System.out.println(a2.remainder(b2));   //结果为4 取模时，被除数必须为正数，结果恒为正             BigInteger a1 = newBigInteger("-16");
             BigInteger b1 = newBigInteger("12");
            
             BigInteger a2 = newBigInteger("16");
             BigInteger b2 = newBigInteger("12");
            
             System.out.println(a1.mod((b1)));  //结果为8（-12*2+8=-16）
             System.out.println(a2.mod(b2));   //结果为4 （12+4=16）BigDecimal类不可变的、任意精度的有符号十进制数。BigDecimal由任意精度的整数非标度值和 32 位的整数标度 (scale) 组成。如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负 scale 次幂。因此，BigDecimal 表示的数值是 (unscaledValue × 10-scale)。BigDecimal 类使用户能完全控制舍入行为。如果未指定舍入模式，并且无法表示准确结果，则抛出一个异常；否则，通过向该操作提供适当的 MathContext 对象，可以对已选择的精度和舍入模式执行计算。构造方法摘要：BigDecimal(BigInteger val)           将 BigInteger 转换为BigDecimal。BigDecimal(BigInteger unscaledVal, int scale)           将 BigInteger 非标度值和 int 标度转换为BigDecimal。BigDecimal(char [] in)           将 BigDecimal 的字符数组表示形式转换为BigDecimalBigDecimal(double val)           将 double 转换为BigDecimal，后者是 double 的二进制浮点值准确的十进制表示形式。BigDecimal(int val)           将 int 转换为BigDecimal。BigDecimal(long val)           将 long 转换为BigDecimal。BigDecimal(String val)           将 BigDecimal 的字符串表示形式转换为BigDecimal。可见，BigDecimal类可以接受int、long、double、String以及BigInteger类型的数据来构造实例。一般来说，16位有效数字以下的运算使用Double类型就足够了，如果需要16位有效数字以上的，应该使用BigDecimal将BigDecimal转换为其他类型的数据时，就会涉及到舍入的问题，该类提供了8中舍入模式。 字段摘要：static BigDecimal ONE           值为 1，标度为 0。 static intROUND_CEILING           接近正无穷大的舍入模式。 static intROUND_DOWN           接近零的舍入模式。 static intROUND_FLOOR           接近负无穷大的舍入模式。 static intROUND_HALF_DOWN           向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。static intROUND_HALF_EVEN           向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。 static intROUND_HALF_UP           向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。static intROUND_UNNECESSARY           断言请求的操作具有精确的结果，因此不需要舍入。 static intROUND_UP           舍入远离零的舍入模式。 static BigDecimal TEN           值为 10，标度为 0。 static BigDecimal ZERO           值为 0，标度为 0。                    double d = 3.1415926;
             //接近正无穷大的舍入模式，5位精度，输出3.14160
             System.out.println(newBigDecimal(d).setScale(5, BigDecimal.ROUND_CEILING));
             //接近负无穷大的舍入模式，5位精度，输出3.14159
             System.out.println(new BigDecimal(d).setScale(5,BigDecimal.ROUND_FLOOR));
             //接近零的舍入模式，5位精度，输出3.14159
             System.out.println(newBigDecimal(d).setScale(5, BigDecimal.ROUND_DOWN));
             // 远离零的舍入模式，5位精度，输出3.14160
             System.out.println(newBigDecimal(d).setScale(5, BigDecimal.ROUND_UP));
             //四舍五入的舍入模式，5位精度，输出3.14159
             System.out.println(newBigDecimal(d).setScale(5, BigDecimal.ROUND_HALF_UP ));除了使用setScale()函数设置取舍模式，还可以在构造函数中传入一个MathContext对象来设置。如             double d = 3.1415926;
             //四舍五入的舍入模式，5位有效数字
             MathContext context = new MathContext(5,RoundingMode.HALF_UP);
             BigDecimal dec = newBigDecimal(d,context);
             System.out.println(dec);  //输出3.1416 方法摘要：BigDecimal abs()          返回 BigDecimal，其值为此BigDecimal 的绝对值，其标度为 this.scale()。BigDecimal add(BigDecimal augend)           返回一个 BigDecimal，其值为 (this +augend)，其标度为 max(this.scale(), augend.scale())。BigDecimal divide(BigDecimal divisor)           返回一个 BigDecimal，其值为 (this /divisor)，其首选标度为 (this.scale() - divisor.scale())；如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)           返回一个 BigDecimal，其值为 (this /divisor)，其标度为指定标度。BigDecimal [] divideAndRemainder(BigDecimal divisor)           返回由两个元素组成的 BigDecimal数组，该数组包含 divideToIntegralValue 的结果，后跟对两个操作数计算所得到的remainder。BigDecimal divideToIntegralValue(BigDecimal divisor)           返回 BigDecimal，其值为向下舍入所得商值(this / divisor) 的整数部分。BigDecimal max(BigDecimal val)           返回此 BigDecimal 和 val 的最大值。 BigDecimal min(BigDecimal val)           返回此 BigDecimal 和 val 的最小值。BigDecimal multiply(BigDecimal multiplicand)           返回一个 BigDecimal，其值为 (this ×multiplicand)，其标度为 (this.scale() + multiplicand.scale())。BigDecimalnegate()           返回 BigDecimal，其值为 (-this)，其标度为this.scale()。BigDecimal plus()          返回 BigDecimal，其值为 (+this)，其标度为this.scale()。BigDecimal pow(int n)           返回其值为 (thisn)的 BigDecimal，准确计算该幂，使其具有无限精度。int precision()           返回此 BigDecimal 的精度。 BigDecimal remainder(BigDecimal divisor)           返回其值为 (this % divisor)的 BigDecimal。int scale()           返回此 BigDecimal 的标度。 BigDecimal scaleByPowerOfTen(int n)           返回其数值等于 (this * 10n)的 BigDecimal。BigDecimal setScale(int newScale)           返回一个 BigDecimal，其标度为指定值，其值在数值上等于此 BigDecimal 的值。BigDecimal setScale(int newScale, int roundingMode)           返回一个 BigDecimal，其标度为指定值，其非标度值通过此 BigDecimal 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。BigDecimal setScale(int newScale, RoundingMode roundingMode)           返回 BigDecimal，其标度为指定值，其非标度值通过此 BigDecimal 的非标度值乘以或除以十的适当次幂来确定，以维护其总值。BigDecimal stripTrailingZeros()           返回数值上等于此小数，但从该表示形式移除所有尾部零的 BigDecimal。BigDecimal subtract(BigDecimal subtrahend)           返回一个 BigDecimal，其值为 (this -subtrahend)，其标度为 max(this.scale(), subtrahend.scale())。 java.text.DecimalFormat类可以控制浮点数的输出格式，前缀零、后缀零以及千位分隔符等import java.text.*;
 
public class DecimalFormatDemo {
 
   static public void customFormat(Stringpattern, double value ) {
      DecimalFormat myFormatter = newDecimalFormat(pattern);
      String output = myFormatter.format(value);
      System.out.println(value + "  " + pattern + "  " + output);
   }
 
   static public void main(String[] args) {
 
      customFormat("###,###.###",123456.789);
      customFormat("###.##",123456.789);
      customFormat("000000.000",123.78);
      customFormat("$###,###.###",12345.67); 
   }
}输出:123456.789  ###,###.### 123,456.789123456.789  ###.## 123456.79123.78  000000.000 000123.78012345.67  $###,###.### $12,345.67字符串String是不可变的对象，它们的值在创建之后不能更改。JDK中有很多方法看似改变了String，实际上是重新创建了一个包含修改结果的新的对象。String对象中有一个常用方法substring(int beginIndex, int endIndex)，该方法可以截取指定起始下标的子串。需要注意的是，指定的起始下标是“左闭右开”区间，包括JDK中的其他方法，如操作数组，集合等，都遵循这一原则。例如：String anotherPalindrome = "Niagara. O roar again!"; String roar =anotherPalindrome.substring(11,15);substring(11,15)得到的是下标为11、12、13、14字符组成的子串，不包括下标为15的字符。

版权声明：本文为博主原创文章，未经博主允许不得转载。

输入3个字符串，按字符串由短到长的顺序输出
输入3个字符串，按字符串由短到长的顺序输出，要求使用指针。


#include "stdafx.h"
#include<iostream>
#include<string.h>
#include<stdio.h>
using namespace std;


char a[80],b[80],c[80];
char *p1,*p2,*p3;

//输入三个字符串，三个字符型指针分别三个字符串
int _tmain(int argc, _TCHAR* argv[])
{
void bijiao();       //因为bijiao在main函数后面定义的，所以这里要先声明一下
cin>>a;
cin>>b;
cin>>c;
p1=a;
p2=b;
p3=c;


bijiao();


return 0;
}

//函数change将两个字符数组里存放的字符串交换
void change(char *a,char *b)
{
char t[100];
strcpy_s(t,80,a);       //strcpy_s是库函数strcpy的安全版本，这里它把从地址a开始且含有NULL结束符的字符串复制到数组t 的地址空间
strcpy_s(a,80,b);
strcpy_s(b,80,t);
}

//函数bijiao比较三个字符串长短并按从短到长排序
void bijiao()
{
int a_l,b_l,c_l;
a_l=strlen(a);       //strlen函数可计算字符串的长短，使用时要加上<string>头文件
b_l=strlen(b);
c_l=strlen(c);


if(a_l>b_l)
{
change(p1,p2);
}
if(a_l>c_l)
{
change(p1,p3);
}
if(b_l>c_l)
{
change(p2,p3);
}


cout<<endl;
cout<<a<<endl;
cout<<b<<endl;
cout<<c<<endl;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

struts2学习笔记——04
文件的上传：
1）表单需要注意的3点
2）struts2的文件上传实际上使用的是comons FileUpload组件，所以导入commons-upload-1.3.jar  commons-io-2.0.1.jar
3)struts进行文件上传需要使用fileupload拦截器
4）基本的文件上传：直接在action中定义如下3个属性
privatee File filedName;//文件对象
private Stgring contentType;//文件夹类型
private String FileName;//文件名称
5）进行文件的上传使用io流即可。
6）一次穿多个文件怎么办
若传递多个文件，则上述的3个属性，可以改为List类型！多个文件域的name属性值需要一致

7）可以对上传的文件进行限制吗？例如扩展名，内容类型，上传文件大小？若可以，则若出错，显示什么错误消息那？消息可以定制吗？
可以的！
可以通过配置fileuploadInterceptor拦截器的参数的方式进行限制











表单的重复提交：




























自定义拦截器：
1）具体步骤：
1.定义一个拦截器的类（实现interceptor接口，继承abstracInteceptor抽象类）
2.在struts.xml文件中配置











版权声明：本文为博主原创文章，未经博主允许不得转载。

【找规律（其实很神的东西）】【TJOI 2015】【bzoj 4001】概率论
4001: [TJOI2015]概率论
Time Limit: 10 Sec  Memory Limit: 128 MB
Submit: 568  Solved: 287

Description 

Input
输入一个正整数N，代表有根树的结点数
Output
输出这棵树期望的叶子节点数。要求误差小于1e-9
Sample Input
1

Sample Output
1.000000000

HINT
 1<=N<=10^9

题解：
找规律。。 
其实这题非常神，套用了各种知识。。然而vampire大神纯靠找规律A了，于是蒟蒻也跟着看了看，发现规律确实挺好找的。。。 
实际上答案就是n(n+1)2(2n−1) \frac {n(n+1)}{2(2n-1)} 。
Code：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

int main(){
    double n; scanf("%lf",&n);
    printf("%0.9f\n",((n*(n+1.0))/(4.0*n-2.0)));
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[Java Concurrency in Practice]第六章 任务执行
任务执行
任务就是抽象、离散的工作单元。把一个应用程序的工作分离到任务中，执行与任务的分离，可以简化程序的管理。
服务器应用程序应该兼具良好的吞吐量和快速的响应性。
6.1 在线程中执行任务
当围绕“任务执行”来设计应用程序结构时，第一步就是要找出清晰地任务边界。在理想的情况下，各个任务之间是相互独立：任务并不依赖于其他任务的状态、结构或边界效应。独立有利于实现并发，因为如果存在足够多的处理资源，那么这些独立的任务都可以并行执行。为了在调度与负载均衡等过程中实现更高的灵活性，每项任务还应该表示应用程序的一小部分处理能力。
在正常的负载下，服务器应用程序应该同时表现出良好的吞吐量和快速的响应性。应用程序提供商希望程序支持尽可能多的用户，从而降低每个每个用户的服务成本，而用户则希望获得尽快的响应。而且，当负荷过载时，应用程序的性能应该是逐渐降低，而不是直接失败。要实现上述目标，应该选择清晰的任务边界以及明确的任务执行策略。
大多数服务器应用程序都提供了一种自然的任务边界选择方式：以独立的客户请求为边界。Web服务器、邮件服务器、文件服务器、EJB容器以及数据库服务器等，这些服务器都能通过网络接受远程客户的连接请求。将独立的请求作为任务边界，既可以实现任务的独立性，又可以实现合理的任务规模。
6.1.1 串行地执行任务
在应用程序中可以通过多种策略来调度任务，而且其中一些策略能够更好地利用潜在的并发性。最简单的策略就是在单个线程中串行地执行各项任务。下面SingleThreadWebServer顺序地处理它的任务——接受达到80端吕的HTTP请求：
class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }
}
理论是正确的，但在实际环境中的执行性能却很糟糕，因为它每次只能处理一个请求。主线程在接受连接与处理相关请求等操作之间不断地交替运行。当服务器正在处理请求时，新到来的连接必须等待直到请求处理完成，然后服务器将再次调用accept。如果请求处理速度很快并且handleRequest可以立即返回，那么这种方法是可行的，但现实世界的Web服务器的情况却并非如此。
在Web请求的处理中包含了一组不同的运算与I/O操作。服务器必须处理套接字请求和写会响应，这些操作通常会由于网络阻塞或连通性问题而被阻塞。此外，服务器还可能处理文件I/O或者数据库请求，这些操作同样会阻塞。在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且还将彻底阻止等待中的请求被处理。如果请求阻塞时间过长，用户将认为服务器是不可用的，因为服务器看似失去了响应。同时，服务器的资源利用率非常低，因为当单线程在等待I/O操作完成时，CPU将处于空闲状态。
在服务器应用程序中，串行处理机制通常都无法提供高吞吐率或快速响应性。也有一些例外，例如，当任务数量很少且执行时间很长时，或者当服务器只为单个用户提供服务，并且该客户每次只发出一个请求时——但大多数服务器应用程序并不是按照这种方式来工作的。在某些情况下，串行处理方式能带来简单性和安全性。大多数GUI框架都通过单一的线程来串行地处理任务。
6.1.2 显式地为任务创建线程
通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性。如下程序所示：
class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final  Socket connection = socket.accept();
            Runnable task = new Runnable() {//使用线程处理每个请求
                    public void run() {
                        handleRequest(connection);
                    }
                };
            new Thread(task).start();
        }
    }
}
结构上类似于前面的单线程版本——主线程仍然不断地交替执行“接受外部连接”与“分发请求”等操作。区别在于，对于每个连接，主循环都将创建一个新线程来处理请求，而不是在主循环中进行处理。由此可得出3个主要结论：

任务处理程序从主线程中分离出来，使得主循环能够更快地重新等待下一个到来的请求。这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。
任务可以并行处理，从而能同时服务多个请求。如果有多个处理器，或者任务由于某种原因被阻塞，例如等待I/O完成，获取锁或者资源可用性等，程序的吞吐量将得到提高。
任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。

在正常的负载情况下，“为每个任务分配一个线程”的方法能提升串行执行的性能。只要请求的到达率不超出服务器的请求处理能力，那么这种方法可以同时带来更快地响应性和更高的吞吐率。
6.1.3 无限制创建线程的不足
在生产环境中，“为每个任务分配一个线程”这种方法存在一些缺陷，尤其是当需要创建大量的线程时：

线程声明周期的开销非常高。线程的创建与销毁并不是没有代价的。根据平台的不同，实际的开销也有所不同，但线程的创建过程都会需要时间，延迟处理的请求，并且需要JVM和操作系统提供一些辅助操作。如果请求的到达率非常高且请求的处理过程是轻量级的，例如大多数服务器应用程序就是这种情况，那么为每个请求创建一个新线程将消耗大量的计算资源。
资源消耗。活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用处理器的数量，那么有些线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用处理器的数量，那么有些线程将闲置。大量空闲的线程会占用许多内存，给垃圾回收期带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。如果你已经拥有足够多的线程使CPU保持忙碌状态，那么再创建更多地线程反而会降低性能。
稳定性。在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么很可能抛出OutOfMemoryError异常，要想从这种错误中恢复过来是非常危险的，更简单的办法是通过构造程序来避免超出这些限制。

在一定的范围范围内，增加线程可以提高系统的吞吐率，但如果超出了这个范围，再创造更多的线程只会降低程序的执行速度，并且如果过多地创建一个线程，那么整个应用程序将崩溃。要想避免这种危险，就应该对应用程序创建的线程数量进行限制，并且全面地测试应用程序，从而确保在线程数量达到限制时，程序也不会耗尽资源。
“每任务一线程”的问题在于它没有对创建的线程的数量进行任何限制，只限制了远程用户提交HTTP请求的速率。无限制的创建线程的行为在开发阶段可能表现还良好，但一旦部署后，并运行于高负载环境下，它的问题才会暴露出来。
6.2 Executor框架（任务与执行分开）
任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。前面两种通过线程来执行任务的策略，即把所有任务放在单个线程中执行，以及将每个任务放在各自的线程中执行。这两种方式都存在一些严格的限制：串行执行的问题在于其糟糕的响应性和吞吐量，而“为每个任务分配一个线程”的问题在于资源管理的复杂性。
就像“有界队列”防止应用程序过载而耗尽内存，线程池为线程管理提供了同样的好处。线程池简化了线程的管理工作，并且java.util.concurrent提供了一种灵活的线程池实现作为Executor框架的一部分。在Java类库中，任务执行的主要抽象不是Thread，而是Executor，如Executor接口所示：
public interface Executor {
    void execute(Runnable command);
}
Executor接口为灵活且强大的异步任务执行框架提供了基础，该框架能支持多重不同类型的任务执行策略。它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。
Executor基于生产者—消费者模式，提交任务的操作相当于生产者（生成待完成的工作单元），执行任务的线程则相当于消费者（执行完成这些工作单元）。如果要在程序中实现一个生产者—消费者的设计，那么最简单的方式通常就是使用Executor。
6.2.1 示例：基于Executor的Web服务器
class TaskExecutionWebServer {
    private static final int NTHREADS = 100;
    private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);

    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            };
            exec.execute(task);
        }
    }
}
通过使用Executor，将请求处理任务的提交与任务的实际执行解耦开来，并且只需采用另一种不同的Executor实现，就可以改变服务器的行为。改变Executor实现或配置所带来的影响远远小于改变任务提交方式带来的影响。通常，Executor的配置是一次性的，因此在部署阶段可以完成，而提交任务的代码却会不断地扩散到整个程序中，增加了修改的难度。
只要作些简单的修改，就可以让TaskExecutionWebServer像ThreadPerTaskWebServer那样一样运行：替换一个Executor，它为每个请求都创建一个新的线程。我们只需这样实现：
public class ThreadPerTaskExecutor implements Executor {
    public void execute(Runnable r) {
        new Thread(r).start();
    };
}
或者如果要像SingleThreadWebServer那样运行，则可以让Executor在调用线程中同步地执行所有任务：
public class WithinThreadExecutor implements Executor {
    public void execute(Runnable r) {
        r.run();
    };
}
所以使用Executor是很方便的，它可以让你很方便的更改线程的执行机制，做到了任务与执行的解耦与真正分离。
6.2.2 执行策略
通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。在执行策略中定义了任务执行的“What、Where、When、How“等方面，包括：

在什么（What）线程中执行任务？
任务按照什么（What）顺序执行（FIFO、LIFO、优先级）？
有多少个（How Many）任务能并发执行？
在队列中有多少个（How Many）任务在等待执行？
如果系统由于过载而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？
在执行一个任务之前或之后，应该进行哪些（What）动作？

各种执行策略都是一种资源管理工具，最佳策略取决于可用的计算资源以及对服务质量的需求。通过限制并发任务的数量，可以确保应用程序不会由于资源耗尽而失败，或者由于在稀缺资源的上发生竞争而严重影响性能。通过将任务的提交与任务的执行策略分离开来，有助于在部署阶段选择与可用硬件资源最匹配的执行策略。

每当看到下面这种形式的代码时： 
  new Thread(runnable).start() 
  并且你希望获得一种更灵活的执行策略时，请考虑使用Executor来代替Thread。

6.2.3 线程池
线程池，从字面含义来看，是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。
“在线程池中执行任务“比”为每个任务分配一个线程“优势更多。通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而延迟任务的执行，从而提高了响应性。通过适当调整线程池的大小，可以创建足够多得线程以便使处理器保持忙碌状态，同时还可以方式过多线程相互竞争资源而使应用程序耗尽内存或失败。
类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用Executors中的静态工厂方法之一来创建一个线程池： 
newFixedThreadPool。newFixedThreadPool将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化（如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程）。 
newCachedThreadPool。newCachedThreadPool将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。 
newSingleThreadExecutor。newSingleThreadExecutor是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能够确保依照任务在队列中的顺序来串行执行（例如FIFO、LIFO、优先级）。 
newScheduledThreadPool。newScheduledThreadPool创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。
newFixedThreadPool与newCachedThreadPool两个工厂方法返回通用的ThreadPoolExecutor实例。直接使用ThreadPoolExecutor，可以直接用来构造专门用途的Executor。
从”为每个任务分配一个线程“策略变成基于线程池的策略，将对应用程序的稳定性产生重大的影响：Web服务器不会再在高负载下失败（尽管服务器不会因为创建了过多的线程而失败，但在足够长的时间内，如果任务到达的速度总是超过任务执行的速度，那么服务器仍然有可能（只是更不易）耗尽内存，因为等待执行的Runnable队列将不断增长。可以通过使用一个有界的工作队列在Executor框架内部解决这个问题）。由于服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平缓地降低。通过使用Executor，可以实现各种调优、管理、监视、记录日志、错误报告和其他功能。
6.2.4 Executor的生命周期
JVM只有在所有（非守护）线程全部终止后才会退出。因此，如果无法正确地关闭Executor，那么JVM将无法结束。
由于Executor以异步方式来执行任务，因此在任何时刻，之前提交的任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。当关闭应用程序时，可能采用最平缓地关闭方式（完成所有已经启动的任务，并且不再接受任何新的任务），也可能采用最粗暴的关闭方式（直接关掉机房的电源），以及其他各种可能的方式。
误了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口，添加了一些用于生命周期管理的方（同时还有一些用于任务提交的便利方法）。如下给出了ExecutorService中的生命周期管理方法：
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    //  ... 其他用于任务提交的便利方法
}
ExecutorService的生命周期有3种状态：运行、关闭和已终止。ExecutorService在初始创建时处于运行状态。shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。shutdownNow方法将执行粗暴地关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。
在ExecutorService关闭后提交的任务将由”拒绝执行处理器“来处理，它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已经终止。通常在调用awaitTermination之后会立即调用shutdown，从而产生同步地关闭ExecutorService的效果。
下面LifecycleWebServer为Web Server提供了生命周期的支持进行了扩展，它支持两种关闭方式：通过编程手工的调用stop方法，另一种就是由客户端发送一个关闭请求然后再调用stop进行关闭。
class LifecycleWebServer {
    private final ExecutorService exec = ...;

    public void start() throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (!exec.isShutdown()) {
            try {
                final Socket conn = socket.accept();
                exec.execute(new Runnable() {
                    public void run() { handleRequest(conn); }
                });
            } catch (RejectedExecutionException e) {
                if (!exec.isShutdown())
                    log("task submission rejected", e);
            }
        }
    }

    public void stop() { exec.shutdown(); }

    void handleRequest(Socket connection) {
        Request req = readRequest(connection);
        if (isShutdownRequest(req))//判断客户端是否发送关闭请求
            stop();
        else
            dispatchRequest(req);
    }
}
6.2.5 延迟任务与周期任务
Timer类负责管理延迟任务（”在100ms后执行该任务“）以及周期任务（”每10ms执行一次该任务“）。然而，Timer存在一些缺陷，因此应该考虑使用ScheduledThreadPoolExecutor来代替它。可以通过ScheduleThreadPoolExecutor的构造函数或newScheduledThreadPool工厂方法来创建该类的对象。
Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他TimerTask的定时精确性。例如某个周期TimerTask需要每10ms执行一次，而另一个TimerTask需要执行40ms，那么这个周期任务或者在40ms任务执行完成后快速连续地调用4次，或者彻底”丢失“4次调用（取决于它是局域固定速率来调度还是基于固定延时来调度）。线程池能弥补这个缺陷，它可以提供多个线程来执行延迟任务和周期任务。
Timer的另一个问题是，如果TimerTask抛出了一个未检查的异常，那么Timer将表现出糟糕的行为。Timer线程并不捕获异常，因此当TimerTask抛出未检查的异常时将终止定时线程。这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。因此，已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度。（这个问题称之为”线程泄漏“）
由于Timer是启动一个线程来串行的从任务队列中取任务然后执行，如果任务抛出未检查异常，则这个异常不会被抛到调用Timer的线程，因为异常是不会从子线程抛到他的父线程中去的，所以只是Timer线程死掉，而它的父线程还会正常运行。只要某个任务抛出了未检测异常，如果你在计划任务将会得到一个携带“Timer already cancelled”信息的异常。但ScheduledThreadPoolExecutor能正确处理这些表现出错误行为的任务。在Java5.0或更高的JDK中奖很少使用Timer。
如下程序所示：
import static java.util.concurrent.TimeUnit.SECONDS;

import java.util.Timer;
import java.util.TimerTask;

public class OutOfTime
{
    public static void main(String[] args) throws Exception
    {
        Timer timer = new Timer();
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(1);
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(5);
    }

    static class ThrowTask extends TimerTask
    {
        public void run()
        {
            throw new RuntimeException();
        }
    }
}
抛出如下异常：
Exception in thread "Timer-0" java.lang.RuntimeException
    at OutOfTime$ThrowTask.run(OutOfTime.java:21)
    at java.util.TimerThread.mainLoop(Timer.java:555)
    at java.util.TimerThread.run(Timer.java:505)
Exception in thread "main" java.lang.IllegalStateException: Timer already cancelled.
    at java.util.Timer.sched(Timer.java:397)
    at java.util.Timer.schedule(Timer.java:193)
    at OutOfTime.main(OutOfTime.java:13)
如果你要自己创建调度服务，你可以使用类库中提供的DelayQueue，它是BlockingQueue的一个实现，是它为ScheduledThreadPoolExecutor提供了调度的功能。DelayQueue是管理实现Delayed接口的对象，只有在延迟期满时才能从中提取元素，该队列的头部是延迟期满后保存时间最长的 Delayed 元素。实现Delayed的getDelay方法可以告诉DelayQueue所剩余延迟时间（零或负值指示延迟时间已经用尽，表示延时期满），只有延时期满的对象才能放入队列中，在调用take时会调用getDelay进行判断是否延时期满。在放入队列过程中还会根据延时长短进行排序，排序的依据是compareTo（因为Delayed还实现了Comparable接口）方法。
6.3 找出可利用的并行性
Executor框架帮助制定执行策略，但如果要使用Executor，必须将任务表述为一个Runnable。在大多数服务器应用程序中都存在一个明显的任务边界：单个客户请求。但有时候，任务边界并非是显而易见的，例如在很多桌面应用程序中。即使是服务器应用程序，在单个客户请求中仍可能存在可发掘的并行性，例如数据库服务器。
下面我们开发一个组件的不同版本，每个版本允许的不同的并发性。示例是模拟浏览器渲染HTTP页面的功能，模拟一个页面渲染器组件。假设HTTP页面里只有文本标签，当然在文本中穿插着图片（图片标签还带有尺寸大小）。
6.3.1 示例：串行地页面渲染器
最简单的方法就是对HTML文档进行串行处理。当遇到文本标签时，将其绘制到图像缓存中。当遇到图像引用时，先通过网络获取它，然后再将其绘制到图像缓存中。程序只需将输入中的每个元素处理一次（甚至不需要缓存文档），如果页面很大，图片很的多的情况下会让用户等等很长时间。
另一种串行执行方法更好一些，它先绘制文本元素，同时为图像预留出矩形的占位空间，在处理完了第一遍文本后，程序再开始下载图像，并将它们绘制到对应的占位空间中。SingleThreadRenderer就采用了这种方式：
public class SingleThreadRenderer {
    void renderPage(CharSequence source) {
        renderText(source);//渲染文本，并预留图像占位框
        List<ImageData> imageData = new ArrayList<ImageData>();
        for (ImageInfo imageInfo : scanForImageInfo(source))//扫描所有图像
            imageData.add(imageInfo.downloadImage());
        for (ImageData data : imageData)
            renderImage(data);//下载并渲染图像
    }
}
图像下载过程的大部分时间都是在等待I/O操作执行完成，在这期间CPU几乎不做任何工作。因此，这种串行执行方法没有充分地利用CPU，使得用户在看到最终页面之前要等待过长的时间。通过将问题分解为多个独立的任务并发执行，能够获得更高的CPU利用率和响应灵敏度。
6.3.2 携带结果的任务Callable与Future
Executor框架使用Runnable作为其基本的任务表示形式。Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但Runnable不具有返回值与抛出受检查异常。
Callable：它认为主入口点（即call）将返回一个值，并可能抛出一个异常。
如果Callable不需要返回值，可以使用Callable<void>。
在Executor中包含了一些辅助方法能将其他类型的任务封装为一个Callable，例如Runnable和java.security.PrivilegedAction。
Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确地起始点，并且最终会结束。Executor执行的任务有4个生命周期：创建、提交、开始和完成。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。
Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。在Future规范中包含的隐含意义是，任务的生命周期只能前进，不能后退，就像ExecutorService的生命周期一样。当某个任务完成后，它就永远停留在“完成”状态上。下面是Future与Callable接口：
public interface Callable<V> {
    V call() throws Exception;
}

public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException,
                   CancellationException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException,
               CancellationException, TimeoutException;
}
在Executor框架中，总可以取消（shutdown、shutdownNow）已经提交但未开始的任务，但是对于已经开始执行的任务，只有它们响应中断才可以取消。取消已经完成的任务没有影响。   
Future描述了任务的任命周期，并提供了相关方法来获取结果（get）、取消任务（cancel）以及检查任务是已经完成（isDone）还是被取消（isCancelled）。
Future任务生命周期是单向的，不能向后转换——与ExecutorService的生命周期一样，一旦任务，它就永远停留在完成状态上。
get方法的行为取决于任务的状态（尚未开始、正在运行、已完成）。如果任务已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。如果任务跑出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationException。如果get爬出了ExecutionException，那么可以通过getCause来获得被封装的初始异常。下面是get的源码片段：
V innerGet() throws InterruptedException, ExecutionException {
    acquireSharedInterruptibly(0);//如果未执行完会在这里阻塞
    if (getState() == CANCELLED)//如果任务已取消
        throw new CancellationException();
    if (exception != null)//如果任务执行的过程中抛出异常
        throw new ExecutionException(exception);
    return result;
}
可以通过许多种方法创建一个Future来描述任务。ExecutorService中所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor，并得到一个Future用来获得任务的结果或者取消任务。还可以显式地为某个指定的Runnable或Callable实例化一个FutureTask。（由于FutureTask实现了Runnable，因此可以将它提交给Executor来执行或者直接调用它的run方法（将它包装成Thread后当作线程执行，因为FutureTask具有Future特性，所以已可取消或获取执行结果））
从Java6开始，ExecutorService实现可以改写AbstractExecutorService中的newTaskFor方法，从而根据已提交的Runnable或Callable来控制Future的实例化过程。在默认实现中仅创建了一个新的FutureTask，如下所示：
protected <T> RunnableFuture<T> newTaskFor(Callable<T> task)
{
    return new FutureTask<T>(task);
}
将Runnable或Callable对象提交到Executor是一个对象安全发布的过程，即Runnable或Callable对象从提交线程传递到任务执行的任务的过程是线程安全的，我们不用担心这些对象是否完全初始（Runnable与Callable对象的工作内存中的数据写回到主内存中）。类似地，通过Future的get方法获取任务执行结果也是一个安全发布的对象，即将这个结果从计算它的线程发布到任何通过get获得它的线程。
6.3.3 示例：使用Future实现页面渲染
为了使页面渲染器实现更高的并发性，首先将渲染过程分解为两个任务，一个是渲染所有的文本，另一个是下载所有的图像。（因为其中一个任务是CPU密集型，而另一个任务是I/O密集型，因此这种方法即使在单CPU系统上也能提升性能。）
使用Future等待图像下载：
public class FutureRenderer {
    private final ExecutorService executor = ...;

    void renderPage(CharSequence source) {
        final List<ImageInfo> imageInfos = scanForImageInfo(source);
        Callable<List<ImageData>> task =//图像下载任务
                new Callable<List<ImageData>>() {
                    public List<ImageData> call() {
                        List<ImageData> result//存储下载的图片
                                = new ArrayList<ImageData>();
                        for (ImageInfo imageInfo : imageInfos)
                            result.add(imageInfo.downloadImage());
                        return result;//返回下载的图片
                    }
                };

        Future<List<ImageData>> future =  executor.submit(task);//在渲染文本前启动
        renderText(source);//开始渲染文本

        try {
            List<ImageData> imageData =  future.get();//阻塞获取下载的图片
            for (ImageData data : imageData)
                renderImage(data);//待图片下载完后开始渲染图像
        } catch (InterruptedException e) {
            // 恢复中断状态
            Thread.currentThread().interrupt();
            // 我们不需要结果了，所以可以将任务取消
            future.cancel(true);
        } catch (ExecutionException e) {
            throw launderThrowable(e.getCause());
        }
    }
}
Future.get的异常处理代码将处理两个可能的问题：任务遇到了一个Exception，或者调用get的线程在获得结果之前被中断。
虽然上面在一定程度上提高了并发性，然后，我们还可以做得更好，用户不必等到怕有的图像下载完成后一下子看到所有图片，他们或许更希望只要下载完一幅图像就要看到一幅。
FutureRenderer用到了两个任务：一个负责渲染文本，一个负责下载图像。如果渲染文件的速度远远大于下载图像的速度（这完全是有可能的），那么最终的性能与顺序执行版的性能不会有很大的不同，反倒提高了代码的复杂度。
6.3.4 在异构任务并行化中存在的局限
在上个示例中，我们尝试并行地执行两个不同类型的任务——下载图像与渲染页面。然而，通过对异构任务进行并行化来获得重大的性能提升是很困难的。
两个人可以很好地分担洗碗的工作：其中一个人负责清洗，而另一个人负责烘干。然而，要将不同类型的任务平均分配给每个工人却并不容易。当人数增加时，如何确保它们能帮忙而不是妨碍其他人工作，或者在重新分配工作时，并不是容易的事情。如果没有在相似的任务之间找出细粒度的并行性，那么这种方法带来的好处将减少。
当在多个工人之间分配异构的任务时，还有一个问题就是各个任务的大小可能完全不同。如果将两个任务A和B分配给两个工人，但A的执行时间是B的10倍，那么整个过程也只能加速9%。最后，当在多个工厂之间分解任务时，还需要一定的任务协调开销：为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。
FutureRenderer使用了两个任务，其中一个负责渲染文本，另一个负责下载图像。如果渲染文本的速度远远高于下载图像的速度（可能性很大），那么程序的最终性能与串行执行时的性能差别不大，而代码却变得更复杂了。当使用两个线程时，至多能将速度提高一倍。因此，虽然做了许多工作来并发执行异构任务以提高并发度，但从中获得的并发性却是十分有限的。
只有当大量相互独立且同构的任务可以并发进行处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。
6.3.5 CompletionService:Executor与BlockingQueue
如果将Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout指定为0，从而通过轮询来判断任务是否完成。这种方法虽然可行，但却有些繁琐。幸运的是，还有一种更好地方法：完成服务（CompletionService）。
如果你向Executor提交了一批任务并且还要处理这批任务返回的结果，我们可以通过Executor的实现类ExecutorService的“List
private class QueueingFuture<V> extends FutureTask<V>
{
    QueueingFuture(Callable<V> c){ super(c); }
    QueueingFuture(Runnable t,V r){ super(t,r); }

    protected void done()
    {
        completionQueue.add(this);
    }

    ...
}
ExecutorCompletionService的使用大致如下：
//包装一个Executor
ExecutorCompletionService service = new ExecutorCompletionService(executor);
//在循环中一个个提交任务，因为CompletionService不像ExecutorService具
//有任务批量提交方法invokeAll
for (Callable<Integer> task : tasks) service.submit(task);
//在循环中从队列中获取任务结果，结果的个数就是任务的个数，taks为任务集合
for (int i = 0; i < taks.size(); i++)
   count += service.take().get();//从阻塞队列中取出Futur，再读取结果，这里的结果肯定是执行完或取消的任务，调用get是不会阻塞的，但take是可能被阻塞的。
6.3.6 示例：使用CompletionService实现页面渲染器
可以通过CompletionService从两个方面来提升页面渲染器的性能：缩短总运行时间以及提高响应性。为每一幅图像的下载都创建一个独立的任务，并在线程池中执行它们，从而将串行地下载过程转换为并行的过程：这将减少下载所有图像的总时间。此外，通过从CompletionService中获取结果以及使每张图片在下载完成后立刻显示出来，能使用户获得一个更加动态和更高响应性的用户界面。如下程序所示：
public class Renderer {
       private final ExecutorService executor;

       Renderer(ExecutorService executor) {
              this.executor = executor;
       }

       void renderPage(CharSequence source) {
              final List<ImageInfo> info = scanForImageInfo(source);
              //对ExecutorService进行包装，转换成CompletionService
              CompletionService<ImageData> completionService =
                     new ExecutorCompletionService<ImageData>(executor);
              for (final ImageInfo imageInfo : info)//对图像信息循环
                     //每幅图像一个下载任务
                     completionService.submit(new Callable<ImageData>() {
                            public ImageData call() {
                                   return imageInfo.downloadImage();
                            }
                     });
              //当所有图像下载任务启动后进行文本渲染工作
              renderText(source);

              try {
                     //返回结果数目与任务数相等，对结果进行遍历
                     for (int t = 0, n = info.size(); t < n; t++) {
                            //从结果队列中获取Future结果对象，来一个就取一个，但这里有可能阻塞
                            Future<ImageData> f = completionService.take();
                            //获取任务结果，这里不可能被阻塞
                            ImageData imageData = f.get();
                            renderImage(imageData);//开始渲染图像
                     }
              } catch (InterruptedException e) {
                     Thread.currentThread().interrupt();
              } catch (ExecutionException e) {
                     throw launderThrowable(e.getCause());
              }
       }
}
多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。
6.3.7 为任务设置时限
有时候，如果某个任务无法在指定的时间内完成，那么将不再需要它的结果，此时可以放弃这个任务。例如，某个Web应用程序从外部的广告服务器上获取广告信息，但如果该应用程序在两秒内得不到响应，那么将显示一个默认的广告，这样即使不能获得广告信息，也不会降低站点的响应性能。类似地，一个门户网站可以从多个数据源并行地获取数据，但数据只会在指定的时间内等待数据，如果超出了等待时间，那么只显示已经获得的数据。
在有限时间内执行任务的主要困难在于，要确保得到答案的时间不会超过限定的的时间，或者在限定的时间内无法获得答案。在支持时间限制地Future.get中支持这种需求：当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出TimeoutException。
在使用显示任务时需要注意，当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。要实现这个功能，可以由任务本身来管理它的限定时间，并且在超时后终止执行或取消任务。此时可再次使用Future，如果一个限时的get方法抛出了TimeoutException，那么可以通过Future来取消任务。如果编写的任务是可取消的，那么可以提前中止它，以免消耗过多的资源。
下面演示了限时的Future.get的一种典型应用，在指定时间内获取广告信息，如果get超时，会取消获取广告的任务，并使用默认信息代替：
Page renderPageWithAd() throws InterruptedException {
    long endNanos = System.nanoTime() + TIME_BUDGET;//预计任务在这个点运行完
    Future<Ad> f = exec.submit(new FetchAdTask());//提交下载广告任务
    // 在等待广告的时渲染页面
    Page page = renderPageBody();
    Ad ad;//广告
    try {
        // 仅需等待所剩余的预计时间
        long timeLeft = endNanos - System.nanoTime();
        ad = f.get(timeLeft, NANOSECONDS);//在限时内获取结果
    } catch (ExecutionException e) {
        ad = DEFAULT_AD;//如果广告任务执行失败，则设置默认广告
    } catch (TimeoutException e) {
        ad = DEFAULT_AD; //如果广告下载超时，则设置默认广告
        f.cancel(true);//并取消广告下载任务
    }
    page.setAd(ad);//为页面设置广告
    return page;
}
上面是单个任务采用Future.get来限时的，如果现在我们要对一批任务进行限时，且我们不关心任务是否全部完成，则我们可以通过Executor的invokeAll、invokeAny的限时版本来提交任务。invokeAll会在指定的时间内一定会返回Future列表，但列表里可能会有被取消的任务；invokeAny只要有一个任务完成。
小结
通过围绕任务执行来设计应用程序，可以简化开发过程，并有助于实现并发。Executor框架将任务提交与执行策略解耦开来，同时还支持多种不同类型的执行策略。当需要创建线程来执行任务时，可以考虑使用Executor。要想在将应用程序分解为不同的任务时获得最大的好处，必须定义清晰的任务边界。某些应用程序中存在着比较明显的任务边界，而在其他一些程序中则需要进一步分析才能揭示出粒度更细的并行性。
方法小结
Future的get、cancel、isCancelled、isDone方法
get：在任务完成前一直阻塞。会抛出三种异常：CancellationException - 如果计算被取消、ExecutionException - 如果计算抛出异常、InterruptedException - 如果当前的线程在等待时被中断。
get(long timeout, TimeUnit unit)：在超时之前且任务未完成则一直阻塞。除抛出以上三种异常
cancel(boolean mayInterruptIfRunning)：试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。当调用cancel时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经启动，则mayInterruptIfRunning参数决定了是否调用运行任务的线程的interrupt操作。
isCancelled：如果在任务正常完成前将其取消，则返回true
isDone：正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true 
ExecutorService的submit、invokeAll、invokeAny方法
ExecutorService的有三个重载的submit方法：
1、    可以接收Runnable或Callable类型的任务，返回Future<?>类型的Future的get返回null。 
2、    这三个方法都将提交的任务转换成了Future的实现类FutureTask实例，并作为submit的返回实例。 
3、    另外调用这三个方法不会阻塞，不像invokeAll那样要等到所有任务完成后才返回，与不像invokeAny那样要等到有一个任务完成后才返回Future。 
4、    这个三方法会调用Executor的execute来完成，因为Executor的execute会抛出RejectedExecutionException - 如果不能接受执行此任务、NullPointerException - 如果命令为 null这两个运行进异常，所以这三个方法也会抛出这两个异常。
T invokeAny(Collection<Callable<T>> tasks)： 
1、    只要某个任务已成功完成（也就是未抛出异常，这与任务完成概念不一样：任务完成是指定Future的isDone返回true，有可能是抛出异常后进行完成状态），才返回这个结果。一旦正常或异常返回后，则取消尚未完成的任务（即任务所运行的线程处理中断状态，一旦在它上面出现可中断阻塞的方法调用，则会抛出中断异常）。 
2、    此方法会阻塞到有一个任务完成为止（正常完成或异常退出）。 
3、    也是调用Executor的execute来完成 
4、    调用get不会阻塞
invokeAny(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)： 
1、    只要在给定的超时期满前某个任务已成功完成（也就是invokeAny方法不能抛出异常，包括Future.get所抛的异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。 
2、    此方法会阻塞到有一个任务完成为止（正常完成或异常退出）。 
3、    也是调用Executor的execute来完成 
4、    调用get不会阻塞
List<Future<T>> invokeAll(Collection<Callable<T>> tasks)： 
1、    只有当所有任务完成时，才返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。注意，可以正常地或通过抛出异常来已完成任务。 
2、    此方法会阻塞到所有任务完成为止（正常完成或异常退出）。 
3、    也是调用Executor的execute来完成，如果任务执行过程中抛出了其他异常，则方法会异常退出，且取消所有其他还未执行完成的任务。 
4、    返回的列表中的Future都是已经完成的任务，get时不会再阻塞
invokeAll(Collection<Callable<T>> tasks, long timeout,  TimeUnit unit)： 
1、    当所有任务完成或超时期满时（无论哪个首先发生），返回保持任务状态和结果的 Future 列表（如果是超时返回的列表，则列表中的会包括这些还未执行完的任务，使用get获取结果时可能会抛出CancellationException异常）。返回列表的所有元素的 Future.isDone() 为 true。一旦返回后，即取消尚未完成的任务。注意，可以正常地或通过抛出异常来完成任务。 
2、    此方法会阻塞到所有任务完成为止（正常完成或异常退出或超时）。 
3、    也是调用Executor的execute来完成，如果任务执行过程中抛出了其他异常，则方法会异常退出，且取消所有其他还未执行完成的任务。 
4、    返回的列表中的Future中会有因超时执行任务时异常而未执行完的任务，get时会抛出CancellationException或ExecutionException，当然所有的Future的get也不会阻塞。
参考：Java并发编程

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java-List源码分析
纸上得来终觉浅，绝知此事要躬行
  --陆游    问渠那得清如许，为有源头活水来  --朱熹



List继承自Collection的接口，List也是集合的一种。List是有序队列，List中的没一个元素都会有一个索引，第一个元素的索引是0，往后的元素的索引值依次+1，List中允许有重复的元素。
List接口源码：

public interface List<E> extends Collection<E> {
    int size();//大小
    boolean isEmpty();//判断是否为空
    boolean contains(Object o);//判断是否包含某个对象
    Iterator<E> iterator();//返回迭代对象
    Object[] toArray(); //返回对象数组
    <T> T[] toArray(T[] a);//对象数组
    boolean add(E e);//添加某个对象
    boolean remove(Object o);//删除某个对象
    boolean containsAll(Collection<?> c); // 是否包含某个Collection的所有对象
    boolean addAll(Collection<? extends E> c);//将Collection对象追加到List中
    boolean addAll(int index, Collection<? extends E> c);//在某个位置将Collection对象追加到List中
    boolean removeAll(Collection<?> c);//去掉Collection中所包含的对象
    boolean retainAll(Collection<?> c);//去掉不包含在Collection中所包含的对象
    default void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final ListIterator<E> li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }
    @SuppressWarnings({"unchecked", "rawtypes"})
    default void sort(Comparator<? super E> c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator<E> i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }
    void clear();//删除所有对象
    boolean equals(Object o);//判断两个list是否相同
    int hashCode();//返回List的hashCode
    E get(int index);//返回某个位置的对象
    E set(int index, E element);//替换某个位置的对象
    void add(int index, E element);//在某个位置添加对象
    E remove(int index);//删除某个位置的对象
    int indexOf(Object o);//返回某个对象在List中的位置
    int lastIndexOf(Object o);//List中最后一个对象的坐标
    ListIterator<E> listIterator();//返回整个List的迭代
    ListIterator<E> listIterator(int index); //从某个位置开始返回List的迭代
    List<E> subList(int fromIndex, int toIndex);//截取部分List
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.ORDERED);
    }
}


版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

新浪爱彩_竞彩足球 Excel_Vba
Sub 新浪爱彩_竞彩足球()
    On Error Resume Next
    s = Format(Date, "yymmdd")
    Cells.Clear
    at = Array("hrank", "grank", "fight.win", "fight.draw", "fight.lose", "odds[21].fwin", "odds[21].fdrow", "odds[21].flose", "odds[21].win", _
               "odds[21].drow", "odds[21].lose", "odds[26].fwin", "odds[26].fdrow", "odds[26].flose", "odds[26].win", "odds[26].drow", "odds[26].lose", _
               "odds[23].fwin", "odds[23].fdrow", "odds[23].flose", "odds[23].win", "odds[23].drow", "odds[23].lose", "odds[184].fwin", "odds[184].fdrow", _
               "odds[184].flose", "odds[184].win", "odds[184].drow", "odds[184].lose", "asia[11].fwin", "asia[11].ftape", "asia[11].flose", "asia[11].win", _
               "asia[11].tape", "asia[11].lose", "asia[6].fwin", "asia[6].ftape", "asia[6].flose", "asia[6].win", "asia[6].tape", "asia[6].lose", "asia[10].fwin", _
               "asia[10].ftape", "asia[10].flose", "asia[10].win", "asia[10].tape", "asia[10].lose", "asia[13].fwin", "asia[13].ftape", "asia[13].flose", _
               "asia[13].win", "asia[13].tape", "asia[13].lose", "asia[12].fwin", "asia[12].ftape", "asia[12].flose", "asia[12].win", "asia[12].tape", _
               "asia[12].lose", "index.fkelly.win", "index.fkelly.drow", "index.fkelly.lose", "index.kelly.win", "index.kelly.drow", "index.kelly.lose", "avgOdds.fwin", _
               "avgOdds.fdrow", "avgOdds.flose", "avgOdds.win", "avgOdds.drow", "avgOdds.lose", "bf.price.win", "bf.price.drow", "bf.price.lose", "bf.index.win", _
               "bf.index.drow", "bf.index.lose", "radio", "let", "sp.jczq_xspf_gd", "sp.jczq_spf_gd", "sp.jczq_bf_gd", "sp.jczq_bcspf_gd", "sp.jczq_zjqs_gd", "col", _
               "url", "hostUrl", "guestUrl", "hscore", "ascore", "hhscore", "ahscore")
    bt = Array("fixId", "concede", "forbid4071", "forbid4076", "forbid4072", "forbid4073", "forbid4074", "weekIndex", "weekName", "matchDate", "matchId", "matchTime", "endTime", _
               "zcMatchDate", "wholeScore", "xspfSp", "zkjcletno", "spletno", "spfSp", "zkjcletyes", "spletyes", "srfspletyes", "bfSp", "zjqSp", "bqcSp", "resultXspf", "resultSpf", "resultBf", _
               "resultZjq", "resultBqc", "isMiddle", "matchName", "matchNameIndex", "homeTeam", "guestTeam")
    [a1:df1] = Array("", "", "", "", "", "", "", "", "", "", "", "", "开赛时间", "", "", "胜 平 负 0", "", "", "胜 平 负 1", "", "", "", "", "", "", "", "", "", "", "", "", "赛事", "", "主队", "客队", "", "", "", "", "", "威廉初盘", "", "", "威廉即盘", "", "", "立博初盘", "", "", "立博即盘", "", "", "韦德初盘", "", "", "韦德即盘", "", "", "易胜博初盘", "", "", "易胜博即盘", "", "", "澳门初盘", "", "", "澳门即盘 ", "", "", "韦德初盘", "", "", "韦德即盘", "", "", "皇冠初盘", "", "", "皇冠即盘", "", "", "立博初盘", "", "", "立博即盘", "", "", "易胜博初盘", "", "", "易胜博即盘", "", "", "凯利初盘", "", "", "凯利即盘", "", "", "", "", "", "", "", "", "必发价位", "", "", "必发指数")

    Set ms = CreateObject("MSScriptControl.ScriptControl")
    ms.Language = "javascript"

    With CreateObject("Microsoft.XMLHTTP")
        .Open "GET", "http://www.aicai.com/lotnew/jc/getMatchByDate.htm?lotteryType=jczq&cate=gd&dataStr=" & s & "&time=" & ms.eval("new Date().getTime();"), False
        .send
        ms.AddCode "a=" & Replace(Replace(Replace(.responsetext, "':{'00", "':{'"), "'},'0", "'},'"), "'},'0", "'},'")

        For i = 1 To 500
            For j = 0 To 34
                Cells(i + 1, j + 1) = ms.eval("a.raceList[" & i & "]." & bt(j))
            Next j
        Next i

        .Open "GET", "http://www.aicai.com/static/no_cache/jc/zcnew/data/hist/" & s & "zcRefer.js", False
        .send
        ms.AddCode "a=" & .responsetext

        For i = 1 To 500
            For j = 0 To 91
                Cells(i + 1, j + 36) = ms.eval("a[" & Cells(i + 1, 1) & "]." & at(j))
            Next j
        Next i
    End With
End Sub


版权声明：本文为博主原创文章，未经博主允许不得转载。

Dungeon Game


Dungeon Game






题目



The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.

Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.


Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.

For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.





-2 (开始点)
-3           
3               


-5
-10
1


10
30           
-5（结束点）



Notes:

The knight's health has no upper bound.
Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.




题目大致意思：


恶魔抓走了公主(P)并把她囚禁在地牢的右下角。地牢包含M x N个房间，排列成一个二维的格子。我们英勇的骑士(K)一开始位于左上角的房间里，需要一路披荆斩棘营救公主。

骑士拥有一个正整数的初始生命值。如果在任何一点其生命值≤0，他立刻会死去。

一些房间由恶魔守卫着，因此当骑士进入这些房间时就会损失生命值（负整数）；其他房间或者是空的（数值为0），或者包含一些魔力宝珠（magic orbs）可以增加骑士的生命值（正整数）。

为了尽可能快的解救公主，骑士决定每一步只向右或者向下移动。

编写一个函数决定骑士的最小初始生命值，确保他可以成功营救公主。

例如，给定下面的地牢，骑士的初始生命值至少应当为7，如果他按照下面的最优路线行进：右 -> 右 -> 下 -> 下.




-2 (开始点)
-3           
3               


-5
-10
1


10
30           
-5（结束点）



备注：

骑士的生命值没有上界

任何房间都可能包含威胁或者补给，即使骑士进入的第一个房间或者囚禁公主的最后一个房间也一样。





思路:从表格开始入手，因为要使得达到最后的节点（结束点）血量大于0





-2 (开始点)
-3           
3               


-5
-10
1


10
30           
-5（结束点）





我们定义一个数组dp[i][j],表示骑士在点i,j处至少需要的血量，又因为血量必须大于0，并且从最后一个点往前面类推，运用动态规划的思路，对于结束点，我们有如下dp数组





(开始点)
 
 


 
 
 


 
 
6（结束点）





这里的6怎么来的：因为在最后一格需要消耗-5，那么骑士达到此处是至少需要6点血量，使得6+（-5）=1>0,这样才不会死掉




这样我们可以类推，最后一行，和最后一列的数据


为什么是最后一行，最后一列，因为如果骑士此时处于最后一行或者最后一列的某一个点，只有一条路径达到结束点（最后一行，往右走，最后一列，往下走）

  for(int i=row-2;i>=0;i--)
            dp[i][col-1]=Max(dp[i+1][col-1]-dungeon[i][col-1],1);

        for(int i=col-2;i>=0;i--)
            dp[row-1][i]=Max(dp[row-1][i+1]-dungeon[row-1][i],1);




初始化得到最后一行，和最后一列的数据





(开始点)
 
2              


 
 
5


1
1           
6（结束点）





然后根据求的的最后一行和最后一列的数据，用动态规划思想，求的其他点的最少血量





7(开始点)
5          
2              


6
11           
5


1
1           
6（结束点）




最后返回 dp[0][0]即可

代码如下：

class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {

        int row=dungeon.size();
        int col=dungeon[0].size();

        int dp[row][col]; //表示到某一点是至少需要 的 血 ，从最后一个点开始，最少需要6，因为6-5=1>0

         dp[row-1][col-1]=Max(1-dungeon[row-1][col-1],1) ;//表示最后一个需要的

        for(int i=row-2;i>=0;i--)
            dp[i][col-1]=Max(dp[i+1][col-1]-dungeon[i][col-1],1);

        for(int i=col-2;i>=0;i--)
            dp[row-1][i]=Max(dp[row-1][i+1]-dungeon[row-1][i],1);

        for(int i=row-2;i>=0;i--)
        {
            for(int j=col-2;j>=0;j--)
            {
                int right=Max(dp[i][j+1]-dungeon[i][j],1);
                int down=Max(dp[i+1][j]-dungeon[i][j],1);

                dp[i][j]=Min(right,down);
            }
        }

        return dp[0][0];
    }

    int Max(int a,int b)
    {
        return a>b?a:b;
    }
    int Min(int a,int b)
    {
        return a>b?b:a;
    }
};









版权声明：本文为博主原创文章，未经博主允许不得转载。

STL vector的使用(三)遍历
一. vector的遍历总类：
1. 未用名字空间，使用vector 进行遍历：

	for(std::vector<std::string>::size_type index = 0; index < vect.size();index++)
	{
		std::cout << vect[index]   << std::endl;
	}
2. 使用名字空间,使用vector进行遍历：


	for(int index = 0; index < vect.size();index++)
	{
		cout << vect[index]   << endl;
	}

3.  利用迭代器，对vector进行遍历：

	vector<string>::iterator it = vect.begin();

	for(;it != vect.end();it++)
	{
		cout << *it  << endl;
	}







版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu4267--A Simple Problem with Integers（树状数组）
题目链接：点击打开链接
题目大意：有一个n个数的序列，有两种操作1 a b k c 在区间[a,b]内的i，如果满足(i-a)%k == 0 那么第i个数就加上c，
2 a问第a个数的值是什么，首先给出n个数的初始值，然后是q次操作，完成每次操作，如果是询问的话，输出那个值。
第一次考虑用线段树，如果一次操作1 a b k c中[a,b]能覆盖当前线段树的一个小段[l,r]的话，那么对于这个小段中的i，
如果满足(i-a)%k == 0 ，那么第i个数的值就会加c，我们将式子变形一下( (i-l)+(l-a) )%k == 0，这个对于一个给定的i来说，(i-l)的值是确定的，那么只需要枚举k(1～10)就可以计算出会有多少个操作对第i个数存在影响，而且对于不同操作来说如果k和(l-a)%k的值都是相同的，那么他们作用的i也就是相同的，就可以合并。cl[ rt ][ k ][ (l-a)%k ]，线段树这样建立，对于每次询问就可以log(n)的时间查询对第i个数的修改情况，在加上初始值，就是最终的结果。
但是这样做一直MLE，所以将它转化成树状数组，把一次修改拆成两部分:
1 a b k c拆成 1 a n k c和1 (b-a)/k*k+a+k n k -c，其中(r-l)/k*k+l+k是从a开始不断累加k中第一个超过b的数，这样就可以保证原来的操作是不变的。
转化成装数组之后，就把原本的每段的l转化成了累加的时候的节点的位置，按照同样的方法储存数据，求每个数在它之前存在的所有操作对它的影响，这样计算出最终结果。
#include <cstdio>
#include <cstring>
#include <queue>
#include <set>
#include <vector>
#include <cmath>
#include <map>
#include <stack>
#include <algorithm>
using namespace std ;
#pragma comment(linker, "/STACK:102400000,102400000")
#define LL __int64
#define INF 0x3f3f3f3f
#define PI acos(-1.0)
#define root 1,n,1
#define lson l,(l+r)/2,rt<<1
#define rson (l+r)/2+1,r,rt<<1|1
#define int_rt int l,int r,int rt
const int mod=1e9+7;
const int MAXN = 50000+10 ;
int cl[MAXN][11][11] , a[MAXN] ;
int n , q ;
int lowbit(int x) {
    return x & -x ;
}
void add(int a,int k,int c) {
    int i = a , temp ;
    while( i <= n ) {
        temp = (i-a)%k ;
        if( temp == 0 ) temp = k ;
        cl[i][k][temp] += c ;
        i += lowbit(i) ;
    }
}
int sum(int a) {
    int i = a , j , temp , ans = 0 ;
    while( i ) {
        for(j = 1 ; j < 11 ; j++)
            ans += cl[i][j][ j-(a-i)%j ] ;
        i -= lowbit(i) ;
    }
    return ans ;
}
int main() {
    int i , j , k , l , r , c ;
    while( scanf("%d", &n) != EOF ) {
        for(i = 1 ; i <= n ; i++)
            scanf("%d", &a[i]) ;
        memset(cl,0,sizeof(cl)) ;
        scanf("%d", &q) ;
        while( q-- ) {
            scanf("%d", &i) ;
            if( i == 1 ) {
                scanf("%d %d %d %d", &l, &r, &k, &c) ;
                add(l,k,c) ;

                add((r-l)/k*k+l+k,k,-c) ;
            }
            else {
                scanf("%d", &i) ;
                printf("%d\n", sum(i)+a[i]) ;
            }
        }
    }
    return 0 ;
}


版权声明：转载请注明出处：http://blog.csdn.net/winddreams

HDU 4119 Isabella's Message （2011年成都赛区现场赛I题）
1.题目描述：点击打开链接
2.解题思路：本题是一道模拟题，要求模拟一个解密的过程，练习这么久第一次做模拟题1Y了，内心还是很激动的~。只需要根据题意，记录* 所在的位置即可，然后每次都是先解密，后顺时针旋转90度。把每次解密的信息放到一个vector里，接下来就是连接它们，得到解密后的字符串，在map中查找这些单词是否存在即可。如果都存在，就把这条解密信息放到ans中，最后对ans排序，输出ans[0]就是答案。
3.代码：
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<iostream>
#include<algorithm>
#include<cassert>
#include<string>
#include<sstream>
#include<set>
#include<bitset>
#include<vector>
#include<stack>
#include<map>
#include<queue>
#include<deque>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cctype>
#include<functional>
using namespace std;

#define me(s)  memset(s,0,sizeof(s))
#define rep(i,n) for(int i=0;i<(n);i++)
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef pair <int, int> P;


const int N=55;
char s[N][N];
vector<P>pos;
vector<string>mes;
map<string,int>words;
int n;

void rotate()//将每个方格旋转90度
{
    int len=pos.size();
    for(int i=0;i<len;i++)
    {
        int x=pos[i].first,y=pos[i].second;
        pos[i]=P(y,n-1-x);
    }
    sort(pos.begin(),pos.end());
}
void decrypt(int dir)//解密
{
    int len=pos.size();
    string tmp="";
    for(int i=0;i<len;i++)
    {
        int x=pos[i].first,y=pos[i].second;
        tmp+=(isalpha(s[x][y]))?s[x][y]:' ';
    }
    mes.push_back(tmp);
    rotate();
}


int main()
{
    int T;
    scanf("%d",&T);
    for(int kase=1;kase<=T;kase++)
    {
        scanf("%d",&n);
        me(s);
        pos.clear();mes.clear();words.clear();
        for(int i=0;i<n;i++)
            scanf("%s",s[i]);
        char tmp[N];
        for(int i=0;i<n;i++)
        {
            scanf("%s",tmp);
            for(int j=0;j<n;j++)
                if(tmp[j]=='*')
                pos.push_back(P(i,j));
        }
        int m;
        scanf("%d",&m);
        string tp;
        for(int i=0;i<m;i++)
          {
              cin>>tp;
              words[tp]=i;
          }
        printf("Case #%d: ",kase);
        for(int i=0;i<4;i++)
            decrypt(i);

        vector<string>ans;
        for(int i=0;i<4;i++)
        {
            string s=mes[i]+mes[(i+1)%4]+mes[(i+2)%4]+mes[(i+3)%4];//连接信息
            int p=0,st=0;
            string ts="",tc;
            stringstream ss(s);
            int first=1;
            int ok=1;
            while(ss>>tc)
            {
                if(!words.count(tc)){ok=0;break;}
                if(first)first=0;
                else ts+=' ';
                ts+=tc;
            }
            if(ok)ans.push_back(ts);//每个单词都找到了，存到ans中
        }
        if(!ans.empty())
        {
            sort(ans.begin(),ans.end());
            cout<<ans[0]<<endl;
        }
        else puts("FAIL TO DECRYPT");
    }
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

C语言 异步回调
本文主要讲解如果实现回调，特别是在封装接口的时候，回调显得特别重要，我们首先假设有两个程序员在写代码，A程序员写底层驱动接口，B程序员写上层应用程序，然而此时底层驱动接口A有一个数据d需要传输给B，此时有两种方式： 
　　　１、A将数据d存储好放在接口函数中，B自己想什么时候去读就什么时候去读，这就是我们经常使用的函数调用，此时主动权是B。 
　　　2、A实现回调机制，当数据变化的时候才将通知B，你可以来读取数据了，然后B在用户层的回调函数中读取速度d，完成OK。此时主动权是A。 
很明显第一种方法太低效了，B根本就不知道什么时候该去调用接口函数读取数据d。而第二种方式由于B的读取数据操作是依赖A的，只有A叫B读数据，那么B才能读数据。也即是实现了中断读取。 
那么回调是怎么实现的呢，其实回调函数就是一个通过函数指针调用的函数。如果用户层B把函数的指针（地址）作为参数传递给底层驱动A，当这个指针在A中被用为调用它所指向的函数时，我们就说这是回调函数。 
注意：是在A中被调用，这里看到尽管函数是在B中，但是B却不是自己调用这个函数，而是将这个函数的函数指针通过A的接口函数传自A中了，由A来操控执行，这就是回调的意义所在。 
下面就通过一个例子来演示 
首先写A程序员的代码
//-----------------------底层实现A-----------------------------
typedef void (*pcb)(int a); //函数指针定义，后面可以直接使用pcb，方便
typedef struct parameter{
    int a ;
    pcb callback;
}parameter; 

void* callback_thread(void *p1)//此处用的是一个线程
{
    //do something
    parameter* p = (parameter*)p1 ;
    while(1)
    {
        printf("GetCallBack print! \n");
        sleep(3);//延时3秒执行callback函数
        p->callback(p->a);//函数指针执行函数，这个函数来自于应用层B
    }
}

//留给应用层B的接口函数
extern SetCallBackFun(int a, pcb callback)
{
    printf("SetCallBackFun print! \n");
    parameter *p = malloc(sizeof(parameter)) ; 
    p->a  = 10;
    p->callback = callback;

    //创建线程
    pthread_t thing1;
    pthread_create(&thing1,NULL,callback_thread,(void *) p);
    pthread_join(thing1,NULL);
}
上面的代码就是底层接口程序员A写的全部代码，留出接口函数SetCallBackFun即可
下面再实现应用者B的程序，B负责调用SetCallBackFun函数，以及增加一个函数，并将吃函数的函数指针通过SetCallBackFun(int a, pcb callback)的第二个参数pcb callback 传递下去。
//-----------------------应用者B-------------------------------
void fCallBack(int a)       // 应用者增加的函数，此函数会在A中被执行
{
    //do something
    printf("a = %d\n",a);
    printf("fCallBack print! \n");
}


int main(void)
{
    SetCallBackFun(4,fCallBack);

    return 0;
}
运行程序会看到
先会打印A程序的                 printf("GetCallBack print! \n");
然后等待3秒钟才会打印应用者B的    printf("fCallBack print! \n");

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

OJ 刷题---串的简单处理
 题目要求：




输入代码：
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    char str[100];
    int i;
    while(cin.getline(str,100,'\n'))
    {
        for(i=0; str[i]!='\0'; i++) //把每个单词的首字母变为大写
        {
            if(str[i]!=' ')
            {
                if(str[i]>='a'&&str[i]<='z')
                {
                    str[i]-=32;
                    break;
                }
                else
                    break;
            }
        }

        for(i=i+1; str[i]!='\0'; i++) //把每个单词的首字母变为大写
        {
            if(str[i]==' ')
            {
                if(str[i+1]>='a'&&str[i+1]<='z'&&str[i+1]!='\0')
                    str[i+1]-=32;
            }
        }

        for(i=0; str[i]!='\0'; i++)
        {
            if(str[i]>='0'&&str[i]<='9')//字母+数字类型的处理
            {
                if((str[i+1]>='a'&&str[i+1]<='z')||(str[i+1]>='A'&&str[i+1]<='Z'))
                {
                    cout<<str[i]<<'_';
                }
                else
                    cout<<str[i];
            }
            else if((str[i]>='a'&&str[i]<='z')||(str[i]>='A'&&str[i]<='Z'))//数字+字母类型的处理
            {
                if(str[i+1]>='0'&&str[i+1]<='9')
                {
                    cout<<str[i]<<'_';
                }
                else
                    cout<<str[i];
            }
            else if(str[i]==' '&&str[i+1]==' ')//多个空格的缩距处理
            {
                continue ;//直接跳过空格的地方
            }
            else
                cout<<str[i];
        }
        cout<<endl;
    }
    return 0;
}


运行结果：



版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 2104 K-th Number(区间第k大数)（平方分割，归并树，划分树）
题目链接：
http://poj.org/problem?id=2104

解题思路：
因为查询的个数m很大，朴素的求法无法在规定时间内求解。因此应该选用合理的方式维护数据来做到高效地查询。
如果x是第k个数，那么一定有
（1）在区间中不超过x的数不少于k个
（2）在区间中小于x的数有不到k个
因此，如果可以快速求出区间里不超过x的数的个数，就可以通过对x进行二分搜索来求出第k个数是多少。
接下来，我们来看一下如何计算在某个区间里不超过x个数的个数。如果不进行预处理，那么就只能遍历一遍所有元素。
另一方面，如果区间是有序的，那么就可以通过二分搜索法高效地求出不超过x的数的个数了。但是，如果对于每个查询都分别做一次排序，就完全无法降低复杂度。所以，可以考虑使用平方分割和线段树进行求解。
1.平方分割
首先我们来看看如何使用平方分割来解决这个问题。把数列每b个一组分到各个桶里，每一个桶内保存有排序后的数列。这样，如果要求在某个区间中不超过x的数的个数，就可以这样求得。
（1）对于完全包含在区间内的桶，用二分搜索法计算。
（2）对于所有的桶不完全包含在区间内的元素，逐个检查。
如果把b设为sqrt(b),复杂度就变成了
O((n/b)logb + b) = O(sqrt(n)logn)
其中，对每个元素的处理只要O(1)时间，而对于每个桶的处理则需要O(logb)，所以比起让桶的数量和桶内元素的个数尽可能接近，我们更应该把桶的数量设置成比桶内元素个数略少一些，这样可以使得程序更加高效。如果把b设为sqrt(nlogn)，复杂度就变成
O((n/b)logb + b) = O(sqrt(nlogn))
接下来只需要对x进行二分搜索就可以了。因为答案一定时数列a里的某个元素，所以二分搜索需要执行O(logn)次。因此，如果b = sqrt(nlogn)，包括预处理在内整个算法的复杂度就是O(nlogn + msqrt(n)log1.5次方(n))
AC代码：

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

const int B = 1000;//桶的大小
const int N = 100005;
const int M = 5005;
//输入
int n,m;
int a[N];
int L[M],R[M],K[M];

int nums[N];//对A排序之后的结果
vector<int> bucket[N/B];//每个桶排序之后的结果

void solve(){
    for(int i = 0; i < n; i++){
        bucket[i/B].push_back(a[i]);
        nums[i] = a[i];
    }
    sort(nums,nums+n);
    //虽然每B个一组剩下的部分所在的桶没有排序，但是不会产生问题
    for(int i = 0; i < n/B; i++)
        sort(bucket[i].begin(),bucket[i].end());
    for(int i = 0; i < m; i++){
        //求[l,r]区间中第k个数
        int l = L[i]-1,r = R[i],k = K[i];

        int lb = -1,ub = n-1;
        while(ub-lb > 1){
            int mid = (lb+ub)/2;
            int x = nums[mid];
            int tl = l,tr = r,c = 0;

            //区间两端多出的部分
            while(tl < tr && tl % B != 0)
                if(a[tl++] <= x)
                    c++;
            while(tl < tr && tr % B != 0)
                if(a[--tr] <= x)
                    c++;

            //对每一个桶进行计算
            while(tl < tr){
                int b = tl/B;
                c += upper_bound(bucket[b].begin(),bucket[b].end(),x)-bucket[b].begin();
                tl += B;
            }

            if(c >= k)
                ub = mid;
            else
                lb = mid;
        }
        printf("%d\n",nums[ub]);
    }
}

int main(){
    while(~scanf("%d%d",&n,&m)){
        for(int i = 0; i < n; i++)
            scanf("%d",&a[i]);
        for(int i = 0; i < m; i++)
            scanf("%d%d%d",&L[i],&R[i],&K[i]);
        solve();
    }
    return 0;
}


2.归并树
下面我们考虑一下如何使用线段树解决这个问题。我们把数列用线段树维护起来。线段树的每个节点都保存了对应区间排好序后的结果。以前我们接触过的线段树节点上保存的都是数值，而这次则有所不同，每个节点保存了一个数列。
建立线段树的过程和归并排序类似，而每个节点的数列就是其两个儿子节点的数列合并后的结点。建树的复杂度是O(nlogn)。顺带一提，这颗线段树正是归并排序的完整体现。（归并树）。
要计算在某个区间中不超过x的数的个数，只需要递归地进行如下操作就可以了。
（1）如果所给的区间和当前节点的区间完全没有交集，那么返回0个。
（2）如果所给的区间完全包含了当前节点对应的区间，那么使用二分搜索法对该节点上保存的数组进行查找。
（3）否则对两个儿子递归地进行计算之后求和即可。
由于对于同一深度的节点最多只访问常数个，因此可以在O(log二次方n)时间里求出不超过x的数的个数。所以整个算法的复杂度是O(nlogn + mlog三次方(n))。
归并树
以1 5 2 6 3 7为例：
把归并排序递归过程记录下来即是一棵归并树：
       [1 2 3 5 6 7]
    [1 2 5]      [3 6 7]
   [1 5] [2]    [6 3] [7] 
  [1][5]        [6][3]
用对应的下标区间建线段树：（这里下标区间对应的是原数列）
            [1 6]
     [1 3]      [4 6]
  [1 2] [3]   [4 5][6]
  [1][2]      [4][5]
每次查找[l r]区间的第k大数时，在[1 2 3 4 5 6 7]这个有序的序列中二分所要找的数x，然后对应到线段树中去找[l r]中比x小的数有几个，即x的rank。由
于线段树中任意区间对应到归并树中是有序的，所以在线段树中的某个区间查找比x小的数的个数也可以用二分在对应的归并树中找。这样一次查询的
时间复杂度是log(n)^2。
要注意的是，多个x有相同的rank时，应该取最大的一个。
AC代码：

#include <iostream>
#include <cstdio>
using namespace std;

const int N = 100005;
struct node{
    int l,r;
}tree[N<<2];
int n,q;
int a[N],mer[20][N];

void build(int m,int l,int r,int deep){
    tree[m].l = l;
    tree[m].r = r;
    if(l == r){
        mer[deep][l] = num[l];
        return;
    }
    int mid = (l+r)>>1;
    build(m<<1,l,mid,deep+1);
    build(m<<1|1,mid+1,r,deep+1);
    //归并排序，在建树的时候保存
    int i = l,j = (l+r)/2+1,p = 1;
    while(i <= (l+r)/2 && j <= r){
        if(mer[deep+1][i] > mer[deep+1][j])
            mer[deep][p++] = mer[deep+1][j++];
        else
            mer[deep][p++] = mer[deep+1][i++];
    }
    while(i <= (l+r)/2)
        mer[deep][p++] = mer[deep+1][i++];
    while(j <= r)
        mer[deep][p++] = mer[deep+1][j++];
}

int query(int m,int l,int r,int deep,int key){
    if(tree[step].r < l || tree[m].l > r)
        return 0;
    if(tree[m].l >= l && tree[m].r <= r)
        //找到key在排序后的数组中的位置
        return lower_bound(&mer[deep][tree[m].l],&mer[deep][tree[m].r+1,key) - &mer[deep][tree[m].l];  
    return query(m<<1,l,r,deep+1,key)+query(m<<1|1,l,r,key);
}

int solve(int l,int r,int k){
    int low = 1,high = n,mid;
    while(low < high){
        mid = (low+high+1)>>1;
        int cnt = query(1,l,r,1,mer[1][mid]);
        if(cnt <= k)
            low = mid;
        else
            high = mid-1;
    }
    return mer[1][low];
}

int main(){
    while(~scanf("%d%d",&n,&q)){
        for(int i = 1; i <= n; i++)
            scanf("%d",&a[i]);
        build(1,1,n,1);
        while(q--){
            int l,r,k;
            scanf("%d%d%d",&l,&r,&k);
            printf("%d\n",solve(l,r,k-1));
        }
    }
    return 0;
}

3.划分树

其实，归并树是在建树的过程中保存归并排序，划分树是在建树的过程中保存快速排序。
划分树
同样以1 5 2 6 3 7为例：
根据中位数mid，将区间划分成左子树中的数小于等于mid，右子树中的数大于等于mid，得到这样一棵划分树：
        [1 5 2 6 3 7]
     [1 2 3]      [5 6 7]
   [1 2]  [3]    [5 6] [7]
  [1] [2]        [5] [6] 
注意要保持下标的先后顺序不变
对每一个区间，用sum[i]记录区间的左端点left到i有几个进入了左子树，即有几个数小于等于mid
用对应的下标区间建线段树：（这里下标区间对应的是排序后的数列）
            [1 6]
     [1 3]      [4 6]
  [1 2] [3]   [4 5][6]
  [1][2]      [4][5]
每次查找[l r]区间的第k大数时，先查看当前区间[left right]下的sum[r] - sum[l - 1]是否小于等于k，如果是，则递归到左子树，并继续在[left + sum[l - 1], 
left + sum[r] - 1]中找第k大数；否则，进入右子树，继续在[mid + l - left + 1 - sum[l - 1], mid + r - left + 1 - sum[r]]找第k - sum[r] + sum[l - 1]大数，这样
一次查询只要logn的复杂度

AC代码：

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 100005;
struct node{
    int l,r,mid;
}tree[N<<2];
int sa[N],num[20][N],cnt[20][N];//sa中是排序后的，num记录每一层的排序结果，cnt[deep][i]表示第deep层，前i个数中有多少个进入左子树
int n,q;
void debug(int d){
    for(int i = 1; i <= n; i++)
        printf("%d ",num[d][i]);
    printf("\n");
}

void build(int m,int l,int r,int deep){
    tree[m].l = l;
    tree[m].r = r;
    if(l == r)
        return ;
    int mid = (l+r)>>1;
    int mid_val = sa[mid],lsum = mid-l+1;
    for(int i = l; i <= r; i++)
        if(num[deep][i] < mid_val)
            lsum--;//lsum表示左子树中还需要多少个中值
    int L = l,R = mid+1;
    for(int i = l; i <= r; i++){
        if(i == l)
            cnt[deep][i] = 0;
        else
            cnt[deep][i] = cnt[deep][i-1];
        if(num[deep][i] < mid_val || (num[deep][i] == mid_val && lsum > 0)){
            //左子树
            num[deep+1][L++] = num[deep][i];
            cnt[deep][i]++;
            if(num[deep][i] == mid_val)
                lsum--;
        }
        else
            num[deep+1][R++] = num[deep][i];
    }
    //debug(deep);
    build(m<<1,l,mid,deep+1);
    build(m<<1|1,mid+1,r,deep+1);
}

int query(int m,int l,int r,int deep,int k){
    if(l == r)
        return num[deep][l];
    int s1,s2;//s1为[tree[step].left,l-1]中分到左子树的个数
    if(tree[m].l == l)
        s1 = 0;
    else
        s1 = cnt[deep][l-1];
    s2 = cnt[deep][r]-s1;//s2为[l,r]中分到左子树的个数
    if(k <= s2)//左子树的数量大于k,递归左子树
        return query(m<<1,tree[m].l+s1,tree[m].l+s1+s2-1,deep+1,k);
    int b1 = l-1-tree[m].l+1-s1;//b1为[tree[m].l,l-1]中分到右子树的个数
    int b2 = r-l+1-s2;   //b2为[l,r]中分到右子树的个数
    int mid = (tree[m].l+tree[m].r)>>1;
    return query(m<<1|1,mid+1+b1,mid+1+b1+b2-1,deep+1,k-s2);
}

int main(){
    while(~scanf("%d%d",&n,&q)){
        for(int i = 1; i <= n; i++){
            scanf("%d",&num[1][i]);
            sa[i] = num[1][i];
        }
        sort(sa+1,sa+n+1);
        build(1,1,n,1);
        while(q--){
            int l,r,k;
            scanf("%d%d%d",&l,&r,&k);
            printf("%d\n",query(1,l,r,1,k));
        }
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

利用矩阵求斐波那契数列
利用矩阵求斐波那契数列
flyfish 2015-8-27 
矩阵（matrix）定义
一个m*n的矩阵是一个由m行n列元素排成的矩形阵列。矩阵里的元素可以是数字符号或者数学式.
形如{acbd}\begin{Bmatrix}
a & b\\ 
c & d
\end{Bmatrix} 的数表称为二阶矩阵，它由二行二列组成，其中a,b,c,d称为这个矩阵的元素。

形如 
{x1x2}\begin{Bmatrix}
x_1\\ 
x_2
\end{Bmatrix} 
的有序对称为列向量Column vector
设A={acbd}\begin{equation*}A=\begin{Bmatrix}
a & b\\ 
c & d
\end{Bmatrix}
\end{equation*} 
X={x1x2}\begin{equation*}X=\begin{Bmatrix}
x_1\\ 
x_2
\end{Bmatrix}
\end{equation*} 
则Y={ax1+bx2cx1+dx2}\begin{equation*}Y= \begin{Bmatrix}
ax_1+bx_2\\ 
cx_1+dx_2
\end{Bmatrix}
\end{equation*} 
称为二阶矩阵A与平面向量X的乘积，记为AX=Y

斐波那契(Fibonacci)数列
从第三项开始，每一项都是前两项之和。 
FnF_n=FnF_n −_- 1_1 +FnF_n −_- 2_2, n⩾3n\geqslant 3
把斐波那契数列中 相邻的两项FnF_n和FnF_n −_- 1_1写成一个2×\times1的矩阵。 
F0=0F_0=0 
F1=1F_1=1
{FnFn−1}\begin{equation*}
\begin{Bmatrix}F_n\\F_{n-1}\end{Bmatrix}
\end{equation*} 
={Fn−1+Fn−2Fn−1}\begin{equation*}
=\begin{Bmatrix}F_{n-1}+F_{n-2}\\F_{n-1}\end{Bmatrix}
\end{equation*} 
={1×Fn−1+1×Fn−21×Fn−1+0×Fn−2}\begin{equation*}
=\begin{Bmatrix}1\times F_{n-1}+1\times F_{n-2}\\1\times F_{n-1}+0\times F_{n-2}\end{Bmatrix}
\end{equation*}
={1110}×{Fn−1Fn−2}\begin{equation*}
=\begin{Bmatrix}1&1\\1&0\end{Bmatrix}\times\begin{Bmatrix}F_{n-1}\\F_{n-2}\end{Bmatrix}
\end{equation*} 
={1110}n−1×{F1F0}\begin{equation*}
=\begin{Bmatrix}1&1\\1&0\end{Bmatrix}^{n-1}\times\begin{Bmatrix}F_{1}\\F_{0}\end{Bmatrix}
\end{equation*} 
={1110}n−1×{10}\begin{equation*}
=\begin{Bmatrix}1&1\\1&0\end{Bmatrix}^{n-1}\times\begin{Bmatrix}1\\0\end{Bmatrix}
\end{equation*}
求F(n)等于求二阶矩阵的n - 1次方，结果取矩阵第一行第一列的元素。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Round A APAC Test 2016 Problem D. gSnake 贪吃蛇 stl应用


Problem D. gSnake



This contest is open for practice. You can try every problem as many times as you like, though we won't keep track of which problems you solve. Read the Quick-Start
 Guide to get started.




Small input
13 points




Solve D-small






Large input
19 points




Solve D-large







Problem
Alex is a huge fan of the Snake game.

Note: This Google Doodle does not exactly match the rules of the Snake game we will describe below. It is only intended to give you a general idea of what the game looks like.
Alex just learned how to program and wants to develop his own version of Snake, with the following rules:

The game board has R rows and C columns. The top left cell of the board has coordinates (1, 1), and the bottom right cell has coordinates (R, C).At the start of the game, in every cell with coordinates (r, c) such that r + c is odd, there is one piece of food. No other cells have food.The snake's body is always an ordered, connected sequence of one or more cells on the board. The first cell of the sequence is called the "head" of the snake. The second cell (if any) shares an edge (not just a corner) with
 the first cell, and so on. The last cell in the sequence is called the "tail" of the snake.The snake's head is always facing in one of four directions: left, up, right, or down.At the start of the game, the snake is at cell (1, 1) and has a length of one (that is, the snake consists of only a head), and the head faces right.At each integer time (1 second, 2 seconds, etc.), the head of the snake will move into the adjacent cell that its head is facing toward. The board is cyclic, i.e., trying to move off an edge will cause the head
 to appear on the opposite edge of the board. For example, if the snake is at (1, C) and its head is facing right, the head will next move to (1, 1). If the snake is at (1, C) and its head is facing up, the head will next move
 to (R, C).When the snake's head moves into a cell with no food, the snake does not grow. The snake's second cell (if any) moves to the place where the snake's head was, the snake's third cell (if any) moves to the place where the second
 cell was, and so on.When the snake's head moves into a cell with a piece of food, it eats the food (meaning that cell no longer has food), and grows its body. A new head is created in the cell where the food was. The cell that was the snake's head
 becomes the snake's second cell, the cell that was the snake's second cell (if any) becomes the snake's third cell, and so on.If, after a move is complete, the snake's head is in the same place as one of another of its cells, the snake dies and the game ends immediately. (Note that if the snake's head moves toward a cell where its tail was, the game
 will not end, because the tail will move out of the way before the move is complete.)In the game, the player can let the snake perform some turn actions. Each action Ai will happen between the Tith and Ti+1 th seconds. There are two possible actions: "L" and "R". An "L" action
 will turn the head 90 degrees to the left, so, for example, if the snake had been facing down before, it would face right after. An "R" action will turn the head 90 degrees to the right, so, for example, if the snake had been facing down before, it would face
 left after.The game has a time limit: it will end after the move on the 109th second is complete (if the game has even gone on that long!)

To test the game, Alex has written a series of TURN actions. Your task is to simulate that series of actions, and tell Alex the final length of the snake when the game is over. Remember that the game can end either because the snake's head and another cell
 of its body are in the same place after a move is complete, or because time runs out. In the former case, you should count both the head and the overlapping cell of its body as two separate cells, for the purpose of determining length.
Input
The first line of the input gives the number of test cases, T. T test cases follow. Each test cases starts with three integers S, R, and C, where S gives
 the number of turn actions and R and C represent the number of rows and columns of the board. S lines follow; the ith of these lines has an integer Xi, then a character Ai that is either L or R.
 Each of these lines corresponds to performing an action between Xith and Xi+1 th seconds. It's guaranteed that the actions are given in time order and there will never be more than one action between the same two seconds. However, you
 should note that the game may end before the snake gets to execute all of these actions.
Output
For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the length of the snake when the game is over.
Limits
1 ≤ T ≤ 10.

Small dataset
1 ≤ R, C ≤ 100;
1 ≤ S ≤ 100;
1 ≤ Xi ≤ 2000.

Large dataset
1 ≤ R, C ≤ 100000;
1 ≤ S ≤ 100000;
1 ≤ Xi ≤ 1000000.

Sample






Input 
 


Output 
 



2
3 3 3
1 R
2 L
3 R
5 3 3
2 R
4 R
6 R
7 R
8 R




Case #1: 3
Case #2: 5











贪吃蛇 不错的模拟题。要细心才能在有限的时间内写出来。

题意要求，有n,m的方格，左上角为1,1右下角为n,m，蛇起始长度为1，在1，1位置。在坐标相加和为奇数的方格内有一块食物，蛇走到这一块会长大一格，给出控制动作，可以向左 向右走。方格是首尾相接的，也就是说在1，1 向上走，会走到n,1。蛇死的条件是，自已撞上了自已，撞上尾巴不算，因为，尾巴在撞上前，也会向前走一格。要求也就是这么多，问，最终，蛇会有多长。有一个坑就是，如果在指令走完仍没死，蛇可能还会走，还会长长。
由于，n,m太大，所以图是不可能存下来的。所以，用map 或set存，食物 和存蛇，这样，就可以了。代码还算好写，细节要注意点。复杂度为o(n * log(n));
#define N 205
#define M 100005
#define maxn 205
#define MOD 1000000000000000007
int n,m,T,q,a,sd;
char str[N];
int sdir[4][2] = {{3,1},{0,2},{1,3},{2,0}};
int dir[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};
list<pii> snake;
list<pii>::iterator it;
set<pii> fMap,sMap;
bool Check(pii head,pii tail){
    if(head == tail) return true;
    return !sMap.count(head);
}
bool MoveOn(){
    int sx = snake.front().first,sy = snake.front().second;
    sx = sx + dir[sd][0];sy = sy + dir[sd][1];
    if(sx <= 0) sx = n;
    if(sx >= n+1) sx = 1;
    if(sy <= 0) sy = m;
    if(sy >= m+1) sy = 1;
    bool flag = true;
    pii tail = snake.back();
    if(((sx + sy) & 1) && !fMap.count(mp(sx,sy))){
        fMap.insert(mp(sx,sy));
        snake.push_front(mp(sx,sy));
        flag = Check(mp(sx,sy),tail);
        sMap.insert(mp(sx,sy));
    }
    else{
        flag = Check(mp(sx,sy),tail);
        snake.push_front(mp(sx,sy));
        sMap.insert(mp(sx,sy));
        snake.pop_back();
        sMap.erase(tail);
    }
    return flag;
}
int main()
{
    freopen("D-large-practice.in", "r", stdin);
    freopen("D-large-practice.out", "w", stdout);
     while(S(T)!=EOF)
    {
        For(ta,1,T+1){
            fMap.clear();
            sMap.clear();
            snake.clear();
            S(q);S2(n,m);
            int clock = 1;
            bool flag = true;
            sd = 1;
            sMap.insert(mp(1,1));
            snake.push_front(mp(1,1));
            while(q--){
                S(a);
                SS(str);
                if(flag){
                    for(;clock <= a && flag;clock++){
                        flag = MoveOn();
                    }
                    sd = sdir[sd][(str[0] == 'L'? 0:1)];
                }
            }
            if(flag){
                int maxx = max(n,m);
                for(int i = 0;i<maxx && flag;i++){
                    flag = MoveOn();
                }
            }
            printf("Case #%d: %d\n",ta,snake.size());
        }
    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

java之 ------ DAO设计模式的【详解】及常见设计模式的【应用】
DAO

Data Access Object(数据访问接口）
一、场景和问题
在Java程序中，经常需要把数据持久化，也需要获取持久化的数据，但是在进行数据持久化的过程中面临诸多问题（如：数据源
不同、存储类型不同、供应商不同、访问方式不同等等），请问如何能以统一的接口进行数据持久化的操作？

二、解决方案


看懂这个图，DAO理解的也差不多了。（由于语文水平的能力啊，等我好好整理一下思路，在更新啊）


三、DAO的理解
DAO在三层结构模式中起来很大的作用，表现层通过逻辑层调用DAO，然后让DAO去调用数据层，这样很好的将数据层和其他两层隔离开，安全性和可维护性更高。然后在逻辑层和DAO层有可以建立新的DAO2，这个DAO2的作用就是避免外界直接接触里面的接口，主要通过工厂方法，实现接口的应用，这样的目的也是为了提高安全性，而且显得更层次感。

1、DAO其实是利用组合工厂模式来解决问题的，并没有带来新的功能，所以学的其实就是个思路。

2、DAO理论上是没有层数限制的。

3、DAO的各层理论上是没有先后的。



四、DAO设计模式的结构
DAO设计模式一般分为：



1、值对象模式 (传递参数与返回值)

VO(Value Object)：就是存放项目中的一些要对其操作的数据类。
2、DAO模式  

DAO接口：用于声明对于数据的操作的方法。
3、面向接口编程 (分层、封装隔离)

DAOImpl：必须实现DAO接口，真实实现DAO接口的函数，只是单纯的处理数据。
4、工厂模式 

DAOFactory：工厂类，含有getInstance()创建一个DAOImpl类。



五、DAO模式的本质
一层屏蔽一种变化


六、DAO的好处
DAO的好处就是提供给用户的接口只有DAO的接口，所以如果用户想添加数据，只需要调用create函数即可，不需要数据库的操作





常见设计模式的应用
一、面向接口编程
1、面向接口编程是第一大原则。
2、在Java程序设计里面，非常讲究层的划分和模块的划分。通常我们按照三层来划分程序，分别UI层、逻辑层(取名business或service)、数据存储层，他们之间都要通过接口来通讯。
3、在每一个层里面，又有很多外小模块，一个小模块对外也应该是一个整体，那么一个模块对外也应该提供接口，其他地方需要使用到这个模块的功能，都应该通过此接口。



二、接口定义中的参数和返回值
问题：接口里面一定会定义接口隔离体部分需要暴露的方法，对于方法就有参数和返回值的定义，到底需要在接口中如何描述需要传递的参数呢？
答案：值对象模式给了我们很好的解决方案。事实上，值对象已经成为了不同层或是不同模块之间数据交换的标准方法，它体现的是数据的封装，也利于对象的复用。



三、编程中，外部如何得到接口
问题：1、我们知道，在Java程序中，使用一个类要先通过new的操作，得到一个类的实例，然后通过这个类实例去调用类的属性和方法。
2、可是接口呢，我们怎么得到它的实例呢？要知道接口是不能直接new操作的，我们之前学过的方式是：Interface inf = new 实现类();
3、但是在面向接口编程的世界里，如果这样做，意味着客户端必须知道你具体的实现类，这破坏了接口的隔离性。使用接口就是不让外部知道隔离体内部的实现的。怎么办呢？
答案：前面的工厂模式给出了这个问题的解决方案，使用Factory来“生产”接口，对外仅仅提供工厂和接口。



四、内部实现中如何进行数据存储操作 
问题：前面已经学会了如何设计一个模块对外公开的部分，那么，在内部实现的时候，遇到需要数据存储的时候，我们应该怎么操作呢？
答案：对于这个问题，DAO模式给出了较好的解决方案。

（具体操作看实例-----书店管理系统）


总结
一、Java 程序设计--包结构
Java程序设计的系统体系结构很大一部分都体现在包结构上

一种典型的Java应用程序的包结构：前缀.应用或项目的名称.模块组合.模块内部的技术实现

1、前缀：是网站域名的倒写，去掉www（如，Sun公司（非JDK级别）的东西：com.sun.* ）。
2、其中模块组合又由系统、子系统、模块、组件等构成（具体情况根据项目的大小而定，如果项目很大，那么就多分几层。
3、模块内部的技术实现一般由：表现层、逻辑层、数据层等构成。

对于许多类都要使用的公共模块或公共类，可以再独立建立一个包，取名common或base，把这些公共类都放在其中。
对于功能上的公用模块或公共类可建立util或tool包，放入其中。



二、设计与实现的常用方式、DAO的基本功能
1、 设计的时候：从大到小
先把一个大问题分解成一系列的小问题。或者说是把一个大系统分解成多个小系统，小系统再继续进行往下分解，直到分解到自己能够掌控时，再进行动手实现。

实现的时候：从小到大

先实现组件，进行测试通过了，再把几个组件实现合成模块，进行测试通过，然后继续往上扩大。

2、 最典型的DAO接口通常具有的功能
新增功能、修改功能、删除功能、按照主要的键值进行查询、获取所有值的功能、按照条件进行查询的功能。

3、 一个通用DAO接口模板
4、 UserVO 和 UserQueryVO的区别
UserVO封装数据记录，而UserQueryVO用于封装查询条件






























版权声明：本文为博主原创文章，未经博主允许不得转载。

WebRTC VideoEngine超详细教程（二）——集成OPENH264编解码器
总述
WebRTC原生支持VP8和VP9，但也可以自行集成H264编解码器，比较常见的是OPENH264和X264（X264自身只有编码功能，如果要加入解码功能，可以再结合ffmpeg），总体来说，集成H264编解码器的流程和直接使用它们的库的流程类似，但是要先将相应功能依照WebRTC中对编解码器的封装形式重新封装，然后再通过注册外部编解码器的方法在主流程中使用它们。
下面先看一下WebRTC对编解码器的封装形式是怎么样的，定义在webrtc\modules\video_coding\codecs\interface\video_codec_interface.h中，如下
VideoEncoder

class EncodedImageCallback
{
public:
    virtual ~EncodedImageCallback() {};

    // Callback function which is called when an image has been encoded.
    //
    // Input:
    //          - encodedImage         : The encoded image
    //
    // Return value                    : > 0,   signals to the caller that one or more future frames
    //                                          should be dropped to keep bit rate or frame rate.
    //                                   = 0,   if OK.
    //                                   < 0,   on error.
    virtual int32_t
    Encoded(EncodedImage& encodedImage,
            const CodecSpecificInfo* codecSpecificInfo = NULL,
            const RTPFragmentationHeader* fragmentation = NULL) = 0;
};

class VideoEncoder
{
public:
    virtual ~VideoEncoder() {};

    // Initialize the encoder with the information from the VideoCodec.
    //
    // Input:
    //          - codecSettings     : Codec settings
    //          - numberOfCores     : Number of cores available for the encoder
    //          - maxPayloadSize    : The maximum size each payload is allowed
    //                                to have. Usually MTU - overhead.
    //
    // Return value                 : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t InitEncode(const VideoCodec* codecSettings, int32_t numberOfCores, uint32_t maxPayloadSize) = 0;

    // Encode an I420 image (as a part of a video stream). The encoded image
    // will be returned to the user through the encode complete callback.
    //
    // Input:
    //          - inputImage        : Image to be encoded
    //          - codecSpecificInfo : Pointer to codec specific data
    //          - frame_types        : The frame type to encode
    //
    // Return value                 : WEBRTC_VIDEO_CODEC_OK if OK, < 0
    //                                otherwise.
    virtual int32_t Encode(
        const I420VideoFrame& inputImage,
        const CodecSpecificInfo* codecSpecificInfo,
        const std::vector<VideoFrameType>* frame_types) = 0;

    // Register an encode complete callback object.
    //
    // Input:
    //          - callback         : Callback object which handles encoded images.
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t RegisterEncodeCompleteCallback(EncodedImageCallback* callback) = 0;

    // Free encoder memory.
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t Release() = 0;

    // Inform the encoder about the packet loss and round trip time on the
    // network used to decide the best pattern and signaling.
    //
    //          - packetLoss       : Fraction lost (loss rate in percent =
    //                               100 * packetLoss / 255)
    //          - rtt              : Round-trip time in milliseconds
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t SetChannelParameters(uint32_t packetLoss, int rtt) = 0;

    // Inform the encoder about the new target bit rate.
    //
    //          - newBitRate       : New target bit rate
    //          - frameRate        : The target frame rate
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t SetRates(uint32_t newBitRate, uint32_t frameRate) = 0;

    // Use this function to enable or disable periodic key frames. Can be useful for codecs
    // which have other ways of stopping error propagation.
    //
    //          - enable           : Enable or disable periodic key frames
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t SetPeriodicKeyFrames(bool enable) { return WEBRTC_VIDEO_CODEC_ERROR; }

    // Codec configuration data to send out-of-band, i.e. in SIP call setup
    //
    //          - buffer           : Buffer pointer to where the configuration data
    //                               should be stored
    //          - size             : The size of the buffer in bytes
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t CodecConfigParameters(uint8_t* /*buffer*/, int32_t /*size*/) { return WEBRTC_VIDEO_CODEC_ERROR; }
};VideoDecoder


class DecodedImageCallback
{
public:
    virtual ~DecodedImageCallback() {};

    // Callback function which is called when an image has been decoded.
    //
    // Input:
    //          - decodedImage         : The decoded image.
    //
    // Return value                    : 0 if OK, < 0 otherwise.
    virtual int32_t Decoded(I420VideoFrame& decodedImage) = 0;

    virtual int32_t ReceivedDecodedReferenceFrame(const uint64_t pictureId) {return -1;}

    virtual int32_t ReceivedDecodedFrame(const uint64_t pictureId) {return -1;}
};

class VideoDecoder
{
public:
    virtual ~VideoDecoder() {};

    // Initialize the decoder with the information from the VideoCodec.
    //
    // Input:
    //          - inst              : Codec settings
    //          - numberOfCores     : Number of cores available for the decoder
    //
    // Return value                 : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t InitDecode(const VideoCodec* codecSettings, int32_t numberOfCores) = 0;

    // Decode encoded image (as a part of a video stream). The decoded image
    // will be returned to the user through the decode complete callback.
    //
    // Input:
    //          - inputImage        : Encoded image to be decoded
    //          - missingFrames     : True if one or more frames have been lost
    //                                since the previous decode call.
    //          - fragmentation     : Specifies where the encoded frame can be
    //                                split into separate fragments. The meaning
    //                                of fragment is codec specific, but often
    //                                means that each fragment is decodable by
    //                                itself.
    //          - codecSpecificInfo : Pointer to codec specific data
    //          - renderTimeMs      : System time to render in milliseconds. Only
    //                                used by decoders with internal rendering.
    //
    // Return value                 : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t
    Decode(const EncodedImage& inputImage,
           bool missingFrames,
           const RTPFragmentationHeader* fragmentation,
           const CodecSpecificInfo* codecSpecificInfo = NULL,
           int64_t renderTimeMs = -1) = 0;

    // Register an decode complete callback object.
    //
    // Input:
    //          - callback         : Callback object which handles decoded images.
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t RegisterDecodeCompleteCallback(DecodedImageCallback* callback) = 0;

    // Free decoder memory.
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t Release() = 0;

    // Reset decoder state and prepare for a new call.
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t Reset() = 0;

    // Codec configuration data sent out-of-band, i.e. in SIP call setup
    //
    // Input/Output:
    //          - buffer           : Buffer pointer to the configuration data
    //          - size             : The size of the configuration data in
    //                               bytes
    //
    // Return value                : WEBRTC_VIDEO_CODEC_OK if OK, < 0 otherwise.
    virtual int32_t SetCodecConfigParameters(const uint8_t* /*buffer*/, int32_t /*size*/) { return WEBRTC_VIDEO_CODEC_ERROR; }

    // Create a copy of the codec and its internal state.
    //
    // Return value                : A copy of the instance if OK, NULL otherwise.
    virtual VideoDecoder* Copy() { return NULL; }
};



具体到WebRTC原生支持的VP8编解码器，可以参见webrtc\modules\video_coding\codecs\vp8\vp8_impl.h和vp8_impl.cc两个文件，其中定义的VP8EncoderImpl和VP8DecoderImpl这两个类分别继承自VideoEncoder和VideoDecoder类，并且加入了一些私有的成员变量和函数。这也就意味着，我们在试图集成H264编解码器时，也应该有H264EncoderImpl和H264DecoderImpl这样的两个类。
本文先以OPENH264为例做详细说明
首先当然要通过OPENH264项目编译出welsenc.lib和welsdec.lib两个库，再把codec_api.h、codec_app_def.h、codec_def.h、codec_ver.h四个头文件以及welsdec.dll welsenc.dll welsvp.dll三个动态库加入到工程目录下，并且在项目属性中进行相应设置。
编码功能的重新封装
先说编码部分，定义H264EncoderImpl类如下，关键在于加入OPENH264编码功能核心类ISVCEncoder* encoder_;

class H264EncoderImpl : public VideoEncoder{
 public:
  H264EncoderImpl();

  ~H264EncoderImpl();

  int Release();

  int InitEncode(const VideoCodec* codec_settings,
                         int number_of_cores,
                         size_t max_payload_size);

  int Encode(const I420VideoFrame& input_image,
                     const CodecSpecificInfo* codec_specific_info,
                     const std::vector<VideoFrameType>* frame_types);

  int RegisterEncodeCompleteCallback(EncodedImageCallback* callback);

  int SetChannelParameters(uint32_t packet_loss, int rtt);

  int SetRates(uint32_t new_bitrate_kbit, uint32_t frame_rate);

 private:
  // Update frame size for codec.
  int UpdateCodecFrameSize(const I420VideoFrame& input_image);

  EncodedImage encoded_image_;
  EncodedImageCallback* encoded_complete_callback_;
  VideoCodec codec_;
  bool inited_;

//openh264编码功能类
  ISVCEncoder* encoder_;

};  // end of H264Encoder class
然后再来看一下每个方法的具体实现，基本可以参照如下的OPENH264基本编码流程

//setup encoder
int rv = WelsCreateSVCEncoder (&encoder_);
//initilize with basic parameter
SEncParamBase param;
memset (&param, 0, sizeof (SEncParamBase));
param.iUsageType = usageType;
param.fMaxFrameRate = frameRate;
param.iPicWidth = width;
param.iPicHeight = height;
param.iTargetBitrate = 5000000;
encoder_->Initialize (&param);
//set option, set option during encoding process
encoder_->SetOption (ENCODER_OPTION_TRACE_LEVEL, &g_LevelSetting);
int videoFormat = videoFormatI420;
encoder_->SetOption (ENCODER_OPTION_DATAFORMAT, &videoFormat);
//encode and store ouput bistream
int frameSize = width * height * 3 / 2;
BufferedData buf;
buf.SetLength (frameSize);
ASSERT_TRUE (buf.Length() == (size_t)frameSize);
SFrameBSInfo info;
memset (&info, 0, sizeof (SFrameBSInfo));
SSourcePicture pic;
memset (&pic, 0, sizeof (SsourcePicture));
pic.iPicWidth = width;
pic.iPicHeight = height;
pic.iColorFormat = videoFormatI420;
pic.iStride[0] = pic.iPicWidth;
pic.iStride[1] = pic.iStride[2] = pic.iPicWidth >> 1;
pic.pData[0] = buf.data();
pic.pData[1] = pic.pData[0] + width * height;
pic.pData[2] = pic.pData[1] + (width * height >> 2);
for(int num = 0;num<total_num;num++) {
   //prepare input data
   rv = encoder_->EncodeFrame (&pic, &info);
   ASSERT_TRUE (rv == cmResultSuccess);
   if (info.eFrameType != videoFrameTypeSkip && cbk != NULL) {
    //output bitstream
   }
}
//teardown encoder
if (encoder_) {
    encoder_->Uninitialize();
    WelsDestroySVCEncoder (encoder_);
}



H264EncoderImpl()方法实现如下

H264EncoderImpl::H264EncoderImpl()
    : encoded_image_(),
      encoded_complete_callback_(NULL),
      inited_(false),
      encoder_(NULL)
{
  memset(&codec_, 0, sizeof(codec_));
}
Release()方法实现如下，这里调用了OPENH264的WelsDestroySVCEncoder方法


int H264EncoderImpl::Release() {
  if (encoded_image_._buffer != NULL) {
    delete [] encoded_image_._buffer;
    encoded_image_._buffer = NULL;
  }
  if (encoder_ != NULL) {
    encoder_->Uninitialize();
    WelsDestroySVCEncoder(encoder_);
    encoder_ = NULL;
  }
  inited_ = false;
  return WEBRTC_VIDEO_CODEC_OK;
}
InitEncode()方法实现如下，基本上就是OPENH264编码器的创建WelsCreateSVCEncoder与初始化encoder_->Initialize以及参数设置SEncParamBase的流程


int H264EncoderImpl::InitEncode(const VideoCodec* inst,
                               int number_of_cores,
                               size_t max_payload_size) {
  if (inst == NULL) {
    return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
  }
  if (inst->maxFramerate < 1) {
    return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
  }
  // allow zero to represent an unspecified maxBitRate
  if (inst->maxBitrate > 0 && inst->startBitrate > inst->maxBitrate) {
    return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
  }
  if (inst->width < 1 || inst->height < 1) {
    return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
  }
  if (number_of_cores < 1) {
    return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
  }

  int ret_val= Release();
  if (ret_val < 0) {
    return ret_val;
  }

  if (encoder_ == NULL) {
	ret_val = WelsCreateSVCEncoder(&encoder_);

    if (ret_val != 0) {
     WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
  	              "H264EncoderImpl::InitEncode() fails to create encoder ret_val %d",
    	           ret_val);
      return WEBRTC_VIDEO_CODEC_ERROR;
    }
  }
  SEncParamBase param;
  memset (param, 0, sizeof(SEncParamBase));
  param.iUsageType = CAMERA_VIDEO_REAL_TIME;
  param.iRCMode = RC_QUALITY_MODE;
  param.fMaxFrameRate = inst->maxFramerate;
  param.iPicWidth = inst->width;
  param.iPicHeight = inst->height;
  param.iTargetBitrate = inst->maxBitrate;

  ret_val =  encoder_->Initialize(param);
  int videoFormat = videoFormatI420;
  encoder_->SetOption(ENCODER_OPTION_DATAFORMAT, &videoFormat);

  if (ret_val != 0) {
	  WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
		  "H264EncoderImpl::InitEncode() fails to initialize encoder ret_val %d",
		  ret_val);
	  WelsDestroySVCEncoder(encoder_);
	  encoder_ = NULL;
	  return WEBRTC_VIDEO_CODEC_ERROR;
  }

  if (&codec_ != inst) {
    codec_ = *inst;
  }

  if (encoded_image_._buffer != NULL) {
    delete [] encoded_image_._buffer;
  }
  encoded_image_._size = CalcBufferSize(kI420, codec_.width, codec_.height);
  encoded_image_._buffer = new uint8_t[encoded_image_._size];
  encoded_image_._completeFrame = true;
  
  inited_ = true;
  WEBRTC_TRACE(webrtc::kTraceApiCall, webrtc::kTraceVideoCoding, -1,
               "H264EncoderImpl::InitEncode(width:%d, height:%d, framerate:%d, start_bitrate:%d, max_bitrate:%d)",
               inst->width, inst->height, inst->maxFramerate, inst->startBitrate, inst->maxBitrate);

  return WEBRTC_VIDEO_CODEC_OK;
}

Encode()方法中包含了两个功能，一方面是视频帧的编码，这一步骤同样基本可以参照OPENH264的编码流程
另一方面是将编码后数据封装为RTP包发送出去，具体的内容由WebRTC为我们提供的VCMEncodedFrameCallback类的Encoded方法实现，详见webrtc\modules\video_coding\main\source\generic_encoder.cc文件，对这一方法的调用则是在我们的H264EncoderImpl类的RegisterEncodeCompleteCallback方法中实现的，如下


int H264EncoderImpl::RegisterEncodeCompleteCallback(
    EncodedImageCallback* callback) {
  encoded_complete_callback_ = callback;
  return WEBRTC_VIDEO_CODEC_OK;
}而我们需要做的只是获取与每个RTP fragment对应的NAL大小、类型等信息，并且写入RTPFragmentationHeader类中

Encode方法内容如下

int H264EncoderImpl::Encode(const I420VideoFrame& input_image,
                           const CodecSpecificInfo* codec_specific_info,
                           const std::vector<VideoFrameType>* frame_types) {
  if (!inited_) {
    return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
  }
  if (input_image.IsZeroSize()) {
    return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
  }
  if (encoded_complete_callback_ == NULL) {
    return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
  }

  VideoFrameType frame_type = kDeltaFrame;
  // We only support one stream at the moment.
  if (frame_types && frame_types->size() > 0) {
    frame_type = (*frame_types)[0];
  }

  bool send_keyframe = (frame_type == kKeyFrame);
  if (send_keyframe) {
    encoder_->ForceIntraFrame(true);
    WEBRTC_TRACE(webrtc::kTraceApiCall, webrtc::kTraceVideoCoding, -1,
                 "H264EncoderImpl::EncodeKeyFrame(width:%d, height:%d)",
                 input_image.width(), input_image.height());
  }

  // Check for change in frame size.
  if (input_image.width() != codec_.width ||
      input_image.height() != codec_.height) {
    int ret = UpdateCodecFrameSize(input_image);
    if (ret < 0) {
      return ret;
    }
  }
 //编码过程，整个Encode方法是会被反复调用的
  SFrameBSInfo info;
  memset(&info, 0, sizeof(SFrameBSInfo));

  SSourcePicture pic;
  memset(&pic,0,sizeof(SSourcePicture));
  pic.iPicWidth = input_image.width();
  pic.iPicHeight = input_image.height();
  pic.iColorFormat = videoFormatI420;

  pic.iStride[0] = input_image.stride(kYPlane);
  pic.iStride[1] = input_image.stride(kUPlane);
  pic.iStride[2] = input_image.stride(kVPlane);

  pic.pData[0]   = const_cast<uint8_t*>(input_image.buffer(kYPlane));
  pic.pData[1]   = const_cast<uint8_t*>(input_image.buffer(kUPlane));
  pic.pData[2]   = const_cast<uint8_t*>(input_image.buffer(kVPlane));

  int retVal = encoder_->EncodeFrame(&pic, &info);
  if (retVal == videoFrameTypeSkip) {
    return WEBRTC_VIDEO_CODEC_OK;
  }
//获取与每个RTP fragment对应的NAL大小、类型等信息
  int layer = 0;

  uint32_t totalNaluCount = 0;
  while (layer < info.iLayerNum) {
	  const SLayerBSInfo* layer_bs_info = &info.sLayerInfo[layer];
	  if (layer_bs_info != NULL) {
		  totalNaluCount += layer_bs_info->iNalCount;
	  }
	  layer++;
  }
  if (totalNaluCount == 0) {
	  return WEBRTC_VIDEO_CODEC_OK;
  }
//这里我们认为每个分片恰好包含一个NAL单元，具体的RTP分片方法则由WebRTC的VCMPacketizationCallback实现，我们不用管
  RTPFragmentationHeader frag_info;
  frag_info.VerifyAndAllocateFragmentationHeader(totalNaluCount);
  
  encoded_image_._length = 0;
  layer = 0;
  uint32_t totalNaluIndex = 0;

  while (layer < info.iLayerNum) {
	  const SLayerBSInfo* layer_bs_info = &info.sLayerInfo[layer];
	  if (layer_bs_info != NULL) {
		  int layer_size = 0;
		  int nal_begin = 4;
		  uint8_t* nal_buffer = NULL;
		  char nal_type = 0;
		  for (int nal_index = 0; nal_index < layer_bs_info->iNalCount; nal_index++) {
			  nal_buffer = layer_bs_info->pBsBuf + nal_begin;
			  nal_type = (nal_buffer[0] & 0x1F);
			  layer_size += layer_bs_info->pNalLengthInByte[nal_index];
			  nal_begin += layer_size;
			  if (nal_type == 14) {
				  continue;
			  }
			  uint32_t currentNaluSize = layer_bs_info->pNalLengthInByte[nal_index] - 4;
			  memcpy(encoded_image_._buffer + encoded_image_._length, nal_buffer, currentNaluSize);
			  encoded_image_._length += currentNaluSize;

			  WEBRTC_TRACE(webrtc::kTraceApiCall, webrtc::kTraceVideoCoding, -1,
			                "H264EncoderImpl::Encode() nal_type %d, length:%d",
			                 nal_type, encoded_image_._length);
			      
			  // Offset of pointer to data for each fragm.
			  frag_info.fragmentationOffset[totalNaluIndex] = encoded_image_._length - currentNaluSize;
			  // Data size for each fragmentation
			  frag_info.fragmentationLength[totalNaluIndex] = currentNaluSize;
			  // Payload type of each fragmentation
			  frag_info.fragmentationPlType[totalNaluIndex] = nal_type;
			  // Timestamp difference relative "now" for
			  // each fragmentation
			  frag_info.fragmentationTimeDiff[totalNaluIndex] = 0;
			  totalNaluIndex++;
		  } // for
	  }
	  layer++;
  }


		  if (encoded_image_._length > 0) {
			  encoded_image_._timeStamp = input_image.timestamp();
			  encoded_image_.capture_time_ms_ = input_image.render_time_ms();
			  encoded_image_._encodedHeight = codec_.height;
			  encoded_image_._encodedWidth = codec_.width;
                          encoded_image_._frameType = frame_type;
// call back 
encoded_complete_callback_->Encoded(encoded_image_, NULL, &frag_info); 
} 
return WEBRTC_VIDEO_CODEC_OK;
}


最后是SetRate和SetChannelParameter两个方法，用于根据网络情况自适应改变码率和帧率，这里我们暂时不考虑，使用固定码率和帧率，二者的实现如下


int H264EncoderImpl::SetRates(uint32_t new_bitrate_kbit,
                             uint32_t new_framerate) {
  WEBRTC_TRACE(webrtc::kTraceApiCall, webrtc::kTraceVideoCoding, -1,
               "H264EncoderImpl::SetRates(%d, %d)", new_bitrate_kbit, new_framerate);
  if (!inited_) {
    return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
  }
  if (new_framerate < 1) {
    return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
  }
  // update bit rate
  if (codec_.maxBitrate > 0 && new_bitrate_kbit > codec_.maxBitrate) {
    new_bitrate_kbit = codec_.maxBitrate;
  }

  return WEBRTC_VIDEO_CODEC_OK;
}int H264EncoderImpl::SetChannelParameters(uint32_t packet_loss, int rtt) {
	return WEBRTC_VIDEO_CODEC_OK;
}
由此编码功能的重新封装全部完成


解码功能的重新封装
定义H264DecoderImpl类如下，关键在于加入OPENH264解码功能核心类ISVCDecoder* decoder_;
class H264DecoderImpl : public VideoDecoder{
 public:
  enum {
	  MAX_ENCODED_IMAGE_SIZE = 32768
  };

  H264DecoderImpl();

  ~H264DecoderImpl();

  int InitDecode(const VideoCodec* inst, int number_of_cores);

  int Decode(const EncodedImage& input_image,
                     bool missing_frames,
                     const RTPFragmentationHeader* fragmentation,
                     const CodecSpecificInfo* codec_specific_info,
                     int64_t /*render_time_ms*/);

  int RegisterDecodeCompleteCallback(DecodedImageCallback* callback);

  int Release();

  int Reset();

  VideoDecoder* Copy();

 private:
  I420VideoFrame decoded_image_;
  DecodedImageCallback* decode_complete_callback_;
  bool inited_;
  VideoCodec codec_;
  bool key_frame_required_;

  ISVCDecoder* decoder_;
  unsigned char* buffer_with_start_code_;

};  
还是一样，先来看一下OPENH264自己的基本解码流程

//decoder declaration
ISVCDecoder *pSvcDecoder;
//input: encoded bitstream start position; should include start code prefix
unsigned char *pBuf =...;
//input: encoded bit stream length; should include the size of start code prefix
int iSize =...;
//output: [0~2] for Y,U,V buffer for Decoding only
unsigned char *pData[3] =...;
//in-out: for Decoding only: declare and initialize the output buffer info
memset(&sDstBufInfo, 0, sizeof(SBufferInfo));

//decoder creation
CreateDecoder(pSvcDecoder);//declare required parameter
SDecodingParam sDecParam = {0};
sDecParam.sVideoProperty.eVideoBsType = VIDEO_BITSTREAM_AVC;

//initialize the parameter and decoder context, allocate memory
Initialize(&sDecParam);
//do actual decoding process in slice level; this can be done in a loop until data ends
//for Decoding only
 iRet = DecodeFrameNoDelay(pBuf, iSize, pData, &sDstBufInfo);
 //or
 iRet = DecodeFrame2(pBuf, iSize, pData, &sDstBufInfo);
 
 //for Decoding only, pData can be used for render.
 if (sDstBufInfo.iBufferStatus==1){
     output pData[0], pData[1], pData[2];
 }
//uninitialize the decoder and memory free
Uninitialize();
//destroy the decoder
DestroyDecoder();




照葫芦画瓢，即可得出H264DecoderImpl类的各方法的具体实现

H264DecoderImpl()方法的实现如下

H264DecoderImpl::H264DecoderImpl()
		: decode_complete_callback_(NULL),
		inited_(false),
		key_frame_required_(true)
		,buffer_with_start_code_(NULL)
		,decoder_(NULL)
	{
		memset(&codec_, 0, sizeof(codec_));
		buffer_with_start_code_ = new unsigned char[MAX_ENCODED_IMAGE_SIZE];

	}Release()方法的实现如下，调用了OPENH264的Uninitialize和WelsDestroyDecoder方法


int H264DecoderImpl::Release() {
		if (decoder_ != NULL) {
			decoder_->Uninitialize();
			WelsDestroyDecoder(decoder_);
			decoder_ = NULL;
		}
		inited_ = false;
		return WEBRTC_VIDEO_CODEC_OK;
	}
InitDecode方法的实现如下，进行了OPENH264解码参数的设置和初始化


int H264DecoderImpl::InitDecode(const VideoCodec* inst, int number_of_cores) {
		if (inst == NULL) {
			return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
		}
		int ret_val = Release();
		if (ret_val < 0) {
			return ret_val;
		}

		if (&codec_ != inst) {
			// Save VideoCodec instance for later; mainly for duplicating the decoder.
			codec_ = *inst;
		}
		if (decoder_ == NULL) {
			ret_val = WelsCreateDecoder(&decoder_);
			if (ret_val != 0) {
				decoder_ = NULL;
				return WEBRTC_VIDEO_CODEC_ERROR;
			}
		}
		SDecodingParam dec_param;
		memset(&dec_param, 0, sizeof(SDecodingParam));
		dec_param.eOutputColorFormat = videoFormatI420;
		dec_param.uiTargetDqLayer = UCHAR_MAX;
		dec_param.eEcActiveIdc = ERROR_CON_FRAME_COPY_CROSS_IDR;
		dec_param.sVideoProperty.eVideoBsType = VIDEO_BITSTREAM_DEFAULT;
		ret_val = decoder_->Initialize(&dec_param);
		if (ret_val != 0) {
			decoder_->Uninitialize();
			WelsDestroyDecoder(decoder_);
			decoder_ = NULL;
			return WEBRTC_VIDEO_CODEC_ERROR;
		}
		inited_ = true;

		// Always start with a complete key frame.
		key_frame_required_ = true;
		WEBRTC_TRACE(webrtc::kTraceApiCall, webrtc::kTraceVideoCoding, -1,
			"H264DecoderImpl::InitDecode(width:%d, height:%d, framerate:%d, start_bitrate:%d, max_bitrate:%d)",
			inst->width, inst->height, inst->maxFramerate, inst->startBitrate, inst->maxBitrate);
		return WEBRTC_VIDEO_CODEC_OK;
	}Decode方法的实现如下，包含两个功能，一是解码接收到的图像帧，这方面可以参照OPENh264的解码流程

另一个是将解码数据转换为YUV420P像素格式的数据供渲染显示，具体的渲染显示由WebRTC为我们提供的VCMDecodedFrameCallback类的Decoded方法实现，详见webrtc\modules\video_coding\main\source\generic_decoder.cc文件，对这一方法的调用则是在我们的H264DecoderImpl类的RegisterDecodeCompleteCallback方法中实现的，如下

int H264DecoderImpl::RegisterDecodeCompleteCallback(
		DecodedImageCallback* callback) {
		decode_complete_callback_ = callback;
		return WEBRTC_VIDEO_CODEC_OK;
	}
我们需要做的只是将解码数据转换为YUV数据，使用WebRTC的CreateFrame方法，整个Decode方法的实现如下


int H264DecoderImpl::Decode(const EncodedImage& input_image,
		bool missing_frames,
		const RTPFragmentationHeader* fragmentation,
		const CodecSpecificInfo* codec_specific_info,
		int64_t /*render_time_ms*/) {
		if (!inited_) {
			WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
				"H264DecoderImpl::Decode, decoder is not initialized");
			return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
		}

		if (decode_complete_callback_ == NULL) {
			WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
				"H264DecoderImpl::Decode, decode complete call back is not set");
			return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
		}

		if (input_image._buffer == NULL) {
			WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
				"H264DecoderImpl::Decode, null buffer");
			return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
		}
		if (!codec_specific_info) {
			WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
				"H264EncoderImpl::Decode, no codec info");
			return WEBRTC_VIDEO_CODEC_ERROR;
		}
		if (codec_specific_info->codecType != kVideoCodecH264) {
			WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
				"H264EncoderImpl::Decode, non h264 codec %d", codec_specific_info->codecType);
			return WEBRTC_VIDEO_CODEC_ERROR;
		}

		WEBRTC_TRACE(webrtc::kTraceApiCall, webrtc::kTraceVideoCoding, -1,
			"H264DecoderImpl::Decode(frame_type:%d, length:%d",
			input_image._frameType, input_image._length);

		void* data[3];
		SBufferInfo buffer_info;
		memset(data, 0, sizeof(data));
		memset(&buffer_info, 0, sizeof(SBufferInfo));

		memset(buffer_with_start_code_, 0, MAX_ENCODED_IMAGE_SIZE);
		int encoded_image_size = 0;
			memcpy(buffer_with_start_code_ , input_image._buffer, input_image._length);
			encoded_image_size =  input_image._length;

		DECODING_STATE rv = decoder_->DecodeFrame2(buffer_with_start_code_, encoded_image_size, (unsigned char**)data, &buffer_info);

		if (rv != dsErrorFree) {
			WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
				"H264DecoderImpl::Decode, openH264 decoding fails with error %d", rv);
			return WEBRTC_VIDEO_CODEC_ERROR;
		}

		if (buffer_info.iBufferStatus == 1) {
			int size_y = buffer_info.UsrData.sSystemBuffer.iStride[0] * buffer_info.UsrData.sSystemBuffer.iHeight;
			int size_u = buffer_info.UsrData.sSystemBuffer.iStride[1] * (buffer_info.UsrData.sSystemBuffer.iHeight / 2);
			int size_v = buffer_info.UsrData.sSystemBuffer.iStride[1] * (buffer_info.UsrData.sSystemBuffer.iHeight / 2);

			decoded_image_.CreateFrame(size_y, static_cast<uint8_t*>(data[0]),
				size_u, static_cast<uint8_t*>(data[1]),
				size_v, static_cast<uint8_t*>(data[2]),
				buffer_info.UsrData.sSystemBuffer.iWidth,
				buffer_info.UsrData.sSystemBuffer.iHeight,
				buffer_info.UsrData.sSystemBuffer.iStride[0],
				buffer_info.UsrData.sSystemBuffer.iStride[1],
				buffer_info.UsrData.sSystemBuffer.iStride[1]);

			decoded_image_.set_timestamp(input_image._timeStamp);
			decode_complete_callback_->Decoded(decoded_image_);
			return WEBRTC_VIDEO_CODEC_OK;
		}else {
			WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCoding, -1,
				"H264DecoderImpl::Decode, buffer status:%d", buffer_info.iBufferStatus);
			return WEBRTC_VIDEO_CODEC_OK;
		}
	}最后是Reset和Copy方法，分别用于重置和复制，这里暂时用不到，二者的实现如下


VideoDecoder* H264DecoderImpl::Copy() {
		// Sanity checks.
		if (!inited_) {
			// Not initialized.
			assert(false);
			return NULL;
		}
		if (decoded_image_.IsZeroSize()) {
			// Nothing has been decoded before; cannot clone.
			return NULL;
		}
		// Create a new VideoDecoder object
		H264DecoderImpl *copy = new H264DecoderImpl;

		// Initialize the new decoder
		if (copy->InitDecode(&codec_, 1) != WEBRTC_VIDEO_CODEC_OK) {
			delete copy;
			return NULL;
		}

		return static_cast<VideoDecoder*>(copy);
	}
int H264DecoderImpl::Reset() {
		if (!inited_) {
			return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
		}
		InitDecode(&codec_, 1);
		return WEBRTC_VIDEO_CODEC_OK;
	}
由此，对OPENH264解码功能的重新封装也全部完成


注册与调用
最后，我们要在主流程中（见上一篇文章）中注册OPENH264为外部编码器，使用RegisterExternalSendCodec和RegisterExternalReceiveCodec方法，如下


        webrtc::H264Encoder *h264encoder = webrtc::H264Encoder::Create();
	webrtc::H264Decoder *h264decoder = webrtc::H264Decoder::Create();

	webrtc::ViEExternalCodec* external_codec = webrtc::ViEExternalCodec
		::GetInterface(ptrViE);
	external_codec->RegisterExternalSendCodec(videoChannel, 88,
		h264encoder, false);
	external_codec->RegisterExternalReceiveCodec(videoChannel,
		88, h264decoder, false);这里的88也可以改为其他数值，但是要与后面设置的videoCodec.plType值相符。

至此，就成功地将OPENH264集成到了WebRTC的VideoEngine中。
本工程的源代码下载。








版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 1874 畅通工程续
畅通工程续

Time Limit: 3000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)

Total Submission(s): 37414    Accepted Submission(s): 13812


Problem Description
某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。

现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。
 

Input
本题目包含多组数据，请处理到文件结束。
每组数据第一行包含两个正整数N和M(0<N<200,0<M<1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。
接下来是M行道路信息。每一行有三个整数A,B,X(0<=A,B<N,A!=B,0<X<10000),表示城镇A和城镇B之间有一条长度为X的双向道路。
再接下一行有两个整数S,T(0<=S,T<N)，分别代表起点和终点。
 

Output
对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.

 

Sample Input

3 3
0 1 1
0 2 3
1 2 1
0 2
3 1
0 1 1
1 2

 

Sample Output

2
-1模板题： 代码： #include<stdio.h>
#define inf 10000000
#define ac 250
int map[ac][ac],dist[ac];
int d,e;
int cross,road;
void floyd()
{
    int i,j,k;
    for(k=0;k<cross;k++)
      for(i=0;i<cross;i++)
        for(j=0;j<cross;j++)
        {
            if(map[i][j]>map[i][k]+map[k][j])
            map[i][j]=map[i][k]+map[k][j];
        }
        if(map[d][e]!=inf)
        printf("%d\n",map[d][e]);
        else
        printf("-1\n");
 } 
 int main()
 {
     int i,j,a,b,c;
     while(scanf("%d%d",&cross,&road)!=EOF&&cross!=0&&road!=0)
     {
         for(i=0;i<cross;i++)//初始化 
           for(j=0;j<cross;j++)
             {
                 if(i==j)
                 map[i][j]=0;
                 else 
                 map[i][j]=inf;
             }
         while(road--)
         {
             scanf("%d%d%d",&a,&b,&c);
             if(map[a][b]>c)
             map[a][b]=map[b][a]=c;//注意是双向 
         }
         scanf("%d%d",&d,&e);
         floyd();
     }
 }
 地杰斯特拉： 代码： #include<stdio.h>
#include<string.h>
#define INF 0x3f3f3f
#define max 200+10
int dist[max],visit[max],map[max][max];
int city,road;
int start,end;
void dijkstra()
{
    int i,j,next,mindist;
    memset(visit,0,sizeof(visit));
    for(i=0;i<city;i++)//初始化确定单源点 
    {
        dist[i]=map[start][i];
    }
    visit[start]=1;
    for(i=1;i<city;i++)
    {
        mindist=INF;
        for(j=0;j<city;j++)
        {
            if(visit[j]==0&&mindist>dist[j])//寻找距离最短的点 
            {
                mindist=dist[j];
                next=j;
            }
        }
        visit[next]=1;
        for(j=0;j<city;j++)
        {
            if(visit[j]==0&&dist[next]+map[next][j]<dist[j])//路径更新 
            dist[j]=dist[next]+map[next][j];
        }
    }
    if(dist[end]==INF)//不满足条件输出-1 
    printf("-1\n");
    else
    printf("%d\n",dist[end]);
} 
int main()
{
    int i,j,x,y,c;
    while(scanf("%d%d",&city,&road)!=EOF)
    {
        for(i=0;i<city;i++)//初始化 
        {
            for(j=0;j<city;j++)
            {
                if(i==j)
                map[i][j]=0;
                else
                map[i][j]=INF;
            }
        }
        while(road--)
        {
            scanf("%d%d%d",&x,&y,&c);
            if(map[x][y]>c)
            {
                map[x][y]=map[y][x]=c;//双向 
            }
        }
        scanf("%d%d",&start,&end);
        dijkstra();
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA - 11613 Acme Corporation(最小费用流)
题目大意：A公司生产一种元素，给出该元素在未来M个月中每个月的单位售价，最大生产量，生产成本，最大销售量和最大存储时间，和每月存储代价，问这家公司在M个月内所能赚大的最大利润
解题思路：这题建图还是比较简单的。主要说一下怎么跑出答案吧。我用的是MCMF，建边的时候，费用我用的是相反数，所以得到最小费用后要去相反数 
MCMF的时候，用一个数组纪录了到达汇点时所花费的最小价值，因为取的是相反数，所以当价值为正时，就表示已经亏本了，所以可以退出了
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;
#define N 1010
#define ll long long
#define abs(a)((a)>0?(a):(-(a)))
#define INF 0x3f3f3f3f3f3f3f3f

struct Edge{
    int from, to;
    ll cap, flow ,cost;
    Edge() {}
    Edge(int from, int to, ll cap, ll flow, ll cost):from(from), to(to), cap(cap), flow(flow), cost(cost) {}
};

struct MCMF{
    int n, m, source, sink;
    vector<Edge> edges;
    vector<int> G[N];
    ll d[N], f[N];
    int  p[N];
    bool vis[N];

    void init(int n) {
        this->n = n;
        for (int i = 0; i <= n; i++)
            G[i].clear();
        edges.clear();
    }

    void AddEdge(int from, int to, ll cap, ll cost) {
        edges.push_back(Edge(from, to, cap, 0, cost));
        edges.push_back(Edge(to, from, 0, 0, -cost));
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }

    bool BellmanFord(int s, int t, ll &flow, ll &cost) {
        for (int i = 0; i <= n; i++)
            d[i] = INF;
        memset(vis, 0, sizeof(vis));
        vis[s] = 1; d[s] = 0; f[s] = INF; p[s] = 0;
        queue<int> Q;
        Q.push(s);

        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            vis[u] = 0;

            for (int i = 0; i < G[u].size(); i++) {
                Edge &e = edges[G[u][i]];
                if (e.cap > e.flow && d[e.to] > d[u] + e.cost) {
                    d[e.to] = d[u] + e.cost;
                    p[e.to] = G[u][i];
                    f[e.to] = min(f[u], e.cap - e.flow);
                    if (!vis[e.to]) {
                        vis[e.to] = true;
                        Q.push(e.to);
                    }
                }
            }
        }

        if (d[t] > 0)
            return false;

        flow += f[t];
        cost += d[t] * f[t];

        int u = t;
        while (u != s) {
            edges[p[u]].flow += f[t];
            edges[p[u] ^ 1].flow -= f[t];
            u = edges[p[u]].from;
        }
        return true;
    }

    ll Mincost(int s, int t) {
        ll flow = 0, cost = 0;
        while (BellmanFord(s, t, flow, cost));
        return cost;
    }
};
MCMF mcmf;
int n, m, source, sink, cas = 1;

struct Node{    
    ll m, n, p, s, e;
}node[N];

void init() {
    scanf("%d%d", &n, &m);
    source = 0; sink = 2 * n + 1;
    mcmf.init(sink);
    for (int i = 1; i <= n; i++) { 
        scanf("%lld%lld%lld%lld%lld", &node[i].m, &node[i].n, &node[i].p, &node[i].s, &node[i].e);
        mcmf.AddEdge(source, i, node[i].n, 0);
        mcmf.AddEdge(i + n, sink, node[i].s, 0);
    }

    for (int i = 1; i <= n; i++) {
        mcmf.AddEdge(i, i + n, INF, node[i].m - node[i].p);
        for (int j = 1; j <= node[i].e && i + j <= n; j++) 
            mcmf.AddEdge(i, i + j + n, INF, m * j + node[i].m - node[i+j].p);
    }
    ll ans = mcmf.Mincost(source, sink);
    printf("Case %d: %lld\n", cas++, abs(ans));
}

int main() {
    int test;
    scanf("%d", &test);
    while (test--) {
        init();
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java IO流
一、概述
Java中与IO相关的类有很多，都集中在java.io中，都是以流的形式操作的，流是有一定的顺序，像一个管道一样，它的本质是传输数据。根据数据类型的不同可以分为字节流和字符流，根据流向的不同可以分为输入流和输出流。

字符流：因为数据有不同的编码，可以对字符进行不同的操作，其本质还是基于字节流，然后再查询相应的码表。一般用于处理纯文本数据。
字节流：可以处理所有类型数据，二进制文件（图片，音频等）。
输入流：读入数据，也就是数据的源，如键盘，磁盘文件，网络文件，内存等。字符流对应的基本输入流为Reader，字节流对应的基本输入流为InputStream。
输出流：输出数据，数据的目的地，如控制台，磁盘文件，内存等。字符流对应的基本输出流为Writer，字节流对应的基本输出流为OutputStream。

Java 所有IO流的关系如下如：







Java IO流的关系结构


二、字符流
字符流的基本输入输出流是Reader和Writer，两者有一些常用的方法： 
Reader的常用读取操作：

int read() 读取单个字符。 
int read(char[] cbuf) 将字符读入数组。 
abstract  int read(char[] cbuf, int off, int len)  将字符读入数组的某一部分。

Writer的常用写入操作：

abstract  void flush() 刷新该流的缓冲。 
void write(char[] cbuf) 写入字符数组。
void write(int c) 写入单个字符。
void write(String str)  写入字符串。 
void write(String str, int off, int len)  写入字符串的某一部分。 

在使用Reader和Writer进行数据流的读入和写入操作时是不会直接创建Reader和Writer对象的，一般都是使用其子类，如FileReader和FileWriter，示例代码如下：
import java.io.*;
class ReaderDemo {
    public static void main(String[] args) {
        FileReader reader = null;
        FileWriter writer = null;
        try {
            writer = new FileWriter("file.txt");
            // 向流中写入一个char[]，内容为['H','e','l','l','o']
            writer.write("Hello".toCharArray());
            writer.flush(); // 刷新内容到磁盘上
        } catch (IOException e) {
            // IO异常在这里处理
        } finally {
            try {
                // 在finally中关闭流，并判断是否为null
                if(writer != null) {
                    writer.close();
                }
            } catch (IOException e) {}
        }

        try{
            reader = new FileReader("file.txt");
            char[] buf = new char[1024];
            int n = 0;
            // 从流中读入一个char[]，然会读入的长度，-1表示到达流尾
            while((n = reader.read(buf)) != -1) {
                // 输出到屏幕上
                System.out.println(new String(buf, 0, n));
            }
        } catch (IOException e) {
            // IO异常在这里处理
        } finally {
            try {
                // 在finally中关闭流，并判断是否为null
                if(reader != null) {
                    reader.close();
                }
            } catch (IOException e) {}
        }
    }
}
上面代码有些需要注意的地方，如不管是流的创建，打开，写入，读取，刷新，关闭等操作，一般都会抛出IOException，因为对磁盘进行操作（一般都是）都有可能产生错误，如磁盘满了，文件被占用等等，所以必须对其进行捕获，并处理。流的关闭一般放在try中的finally中，原因是为防止出错后无法及时释放资源。在进行数据的写入时，当执行完write方法后，数据可能不会立即被写入到目的地，这时可以使用flush功能进行立即完成写入功能，也可以在close时自定完成内容的写入。 
还有一点关于数据的读入过程，如使用int read()一个字节一个字节的读入，到达流尾时，返回-1，这种方式，需要注意其返回int需要强制转换一下，如int data = reader.read();，那么读到的数据便是(char)data；如果使用int read(char[])方式读取数据，那么就如上面代码示例的读取方式操作即可。
BufferedWriter和BufferedReader使用简介
BufferedInputStream和BufferedOutputStream是为提高读取和写入的效率而出现的，当我们读取和写入数据时，可以现在内存中建立一个缓冲区，加快数据流的读写，其使用非常简单，将Reader或者Writer对象做为参数传递给其构造函数即可。功能和类似，示例代码如下：
import java.io.*;
class Demo {
    public static void main(String[] args) {
        BufferedWriter bw = null;
        try {
            bw = new BufferedWriter(new FileWriter("file.txt"));
            // 向流中写入一个char[]，内容为['H','e','l','l','o']
            bw.write("Hello".toCharArray());
            bw.newLine();
            bw.flush();
        } catch (IOException e) {
            // IO异常在这里处理
        } finally {
            try {
                // 在finally中关闭流，并判断是否为null
                if(bw != null) {
                    bw.close();
                }
            } catch (IOException e) {}
        }
    }
}
其中newLine()是输出一个换行，这种操作是跨平台的，即在Windows下输出\r\n，而在Linux下输出\n。
LineNumberReader使用简介
LineNumberReader单从类名上看，大致也知道了类的功能，便是可以输出文本文件的行号。这里行号是从1开始的，也可以使用setLineNumber(int)功能为其设置一个偏移值，如设置100，那么行号就会从101开始输出。示例代码如下：
import java.io.*;
class Demo {
    public static void main(String[] args) throws IOException {
        LineNumberReader reader = new LineNumberReader(new FileReader("file.txt"));
        String line = null;
        // 如果读到文件末尾则返回null
        while((line=reader.readLine()) != null ) {
            // 获取行号并输出
            System.out.println(reader.getLineNumber()+": " + line);
        }
        reader.close();
    }
}
// 执行结果为
1: Hello
2: haha
3: Hi
4: good meeas
5:
6: sa
三、字节流
字符流操作的是纯文本内容，而字节流则是所有二进制文件都可以操作，如图片，视频，当然文件文件也是可以的。与字符流中读出和写入的类型为char型相对应，字节流读出和写入的是byte类型。字节流的两个基本输入输出流为InputStream和OutputStream，其功能与字符流的功能类似。对于文件的操作的流是相应的FileInputStream和FileOutputStream，下面通过一个图片拷贝功能作为字节流的一个示例代码：
import java.io.*;
class Demo {
    public static void main(String[] args) throws IOException {

        FileInputStream fin = new FileInputStream("pic.png");
        FileOutputStream fout = new FileOutputStream("pic2.png");

        // 与Reader不同的是这里使用的是byte类型
        byte[] buf = new byte[1024];
        int n = 0;

        while((n=fin.read(buf)) != -1) {
            fout.write(buf, 0, n);
        }

        // 关闭流
        fin.close();
        fout.close();
    }
}
BufferedInputStream和BufferedOutputStream使用简介
为了提高流操作的效率，这里也用相应的缓冲流，到底使用缓冲流与不使用缓冲流在效率上有多大的差别，可以通过比较得出结果。从下面代码的比较结果可以明显的发现，加入缓冲机制会大大提高程序的运行效率，原因大致解释为，未加入缓冲机制，每次读取read()都会调用系统底层读取磁盘操作，每次读取一个字节，非常耗时；而加入缓冲机制后，系统会一次将很多内容读取到内存，而调用read()时，只需要从内存中返回数据内容即可，大大减少了系统底层访问磁盘的次数，所以速度会加快很多。代码示例如下：
import java.io.*;
class Demo {
    public static void main(String[] args) throws IOException {
        // 未加缓冲机制
        FileInputStream fin = new FileInputStream("movie.avi");
        FileOutputStream fout = new FileOutputStream("movie2.avi");
        int data = 0;
        long time1 = System.currentTimeMillis();

        while((data = fin.read()) != -1) {
            fout.write(data);
        }
        System.out.println("普通：" + (System.currentTimeMillis()-time1) + "毫秒");
        fin.close();
        fout.close();
        // 加上缓冲机制
        BufferedInputStream bfin = 
            new BufferedInputStream(new FileInputStream("movie.avi"));
        BufferedOutputStream bfout = 
            new BufferedOutputStream(new FileOutputStream("movie3.avi"));
        long time2 = System.currentTimeMillis();

        while((data = bfin.read()) != -1) {
            bfout.write(data);
        }
        System.out.println("缓冲：" + (System.currentTimeMillis()-time2) + "毫秒");
        bfin.close();
        bfout.close();
    }
}
// 执行结果为
普通：50052毫秒
缓冲：61毫秒
读取转换流和写入转换流
这里涉及到的两个流是关于字符流和字节流的转换的操作，去两者名称为：InputStreamReader和OutputStreamWriter，InputStreamReader是将InputStream（字节流）流作为参数构造出输入字符流。而OutputStreamWriter则是将OutStream（字节流）作为参数构造出输出字符流。如此一来，我们读取键盘（System.in）数据时，便可以使用Reader的功能，也可以使用Writer功能将数据输出到控制台（System.out），示例代码如下：
import java.io.*;
class Demo {
    public static void main(String[] args) throws IOException {
        // 键盘的最常见写法。
        BufferedReader bufr = 
                new BufferedReader(new InputStreamReader(System.in));

        // 使用字符输出方式到控制台
        BufferedWriter bufw = 
                new BufferedWriter(new OutputStreamWriter(System.out));

        String line = null;
        while((line=bufr.readLine()) != null) {
            // 输入end时退出
            if("end".equals(line)) break;
            bufw.write(line.toUpperCase());
            bufw.newLine();
            bufw.flush();
        }
        bufr.close();
        bufw.close();
    }
}
// 执行结果为
hello
HELLO
Hi
HI
good
GOOD
end
四、流的总结
Java将IO单独封装在一个包内，其中不同功能的流数不胜数，使用起来很容易混乱，所以，在使用java io流时需要按照一定的规则，如按照流的流向可以分为两大类，即输入流和输出流，输入流来自数据源，输出流有目的地。常见的源和目的地有如下：

源：键盘录入，磁盘读入，网络文件，内存。
目的地：控制台输出，磁盘文件，内存。

在明确流向后，在看流的数据是否为纯文本类型，若是则优先选用Reader或Writer字符流来操作，若是二进制类型，则使用InputStream和OutputStream字节流来操作。 
提高流的效率，可以使用BufferedXXX来包装流。对于编码问题，可以使用InputStreamReader和OutputStreamWriter，其可以指定编码类型，如utf-8或者GBK等。
五、File的使用简介
是将文件和文件夹封装成的对象，方便对文件或者文件夹的属性信息进行操作，也可以作为参数传递。
File常用内容
static String separator为一种夸平台文件路径分隔符。 
文件的创建和删除
File file = new File("file.txt");
file.createNewFile(); // 用于创建一个空文件,成功返回true，若已存在，则不会创建并返回false,
file.delete(); // 删除成功返回true，否则返回false
file.deleteOnExit(); // 退出时删除，一般用于系统退出时删除临时文件
文件的判断
// 通过文件的目录和文件名创建一个File对象
File file = new File("c:" + File.separator + "java", "info.txt");
file.canExecute(); // 是否可被执行
file.exists(); // 是否存在
file.mkdir(); // 创建目录，一层（成功返回true，失败返回false）
file.mkdirs(); // 创建多级目录
file.isDirectory(); // 是否为目录文件，不存在或者不是目录返回false
file.isFile(); // 是否为文件，不存在或不是文件返回false
file.isHidden(); // 是否为隐藏文件
file.isAbsolute(); // 是否为据对路径
file.getName(); // 获取文件名
file.getParh(); // 获取文件路径
file.getParent(); // 父目录
file.lastModified(); // 最后修改时间
文件列表
File[] files = File.listRoots();列出有效盘符，如（C:\，D:\等）。获取文件夹内的所有文件，以及自定义指定文件，可以使用FileFilter来过滤文件。若要删除内容不为空的文件夹时，需要递归删除文件夹内的所有内容。示例代码如下：
import java.io.*;
class Demo {
    public static void main(String[] args) {

        // 列出javas\\day20目录下的java文件
        File file = new File("javas\\day20");
        File[] files = file.listFiles(new FileFilter() {
            public boolean accept(File filename) {
                // 以.java结尾的都接受
                return filename.getName().endsWith(".java");
            }
        });

        for(File f : files) {
            System.out.println(f.getName());
        }

        // 删除javas内的所有内容
        delete(new File("javas"));
    }

    /**
     * 递归删除内容不为空的文件夹或文件
     */
    public static void delete(File file) {
        if(file.isDirectory()) {
            File[] files = file.listFiles();
            for(File f : files) {
                if(f.isDirectory()) {
                    delete(f);
                } else {
                    f.delete();
                }
            }
        }
        file.delete();
    }
}
// 执行结果为
FileDemo.java
FileDemo2.java
FileDemo3.java
JavaFileList.java
PrintStreamDemo.java
PropertiesDemo.java
RemoveDir.java
RunCount.java
SequenceDemo.java
SplitFile.java
六、其他IO内容
1、改变标准输入输入流，可以使用System.setIn(InputStream)和System.setOut(PrintStream)来设置标准输入输出流，可以将标准输入设置成从键盘读入，或者将标准输出设置成输出到文件等。 
2、异常信息输出到文件，在捕获异常后一般使用e.printStackTrace()将异常信息输出，但是这样对用户来说是没有任何意义的，所以可以使用e.printStackTrace(new FileOutputStream("log.txt"))将异常信息输出到文件。 
3、Properties简介，可以使用Properties存取配置文件，其内部有相关流操作，即load(InputStream inStream)和store(OutputStream out, String comments)用于从本地读取配置文件和将配置文件保存至本地。 
4、合并流SequenceInputStream可以将多个流合并成一个整体，有两种构造函数，一是将两个字节流合并成一个流（较为易懂），二是传递一个Enumeration<? extends InputStream> e类型参数，示例代码如下：
import java.io.*;
import java.util.*;
class SequenceDemo {
    public static void main(String[] args) throws IOException {
        // Vector 具有获取Enumeration功能
        Vector<FileInputStream> v = new Vector<FileInputStream>();
        v.add(new FileInputStream("1.txt"));
        v.add(new FileInputStream("2.txt"));
        v.add(new FileInputStream("3.txt"));

        // 获取流枚举
        Enumeration<FileInputStream> en = v.elements();
        // 构造合并流
        SequenceInputStream sin = new SequenceInputStream(en);
        // 将内容都写入fout
        FileOutputStream fout = new FileOutputStream("123.txt");
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=sis.read(buf))!=-1) {
            fos.write(buf,0,len);
        }
        fout.close();
        sin.close();
    }
}
5、对象的序列化，实现Serializable接口，序列化即使将一个对象整个存储到文件中保存，可以实现数据的保存，下次可以将对象从文件中恢复出，只需要此对象实现了Serializable接口即可，注意的两点是，一是为对象添加static long serialVersionUID = 42L;随便指定一个数值，这是这个对象的唯一标识，即有相同标识才可以从文件中恢复出对象；二是在不需要序列化的对象前加上transient关键字。序列化只会序列化堆中的数据，静态数据不会被序列化，transient关键字的也不会。 
6、管道流，PipedInputStream和PipedOutputStream，管道流就好像输入输出为一条管道，输入流可以从管道中读取数据，而输出流可以向管道中输入。可以通过两条线程同时操作，当输入流没有内容可以读取时，会柱塞线程等待输入数据。通过connect()来关联相关流。 
7、RandomAccessFile用与文件的随机访问，自身具备读写方法，有r、rw等打开方式，常用方法如skipBytes(int)跳过一部分内容，seek(index)将文件指针移到指定位置，适用于文件的断点写入，和多线程分段写入等。 
8、ByteArrayStream是一种基于数组的流，不用close操作，也不会抛出IOException，其简单来说就是一个数组操作工具。和其类似的有CharArrayInputStream、CharArrayOutputStream针对字符数组操作的流和StringReader、StringWriter针对字符串操作的流。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java-Collection
纸上得来终觉浅，绝知此事要躬行
  --陆游    问渠那得清如许，为有源头活水来  --朱熹



Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。Java集合工具包位置是java.util.*
Java集合主要可以划分为4个部分：List列表、Set集合、Map映射、工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)。
Java集合框架如下图：
 


由上图可以看到Java框架主要是Collection和Map。
一、Collection是一个接口，是一个高度抽象出来的集合，接口包含了基本操作和属性。
        Collection包含了List和Set两大分支：
1）、List是一个有序的队列，每一个元素都有它的索引，第一个元素的索引值是0。List的实现类有LinkedList、ArrayList、Vector和Stack。
         （1）、LinkedList实现了List接口，允许元素为空，LinkedList提供了额外的get,remove,insert方法，这些操作可以使LinkedList被用作堆栈、队列或双向队列。
           LinkedList并不是线程安全的，如果多个线程同时访问LinkedList，则必须自己实现访问同步，或者另外一种解决方法是在创建List时构造一个同步的List。
         （2）、ArrayList  实现了可变大小的数组，允许所有元素包括null，同时ArrayList也不是线程安全的。
         （3）、Vector类似于ArrayList，但Vector是线程安全的。
         （4）、Stack继承自Vector，实现一个后进先出的堆栈。


            Vector、ArrayLis和LinkedList比较：
            （1）Vector是线程安全的，ArrayList和LinkedList不是线程安全的，但一般不考虑线程安全因素，ArrayList和LinkedList效率比较高。
            （2）ArrayList和Vector是实现了基于动态数组的数据结构而LinkedList是基于链表的数据结构。
            （3）数组和链表的查询，删除等的性能。


 2）、set是一个不允许有重复元素的集合。set的实现类有Hashset和Treeset。HashSet依赖于HashMap，实际上是通过HashMap实现的；TreeSet依赖于TreeMap，通过TreeMap来实现的。


     
二、Map是一个映射接口，采用key-value键值对的方式。
        AbstractMap是一个抽象类，它实现了Map接口中的大部分API，而HashMap、TreeMap和WeakHashMap都是继承于AbstractMap，HashTable虽然继承于Dictionary，但它实现了Map接口。


1）、HashTable
        （1）HashTable继承Map接口，实现一个key-value映射的哈希表，任何非空的对象都可作为key或者value。
        （2）添加数据put和取出数据get两个操作的时间开销为常数。
        （3）由于作为key的对象是通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须要实现hashCode和equals方法。hashCode和equals方法都是继承自根类Object。
        （4）HashTable是线程安全的。


2）、HashMap
        （1）HashMap和HashTable类似，但HashMap是非线程安全的，且允许key和value都为空。
        （2）将HashMap视为Collection时，其迭代操作时间开销和HashMap的容量成正比，如果迭代性能的操作相当重要的话，不要将HashMap的初始化容量舍得过高。


3）、TreeMap
        （1）HashMap通过Hashcode对其内容进行快速查找，无序的，而TreeMap中所有的元素都保持着某种固定的顺序，有序的。
        （2）TreeMap没有调优选项，因为该树总是处于平衡状态。


4）、WeakHashMap
          （1） WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。 
  
总结
（1）如果涉及到堆栈，队列等操作，应该考虑用List；对于需要快速插入，删除元素，应该使用LinkedList；如果需要快速随机访问元素，应该使用ArrayList。
（2）如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高；如果多个线程可能同时操作一个类，应该使用同步的类。
（3）要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。
（4）使用Map时，查找、更新、删除、新增最好使用HashMap或HashTable；对Map进行自然顺序或自定义键顺序遍历时，最好使用TreeMap;
（5）尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。


Collection接口源码：

public interface Collection<E> extends Iterable<E> {
    int size(); //大小
    boolean isEmpty();//是否为空
    boolean contains(Object o); //是否包含某个对象
    Iterator<E> iterator(); //迭代
    Object[] toArray(); //转化为数组
    <T> T[] toArray(T[] a);
    boolean add(E e); //增加对象
    boolean remove(Object o); //删除对象
    boolean containsAll(Collection<?> c); //判断是否包含相同的Collection
    boolean addAll(Collection<? extends E> c); //将Collection追加到
    boolean removeAll(Collection<?> c); //删除所有相同对象
    default boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator<E> each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
    boolean retainAll(Collection<?> c);
    void clear();
    boolean equals(Object o);
    int hashCode();
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, 0);
    }
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
    default Stream<E> parallelStream() {
        return StreamSupport.stream(spliterator(), true);
    }
}




版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

HDU 3232 && UVA 12230 (简单期望)


Crossing Rivers
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 738    Accepted Submission(s): 387

Problem Description 
You live in a village but work in another village. You decided to follow the straight path between your house (A) and the working place (B), but there are several rivers you need to cross. Assume B is
 to the right of A, and all the rivers lie between them.
Fortunately, there is one "automatic" boat moving smoothly in each river. When you arrive the left bank of a river, just wait for the boat, then go with it. You're so slim that carrying you does not change the speed of any boat.
Days and days after, you came up with the following question: assume each boat is independently placed at random at time 0, what is the
expected time to reach B from A? Your walking speed is always 1.
To be more precise, for a river of length L, the distance of the boat (which could be regarded as a mathematical point) to the left bank at time 0 is
uniformly chosen from interval [0, L], and the boat is equally like to be moving left or right, if it’s not precisely at the river bank.
 
Input 
There will be at most 10 test cases. Each case begins with two integers
n and D, where n (0 <= n <= 10) is the number of rivers between A and B,
D (1 <= D <= 1000) is the distance from A to B. Each of the following
n lines describes a river with 3 integers: p, L and v (0 <=
p < D, 0 < L <= D, 1 <= v <= 100). 
p is the distance from A to the left bank of this river, L is the length of this river,
v is the speed of the boat on this river. It is guaranteed that rivers lie between A and B, and they don’t overlap. The last test case is followed by
n=D=0, which should not be processed.
 
Output 
For each test case, print the case number and the expected time, rounded to 3 digits after the decimal point.
Print a blank line after the output of each test case.
 
Sample Input

1 1
0 1 2
0 1
0 0

 
Sample Output

Case 1: 1.000

Case 2: 1.000

 
Source 
2009 Asia Wuhan Regional Contest Hosted
 by Wuhan University

题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=3232

题目大意：A，B相距D，A,B间有n条河，河宽Li，每条河上有一个速度为vi的船，在河山来回行驶，每条河离A的距离为pi，现在求从A到B时间的期望，步行速度始终为1

题目分析：首先如果全部步行则期望为D，现在每遇到一条河，求过河时间的期望，等待时间的区间为(0，2*L/v)，船在每个地方都是等可能的，所以等待的期望就是(0 + 2*L/v) / 2 = L / v，又过河还要L / v，所以总的渡河期望值为2 * L / v，所以每遇到一条河拿D减去假设步行过河的期望L再加上实际过河期望2 * L / v即可，最后发现和p没有卵关系，真开心～

#include <cstdio>

int main()
{
    int n;
    double D;
    int ca = 1;
    while(scanf("%d %lf", &n, &D) != EOF && (n + D))
    {
        double p, l, v;
        for(int i = 0; i < n; i++)
        {
            scanf("%lf %lf %lf", &p, &l, &v);
            D = D - l + l * 2.0 / v;
        }
        printf("Case %d: %.3f\n\n", ca ++ , D);
    }
}


 



版权声明：本文为博主原创文章，未经博主允许不得转载。

图结构练习——最短路径
题目描述

 给定一个带权无向图，求节点1到节点n的最短路径。
 


输入
 输入包含多组数据，格式如下。
第一行包括两个整数n m，代表节点个数和边的个数。(n<=100)
剩下m行每行3个正整数a b c，代表节点a和节点b之间有一条边，权值为c。
 

输出
 每组输出占一行，仅输出从1到n的最短路径权值。（保证最短路径存在）
 

示例输入

3 2
1 2 1
1 3 1
1 0


示例输出

1
0


最短路问题
#include<stdio.h>
#include<string.h>
#define INF 0x3f3f3f3f
int map[200][200];
int dis[200][200];
int f1(int s,int e,int n)
{
  int i,j,k;
  for(i=0;i<=n;i++)
  {
    for(j=0;j<=n;j++)
    {
      dis[i][j]=map[i][j];
     }
  }
  for(k=1;k<=n;k++)
  {
    for(i=1;i<=n;i++)
    {
    for(j=1;j<=n;j++)
    {
      if(i!=j)
      {
        if(dis[i][j]>dis[i][k]+dis[k][j])
        {
          dis[i][j]=dis[i][k]+dis[k][j];
        }
    }
      }
    }
  }
  return dis[s][e];
  }
int main()
{
int n,m,i,j;
int a,b,c;
while(~scanf("%d%d",&n,&m))
{
memset(map,0,sizeof(map));
for(i=0;i<=n;i++)
{
  for(j=0;j<=n;j++)
  {
    if(i==j)
    map[i][j]=0;
    else
    map[i][j]=INF;
  }
}
  for(i=0;i<=m-1;i++)
  {
    scanf("%d%d%d",&a,&b,&c);
    if(map[a][b]>c)
    {
      map[a][b]=c;
      map[b][a]=c;
    }
  }
  int ans=f1(1,n,n);
  printf("%d\n",ans);
}
  return 0;
}
 








版权声明：本文为博主原创文章，未经博主允许不得转载。

Java设计模式 -- 工厂模式
项目实例

背景： 有四种WebView 因为业务逻辑的不同被划分为四种类型，分别如下：

public static final int BROWSER_TYPE_INNER = 0;
public static final int BROWSER_TYPE_SIMPLE = 1;
public static final int BROWSER_TYPE_OUTER = 2;
public static final int BROWSER_TYPE_THIRD = 3;
这四种不同类型的业务逻辑分别放在不同的Handler类，因此就会有四种Handler，为了统一接口和利于扩展，提供一个接口，这个接口为：IWebViewBusiness，然后我们为了抽出业务逻辑部分，进一步理清代码逻辑，使用一个WebViewManager类来管理。 
具体的层次结构如下：

上面的继承关系比较简单，这里不再赘述了，下面重点看一下四个Handler的管理类
public class WebViewManager implements IWebViewBusiness{
}
通过这个管理类，在构造器中来生成不同的Handler
public WebViewManager(Context context , IWebViewUI webviewUI, int browserType){
     this.mIWebViewUI = webviewUI;
     switch(browserType ){
     case BROWSER_TYPE_INNER :
          mWebViewHandler = new InnerWebViewHandler(context, mIWebViewUI);
          break;
     case BROWSER_TYPE_OUTER :
          mWebViewHandler = new OuterWebViewHandler(context, mIWebViewUI);
          break;
     case BROWSER_TYPE_SIMPLE :
          mWebViewHandler = new SimpleWebViewHandler(context, mIWebViewUI);
          break;
     case BROWSER_TYPE_THIRD :
          mWebViewHandler = new BrowserThirdHandler(context, mIWebViewUI);
          break;
    }
}
接着看一下在具体的WebViewFragment或者WebViewActivity等类似的UI类中如何去使用。
public class SuperFanliFragmentWebview extends BaseFragmentWebview {
}
在onCreate()生命周期中生成Manager实例，而这个Manager通过Type类型参数构造不同的Handler。
@Override
public void onCreate (Bundle savedInstanceState ) {
     super.onCreate(savedInstanceState );
     mWebViewManager = new WebViewManager(getActivity(), this, WebViewManager.BROWSER_TYPE_INNER );
     mWebViewManager.onCreate(savedInstanceState );

}
至此结构抽象完成，仔细看看上面的实例，是不是很像下面的普通工厂模式：

普通工厂实例
上图简单的实例如下：
/************************************************
*                Send接口                       *
************************************************/
public interface Sender {
    public void Send();
}
/************************************************
*               Mail实现类                      *
************************************************/
public class MailSender implements Sender {
    @Override
    public void Send() {
        System.out.println("this is mailsender!");
    }
}
/************************************************
*               SMS实现类                       *
************************************************/
public class SmsSender implements Sender {

    @Override
    public void Send() {
        System.out.println("this is sms sender!");
    }
}
/************************************************
*               普通工厂类                      *
************************************************/
public class SendFactory {

    public Sender produce(String type) {
        if ("mail".equals(type)) {
            return new MailSender();
        } else if ("sms".equals(type)) {
            return new SmsSender();
        } else {
            System.out.println("请输入正确的类型!");
            return null;
        }
    }
}
测试Case
public class FactoryTest {
    public static void main(String[] args) {
        SendFactory factory = new SendFactory();
        Sender sender = factory.produce("sms");
        sender.Send();
    }
}
普通工厂小结

普通工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要扩展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。

抽象工厂
 
上图简单的实例如下：
/************************************************
*                Send接口                       *
************************************************/
public interface Sender {
    public void Send();
}
/************************************************
*               Mail实现类                      *
************************************************/
public class MailSender implements Sender {
    @Override
    public void Send() {
        System.out.println("this is mailsender!");
    }
}
/************************************************
*               SMS实现类                       *
************************************************/
public class SmsSender implements Sender {

    @Override
    public void Send() {
        System.out.println("this is sms sender!");
    }
}
/************************************************
*               工厂接口                        *
************************************************/
public interface Provider {
    public Sender produce();
}
/************************************************
*               Mail工厂实现类                  *
************************************************/
public class SendMailFactory implements Provider {

    @Override
    public Sender produce(){
        return new MailSender();
    }
}
/************************************************
*               SMS工厂实现类                   *
************************************************/
public class SendSmsFactory implements Provider{

    @Override
    public Sender produce() {
        return new SmsSender();
    }
}
测试Case
public class Test {
    public static void main(String[] args) {
        Provider provider = new SendMailFactory();
        Sender sender = provider.produce();
        sender.Send();
    }
}
抽象工厂小结

其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！

改造项目实例
按照上面的抽象工厂，改造扩展更好的抽象工厂如下： 
先定义上面所谓的Provider接口：
public interface WebViewHandlerProvider {

    public IWebViewBusiness produce( final Context context , final IWebViewUI webviewBusiness );

}
接着定义其他几种类型的Handler的工厂类并实现这个接口：
/*****************************************************************************
*                          InnerWebView工厂实现类                            *
*****************************************************************************/
public class InnerWebViewHandlerFactory implements WebViewHandlerProvider {
    @Override
    public IWebViewBusiness produce(Context context, IWebViewUI webviewBusiness) {
        if (context == null || webviewBusiness == null ) {
            return null ;
        }

        return new InnerWebViewHandler(context, webviewBusiness);
    }
}
/*****************************************************************************
*                           OutWebView工厂实现类                             *
*****************************************************************************/
public class OutWebViewHandlerFactory implements WebViewHandlerProvider {
    @Override
    public IWebViewBusiness produce(Context context, IWebViewUI webviewBusiness) {
        if (context == null || webviewBusiness == null ) {
            return null ;
        }

        return new OuterWebViewHandler(context, webviewBusiness);
    }
}
/*****************************************************************************
*                           其他工厂实现类省略                               *
*****************************************************************************/
结构如下： 
 
修改完成以后，我们来看看具体该如何使用，还是回到UI类看一下：
public class SuperFanliFragmentWebview extends BaseFragmentWebview {
}
还是在onCreate()生命周期中生成Manager实例
@Override
public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState );

     final WebViewHandlerProvider handlerProvider = new InnerWebViewHandlerFactory();
     mProvider = handlerProvider .produce(getActivity(), this);
     mProvider.onCreate(savedInstanceState );

}
这样就修改完成了，如果想要增加一种类型的Handler，只需要增加一个Factory，和一个具体的Handler即可，完全不用修改其他类，这个扩展性比较好。 
当然如果不想这么干，也可以直接不用抽象工厂模式，直接简单粗暴好了：
@Override
public void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState );

    mProvider = new InnerWebViewHandler(getActivity(), this);          
    mProvider.onCreate(savedInstanceState); 
}
最后多嘴一句，如果就这样简单粗暴，和上面抽象工厂实现相比，这两种实现方式有什么区别？

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

组合数重点整理
总结下最近刷过的关于组合数的题目，以供以后复习参考。 
首先要介绍的就是lucas定理，这也是组合数中重点中的重点。 
 
 
同时，因为我们也经常要遇到关于取模的运算，所以关于逆元的概念也必不可少。 
 
 
好了，接下来就是通过解决实际问题，来实践了。 
1.hdu3037 
解析：通过隔板法，求C(n+m , m )% p即可，这里我们就需要用到lucas定理了，注意，我们一般会预处理一些所需要的阶乘运算，以便后来方便使用，降低复杂度，在这道题里面，我们预先处理了0~p的阶乘。
/*
ID: CaoLei
PROG: hdu_3037.cpp
LANG: C++
*/

#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <vector>
using namespace std;
#define N 100010
#define pi acos(-1.0)
#define inf 100000000
typedef long long ll;
typedef unsigned long long ull;
ll p;
ll fact[N];
void init(){
    fact[0]=1;
    for(int i=1;i<=p;i++)
      fact[i]=fact[i-1]*i%p;
}

ll pow(ll a,ll b,ll pp){
    ll tmp=a,ans=1;
    while(b){
        if(b&1){
            ans=ans*tmp%pp;
        }
        b>>=1;
        tmp=tmp*tmp%pp;
    }
    return ans;
}
ll lucas(ll n,ll m,ll p){
    if(m==0) return 1;
    else if(n%p<m%p) return 0;
    else return fact[n%p]*pow(fact[n%p-m%p]*fact[m%p]%p,p-2,p)%p*lucas(n/p,m/p,p)%p;   //在这里面痛哇，fact[n-m]*fact[m]%p忘了模除
}

int main(){
    freopen("in.txt","r",stdin);
    int t;
    scanf("%d",&t);
    ll n,m;
    while(t--){
        scanf("%lld%lld%lld",&n,&m,&p);
        init();
        printf("%lld\n",lucas(n+m,m,p));
    }
    return 0;
}
2.hdu3944 
解析：其实将部分答案打出来仔细观察，就可以发现只需要求(C(n+1,m)+n-m)%p即可，但是注意这道题需要预处理大量的答案。
/*
ID: CaoLei
PROG: hdu_3944.cpp
LANG: C++
*/

#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <cmath>
#include <vector>
using namespace std;
#define N 10010
#define pi acos(-1.0)
#define inf 100000000
typedef long long ll;
typedef unsigned long long ull;
ll p;
int prime[10010];
bool is[10010];
int fact[N*1250];
ll pow(ll a,ll b,ll pp){
    ll tmp=a,ans=1;
    while(b){
        if(b&1){
            ans=ans*tmp%pp;
        }
        b>>=1;
        tmp=tmp*tmp%pp;
    }
    return ans;
}
ll getint(){
    char ch=getchar();
    ll ret=0;
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){
        ret=ret*10+ch-'0';ch=getchar();
    }
    return ret;
}  

ll lucas(ll n,ll m,ll p){
    if(m==0) return 1;
    else if(n%p<m%p) return 0;
    else return (ll)fact[n%p+prime[p]]*pow((ll)fact[n%p-m%p+prime[p]]*fact[m%p+prime[p]]%p,p-2,p)%p*lucas(n/p,m/p,p)%p;   
}

int main(){
    freopen("in.txt","r",stdin);
    int po=0;
    is[0]=is[1]=true;
    for(int i=2;i<=10000;i++){
        if(!is[i]){
            prime[i]=po*10000;
            fact[po*10000]=1;
            for(int j=po*10000+1;j<=po*10000+i;j++){
                fact[j]=(ll)fact[j-1]*ll(j-po*10000)%(ll)i;
            }
            po++;
            for(int j=2*i;j<=10000;j+=i) is[j]=true;
        }
    }
    ll n,m;
    int cnt=1;
    while(~scanf("%lld",&n)){
        m=getint();
        p=getint();
        if(m>n/2) m=n-m;
          printf("Case #%d: %lld\n",cnt++,(lucas(n+1,m,p)+n-m)%p);
    }
    return 0;
}
3.hdu4349 
解析：这时候就要借鉴《初等数论》上的结论了。 

/*
ID: CaoLei
PROG: hdu_4349.cpp
LANG: C++
*/

#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <cmath>
#include <vector>
using namespace std;
#define N 500010
#define pi acos(-1.0)
#define inf 100000000
typedef long long ll;
typedef unsigned long long ull;

int main(){
    int n,k;
    while(~scanf("%d%d",&n,&k)){
        while(n){
            if(n%2==0&&k%2==1) break;
            n>>=1;
            k>>=1;
        }
        if(n) printf("0\n");
        else printf("1\n");
    }
    return 0;
}

4.poj3146 
解析：这道题我按照上一题的结论试了试，就AC了。
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <cmath>
#include <vector>
using namespace std;
#define N 1010
#define pi acos(-1.0)
#define inf 100000000
typedef long long ll;
typedef unsigned long long ull;
int main(){
    int p,n,cnt=0;
    int ans;
    while(~scanf("%d%d",&p,&n)){
        if(p==0&&n==0) break;
        ans=1;
        while(n){
            ans*=(n%p+1);
            ans%=10000;
            n/=p;
        }
        printf("Case %d: ",++cnt);
        if(ans<10) printf("000%d\n",ans);
        else if(ans<100) printf("00%d\n",ans);
        else if(ans<1000) printf("0%d\n",ans);
        else printf("%d\n",ans);
    }
    return 0;
}
5.zoj3557 
解析：同样是隔板问题，但是要注意下预处理。
/*
ID: CaoLei
PROG: zoj_3557.cpp
LANG: C++
*/

#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <cmath>
#include <vector>
using namespace std;
#define N 500010
#define pi acos(-1.0)
#define inf 100000000
typedef long long ll;
typedef unsigned long long ull;
ll p;
ll fact[N];

ll pow(ll a,ll b,ll pp){
    ll tmp=a,ans=1;
    while(b){
        if(b&1){
            ans=ans*tmp%pp;
        }
        b>>=1;
        tmp=tmp*tmp%pp;
    }
    return ans;
}
ll c(ll n,ll m){
    ll a=1;
    for(int i=n;i>n-m;i--)
      a=a*i%p;
    a=a*pow(fact[m]%p,p-2,p)%p;
    return a;
}

ll lucas(ll n,ll m,ll p){
    if(m==0) return 1;
    else if(n%p<m%p) return 0;
    else return c(n%p,m%p)%p*lucas(n/p,m/p,p)%p;   //在这里面痛哇，fact[n-m]*fact[m]%p忘了模除
}

int main(){
    freopen("in.txt","r",stdin);
    ll n,m;
    while(~scanf("%lld%lld%lld",&n,&m,&p)){
        fact[0]=1;
        for(int i=1;i<=m;i++){
            fact[i]=fact[i-1]*i%p;
        }
        printf("%lld\n",lucas(n-m+1,m,p));
    }
    return 0;
}

（持续更新中）

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java序列化Serializable和Externalizable
纸上得来终觉浅，绝知此事要躬行
  --陆游       问渠那得清如许，为有源头活水来  --朱熹



什么是Java序列化？为什么出现Java序列化？怎样实现Java序列化？
一、什么是Java序列化
Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。


二、为什么出现Java序列化
两个进程之间进行通信时，需要传输各种信息，比如文本，图像，声音等等，这些信息是通过二进制流的形式进行传输的。
那么进程之间是不是也可以传递对象数据呢？答案是可以的。Java的序列化和反序列化就是将Java对象转化为字节序列，并
在网络上进行传输，反序列化将获得的字节序列数据生成对象。


三、怎样实现Java序列化


1）、对象的输入输出：ObjectInputStream，ObjectOutputStream。
2）、对象要实现Serializable或者Externalizable接口，否则会抛出异常。


注意：在Serializable中声明为static和transient类型的成员数据不能被序列化。


实现Serializable接口的序列化和反序列化示例程序：



public class Student implements Serializable
{
    private String name;
    private char sex;
    public Student()
    {

    }
    public Student(String name,char sex)
    {
        this.name = name;
        this.sex = sex;
    }

    public void setName(String name)
    {
        this.name = name;
    }

    public void setSex(char sex)
    {
        this.sex = sex;
    }


    public String getName()
    {
        return this.name;
    }

    public char getSex()
    {
        return this.sex;
    }

}

public class UseStudent
{
    public static void main(String[] args)
    {
        Student st = new Student("Tom",'M');
        File file = new File("O:\\Java\\com\\jieke\\io\\student.txt");
        try
        {
            file.createNewFile();
        }
        catch(IOException e)
        {
            e.printStackTrace();
        }
        try
        {
            //Student对象序列化过程  
            FileOutputStream fos = new FileOutputStream(file);
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(st);
            oos.flush();
            oos.close();
            fos.close();

            //Student对象反序列化过程  
            FileInputStream fis = new FileInputStream(file);
            ObjectInputStream ois = new ObjectInputStream(fis);
            Student st1 = (Student) ois.readObject();
            System.out.println("name = " + st1.getName());
            System.out.println("sex = " + st1.getSex());
            ois.close();
            fis.close();
        }
        catch(ClassNotFoundException e)
        {
            e.printStackTrace();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
}  



使用Externalizable接口进行序列化，必须要重写writeExternal（ObjectOutput
 output）和readExternal（ObjectInput input）方法
使用该接口的序列化方法需要我们来实现，因此可以对static和transient数据进行序列化。

public class Person implements Externalizable {
    private static final long serialVersionUID = -842029427676826563L;
    public static String name;
    private int age;
    private transient int workDay = 5;
    private String fClub;
    public Person() {
        System.out.println("none-arg constructor");
    }
    public Person(int age, String fClub) {
        this.age = age;
        this.fClub = fClub;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public int getWorkDay() {
        return workDay;
    }
    public void setWorkDay(int workDay) {
        this.workDay = workDay;
    }
    public String getfClub() {
        return fClub;
    }
    public void setfClub(String fClub) {
        this.fClub = fClub;
    }
    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();//执行默认的序列化机制  
        out.writeInt(workDay);
        System.out.println("正在进行序列持久化");
    }
    private void readObject(ObjectInputStream in) throws IOException,
            ClassNotFoundException {
        in.defaultReadObject();
        workDay = in.readInt();
        System.out.println("读取持久化对象");
    }
    @Override
    public void readExternal(ObjectInput arg0) throws IOException,
            ClassNotFoundException {
        // TODO Auto-generated method stub  
    }
    @Override
    public void writeExternal(ObjectOutput arg0) throws IOException {
        // TODO Auto-generated method stub    
    }
}
public class Hello {
    public static void main(String[] args) {
        Person person = new Person(26, "Juventus");
        person.setWorkDay(7);
        try {
            FileOutputStream fs = new FileOutputStream("foo.ser");
            ObjectOutputStream os = new ObjectOutputStream(fs);
            os.writeObject(person);
            os.close();
            Person.name = "Alex";
            FileInputStream in = new FileInputStream("foo.ser");
            ObjectInputStream s = new ObjectInputStream(in);
            Person p = (Person) s.readObject();
            System.out.println("name==" + Person.name + " age==" + p.getAge()
                    + " workDay==" + p.getWorkDay() + " fClub==" + p.getfClub());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}  

当然还有很多开源的序列化和反序列化的库，可以在实际的工程中进行使用。

版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

Java四种引用类型
纸上得来终觉浅，绝知此事要躬行
  --陆游    问渠那得清如许，为有源头活水来  --朱熹



Java从1.2版本开始引入了4种引用，这四种引用的级别由高到低依次为：强引用>软引用>弱引用>虚引用。


一、强引用（StrongReference）：
        强引用是使用最普遍的引用，一般我们将对象初始化之后就是一个强引用。当一个对象具有强引用时，JVM不会对它进行垃圾回收。当内存不足时，宁愿抛出OutofMemoryError，让程序异常终止，也不会回收强引用。
二、软引用（SoftReference）:
        如果一个对象是弱引用，如果内存足够就不会对它进行垃圾回收；如果内存空间不足了，就会回收这部分对象。只要垃圾回收器没有对它进行回收，那么程序就可以使用它。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
三、弱引用（WeakReference）：
        弱引用和软引用的区别在于弱引用拥有更短的生命周期。当垃圾回收器扫描内存区域时，只要发现弱引用就会对它进行回收。但由于垃圾回收器是一个优先级比较低的线程，因此不一定很快就会发现那些弱引用对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
四、虚引用（PhantomReference）：
        与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之
 关联的引用队列中。


示例代码：


强引用：

public class MyClass
{
    MyClass()
    {

    }
}
public class Test
{
    public static void main(String [] args)
    {
        MyClass myClass=new MyClass();
        System.gc();
    }
}

显式的调用了垃圾回收，但由于myClass是强引用，myClass没有被回收。


软引用：


public class MyClass
{
    MyClass()
    {

    }
}
public class Test
{
    public static void main(String [] args)
    {
        MyClass myClass=new MyClass();
        SoftReference ref=new SoftReference(myClass);
        System.gc();
    }
}

内存不足时软引用被回收。


弱引用：


public class MyClass
{
    MyClass()
    {

    }
}
public class Test
{
    public static void main(String [] args)
    {
        MyClass myClass=new MyClass();
        WeakReference ref=new WeakReference(myClass);
        System.gc();
    }
}


在JVM垃圾回收时，弱引用就会被回收。


虚引用：


public class MyClass
{
    MyClass()
    {

    }
}
public class Test
{
    public static void main(String [] args)
    {
        MyClass myClass=new MyClass();
        ReferenceQueue rq=new ReferenceQueue();
        PhantomReference pr=new PhantomReference(myClass,rq);
        System.gc();
    }
}

虚引用，被实例化之后就会被回收。


总结：





级别


什么时候被垃圾回收


用途


生存时间




强引用


从来不会


对象的一般状态


JVM停止运行时终止




软引用


在内存不足时


对象简单？缓存


内存不足时终止




弱引用


在垃圾回收时


对象缓存


gc运行后终止




虚引用


Unknown


Unknown


Unknown
 








版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

【LeetCode-面试算法经典-Java实现】【200-Number of Islands（岛的数目）】
【200-Number of Islands（岛的数目）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 
　　Example 1:
11110
11010
11000
00000
　　Answer: 1 
　　Example 2:
11000
11000
00100
00011
　　Answer: 3 

题目大意
　　给定的一个二维网格的地图（’1’（陆地）和0（水）），计数岛的数量。岛屿是四面环水，是由相邻的陆地水平或垂直连接而形成的。你可以假设该网格的所有四个边都被水包围。 

解题思路
　　一个网格，有一个相应的访问标记矩阵，对网格每个元素时行广度优先遍历（或者深度优先遍历），统计岛的数目 

代码实现
算法实现类
public class Solution {

    public int numIslands(char[][] grid) {
        // 参数校验
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        // 元素默认值是false
        boolean[][] visited = new boolean[grid.length][grid[0].length];

        int result = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                // 如果此位置没有被访问过，并且此位置是岛，就里德广度优先遍历
                if (!visited[i][j] && grid[i][j] == '1') {
                    result++;
                    bfs(grid, visited, i, j);
                }
            }
        }
        return result;
    }

    /**
     * 广度优先搜索
     * @param grid 网格
     * @param visited 访问标记矩阵
     * @param row 横坐标
     * @param col 纵坐标
     */
    private void bfs(char[][] grid, boolean[][] visited, int row, int col) {

        if (row >= 0 && row < grid.length // 行合法
                && col >= 0 && col < grid[0].length // 列合法
                && !visited[row][col] // 没有访问过
                && grid[row][col] == '1') { // 是岛上陆地

            // 标记此位置已经访问过了
            visited[row][col] = true;

            // 上
            bfs(grid, visited, row - 1, col);
            // 右
            bfs(grid, visited, row, col + 1);
            // 下
            bfs(grid, visited, row + 1, col);
            // 左
            bfs(grid, visited, row, col - 1);

        }
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47970795】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

vs2013 编译 x64 qt4.8.6
vs2013 直接qt4.8.6 x6位平台 的话 ，会有问题，需要一个patch文件patch 链接： http://download.csdn.net/detail/zhuyingqingfen/9048057如下图：可以手动把首行前面有减号的地方换成对应前面有加号的即可（或者patch -p0 < thispatch）下载Qt 4.8.6 版本 http://download.qt.io/archive/qt/4.8/4.8.6/qt-everywhere-opensource-src-4.8.6.zip打开vs2013的命令行工具 ，中文名称是： VS2013 x64 本机工具命令提示，对应的英文名称是："VS2013 x64 Native Tools Command Prompt"编译命令：configure -opensource -nomake demos -nomake examples -platform win32-msvc2013然后nmake 就ok了。

版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode-面试算法经典-Java实现】【198-House Robber（抢劫犯）】
【198-House Robber（抢劫犯）】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. 
　　Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 

题目大意
　　题目大意：你是一名专业强盗，计划沿着一条街打家劫舍。每间房屋都储存有一定数量的金钱，唯一能阻止你打劫的约束条件就是：由于房屋之间有安全系统相连，如果同一个晚上有两间相邻的房屋被闯入，它们就会自动联络警察，因此不可以打劫相邻的房屋。 

解题思路
　　给定一列非负整数，代表每间房屋的金钱数，计算出在不惊动警察的前提下一晚上最多可以打劫到的金钱数。 
　　解题思路：动态规划（Dynamic Programming） 
　　状态转移方程：dp[i] = max(dp[i - 2], dp[i - 3]) + num[i] 【A】 
　　其中，dp[i]表示打劫到第i间房屋时累计取得的金钱最大值。 
　　第 i 个位置的 max 值是由 max(i-2, i-3) 加上 i 位置的值决定，以此类推) 

代码实现
算法实现类
public class Solution {

    public int rob(int[] nums) {

        if (nums == null || nums.length == 0) {
            return 0;
        }

        // 如果数组中的元素个个数大于2个，对于【A】式，i=2，dp[2-3]不存在
        if (nums.length > 2) {
            nums[2] += nums[0];
        }

        // 从第四个元素开始处理
        int i = 3;
        for (; i < nums.length; i++) {
            // 求出第i个元素的最大值
            nums[i] += Math.max(nums[i - 2], nums[i - 3]);
        }

        // 如果只有一个元素，返回这个元素值
        if (nums.length == 1) {
            return nums[0];
        }
        // 有两个元素返回其中较大的值
        else if (nums.length == 2) {
            return Math.max(nums[0], nums[1]);
        }
        // 多于两个元素，最大值在末尾两个之间，找最大的返回
        else {
            return Math.max(nums[i - 1], nums[i - 2]);
        }
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47970775】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

木棒与三角形问题小结

木棒与三角形问题小结
木棒与三角形问题，一般都可以枚举最长边，用容斥来做

题型1：
求长度为l的木棒，截成3段，求能组成三角形的方法数(截的位置不同算不同的方法比如1 3 3和3 3 1算不同的方法)。

//方法一：
LL gao(int l){
	LL ret=0;
	for(int i=1;2*i<l;++i) {
		ret+=(l-1)/2-(l/2-i);
	}
	return ret;
}

//方法二：
//枚举最长边，用容斥来做
LL cal(LL a, LL remain) {
	if(a < remain) return 0;
	return remain - 1;
}

LL gao(LL l) {
	LL ret = (l - 1) * (l - 2) / 2;
	for(int i = 1; i < l; ++i) {
		ret -= 3 * cal(i, l - i);
	}
	return ret;
}


题型2：
给出3根木棒，长度分别为a, b, c，分别给它们一个增量a1, b1, c1，使得它们能构成一个三角形，且a1 + b1 + c1 == l，且a1, b1, c1 >= 0。问能构成三角形的方法数(增量不同算不同的方法)。限制：1 <= a, b, c <= 1e5; 0 <= l <= 1e5

LL cal(LL a, LL b, LL c, LL r) {
	if(a < b + c + r) return 0;
	return r + 1;
}

void gao(LL a, LL b, LL c, LL l) {
	LL ans = (l + 1) * (l + 2) / 2;
	for(int i = 0; i <= l; ++i) {
		ans -= cal(a + i, b, c, l - i);
		ans -= cal(b + i, a, c, l - i);
		ans -= cal(c + i, a, b, l - i);
	}
	cout<<ans<<endl;
}


题型3：
给出3根木棒，长度分别为a, b, c，分别给它们一个增量a1, b1, c1，使得它们能构成一个三角形，且a1 + b1 + c1 <= l，且a1, b1, c1 >= 0。问能构成三角形的方法数(增量不同算不同的方法)。限制：1 <= a, b, c <= 1e5; 0 <= l <= 1e5

LL cal(LL a, LL b, LL c, LL r) {
	if(a < b + c) return 0;
	LL tmp = min(r, a - (b + c));
	return (tmp + 1) * (tmp + 2) / 2;
}

void gao(LL a, LL b, LL c, LL l) {
	LL ans = (l + 1) * (l + 2) * (l + 3) / 6;

	for(int i = 0; i <= l; ++i) {
		ans -= cal(a + i, b, c, l - i);
		ans -= cal(b + i, a, c, l - i);
		ans -= cal(c + i, a, b, l - i);
	}
	cout<<ans<<endl;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Opencv 各种特征点提取和匹配
opencv 特征点的提取和匹配
1. 当中的数据结构
KeyPoint这数据结构中有如下数据结构：
class KeyPoint 
{               Point2f  pt;  //坐标 
             float  size; //特征点邻域直径 
             float  angle; //特征点的方向，值为[零,三百六十)，负值表示不使用 
             float  response; 
             int  octave; //特征点所在的图像金字塔的组 
             int  class_id; //用于聚类的id
angle：角度，表示关键点的方向，SIFT算法通过对关键点周围邻域进行梯度运算，求得该点方向。-1为初值。
class_id：当要对图片进行分类时，我们可以用class_id对每个特征点进行区分，未设定时为-1
octave：代表是从金字塔哪一层提取的得到的数据。
pt：关键点点的坐标（pt.x  pt.y）
response：响应程度，代表该点强壮大小。response代表着该关键点how good，更确切的说，是该点角点的程度。瞬间明白。
size：该点直径的大小
注意：keypoint只是保存了opencv的sift库检测到的特征点的一些基本信息，也就上面所说的这些，但sift所提取出来的特征向量其实不是在这个里面，特征向量通过SiftDescriptorExtractor 提取，结果放在一个Mat的数据结构中。新版的SIFT可以直接提取。
DMATCH 数据结构：
struct DMatch 
{              //三个构造函数 
    DMatch(): 
 queryIdx(-1),trainIdx(-1),imgIdx(-1),distance(std::numeric_limits::max()) {}
DMatch(int  _queryIdx, int  _trainIdx, float  _distance ) : 
queryIdx( _queryIdx),trainIdx( _trainIdx), imgIdx(-1),distance( _distance) {}
DMatch(int  _queryIdx, int  _trainIdx, int  _imgIdx, float  _distance ) :  
 queryIdx(_queryIdx), trainIdx( _trainIdx), imgIdx( _imgIdx),distance( _distance) {} 
          int queryIdx;  //此匹配对应的查询图像的特征描述子索引（输入图1） 
          int trainIdx;   //此匹配对应的训练(模板)图像的特征描述子索引（输入图2） 
          int imgIdx;    //训练图像的索引(若有多个) 
          float distance;  //两个特征向量之间的欧氏距离，越小表明匹配度越高。 
          booloperator < (const DMatch &m) const; 
};
2. 各种的特征点
#include <iostream>
#include "opencv2/opencv.hpp"
#include "opencv2/core/core.hpp"  
#include "opencv2/features2d/features2d.hpp"  
#include "opencv2/highgui/highgui.hpp"  
#include  "opencv2/legacy/legacy.hpp" // 暴力匹配的头文件
#include  "opencv2/nonfree/nonfree.hpp"
#include <iostream>  
#include <vector> 

#include "cv_import_static_lib.h"

using namespace std;
using namespace cv;

void main(){


    Mat img_1 = imread("E:\\3Dtestdata\\3.jpg");
    Mat img_2 = imread("E:\\3Dtestdata\\4.jpg");
    if (!img_1.data || !img_2.data)
    {
        cout << "error reading images " << endl;
        return ;
    }

    vector<KeyPoint> keyPoints_1, keyPoints_2;
    Mat descriptors_1, descriptors_2;

    /*-----------------SIFT featrue Point----------------
    SIFT sift;
    sift(img_1, Mat(), keyPoints_1, descriptors_1);
    sift(img_2, Mat(), keyPoints_2, descriptors_2);
    */

    /*-----------------SURF featrue Point----------------
    SURF surf;
    surf(img_1, Mat(), keyPoints_1, descriptors_1);
    surf(img_2, Mat(), keyPoints_2, descriptors_2); 
    //SurfDescriptorExtractor extrator;           // another surf sift operation 
    //extrator.compute(img_1, keyPoints_1, descriptors_1);
    //extrator.compute(img_2, keyPoints_2, descriptors_2);
    */

    //-----------------ORB featrue Point----------------
    ORB orb;   // float Feature, can not use FlannBase Match.
    orb(img_1, Mat(), keyPoints_1, descriptors_1);
    orb(img_2, Mat(), keyPoints_2, descriptors_2);


    /*-----------------ORB featrue Point----------------
    MSER mesr;
     */

    /*-----------------FAST featrue Point----------------
    FastFeatureDetector fast1(100);   // 检测的阈值为40  
    FastFeatureDetector fast2(100);

    fast1.detect(img_1, keyPoints_1);
    fast2.detect(img_2, keyPoints_2);
    //SurfDescriptorExtractor extrator;           // another surf sift operation 
    //extrator.compute(img_1, keyPoints_1, descriptors_1);
    //extrator.compute(img_2, keyPoints_2, descriptors_2);

    OrbDescriptorExtractor extrator;
    extrator.compute(img_1, keyPoints_1, descriptors_1);
    extrator.compute(img_2, keyPoints_2, descriptors_2);
    */


    BruteForceMatcher<HammingLUT> matcher;// orb 等float型的

    //FlannBasedMatcher matcher;   // 只能 对uchar的点进行匹配

    vector< DMatch > matches;

    matcher.match(descriptors_1, descriptors_2, matches);

    double max_dist = 0; double min_dist = 100;
    //-- Quick calculation of max and min distances between keypoints  
    for (int i = 0; i < descriptors_1.rows; i++)
    {
        double dist = matches[i].distance;
        if (dist < min_dist) min_dist = dist;
        if (dist > max_dist) max_dist = dist;
    }
    cout<<"-- Max dist :"<< max_dist<<endl;
    cout<<"-- Min dist :"<< min_dist<<endl;

    //-- Draw only "good" matches (i.e. whose distance is less than 0.6*max_dist )  
    //-- PS.- radiusMatch can also be used here.  
    vector< DMatch > good_matches;
    for (int i = 0; i < descriptors_1.rows; i++)
    {
        if (matches[i].distance < 0.6*max_dist)
        {
            good_matches.push_back(matches[i]);
        }
    }


    // vector<KeyPoint> m_LeftKey;
    // vector<KeyPoint> m_RightKey;
    // vector<DMatch> m_Matches;
    // 以上三个变量已经被计算出来，分别是提取的关键点及其匹配，下面直接计算F

    // 分配空间
    int ptCount = (int)matches.size();
    Mat p1(ptCount, 2, CV_32F);
    Mat p2(ptCount, 2, CV_32F);

    // 把Keypoint转换为Mat
    Point2f pt;
    for (int i = 0; i<ptCount; i++)
    {
        pt = keyPoints_1[matches[i].queryIdx].pt;
        p1.at<float>(i, 0) = pt.x;
        p1.at<float>(i, 1) = pt.y;

        pt = keyPoints_2[matches[i].trainIdx].pt;
        p2.at<float>(i, 0) = pt.x;
        p2.at<float>(i, 1) = pt.y;
    }


    // 用RANSAC方法计算 基本矩阵F
    Mat m_Fundamental;
    vector<uchar> m_RANSACStatus;

    m_Fundamental = findFundamentalMat(p1, p2, m_RANSACStatus, FM_RANSAC);//?????????????????

    // 计算野点个数
    int OutlinerCount = 0;
    for (int i = 0; i<ptCount; i++)
    {
        if (m_RANSACStatus[i] == 0) // 状态为0表示野点
        {
            OutlinerCount++;
        }
    }

    // 计算内点
    vector<Point2f> m_LeftInlier;
    vector<Point2f> m_RightInlier;
    vector<DMatch> m_InlierMatches;
    // 上面三个变量用于保存内点和匹配关系
    int InlinerCount = ptCount - OutlinerCount;
    m_InlierMatches.resize(InlinerCount);
    m_LeftInlier.resize(InlinerCount);
    m_RightInlier.resize(InlinerCount);
    InlinerCount = 0;
    for (int i = 0; i<ptCount; i++)
    {
        if (m_RANSACStatus[i] != 0)
        {
            m_LeftInlier[InlinerCount].x = p1.at<float>(i, 0);
            m_LeftInlier[InlinerCount].y = p1.at<float>(i, 1);
            m_RightInlier[InlinerCount].x = p2.at<float>(i, 0);
            m_RightInlier[InlinerCount].y = p2.at<float>(i, 1);
            m_InlierMatches[InlinerCount].queryIdx = InlinerCount;
            m_InlierMatches[InlinerCount].trainIdx = InlinerCount;
            InlinerCount++;
        }
    }

    // 把内点转换为drawMatches可以使用的格式
    vector<KeyPoint> key1(InlinerCount);
    vector<KeyPoint> key2(InlinerCount);
    KeyPoint::convert(m_LeftInlier, key1);
    KeyPoint::convert(m_RightInlier, key2);

    // 显示计算F过后的内点匹配
     //Mat m_matLeftImage;
     //Mat m_matRightImage;
    // 以上两个变量保存的是左右两幅图像
    Mat OutImage;
    drawMatches(img_1, key1, img_2, key2, m_InlierMatches, OutImage);

    //stereoRectifyUncalibrated();

    Mat img_matches;
    drawMatches(img_1, keyPoints_1, img_2, keyPoints_2,
    good_matches, img_matches, Scalar::all(-1), Scalar::all(-1),
    vector<char>(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);

    imwrite("FASTResult.jpg", img_matches);
    imshow("Match", img_matches);

    imwrite("FmatrixResult.jpg", OutImage);
    imshow("Match2", OutImage);
    waitKey(0);

    return;
}

做好匹配以后，对于以后的三维重建都很有帮助。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA - 10779 Collectors Problem(最大流)
题目大意：有N个人在收集贴纸。现在给出每个人所拥有的贴纸 
然后1这个想要得到更多种类的贴纸，所以他要拿他的贴纸去跟别人换，换的条件是1张交换1张，且你所交换的那张贴纸的种类对方没有，你想要得到的贴纸的种类对方至少有2张，问最后这个人能得到多少种贴纸
解题思路：一个超级源点，连接贴纸的种类，容量为1这个人所拥有的该种类的贴纸数量 
将所有贴纸的种类连接到超级汇点，容量为1 
在弄出N-1个点，代表另外的人，如果该贴纸的种类对方没有，那么连边，容量为1，因为只需要1张就够了(贴纸 –>人) 
如果该贴纸对方有至少两张，那么连边，容量为这个人的该贴纸的数量-1（至少要保留一张，人–>贴纸） 
然后跑最大流
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
#define N 1010
#define INF 0x3f3f3f3f

struct Edge{
    int from, to, cap, flow;
    Edge() {}
    Edge(int from, int to, int cap, int flow) : from(from), to(to), cap(cap), flow(flow) {}
};

struct Dinic{
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[N];
    bool vis[N];
    int d[N], cur[N];

    void init(int n) {
        this->n = n;
        for (int i = 0; i <= n; i++) {
            G[i].clear();
        }
        edges.clear();
    }

    void AddEdge(int from, int to, int cap) {
        edges.push_back(Edge(from, to, cap, 0));
        edges.push_back(Edge(to, from, 0, 0));
        int m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    } 

    bool BFS() {
        memset(vis, 0, sizeof(vis));
        queue<int> Q;
        Q.push(s);
        vis[s] = 1;
        d[s] = 0;

        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for (int i = 0; i < G[u].size(); i++) {
                Edge &e = edges[G[u][i]];
                if (!vis[e.to] && e.cap > e.flow) {
                    vis[e.to] = true;
                    d[e.to] = d[u] + 1;
                    Q.push(e.to);
                }
            }
        }
        return vis[t];
    }

    int DFS(int x, int a) {
        if (x == t || a == 0)
            return a;

        int flow = 0, f;
        for (int i = cur[x]; i < G[x].size(); i++) {
            Edge &e = edges[G[x][i]];
            if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0) {
                e.flow += f;
                edges[G[x][i] ^ 1].flow -= f;
                flow += f;
                a -= f;
                if (a == 0)
                    break;
            }
        }
        return flow;
    }

    int Maxflow(int s, int t) {
        this->s = s; this->t = t;
        int flow = 0;
        while (BFS()) {
            memset(cur, 0, sizeof(cur));
            flow += DFS(s, INF);
        }
        return flow;
    }
};

Dinic dinic;
int n, m, source, sink, cas = 1;
int num[15][30];

void init() {
    scanf("%d%d", &n, &m);
    memset(num, 0, sizeof(num));
    source = 0; sink = n + m;

    int x, y;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &x);
        for (int j = 1; j <= x; j++) {
            scanf("%d", &y);
            num[i][y]++;
        }
    }

    dinic.init(sink);
    for (int j = 1; j <= m; j++) {
        dinic.AddEdge(source, j, num[1][j]);
        dinic.AddEdge(j, sink, 1);
    }

    for (int i = 2; i <= n; i++) 
        for (int j = 1; j <= m; j++) {
            if (num[i][j] > 1) dinic.AddEdge(m + i - 1, j, num[i][j] - 1);
            if (!num[i][j]) dinic.AddEdge(j, m + i - 1, 1);
        }

    int ans = dinic.Maxflow(source, sink);
    printf("Case #%d: %d\n", cas++, ans);
}

int main() {
    int test;
    scanf("%d", &test);
    while (test--) {
        init();
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Objective-C 【点语法】

———————————————————————————————————————————
点语法的使用

//
//  点语法的使用
//
//  点语法:   xcode的一种特性，xcode帮我们做代码替换
//  点语法的格式:   对象.属性名
//

一段代码：

#import <Foundation/Foundation.h>

@interface Person : NSObject
{
    NSString *_name;
    int _age;
}
-(void)setName:(NSString *)name;
-(NSString *)name;

-(void)setAge:(int)age;
-(int)age;
@end

#import "Person.h"

@implementation Person
-(void)setName:(NSString *)name
{
    NSLog(@"这是name的set方法！");
    _name=name;
}
-(NSString *)name
{
    NSLog(@"这是name的get方法！");
    return _name;
}

-(void)setAge:(int)age
{
    NSLog(@"这是age的set方法！");
    _age=age;
}
-(int)age
{
    NSLog(@"这是age的get方法！");
    return _age;
}
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Person *p=[Person new];
//        先用普通的方法去调用set和get方法，我们在set和get方法中加入了一行输出语句，来判断是否被调用
//        [p setName:@"Wang"];
//        [p setAge:18];
//        
//        [p name];
//        [p age];
        
//        再使用点方法
//        p.name=@"Wang";
//        p.age=18;
//        
//        NSString *a=p.name;
//        int b=p.age;
//        显然点方法也同样的调用了set和get方法，和上面的语句作用是一致的
//        但是，需要注意的是，此时的点方法（p.age和p.age=18）并不是直接访问实例变量，并不是看到p.age=18;就是给age赋值，而是Xcode看到点语法的语句后，自动帮我们替换成:
//        p.age=18; ————替换成————> [p setAge:18];
//        p.age; ————替换成————> [p age];

//        那么问题来了，我们调用set方法和get方法的点语法十分的相似，都是p.age，那么系统是怎么区分的呢？
//        显然，系统有自己的区分机制。一般而言，p.age出现在等号左侧就代表替换成set方法，p.age出现在等号右侧就替换成get方法。
//        当然这是一般情况，如果是 NSLog(@"%d",p.age); 的话，没有等号，怎么办呢？所以，其真正的原理是：如果 设置值（写），那么就替换成set方法；如果 取值（读），那么就替换成get方法。
    }
    return 0;
}


———————————————————————————————————————————
点语法的注意事项

注意：

①我们可以看到，上一段我们介绍的点语法，都是   实例对象名.属性名   的形式去调用的。
那么看下面的一段代码：

-(void)setAge:(int)age
{     self.age=age;
}

★self表示当前对象，然后用当前对象调用点语法，去写这个set方法，这样显然是错误的！！！

上面的代码相当于：

-(void)setAge:(int)age
{
    [self setAge:age];   //死循环
}

★我们一定要记住，点语法不是直接去访问实例变量，而是Xcode的一种替换代码的手段，本质上是方法的调用，使用点语法的时候，编译器会自动将点语法展开成相应的set、get方法。上面是一个设置值的语句，所以点语法表示的是调用set方法。这样说来，你在set方法里面再调用set方法，不就是死循环了么！！！

②还是强调一下点语法的本质，点语法的本质是转换成相应的set、get方法，如果没有set、get方法，这不能使用点语法。所以使用点语法之前要先写set/get方法。


———————————————————————————————————————————


版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu5399  Too Simple（函数映射）
题目：

Too Simple
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 1042    Accepted Submission(s): 355


Problem Description
Rhason Cheung had a simple problem, and asked Teacher Mai for help. But Teacher Mai thought this problem was too simple, sometimes naive. So she ask you for help.

Teacher Mai has m
 functions f1,f2,⋯,fm:{1,2,⋯,n}→{1,2,⋯,n}(that
 means for all x∈{1,2,⋯,n},f(x)∈{1,2,⋯,n}).
 But Rhason only knows some of these functions, and others are unknown.

She wants to know how many different function series 
f1,f2,⋯,fm
 there are that for every i(1≤i≤n),f1(f2(⋯fm(i)))=i.
 Two function series f1,f2,⋯,fm
 and g1,g2,⋯,gm
 are considered different if and only if there exist 
i(1≤i≤m),j(1≤j≤n),fi(j)≠gi(j).

 

Input
For each test case, the first lines contains two numbers
n,m(1≤n,m≤100).

The following are m
 lines. In i-th
 line, there is one number −1
 or n
 space-separated numbers.

If there is only one number −1,
 the function fi
 is unknown. Otherwise the j-th
 number in the i-th
 line means fi(j).

 

Output
For each test case print the answer modulo 
109+7.

 

Sample Input

3 3
1 2 3
-1
3 2 1

 

Sample Output

1
HintThe order in the function series is determined. What she can do is to assign the values to the unknown functions. 

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9

 

Recommend
wange2014
 



题意：有m个函数，每个函数的定义域和值域都是｛1，2。。。。n｝，有一些函数是已知的，有一些函数是未知的，求满足f1（f2(...(fm(i)))）=i的函数序列有多少个。


思路：如果不存在未知函数，那么我们直接模拟这m个函数的求值，看对于每一个i最后求出来是否等于i；如果存在未知函数，我们先来证明一下如果某个已知的函数的值域不取完1到n，那么不存在函数序列满足题意。
证明：假设Fj的值域不取完1到n，那么存在p和q，使得Fj（p）==Fj（q），于是对于Fj外层的函数而言，也存在两个不同的值， 映射为同一值，不满足函数序列的定义，证毕。


所以我们先检查一下每个已知的函数的值域是否取完1到n，没取完结果就为0，如果取完了那证明一定有解，假设有x个未知函数，那么我们的x-1个未知函数可以任意取值，剩下的那个未知函数取固定的值使得满足映射条件即可，答案为(N!)^(X-1)


代码：


#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include<climits>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <fstream>
#include <numeric>
#include <iomanip>
#include <bitset>
#include <list>
#include <stdexcept>
#include <functional>
#include <utility>
#include <ctime>
using namespace std;

#define PB push_back
#define MP make_pair

#define REP(i,x,n) for(int i=x;i<(n);++i)
#define FOR(i,l,h) for(int i=(l);i<=(h);++i)
#define FORD(i,h,l) for(int i=(h);i>=(l);--i)
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define OI(X) printf("%d",X);
#define RS(X) scanf("%s", (X))
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
#define Swap(a, b) (a ^= b, b ^= a, a ^= b)
#define Dpoint  strcut node{int x,y}
#define cmpd int cmp(const int &a,const int &b){return a>b;}

 /*#ifdef HOME
    freopen("in.txt","r",stdin);
    #endif*/
const int MOD = 1e9+7;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef long long LL;
typedef pair<int,int> PII;
//#define HOME

int Scan()
{
	int res = 0, ch, flag = 0;

	if((ch = getchar()) == '-')				//判断正负
		flag = 1;

	else if(ch >= '0' && ch <= '9')			//得到完整的数
		res = ch - '0';
	while((ch = getchar()) >= '0' && ch <= '9' )
		res = res * 10 + ch - '0';

	return flag ? -res : res;
}
/*----------------PLEASE-----DO-----NOT-----HACK-----ME--------------------*/


const int mod=1e9+7;
int f[105][105];
long long int fact[105];
int main()
{
int n,m;
fact[0]=1;
for(int i=1;i<=100;i++)
    fact[i]=(fact[i-1]*(long long )i)%mod;
while(RII(n,m)!=EOF)
{   int x=0;
    for(int i=0;i<m;i++)
    {scanf("%d",&f[i][1]);
    if(f[i][1]==-1)
        x++;
    else
    {
        for(int j=2;j<=n;j++)
            RI(f[i][j]);
    }
    }
    if(x==0)
    {
        int ans[105];
        for(int i=1;i<=n;i++)
            ans[i]=i;
        for(int i=m-1;i>=0;i--)
        {
            for(int j=1;j<=n;j++)
            ans[j]=f[i][ans[j]];
        }
        int ok=1;
        for(int i=1;i<=n;i++)
            if(ans[i]!=i)
            {
                ok=0;
                break;
            }
        if(!ok)
        {
            printf("0\n");
            continue;
        }
        else
        {
            printf("1\n");
        }
    }
    else
    {   int vis[105];
        int ok=1;
        for(int i=0;i<m;i++)
        {
            if(f[i][1]==-1)
                continue;
            MS0(vis);
            for(int j=1;j<=n;j++)
            {
                vis[f[i][j]]=1;
            }
            //int ok=1;
            for(int j=1;j<=n;j++)
                if(!vis[j])
            {
                ok=0;
                break;
            }
            if(!ok)
            {
                printf("0\n");
                break;
            }
        }
        if(!ok)
            continue;
       long long int ans=1;
       for(int i=1;i<x;i++)
        ans=(fact[n]*ans)%mod;
       printf("%I64d\n",ans);


    }
}


        return 0;
}


f1(f2(⋯fm(i)))=i

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU5396 Expressions(区间DP)
题目：


欢迎参加——每周六晚的BestCoder（有米！）

Expression
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 511    Accepted Submission(s): 300


Problem Description
Teacher Mai has n numbers
a_1,a_2,\cdots,a_nand 
n-1 operators("+", "-" or "*")op_1,op_2,\cdots,op_{n-1}, which are arranged in the form
a_1~op_1~a_2~op_2~a_3~\cdots~a_n.

He wants to erase numbers one by one. In i-th round, there are
n+1-i numbers remained. He can erase two adjacent numbers and the operator between them, and then put a new number (derived from this one operation) in this position. After
n-1 rounds, there is the only one number remained. The result of this sequence of operations is the last number remained.


He wants to know the sum of results of all different sequences of operations. Two sequences of operations are considered different if and only if in one round he chooses different numbers.

For example, a possible sequence of operations for "1+4*6-8*3" is
1+4*6-8*3\to 1+4*(-2)*3\to 1+(-8)*3\to (-7)*3\to -21.

 

Input
There are multiple test cases.

For each test case, the first line contains one number 
n(2\leq n\leq 100).

The second line contains n integers 
a_1,a_2,\cdots,a_n(0\leq a_i\leq 10^9).

The third line contains a string with length n-1 consisting "+","-" and "*", which represents the operator sequence.

 

Output
For each test case print the answer modulo 
10^9+7.

 

Sample Input

3
3 2 1
-+
5
1 4 6 8 3
+*-*

 

Sample Output

2
999999689
Hint Two numbers are considered different when they are in different positions.
 

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9

 

Recommend
wange2014



题意：给n个数字n-1个操作，问所有的操作序列能够得到的表达式的值的和是多少


思路：区间DP，设dp[i][j]为i到j能够得到的所有表达式的和，枚举进行的操作，那么对于乘法操作，假设在位置k，那么由于乘法有分配律，我们把dp【i】【k】和dp【k+1】【j】乘起来就得到左边的所有表达式的和乘以右边的所有表达式的和的结果。（a1+a2+。。+ai）*（b1+b2+。。+bj）=a1*b1+a1*b2+。。。；对于加法操作，左边的每个表达式实际上要跟右边加A【j-k-1】次（A为排列，因为右边有j-k-1个操作），同理右边的每个表达式要跟左边加A【k-i】次；减法操作跟加法同理。得到的结果还要再乘上C[j-i][k-s]，因为左右两边的顺序没有确定。


代码
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include<climits>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <fstream>
#include <numeric>
#include <iomanip>
#include <bitset>
#include <list>
#include <stdexcept>
#include <functional>
#include <utility>
#include <ctime>
using namespace std;

#define PB push_back
#define MP make_pair

#define REP(i,x,n) for(int i=x;i<(n);++i)
#define FOR(i,l,h) for(int i=(l);i<=(h);++i)
#define FORD(i,h,l) for(int i=(h);i>=(l);--i)
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define OI(X) printf("%d",X);
#define RS(X) scanf("%s", (X))
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
#define Swap(a, b) (a ^= b, b ^= a, a ^= b)
#define Dpoint  strcut node{int x,y}
#define cmpd int cmp(const int &a,const int &b){return a>b;}

 /*#ifdef HOME
    freopen("in.txt","r",stdin);
    #endif*/
const int MOD = 1e9+7;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef long long LL;
typedef pair<int,int> PII;
//#define HOME

int Scan()
{
	int res = 0, ch, flag = 0;

	if((ch = getchar()) == '-')				//判断正负
		flag = 1;

	else if(ch >= '0' && ch <= '9')			//得到完整的数
		res = ch - '0';
	while((ch = getchar()) >= '0' && ch <= '9' )
		res = res * 10 + ch - '0';

	return flag ? -res : res;
}
/*--o--------------PLEASE-----DO-----NOT-----HACK-----ME--------------------*/


const int mod=1e9+7;
int a[105];
char op[105];
long long int dp[105][105];
long long int fact[105];
long long int c[105][105];
int main()
{int n;
fact[0]=1;
for(int i=1;i<=100;i++)
fact[i]=(fact[i-1]*i)%mod;
c[0][0]=1;
for(int i=0;i<=100;i++)
{
for(int j=0;j<=i;j++)
if(j==0||i==j)
    c[i][j]=1;
else
c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
}
while(RI(n)!=EOF)
{
    for(int i=0;i<n;i++)
        RI(a[i]);
    scanf("%s",op);
   MS0(dp);
    for(int i=0;i<n;i++)
        dp[i][i]=a[i];
    for(int len=2;len<=n;len++)
        for(int s=0;s+len-1<n;s++)
        {for(int k=s;k<s+len-1;k++)
    {   long long tmp;
        if(op[k]=='*')
        tmp=(dp[s][k]*dp[k+1][s+len-1])%mod;
        else
        if(op[k]=='+')
        tmp=(dp[s][k]*fact[s+len-2-k]+dp[k+1][s+len-1]*fact[k-s])%mod;
        else
        tmp=(dp[s][k]*fact[s+len-2-k]-dp[k+1][s+len-1]*fact[k-s])%mod;
        tmp=(tmp+mod)%mod;
        dp[s][s+len-1]=((dp[s][s+len-1]+tmp*c[len-2][k-s])%mod+mod)%mod;
    }

        }
printf("%I64d\n",dp[0][n-1]);

}



        return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

【LeetCode-面试算法经典-Java实现】【199-Binary Tree Right Side View（从右边看二叉树）】
【199-Binary Tree Right Side View（从右边看二叉树】

【LeetCode-面试算法经典-Java实现】【所有题目目录索引】

代码下载【https://github.com/Wang-Jun-Chao】
原题
　　Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. 
　　For example: 
　　Given the following binary tree,
   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
　　You should return [1, 3, 4]. 

题目大意
　　给定一个二叉树，想象自己站在树的右边，返回从下到下你能看到的节点的值。 

解题思路
　　二叉树的层次遍历，每层按照从左向右的顺序依次访问节点，（每一层取最右边的结点） 

代码实现
树结点类
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}
算法实现类
public class Solution {

    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new LinkedList<>();

        if (root != null) {
            Deque<TreeNode> deque = new LinkedList<>();
            // 当前层的结点数
            int current = 1;
            // 下一层的结点数
            int next = 0;
            TreeNode node;
            deque.addLast(root);
            while (deque.size() > 0) {
                // 取第一个结点
                node = deque.removeFirst();
                current--;

                // 添加非空的左结点
                if (node.left != null) {
                    next++;
                    deque.addLast(node.left);
                }

                // 添加非空的右结点
                if (node.right != null) {
                    next++;
                    deque.addLast(node.right);
                }

                // 如果当前层已经处理完了
                if (current == 0) {
                    // 保存此层的最右一个结点值
                    result.add(node.val);
                    // 设置下一层的元素个数
                    current = next;
                    next = 0;
                }
            }
        }

        return result;
    }
}
评测结果
　　点击图片，鼠标不释放，拖动一段位置，释放后在新的窗口中查看完整图片。

特别说明
欢迎转载，转载请注明出处【http://blog.csdn.net/derrantcm/article/details/47970785】

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java泛型
纸上得来终觉浅，绝知此事要躬行
  --陆游       问渠那得清如许，为有源头活水来  --朱熹



泛型是JDK1.5中最重要的特征，通过引入泛型，我们将获得编译时类型的安全和运行时更小的抛出ClassCastException的可能。泛型用的最多的地方是集合。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。
表面上看起来，无论语法还是应用的环境（比如容器类），泛型类型（或者泛型）都类似于 C++ 中的模板。但是这种相似性仅限于表面，Java 语言中的泛型基本上完全在编译器中实现，由编译器执行类型检查和类型推断，然后生成普通的非泛型的字节码。这种实现技术称为 擦除（erasure）（编译器使用泛型类型信息保证类型安全，然后在生成字节码之前将其清除），这项技术有一些奇怪，并且有时会带来一些令人迷惑的后果。虽然范型是
 Java 类走向类型安全的一大步，但是在学习使用泛型的过程中几乎肯定会遇到头痛（有时候让人无法忍受）的问题。
（1）所谓泛型，就是变量类型的参数化
（2）尖括号中包含的时形式类型参数，当类被使用时再使用具体的类型参数
（3）不能用new来创建泛型数组，实现的方式是object []  test
（4）继承泛型类和实现泛型接口时，需要带有原来的类型



Java泛型类的示例：
public class Test<T>
{
    //T作为数据类型
}
在实例化该类时，必须指明泛型T的具体类型，例如：Test<Object> t = new Test<Object>();，指明泛型T的类型为Object。



最简单的泛型类示例：

public class GenericTest {

    public static void main(String[] args) {

        Box<String> name = new Box<String>("corn");
        System.out.println("name:" + name.getData());
        Box<Integer> number=new Box<Integer>(20);
        System.out.println("number:"+number.getData());
    }

}
class Box<T>   //引入一个类型变量T，用<>括起来，并放在类名的后面，同时泛型类可以有多个类型变量。
{
    private T data;
    public Box() {

    }
    public Box(T data) {
        this.data = data;
    }
    public T getData() {
        return data;
    }
} 
泛型接口的示例：

interface Show<T,U>{
    void show(T t,U u);
}

class ShowTest implements Show<String,Date>{
    @Override
    public void show(String str,Date date) {
        System.out.println(str);
        System.out.println(date);
    }
}
泛型方法的示例：


public static void main(String[] args) throws ClassNotFoundException {
    String str=get("Hello", "World");
    System.out.println(str);
}

public static <T, U> T get(T t, U u) {
    if (u != null)
        return t;
    else
        return null;
}  




版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

Suffix Array 后缀数组
后缀数组

顾名思义，SuffixArray(以下有时简称SA) 和字符串的后缀有关。

后缀:字符串中某个位置一直到结尾的子串。(SA中讨论包括了原串和空串)，所以共有len+1个后缀。

后缀数组: 字符串的所有后缀组成的按字典序从小到大排好的数组。由于SA中记录的都是字符串的后缀，所以SA只需要记录其表示的后缀的起始位置。

由于比较字典序是O(n)的，所以暴力算法的复杂度将是O(n^2logn)。通过一些算法可以降到线性复杂度。这里先介绍一种简单的O(nlognlogn)的算法。


该算法的思想是通过倍增法降低了比较字典序的大小的复杂度O(n)到O(logn)。其求解时不先算后缀，而是先算长度为1的子串的字典序大小排列，然后得到一个rank数组，即该子串在所有子串中排位的值。字典序越小，rank值越小。


rank[k][i] 表示起始位置为i的长度为k的子串在所有长度为k的子串中的字典序大小。


这时我们要比较长度为2k的子串的大小的话，其第i个位置的长度为2k的子串的大小可以通过比较rank[k][i]和rank[k][i+k]来实现。



SA中的sa[i]表示字典序位i的后缀串的起始位置。


const int MAXN = 100000 + 5;
int _k, _len;
int _rank[MAXN];
int _tmp[MAXN];
int _sa[MAXN];// 后缀数组。

bool _cmp(int i, int j) {
    if (_rank[i] == _rank[j]) {
        int _ri = (i+_k <= _len) ? _rank[i+_k] : -1;
        int _rj = (j+_k <= _len) ? _rank[j+_k] : -1;
        return _ri < _rj;
    } else {
        return _rank[i] < _rank[j];
    }
}

void Suffix_sa(string s, int* sa) {
    _len = s.size();

    for (int i=0; i<_len; i++) {
        sa[i] = i;
        _rank[i] = s[i];
    }
    sa[_len] = _len;
    _rank[_len] = -1;

    for ( _k=1; _k<=_len; _k<<=1) {
        sort(sa, sa+_len+1, _cmp);

        _tmp[sa[0]] = 0;

        for (int i=1; i<=_len; i++) {
            _tmp[sa[i]] = _tmp[sa[i-1]];
            if (_cmp(sa[i-1], sa[i])) {
                _tmp[sa[i]]++;
            }
        }

        copy(_tmp, _tmp+_len+1, _rank);
    }
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

Cube Stacking  POJ1988 【并查集的应用】
http://poj.org/problem?id=1988


Description

Farmer John and Betsy are playing a game with N (1 <= N <= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1<= P <= 100,000) operation. There are two types of operations: 
moves and counts. 
* In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y. 
* In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value. 

Write a program that can verify the results of the game. 

Input

* Line 1: A single integer, P 

* Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a 'M' for a move operation or a 'C' for a count operation. For move operations, the line also contains two integers: X and Y.For
 count operations, the line also contains a single integer: X. 

Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself. 

Output

Print the output from each of the count operations in the same order as the input file. 

Sample Input
6
M 1 6
C 1
M 2 4
M 2 6
C 3
C 4

Sample Output
1
0
2

求出任何一个节点的下属的个数
/*
带权并查集，一堆中最顶上的方块作为父节点，用dis[X] 统计X到父亲节点的距离，num[fa[X]]表示团的大小，两者相减即为答案
*/
#include <stdio.h>
#include <string.h>
#define N 30000+100//结点个数
int num[N];//记录这个团队的人数
int dis[N];//记录有个点到根节点的距离
int per[N];//表示父节点

void init()
{
    for(int i=0;i<N;++i)
    {
        num[i]=1;
        dis[i]=0;
        per[i]=i;
    }
}

int find(int x)
{
    if(x==per[x]) return x;
    int t=per[x];
    per[x]=find(per[x]);
    dis[x]+=dis[t];//当查找一个数时，
    return per[x];
}

void join(int x,int y)
{
    int fx=find(x);
    int fy=find(y);
    if(fx!=fy)
    {
        per[fy]=fx;
        dis[fy]=num[fx];
        num[fx]+=num[fy];
    }
}
int main()
{
    int n;
    int a,b;
    char ch;
    while(~scanf("%d",&n))
    {
        init();
        while(n--)
        {
            getchar();
            scanf("%c",&ch);
            if(ch=='M')
            {
                scanf("%d%d",&a,&b);
                join(a,b);
            }
            else if(ch=='C')
            {
                scanf("%d",&a);
                int x=find(a);
                printf("%d\n",num[x]-dis[a]-1);
            }
        }
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5288 OO’s Sequence (2015 MUT#1 数学+质因子分解)
【题目链接】：click here~~
【题目大意】：给定区间内【l=<i<=r】【l=<j<=r,j<>i】，求与i互质的j的i的个数。
eg:
5
1 2 3 4 5
一个有5*6/2=15个区间即15个f[l,r]
【1,1】 【1,2】 【1,3】 【1,4】【1,5】
【2,2】 【2,3】 【2,4】【2,5】
【3,3】 【3,4】【3,5】
【4,4】【4,5】
【5,5】
设总数为sum
对于区间【1,1】 其中当i=1时，左右没有数被他整除，所以 sum++；
对于区间【2,2】其中当i=1时，左右没有数被他整除，所以sum++；
其中当i=2时，左边的数a[1]被他整除,所以sum不变
对于区间【3,5】，其中i=3,4,5时左右的数都不能被整除，所以sum+=3；
其他区间同理可得

【思路】：由上可转化为，以a[i](1<=i<=n)为被除数的所有符合的条件的区间数的和，那么只要逐个算出从1到n的所有以a[i]为被除数的区间的总数即可(对于样例，
以a[1]为被除数的区间有[1,1],[1,2],[1,3],[1,4],[1,5],
以a[2]为被除数的区间有[2,2],[2,3],[2,4],[2,5]
以a[3]为被除数的区间有[2,3],[2,4],[2,5],[3,3],[3,4],[3,5]
以a[4]为被除数的区间有[3,4],[3,5],[4,4],[4,5],
以a[5]为被除数的区间有[2,5],[3,5],[4,5],[5,5]
)
然后对于每个i对应以a[i]为被除数的区间的个数可以转换为a[i]左边离他最近的位置（设为l[i]）距离i、的距离乘以a[i]右边离他最近的位置（设为r[i]）到i的距离，即(i-l[i])*(r[i]-i)

代码：
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
const int MOD=1e9+7;
typedef long long LL;
int arr[N],t,n,m,tmp;
int ll[N],rr[N];
vector <int> val[N];
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        for(int i=101; i<=10000; ++i) val[i].clear(); //预处理l和r以及把大于100的数的下标放入v容器
        for(int i=1; i<=n; ++i)
        {
            ll[i]=0;rr[i]=n+1;
            scanf("%d",&arr[i]);
            if(arr[i]>100)
               val[arr[i]].push_back(i);
        }

        for(int i=1; i<=100; ++i) //更新[n个数中能被100以内的数整除的l]使得该a[l]（0<a[l]<=100）成为位于a[j]左边离a[j]最近的
        {
            int maxl=0;
            for(int j=1; j<=n; ++j)
            {
                if(arr[j]%i==0) ll[j]=max(maxl,ll[j]);
                if(arr[j]==i) maxl=j;
            }
        }

        for(int i=1; i<=100; ++i)  //更新[n个数中能被100以内的数整除的r]使得该a[r]（0<a[r]<=100）成为位于a[j]右边离a[j]最近的
        {
            int minr=n+1;
            for(int j=n; j>=1; --j)
            {
                if(arr[j]%i==0) rr[j]=min(minr,rr[j]);
                if(arr[j]==i) minr=j;
            }
        }

        for(int i=1; i<=n; ++i) //对于从左往右依次出现的a[j]依次更新是a[j]倍数的数的l
        {
            if(arr[i]>100)
            for(int j=arr[i]; j<=10000; j+=arr[i])
            {
                for(int k=val[j].size()-1; k>=0; --k)
                {
                    if(val[j][k]<=i) break;
                    else ll[val[j][k]]=max(i,ll[val[j][k]]);
                }
            }
        }

        for(int i=1; i<=n; ++i)  //对于从左往右依次出现的a[j]依次更新是a[j]倍数的数的r
        {
            if(arr[i]>100)
            for(int j=arr[i]; j<=10000; j+=arr[i])
            {
                for(int k=0; k<val[j].size(); ++k)
                {
                    if(val[j][k]>=i) break;
                    else rr[val[j][k]]=min(i,rr[val[j][k]]);

                }
            }
        }
        LL ans=0;
        for(int i=1; i<=n; ++i)
        {
            ans+=((i-ll[i])*(rr[i]-i)%MOD);
        }
        printf("%I64d\n",ans);
    } return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

【递推】【高精度】【FJOI 2007】【bzoj 1002】轮状病毒
1002: [FJOI2007]轮状病毒
Time Limit: 1 Sec  Memory Limit: 162 MB
Submit: 3238  Solved: 1797

Description
给定n(N<=100)，编程计算有多少个不同的n轮状病毒。 

Input
第一行有1个正整数n。
Output
将编程计算出的不同的n轮状病毒数输出
Sample Input
3

Sample Output
16

题解：
递推。 
打表可以找规律得，f[i]=3*f[i-1]-f[i-2]+2，但是需要高精度。。 
还可以找更神奇的规律，和卢卡斯数列相关——>这里是卢卡斯数列相关的做法——by Vampire
Code：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

int n,f[110][110];

void jia(int x,int y){
    f[x][1]+=y;
    for (int i=1; i<=f[x][0]; i++)
        if (f[x][i]>9)
            f[x][i+1]+=f[x][i]/10,f[x][i]%=10;
    if (f[x][f[x][0]+1]) f[x][0]++;
}
void jian(int x,int y){
    int c[110];
    for (int i=0; i<=f[x][0]; i++) c[i]=f[x][i];
    for (int i=1; i<=f[y][0]; i++){
        if (c[i]<0) c[i+1]--,c[i]+=10;
        int s=c[i]-f[y][i];
        if (s<0) c[i+1]--,s+=10;
        c[i]=s;
    }
    for (int i=f[y][0]+1; i<=c[0]; i++)
        if (c[i]<0) c[i+1]--,c[i]+=10;
    while (!c[c[0]]) c[0]--;
    for (int i=0; i<=c[0]; i++) f[x][i]=c[i];
}
void cheng(int x,int y,int z){
    int c[110]; f[x][0]=f[y][0];
    for (int i=0; i<=f[y][0]; i++) c[i]=f[y][i];
    for (int i=1; i<=c[0]; i++){
        c[i]*=z;
        if (c[i]>9)
            f[x][i+1]+=c[i]/10,c[i]%=10;
        f[x][i]+=c[i];
    }
    if (f[x][f[x][0]+1]) f[x][0]++;
}

void dp(){
    memset(f,0,sizeof(f));
    f[1][++f[1][0]]=1,f[2][++f[2][0]]=5;
    for (int i=3; i<=n; i++)
        cheng(i,i-1,3),jian(i,i-2),jia(i,2);
}

void out(){
    for (int i=f[n][0]; i>=1; i--)
        printf("%d",f[n][i]);
    printf("\n");
}

int main(){
    scanf("%d",&n);

    dp(); out();

    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java 类加载机制 ClassLoder
纸上得来终觉浅，绝知此事要躬行
  --陆游       问渠那得清如许，为有源头活水来  --朱熹



一个类从被加载到内存中开始到卸载出内存为止，它的整个生命周期包括了：加载（loading）、验证（Verification）、准备（Preparetation）、解析（Resolution）、
初始化（Initialization）、使用（Using）、卸载（Uploading）七个阶段。其中验证’准备和解析称为链接。






一、ClassLoader类加载的架构



 1）、Bootstrap Classloader启动类加载器，主要负责java_home/lib下的核心api或者-Xbootstrap选项指定的jar包装入工作。
 2）、Extension ClassLoader扩展类加载器，主要负责java_home/lib/ext下jar包
 3）、App CLassLoader 系统类加载器，主要负责Java -classpath/所指的目录下的类与jar包的装入工作；
 4）、 UserCustom ClassLoader用户自定义类加载器，在程序运行期间，通过Java.lang.Classloader的子类动态加载class


二、类加载的特性
1）、每一个ClassLoader都会维护一个自己的命名空间，同一个命名空间不能出现两个相同的类名
2）、为了实现java安全沙箱模型顶层的类加载器安全机制, java默认采用了 " 双亲委派的加载链 " 结构。


三、类的加载方式有三种：
1）、命令行启动应用时由JVM初始化加载。
2）、通过class.forName()方法动态加载。
3）、通过ClassLoader（）.loadClass()方法动态加载。
这三种加载方式对静态代码块的执行有影响。
如下例子：

public class MyHello {
    static
    {
        System.out.println("hello word");
    }
}

public class Hello {

    public static void main(String[] args) {
        ClassLoader loader=Hello.class.getClassLoader();
        try {
            //静态代码块不运行
            //loader.loadClass("Test.MyHello");

            //静态代码块运行输出hello world
            //Class.forName("Test.MyHello");

            //静态代码块不运行
            //Class.forName("Test.MyHello", false, loader);

            //静态代码块运行输出hello world
            Class.forName("Test.MyHello", true, loader);

        } catch (ClassNotFoundException e) {
            // TODO 自动生成的 catch 块
            e.printStackTrace();
        }
    }
}




一、ClassLoader类加载的架构



 1）、Bootstrap Classloader启动类加载器，主要负责java_home/lib下的核心api或者-Xbootstrap选项指定的jar包装入工作。
 2）、Extension ClassLoader扩展类加载器，主要负责java_home/lib/ext下jar包
 3）、App CLassLoader 系统类加载器，主要负责Java -classpath/所指的目录下的类与jar包的装入工作；
 4）、 UserCustom ClassLoader用户自定义类加载器，在程序运行期间，通过Java.lang.Classloader的子类动态加载class



版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

HDU 5093 Battle ships（二分图匹配）
该题是一道经典的二分图匹配题目 。  同一列（行）上不能放两个船除非有冰山隔着。对于这种二维平面图，我们很容易想到将行和列分成两个集合，进行二分图匹配，当一个行坐标匹配到一个列坐标时，该格子可以放置船。那么为了使任意两个船都不在同一行或者同一列，除非有冰山，我们可以将每一行中一块连续的只能放置一个船的区域都设成一个编号，同样的按照列也这样处理，这样就相当于将行和列缩点了，接下来用最大流模板套一套就可以了 。 
处理二分图还有一种更好的算法，叫匈牙利算法，紫书上没有，先用最大流算法解决吧 。
紫书十一章还有一道相似的题目，不过更加有趣 传送门
细节参见代码：

#include<bits/stdc++.h>
using namespace std;
const int maxn = 2*550*550;
typedef long long ll;
const int INF = 1000000000;
int T,n,m,id1[55][55],id2[55][55];
struct Edge {
  int from, to, cap, flow;
};
bool operator < (const Edge& a, const Edge& b) {
  return a.from < b.from || (a.from == b.from && a.to < b.to);
}
struct Dinic {
  int n, m, s, t;
  vector<Edge> old;
  vector<Edge> edges;    // 边数的两倍
  vector<int> G[maxn];   // 邻接表，G[i][j]表示结点i的第j条边在e数组中的序号
  bool vis[maxn];        // BFS使用
  int d[maxn];           // 从起点到i的距离
  int cur[maxn];         // 当前弧指针
void init(int n) {
    for(int i = 0; i < n; i++) G[i].clear();
    edges.clear();
}
void AddEdge(int from, int to, int cap) {
    edges.push_back((Edge){from, to, cap, 0});
    edges.push_back((Edge){to, from, 0, 0});
    m = edges.size();
    G[from].push_back(m-2);
    G[to].push_back(m-1);
}
bool BFS() {
    memset(vis, 0, sizeof(vis));
    queue<int> Q;
    Q.push(s);
    vis[s] = 1;
    d[s] = 0;
    while(!Q.empty()) {
      int x = Q.front(); Q.pop();
      for(int i = 0; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i]];
        if(!vis[e.to] && e.cap > e.flow) {
          vis[e.to] = 1;
          d[e.to] = d[x] + 1;
          Q.push(e.to);
        }
      }
    }
    return vis[t];
}
int DFS(int x, int a) {
    if(x == t || a == 0) return a;
    int flow = 0, f;
    for(int& i = cur[x]; i < G[x].size(); i++) {
      Edge& e = edges[G[x][i]];
      if(d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap-e.flow))) > 0) {
        e.flow += f;
        edges[G[x][i]^1].flow -= f;
        flow += f;
        a -= f;
        if(a == 0) break;
      }
    }
    return flow;
}
int Maxflow(int s, int t) {
    this->s = s; this->t = t;
    int flow = 0;
    while(BFS()) {
      memset(cur, 0, sizeof(cur));
      flow += DFS(s, INF);
    }
    return flow;
  }
}g;
map<int,int> p;
char s[55][55];
int main() {
    scanf("%d",&T);
    while(T--) {
        scanf("%d%d",&n,&m);
        g.init(maxn);
        for(int i=1;i<=n;i++) scanf("%s",s[i]+1);
        int cnt = 1;
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++) {
                if(s[i][j] == '#') id1[i][j] = cnt++;
                if(s[i][j] == '*') id1[i][j] = cnt;
            }
            cnt++;
        }
        for(int j=1;j<=m;j++) {
            for(int i=1;i<=n;i++) {
                if(s[i][j] == '#') id2[i][j] = cnt++;
                if(s[i][j] == '*') id2[i][j] = cnt;
            }
            cnt++;
        }
        p.clear();
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++) {
                if(s[i][j] == '*') {
                    g.AddEdge(id1[i][j],id2[i][j],1);
                    if(!p.count(id1[i][j])) {
                        p[id1[i][j]] = 1;
                        g.AddEdge(0,id1[i][j],1);
                    }
                    if(!p.count(id2[i][j])) {
                        p[id2[i][j]] = 1;
                        g.AddEdge(id2[i][j],cnt+1,1);
                    }
                }
            }
        }
        int ans = g.Maxflow(0,cnt+1);
        printf("%d\n",ans);
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

【并查集】UVALive3027 Corporative Network
【并查集】UVALive3027 Corporative Network
并查集——维护到根节点距离的d数组
题目大意
对n个节点操作，加边 or 询问某节点到根节点的距离
 


说一下思路
之前做过一道求连通分支最大元素个数的题目，维护的是一个cnt[ ]数组（在加边的过程中）；比较这道题，可以考虑维护到根节点的距离d[ ]数组。
思路：记下每个节点到父亲节点的距离为d[i]，然后在路径压缩时维护这个d数组；
在加边时只有这两个节点中的父亲节点的d需要维护，并不需要查操作，这一点的区别是相当大的！而怎样得到某节点u到根节点的距离呢？查操作。查操作本身带路径压缩的，所以不可能直接得到最终答案，必须一边路径压缩，一边维护数组d，最后输出d[u]即可
★维护过程与路径压缩同时进行，想想还是有点小麻烦！


参考代码
#include<bits/stdc++.h>
using namespace std;

const int _max = 2e4 + 10;
char cmd[2];
int n,a,b,pre[_max],d[_max];

void init(){
  for(int i = 1; i <= n; ++ i){
    pre[i] = i;//每个元素所在集合为其自身
    d[i] = 0;//每个节点到父亲节点的距离为0
  }
}

int find(int x){//返回元素x的根节点，路径压缩过程中维护d[]数组
  if( x == pre[x]) return x;
  int root = find(pre[x]);
  d[x] += d[pre[x]];
  return  pre[x] = root;
}

void join(int a,int b){//并,按要求合并边（a,b）
  pre[a] = b;
  d[a] = (abs(a - b))%1000;
}

int main(){
 #ifndef ONLINE_JUDGE
 freopen("input.txt","r",stdin);
 #endif // ONLINE_JUDGE
 int T;cin>>T;
 while(T--){
    scanf("%d",&n);
    init();
    while(scanf("%s",cmd) == 1 && cmd[0] != 'O'){
        if(cmd[0] == 'I'){
            scanf("%d%d",&a,&b);
            join(a,b);
        }
        else{
          scanf("%d",&a);
          find(a);
          printf("%d\n",d[a]);
        }
    }
 }
 return 0;
}


加粗    Ctrl + B 
斜体    Ctrl + I 
引用    Ctrl + Q
插入链接    Ctrl + L
插入代码    Ctrl + K
插入图片    Ctrl + G
提升标题    Ctrl + H
有序列表    Ctrl + O
无序列表    Ctrl + U
横线    Ctrl + R
撤销    Ctrl + Z
重做    Ctrl + Y


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

C++空类的大小
C++空类的大小为什么不为0？
先来看测试程序的输出。
#include <iostream>
using namespace std;

class NoMembers
{
};

int main()
{
    NoMembers n;  // Object of type NoMembers.
    cout << "The size of an object of empty class is: "
         << sizeof(n) << endl;
}
输出: 

The size of an object of empty class is: 1

C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。这是由于：

new需要分配不同的内存地址，不能分配内存大小为0的空间
避免除以 sizeof(T)时得到除以0错误

故使用一个字节来区分空类。
值得注意的是，这并不代表一个空的基类也需要加一个字节到子类中去。子类继承空类后，子类如果有自己的数据成员，则空基类的一个字节并不会加到子类中去。例如，
class Empty {};
struct D : public Empty { int a;};
sizeof(D)为4。
参考资料 
1. http://www.stroustrup.com/bs_faq2.html#sizeof-empty 
2. https://msdn.microsoft.com/en-us/library/f42z47h2.aspx 
3. http://en.cppreference.com/w/cpp/language/sizeof

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请注明出处: http://blog.csdn.net/lihao21

IOS之秒表计时器
1.利用xib方式新建一个秒表计数器。


功能实现：
该应用有三个按钮：开始，记次，复位
开始：开始控制着秒表的开始，点击后，按钮文字变成停止，在没有开始的情况下不允许记次操作
记次：可以记录多个你点击的时间，
复位：复位可以让秒表归零


实现效果图如下：
                                                 







1.
新建一个类，勾选xib,然后新建一个试图监控器，然后加载到根视图中

在AppDelegate.m中代码如下：
//新建一个视图控制器
    MainViewController *myView = [[MainViewController alloc]init];
    //将新建的视图控制器放到根视图中去。
    self.window.rootViewController = myView;
２.
我们在xib文件进行拖控件，两个label　和三个button，第一个label是一个不用操控的，只是一个
题目而已
第二个label是一个现实秒表数据的label
然后是三个按钮，分别用来控制开始，记次，和复位：
视图如下：


               
  
３.
在MainViewController.h中声明成员变量：毫秒，秒，分钟：另外还有一个NSTimer类型的timer；来用来接收计时器的方法
 
以每隔一毫秒调用让成员变成产生变化：
 
因为我们要和按钮进行交互，所以当我按下按钮的时候，按钮的文本变成了“停止”，这时候就需要一个临时变量。然后
 
用判断的方法，来对按钮进行更换文本，一般我们定义一个ＢＯＯＬ类型的变量。


 
然后就是三个按钮控制的方法：
 
代码如下：
#import <UIKit/UIKit.h>

	@interface MainViewController : UIViewController{
	    
	    
	    int persent;
	    int seconds;
	    int minutes;
	    IBOutlet UILabel *label;
	    BOOL isOn;
	    
	    
	}
	@property (nonatomic,strong )NSTimer *timer;
	- (IBAction)start:(id)sender;
	- (IBAction)record;
	- (IBAction)reset;

	@end
４.
首先我们开始实现方法：
对数据成员进行初始化：然后新建一个计时器，控制时间的不断变化：
代码如下：
- (void)viewDidLoad
{
    [super viewDidLoad];
    
    
    isStop = YES;
    //类方法会自动释放。
    self.timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(startTimer) userInfo:nil repeats:YES];
    //需要让定时器暂停
    [_timer setFireDate:[NSDate distantFuture]];
    
    // Do any additional setup after loading the view from its nib.
}
５.
在计数器里面我们看到一个方法：“startTimer”，没过１毫秒就调用这个方法，然后在这个方法中我们可以对成员变量
进行操作：代码如下：

-(void)startTimer{
    percens++;
    ／／没过１００毫秒，就让秒＋１，然后让毫秒在归零
    if(percens==100){
        seconds++;
        percens = 0;
    }
    if (seconds == 60) {
        minus++;
        seconds = 0;
    }
    ／／让不断变量的时间数据进行显示到label上面。
    label.text = [NSString stringWithFormat:@"%02d:%02d.%02d",minus,seconds,percens];
}

６.
然后考虑到的就是我们怎么控制的问题了，思路：我们只需把 [_timer setFireDate:[NSDate distantFuture]];
方法中的NSDate修改为当前的时间就可以让计时器立即执行：然后我们在开始按钮关联的方法中进行操作
代码如下：
//sender是触发者，响应者是当前类的对象
//目标动作机制。
//启动
-(IBAction)start:(id)sender{

    UIButton *btn = (UIButton *)sender;
     //如果按钮此时的状态是ｙｅｓ，那么我们按下后就把文本变成“停止”，然后让isStop = NO;
    //最主要的是让[_timer setFireDate:[NSDate date]];让计时器开始运行
    if (isStop) {
        [btn setTitle:@"停止" forState:UIControlStateNormal];
        [_timer setFireDate:[NSDate date]];
        isStop = NO;
    }else{//如果isStop = NO，当按钮按下的时候就让按钮的文本变成“开始”，然后在把isStop = YES;
        　//然后让[_timer setFireDate:[NSDate distantFuture]];，让计时器停止运行
        [btn setTitle:@"开始" forState:UIControlStateNormal];
        [_timer setFireDate:[NSDate distantFuture]];
        isStop = YES;
    }
    //设置定时器的启动时间为当前时间。
    //[_timer setFireDate:[NSDate date]];
}
７.
然后我们开始写记录时间的方法，这个方法中需要我们定义两个UILabel，分别用来显示第一次按下的数据和
按下的时候时间的数据。代码如下：
//记次
-(IBAction)record{
    //如果秒表没有启动，则无法点击
    if(isStop)return;
    static int count=0;
    
    UILabel *countLabel = [[UILabel alloc]init];
     //用来显示次数。Ｙ轴不断的向下延伸，２６０是上一个控件占用的长度
    countLabel.frame = CGRectMake(10, count*30+260, 100, 30);
    countLabel.text = [NSString stringWithFormat:@"记次 %d",++count];
    //NSLog(@"%@",countLabel);
    [self.view addSubview:countLabel];
    
    //记时label
    UILabel *timeLabel = [[UILabel alloc]init];
    //count之所以减去１，因为++count，而次数和时间的数据要显示在同一行
    timeLabel.frame = CGRectMake(220, 260+(count-1)*30, 100, 30);
    timeLabel.text = label.text;
    [self.view addSubview:timeLabel];
}


８．
最后就是我们的复位的方法了这个方法比较简单，只需要把成员变量置０，然后赋值就可以了
代码如下
//复位
-(IBAction)reset{
    percens = 0;
    seconds = 0;
    minus = 0;
   label.text = [NSString stringWithFormat:@"%02d:%02d.%02d",percens,seconds,minus];
    
    
}
9.
缺憾：
1.记次次数过多的时候，的文本显示没有滚动条，所以一个屏幕只能显示数个记录的时间数据
2.在复位的时候，如果开始按钮处于停止的文本，没有实现控制开始按钮让其变为初始值“开始”




10.手写代码实现：
由于源代码和上面的步骤差不多，这里就不做过多的介绍，仅提供源代码：
点击打开链接

介绍结束：




版权声明：本文为博主原创文章，未经博主允许不得转载。

R语言-找出向量或矩阵中的最大10个数
一、向量
最大10的数的索引（位置），可先按降序排序，得到索引号，然后将前10个取出即可。
建议方法：
order(x,decreasing=TRUE)[1:10]
过程详解：
1、测试数据x

> x
[1] 0.00 0.00 0.00 0.00 0.00 0.00 0.06 0.09 0.20 0.09 0.08 0.14 0.14 0.23
[15] 0.08 0.06 0.12 0.20 0.14 0.11 0.20 0.14 0.17 0.15 0.18 0.15 0.20 0.12
[29] 0.23 0.08 0.12 0.08 0.23 0.12 0.08 0.17 0.18 0.17 0.12 0.17 0.14 0.18
[43] 0.11 0.27 0.06

2、按降序排序

> order(x,decreasing=TRUE)
[1] 44 14 29 33  9 18 21 27 25 37 42 23 36 38 40 24 26 12 13 19 22 41 17 28
[25] 31 34 39 20 43  8 10 11 15 30 32 35  7 16 45  1  2  3  4  5  6
> 

3、这里就能取出最大10个数的索引了
> order(x,decreasing=TRUE)[1:10]
[1] 44 14 29 33  9 18 21 27 25 37

4、可以看一下，这取出的10个数的索引是不是指向最大的十个数。
> x[order(x,decreasing=TRUE)[1:10]]
[1] 0.27 0.23 0.23 0.23 0.20 0.20 0.20 0.20 0.18 0.18

二、矩阵
首先设定有矩阵y，9行5列，求最大的10个数的索引。

> y
      [,1] [,2] [,3] [,4] [,5]
[1,] 0.00 0.09 0.14 0.12 0.18
[2,] 0.00 0.08 0.11 0.23 0.17
[3,] 0.00 0.14 0.20 0.08 0.12
[4,] 0.00 0.14 0.14 0.12 0.17
[5,] 0.00 0.23 0.17 0.08 0.14
[6,] 0.00 0.08 0.15 0.23 0.18
[7,] 0.06 0.06 0.18 0.12 0.11
[8,] 0.09 0.12 0.15 0.08 0.27
[9,] 0.20 0.20 0.20 0.17 0.06

解答方法：

1、使用sore.list()进行排序
> arrayInd(sort.list(y,decreasing=T)[1:10],dim(y))
      [,1] [,2]
[1,]    8    5
[2,]    5    2
[3,]    2    4
[4,]    6    4
[5,]    9    1
[6,]    9    2
[7,]    3    3
[8,]    9    3
[9,]    7    3
[10,]    1    5


2、使用order()函数进行排序

错误的方法：
> arrayInd(which(order(y, decreasing = TRUE) <= 10), dim(y))
      [,1] [,2]
[1,]    5    1
[2,]    3    4
[3,]    4    4
[4,]    1    5
[5,]    4    5
[6,]    5    5
[7,]    6    5
[8,]    7    5
[9,]    8    5
[10,]    9    5

which(order(y, decreasing = TRUE) <= 10)含义是先将数据进行排序，然后取索引小于等于10的，最大的10个数在排完序后，索引不应是<=10，而是排在前10位的就是最大的10个数的索引。
正确的方法：
> arrayInd(order(y,decreasing=TRUE)[1:10],dim(y))
      [,1] [,2]
[1,]    8    5
[2,]    5    2
[3,]    2    4
[4,]    6    4
[5,]    9    1
[6,]    9    2
[7,]    3    3
[8,]    9    3
[9,]    7    3
[10,]    1    5

版权声明：本文为博主原创文章，未经博主允许不得转载。

Go web之旅（Request分析）
在网站上进行的每一次交互，其实其内部所经历的过程可以简化为3步： 
1.发送请求 
2.服务器端进行处理 
3.请求响应 
为什么要提到上面的交互过程呢？因为最近有读者建议讲一下网站交互，所以现在我们结合网站交互过程进行我们今天的Go web旅程之源码解析。 
我们都知道网站是采用http协议进行数据传送的。http请求是由三部分组成，分别是:请求行、请求头、请求主体。下面是访问google时的请求和响应: 
 
咱先分析请求，最上面四行是请求行，其格式一般为（方法+[空格]+请求URI+[空格]+版本号+[回车换行]），最下面的是请求头，一般内容如上图，还有请求主体这里没有，因为一般请求方式为GET的请求，是没有请求主体的，因为该请求方式的请求其数据一般封装在地址栏的。
好了介绍了这么长时间的的http协议的请求格式，下面我们就看一下go语言的request的数据结构和常用的函数:

type Request struct {

    Method string//请求方式(GET, POST, PUT, etc.),一般没写的话默认为GET

    URL *url.URL//请求地址
    Proto      string //协议版本 "HTTP/1.0"
    Header Header   //请求头

    Body io.ReadCloser//请求主体

    ContentLength int64//请求主体内容的长度

    Host string      //主机
    ......

}
其中Header的类型为map[string][]string,采用键值对的形式来存储request请求头，这从上面图中就可以看出。
type Header map[string][]string
常见的函数: 
//ParseHTTPVersion解析HTTP版本. 
// eg.”HTTP/1.0” 返回值(1, 0, true).

func ParseHTTPVersion(vers string) (major, minor int, ok bool)
// NewRequest创建一个给定method, URL,body的Request
func NewRequest(method, urlStr string, body io.Reader) (*Request, error)
//BasicAuth函数是用来获取请求头的授权，它是调用parseBasicAuth()函数进行解析实现的

func (r *Request) BasicAuth() (username, password string, ok bool)
func parseBasicAuth(auth string) (username, password string, ok bool)
//解析请求行
func parseRequestLine(line string) (method, requestURI, proto string, ok bool)
//ReadRequest函数从输入流中读取并解析得到一个Request
func ReadRequest(b *bufio.Reader) (req *Request, err error)
在网站的交互中最重要的是数据的交流了，数据在不同的层次或不同的地方类型是不同的， 
而且采用不同的方式发送请求，其数据类型也是不同的。 
比如在前端数据一般用字符串作为类型，在后台会采用各种不同的类型 
在数据传google会采用json格式，而在后台会采用结构体或对象来交流数据。 
请求方式方面，如果采用GET方式，数据是直接拼接在URL中，而采用POST,PUT方式数据一般使用form(表单) 
进行数据封装的。
下面两个函数就是go语言中实现对request中的form封装的数据进行解析的
/*对request中的form封装的数据进行解析，
内部实现机制:根据请求方式的不同采用不同的方式解析.
如果请求方式为POST,PUT,或PATCH则调用parsePostForm()进行解析
*/
func (r *Request) ParseForm() error
func parsePostForm(r *Request) (vs url.Values, err error)

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu(2089)——不要62（数位dp）
这道题很早之前就用数位dp做过一遍，但是那时候并没有理解透彻。今天又细细思考了一下，感觉比之前要好多了
题意：
就是叫你在[n,m]这个区间范围内找出不包含4和62的数字的个数。
思路：
1）暴力
2）数位dp：
      做数位dp前，我们首先需要初始化，我们定义f[i][j]为开头为j的i位数中正常的数字有几个。
     然后我们可以用三层for循环来对f数组进行初始化。
void init(){
	f[0][0]=1;						//别忘记了
	for(int i=1;i<=7;i++){
		for(int j=0;j<=9;j++){
			for(int k=0;k<=9;k++){
				if((j!=4)&&(!(j==6&&k==2))){		//这里的逻辑关系一开始我写成||(j!=6&&k!=2)，这样子是有问题的
					f[i][j]=f[i-1][k]+f[i][j];
				}
			}
		}
	}
}


第一层我们for的是第几位，第二层我们则对第i位能够取到的数字进行枚举，第三层我们对第i-1位能够取到的数字进行枚举。因为当前第i位的取值关系只与第i-1位和当前第i位有关，所以我们就可以得到这个递推式了。

最重要的就是求数字有几个了。
今天我终于搞懂了为什么有时候是cal(m+1)-cal(n)，而有时候是cal(m)-cal(n-1)了。
这个取决于你自己的dp是怎么定义的。当你定义为前i个数里面有多少个是符合条件的，那么就是我写的第一种写法。
如果定义为前i个数包括自己本身有多少个数是符合条件的，那么就是我写的第二种写法。
但是两种写法本质上并没有什么区别。
这道题我写的是第一种，即为不包含本身的。
求法为：
我们从低位到高位分别标记为1~n（n为位数），然后从高位开始寻找，然后后面代替的数字肯定不能大于当前那位的值，又因为我定义的是不包含自身，所以就得小于当前那位的值，然后ans+=已经求出来的f[i][j]，就这样一位位的推下去，直至最后一位，所以这也就是我们最后一位为什么要加1的原因。
当然，当这位是4，或者这位是2并且前一位是6的情况下，那么直接跳出循环就好了。

int cal(int x){
	int tmp=x,t=0;
	while(tmp){
		dig[++t]=tmp%10;
		tmp=tmp/10;
	}
	dig[t+1]=0;
	int ans=0;
	for(int i=t;i>=1;i--){
		for(int j=0;j<dig[i];j++){
			if((j!=4)&&(!(j==2&&dig[i+1]==6)))
				ans+=f[i][j];
		}
		if((dig[i]==4)||(dig[i]==2&&dig[i+1]==6)) break;
	}
	return ans;
}
一开始我一直想不通为什么j循环到小于dig[i]就好了，其实就是定义的问题。


#include<stdio.h>
#include<string.h>
#include<queue>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<math.h>
#include<iostream>
#include<algorithm>
using namespace std;
#define maxn 11
int dig[maxn];
int f[maxn][maxn];
void init(){
	f[0][0]=1;
	for(int i=1;i<=7;i++){
		for(int j=0;j<=9;j++){
			for(int k=0;k<=9;k++){
				if((j!=4)&&(!(j==6&&k==2))){
					f[i][j]=f[i-1][k]+f[i][j];
				}
			}
		}
	}
}
int cal(int x){
	int tmp=x,t=0;
	while(tmp){
		dig[++t]=tmp%10;
		tmp=tmp/10;
	}
	dig[t+1]=0;
	int ans=0;
	for(int i=t;i>=1;i--){
		for(int j=0;j<dig[i];j++){
			if((j!=4)&&(!(j==2&&dig[i+1]==6)))
				ans+=f[i][j];
		}
		if((dig[i]==4)||(dig[i]==2&&dig[i+1]==6)) break;
	}
	return ans;
}
int main(){
	int n,m;
	init();
	while(~scanf("%d%d",&n,&m)){	
		if(n==0&&m==0) break;
		printf("%d\n",cal(m+1)-cal(n));<span style="white-space:pre">		</span>//!!!
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

【Java并发编程实战】-----“J.U.C”：ReentrantLock之三unlock方法分析
前篇博客LZ已经分析了ReentrantLock的lock()实现过程，我们了解到lock实现机制有公平锁和非公平锁，两者的主要区别在于公平锁要按照CLH队列等待获取锁，而非公平锁无视CLH队列直接获取锁。但是对于unlock()而已，它是不分为公平锁和非公平锁的。public void unlock() {
        sync.release(1);
    }

    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }release(1)，尝试在当前锁的锁定计数（state）值上减1。成功返回true，否则返回false。当然在release()方法中不仅仅只是将state – 1这么简单，- 1之后还需要进行一番处理，如果-1之后的新state = 0 ，则表示当前锁已经被线程释放了，同时会唤醒线程等待队列中的下一个线程，当然该锁不一定就一定会把所有权交给下一个线程，能不能成功就看它是不是亲爹生的了（看运气）。protected final boolean tryRelease(int releases) {
        int c = getState() - releases;   //state - 1
        //判断是否为当前线程在调用，不是抛出IllegalMonitorStateException异常
        if (Thread.currentThread() != getExclusiveOwnerThread())   
            throw new IllegalMonitorStateException();
        boolean free = false;
        //c == 0,释放该锁，同时将当前所持有线程设置为null
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        //设置state
        setState(c);
        return free;
    }在release代码中有一段代码很重要：            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;对于这个LZ在前篇博客已经较为详细的阐述了。不懂或者忘记请再次翻阅：【Java并发编程实战】—–“J.U.C”：ReentrantLock之二lock方法分析waitStatus!=0表明或者处于CANCEL状态，或者是置SIGNAL表示下一个线程在等待其唤醒。也就是说waitStatus不为零表示它的后继在等待唤醒。unparkSuccessor()方法：private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        //如果waitStatus < 0 则将当前节点清零
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0);

        //若后续节点为空或已被cancel，则从尾部开始找到队列中第一个waitStatus<=0，即未被cancel的节点
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }注：unlock最好放在finally中！！！！！！unlock最好放在finally中！！！！！！ unlock最好放在finally中！！！！！！ （重要的事说三遍） 参考文献：1、Java多线程系列–“JUC锁”04之 公平锁(二)

版权声明：本文为博主原创文章，未经博主允许不得转载。

PyQt5学习随笔01--计算一个文件夹里我们码的代码行数&&PyQt的多线程通信
    今天突然想知道自学习Python以来我一共码了多少行代码了，于是写了一个简单的程序：__author__ = 'jiangzhiheng'
# coding=utf-8
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
import glob

global lines
lines = 0

def count_work():
    main()

def main():
    global lines
    py_filenames = glob.glob('C:\\Users\\jiangzhiheng\\Desktop\\python\\*.py')
    for filename in py_filenames:
        if filename:
            for line in open(filename,'rb').readlines():   #以二进制读，否则会出现UnicodeEncodeError
                if line:
                    lines+=1                                #统计代码行数
                    lcdNumber.display(lines)
                    myfile = open('all.txt','a')
                    myfile.write(line.decode('utf-8')+'\n')      #用decode函数将二进制数据转为str
                    myfile.close()


app= QApplication([])
mywindow = QWidget()
layout = QVBoxLayout(mywindow)     #垂直布局
lcdNumber = QLCDNumber()
layout.addWidget(lcdNumber)    #增加数字显示屏
button = QPushButton('测试')
layout.addWidget(button)       #增加按钮

button.clicked.connect(count_work)       #将button按钮连接到count_work函数槽

mywindow.show()
app.exec_()
运行效果：


     但是发现出了一个问题，就是点击“测试”按钮开始计算时，页面停止响应,直到计算结束，期间数字显示板一直显示为0。发现原因如下：因为 Qt 中所有界面都是在 UI 线程中（也被称为主线程，就是执行了QApplication::exec()的线程），在执行一些耗时的操作，就会阻塞 UI 线程，从而让界面停止响应。为避免这个问题，考虑另外加一个线程执行那个循环：

__author__ = 'jiangzhiheng'
# coding=utf-8
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
import glob    #glob模块获取文件名，类似于windowsde 搜索功能，支持"?，[],*"通配符，用法如下面例子所示

global lines               #定义一个全局变量用于计数
lines = 0
global directory
directory = ''

class MyThread(QThread):             #创建一个新QThread类
    def __init__(self):
        super(MyThread,self).__init__()

    def run(self):                  #重新定义run函数，run函数就是新线程要执行的的代码
        global lines
        py_filenames = glob.glob(directory+'\\*.py')
        for filename in py_filenames:
            if filename:
                for line in open(filename,'rb').readlines():   #以二进制读，否则会出现UnicodeEncodeError
                    if line:
                        lines+=1                                #统计代码行数
                        lcdNumber.display(lines)
                        myfile = open('Lines.txt','a')
                        myfile.write(line.decode('utf-8')+'\n')      #用decode函数将二进制数据转为str
                        myfile.close()

def main():                 ##定义槽函数
    global directory        #引用全局变量
    directory = QFileDialog.getExistingDirectory(mywindow,'选择文件夹',
                                                 'C:\\')             #这里改为自己选择文件夹
    myThread = MyThread()
    myThread.start()



app= QApplication([])
mywindow = QWidget()              #创建一个新窗口
layout = QVBoxLayout(mywindow)     #垂直布局
lcdNumber = QLCDNumber()
layout.addWidget(lcdNumber)    #增加数字显示屏
button = QPushButton('测试')
layout.addWidget(button)       #增加按钮

button.clicked.connect(main)       #将button按钮连接到count_work函数槽

mywindow.show()
app.exec_()


版权声明：本文为博主原创文章，未经博主允许不得转载。

认识size_t和指针类型的大小
1.size_t占用的空间
对于size_t究竟是什么类型，百度百科进行了先关说明。
size_t概述： size_t 类型定义在cstddef头文件中，该文件是C标准库的头文件stddef.h的C++版。它是一个与机器相关的unsigned整型类型，其大小足以保证存储内存中对象的大小。
size_t由来:  在C++中，设计 size_t 就是为了适应多个平台的 。size_t的引入增强了程序在不同平台上的可移植性。
size_t大小: 关于size_t占用的空间百度百科的描述是：经测试发现，在32位系统中size_t是4字节的，而在64位系统中，size_t是8字节的，这样利用该类型可以增强程序的可移植性。
疑问百度百科和网上猿友的描述看似很有道理，但是很多人在测试的时候发现，为什么测试环境明明是64位的系统，sizeof(size_t)的值却等于4呢？而不是原本预期的8。
本机环境是Win7 64bits，使用VS2012来验证。
本机系统类型： 

测试代码：
cout<<"sizeof(size_t)="<<sizeof(size_t)<<endl;
输出结果： 

疑问解答： 为什么会这样，我之前一直也弄不明白。原来网上说的size_t的大小由系统的位数决定是不准确的。那size_t的大小究竟是由什么决定的呢？
先看一下我刚刚测试代码的VS2012的编译配置。配置如下：
 
红色框中的Win32表示的是什么意思呢？原来Win32表示的是生成的程序是32bits。32bits的程序既可以在Windows 32bits的系统下运行，也可以在Windows 64bits的系统下运行。所以，我们配置生成的程序是32bits的，因此size_t就是unsigned int 类型，即大小为4个字节。
VC++中关于size_t类型的定义如下：
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
其大概的意思就是size_t要么是unsigned int，要么是unsigned long int，那么按照上面的推理，修改编译选项为x64，生成64bits的程序，size_t的类型是不是就变成了unsigned long int了呢？验证如下：
VS2012的编译配置更改如下： 

同样的测试代码：
cout<<"sizeof(size_t)="<<sizeof(size_t)<<endl;
输出结果为： 
 
正如预期的一样，size_t变成了unsigned long int ,占用8字节的内存空间。
总结：size_t的大小并非像很多网上描述的那样，其大小是由系统的位数决定的。size_t的大小是由你生成的程序类型决定的，只是生成的程序类型与系统的类型有一定关系。32bits的程序既可以在64bits的系统上运行，也可以在32bits的系统上运行。但是64bits的程序只能在64bits的系统上运行。然而我们编译的程序一般是32bits的，因此size_t的大小也就变成了4个字节。

2.指针的大小
关于指针的大小，网上描述基本上是千篇一律，认为指针是存放地址的，如果是32位机器就是4字节的，如果是64位机器就是8字节的，根据机器字而决定的。
这里的32位机器和64位机器指的是什么呢？我觉的CPU的架构决定了机器的类型，如果CPU是x86架构，那么就是32位的CPU，当然并非所有的x86架构的CPU都是32位的，比如intel的8086和8088就是16位的CPU。
如果CPU是x86-64的架构，那么就是64位的CPU。CPU的位数是由其字长决定，字长表示CPU在同一时间中能够处理二进制数的位数叫字长。字长是由CPU中寄存器的位数决定的，并非由数据总线的宽度决定的，只是数据总线的宽度一般与CPU的位数相一致。
系统的位数是依赖于CPU的位数，即32位的CPU不能装64位的系统，但是现在（2015年）的CPU基本上都是x86-64的CPU，都支持64位的系统。但是正如上面的讨论，如果编译生成的程序不是64位的，那么指针的大小依然是4个字节。
验证如下：
VS2012的编译配置如下： 
 
测试代码：
cout<<"sizeof(char*)="<<sizeof(char*)<<endl;
输出结果： 

更改编译配置，生成64位的程序，我们将得到预想的结果： 


参考资料
[1]百度百科.size_t

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Ural 1780 Gray Code （暴力）
Ural 1780
题意：
输入一个二进制数与该二进制数的格雷码，但有一些位置不确定，写程序将其恢复，无法恢复输出Impossible，多解输出Ambiguity。
思路：
其实是个普通的乱搞题。。 
Gray码的定义：Gi=Bi−1⊗Bi,G0=B0G_i = B_{i-1}\otimes B_{i} , G_0=B_0 
（第i位格雷码等于第i位二进制码与第i-1位二进制码的异或值） 
然后按照这个定义编码，正向反向各自编一遍，出现矛盾输出Impossible，最后还含有’?’则有多解。
代码：
/*
* @author FreeWifi_novicer
* language : C++/C
*/
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<string>
#include<map>
#include<set>
#include<vector>
#include<queue>

using namespace std;

#define clr( x , y ) memset(x,y,sizeof(x))
#define cls( x ) memset(x,0,sizeof(x))
#define mp make_pair
#define pb push_back
typedef long long lint;
typedef long long ll;
typedef long long LL;

bool check( char &k1 , char &k0 , char &x1 ){
        //cout << k1 << k0 << x1 << endl;
    if( k0 == '?' ) {
        if( k1 == '0' ) {
            if( x1 != '?' )
                k0 = x1 ;
            return true ;
        }
        else if( k1 == '1' ) {
            if( x1 != '?' )
                k0 = '1' + '0' - x1 ;
            return true ;
        }
    }
    else if( k0 == '0' ){
        if( k1 != x1 && k1 != '?' && x1 != '?' )
            return false ;
        if( k1 == '?' )
            k1 = x1 ;
        if( x1 == '?' )
            x1 = k1 ;
        return true ;
    }
    else {
        if( k1 == x1 && k1 != '?' )
            return false ;
        if( k1 == '?' && x1 != '?' )
            k1 = '1' + '0' - x1 ;
        if( x1 == '?' && k1 != '?' )
            x1 = '1' + '0' - k1 ;
        return true ;
    }
}
int main(){
  //freopen("input.txt","r",stdin);
    string x , k ;
    while( cin >> k >> x ){
        k = '0' + k ;
        int len = x.length() ;
        int flag = 0 ;
        for( int i = 0 ; i < len ; i++ ){
            if( !check( k[i+1] , k[i] , x[i]) ) {
                cout << "Impossible" << endl;
                flag = 1 ;
                break ;
            }
        }
        if( flag ) continue ;
        for( int i = len - 1 ; i >= 0 ; i-- ){
            if( !check( k[i+1] , k[i] , x[i] ) ) {
                cout << "Impossible" << endl ;
                flag = 1 ;
                break ;
            }
        }
        k.erase(0,1);
        if( flag ) continue ;
        if( k.find( "?" ) != string::npos || x.find( "?" ) != string::npos ){
            cout << "Ambiguity" << endl;
            continue ;
        }
        cout << k << endl ;
        cout << x << endl ;
        k.clear() ;
        x.clear() ;
    }
    return 0;
}



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：博主表示授权一切转载啦：）

UVA 11427 Expect the Expected (概率dp＋推公式求期望  详解)
题目链接：https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2422



题目大意：一个人每天玩游戏，玩一局胜利的概率为p，一天最多玩n次，如果当天某时刻胜率大于p则结束，第二天继续玩，如果某天玩了n次胜率还是不大于p，则失败不再玩，求玩的天数的期望


题目分析：先求一天失败的概率q，设dp[i][j]为一天内玩了i局胜j局的概率，则q=∑dp[n][i] (i / n <= a / b)，下面是dp方程：
dp[i][0] = dp[i - 1][0] * (1- p)，  一局都没胜利
dp[i][j] = dp[i - 1][j] * (1-  p)，第i局输了
dp[i][j] = dp[i - 1][j - 1] * p，(a * i >= b * j)，第i局胜了，这里一定要注意，前提是胜率不能大于p，否则当天就算胜利了
因为每天玩的情况都是独立的，最后答案E = 1 * q + 2 * q * (1 - q) + 3 * q * (1- q)^2 + ... + n * q * (1 - q)^(n - 1)  (n -> ∞)
E/q = 1 + 2 * (1 - q) + 3 * (1 - q)^2 + ... + n * (1 - q)^(n - 1)     ......(1)

E/q * (1 - q) = (1 - q) + 2 * (1 - q)^2 + 3 * (1 - q)^3 + ... + n * (1 - q)^n    ......(2)
(1) - (2) = E = 1 + (1 - q) + (1 - q)^2 + (1 - q)^3 + ... + (1 - q)^(n - 1) - n * (1 - q)^n
好多博客写的都不对，虽然不影响答案，等比数列求完后面还有一项，所以最后
E = 1 / q - (1 - q)^n / q - n * (1 - q)^n，显然(1 - q)^n / q这个在n趋向于无穷大的时候是0，至于n*(1-q)^n，令x＝1-q，则0 < x < 1，令k = 1 / x，则k > 1，原式等于n / (k ^ n)，然后洛必达法则，得到它的极限为0，其实你也可以说指数增长的肯定比线性快，但是这样证更清晰吧，所以最后得到E = 1 / q，如此简单的式子。。。orz
#include <cstdio>
#include <cstring>
int const MAX = 105;
double dp[MAX][MAX];

int main()
{
    int T;
    scanf("%d", &T);
    for(int ca = 1; ca <= T; ca++)
    {
        memset(dp, 0, sizeof(dp));
        int a, b, n;
        scanf("%d/%d %d", &a, &b, &n);
        double p = (double)a / (double)b;
        dp[0][0] = 1.0;
        for(int i = 1; i <= n; i++)
        {
            dp[i][0] = dp[i - 1][0] * (1.0 - p);
            for(int j = 1; j <= n; j++)
            {
                dp[i][j] += dp[i - 1][j] * (1.0 - p);
                if(a * i >= b * j)
                    dp[i][j] += dp[i - 1][j - 1] * p;
            }
        }
        double ans = 0;
        for(int i = 0; i <= n; i++)
            ans += dp[n][i];
        printf("Case #%d: %d\n", ca, (int) (1.0 / ans));
    }
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

《Java实战开发经典》第五章5.4
package five; 
//第五章练习4，设计一个Dog类有名字、颜色、年龄属性，并初始化这些属性，定义方法输出Dog信息，编写程序使用Dog类 
public class Four { 
public static void main(String[] args) { 
    Dog dog=new Dog(“bamaao”,”black”,45); 
    dog.tell(); 
} 
} 
class Dog{ 
    private String name; 
    private String color; 
    private int age; 
    public Dog(String name,String color,int age){ 
        this.name=name; 
        this.color=color; 
        this.age=age; 
    } 
    public void tell(){ 
        System.out.println(“这只狗的名字是”+name+”它的颜色是”+color+”它的年龄是”+age); 
    } 
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 2594--Treasure Exploration【二分图 && 最小路径覆盖 && 点可以重复走 && 传递闭包】


Treasure Exploration




Time Limit: 6000MS
 
Memory Limit: 65536K


Total Submissions: 7343
 
Accepted: 3002





Description

Have you ever read any book about treasure exploration? Have you ever see any film about treasure exploration? Have you ever explored treasure? If you never have such experiences, you would never know what fun treasure exploring brings to you. 
Recently, a company named EUC (Exploring the Unknown Company) plan to explore an unknown place on Mars, which is considered full of treasure. For fast development of technology and bad environment for human beings, EUC sends some robots to explore the treasure. 
To make it easy, we use a graph, which is formed by N points (these N points are numbered from 1 to N), to represent the places to be explored. And some points are connected by one-way road, which means that, through the road, a robot can only move from one
 end to the other end, but cannot move back. For some unknown reasons, there is no circle in this graph. The robots can be sent to any point from Earth by rockets. After landing, the robot can visit some points through the roads, and it can choose some points,
 which are on its roads, to explore. You should notice that the roads of two different robots may contain some same point. 
For financial reason, EUC wants to use minimal number of robots to explore all the points on Mars. 
As an ICPCer, who has excellent programming skill, can your help EUC?
Input

The input will consist of several test cases. For each test case, two integers N (1 <= N <= 500) and M (0 <= M <= 5000) are given in the first line, indicating the number of points and the number of one-way roads in the graph respectively. Each of the following
 M lines contains two different integers A and B, indicating there is a one-way from A to B (0 < A, B <= N). The input is terminated by a single line with two zeros.
Output

For each test of the input, print a line containing the least robots needed.
Sample Input
1 0
2 1
1 2
2 0
0 0

Sample Output
1
1
2

题意：
派机器人去火星寻宝，给出一个无环的有向图，机器人可以降落在任何一个点上，再沿着路去其他点探索，我们的任务是计算至少派多少机器人就可以访问到所有的点。有的点可以重复去。



解析：这题粗略一看，有点最小路径覆盖的意思，但是和标准的最小路径覆盖问题不同在于，标准的最小路径覆盖问题是每个点只能走一次，本题的点是可以重复去走了。
但是我们可以转化一下，传递闭包建立新图，转化为标准的路径覆盖。最小路径覆盖 = 图的顶点数 – 最大匹配数。
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 550
using namespace std;
int map[maxn][maxn];
int used[maxn];
int link[maxn];
int n, m;

void init(){
    memset(map, 0, sizeof(map));
}

void getmap(){
    while(m--){
        int a, b;
        scanf("%d%d", &a, &b);
        map[a][b] = 1;
    }
}

void floyd(){
    for(int k = 1; k <= n; ++k)
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= n; ++j)
                map[i][j] = map[i][j] || map[i][k] && map[k][j];
}

bool dfs(int x){
    for(int i = 1; i <= n; ++i){
        if(map[x][i] && !used[i]){
            used[i] = 1;
            if(link[i] == -1 || dfs(link[i])){
                link[i] = x;
                return true;
            }
        }
    }
    return false;
}

int hungary(){
    int ans = 0;
    memset(link, -1, sizeof(link));
    for(int i = 1; i <= n; ++i){
        memset(used, 0, sizeof(used));
        if(dfs(i))
            ans++;
    }
    return ans;
}

int main (){
    while(scanf("%d%d", &n, &m), n || m ){
        init();
        getmap();
        floyd();
        int sum = hungary();
        printf("%d\n", n - sum);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

搭建PHP运行环境
前言：因为要做众筹，所以需要参考和学习一下众筹的业务，但是大部分的众筹都是PHP开发，那接下来首先需要搭建一个PHP的环境。之前手动搭建过几次的PHP环境，这次自然也是手动来搭建，准备了PHP 5.3、Apache、mysql，然而弄到最后，虽然环境搭起来了，但是万维的众筹不能很好的运行，只能另想其他办法。
准备
phpStudy_2014_setup.1413444920.exe 
方维众筹，这等源码你可以到淘宝上买得到。
开始
其实吧，这玩意安装起来也相当的快捷，一站式傻瓜安装。
注意：如果你电脑已经安装过了mysql，那么在安装过程中就不需要再勾选mysql了！
 
他会自动创建测试文件，你可以在浏览器上输入localhost就可以访问PHP了。
紧接着，最重要的是我们把众筹的源码放到服务器目录中

当然这中间还有众筹的一些安装方法，切记：淘宝的一些卖家很低端，所以他们会让你再去买什么PHP空间，千万别信他，目前这种安装方法就OK了！
结语：其实吧，我想写点别的，让我再酝酿一下吧！

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本站博客均为qing_gee原创文章，若您需要引用、转载，只需要注明来源及原文链接即可。

Java实现堆
package com.heap;

class Node {
    private int iData;

    public int getKey() {
        return iData;
    }

    public void setKey(int iData) {
        this.iData = iData;
    }

    public Node(int iData) {
        super();
        this.iData = iData;
    }

}

class Heap {
    private Node[] heapArray;
    private int maxSize;
    private int currentSize;

    public int getMaxSize(){
        return maxSize;
    }

    public int getCurrentSize(){
        return currentSize;
    }

    public Heap(int max) {
        this.maxSize = max;
        currentSize = 0;
        heapArray = new Node[maxSize];
    }

    public boolean isEmpty() {
        return currentSize == 0;
    }

    //插入使用向上筛选，  节点初始时插入到数组的最后第一个空着的单元中，数组容量大小增一
    public boolean insert(int key) {
        if (currentSize == maxSize) {
            return false;
        }
        Node newNode = new Node(key);
        heapArray[currentSize] = newNode;
        trickleUp(currentSize++);
        return true;
    }

    //向上筛选，插入时，从下往上查找，直到新插入节点咋一个大于它的节点之下，在一个小于它的节点之上
    private void trickleUp(int index) {
        int parent = (index - 1) / 2;
        Node bottom = heapArray[index];
        while (index > 0 && heapArray[parent].getKey() < bottom.getKey()) {
            heapArray[index] = heapArray[parent];
            index = parent;
            parent = (parent - 1) / 2;
        }
        heapArray[index] = bottom;
    }

    //删除每次删除的是根节点
    //1.移走根；2.把最后一个节点移动到根的位置；3.一直向下筛选这个节点，直到它在一个大于它的节点之下
    //小于它的节点之上为止
    public Node remove() {
        Node root = heapArray[0];
        heapArray[0] = heapArray[--currentSize];
        trickleDown(0);
        return root;
    }

    //向下筛选，
    private void trickleDown(int index) {
        int largeChild;
        Node top = heapArray[index];//当前节点
        while (index < currentSize / 2) {
            int leftChild = 2 * index + 1;
            int rightChild = leftChild + 1;

            if (rightChild < currentSize
                    && heapArray[leftChild].getKey() < heapArray[rightChild]
                            .getKey()) {
                largeChild = rightChild;
            } else{
                largeChild = leftChild;
            }

            if(top.getKey() >= heapArray[largeChild].getKey())
                break;

            heapArray[index] = heapArray[largeChild];
            index = largeChild;         
        }
        heapArray[index] = top;
    }

    //修改节点
    public boolean change(int index, int newValue){
        if(index < 0 || index >= currentSize)
            return false;
        int oldValue = heapArray[index].getKey();
        heapArray[index].setKey(newValue);

        if(oldValue < newValue)
            trickleUp(index);
        else
            trickleDown(index);
        return true;
    }


    //打印
    public void displayHeap(){
        System.out.println("heapArray:");

        for(int m = 0; m < currentSize; m++)
            if(heapArray[m] != null)
                System.out.print(heapArray[m].getKey() + " ");
            else
                System.out.print("--");
            System.out.println();

            int nBlanks = 32;
            int itemsPerRow = 1;
            int column = 0;
            int j = 0;
            String dots = "................................";
            System.out.println(dots + dots);

            while(currentSize > 0){
                if(column == 0)
                    for(int k = 0; k < nBlanks; k++)
                        System.out.print(' ');
                System.out.print(heapArray[j].getKey());

                if(++j == currentSize)
                    break;

                if(++column == itemsPerRow){
                    nBlanks /= 2;
                    itemsPerRow *= 2;
                    column = 0;
                    System.out.println();
                } else 
                    for(int k = 0; k < nBlanks * 2 - 2; k++)
                        System.out.print(' ');              
            }
            System.out.println("\n" + dots + dots);
    }
}




package com.heap;

import java.util.Arrays;

public class TestHeap {

    public static void main(String[] args) {

        int value, value2;
        Heap theHeap = new Heap(31);
        boolean success;

        theHeap.insert(70);
        theHeap.insert(40);
        theHeap.insert(50);
        theHeap.insert(20);
        theHeap.insert(60);
        theHeap.insert(100);
        theHeap.insert(80);
        theHeap.insert(30);
        theHeap.insert(10);
        theHeap.insert(90);

//      //显示
        theHeap.displayHeap();
//      
//      success = theHeap.insert(55);
//      System.out.println("success:" + success );
//      theHeap.displayHeap();
//      
//      theHeap.remove();
//      theHeap.displayHeap();

        //--------------------------------堆排序
//      int[] arr = {12, 54, 9, 3 ,123, 90,13};
//      theHeap = new Heap(7);
//      for(int i = 0; i < arr.length; i++)
//          theHeap.insert(arr[i]);
//      for(int i = 0; i < arr.length; i++)
//          arr[i] = theHeap.remove().getKey();
//      
//      System.out.println(Arrays.toString(arr));
        //--------------------------------
    }

    //堆排序
    public static void heapSort(int arr[]){
        Heap theHeap = new Heap(7);
        for(int i = 0; i < arr.length; i++)
            theHeap.insert(arr[i]);
        for(int i = 0; i < arr.length; i++)
            arr[i] = theHeap.remove().getKey();
    }
}



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

关于浮点数的一些问题
在stackoverflow中看到的，之前用float类型数据比较少，所以没怎么研究。现在看看 
看看测试代码
int main()
{
    float a = 0.7;
    float b = 0.5;
    if (a < 0.7)
    {
       if (b < 0.5) printf("2 are right");
       else         printf("1 is right");
    }
    else printf("0 are right");
}
按照理论情况应该是第一个if不进入，在linux 64位上看看 
 
这个情况发生了， 
还有一个代码 
 
运行结果是 
 
就上面两种情况分析一下。
先看看这两种写法 
0.7和.7 
一个小代码实验
#include<stdio.h>

int main()
{
 float a=0.7;
 printf("%zu\n",sizeof(a));
 printf("%zu\n",sizeof(0.7));
 printf("%zu\n",sizeof(.7));

 return 0;
}
运行结果是 
 
是不是可以这样认为，对于常值小数，os是将其默认设置为double 型的，
上面都是一些实验现象，为了更深入理解浮点数，看看浮点数在计算机中是怎么存储和计算的。
我们知道  对于十进制而言， 
大于0的权重是10正次幂，而小于零的是10负次幂，所以 
对于二进制小数，同样采样这样的方法， 
所以这里面就会出现一个问题，对于有限长度的编码，十进制是不能表示分数的，而对于二进制小数只能表示能被二整除的一些数，并不能准确的表示，只能近似的表示。只有增加二进制编码长度才会将这个误差缩小，
IEEE是如何将浮点数存储起来的， 
 
为了说明这个问题 ，采用union来查看float的存储数据
union f
{
 int p;
 float f;
};

int main()
{
     union f  tf;
     tf.f=0.1;
     printf("%x\n",tf.p);
     return 0;
}
 
0_01111011_10011001100110011001101
所以现在已经明白一个事实就是，从正数小数到二进制小数之间的转化实际上并不是完全相等的转化，是有一定误差的。对于同一个十进制小数转化成float和double由于编码位数的不一致，结果也是不同的。
为此在比较浮点数时，采用的是误差比较法 
if (fabs(result - expectedResult) < 0.00001) 
fabs用于计算小数之间的绝对值的
result和expectedResult是两个需要比较的浮点数
stackoverflow的问题原地址 
http://stackoverflow.com/questions/7011184/floating-point-comparison
下面是一个国外人写的关于浮点数的文章 
http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

图的深度优先搜索（DFS）
今天又复习了图的深度优先搜索，深深感觉了深搜就是外挂，岂止是外挂，简直就是外挂，动态规划做不出来的，深搜搜出来了，贪心贪不出来的深搜搜出来了，连并查集，拓扑排序做不出来的，深搜都做出来了，很遗憾以前深搜没有好好学。


深度优先搜索（Depth-First-Search）是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。




事实上,深度优先搜索属于图算法的一种,英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止,而且每个节点只能访问一次.

深搜主要的是一个回溯的过程，标记当前的点已经用过，在用过的基础上，进行下一步，当进行到了最后发现此点不能用，于是就回溯回来，因此造成了该算法的时间复杂度为（O（n!））；很容易造成超时，但是在部分题内，盲目搜索遍历一遍也挺挺快的，基本都是0ms，此算法，代码容易写，容易想，怪不得研究出dfs的两位神得了图灵奖，真6；

oj上边有很多适合练习深搜的题，如hdoj1045,还有最经典的n皇后问题，hdoj1258，南阳32组合数问题，南阳oj58最小步数问题，hdoj1016素数环问题，poj2362,zoj1003...（由于题目过多，只列取了经典的）；

附几道深经典搜题及代码：

组合数问题：



描述
找出从自然数1、2、... 、n（0<n<10）中任取r(0<r<=n)个数的所有组合。


输入输入n、r。
输出按特定顺序输出所有组合。
特定顺序：每一个组合中的值从大到小排列，组合之间按逆字典序排列。
样例输入
5 3

样例输出
543
542
541
532
531
521
432
431
421
321




附代码：


#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
int n,m,vis[1000],a[1000]={1000};
void dfs(int step)
{
	int i;
	if(step==n+1)
	{
		for(i=1;i<n;i++)
		printf("%d",a[i]);
		printf("%d\n",a[i]);	
	}
	for(i=m;i>=1;--i)
	{
		if(!vis[i]&&i<a[step-1])
		{
			vis[i]=1;
			a[step]=i;
			dfs(step+1);
			vis[i]=0;
		}
	}
}
int main()
{
	while(scanf("%d%d",&m,&n),m+n)
	{
		memset(vis,0,sizeof(vis));
		dfs(1);
	}
	return 0;
}
杭电1258：



Problem Description

Given a specified total t and a list of n integers, find all distinct sums using numbers from the list that add up to t. For example, if t=4, n=6, and the list is [4,3,2,2,1,1], then there are four different sums that equal 4: 4,3+1,2+2, and 2+1+1.(A number
 can be used within a sum as many times as it appears in the list, and a single number counts as a sum.) Your job is to solve this problem in general.


 


Input

The input will contain one or more test cases, one per line. Each test case contains t, the total, followed by n, the number of integers in the list, followed by n integers x1,...,xn. If n=0 it signals the end of the input; otherwise, t will be a positive integer
 less than 1000, n will be an integer between 1 and 12(inclusive), and x1,...,xn will be positive integers less than 100. All numbers will be separated by exactly one space. The numbers in each list appear in nonincreasing order, and there may be repetitions.


 


Output

For each test case, first output a line containing 'Sums of', the total, and a colon. Then output each sum, one per line; if there are no sums, output the line 'NONE'. The numbers within each sum must appear in nonincreasing order. A number may be repeated
 in the sum as many times as it was repeated in the original list. The sums themselves must be sorted in decreasing order based on the numbers appearing in the sum. In other words, the sums must be sorted by their first number; sums with the same first number
 must be sorted by their second number; sums with the same first two numbers must be sorted by their third number; and so on. Within each test case, all sums must be distince; the same sum connot appear twice.


 


Sample Input

4 6 4 3 2 2 1 1
5 3 2 1 1
400 12 50 50 50 50 50 50 25 25 25 25 25 25
0 0


 


Sample Output

Sums of 4:
4
3+1
2+2
2+1+1
Sums of 5:
NONE
Sums of 400:
50+50+50+50+50+50+25+25+25+25
50+50+50+50+50+25+25+25+25+25+25


 
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace  std;
int a[10100];
int res[10100]={10000};
int vis[10100],j,flag,n;
void dfs(int m,int cnt)
{
	int i;
	if(m==0)
	{
		flag=1;
		for(j=1;j<cnt-1;j++)
		printf("%d+",res[j]);
		printf("%d\n",res[j]);
		return ;
	}
	for(i=1;i<=n;i++)
	{
		if(!vis[i]&&m-a[i]>=0&&a[i]<=res[cnt-1])
		{
			vis[i]=1;
			res[cnt]=a[i];
			dfs(m-a[i],cnt+1);
			vis[i]=0;
			while(a[i]==a[i+1]&&i<=n)
			++i;
		}
	}
}
int main()
{
	int m,i,j;
	while(scanf("%d%d",&m,&n),(m||n))
	{
		for(i=1;i<=n;i++)
		scanf("%d",&a[i]);
		
		flag=0;
		printf("Sums of %d:\n",m);
		memset(vis,0,sizeof(vis));
		dfs(m,1);
		if(!flag)
		printf("NONE\n");
	}
}杭电1016，素数环问题，约瑟夫环：




Problem Description

A ring is compose of n circles as shown in diagram. Put natural number 1, 2, ..., n into each circle separately, and the sum of numbers in two adjacent circles should be a prime.

Note: the number of first circle should always be 1.




 


Input

n (0 < n < 20).


 


Output

The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely and anticlockwisely. The order of numbers must satisfy the above requirements. Print solutions in lexicographical order.

You are to write a program that completes above process.

Print a blank line after each case.


 


Sample Input

6
8


 


Sample Output

Case 1:
1 4 3 2 5 6
1 6 5 2 3 4

Case 2:
1 2 3 8 5 6 7 4
1 2 5 8 3 4 7 6
1 4 7 6 5 8 3 2
1 6 7 4 3 8 5 2


 


附代码 ：


#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
int vis[30],a[30],m,n;
int is(int n)
{
	for(int i=2;i*i<=n;i++)
	if(n%i==0)
	return 0;
	return 1;
}
void dfs(int n,int c)
{
	if(c==n)
	{
		if(is(a[n]+1))
		{
			printf("1");
			for(int i=2;i<=n;i++)
			printf(" %d",a[i]);
			printf("\n");
		}
		return ;
	}
	for(int i=2;i<=n;i++)
	{
		if(!vis[i]&&is(a[c]+i))
		{
		a[c+1]=i;
		vis[i]=1;
		dfs(n,c+1);
		vis[i]=0;
		}
	}
}
int main()
{
	int flag=1;
	while(~scanf("%d",&n))
	{
		memset(vis,0,sizeof(vis));
		printf("Case %d:\n",flag++);
		vis[1]=1;
		a[1]=1;
		dfs(n,1);
		printf("\n");
	}
	return 0;
}
杭电2553，n皇后问题：



Problem Description

在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。
你的任务是，对于给定的N，求出有多少种合法的放置方法。




Input

共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。

 


Output

共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。

 


Sample Input

1
8
5
0


 


Sample Output

1
92
10

附代码：


#include<stdio.h>  
#include<math.h>  
int x[15];//x数组表示放在该列的哪个位置，下标表示列，值表示放置在第几行   
int sum, n;  
bool place (int v)  
{  
    int i;  
    for(i=1;i<v;++i)  
    {  
        if(x[i] == x[v] || abs(x[i]-x[v])==abs(i-v))//如果在同一行,或在对角线方向（为什么这里不判断是否为同一列呢？主要是因为x数组表示放在该列的哪个位置）   
            return 0;  
    }  
    return 1;  
}  
void backtrack(int v)  
{  
    int i;  
    if(v>n) //把最后一个皇后放置成功后   
        sum++;  
    else  
    {  
        for(i=1;i<=n;++i) //找n个皇后   
        {  
            x[v]=i;  
            if(place(v))  
            {  
                backtrack(v+1);  
            }  
        }  
    }  
}  
int main()  
{     
    int ans[15];  
    for(n = 1; n <= 10; ++n)  
    {  
        sum = 0;  
        backtrack(1);  
        ans[n] = sum;     
    }     
    while(scanf("%d",&n), n)  
    {  
        printf("%d\n",ans[n]);  
    }  
    return 0;  
}  









版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 3874 Necklace(树状数组的离线操作)
题目链接：HDU 3874 Necklace



【题目大意】
组成项链的珠子有品级之分，价值从1~1000000不等，然而珠子的价值会有重复，例如一个项链有这6个珠子构成 1 1 1 2 3 1，
我们要求给定区间珠子的价值总和，如果区间内有相同价值的珠子，则只计算相同价值珠子中的一个；
用 F（左区间，右区间），来求区间和。

例如  F(1,3)=1,   F(2,4)=3,   F(2,6)=6.


区间求和问题用树状数组来做比较方便，但是重复数字怎么处理那？ 在网上学到了离线操作，非常巧妙


离线查询，顾名思义，不再是实时查询，而是根据需要先调整查询的顺序。



简单来讲就是将查询操作按照右区间从小到大排序。
然后从头依次遍历， 每次用map储存当前数字的最右区间，如果发现当前map值不为空，就删除节点（删除之前保存的数字最右区间），这样在求和的时候就不会重复计算相同的值了。


具体来看代码吧~


【源代码】
#include <iostream>
#include <cstdio>
#include <map>
#include <cstring>
#include <algorithm>
using namespace std;
int n;
typedef long long ll;
const  int maxn = 200010;
const  int maxe = 50010;
struct node{
	int l,r,po;
}order[maxn];
ll s[maxe];
int num[maxe];
ll ans[maxn];
bool cmp(const node&a,const node&b){
	return a.r<b.r; //按照右区间从小到大排序
}
int lowbit(int x)
{
	return x&(-x);
}
void modify(int x,int val){
	for(int i=x;i<=n;i+=lowbit(i)){
		s[i]+=val;
	}
}
ll sum(int x){
	ll ans = 0;
	for(int i=x;i>0;i-=lowbit(i))
		ans+=s[i];
	return ans;
}
int main(){
	int T;
	map<int ,int >mp;
	scanf("%d",&T);
	while(T--){
		memset(s,0,sizeof(s)); //储存树状数组要清空
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&num[i]);
		}
		int cmd;
		scanf("%d",&cmd);
		for(int i=1;i<=cmd;i++){
			scanf("%d%d",&order[i].l,&order[i].r);
			order[i].po = i; //记录下表，方便排序后寻找
		}
		sort(order+1,order+cmd+1,cmp);
		int r=1; //从开始依次遍历
		mp.clear();
		for(int i=1;i<=cmd;i++){
			while(r<=order[i].r){
				if(mp[num[r]])
					modify(mp[num[r]],-num[r]); //如果出现重复， 删去之前的节点，map中保存了上次出现的节点位置
				mp[num[r]]=r; //保存当前节点位置
				modify(r,num[r]); //更新树状数组
				r++;
			}
			ans [order[i].po]=sum(order[i].r)-sum(order[i].l-1); //每次直接求和
		}
		for(int i=1;i<=cmd;i++)
			printf("%lld\n",ans[i]);
	}
	return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

JAVA并发编程5_线程状态

JAVA线程的可能处于一下几种状态，任意的时间点一个线程只能处于一个状态。
1. 新建状态（New）：创建后尚未启动的线程处于这种状态。
转移时机：创建一个新线程。
2. 就绪状态（Runnable）：调用了start()方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
转移时机：调用start()方法。
处于Running状态的线程被CPU选择执行其他线程。
执行Thread.yeild()，不保证。
3. 运行状态（Running）：就绪状态的线程获得的了CPU的执行权，正在执行run方法。
转移时机：获得了CPU的执行权。
4. 阻塞（Blocked）：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
转移时机：已经有其他线程正在执行同步代码段，等待同步锁。
5. 无期限等待（Waiting）：不会被分配CPU的执行事件，要等待被其他线程显式的唤醒，以下方法导致线程陷入无期限等待：
转移时机：未设置timeout参数的Object.wait()方法
未设置timeout参数的Thread.join()方法
6. 期限等待（Time Waiting）：也不会被分配CPU执行事件，不过无需等待其他线程显式的唤醒，在一定时间之后会由系统自动唤醒。以下方法导致线程陷入期限等待：
转移时机：设置Timeout参数的Object.wait()方法
设置Timeout参数的Thread.join()方法
Thread.sleep(long)方法
7. 结束（Terminated）：线程执行完了，run方法退出。

HDU 3081--【二分图 &&  传递闭包 && 完美匹配次数 && 经典】

Marriage Match II
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2794    Accepted Submission(s): 938


Problem Description
Presumably, you all have known the question of stable marriage match. A girl will choose a boy; it is similar as the game of playing house we used to play when we are kids. What a happy time as so many friends playing together. And
 it is normal that a fight or a quarrel breaks out, but we will still play together after that, because we are kids.

Now, there are 2n kids, n boys numbered from 1 to n, and n girls numbered from 1 to n. you know, ladies first. So, every girl can choose a boy first, with whom she has not quarreled, to make up a family. Besides, the girl X can also choose boy Z to be her boyfriend
 when her friend, girl Y has not quarreled with him. Furthermore, the friendship is mutual, which means a and c are friends provided that a and b are friends and b and c are friend.

Once every girl finds their boyfriends they will start a new round of this game—marriage match. At the end of each round, every girl will start to find a new boyfriend, who she has not chosen before. So the game goes on and on.
Now, here is the question for you, how many rounds can these 2n kids totally play this game?

 

Input
There are several test cases. First is a integer T, means the number of test cases.

Each test case starts with three integer n, m and f in a line (3<=n<=100,0<m<n*n,0<=f<n). n means there are 2*n children, n girls(number from 1 to n) and n boys(number from 1 to n).
Then m lines follow. Each line contains two numbers a and b, means girl a and boy b had never quarreled with each other.

Then f lines follow. Each line contains two numbers c and d, means girl c and girl d are good friends.

 

Output
For each case, output a number in one line. The maximal number of Marriage Match the children can play.
 

Sample Input

1
4 5 2
1 1
2 3
3 2
4 2
4 4
1 4
2 3

 

Sample Output

2

 


题意：
有 2*n个同学，n男n女，有 m 对男女之间木有吵过架（有关系），f  对女生互为朋友（有关系），现在这 n 个女生要找对象，要求没有和她吵过架或者没有和她朋友吵过架，
当 n 个女生都找到对象的时候算作一轮，然后重新找，满足每个女生都不能找和上次一样的对象，问最多能进行多少轮。（可以理解为经过多少轮游戏不存在完美匹配）。

解析：
首先把女生之间的关系传递闭包一下。有关系的男女之间建边，构造二分图。每次用匈牙利算法求一下最大匹配。若是完美匹配，删去当前的边，接着求最大匹配，直到不是完美匹配为止。


#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 110
using namespace std;
int map[maxn][maxn];//男女关系
int node[maxn][maxn];//女生之间的朋友关系
int used[maxn];
int link[maxn];
int n, m, f;

void init(){
    memset(map, 0, sizeof(map));
    memset(node, 0, sizeof(node));
}

void floyd(){
    for(int k = 1; k <= n; ++k)
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= n; ++j)
                node[i][j] = node[i][j] || (node[i][k] && node[k][j]);
}


void getmap(){
    scanf("%d%d%d", &n, &m, &f);
    int a, b;
    while(m--){
        scanf("%d%d", &a, &b);
        map[a][b] = 1;
    }
    while(f--){
        scanf("%d%d", &a, &b);
        node[a][b] = node[b][a] = 1;
    }
    floyd();
    for(int i = 1; i <= n; ++i){//枚举每一个女生
        for(int j = 1; j <= n; ++j){
            if(node[i][j]){//女生i , j之间为朋友关系
                for(int k = 1; k <= n; ++k){
                    //若女生i 和男生 k 可以做伴侣，
                    //则女生j 和男生 k 也可以做伴侣
                    if(map[i][k])
                        map[j][k] = 1;
                }
            }
        }
    }
}

bool dfs(int x){
    for(int i = 1; i <= n; ++i){
        if(map[x][i] && !used[i]){
            used[i] = 1;
            if(link[i] == -1 || dfs(link[i])){
                link[i] = x;
                return true;
            }
        }
    }
    return false;
}

int hungary(){
    int ans = 0;
    memset(link, -1, sizeof(link));
    for(int i = 1; i <= n; ++i){
        memset(used, 0, sizeof(used));
        if(dfs(i))
            ans++;
    }
    return ans;
}

void solve(){
    int num = 0;
    while(1){
        int sum = hungary();
        if(sum == n){
            num++;
            for(int i = 1; i <= n; ++i)
                map[link[i]][i] = 0;
        }
        else
            break;
    }
    printf("%d\n", num);
}

int main (){
    int T;
    scanf("%d", &T);
    while(T--){
        init();
        getmap();
        solve();
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 2824:The Euler function【Euler】
The Euler function
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4509    Accepted Submission(s): 1873


Problem Description
The Euler function phi is an important kind of function in number theory, (n) represents the amount of the numbers which are smaller than n and coprime to n, and this function has a lot of beautiful characteristics. Here comes a very
 easy question: suppose you are given a, b, try to calculate (a)+ (a+1)+....+ (b)
 

Input
There are several test cases. Each line has two integers a, b (2<a<b<3000000).
 

Output
Output the result of (a)+ (a+1)+....+ (b)
 

Sample Input

3 100

 

Sample Output

3042

 

老是调用函数会超时，，，累加打表可解决～～；
AC-code:
#include<cstdio>
#define MAX 3000010
long long E[MAX];
void euler()
{
	int j,i;
	for(i=2;i<MAX;i++)
	{
		if(!E[i])
		for(j=i;j<MAX;j+=i)
		{
			if(!E[j])
				E[j]=j;
			E[j]=E[j]/i*(i-1);
		}
		E[i]+=E[i-1];
	}
}
int main()
{
	int a,b;
	euler();
	while(~scanf("%d%d",&a,&b))
	{
		printf("%lld\n",E[b]-E[a-1]);
	}
	return 0;
}

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

【php】global的使用与php的全局变量
php的全局变量和其余编程语言是不同的，在大多数的编程语言中，全局变量在其下的函数、类中自动生效，除非被局部变量覆盖，或者根本就不允许再声明相同名称与类型的局部变量，但是php中的全局变量不是默认生效的。php中全局变量在函数中使用时必须申明为全局，Global这个关键字在函数中定义才有用。也就是说Global的作用是定义全局变量，但是这个全局变量不是应用于整个网站，而是应用于当前页面，包括include或require的所有文件。 
直接用一个例子来说明此问题，如下代码：
<?php
$a=5;
function test(){
	echo $a;
}
test();
?>
很简单，声明一个全局变量$a=5，然后声明一个函数test()打印这个全局变量，之后，调用这个test()，按照一般的编程语言的思维，此处的输出必然为5，然而，在实际执行却是如下的效果：


直接报错的了，说这个a没有定义，简直是无法理喻，但是php就是这样设置，可是我却是需要使用到$a作为全局变量，有可能下面还有很多函数、很多类要使用这个$a啊！这是，你需要每次使用全局变量$a之间，用global这个关键字声明一下。
如下代码则是正确示范：
<?php
$a=5;
function test(){
	global $a;
	echo $a;
}
test();
?>运行结果如下，这样a就可以使用了，每次使用全局变量$a都要这样声明一下，这是php的规则。

值得注意的是，如下的代码是错误的：
<?php
global $a;
$a=5;
function test(){
	echo $a;
}
test();
?>运行结果同样如此：



版权声明：本文为博主原创文章，未经博主允许不得转载。

JVM之ClassLoader
为了支持跨平台的特性，java语言采用源代码编译成中间字节码，然后又各平台的jvm解释执行的方式。字节码采用了完全与平台无关的方式进行描述，java只给出了字节码格式的规范，并没有规定字节码最终来源是什么，它可以是除了java语言外的其他语言产生，只要是满足字节码规范的，都可以在jvm中很好的运行。正因为这个特性，极大的促进了各类语言的发展，在jvm平台上出现了很多语言，如scala，groovy等由于字节码来源并没有做限制，因此jvm必须在字节码正式使用之前，即在加载过程中，对字节码进行检查验证，以保证字节码的可用性和安全性。1. jvm运行时内存结构划分在正式介绍之前，先看看jvm内存结构划分：结合垃圾回收机制，将堆细化：在加载阶段主要用到的是方法区：方法区是可供各条线程共享的运行时内存区域。存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。如果把方法的代码看作它的“静态”部分，而把一次方法调用需要记录的临时数据看做它的“动态”部分，那么每个方法的代码是只有一份的，存储于JVM的方法区中；每次某方法被调用，则在该调用所在的线程的的Java栈上新分配一个栈帧，用于存放临时数据，在方法返回时栈帧自动撤销。2. 类加载过程jvm将类加载过程分成加载，连接，初始化三个阶段，其中连接阶段又细分为验证，准备，解析三个阶段。上述三个阶段总体上会保持这个顺序，但是有些特殊情况，如加载阶段与连接阶段的部分内容（一部分字节码的验证工作）是交叉进行的。再如：解析阶段可以是推迟初次访问某个类的时候，因此它可能出现在初始化阶段之后。2.1 装载装载阶段主要是将java字节码以二进制的方式读入到jvm内存中，然后将二进制数据流按照字节码规范解析成jvm内部的运行时数据结构。java只对字节码进行了规范，并没有对内部运行时数据结构进行规定，不同的jvm实现可以采用不同的数据结构，这些运行时数据结构是保存在jvm的方法区中(hotspot jvm的内部数据结构定义可以参见撒迦的博文借助HotSpot SA来一窥PermGen上的对象)。当一个类的二进制解析完毕后，jvm最终会在堆上生成一个java.lang.Class类型的实例对象，通过这个对象可以访问到该类在方法区的内容。jvm规范并没有规定从二进制字节码数据应该如何产生，事实上，jvm为了支持二进制字节码数据来源的可扩展性，它提供了一个回调接口将通过一个类的全限定名来获取描述此类的二进制字节码的动作开放到jvm的外部实现,这就是我们后面要讲到的类加载器，如果有需要，我们完全可以自定义一些类加载器，达到一些特殊应用场景。由于有了jvm的支持，二进制流的产生的方式可以是：(1) 从本地文件系统中读取(2) 从网络上加载（典型应用：java Applet）(3) 从jar，zip，war等压缩文件中加载(4) 通过动态将java源文件动态编译产生（jsp的动态编译）(5) 通过程序直接生成。2.2 连接连接阶段主要是做一些加载完成之后的验证工作，和初始化之前的准备一些工作，它细分为三个阶段。2.2.1 验证验证是连接阶段的第一步，它主要是用于保证加载的字节码符合java语言的规范，并且不会给虚拟机带来危害。比如验证这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。按照验证的内容不同又可以细分为4个阶段：文件格式验证（这一步会与装载阶段交叉进行），元数据验证，字节码验证，符号引用验证（这个阶段的验证往往会与解析阶段交叉进行）。2.2.2 准备准备阶段主要是为类的静态变量分配内存，并设置jvm默认的初始值。对于非静态的变量，则不会为它们分配内存。在jvm中各类型的初始值如下：int,byte,char,long,float,double 默认初始值为0boolean 为false（在jvm内部用int表示boolean，因此初始值为0）reference类型为null对于final static基本类型或者String类型，则直接采用常量值（这实际上是在编译阶段就已经处理好了）。2.2.3 解析解析过程就是查找类的常量池中的类，字段，方法，接口的符号引用，将他们替换成直接引用的过程。a.解析过程主要针对于常量池中的CONSTANT_Class_info,CONSTANT_Fieldref_info,CONSTANT_Methodref_info及CONSTANT_InterfaceMethodref_info四种常量。b. jvm规范并没有规定解析阶段发生的时间，只是规定了在执行anewarray,checkcast,getfield,getstatic,instanceof,invokeinterface,invokespecial,invokespecial,invokestatic,invokevirtual,multinewaary,new,putfield,putstatic这13个指令应用于符号指令时，先对它们进行解析，获取它们的直接引用.c. jvm对于每个加载的类都会有在内部创建一个运行时常量池（参考上面图示），在解析之前是以字符串的方式将符号引用保存在运行时常量池中，在程序运行过程中当需要使用某个符号引用时，就会促发解析的过程，解析过程就是通过符号引用查找对应的类实体，然后用直接引用替换符号引用。由于符号引用已经被替换成直接引用，因此后面再次访问时，无需再次解析，直接返回直接引用。2.3 初始化初始化阶段是根据用户程序中的初始化语句为类的静态变量赋予正确的初始值。这里初始化执行逻辑最终会体现在类构造器方法<clinit>()方中。该方法由编译器在编译阶段生成，它封装了两部分内容:静态变量的初始化语句和静态语句块。2.3.1 初始化执行时机jvm规范明确规定了初始化执行条件，只要满足以下四个条件之一，就会执行初始化工作(1) 通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法(对应new,getstatic,putstatic,invokespecial这四条字节码指令）。(2) 通过反射方式执行以上行为时。(3) 初始化子类的时候，会触发父类的初始化。(4) 作为程序入口直接运行时的主类。2.3.2 初始化过程初始化过程包括两步：(1) 如果类存在直接父类，并且父类没有被初始化则对直接父类进行初始化。(2) 如果类当前存在<clinit>()方法，则执行<clinit>()方法。需要注意的是接口（interface）的初始化并不要求先初始化它的父接口。（接口不能有static块）2.3.3 <clinit>()方法存在的条件并不是每个类都有<clinit>()方法,如下情况下不会有<clinit>()方法：a. 类没有静态变量也没有静态语句块b.类中虽然定义了静态变量，但是没有给出明确的初始化语句。c.如果类中仅包含了final static 的静态变量的初始化语句，而且初始化语句采用编译时常量表达时，也不会有<clinit>()方法。例子：public class ConstantExample {

    public static final int   a = 10;
    public static final float b = a * 2.0f;
}编译之后用 javap -verbose ConstantExample查看字节码,显示如下：{
public static final int a;
  Constant value: int 10
public static final float b;
  Constant value: float 20.0f
public ConstantExample();
  Code:
   Stack=1, Locals=1, Args_size=1
   0:	aload_0
   1:	invokespecial	#15; //Method java/lang/Object."<init>":()V
   4:	return
  LineNumberTable: 
   line 12: 0

  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   0      5      0    this       LConstantExample;

}这里由于编译器直接10，当作常量来处理，看到是没有<clinit>()方法存在的。可以当作常量来处理的类型包括基本类型和String类型对于其他类型：public class ConstantExample1 {

    public static final int   a = 10;
    public static final float b = a * 2.0f;
    public static final Date  c = new Date();
}这里虽然c被声明成final，但是仍然会产生<clinit>()方法，如下所示：{
public static final int a;
  Constant value: int 10
public static final float b;
  Constant value: float 20.0f
public static final java.util.Date c;

static {};
  Code:
   Stack=2, Locals=0, Args_size=0
   0:	new	#17; //class java/util/Date
   3:	dup
   4:	invokespecial	#19; //Method java/util/Date."<init>":()V
   7:	putstatic	#22; //Field c:Ljava/util/Date;
   10:	return
  LineNumberTable: 
   line 19: 0
   line 14: 102.3.4 并发性在同一个类加载器域下，每个类只会被初始化一次，当多个线程都需要初始化同一个类，这时只允许一个线程执行初始化工作，其他线程则等待。当初始化执行完后，该线程会通知其他等待的线程。2.4 在使用过程中类，对象在方法区和堆上的分布状态先上代码public class TestThread extends Thread implements Cloneable {

    public static void main(String[] args) {
        TestThread t = new TestThread();
        t.start();
    }
}上面这代码中TestThread及相关类在jvm运行的存储和引用情况如下图所示： 其中 t 作为TestThread对象的一个引用存储在线程的栈帧空间中，Thread对象及类型数据对应的Class对象实例都存储在堆上，类型数据存储在方法区，前面讲到了，TestThread的类型数据中的符号引用在解析过程中会被替换成直接引用，因此TestThread类型数据中会直接引用到它的父类Thread及它实现的接口Cloneable的类型数据。在同一个类加载器空间中，对于全限定名相同的类，只会存在唯一的一份类的实例及类型数据。实际上类的实例数据和其对应的Class对象是相互引用的。3. 类加载器上面已经讲到类加载器实际上jvm在类加载过程中的装载阶段开放给外部使用的一个回调接口，它主要实现的功能就是：将通过一个类的全限定名来获取描述此类的二进制字节码。当然类加载器的优势远不止如此，它是java安全体系的一个重要环节（java安全体系结构，后面会专门写篇文章讨论），同时通过类加载器的双亲委派原则等类加载器和class唯一性标识一个class的方式，可以给应用程序带来一些强大的功能，如hotswap。3.1 双亲委派模型在jvm中一个类实例的唯一性标识是类的全限定名和该类的加载器，类加载器相当于一个命名空间，将同名class进行了隔离。从jvm的角度来说，只存在两类加载器，一类是由c++实现的启动类加载器，是jvm的一部分，一类是由java语言实现的应用程序加载器，独立在jvm之外。jkd中自己定义了一些类加载器:(1).BootStrap ClassLoader：启动类加载器，由C++代码实现，负责加载存放在%JAVA_HOME%\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。(2).Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。(3).Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。参考ClassLoader源代码会发现，这些Class之间并不是采用继承的方式实现父子关系，而是采用组合方式。正常情况下，每个类加载在收到类加载请求时，会先调用父加载器进行加载，若父加载器加载失败，则子加载器进行加载。3.2 两种主动加载方式在java中有两种办法可以在应用程序中主动加载类:一种是Class类的forName静态方法public static Class<?> forName(String className) 
                throws ClassNotFoundException 
//允许指定是否初始化，并且指定类的类加载器
public static Class<?> forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException另一种就是ClassLoader中的loadClass方法protected synchronized Class<?> loadClass(String name, boolean resolve) //第二个参数表示是否在转载完后进行连接（解析）
	throws ClassNotFoundException

public Class<?> loadClass(String name) throws ClassNotFoundException上面这两种方式是有区别的，如下例所示public class InitialClass {

    public static int i;
    static {
        i = 1000;
        System.out.println("InitialClass is init");
    }

}public class InitClassTest {

    public static void main(String[] args) throws MalformedURLException, ClassNotFoundException {
        Class classFromForName = Class.forName("com.alibaba.china.jianchi.example.InitialClass",
                                               true,
                                               new URLClassLoader(
                                                                  new URL[] { new URL(
                                                                                      "file:/home/tanfeng/workspace/springStudy/bin/") },
                                                                  InitClassTest.class.getClassLoader()));

        Class classFromClassLoader = (new URLClassLoader(
                                                         new URL[] { new URL(
                                                                             "file:/home/tanfeng/workspace/springStudy/bin/") },
                                                         InitClassTest.class.getClassLoader())).loadClass("com.alibaba.china.jianchi.example.InitialClass");

    }
}通过运行可以考到用Class.forName()方法会将装载的类初始化，而ClassLoader.loadClass()方法则不会。我们经常会看到在数据库操作时，会用Class.forName()的方式加载驱动类，而不是ClassLoader.loadClass()方法，为何要这样呢？来看看mysql的驱动类实现，可以看到在类的初始化阶段，它会将自己注册到驱动管理器中（static块）。package com.mysql.jdbc;
public class Driver extends NonRegisteringDriver implements java.sql.Driver {

	static {
		try {
			java.sql.DriverManager.registerDriver(new Driver());
		} catch (SQLException E) {
			throw new RuntimeException("Can't register driver!");
		}
	}
      ... ...
}3.3 自定义类加载器的应用3.3.1 Tomcat中类加载器分析3.3.1.1 tomcat中通过自定义一组类加载器，解决了以下几个问题：（1）部署在一个服务器上的两个Web应用程序自身所使用的Java类库是相互隔离的。（2）部署在一个服务器上的两个Web应用程序可以共享服务器提供的java共用类库。（3）服务器尽可能的保证自身安全不受部署的Web应用程序影响。（4）支持对JSP的HotSwap功能。3.3.1.2 tomcat的目录结构tomcat主要根据根据java类库的共享范围，分为4组目录：（1）common目录：能被Tomcat和所有Web应用程序共享。 （2）server目录：仅能被Tomcat使用，其他Web应用程序不可见。 （3）Shared目录：可以被所有Web应用程序共享，对Tomcat不可见。 （4）WEB-INF目录：只能被当前Web应用程序使用，对其他web应用程序不可见。3.3.1.3 tomcat自定义类加载器这几个类加载器分别对应加载/common/*、/server/*、/shared/*和 /WEB-INF/*类库， 其中Webapp类加载器和Jsp类加载器会存在多个，每个Web应用对应一个Webapp类加载器。CommonClassLoader加载的类可以被CatalinaClassLoader和ShareClassLoader使用；CatalinaClassLoader加载的类和ShareClassLoader加载的类相互隔离； WebappClassLoader可以使用ShareClassLoader加载的类，但各个WebappClassLoader间相互隔离；JspClassLoader仅能用JSP文件编译的class文件。 
C#——await与async实现多线程异步编程
           以前，我们或许用过Thread，在主线程执行的时候，新开另一个新线程，来执行新方法。           今天看别人发给我的一段代码的时候发现了一个不认识的await,但是又感觉很熟悉的样子，感觉是线程那块儿的东西，查了下，发现一个简单的方法实现多线程异步编程。（PS：framework 在4.5以上才可以哦~）        /// <summary>
        /// 测试方法
        /// </summary>
        /// <remarks>创建者：刘慧超; 创建时间：2015-08-24 20:22:14</remarks>
        public async static  void AsyncPrintHelloWorld()
        {
            Console.WriteLine("异步方法调用开始");
            Console.WriteLine("异步方法：hello world");

            //.net framework 4.5及其以上版本
            await Task.Delay(1000); //此处开启新线程来处理，做个测试。。。
            Console.WriteLine("退出异步方法");
        }   main调用：            Console.WriteLine("===============异步方法调用===========");
            AsyncPrintHelloWorld();
            Console.WriteLine("*************现在执行的是主线程的方法**************");
            Console.ReadKey();   方法结果：                在方法上面加上关键字async,同时，对于方法中要开启新线程的地方，加入await关键字，则此处会另开一个线程去处理，主线程继续，这里的方法执行完给个结果。          挺好玩儿的，不知道哪天就用到了。。。。。。     

版权声明：本文为博主原创文章，未经博主允许不得转载。

C++构造函数初始化列表处提示出现 error: expected '{' before 'this'
1. C++构造函数初始化列表处提示出现 error: expected ‘{’ before ‘this’
问题描述下： 
Linux环境运行，使用g++编译，贴上如下代码出错处已标注于代码中。 
代码如下：
User(string& userName, string& password, string& nickname, uint8& state, string& IP, string& latestLoginTime, uint8& gender, string& mobile, string& email, string& image, string& signature, string& birthday):
this->userName(userName),//提示这里出错
this->password(password),
this->nickname(nickname),
this->state(state),
this->IP(IP),
this->latestLoginTime(latestLoginTime),this->gender(gender),this->mobile(mobile),this->email(email),this->image(image),this->signature(signature),this->birthday(birthday){};
这个问题困扰我很久，一直找不到错误的原因。在得知网友点拨后，才知道其原因是类对象完成初始化之前，类对象还未成形，不能使用this指针。以上问题的解决方案就是去掉this。

2. 初始化列表中不能使用this，那构造函数体内是否可以使用this呢？
答案是，当然可以，因为构造函数对成员数据的初始化在是在初始化列表中完成的，构造函数体内对数据成员所做的工作仅仅是赋值操作，在此之前，类成员数据已经完成了初始化工作，是由其默认构造函数完成的。所以，这也是编程原则中尽量使用初始化列表的原因。 
    验证代码如下：
class someClass{
    int num;
    string studentNmae;

public:
    someClass(const int& num,const string& name) :this->num(num),this->studentNmae(name)
    {}
};
以上代码编译不会通过，但是将类成员数据的初始化改为赋值，则没有问题，代码修改如下：
class someClass{
    int num;
    string studentNmae;
public:
someClass(const int& num,const string& name)
{
this->num=num;
        this->studentNmae=name;
}
};

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

java多线程（八）为什么弃用stop和suspend
转载请注明出处：http://blog.csdn.net/xingjiarong/article/details/47984659


初始的java版本中定义了一个stop方法来终止一个线程还定义了一个suspend方法来阻塞一个线程，直到另一个线程调用resume方法。这两个方法在Java SE 1.2之后就被弃用了，因为这两种方法都不安全，下面我们分别来讨论一下为什么不安全和应该怎样做才是安全的。


一、stop方法为什么不安全


其实stop方法天生就不安全，因为它在终止一个线程时会强制中断线程的执行，不管run方法是否执行完了，并且还会释放这个线程所持有的所有的锁对象。这一现象会被其它因为请求锁而阻塞的线程看到，使他们继续向下执行。这就会造成数据的不一致，我们还是拿银行转账作为例子，我们还是从A账户向B账户转账500元，我们之前讨论过，这一过程分为三步，第一步是从A账户中减去500元，假如到这时线程就被stop了，那么这个线程就会释放它所取得锁，然后其他的线程继续执行，这样A账户就莫名其妙的少了500元而B账户也没有收到钱。这就是stop方法的不安全性。


二、suspend方法为什么被弃用


suspend被弃用的原因是因为它会造成死锁。suspend方法和stop方法不一样，它不会破换对象和强制释放锁，相反它会一直保持对锁的占有，一直到其他的线程调用resume方法，它才能继续向下执行。
假如有A，B两个线程，A线程在获得某个锁之后被suspend阻塞，这时A不能继续执行，线程B在或者相同的锁之后才能调用resume方法将A唤醒，但是此时的锁被A占有，B不能继续执行，也就不能及时的唤醒A，此时A，B两个线程都不能继续向下执行而形成了死锁。这就是suspend被弃用的原因。




三、如何正确的终止一个线程



class MyThread extends Thread {
	public volatile boolean flag = true;

	public void run() {
		while (flag) {
			System.out.println("线程正在执行");
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		System.out.println("线程已终止");
	}
}

public class Main {

	public static void main(String[] args) {
		MyThread myThread = new MyThread();
		myThread.start();
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		myThread.flag = false;
		System.out.println("主线程结束！");
	}
}

我们可以采用设置一个条件变量的方式，run方法中的while循环会不断的检测flag的值，在想要结束线程的地方将flag的值设置为false就可以啦！注意这里要将flag设置成volitale的，因为volitale可以保证数据的有效性，如果不设置话，可能会造成子线程多执行一次的错误，例如子线程将flag读到自己线程栈中，flag的值为true，此时子线程的交出执行权，操作系统将执行权交给了主线程，主线程执行flag=false；的操作，希望子线程不要再执行了，但是这一改变子线程是不能看到的，所以子线程还会再向下执行一次，然后重新读取flag的值的时候才会终止。


当然你也可以将对flag所有操作都封装在synchronized关键字修饰的方法中，实现互斥访问，也可以达到相同的效果。


四、如何正确的阻塞线程


如果想安全的阻塞线程，引入一个变量suspendRequested并在run方法安全的地方测试它，安全的地方是指该线程没有封锁其他线程需要的对象的地方。当线程发现如果变量已被设置，将会保持等待状态直到它再次被获得为止。



public volatile boolean suspendRequested = false;
	private Lock suspendLock = new ReentrantLock();
	private Condition suspendCondition = suspendLock.newCondition();

	public void run() {

		while (true) {
			if (suspendRequested) {
				suspendLock.lock();
				try {
					while (suspendRequested)
						suspendCondition.await();
				} catch (Exception e) {

				} finally {
					suspendLock.unlock();
				}
			}
		}
	}

	public void requestSuspend() {
		suspendRequested = true;
	}

	public void requestResume() {
		suspendRequested = false;
		suspendLock.lock();
		try {
			suspendCondition.signalAll();
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			suspendLock.unlock();
		}
	}





版权声明：本文为博主原创文章，转载请注明出处，查看原文章，请访问：http://blog.csdn.net/xingjiarong

Blue Jeans
Description
The Genographic Project is a research partnership between IBM and The National Geographic Society that is analyzing DNA from hundreds of thousands of contributors to map how the Earth was populated.


As an IBM researcher, you have been tasked with writing a program that will find commonalities amongst given snippets of DNA that can be correlated with individual survey information to identify new genetic markers.


A DNA base sequence is noted by listing the nitrogen bases in the order in which they are found in the molecule. There are four bases: adenine (A), thymine (T), guanine (G), and cytosine (C). A 6-base DNA sequence could be represented as TAGACC.


Given a set of DNA base sequences, determine the longest series of bases that occurs in all of the sequences.

Input
Input to this problem will begin with a line containing a single integer n indicating the number of datasets. Each dataset consists of the following components:

A single positive integer m (2 <= m <= 10) indicating the number of base sequences in this dataset.
m lines each containing a single base sequence consisting of 60 bases. 

Output
For each dataset in the input, output the longest base subsequence common to all of the given base sequences. If the longest common subsequence is less than three bases in length, display the string "no significant commonalities"
 instead. If multiple subsequences of the same longest length exist, output only the subsequence that comes first in alphabetical order.

Sample Input
3
2
GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
3
GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA
GATACTAGATACTAGATACTAGATACTAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA
GATACCAGATACCAGATACCAGATACCAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA
3
CATCATCATCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
ACATCATCATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AACATCATCATTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
Sample Output
no significant commonalities
AGATAC
CATCATCAT



题解：求最长的公共字串并且按照字典序找最小的一个，由于长度小，暴力。
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>

using namespace std;

string s[20];

int main()
{
	int ncase;
	cin>>ncase;
	while(ncase--)
	{
		int n;
		scanf("%d",&n);
		for(int i = 0;i < n;i++)
		{
			cin>>s[i];
		}
		bool flag = false;
		string res = "Z";
		for(int i = 60;i > 2;i--)
		{
			for(int j = 0;j <= 60 - i;j++)
			{
				string s1(s[0],j,i);
				bool f = true;
				for(int k = 1;k < n;k++)
				{
					if(s[k].find(s1) == string::npos)
					{
						f = false;
						break;
					}
				}
				if(f)
				{
					if(res > s1)
					{
						res = s1;
					}
					flag = true;
				}
			}
			if(flag)
			{
				break;
			}
		}
		
		if(flag)
		{
			cout<<res<<endl;
		}
		else
		{
			cout<<"no significant commonalities\n";
		}
	}
	
	
	
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

C#深拷贝
C#的深拷贝，需要自己实现逻辑，目前我没有发现微软提供了可供调用的API。微软只是提供ICloneable接口，此接口只是为我们提供了一个规范，必须实现object Clone();方法，如下代码：
public class Person : ICloneable
{
    public int ID { get; set; }
    public string Name { get; set; }
    Object Clone(){
        Person newPerson = new Person();
        newPerson.ID = this.ID;
        newPerson.Name = this.Name;
        return newPerson;
    }
}
下面是调用方法：
Person oldPerson = new Person();
oldPerson.ID = 1;
oldPerson.Name = "Terry";
Person newPerson = (Person)oldPerson.Clone();
newPerson.Name = "Harry";
Console.WriteLine("old person's name is " + oldPerson.Name);//他们输出的Name是不一致的，所以说实现了深拷贝
Console.WriteLine("new person's name is " + newPerson.Name);
此时可能会有人问了，既然具体实现逻辑还要自己写，干嘛要继承ICloneable接口呢？ 
其实微软定义了这么个接口，是基于软件工程方面的考虑，提高代码的规范性。试想如果一个项目组有多个人在实现深拷贝，而又没有继承ICloneable这个接口，那么结果会是什么样呢？可以肯定的是，在接口、拷贝方法命名上会有多个版本存在。
当然，如果我们不想这么麻烦，可以考虑使用反射的机制来实现深拷贝，不过这样的话对性能会有影响，下面是样例代码：
public static class ExntedHelper
    {
        /// <summary>
        /// 深复制
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="source"></param>
        /// <returns></returns>
        public static T CopySameFieldObject<T>(this Object source)
        {
            Type _SrcT = source.GetType();
            Type _DestT = typeof(T);

            // 构造一个要转换对象实例
            Object _Instance = _DestT.InvokeMember("", BindingFlags.CreateInstance, null, null, null);

            // 这里指定搜索所有公开和非公开的字段
            FieldInfo[] _SrcFields = _SrcT.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

            // 将源头对象的每个字段的值分别赋值到转换对象里，因为假定字段都一样，这里就不做容错处理了
            foreach (FieldInfo field in _SrcFields)
            {
                if (field.GetValue(source) != null)
                        _DestT.GetField(field.Name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance).
                            SetValue(_Instance, field.GetValue(source));
            }

            return (T)_Instance;
        }
    }
调用代码：
Person oldPerson = new Person();
oldPerson.ID = 1;
oldPerson.Name = "Terry";
Person newPerson = oldPerson.CopySameFieldObject<Person>();
newPerson.Name = "Harry";
Console.WriteLine("old person's name is " + oldPerson.Name);//他们输出的Name是不一致的，所以说实现了深拷贝
Console.WriteLine("new person's name is " + newPerson.Name);

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

JavaScript中BOOLEAN类型之三种情景代码举例
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<title>无标题文档</title>
</head>

<body>
	<script language="javascript">
		/*
		* 一般性的true,false
		*/
		var flag = true;
		if(flag){
			alert('truetrue.............');
		}else{
			alert('falsefalse...........');
		}
	</script>
	
	<script language="javascript">
		/*
		*	一个对象不存在，为null时的true,false
		*/
		var obj = document.getElementById('id');
		if(obj){ //虽然这里的obj为null，但是可以解读为false
			alert('obj不为null表示true');
		} else{
			alert('obj为null时可识别为false');
		}
	</script>
	
	<script language="javascript">
		/*
		*  一个对象不存在为undefined时的true,false
		*/
		var a;
		if(a){//虽然a的值为undefined,但是这里可以解读为false
			alert('a的值不为undefined解读为true');
		} else {
			alert('a的值为undefined解读为false');
		}
	</script>
</body>
</html>


版权声明：本文为博主原创文章，未经博主允许不得转载。

Java虚拟机
纸上得来终觉浅，绝知此事要躬行
  --陆游       问渠那得清如许，为有源头活水来  --朱熹



一、JVM主要的结构如下：





二、各个区域功能介绍


1）、方法区（Method Area）：
        （1）用于存储虚拟机加载的类信息、常量、静态变量等，是各个线程共享的内存区域；
        （2）默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小；
        （3）方法区中还有一部分是运行时常量池，主要用来存储编译时生成的字面量和符号引用，常量也可以在运行时产生，如String的intern方法；
        （4）和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾收集。
2）、栈：
        （1）Java虚拟机栈是线程私有的，生命周期与线程相同。
        （2）每个方法被执行的时候都同时创建一个栈帧（stack frame），用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法执行完的过程就对应栈帧
    在栈中进入进出的过程。
        （3）JVM虚拟机栈中的局部变量表存储了编译期可知的各种基本数据类型。局部变量表所需要的空间在编译期就分配完成。
        （4）栈帧是方法运行期的基础数据结构。
3）、本地方法栈（Native Method Stack）：
        （1）本地方法栈为JVM虚拟机使用到的Native方法服务。
4）、堆（Heap）：
        （1）Java虚拟机所管理的内存中最大的一块。
        （2）Java堆是所有线程共享的区域，在虚拟机启动时创建。
        （3）内存区域的唯一目的就是存放对象实例，所有的对象实例以及数组都在堆上分配内存。
        （4）Java堆是JVM垃圾回收机制主要管理的内存区域，Java堆可以处于内存上不连续的内存空间。
5）、程序计数器：
        （1）一块比较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器
        （2）字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令、分支，循环、跳转、异常处理、线程恢复等都需要依赖程序计数器。
6）、运行时常量池：
        （1）运行时常量池是方法区的一部分。
        （2）Class文件中除了有类的版本、字段、方法接口描述等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载
        之后存放到方法区的运行时常量池。
7）、直接内存：
        由于Java引进了NIO，引入了通道和缓冲区的IO方式，可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响堆内存大小。



版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

C++中 pair 的用法


#include<iostream>
#include<string>
#include<map>
using namespace std;

// pair简单讲就是将两个数据整合成一个数据
// 本质上是有first, second两个成员变量的结构体
int main()
{
	// pair两种构造的方法
	// 方法1
	pair<string, double> pA("one", 1.11);// 浮点数默认是double, float的话有会警告。
	// 方法2
	pair<string, int> pB;
	pB = make_pair("two", 2);

	// pair的输出
	cout << "pA : " << pA.first << "  "<< pA.second << endl;
	cout << "pB : " << pB.first << "  "<< pB.second << endl;


	// 结合map的使用
	map<string, double> mA;
	map<string,int>mB;
	mA.insert(pA);
	mB.insert(pB);

	for (map<string, double>::iterator it = mA.begin(); it != mA.end(); ++it)
	{
		cout << "First Member of mA:  " << it->first << endl;
		cout << "Second Member of mA: " << it->second << endl;
	}

	for (map<string, int>::iterator it = mB.begin(); it != mB.end(); ++it)
	{
		cout << "First Member of mB:  " << it->first << endl;
		cout << "Second Member of mB: " << it->second << endl;
	}
	return 0;
}








#include<algorithm>
#include<iostream>
#include<sstream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<string>
#include<map>
#include<set>
using namespace std;

map<string, int> m;
pair<string,int> p;

int main() {

    p = make_pair("one",1);//make_pair(),返回一个pair类型

    cout << p.first << endl;//输出p的key，也就是"one";

    cout << p.second << endl;//输出p的value，也就是1

    m.insert(make_pair("two",2));

    map<string, int>::iterator mit;

    mit = m.begin();

    cout << mit->first << endl;
    
    cout << mit->second << endl;//分别输出“two”，和2

    return 0;
}




#include <iostream>
#include <string>
#include <vector>
using namespace std;

int main()
{
    pair<string, string> anon;    // 包含两个字符串
    pair<string, int> word_count; // 包含字符串和整数
    pair<string, vector<int> > line; // 包含字符串和一个int容器

    pair<string, string> author("James", "Joyce"); // 定义成员时初始化
    cout << author.first << " - " << author.second << endl;

    string firstBook;             // 使用 . 访问和测试pair数据成员
    if (author.first == "James" && author.second == "Joyce") {
        firstBook = "Stephen Hero";
        cout << firstBook << endl;
    }

    typedef pair<string, string> Author; // 简化声明一个作者pair类型
    Author proust("Marcel", "Proust");
    Author Joyce("James", "Joyce");

    pair<string, string> next_auth;
    string first, last;
    while (cin >> first >> last) {
        // 使用make_pair函数生成一个新pair对象
        next_auth = make_pair(first, last);
        // 使用make_pair函数，等价于下面这句
        next_auth = pair<string, string> (first, last);

        cout << next_auth.first << " - " << next_auth.second << endl;
        if (next_auth.first == next_auth.second)
            break; // 输入两个相等,退出循环
    }

    cout <<  "因为pair的数据成员是共有的，因而可以直接读取输入" << endl;
    while (cin >> next_auth.first >> next_auth.second) {

        cout << next_auth.first << " - " << next_auth.second << endl;
        if (next_auth.first == next_auth.second)
            break;
    }

    return 0;
}


暂时只会这么简单的用法，刚学到的……





版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        Java高手需要注意的25个学习目标
1.你需要精通面向对象分析与设计(OOA/OOD)、涉及模式(GOF，J2EEDP)以及综合模式。你应该了解UML，尤其是class，object，interaction以及statediagrams。　　2.你需要学习Java语言的基础知识以及它的核心类库(collections，serialization，streams，networking，?multithreading，reflection，event，handling，NIO，localization，以及其他)。　　3.你应该了解JVM，classloaders，classreflect，以及垃圾回收的基本工作机制等。你应该有能力反编译一个类文件并且明白一些基本的汇编指令。　　4.如果你将要写客户端程序，你需要学习Web的小应用程序(applet)，必需掌握GUI设计的思想和方法，以及桌面程序的SWING，AWT，?SWT。你还应该对UI部件的JavaBEAN组件模式有所了解。JavaBEANS也被应用在JSP中以把业务逻辑从表现层中分离出来。　　5.你需要学习Java数据库技术，并且会使用至少一种persistence/ORM构架，例如Hibernate，JDO，?CocoBase，TopLink，InsideLiberator(国产JDO红工厂软件)或者iBatis。　　6.你还应该了解对象关系的阻抗失配的含义，以及它是如何影响业务对象的与关系型数据库的交互，和它的运行结果，还需要掌握不同的数据库产品运用，比如racle，mysql，mssqlserver。　　7.你需要学习Servlets，JSP，以及JSTL(StandardTagLibraries)和可以选择的第三方TagLibraries。　　8.你需要熟悉主流的网页框架，例如JSF，Struts，Tapestry，Cocoon，WebWork，以及他们下面的涉及模式，如MVC/MODEL2。　　9.你需要学习如何使用及管理Web服务器，例如tomcat，resin，Jrun，并且知道如何在其基础上扩展和维护Web程序。　　10.你需要学习分布式对象以及远程API，例如RMI和RMI/IIOP。　　11.你需要掌握各种流行中间件技术标准和与Java结合实现，比如Tuxedo、CROBA，当然也包括JavaEE本身。　　12.你需要学习最少一种的XMLAPI，例如JAXP(JavaAPIforXMLProcessing)，JDOM(JavaforXMLDocumentObjectModel)，DOM4J，或JAXR(JavaAPIforXMLRegistries)。　　13.你应该学习如何利用Java的API和工具来构建WebService。例如JAX-RPC(JavaAPIforXML/RPC)，SAAJ?(SOAPwithAttachmentsAPIforJava)，JAXB(JavaArchitectureforXMLBinding)，JAXM(JavaAPIforXMLMessaging)，?JAXR(JavaAPIforXMLRegistries)，或者JWSDP(JavaWebServicesDeveloperPack)。　　14.你需要学习一门轻量级应用程序框架，例如Spring，PicoContainer，Avalon，以及它们的IoC/DI风格(setter，constructor，interfaceinjection)。　　15.你需要熟悉不同的J2EE技术，例如JNDI(JavaNamingandDirectoryInterface)，JMS?(JavaMessageService)，JTA/JTS(JavaTransactionAPI/JavaTransactionService)，JMX?(JavaManagementeXtensions)，以及JavaMail。　　16.你需要学习企业级JavaBeans(EJB)以及它们的不同组件模式：Stateless/StatefulSessionBeans，EntityBeans(包含Bean-?ManagedPersistence[BMP]或者Container-ManagedPersistence[CMP]和它的EJB-QL)，或者?Message-DrivenBeans(MDB)。　　17.你需要学习如何管理与配置一个J2EE应用程序服务器，如WebLogic，JBoss等，并且利用它的附加服务，例如簇类，连接池以及分布式处理支援。你还需要了解如何在它上面封装和配置应用程序并且能够监控、调整它的性能。　　18.你需要熟悉面向方面的程序设计以及面向属性的程序设计(这两个都被很容易混淆的缩写为AOP)，以及他们的主流Java规格和执行。例如AspectJ和AspectWerkz。　　19.你需要熟悉对不同有用的API和framework等来为你服务。例如Log4J(logging/tracing)，Quartz?(scheduling)，JGroups(networkgroupcommunication)，JCache(distributedcaching)，?Lucene(full-textsearch)，JakartaCommons等等。　　20.你应该熟练掌握一种JavaIDE例如sunOne，netBeans，IntelliJIDEA或者Eclipse。(有些人更喜欢VI或EMACS来编写文件。随便你用什么了：)　　21.Java(精确的说是有些配置)是冗长的，它需要很多的人工代码(例如EJB)，所以你需要熟悉代码生成工具，例如XDoclet。　　22.你需要熟悉一种单元测试体系(JNunit)，并且学习不同的生成、部署工具(Ant，Maven)。　　23.你需要熟悉一些在Java开发中经常用到的软件工程过程。例如RUP(RationalUnifiedProcess)andAgilemethodologies。　　24.你还需要紧跟Java发展的步伐，比如现在可以深入的学习Webwork2.0　　25.你必需要对实际项目的开发流程有所了解，至少要有两个有实际应用价值的项目，而不是练习项目!因为现在企业看重的是你有没有实际的开发经验，真正开发经验的体现就是你做的项目，也就是有实际应用的项目!

版权声明：感觉我写的还算不错的的话希望你能够动动你的鼠标和键盘为我点上一个赞或是为我奉献上一个评论，在下感激不尽!_______________________________________________________欢迎转载，希望在你转载的同时，添加原文地址，谢谢配合

poj2362Square

Square




Time Limit: 3000MS
 
Memory Limit: 65536K


Total Submissions: 21988
 
Accepted: 7691




Description

Given a set of sticks of various lengths, is it possible to join them end-to-end to form a square?
Input

The first line of input contains N, the number of test cases. Each test case begins with an integer 4 <= M <= 20, the number of sticks. M integers follow; each gives the length of a stick - an integer between 1 and 10,000.
Output

For each case, output a line containing "yes" if is is possible to form a square; otherwise output "no".
Sample Input
3
4 1 1 1 1
5 10 20 30 40 50
8 1 7 2 6 4 4 3 5

Sample Output
yes
no
yes

Source
Waterloo local 2002.09.21
很不错的一道题，就是说 给若干个小木棍，看是否能拼成一个正方形形，拼成一个矩形要满足所有木棍的总长度对4取余等于0，还得满足最长的一根小木棍不能长于所拼成正方形的边长。
正常考虑，要所围成的图形为正方形，需要检测一条边和别的边长度加到一块是否为正方形的边长，这个边长可能为一个木棍，也可能是两个木棍，三个木棍，四个，五个.....
计算时 计算到当前所加的木棍长度，如果当前的长度加上下一个木棍的长度大于所拼成正方形的边长，则不能判定为次状态无解，可能是加上别的一条，两条，三条...等于了所求的边长，如果把所有的情况加上了依然无解，依旧不能断定次木棍不能组成矩形，还可能当前本身加上的木棍长度就不合理，所以本题不用深搜无解
深搜（深入优先搜索（DFS）），当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,算法复杂度很高，就是把所有的点都遍历了一遍，不过代码很简单，很容易写，毕竟是时间复杂度为（O(n!)）;
本题大致做法就是对所有小棒子长度求和sum，sum就是正方形的周长，sum/4就是边长side。
问题就转变为：这堆小棒子能否刚好组合成为4根长度均为side的大棒子
 
不难了解，小棒子的长度越长，其灵活性越差。例如长度为5的一根棒子的组合方式要比5根长度为1的棒子的组合方式少，这就是灵活性的体现。
由此，我们首先要对这堆小棒子降序排序，从最长的棒子开始进行DFS
 
剪枝，有3处可剪：
1、  要组合为正方形，必须满足sum%4==0；
2、  所有小棒子中最长的一根，必须满足Max_length <= side，这是因为小棒子不能折断；
3、  当满足条件1、2时，只需要能组合3条边，就能确定这堆棒子可以组合为正方形。
 

附ac代码：
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
int a[21],i,j,k,l,m,n,mid,vis[1000],num;
long sum;
int dfs(int num,int len,int s) 
{                                                      
    if(num==3)  //如果已经得到的可构成变长的数位3  则不需要计算，剩下的一定能构成  
        return 1;  
    for(int i=s;i<=n;i++)  
    {
        if(vis[i])  //如果该木棍已经被使用，则无法继续使用 
            continue;  
  
        vis[i]=1;  //如果该木棍未被使用，则把该木棍标记为已经使用过了 
        if(len+a[i]<mid)  //得到的当前长度未达到边长 
        {  
            if(dfs(num,len+a[i],i))  //继续访问下一个 
                return 1;  
        }
        else if(len+a[i]==mid)  //得到的当前长度达到边长
        {  
            if(dfs(num+1,0,1))  //num+1,当前长度记为0； 
                return 1;  
        }  
        vis[i]=0;  //如果未到达要求，释放该点，以备下次别的情况访问 
    }  
    return 0;  
}  
int main()
{
	scanf("%d",&m);
	while(m--)
	{
		scanf("%d",&n);
		sum=0;
		for(i=1;i<=n;i++)
		{
		scanf("%d",&a[i]);
		sum+=a[i];//先求和，得到总长度。 
		}
		sort(a+1,a+n+1);//将所有的 木棍进行从小到大排序，sort里边逗号是该数组最后一个成员的地址的下一位 
		mid=sum/4;//在进行除法，得到边长 
		if(mid*4!=sum)//如果边长非整数 ，则不需要计算 
		//if(sum%4) 
		printf("no\n");
		else if(a[n]>mid)//如果最长的边大于了边长，因为小木棍不可分割，所以也不需要判断 
		printf("no\n");
		else
		{
		num=0;
		memset(vis,0,sizeof(vis));
		if(dfs(0,0,1))//第一个0代表 已经得到的可构成的边长数，第二个代表当前所得木棍和的长度，1代表搜索的地址 
		printf("yes\n");
		else
		printf("no\n");
		}
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 4407 Sum（容斥原理+质因数分解）
HDU 4407
题意：
给一个长度为n的序列，序列由1~n依次组成。 
对序列执行两种操作： 
1.查询[x,y]内与p互素的数的和； 
2.修改第x数为c.
思路：
往线段树的方向想了半天，发现就是容斥原理略微变形，脑残不可医啊。。
修改操作可以用map进行映射。
查询操作的话我们就把序列一直当做1~n的序列来查询，然后迭代器跑一遍map判断对查询有无影响即可，总之操作最多2000次； 
对于查询操作，我们可以先分解出p的质因数，设p的每种质因数组合的里的质因数乘积为value，那么[x,y]内value的倍数与p必定不互素，求出value的区间[x,y]内所有倍数和（用等比数列求和公式），然后对结果进行容斥求和，即得出区间[x,y]内与p不互素的数的和sum，然后区间所有数的和（用等差数列求和公式）减去sum即可。
代码：
/*
* @author FreeWifi_novicer
* language : C++/C
*/
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<string>
#include<map>
#include<set>
#include<vector>
#include<queue>

using namespace std;

#define clr( x , y ) memset(x,y,sizeof(x))
#define cls( x ) memset(x,0,sizeof(x))
#define mp make_pair
#define pb push_back
typedef long long lint;
typedef long long ll;
typedef long long LL;

map<int , int>v ;
vector<int>fac ;

int gcd( int x , int y ){
    if( y == 0 ) return x ;
    return gcd( y , x % y ) ;
}

lint cal( int l , int r , int val ){
    int n = ( r / val ) - ( ( l - 1 ) / val ) ;
    int a1 = ( l % val == 0 )? l : ( val - l % val ) + l ;
    int an = r - r % val ;
    lint res = (lint)( a1 + an ) * (lint)n / 2 ; // 等比数列求和公式
    return res ;
}

lint work( int l , int r , int p ){
    fac.clear() ;
    for( int i = 2 ; i * i <= p ; i++ ){
        if( p % i == 0 ){
            fac.pb( i ) ;
            while( p % i == 0 ) p /= i ;
        }
    }
    if( p > 1 ) fac.pb( p ) ;
    int s = fac.size() ;
    lint res = 0 ;
    for( int i = 1 ; i < ( 1 << s ) ; i++ ){
        int bits = 0 ;
        lint val = 1 ;
        for( lint j = 0 ; j < s ; j++ ){
            if( i & ( 1 << j ) ){
                bits++ ;
                val *= fac[j] ;
            }
        }
        lint tmp = cal( l , r , val ) ;
        if( bits & 1 ) // 容斥原理
            res += tmp ;
        else
            res -= tmp ;
    }
    lint sum =  (lint)( l + r ) * (lint)( r - l + 1 ) / 2 ;
    res = sum - res ; // 等差数列求和公式
    return res ;
}

lint solve( int l , int r , int p ){
    lint res = work( l , r , p ) ;
    if( v.empty() ) return res ;

    map<int,int>::iterator it ;
    for( it = v.begin() ; it != v.end() ; it++ ){
        lint x = it->first , y = it->second ;
        if( x > r || x < l ) continue ;
        if( gcd( x , p ) == 1 ) res -= x ;
        if( gcd( y , p ) == 1 ) res += y ;
    }
    return res ;
}

int main(){
  //freopen("input.txt","r",stdin);
    int t ; cin >> t ;
    while( t-- ){
        v.clear() ;
        int n , m ;
        cin >> n >> m ;
        for( int i = 1 ; i <= m ; i++ ){
            int op ;
            scanf( "%d" , &op ) ;
            if( op == 1 ){
                int l , r , p ;
                scanf( "%d%d%d" , &l , &r , &p ) ;
                if( l > r ) swap( l , r ) ;
                lint ans = solve( l , r , p ) ;
                printf( "%I64d\n" , ans ) ;
            }
            else if( op == 2 ){
                int pos , x ;
                scanf( "%d%d" , &pos , &x ) ;
                v[pos] = x ;
            }
        }
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：博主表示授权一切转载啦：）

HDOJ  2546  饭卡(01背包)
饭卡

Time Limit: 5000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)

Total Submission(s): 16626    Accepted Submission(s): 5783


Problem Description
电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。
某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。

 


Input
多组数据。对于每组数据：
第一行为正整数n，表示菜的数量。n<=1000。
第二行包括n个正整数，表示每种菜的价格。价格不超过50。
第三行包括一个正整数m，表示卡上的余额。m<=1000。

n=0表示数据结束。

 


Output
对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。
 


Sample Input

1
50
5
10
1 2 3 2 1 1 2 3 2 1
50
0

 


Sample Output

-45
32

 


解题思路： 卡上余额减去5为可用余额，可用余额所能购买到的最大价值加上最大菜价就是余额所能购买到的最大价值。 卡上的最小余额即为余额减去余额所能购买的最大价值。




具体代码如下：


<span style="font-size:18px;">#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int main()
{
	int n,m,i,j;
	int val[1010],dp[1010];
	while(scanf("%d",&n)&&n)
	{
		for(i=0;i<n;++i)
		   scanf("%d",&val[i]);
		sort(val,val+n);
		scanf("%d",&m);
		if(m<5)//若m小于5，则不能购买菜品，余额为m 
		{
			printf("%d\n",m);
			continue;
		}
		m-=5;//可用余额 
		memset(dp,0,sizeof(dp));
		for(i=0;i<n-1;++i)//最大菜价不参与 
		{
			for(j=m;j>=val[i];j--)
			   dp[j]=max(dp[j],dp[j-val[i]]+val[i]);//可用余额购买到的最大价值 
		}
		printf("%d\n",m+5-dp[m]-val[n-1]);//余额减去  可用余额购买的最大价值与最大菜价的和 
	}
	return 0;
}</span>








版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA - 11082 Matrix Decompressing(最大流＋行列模型)
题目大意：给出一个R行C列的矩阵，现在给出他的前1-R行和 && 前1-C列和，问这个矩阵原来是怎样的，要求每个元素大小在1-20之间
解题思路：将每一行连接到超级源点，容量为该行的和-列数 
将每一列连接到超级汇点，容量为该列的和-行数 
接着将每行连接到该行的每一个元素，容量为19 
将每个元素连接到元素所在列，容量为19 
为什么容量为19，因为跑最大流的时候有可能边的流量为0，而他要求的是每个数的范围在1-20之间，所以最后的答案都要加上1，这也解释了为什么连接到超级源点和超级汇点的容量要减去相应的值
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
#define N 1010
#define INF 0x3f3f3f3f

struct Edge{
    int from, to, cap, flow;
    Edge() {}
    Edge(int from, int to, int cap, int flow) : from(from), to(to), cap(cap), flow(flow) {}
};

struct Dinic{
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[N];
    bool vis[N];
    int d[N], cur[N];

    void init(int n) {
        this->n = n;
        for (int i = 0; i <= n; i++) {
            G[i].clear();
        }
        edges.clear();
    }

    void AddEdge(int from, int to, int cap) {
        edges.push_back(Edge(from, to, cap, 0));
        edges.push_back(Edge(to, from, 0, 0));
        int m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    } 

    bool BFS() {
        memset(vis, 0, sizeof(vis));
        queue<int> Q;
        Q.push(s);
        vis[s] = 1;
        d[s] = 0;

        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for (int i = 0; i < G[u].size(); i++) {
                Edge &e = edges[G[u][i]];
                if (!vis[e.to] && e.cap > e.flow) {
                    vis[e.to] = true;
                    d[e.to] = d[u] + 1;
                    Q.push(e.to);
                }
            }
        }
        return vis[t];
    }

    int DFS(int x, int a) {
        if (x == t || a == 0)
            return a;

        int flow = 0, f;
        for (int i = cur[x]; i < G[x].size(); i++) {
            Edge &e = edges[G[x][i]];
            if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0) {
                e.flow += f;
                edges[G[x][i] ^ 1].flow -= f;
                flow += f;
                a -= f;
                if (a == 0)
                    break;
            }
        }
        return flow;
    }

    int Maxflow(int s, int t) {
        this->s = s; this->t = t;
        int flow = 0;
        while (BFS()) {
            memset(cur, 0, sizeof(cur));
            flow += DFS(s, INF);
        }
        return flow;
    }
};

Dinic dinic;

int n, m, cas = 1;
int SumRow[N], SumCol[N], row[N], col[N];
void init() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) 
        scanf("%d", &SumRow[i]);
    for (int i = 1; i <= m; i++)
        scanf("%d", &SumCol[i]);

    int source = 0, sink = n * m + n + m + 1;
    dinic.init(sink);


    row[1] = SumRow[1];
    dinic.AddEdge(source, n * m + 1, row[1] - m);
    for (int i = 2; i <= n; i++) {
        row[i] = SumRow[i] - SumRow[i - 1];
        dinic.AddEdge(source, n * m + i, row[i] - m);
    }

    col[1] = SumCol[1];
    dinic.AddEdge(n * m + n + 1, sink, SumCol[1] - n);
    for (int i = 2; i <= m; i++) {
        col[i] = SumCol[i] - SumCol[i - 1];
        dinic.AddEdge(n * m + n + i, sink, col[i] - n);
    }

    for (int i = 0; i < n; i++)
        for (int j = 1; j <= m; j++) {
            dinic.AddEdge(n * m + i + 1, i * m + j, 19);
            dinic.AddEdge(i * m + j, n * m + n + j, 19);
        }
    int ans = dinic.Maxflow(source, sink);
    printf("Matrix %d\n", cas++);
    for (int i = 0; i < n; i++) {
        for (int j = 1; j <= m; j++) {
            if (j != 1)
                printf(" ");
            for (int k = 0; k < dinic.G[i*m+j].size(); k++) {
                int u = dinic.edges[dinic.G[i*m+j][k]].from;
                int v = dinic.edges[dinic.G[i*m+j][k]].to;

                if (u == i * m + j && v == n * m + n + j) {
                    printf("%d", dinic.edges[dinic.G[i*m+j][k]].flow + 1);
                    break;
                }
            }
        }
        printf("\n");
    }
}

int main() {
    int test;
    scanf("%d", &test);
    while (test--) {
        init();
        if (test)
            printf("\n");
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

java多线程（七）提高锁的效率——使用读写锁
转载请注明出处：http://blog.csdn.net/xingjiarong/article/details/47947515
之前我们讲过ReentrantLock，这种锁不区分读操作和写操作，如果有一个线程在执行读操作，那么其他的所有的线程不能进行任何的读操作或者写操作。这样可以保证程序的互斥性，但是降低了程序的并发性，使执行效率降低，没有有效的发挥多线程的优势。比如说，有一个系统，主要是以读操作为主，比如有10个线程负责读数据，只有一个线程负责写数据。如果用我们之前的ReentrantLock方法，这10个线程中没有哪两个线程是可以同时执行的，但是我们仔细想一下，如果一个线程在执行读操作，那么其他的读线程可以执行吗？当然是可以的啊，因为读操作不会改变数据，自然不会造成数据错误，所以针对这种情况，java中有一个ReentrantReadWriteLock，用来控制读写操作。


这种锁分为两种，读锁和写锁。如果一个线程获得了读锁，那么其他的执行读操作的线程可以继续获得该读锁，也就是说读操作可以并发的执行，但是其他的写锁将会被阻塞。如果一个线程获得了写锁，那么其他的任何试图获得读锁和写锁的线程都将被阻塞。


我们来看一个例子：



import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWrite {
	private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
	private Lock readLock;
	private Lock writeLock;
	private int num = -1;

	public ReadWrite() {
		readLock = lock.readLock();
		writeLock = lock.writeLock();
	}
	
	public void read(){
		while(true){
			try{
				readLock.lock();
				System.out.println(Thread.currentThread()+"准备读取数据!");
				Thread.sleep(1000);
				System.out.println(Thread.currentThread()+"读取的数据为"+num);
			}catch(Exception e){
				e.printStackTrace();
			}finally{
				readLock.unlock();
			}
		}
		
	}
	
	public void write(){
		while(true){
			try{
				writeLock.lock();
				System.out.println(Thread.currentThread()+"准备写入数据");
				Thread.sleep(1000);
				num = (int)(Math.random()*10);
				System.out.println(Thread.currentThread()+"已经写入数据"+num);
			}catch(Exception e){
				e.printStackTrace();
			}finally{
				writeLock.unlock();
			}
		}
		
	}
}




public class Main {

	public static void main(String[] args) {
		final ReadWrite rd = new ReadWrite();
		
		for(int i=0;i<3;i++){
			new Thread(new Runnable() {
				
				@Override
				public void run() {
					rd.read();
				}
			}).start();;
		}
		
		new Thread(new Runnable() {
			
			@Override
			public void run() {
				rd.write();
			}
		}).start();
	}

}






在ReadWrite类中声明了一个ReentrantReadWriteLock和一个int型的变量，ReentrantReadWriteLock中有两个方法readLock（）和writeLock（），分别用来获得读锁和写锁。ReadWrite类有read和write，分别用来读取num的值和改变num的值。在主程序中，有三个线程负责读数据，一个线程负责写数据。运行效果如下：





我们可以清楚的看到，三个读取的线程是同时执行的，但是写操作是不能喝读操作一起执行的。所以以后在执行读操作和写操作时可以考虑使用读写锁。



版权声明：本文为博主原创文章，转载请注明出处，查看原文章，请访问：http://blog.csdn.net/xingjiarong

Qt  QString的arg()方法的使用
QString的arg()方法用于填充字符串中的%1,%2...为给定的参数，如
QString m = tr("%1:%2:%3").arg("12").arg("60").arg("60");    // m = "12:60:60:
它还有另外一种重载方法：
QString QString::​arg(int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' )) const



这个方法用于填充字符串中的%1,%2...为给定格式的整形数字，其中第一个参数是要填充的数字，第二个参数为最小宽度，第二个参数为进制，第四个参数为当原始数字长度不足最小宽度时用于填充的字符。


如
        QString text = QString("%1:%2")
                       .arg(123, 5, 10, QChar('0'))
                       .arg(456, 5, 10, QChar('0'));    // text = "00123:00456"



版权声明：本文为博主原创文章，未经博主允许不得转载。

《C算法》读书笔记9：希尔排序的性质研究
接上文。增量序列h有两条重要性质： 
首先，定义h排序结束后的数组为h有序。 
1、k排序一个h有序的数组，得到的数组既为k有序也为h有序。 
2、当k、h互质时，对该新数组进行g排序，比较次数少于N(k−1)(h−1)/gN(k - 1)(h - 1)/g 
下面是一个很不错的增量序列hi=1,8,23,77,281,1073,4193,16577...h_i = {1, 8, 23, 77, 281, 1073, 4193, 16577...}，经实验发现，它的表现好于hn=3hn−1+1h_n=3h_{n-1}+1与hn=2hn−1+1h_n=2h_{n-1}+1。有文献证明，该序列的希尔排序复杂度下界为O(N4/3)O(N^{4/3})。 
更进一步，根据性质2，假如一个2有序且3有序的数组进行最后一遍排序（1排序），比较次数为线性。
以下是N=20000N=20000时的一组完全随机实验数据：
hn=2hn−1+1h_n=2h_{n-1}+1 
8191 4095 2047 1023 511 255 127 63 31 15 7 3 1  
shell sort step 321464
hn=3hn−1+1h_n=3h_{n-1}+1 
这是Knuth在1969年提出的增量数列 
9841 3280 1093 364 121 40 13 4 1  
shell sort step 387480
hn=2hn−1h_n=2h_{n-1} 
8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1  
shell sort step 1684506
hi=1,8,23,77,281,1073,4193,16577...h_i={1, 8, 23, 77, 281, 1073, 4193, 16577...} 
这是Sedgewick在书中提出的一个数列 
16577 4193 1073 281 77 23 8 1  
shell sort step 373642
对该数列进行增项训练，发现在1073和281之间插入一项541，能得到较好结果： 
16577 4193 1073 541 281 77 23 8 1  
shell sort step 318192
同理，对hn=3hn−1+1h_n=3h_{n-1}+1研究后发现，将第二项13替换为23，得到结果为局部最优。 
9841 3280 1093 364 121 40 23 4 1  
shell sort step 342600
由此想到如下改进： 
首先固定h0,h2,h3,...h_0,h_2,h_3,...，枚举h1h_1，得到最优数列。 
接着固定h0,h1,h3,...h_0,h_1,h_3,...，枚举h2h_2，得到最优数列。 
依次类推，最后得到一个新的数列hi^\hat {h_i}。 
hi^=1,5,23,65,175,383,969,2171,4626,9251...\hat{h_i} = 1,5,23,65,175,383,969,2171,4626,9251...
4626 2171 969 383 175 65 23 5 1  
shell sort step 269223
此时，较原Knuth数列，已提高43%效率。

出人意料的是，斐波那契数列hn=hn−1+hn−2h_n=h_{n-1}+h_{n-2}的效果比很多数列都要差，只比Knuth数列好一点。(真是对不起，K神） 
10946 6765 4181 2584 1597 987 610 377 233 144 89 55 34 21 13 8 5 3 2 1  
shell sort step 368606 
我的看法是，就像某些数列太长了一样，在h上外循环遍历太多，造成总的交换次数增多。我也不知道为什么，有待进一步研究。
如上所见，等比数列hi=1,a,a2,a3,...h_i=1,a,a^2,a^3,...的效果极差，但如果对其做一点小小的改动，使a=2.1，再设数列hi=1,⌊a⌋,⌊a2⌋,⌊a3⌋,...h_i=1,\lfloor {a} \rfloor,\lfloor {a^2} \rfloor,\lfloor {a^3} \rfloor,...，可以看到数量级的飞跃。 
15447 7355 3502 1667 794 378 180 85 40 19 9 4 2 1  
shell sort step 200076
有数列如下： 
hi=9∗4i−9∗2i+1h_i=9*4^i-9*2^i+1 
以及： 
gi=4i−3∗2i+1g_i=4^i-3*2^i+1 
将两个数列合并，得到新的增量数列： 
8929 3905 2161 929 505 209 109 41 19 5 1  
shell sort step 235935
1971年，Pratt提出了一个增量三角形： 
 
该图中每个数都是左上数的三倍，右上数的两倍。Pratt证明了，该数列的时间复杂度低于O(N((logN)2)O(N((logN)^2) 
实际应用中，可以将{2,3}替换成较大的互质素数对{h,k}，以减少序列项的数量。
尽管这么说，从实验来看，2,3的结果显示相当优秀，在本次实验中荣获冠军：
8192 9216 6144 4096 6912 4608 3072 2048 7776 5184 3456 2304 1536 1024 8748 5832 3888 2592 1728 1152 768 512 6561 4374 2916 1944 1296 864 576 384 256 2187 1458 972 648 432 288 192 128 729 486 324 216 144 96 64 243 162 108 72 48 32 81 54 36 24 16 27 18 12 8 9 6 4 3 2 1  
shell sort step 158654
而3,5和5，7都不如2，3 
6561 5103 2187 9261 3969 1701 729 7203 3087 1323 567 243 2401 1029 441 189 81 343 147 63 27 49 21 9 7 3 1  
shell sort step 195064

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java-Set源码分析
纸上得来终觉浅，绝知此事要躬行
  --陆游    问渠那得清如许，为有源头活水来  --朱熹



Set也是继承自Collection，set也是集合的一种，同时set不允许重复的元素存在。


Set源码：

public interface Set<E> extends Collection<E> {
    int size(); //大小
    boolean isEmpty();//是否为空
    boolean contains(Object o); //是否包含某个对象
    Iterator<E> iterator(); //生成迭代器
    Object[] toArray(); //返回Object数组
    <T> T[] toArray(T[] a); //返回泛型数组
    boolean add(E e); //向set中添加元素
    boolean remove(Object o); //从set中删除某个元素
    boolean containsAll(Collection<?> c); //某个Collection是否都包含在此lset中
    boolean addAll(Collection<? extends E> c); //将某个Collection追加到此set中
    boolean retainAll(Collection<?> c); //删除不存在于Collection中的set中的元素
    boolean removeAll(Collection<?> c); //删除包含在此Collection中的元素
    void clear(); //清空set
    boolean equals(Object o);//判断两个set是否相同
    int hashCode(); //计算set的hashCode
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.DISTINCT);
    }
}


版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

Java知识总结---MVC模式解析之MyBatis（四）
         在上一篇的文章里，简单介绍了一些SpringMVC的一些简单使用方法。今天就来看看Mybatis。现在流行的Hibernate、Mybatis都是比较常见的ORM框架。什么是ORM呢，就是 Object Relational Mapping，对象关系映射，通俗点说，就是把对象映射成sql语句，在操作的时候，直接操作对象就可以了。了解过Hibernate的都知道，在做CRUD的时候，直接操作一个Model，即可操作数据库，对于一些特殊的情况，我们还可以使用hql，虽然这样很方便，但是在一些特殊的情况下，往往会有比较复杂的sql，虽然用Hibernate也能够解决，但却并不怎么容易。而Mybatis呢，了解过的都知道，它还是通过sql语句来操作数据库，只是把sql都写在配置文件中，并且对于参数，返回结果都能用对象来操作。这样不仅能解决一些复杂sql的问题，对代码层面来说，只是调用insert，select这些方法，而不需要显示的创建connection，statement，resultset等等。下面呢，我们就来看看如何在项目中使用Mybatis。
        我们仍然以之前文章里搭建的项目为基础，来看看Mybatis的配置。
        首先，我们先看看mybatis的核心配置文件：mybatis-config.xml
<?xml version="1.0" encoding="UTF-8" ?> 
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> 
<configuration> 
	<settings>
		<setting name="cacheEnabled" value="true" />
		<setting name="lazyLoadingEnabled" value="false" />
		<setting name="defaultStatementTimeout" value="30" />
	</settings>
	
    <mappers> 
        <mapper resource="mybatis/UserMapper.xml" /> 
    </mappers> 
</configuration>
这个是最简单的配置方式，settings里配置了一些是否使用缓存，是否使用懒加载，默认的超时时间等信息。而mappers里配置了要加载的具体sql映射配置文件。操作数据库，数据库的连接信息是必不可少的，由于我们项目中使用了spring，这些信息都放在了spring的配置文件中，如果项目中没用spring，那就需要在这个配置文件中配置数据库的相关信息了，可以使用如下的配置：
 <environments default="development">
          <environment id="development">
              <transactionManager type="JDBC" />
              <!-- 配置数据库连接信息 -->
             <dataSource type="POOLED">
                 <property name="driver" value="com.mysql.jdbc.Driver" />
                 <property name="url" value="jdbc:mysql://localhost:3306/mybatis" />
                 <property name="username" value="root" />
                 <property name="password" value="root" />
             </dataSource>
         </environment>
</environments>当然了，其中还有一些其他的配置，就不一一来说了，有需要的可以自行查阅相关文档。
接下来就看看，怎么去使用mybatis-config配置文件呢？我们操作数据库，就需要dao，这个类我们一般会继承SqlSessionDaoSupport来进行操作。这个类需要我们注入一个属性sqlSessionFactory。配置如下：
<bean id="userDao" class="com.demo.dao.impl.UserDaoImpl">
		<property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
</bean>那么sqlSessionFactory怎么配置呢？
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"> 
         <property name="configLocation" value="classpath:mybatis-config.xml" /> 
         <property name="dataSource" ref="dataSource" /> 
</bean>configLocation指定了mybatis的核心配置文件，dataSource就是数据源，是对数据库的配置信息。
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> 
	<property name="driverClassName" value="${jdbc.driverClassName}" /> 
	<property name="url" value="${jdbc.url}" /> 
	<property name="username" value="${jdbc.username}"></property>
      	<property name="password" value="${jdbc.password}"></property>
</bean>这个就是datasource的配置，现在使用的是DriverManager的方式去配置的。其实在项目中，比较常用的是JNDI数据源。JNDI数据源不是配置在项目中的，而是配置在容器中。比如在Tomcat数据源的配置是在TOMCAT_HOME/conf/context.xml中context里加上如下的配置：
<Resource name="jdbc/usertest"
       auth="Container"
       type="javax.sql.DataSource"
       driverClassName="com.mysql.jdbc.Driver"
       url="jdbc:mysql://localhost/test"
       username="root"
       password="root"
       maxActive="100"
       maxIdle="30"
       maxWait="10000" />这样，我们需要修改数据库配置的时候，直接修改容器的配置文件就行了，就不需要修改项目啦。JNDI数据源配置之后，项目中dataSource也需要修改。
	<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
		<property name="jndiName" value="java:comp/env/java/usertest"></property>
	</bean>这里只需要配置jndiName就可以了，名字必须是java:comp/ev/加上在容器中配置的jndi名字jdbc/usertest。这样jndi数据源就配置好了。
下面我们就来说说mybatis的配置*Mapper.xml，这个文件里存放的就是sql的配置了。一般这个文件的命名都是模块名+Mapper.xml，每个模块都有自己的Mapper。
<mapper namespace="user">
	
	<resultMap type="com.demo.model.UserModel" id="UserModel">
		<result column="id" property="id" jdbcType="INTEGER"/>
		<result column="name" property="name" jdbcType="VARCHAR"/>
		<result column="age" property="age" jdbcType="INTEGER"/>
		<result column="address" property="address" jdbcType="VARCHAR"/>
		
	</resultMap>
	
	<insert id="insertUser" parameterType="com.demo.model.UserModel">
		insert into t_user(`name`,`age`,`address`) values(
			#{name,jdbcType=VARCHAR},
			#{age,jdbcType=INTEGER},
			#{address,jdbcType=VARCHAR}
		);
	</insert>
	
	<select id="selectUserById" parameterType="INTEGER" resultMap="UserModel">
		select `id`,`name`,`age`,`address` from t_user 
		where `id` = #{userid,jdbcType=INTEGER};
	</select>
	
	<select id="selectAllUser" resultType="com.demo.model.UserModel">
		select `id`,`name`,`age`,`address` from t_user
	</select>
</mapper>
首先是mapper的namespace属性，一般我们都使用模板的名字。
resultMa是结果映射，主要用于将sql的返回结果映射到对象，一般用于数据库表的字段名和Model的属性名不一致的情况。mybatis和java类型映射关系如下：
JDBC Type           Java Type  
CHAR                String  
VARCHAR             String  
LONGVARCHAR         String  
NUMERIC             java.math.BigDecimal  
DECIMAL             java.math.BigDecimal  
BIT             boolean  
BOOLEAN             boolean  
TINYINT             byte  
SMALLINT            short  
INTEGER             int  
BIGINT              long  
REAL                float  
FLOAT               double  
DOUBLE              double  
BINARY              byte[]  
VARBINARY           byte[]  
LONGVARBINARY               byte[]  
DATE                java.sql.Date  
TIME                java.sql.Time  
TIMESTAMP           java.sql.Timestamp  
CLOB                Clob  
BLOB                Blob  
ARRAY               Array  
DISTINCT            mapping of underlying type  
STRUCT              Struct  
REF                  Ref  
DATALINK            java.net.URL
接下来就是sql了，mybatis对sql进行了区分，不同的sql使用不同的标签，插入：insert，查询：select，删除：delete，更新：update，每个sql都必须有一个唯一的id，这个id就是在代码里需要执行这条sql的一个标识。
parameterType是参数的类型，如果没有可以不填，如果是java类型，一定要写全路径名。
返回结果呢，有两种，一种是resultType，一种是resultMap，resultType就是返回正常的类型，如INTEGER，就是不需要转换的对象。如果需要转换，就得使用resultMap了，对应的值，必须在上边的<resultMap>中进行了配置。
以上就是配置方面的信息，在代码中使用就很简单了。
public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao {

	public boolean insert(UserModel user) {
		int count = getSqlSession().insert("insertUser", user);
		if(count > 0) {
			return true;
		}
		return false;
	}

        public UserModel getUser(int userid) {
               List<UserModel> list = getSqlSession().selectList("selectUserById", userid);
               return list != null && list.size() > 0  ? list.get(0) : null; 
    }
}

直接调用getSqlSession()的相应方法就可以了。在这要注意，如果有多条查询结果的话，mybatis会默认把他们放到List里。



版权声明：本文为博主原创文章，未经博主允许不得转载。

Java异常
纸上得来终觉浅，绝知此事要躬行
  --陆游       问渠那得清如许，为有源头活水来  --朱熹



一、java异常的超类是java.lang.Throwable
异常处理的类结构组成：



二、java异常分为两类Error和Exception：
Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等，这些异常发生JVM选择线程终止。
Exception是程序本身可以处理的异常分为两种：
    （1）非运行时异常（发生在编译阶段，称为checkException）：一般是指没有遵循java语言规范的错误，比较容易看出。
如NullPointerException、IndexOutOfBoundsException， 这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。
这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生。
    （2）运行时异常（发生在程序运行过程中，称为uncheckException）：一般发生在程序运行过程中出现的异常，比如空指针错误等等。
三、Java异常涉及到5个关键字：try，catch，finally，throw，throws
        try{
                尝试运行的程序代码
            }
            catch(异常类型  异常变量名)
            {
                异常处理代码，同时catch可以是多个，但只运行其中的一个
            }
            finally()
            {
                finally总在方法返回前运行，finally语句部分只有一个
            }


        throw关键字用于方法体内部，用来抛出一个throwable类型的异常，
        throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出哪些异常，
        
四、常见的异常：
        NullPointException  空指针异常
        ClassNotFoundException  找不到类
        ClassCastException  类型转换
        ArrayIndexOutOfBoundsException  数组越界
五、finally（）


当在try和catch中有return语句的时候，finally都会被执行的。
        

版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

【最小树形图(奇怪的kruskal)】【SCOI 2012】【bzoj 2753】滑雪与时间胶囊
2753: [SCOI2012]滑雪与时间胶囊
Time Limit: 50 Sec  Memory Limit: 128 MB
Submit: 1621  Solved: 570

Description
a180285非常喜欢滑雪。他来到一座雪山，这里分布着M条供滑行的轨道和N个轨道之间的交点（同时也是景点），而且每个景点都有一编号i（1<=i<=N）和一高度Hi。a180285能从景点i 滑到景点j 当且仅当存在一条i 和j 之间的边，且i 的高度不小于j。 与其他滑雪爱好者不同，a180285喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。于是a180285拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是a180285 滑行的距离）。请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285站在1号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间 
胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？
Input
输入的第一行是两个整数N，M。 
接下来1行有N个整数Hi，分别表示每个景点的高度。 
接下来M行，表示各个景点之间轨道分布的情况。每行3个整数，Ui，Vi，Ki。表示 
编号为Ui的景点和编号为Vi的景点之间有一条长度为Ki的轨道。
Output
输出一行，表示a180285最多能到达多少个景点，以及此时最短的滑行距离总和。 
Sample Input
3 3 
3 2 1 
1 2 1 
2 3 1 
1 3 10 

Sample Output
3 2 

HINT
【数据范围】 
对于30%的数据，保证 1<=N<=2000 

对于100%的数据，保证 1<=N<=100000 

对于所有的数据，保证 1<=M<=1000000，1<=Hi<=1000000000，1<=Ki<=1000000000。

题解：
第一问就是要找有多少点和1联通，直接bfs一边就好了。 
第二问实际上是求一个最小树形图(就是有向图上的最小生成树)。 
一般都是用朱刘算法的，然而感觉不大会写并且复杂度有些不对，于是想了想kruskal，发现我们只需要对所有第一问中找出的点做就好了，所以可以对所有边按终点的高度降序和边长升序排序就好了，这样就可以克服kruskal可能会做出来不联通的树了。
Code：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 100100
#define M 2001000
#define LL long long

struct Edge{
    int u,v,next; LL k;
}edge[M<<1];
int n,m,num=0,ans1,head[N],h[N],fa[N],q[M<<1];
LL ans2; bool vis[N];

int in(){
    int x=0; char ch=getchar();
    while (ch<'0' || ch>'9') ch=getchar();
    while (ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}
LL Lin(){
    LL x=0; char ch=getchar();
    while (ch<'0' || ch>'9') ch=getchar();
    while (ch>='0' && ch<='9') x=x*10+(LL)(ch-'0'),ch=getchar();
    return x;
}

void add(int u,int v,int k){
    edge[++num].u=u; edge[num].v=v; edge[num].k=k;
    edge[num].next=head[u]; head[u]=num;
}

void bfs(){
    int h=0,t=1; ans1=0;
    memset(vis,0,sizeof(vis));
    q[h]=1; vis[1]=1;
    while (h<t){
        int u=q[h++]; ans1++;
        for (int i=head[u]; i; i=edge[i].next){
            int v=edge[i].v;
            if (vis[v]) continue;
            q[t++]=v; vis[v]=1;
        }
    }
}

bool cmp(Edge x,Edge y){
    if (h[x.v]!=h[y.v]) return h[x.v]>h[y.v];
    return x.k<y.k;
}
int find(int x){
    if (x==fa[x]) return x;
    fa[x]=find(fa[x]);
    return fa[x];
}
void unionn(int x,int y){
    fa[x]=y;
}
void kruskal(){
    ans2=0;
    sort(edge+1,edge+num+1,cmp);
    for (int i=1; i<=n; i++) fa[i]=i;
    for (int i=1; i<=num; i++){
        int u=edge[i].u,v=edge[i].v;
        if (!vis[u] || !vis[v]) continue;
        int f1=find(u),f2=find(v);
        if (f1!=f2)
            unionn(f1,f2),ans2+=edge[i].k;
    }
}

int main(){
    n=in(),m=in();
    for (int i=1; i<=n; i++) h[i]=in();
    for (int i=1; i<=m; i++){
        int u=in(),v=in(); LL k=Lin();
        if (h[u]>=h[v]) add(u,v,k);
        if (h[v]>=h[u]) add(v,u,k);
    }

    bfs(); kruskal();

    printf("%d %lld\n",ans1,ans2);
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

JAVA并发编程7_线程封闭：ThreadLocal类
多线程访问共享数据时，通常需要同步，一种避免使用同步的方式就是不共享数据。如果仅在单线程里访问数据，那么就不需要使用同步，这种技术被称为线程封闭。
Ad-hoc线程封闭：维护线程封闭性的职责完全由程序实现来承担。
栈封闭：我的理解就是局部变量，局部变量是线程私有的，不会被共享，也就不存在竞争问题。因此能使用局部变量的地方就不要使用全局变量。
ThreadLocal类：一种维护线程封闭性更规范的方法。顾名思义就是创建一个线程局部变量。它会为使用相同变量的每个不同线程都创建不同存储。我的理解是在使用全局的变量（多线程均可能同时访问的变量）的前提下，多个线程同时去访问该变量，一般会出现线程不安全，而此时我们又不需要共享该变量，就可以使用ThreadLocal类来解决。
实际上，ThreadLocal根本就不是解决共享变量的问题，线程之间根本就不会共享变量，一定要注意ThreadLocal是用来隔离线程存储数据的。

public class Test implements Runnable{
	private ThreadLocal<Integer> num = new ThreadLocal<Integer>(){
		protected Integer initialValue() {
			return 100;
		};
	};
	
	@Override
	public void run() {
		while (!Thread.currentThread().isInterrupted()) {
			increment();
			System.out.println(Thread.currentThread().getName() + "  " + num.get());
			Thread.yield();
		}
	}
	
	private void increment() {
		num.set(num.get() + 1);
	}

	public static void main(String[] args) throws InterruptedException {
		Test test = new Test();
		ExecutorService exec = Executors.newCachedThreadPool();
		for (int i = 0; i < 5; i++) {
			exec.execute(test);
		}
		TimeUnit.MILLISECONDS.sleep(5);
		exec.shutdownNow();
	}
}
输出pool-1-thread-2  101
pool-1-thread-1  101
pool-1-thread-4  101
pool-1-thread-3  101
pool-1-thread-5  101
pool-1-thread-4  102
pool-1-thread-1  102
pool-1-thread-3  102
pool-1-thread-2  102
pool-1-thread-5  102
pool-1-thread-1  103
pool-1-thread-4  103
pool-1-thread-3  103
pool-1-thread-2  103
pool-1-thread-5  103
pool-1-thread-1  104
pool-1-thread-4  104
pool-1-thread-3  104
pool-1-thread-2  104
pool-1-thread-5  104
…
程序运行时，很显然每个线程都被分配了自己的存储。如果不是使用ThreadLocal类，那这五个线程共享的是num变量，必然会产生线程不安全产生竞争。
HDU 5400 Arithmetic Sequence(数学，容斥)
题目：

Arithmetic Sequence
Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 938    Accepted Submission(s): 412


Problem Description
A sequence b1,b2,⋯,bn
 are called (d1,d2)-arithmetic
 sequence if and only if there exist i(1≤i≤n)
 such that for every j(1≤j<i),bj+1=bj+d1
 and for every j(i≤j<n),bj+1=bj+d2.

Teacher Mai has a sequence a1,a2,⋯,an.
 He wants to know how many intervals [l,r](1≤l≤r≤n)
 there are that al,al+1,⋯,ar
 are (d1,d2)-arithmetic
 sequence.

 

Input
There are multiple test cases.

For each test case, the first line contains three numbers 
n,d1,d2(1≤n≤105,|d1|,|d2|≤1000),
 the next line contains n
 integers a1,a2,⋯,an(|ai|≤109).

 

Output
For each test case, print the answer.

 

Sample Input

5 2 -2
0 2 0 -2 0
5 2 3
2 3 3 3 3

 

Sample Output

12
5

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9




题意：给一个数列，问这个数列中有多少个子数列，可以被分为两个序列，这两个序列都为等差数列（公差分别为d1和d2）。


思路：枚举每个数字，求出它的左边能构成的公差为d1的等差数列的左边界l和它的右边能构成的公差为d2的等差数列的右边界r，那么对于这个【l,r】区间内的每个子区间都满足题意，共有（r-l+1）*(r-l+2)/2个子区间。但是这样可能会重复计算，因为枚举不同数字的时候可能会得到相同区间，由于区间的左边界是非降的，我们只需要记录已经出现过的右边界的最大值，就能得到当前区间和出现过的区间重叠的地方，减去这部分区间就可以了。


代码：
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include<climits>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <fstream>
#include <numeric>
#include <iomanip>
#include <bitset>
#include <list>
#include <stdexcept>
#include <functional>
#include <utility>
#include <ctime>
using namespace std;

#define PB push_back
#define MP make_pair

#define REP(i,x,n) for(int i=x;i<(n);++i)
#define FOR(i,l,h) for(int i=(l);i<=(h);++i)
#define FORD(i,h,l) for(int i=(h);i>=(l);--i)
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define OI(X) printf("%d",X);
#define RS(X) scanf("%s", (X))
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
#define Swap(a, b) (a ^= b, b ^= a, a ^= b)
#define Dpoint  strcut node{int x,y}
#define cmpd int cmp(const int &a,const int &b){return a>b;}

 /*#ifdef HOME
    freopen("in.txt","r",stdin);
    #endif*/
const int MOD = 1e9+7;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef long long LL;
typedef pair<int,int> PII;
//#define HOME

int Scan()
{
	int res = 0, ch, flag = 0;

	if((ch = getchar()) == '-')				//判断正负
		flag = 1;

	else if(ch >= '0' && ch <= '9')			//得到完整的数
		res = ch - '0';
	while((ch = getchar()) >= '0' && ch <= '9' )
		res = res * 10 + ch - '0';

	return flag ? -res : res;
}
/*----------------PLEASE-----DO-----NOT-----HACK-----ME--------------------*/


#define MAXN 100000
int a[MAXN+5];
int l[MAXN+5];
int r[MAXN+5];
//int len1[MAXN+5];
//int len2[MAXN+5];
int main()
{int n,d1,d2;
while(RIII(n,d1,d2)!=EOF)
{
    REP(i,0,n)
    scanf("%d",&a[i]);
    //len1[0]=0;
    l[0]=0;
    for(int i=1;i<n;i++)
        if(a[i]==a[i-1]+d1)
        l[i]=l[i-1];
       else
        l[i]=i;
        r[n-1]=n-1;
    for(int i=n-2;i>=0;i--)
        if(a[i]==a[i+1]-d2)
        r[i]=r[i+1];
        else
        r[i]=i;
    long long int ans=0;
    int last=-1;
    for(int i=0;i<n;i++)
        {
            long long int c=r[i]-l[i]+1;
            ans+=c*(c+1)/2;
            c=min(last,r[i])-l[i]+1;
            if(c>0)
                ans-=c*(c+1)/2;
            last=max(last,r[i]);

        }
    printf("%I64d\n",ans);



}



        return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

使用不带头结点的循环链表实现队列（数据结构）

我使用类模版来完成循环链表实现队列的操作。首先定义一个结点类node用来保存结点信息，然后定义队列类Queue，接下来我们思考：要完成队列的4个基本操作即
1.判断队列是否为空
2.在队列尾部push进数据
3.从队列头部取出数据
4.删除掉队列首部的元素
我们这个Queue类需要什么成员变量？
答案是： （维护）队列尾部结点、队列大小就够了。
我们来分析，尾部push数据的时候，我们只需要在myback和myback->next之间插入这个结点，然后把这个myback指向这个结点即可。取出和删除头部数据只需要对myback->next进行操作即可，复杂度是O（1），效率很高。



剩下的一些实现细节看我下面的代码实现：
//circle_list.h
#ifndef CIRCLE_LIST
#define CIRCLE_LIST
#include<iostream>
#include<string>
#include<cstring>
template <typename T>
class node//节点类
{
public:
	T data;
	node *next;
	node(T da = 0, node *n = NULL) :data(da), next(n){}
};
template <typename T>
class Queue
{
public:
	node<T> *myback;
	int size;
	Queue(node<T> *begin = NULL, int s = 0) :myback(begin),size(s){}
	bool empty();
	void enqueue(T value);//后面压入
	T front();
	void display();
	void dequeue();//前面删除
	~Queue();
	Queue(const Queue<T> &temp);
	Queue<T> operator=(const Queue<T>temp);
};
template <typename T>
bool Queue<T>::empty()
{
	if (size == 0)
		return true;
	return false;
}
template <typename T>
Queue<T>::Queue(const Queue<T> &temp)
{
		size = 0;
		node<T>* scan = (temp.myback)->next;
		while (scan != temp.myback)
		{
			enqueue(scan->data);
			scan = scan->next;
		}
		enqueue(temp.myback->data);

}
template <typename T>
Queue<T> Queue<T>::operator=(const Queue<T> temp)
{

		size = 0;
		node<T>* scan = (temp.myback)->next;
		while (scan != temp.myback)
		{
			enqueue(scan->data);
			scan = scan->next;
		}
		enqueue(temp.myback->data);
	return *this;
}


template <typename T>
void Queue<T>::enqueue(T value)
{

	node<T>*last = new node<T>;
	last->data = value;
	if (size == 0)
	{
		myback = last;
		myback->next = myback;
	}
	else
	{
		node<T> *temp = myback->next;
		myback->next = last;
		last->next = temp;
		myback = last;
		myback->next = temp;
	}
	size++;
}
template <typename T>
T Queue<T>::front()
{
	return (myback->next)->data;
}
template <typename T>
void Queue<T>::display()
{
	if (size == 1)
	{
		cout << myback->data << endl;
		return;
	}
	else
	{
		node<T> *first = myback->next;
		while (first != myback)
		{
			cout << first->data << " ";
			first = first->next;
		}
		cout << myback->data;
		cout << endl;
	}
}
template <typename T>
void Queue<T>::dequeue()
{

	node<T>*cur = myback->next;
	node <T>*now = cur->next;
	myback->next = now;
	delete cur;
	size--;
}
template <typename T>
Queue<T>::~Queue()
{
	if (size == 0){}
	else
	{
		node<T> *p = myback->next;
		node<T> *nex = p->next;
		while (p != myback)
		{
			delete p;
			p = nex;
			nex = nex->next;
		}
		delete myback;
	}
}

#endif
进行测试：
//main.cpp
#include"circle_list.h"
using namespace std;
int main()
{
	Queue<int> q;
	cout <<"队列是否为空？"<< q.empty() << endl;
	q.enqueue(1);
	q.enqueue(2);
	q.enqueue(3);
	cout << "输出第一个队列中的数据：" << endl;
	q.display();
	Queue<int> a(q);
	cout << "输出通过拷贝构造函数建立的队列中的数据：" << endl;
	a.display();
	Queue<int> b;
	b = q; cout << "输出通过赋值运算符重载建立的队列中的数据：" << endl;
	b.display();
	cout << "输出队列首的元素：" << endl;
	cout << q.front() << endl;
	q.dequeue();
	cout << "删除队首元素后的队列：" << endl;
	q.display();
	//cout << q.empty() << endl;
	return 0;
}
实验结果截图;



版权声明：本文为博主原创文章，未经博主允许不得转载。

OpenCV入门笔记（六） 形态学变换
形态学变换（Morphological Transformations），其实是数学上的一个分支，是基于形状的一些列图像处理操作。OpenCV提供了很多方便而有用的操作函数。

一、腐蚀和膨胀（erosion & dilation）
腐蚀（erosion）和膨胀（dilation）是形态学中两个最基本的操作。他们结合后又会衍生出其他很多种复杂的过程。其基本思想很简单，就是用一个核函数，扫过原图像，用覆盖的区域中最值代替锚点（锚点即核函数当前的中心点，即扫描的中心点）。下面是苏东坡《水调歌头·明月几时有》的楷体图片，我们来看看腐蚀和膨胀对该图片的影响。
值得注意的是，这里是白底黑字，形态学操作都是针对 高亮部分，即白色的背景而言的。这里腐蚀可以看做是对白色的背景，一点点蚕食，所以字会变粗变大；相反的，膨胀，就是背景长胖了，把字给挤的细瘦细瘦的。
原图（origin） 如下


腐蚀（erosion） 

锚点取的值是核函数覆盖区域中的最小值，值越小越暗，如下图



膨胀（dilation） 

锚点取的值是核函数覆盖区域中的最大值，值越大越量，如下图



下面的代码，展示了原图，腐蚀和膨胀后的三张图。
#coding:utf8

import cv2
import numpy as np

# 常用于处理二值化后的图片
img = cv2.imread("poem_binary.png")

# 核函数，这里可以自定义的
kernel = np.ones((3, 3), np.uint8)

# 腐蚀和膨胀操作
erosion = cv2.erode(img, kernel, iterations = 1)
dilation = cv2.dilate(img, kernel, iterations = 1)

# 显示三张图片
cv2.namedWindow("origin img", cv2.WINDOW_NORMAL)
cv2.namedWindow("erosion", cv2.WINDOW_NORMAL)
cv2.namedWindow("dilation", cv2.WINDOW_NORMAL)
cv2.imshow("origin img", img)
cv2.imshow("erosion", erosion)
cv2.imshow("dilation", dilation)

# 等待键盘输入
cv2.waitKey(0)
cv2.destroyAllWindows()


二、形态学函数（MorphologyEx）
所谓的 高级形态学变换 ，其实还是在上面的腐蚀和膨胀上发展来的，一共五种，都是直接用morphologyEx函数调用。列举如下
1. 开运算（Opening Operation） = 先腐蚀，后膨胀 
dst=open(src,element)=dilate(erode(src,element))dst = open(src, element) = dilate(erode(src, element))
2. 闭运算（Closing Operation） = 先膨胀，后腐蚀 
dst=close(src,element)=erode(dilate(src,element))dst = close(src, element) = erode(dilate(src, element))
3. 形态学梯度（Morphological Gradient） = 膨胀图 - 腐蚀图 
dst=morph_grad(src,element)=dilate(src,element)−erode(src,element)dst = morph\_grad(src, element) = dilate(src, element) - erode(src, element)
4. 顶帽（Top Hat） = 原图 - 开运算图 
dst=tophat(src,element)=src−open(src,element)dst = tophat(src, element) = src - open(src, element)
5. 黑帽（Black Hat） = 闭运算图 - 原图 
dst=blackhat(src,element)=close(src,element)−srcdst = blackhat(src, element) = close(src, element) - src
下面是一些参考资料

【这篇博文】不是一般的详细，原理，展示都有。
C++版教程见这里【更多形态学变换】
Python版教程的见这里【Morphological Transformations】

我用了一张楷体的“阖”字做了各个特效，结果如下图


代码也放在这里。
#coding:utf8
import cv2
import numpy as np

# 读取图片
img = cv2.imread("./pic/he.png")

# 核函数，这里可以自定义的，两种方法都可以
#kernel = np.ones((3, 3), np.uint8)
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))

# 更多的形态学运算
opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)
closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)
gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)
tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)
blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)

# 显示图片
cv2.namedWindow("origin img", cv2.WINDOW_NORMAL)
cv2.namedWindow("opening", cv2.WINDOW_NORMAL)
cv2.namedWindow("closing", cv2.WINDOW_NORMAL)
cv2.namedWindow("gradient", cv2.WINDOW_NORMAL)
cv2.namedWindow("tophat", cv2.WINDOW_NORMAL)
cv2.namedWindow("blackhat", cv2.WINDOW_NORMAL)

cv2.imshow("origin img", img)
cv2.imshow("opening", opening)
cv2.imshow("closing", closing)
cv2.imshow("gradient", gradient)
cv2.imshow("tophat", tophat)
cv2.imshow("blackhat", blackhat)

# 等待键盘输入
cv2.waitKey(0)
cv2.destroyAllWindows()

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题16——反转链表
题目描述：
            定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表节点定义如下：

public class ListNode
{
	int val;
	ListNode next;
	ListNode(int x)
	{
		val=x;
	}
}
示意图：









分析：
         为了正确反转一个链表，需要调整链表中指针的方向，为了将调整指针这个复杂的过程分析清楚，我们可以借助图形来分析，如上图所示，在（a）所示的链表中，h、i和j是3个相邻的结点。假设经过若干操作，我们已经把结点h之前的指针调整完毕，这些结点的next都指向前面一个结点，接下来我们把i的next指向h，此时的链表的结构图如图（b）所示。
         不难注意到，由于结点i的next指向了它的前一个结点，导致我们无法在链表中遍历到结点j。为了避免连边在结点i处断开，我们需要在调整结点i的next之前，把节点j保存起来。
         也就是说我们在调整结点i的next指针时，除了需要知道节点i本事之外，还需要i的前一个结点h，因为我们需要把结点i的next指向节点h，同时，我们还事先需要保存i的一个节点j，以防止链表断开。因此我们需要定义3个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点。


注意：
         （1）输入的链表头指针为null或者整个链表只有一个结点时
           （2）翻转后的链表出现断裂


代码：


package offer;

public class reverseList
{
	public ListNode reverse(ListNode head)
	{
		ListNode pReverseHead=null;
		ListNode pNode=head;
		ListNode pPrev=null;
		while (pNode.next!=null)
		{
			ListNode pNext=pNode.next;
			if (pNext==null)
			{
				pReverseHead=head;
			}
			pNode.next=pPrev;
			pPrev=pNode;
			pNode=pNext;
		}
		return pReverseHead;
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

Java中遍历Map对象
下面列出一些最常用的Java遍历Map对象的方法

1、在for-each中使用entrySet遍历
这是最常用的遍历方式。在键值都需要时使用。
Map<String,String> map = new HashMap<String,String>();

for(Map.Entry<String, String> entry : map.entrySet()){
    System.out.println(entry.getKey()+" : "+entry.getValue());
}
 

2、在for-each循环中遍历keys或values
如果只需要map中的键或者值，可以通过keySet或values来实现遍历，而不是用entrySet。
Map<String,String> map = new HashMap<String,String>();

for(String key : map.keySet()){
    System.out.println("key: " + key);
}
for(String value : map.values()){
    System.out.println("value: " + value);
}
 

3、使用Iterator遍历
Map<String,String> map = new HashMap<String,String>();

Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
while(iterator.hasNext()){
    Map.Entry<String, String> m = iterator.next();
    System.out.println(m.getKey()+ " : "+m.getValue());
}
使用此方法在遍历时调用iterator.remove()可以删除entries，其他方法则不能，可能会产生意想不到的结果。 
参考:链接 


4、通过key遍历value
Map<String,String> map = new HashMap<String,String>();

for(String key : map.keySet()){
    String value = map.get(key);
    System.out.println(key + " : " +value);
}
 
例：
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class T {

    public static void main(String[] args) {
        Map<String, String> map = new HashMap<String, String>();
        map.put("beijing", "kaoya");
        map.put("henan", "hulatang");
        map.put("tianjin", "mahua");

        System.out.println("1、在for-each中使用entrySet遍历");
        for (Map.Entry<String, String> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " : " + entry.getValue());
        }

        System.out.println("2、在for-each循环中遍历keys或values");
        for (String key : map.keySet()) {
            System.out.println("key: " + key);
        }
        for (String value : map.values()) {
            System.out.println("value: " + value);
        }

        System.out.println("3、使用Iterator遍历");
        Iterator<Map.Entry<String, String>> ite = map.entrySet().iterator();
        while (ite.hasNext()) {
            Map.Entry<String, String> m = ite.next();
            System.out.println(m.getKey() + " : " + m.getValue());
        }

        System.out.println("4、通过key遍历value");
        for (String key : map.keySet()) {
            String value = map.get(key);
            System.out.println(key + " : " + value);
        }
    }

}
 
作者：itmyhome

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

欧拉函数

 
一 欧拉函数的定义:
     在数论中，对于正整数N,少于或等于N
 ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。
   φ函数的值：
    φ(x)=x(1-1/p(1))(1-1/p(2))(1-1/p(3))(1-1/p(4))…..(1-1/p(n))其中p(1),p(2)…p(n)为x
   的所有质因数;x是正整数;
 φ(1)=1(唯一和1互质的数，且小于等于1)。注意：每种质因数只有一个。
   例如:
        φ(10)=10×(1-1/2)×(1-1/5)=4;
        1 3 7 9
        φ(30)=30×(1-1/2)×(1-1/3)×(1-1/5)=8;
        φ(49)=49×(1-1/7)=42;
二 欧拉函数的性质：
          (1)p^k型欧拉函数:
    N是质数p(即N=p),
 φ(n)= φ(p)=p-p^(k-1)=p-1。
    若N是质数p的k次幂(即N=p^k)，φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)。
   (2)mn型欧拉函数
       设n为正整数，以φ(n)表示不超过n且与n互素的正整数的个数，称为n的欧拉函数值。若m,n互质，
   φ(mn)=(m-1)(n-1)=φ(m)φ(n)。
   (3)特殊性质:
    若n为奇数时，φ(2n)=φ(n)。
    对于任何两个互质的正整数a,n(n>2)有:a^φ(n)=1
 mod n (恒等于)此公式即欧拉定理
    当n=p且
 a与素数p互质(即:gcd(a,p)=1)则上式有:
 a^(p-1)=1 mod n (恒等于)此公式即费马小定理
 
三 ｜｜欧拉函数相关的证明：
    (1)p^k型的欧拉函数的证明：
      对于给定的一个素数p: φ(p)=p-1那么容易证明φ(n)=p^k-p^(k-1)
    已知少于或等于p^k的正整数的个数为p^k-1,其中和p^k不互质的正整数有{
 p×1,p×2,...,p×(p^(k-    1)-1)}，共计p^(k-1)-1个
    故: φ(n) = p^k-1-(p^(k-1)-1)=p^k-p^(k-1)。
    (2)mn型的欧拉函数的证明:
      因为:x=mn m与n互质(即:gcd(m,n)=1);根据中国剩余定理Z(x)和Z(m)×Z(n)之间存在一一映射，
    所以x的完全余数集(见下面参考)中的元素的个数Z(x)等于Z(m)×Z(n)元素的个数；而Z(m)×Z(n)=
    φ(m)φ(n)
    故有: φ(mn) =φ(m)φ(n)成立。
    (3)任意正整数的欧拉函数的相关证明:
    任意一个整数n都可以表示为其质因子的乘积:
     n=(p(1)*k(1)) *(p(2)*k(2)) *(p(3)*k(3))…(p(i)*k(i))*…*(p(I)*k(I))其中I为n的
    质因子的个数。
    根据(1)(2)的结论，很容易得出它的欧拉函数为:
      φ(n)=n(1-1/p(1))(1-1/p(2))(1-1/p(3))(1-1/p(4))…..(1-1/p(i))其中I为n的质因子的个数。
    对于任意n>2,2|φ(n)必定存在
 p(i)-1是偶数
 
    欧拉定理的相关证明:
      (1)令Z(n)={ X(1),X(2),…,X(φ(n)) } S={ a*X(1) mod n, a*X(2) mod n ,…,a*X(φ(n))
    mod n },则 Z(n)=S。
      （1)因为a与n互质(即:gcd(a,n)=1),
 X(i)(1≤i≤φ(n))与n互质(即:gcd(X(i),n)=1);所以
    a*X(i)与n互质(即:gcd(a*X(i),n)=1),故
 a*X(i) mod n ∈ Z(n)。
      （2)若i≠j,那么
 X(i)≠X(j) ,又有a与n互质(即:gcd(a,n)==1)，则可得出:
 a*(X(i)) mod 
    n≠a*X(j) mod n (消去定律)。
       (2)a^(φ(n))*X(1)*X(2)*X(3)*…*X(φ(n)) mod n=(a*X(1))*(a*X(2))*(a*X(3))*…*
    (a*X(φ(n))) mod n=(a*X(1)
 mod n)*(a*X(2) mod n)*(a*X(3) mod n)*…*(a*X(φ(n)) mod 
     n mod n=X(1)*X(2)*X(3)*…*X(φ(n))
 mod n。
    对比等式左右两端，因为X(i)(1≤i≤φ(n))与n互质(即:gcd(X(i),n)==1)
 ,
    故: a^φ(n)=1 mod n (恒等于)成立。
 
    费马小定理的相关证明：
    若正整数 a与素数p互质，则有a^(p-1)=1
 mod n(恒等于)
    由于φ(p)=p-1且
 a^φ(n)=1 mod n，又有此处的p==n;
    故:a^(p-1)=1 mod n成立。
    此定理可以用来简化幂的模运算:
    例如:计算
 7^222的个位数，实际上是求7^222被10除的余数，且7与10互质，φ(10)=1，由欧拉定理知
   7^4= 1mod 10
    故7^222=(7^4)^55*(7^2)=>(1^55)*(7^2)=>49=>9
 mod 10
 
四 欧拉函数的延伸:
   小于或等于n的数中，与n互质的数的总和为：φ(x)
 * x / 2  (n>1)。
 
五 相关知识参考:
        完全余数集合：
     定义小于 n且和
 n 互质的数构成的集合为 Z(n)，称呼这个集合为 n的完全余数集合。显然
 |Z(n)|
   ＝φ(n)。
    
同余定理：
    如果 a mod b = c则有(a+kb)
 mod b =c(k为非0整数)
    如果 a mod b = c则有(ka)
 mod b =kc (k为正整数)
    (a+b) mod c =((a mod c)+(b mod c )) mod c;
    (a*b) mod c=((a mod c)*(b mod c)) mod c;｜｜｜
六 欧拉函数模板
   (1)直接求小于或等于n,且与n互质的个数:
代码：
 
int Euler(int n)
{
    int ret=n;
    for(int i=2;i<=sqrt(n);i++)
     if(n%i==0)
      {
        ret=ret/i*(i-1);//先进行除法防止溢出(ret=ret*(1-1/p(i))) 
        while(n%i==0)
          n/=i;
     }
    if(n>1)
          ret=ret/n*(n-1);
        return ret;
}

   
  （2）筛选模板:求[1,n]之间每个数的质因数的个数
代码：
 
#define size 1000001
int euler[size];
void Init()
{ 
     memset(euler,0,sizeof(euler)); 
	 euler[1]=1;
     for(int i=2;i<size;i++)
       if(!euler[i])
       for(int j=i;j<size;j+=i)
       {
       	if(!euler[j])
       	 euler[j]=j;
       	 euler[j]=euler[j]/i*(i-1);//先进行除法是为了防止中间数据的溢出 
	} 
}




 
七 欧拉函数表
x=1  euler[1]=1
2             1
3             2
4             2
5             4
6             2
7             6
8             4
9             6
10            4
11            10
12            4
13            12
14            6
15            8
16            8
17            16
18            6
19            18
20            8
21            12
22            10
23            22
24            8
25            20
26            12
27            18
28            12
29            28
30            8
31            30
32            16
33            20
34            16
35            24
36            12
37            36
38            18
39            24
40            16

版权声明：本文为博主原创文章，未经博主允许不得转载。

c语言实现函数给主函数中的指针赋值的方法
//利用二维指针。自从学了c之后，还没怎么用过二维指针，这么算是记住了
/*
c语言实现函数给主函数中的指针赋值的方法

*/

#include<stdio.h>

void f (int **p);

int main (){

  int * a ;
  a = NULL ;
  f (&a);
  printf("%d",*a);
  free(a);
}

void f (int **a){

    *a = (int *)malloc (sizeof (int )) ;
    **a = 1 ;

}

输出结果是1 
重点是给主函数中的a指针可以赋值你想赋值的地址，而不是a指向的值


版权声明：本文为博主原创文章，未经博主允许不得转载。

eclipse的自动提示
由于重新配置了环境，并且eclipse也是装的4.2的，今天用的时候发现了，居然没有自动提示功能，也就是当一个对象居然点不出他的相关方法。后来网上搜索了下，成功的 办法是。
1、我window->Preferences->Java->Editor->content assist 
把 Enable auto activation 选项打上勾 ：(如下图)

并且在点后面加上.abcdefghijklmnopqrstuvwxyz
此时重启了eclipse还不成功，之后接着第二步骤
2、

把该勾选的斗勾选起来
，我自己的eclipse不用重启就成功了。
这里再总结下，首先第一步中的作用是指当你输入一个字母的时候eclipse就会马上联想相关的单词并显示出来，并且那些联想的单词总是跟着，如果你觉得比较烦的话，就改为默认的点号。第二步中才是重点，作用是就是当你用alt+/快捷键的时候会联想出来的。

版权声明：本文为博主原创文章，未经博主允许不得转载。

数据结构（Java语言）——BinaryHeap简单实现
    优先队列priority queue是允许至少下列两种操作的数据结构：insert插入以及deleteMin（删除最小者），它的工作是找出，返回并删除优先队列中最小的元素。insert操作等价于enqueue入队，而deleteMin则是dequeue出队在优先队列中的等价操作。
    一种实现优先队列的方法是使用二叉堆binary heap，它的使用对于优先队列的实现相当普遍，以至于当堆heap这个词不加修饰地用在优先队列的上下文中时，一般都是指数据结构的这种实现。在本节，我们把二叉堆只叫做堆。像二叉查找树一样，堆也有两个性质，即结构性和堆序性。恰似AVL树，对堆的一次操作可能破坏这两个性质中的一个，因此，堆得操作必须到堆得所有性质都被满足时才能终止。事实上这并不难做到。
    堆是一棵被完全填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入。这样的树称为完全二叉树。容易证明，一棵高为h的完全二叉树有2^h到2^(h+1)-1个节点。这意味着完全二叉树的高是logN向下取整，显然它是O(logN)。
    一个重要的观察发现，因为完全二叉树这么有规律，所以它可以用一个数组表示而不需要使用链。对于数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在左儿子后的单元(2i+1)中，它的父亲则在位置i/2中。因此，这里不仅不需要链，而且遍历该树所需要的操作极简单，在大部分计算机上运行很可能非常快。这种实现的唯一问题在于，最大的堆大小需要事先估计，但一般这并不成问题。
    以下是一个二叉堆的实现：

import java.util.NoSuchElementException;
import java.util.Random;

public class BinaryHeap<AnyType extends Comparable<? super AnyType>> {
	private static final int DEFAULT_CAPACITY = 10;// 默认容量
	private int currentSize; // 当前堆大小
	private AnyType[] array; // 数组

	public BinaryHeap() {
		this(DEFAULT_CAPACITY);
	}

	@SuppressWarnings("unchecked")
	public BinaryHeap(int capacity) {
		currentSize = 0;
		array = (AnyType[]) new Comparable[capacity + 1];
	}

	@SuppressWarnings("unchecked")
	public BinaryHeap(AnyType[] items) {
		currentSize = items.length;
		array = (AnyType[]) new Comparable[(currentSize + 2) * 11 / 10];
		int i = 1;
		for (AnyType item : items) {
			array[i++] = item;
		}
		buildHeap();
	}

	/**
	 * 从任意排列的项目中建立堆，线性时间运行
	 */
	private void buildHeap() {
		for (int i = currentSize / 2; i > 0; i--) {
			percolateDown(i);
		}
	}

	/**
	 * 堆内元素向下移动
	 * 
	 * @param hole
	 *            下移的开始下标
	 */
	private void percolateDown(int hole) {
		int child;
		AnyType tmp = array[hole];
		for (; hole * 2 <= currentSize; hole = child) {
			child = hole * 2;
			if (child != currentSize
					&& array[child + 1].compareTo(array[child]) < 0) {
				child++;
			}
			if (array[child].compareTo(tmp) < 0) {
				array[hole] = array[child];
			} else {
				break;
			}
		}
		array[hole] = tmp;
	}

	/**
	 * 插入一个元素
	 * 
	 * @param x
	 *            插入元素
	 */
	public void insert(AnyType x) {
		if (isFull()) {
			enlargeArray(array.length * 2 + 1);
		}
		int hole = ++currentSize;
		for (; hole > 1 && x.compareTo(array[hole / 2]) < 0; hole /= 2) {
			array[hole] = array[hole / 2];
		}
		array[hole] = x;
	}

	/**
	 * 堆是否满
	 * 
	 * @return 是否堆满
	 */
	public boolean isFull() {
		return currentSize == array.length - 1;
	}

	/**
	 * 堆是否空
	 * 
	 * @return 是否堆空
	 */
	public boolean isEmpty() {
		return currentSize == 0;
	}

	/**
	 * 清空堆
	 */
	@SuppressWarnings("unused")
	public void makeEmpay() {
		currentSize = 0;
		for (AnyType anyType : array) {
			anyType=null;
		}
	}

	/**
	 * 找到堆中最小元素
	 * @return 最小元素
	 */
	public AnyType findMin() {
		if (isEmpty())
			return null;
		return array[1];
	}

	/**
	 * 删除堆中最小元素
	 * @return 删除元素
	 */
	public AnyType deleteMin() {
		if (isEmpty()) {
			throw new NoSuchElementException();
		}
		AnyType minItem = findMin();
		array[1] = array[currentSize];
		array[currentSize--] = null;
		percolateDown(1);
		return minItem;
	}

	/**
	 * 扩大数组容量
	 * @param newSize 新的容量
	 */
	@SuppressWarnings("unchecked")
	private void enlargeArray(int newSize) {
		AnyType[] old = array;
		array = (AnyType[]) new Comparable[newSize];
		for (int i = 0; i < old.length; i++) {
			array[i] = old[i];
		}
	}

	/**
	 * 输出数组中的元素
	 */
	public void printHeap() {
		for (AnyType anyType : array) {
			System.out.print(anyType + " ");
		}
	}

	public static void main(String[] args) {
		BinaryHeap<Integer> heap = new BinaryHeap<Integer>();
		for (int i = 0; i < 20; i++) {
			heap.insert(i);
		}
		heap.deleteMin();
		heap.deleteMin();
		heap.deleteMin();
		heap.printHeap();
	}
}

执行结果：

null 3 4 5 7 9 11 6 15 8 17 10 18 12 13 14 19 16 null null null null null 


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ--1599--find the mincost route（floyd+最小环）
find the mincost route
Time Limit: 1000/2000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 3393    Accepted Submission(s): 1382


Problem Description
杭州有N个景区，景区之间有一些双向的路来连接，现在8600想找一条旅游路线，这个路线从A点出发并且最后回到A点，假设经过的路线为V1,V2,....VK,V1,那么必须满足K>2,就是说至除了出发点以外至少要经过2个其他不同的景区，而且不能重复经过同一个景区。现在8600需要你帮他找一条这样的路线，并且花费越少越好。

 

Input
第一行是2个整数N和M（N <= 100, M <= 1000)，代表景区的个数和道路的条数。
接下来的M行里，每行包括3个整数a,b,c.代表a和b之间有一条通路，并且需要花费c元(c <= 100)。
 

Output
对于每个测试实例，如果能找到这样一条路线的话，输出花费的最小值。如果找不到的话，输出"It's impossible.".
 

Sample Input

3 3
1 2 1
2 3 1
1 3 1
3 3
1 2 1
1 2 3
2 3 1

 

Sample Output

3
It's impossible.

 
思路：就是一道floyd+最小环的模板题，难点就在于去理解 最小环。还有一点，要注意最小环的判断是在更新dis数组之前进行的。详细的解释在这里（点击即可进入）
ac代码：
#include<stdio.h>
#include<string.h>
#define INF 0x3f3f3f//无穷大定义的大了，晕 真是没想到，这也会错，以后还是定义为这个无穷大吧。 
#define min(a,b) a<b?a:b
int n,m,dis[110][110],map[110][110];
//void init(){
//	memset(dis,INF,sizeof(dis));
//	memset(map,INF,sizeof(map));
//	for(int i=1;i<=n;i++)
//		for(int j=1;j<=n;j++)
//			if(i==j)
//				map[i][j]=dis[i][j]=0;
//}
void init()  //长记性了  上面的那个初始化方式不行，一直wa，虽然不造为什么，以后还是用for循环初始化吧。 
{  
    for(int i = 1; i <= n; i++)  
    {  
        for(int j = 1; j <= n; j++)  
        {  
            if(i == j)  
            map[i][j] = dis[i][j] = 0;  
            else  
            map[i][j] = dis[i][j] = INF;  
        }  
    }  
}  
void getmap(){
		init();
		while(m--){
			int a,b,c;
			scanf("%d%d%d",&a,&b,&c);
			if(map[a][b]>c)//判断重边。 
				map[a][b]=map[b][a]=dis[a][b]=dis[b][a]=c;
		}
}
void floyd(){
	int i,j,k,ans=INF;
	for(k=1;k<=n;k++){
		for(i=1;i<k;i++)
			for(j=i+1;j<k;j++)//用来保证每次三个点都不一样。 
				ans=min(ans,dis[i][j]+map[i][k]+map[k][j]);//记录最小环。 
		for(i=1;i<=n;i++)
			if(dis[i][k]!=INF){
				for(j=1;j<=n;j++)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
			}
	}
	if(ans==INF)
		printf("It's impossible.\n");
	else
		printf("%d\n",ans);
}
int main(){
	while(scanf("%d%d",&n,&m)!=EOF){
		getmap();
		floyd();
	}
	return 0;
}


版权声明：本文为小小呆原创文章，欲转载，请在后台勾搭本呆。

MongoDB count distinct group by JavaAPI查询
import java.net.UnknownHostException;
import com.mongodb.BasicDBList;
import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.Mongo;
public class MongoDBTest {
	private static DB db = null; 
	
	static{
		Mongo mongo = null;
		try {
			mongo = new Mongo("localhost", 27017);
		} catch (UnknownHostException e) {
			e.printStackTrace();
		}
		db = mongo.getDB("TestDB");	//连接数据
	}
	
	/**
	 * select count(*) from list
	 */
	public Long m1() {
		DBCollection collection = db.getCollection("list");
		return collection.count();
	}
	
	/**
	 * select count(*) from list where userId = 'orange'
	 */
	public Long m2(){
		DBCollection listCollection = db.getCollection("list");
		BasicDBObject query =new BasicDBObject();
		query.put("userId", "orange");
		return listCollection.count(query);
	}
	
	
	/**
	 * select count(*) from list where userId = 'orange' and time >= '20101201' and time <= '20101211'
	 */
	public Long m3(){
		DBCollection listCollection = db.getCollection("list");
		BasicDBObject query =new BasicDBObject();
		query.put("userId","orange");
		query.put("time", new BasicDBObject("$gte", "20101201").append("$lte", "20101211"));
		return listCollection.count(query);
	}


	/**
	 * select count(distinct(userId)) from detail where time >= '20101201' and time <='20101211'
	 */
	public int m4() {  
		DBCollection collection = db.getCollection("detail");
		BasicDBObject query = new BasicDBObject(); 
		query.put("time", new BasicDBObject("$gte", "20101201").append("$lte", "20101211")); 
		return collection.distinct("userId", query).size();
	}
	
	
	/**
	 * select date_format(time, '%Y-%m-%d %H') as sj ,count(*) from detail group by sj
	 */
	public void m5() {
		DBCollection collection = db.getCollection("detail");
		String formatDate = "function(obj,doc){"
				+ "var date = new Date(doc.time);"
				+ "var dateKey = date.getFullYear()+\"-\"+(date.getMonth()+1)+\"-\"+date.getDate(); "
				+ "return {'time':datekey}" + "}";
		BasicDBObject key = new BasicDBObject();
		key.put(formatDate, true); // 要分组的列
		BasicDBObject query = new BasicDBObject(); // where条件
		String reduce = "function (obj, prev) {prev.count++}";
		BasicDBObject initial = new BasicDBObject();
		initial.append("count", 0); // 每列初始值
		BasicDBList group = (BasicDBList) collection.group(key, query, initial,	reduce);
		System.out.println(group);
	}

}

版权声明：本文为博主原创文章，未经博主允许不得转载。

ZOJ 3435 Ideal Puzzle Bobble (莫比乌斯反演基础题)


Ideal Puzzle Bobble

Time Limit: 2 Seconds     Memory Limit:
65536 KB 




Have you ever played Puzzle Bobble, a very famous PC game? In this game, as a very cute bobble dragon, you must keep shooting powerful bubbles to crush all the colorful bubbles upwards. Victory comes when all the bubbles upwards
 are crushed. 
Little Tom is crazy about this game. One day, he finds that all kinds of Puzzle Bobble are 2D Games. To be more excited when playing this game, he comes up with a new idea to design a 3D Puzzle Bobble game! In this game, the
 bobble dragon is standing in a cubic room with L in length, W in width andH in height. Around him are so many colorful bubbles. We can use 3D Cartesian coordinates (x,y,
z) to represent the locations of the bobble dragon and those bubbles. All these coordinates (x,y,
z) are triple positive integers ranged from (1, 1, 
1) to (L, W, H). 
To simplify the problem, let's assume the bobble dragon is standing at (1,1,
1) in the room. And there is one colorful bubble at every (x,y,
z) in the room except (1, 1, 1). The dragon is so strong that he can shoot out a magical bubble to crushall the colorful bubbles in the straight line which the magical bubble flies every single time. Note
 that bubbles aresignificantly small with respect to the distances between each two bubbles. Our question remains, how many magical bubbles will the cute dragon shoot before crushing all the colorful bubbles around him?

Input
There are multiple cases, no more than 200. Each case contains one single line. In this line, there are three positive integersL,
W and H (2 ≤ L, W, H ≤ 1000000) which describes the size of the room. Proceed to the end of the file.
Output
For each case, print the number of the magical bubbles needed to crush all the colorful bubbles in one line.
Sample Input
2 2 2
3 3 3

Sample Output
7
19



Author: ZHU, Yuke
Contest: ZOJ Monthly, November 2010


题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3435


题目大意：(1,1,1)和(l, w, h)组成的长方体中从点(1,1,1)能看到的点数


题目分析：和前一题几乎一样，唯一的不同就是gcd(a, b, c) = 1，1 <= a <= l，1 <= b <= w，1 <= c <= h，范围不同，然而这并没有什么卵关系，l,w,h都减1，函数的参数变一下就行了



#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
int const MAX = 1000005;
int mob[MAX], p[MAX], sum[MAX];
bool noprime[MAX];

int Min(int a, int b, int c)
{
    return min(a, min(b, c));
}

void Mobius()
{
    int pnum = 0;
    mob[1] = 1;
    sum[1] = 1;
    for(int i = 2; i < MAX; i++)
    {
        if(!noprime[i])
        {
            p[pnum ++] = i;
            mob[i] = -1;
        }
        for(int j = 0; j < pnum && i * p[j] < MAX; j++)
        {
            noprime[i * p[j]] = true;
            if(i % p[j] == 0)
            {
                mob[i * p[j]] = 0;
                break;
            }
            mob[i * p[j]] = -mob[i];
        }
        sum[i] = sum[i - 1] + mob[i]; 
    }
}

ll cal(int l, int r)
{
    if(l > r)
        swap(l, r);
    ll ans = 0;
    for(int i = 1, last = 0; i <= l; i = last + 1)
    {
        last = min(l / (l / i), r / (r / i));
        ans += (ll) (l / i) * (r / i) * (sum[last] - sum[i - 1]);
    }
    return ans;
}

ll cal(int l, int m, int r)
{
    if(l > r)
        swap(l, r);
    if(l > m)
        swap(l, m);
    ll ans = 0;
    for(int i = 1, last = 0; i <= l; i = last + 1)
    {
        last = Min(l / (l / i), m / (m / i), r / (r / i));
        ans += (ll) (l / i) * (m / i) * (r / i) * (sum[last] - sum[i - 1]);
    }
    return ans;
}

int main()
{
    Mobius();
    int a, b, c;
    while(scanf("%d %d %d", &a, &b, &c) != EOF)
    {
        a --;
        b --;
        c --;
        ll ans = 3;
        ans += (ll) cal(a, b, c);
        ans += (ll) cal(a, b);
        ans += (ll) cal(b, c);
        ans += (ll) cal(a, c);
        printf("%lld\n", ans);
    }
}










版权声明：本文为博主原创文章，未经博主允许不得转载。

RT_Thead 中断

一、什么是中断？

中断有两种，一种是CPU本身在执行程序的过程中产生的，一种是由CPU外部产生的。 cpu外部中断，就是通常所讲的“中断”（interrupt）。对于执行程序来说，这种“中断”的发生完全是异步的，因为不知道什么时候会发生。CPU对其的响应也完全是被动的， 可以通过“关中断”指令关闭对其的响应。 然而由软件产生的中断一般是由专设的指令，如X86中的“INT n”在程序中有意产生的， 是主动的，同步的。只要CPU执行一条INT指令，在开始执行下一条指令之前一定会进入中 断服务程序。这种主动的中断称为“陷阱”（trap）

从物理学的角度看，中断是一种电信号，由硬件设备产生，并直接送入中断控制器的输入引脚上，然后再由中断控制器向处理器发送相应的信号。处理器一经检测到该信号，便中断自己当前正在处理的工作，转而去处理中断。此后，处理器会通知 OS 已经产生中断。这样，OS 就可以对这个中断进行适当的处理。不同的设备对应的中断不同，而每个中断都通过一个唯一的数字标识，这些值通常被称为中断请求线(IRQ)。
中断可分为同步（synchronous）中断和异步（asynchronous）中断：

1. 同步中断是当指令执行时由 CPU 控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后 CPU 才会发出中断，而不是发生在代码指令执行期间，比如系统调用。

2. 异步中断是指由其他硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生，例如键盘中断。

二、什么是异常？

同步中断又称为异常（exception）；异步中断则被称为中断（interrupt）。我们通常讲的中断指的都是异步中断，即cpu外部中断。
1.中断可分为可屏蔽中断（Maskable interrupt）和非屏蔽中断（Nomaskable interrupt）。
2.异常可分为故障（fault）、陷阱（trap）、终止（abort）三类。

这些类别之间的异同点如下：

类别             原因                   异步/同步                   返回行为
中断      来自I/O设备的信号          异步                 总是返回到下一条指令
陷阱      有意的异常                    同步                 总是返回到下一条指令
故障      潜在可恢复的错误           同步                 返回到当前指令
终止      不可恢复的错误              同步                 不会返回

三、中断处理过程

当中断产生时，处理器将按如下的顺序执行：
• 保存当前处理机状态信息
• 载入异常或中断处理函数到PC寄存器
• 把控制权转交给处理函数并开始执行
• 当处理函数执行完成时，恢复处理器状态信息
• 从异常或中断中返回到前一个程序执行点

中断使得CPU可以在事件发生时才予以处理，而不必让CPU连续不断地查询是否有相应的事件发生。通过两条特殊指令：关中断和开中断可以让处理器不响应或响应中断（在关闭中断期间，通常处理器会把新产生的中断挂起，当中断打开时立刻进行响应）。在执行中断服务例程的过程中，如果有更高优先级别的中断源触发中断，由于当前处于中断处理上下文环境中，根据不同的处理器构架可能有不同的处理方式：比如新的中断等待挂起直到当前中断处理离开后再行响应，但这在硬实时环境中不允许发生；或者新的高优先级中断打断当前中断处理过程，而去直接响应这个更高优先级的新中断源，这称为中断嵌套，而中断是否能够嵌套，一般由MCU处理器的中断机制决定，如stm32中只有新中断的抢占优先级比当前中断高时，才能打断当前中断进入新的中断服务函数。

在系统响应中断前，软件代码（或处理器）需要把当前线程的上下文保存下来（通常保存在当前线程的线程栈中），再调用中断服务例程进行中断响应、处理。在进行中断处理时（实质是调用用户的中断服务例程函数），中断处理函数中很可能会有自己的局部变量，这些都需要相应的栈空间来保存，所以中断响应依然需要一个栈空间来做为上下文运行中断处理函数。中断栈可以保存在打断的线程栈中，当从中断中退出时，返回相应的线程继续执行。中断栈也可以与打断线程栈完全分离开来，即每次进入中断时，在保存完被打断的线程上下文后，切换到新的中断栈中独立运行；在中断退出时，再做相应的上下文恢复。

使用独立中断栈相对来说更容易实现，并且对于线程栈使用情况也比较容易了解掌握（否则必须要为中断栈预留空间，如果系统支持中断嵌套，还需要考虑应该为嵌套中断预留多大的空间）。RT-Thread采用的方式是提供独立的中断栈，即中断发生时，中断的前期处理程序会将用户的栈指针更换到系统事先留出的中断栈空间中，等中断退出时再恢复用户的栈指针。这样中断就不会占用线程的栈空间，从而提高了内存空间的利用率，且随着任务的增加，这种减少内存占用的的效果也越明显。以stm32的cotex-M3/M4为例，cotex-M3/M4中拥有两个堆栈指针，然而它们是banked，因此任一时刻只能使用其中的一个：

      主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核，以及异常与中断处理。

      进程堆栈指针（PSP）：由用户的应用程序代码（如线程切换）使用。堆栈指针的最低两位永远是0，这意味着堆栈总是4 字节对齐的。

由此可以看出，在一个实际运行系统里有两大部分：一是操作系统和中断，一是用户应用程序。它们使用的资源是不一样的，从中断（线程调度时产生的中断）返回到用户应用程序线程时，系统使用的堆栈指针也从MSP变成PSP。

四、与操作系统相关的中断接口：在src/irq.c中

void rt_interrupt_enter(void);
void rt_interrupt_leave(void); 
当整个系统被中断打断，进入中断处理函数时，OS需要知道当前已经进入到中断状态。
rt_interrupt_enter函数用于通知OS，当前已经进入了中断状态；rt_interrupt_leave函数用于通知OS，已经离开中断状态。通常来说，OS需要知道这样的运行状态，这样在中断服务例程中，如果调用了OS相关的调用，OS好及时调整相应的行为，例如进行任务切换时应该采取中断中任务切换的策略，而不是立即进行切换。但是如果中断服务例程很显然、很必然地不会去调用OS相关的函数，此时也可以不调用rt_interrupt_enter/leave函数。

rt_uint8_t rt_interrupt_get_nest(void);
获取当前中断嵌套计数值，大于0说明处于中断服务中，大于1说明存在中断嵌套


五、与MCU相关的中断接口：以stm32f4为例

关闭中断：在libcpu/arm/cotex-m4/context_rvds.S中用汇编语言实现
rt_base_t rt_hw_interrupt_disable(void);
函数返回中断前的系统中断状态。
当系统关闭了中断时，就意味着当前线程/代码不会被其他事件所打断（因为整个系统已经不再对外部事件响应），也就是当前线程不会被抢占（因为线程切换时用到了PendSV_Handler），除非这个线程主动让出处理器。

打开中断：在libcpu/arm/cotex-m4/context_rvds.S中用汇编语言实现
void rt_hw_interrupt_enable(rt_base_t level);
调用这个函数接口将恢复调用rt_hw_interrupt_disable前的中断状态，level是上一次关闭中断时返回的值。打开中断往往是和关闭中断成对使用的，用于恢复关闭中断前的状态。
注意：调用这个接口并不代表着肯定打开中断，而是恢复关闭中断前的状态，如果调用rt_hw_interrupt_disable（）前是关中断状态，那么调用此函数后依然是关中断状态。


版权声明：本文为博主原创文章，未经博主允许不得转载。

BFS和DFS的简要分析

广度优先搜索（BFS），可以被形象的描述为“浅尝辄止”，具体一点就是每个顶点只访问它的邻接节点（如果它的邻接节点没有被访问）并且记录这个邻接节点，当访问完它的邻接节点之后就结束这个顶点的访问。

广度优先用到了“先进先出”队列，通过这个队列来存储第一次发现的节点，以便下一次的处理；而对于再次发现的节点，我们不予理会——不放入队列，因为再次发现的节点：

无非是已经处理完的了；或者是存储在队列中尚未处理的。



《算法导轮》对两种搜索都采用了很聪明的做法，用白色WHITE来标志未发现的节点，用灰色GRAY来标志第一次被发现的节点，用黑色BLACK来标志第二次被发现的节点。

于是有了：









BFS(G,s)

    for each
 vertex v in V[G]

        status[v]
 = WHITE

        /******其他初始化******/

    status[s]
 = GRAY    //s是原点

    queue
 q

    入队(q,s);

    while q非空

        t
 = 出队(q);

        for each
 vertex v in Adj[t] //与t邻接的点

            if status[v]
 = WHITE    //只对未访问的操作

                status[v]
 = GRAY    //标记为第一次访问

                /******其他操作******/

                入队(q,v)

        status[t]
 = BLACK   //此点已经处理完了









导轮还在上面伪代码的“其他”中加入了访问长度和父节点的操作。此举可以算出，从源点到其他顶点路径的最少步数和它的具体路径。

关于广度优先搜索的一个简单应用：

假如有问题，每个村庄之间都通过桥来联通，先给出村庄的图，问村庄A到村庄B最少要通过多少座桥？这个问题可以很容易的转化为上面的BFS问题。






深度优先搜索


深度优先搜索（DFS），可以被形象的描述为“打破沙锅问到底”，具体一点就是访问一个顶点之后，我继而访问它的下一个邻接的顶点，如此往复，直到当前顶点一被访问或者它不存在邻接的顶点。

同样，算法导论采用了“聪明的做法”，用三种颜色来标记三种状态。但这三种状态不同于广度优先搜索：

WHITE 未访问顶点GRAY 一条深度搜索路径上的顶点，即被发现时BLACK 此顶点的邻接顶点被全部访问完之后——结束访问次顶点






DFS(G,s)

    for each
 vertex v in V(G)

        status[v]
 = WHITE

        /******其他初始化******/

    for each
 vertex v in V(G)

        if(status[v]==WHITE)

            DFS-VISIT(v)

 

DFS-VISIT(v)

    status[v]
 = GRAY

    for each
 vertex t in Adj(v)

        if status[t]
 = WHITE

            DFS-VISIT(t)

            /******其他操作******/

    status[v]
 = BLACK





通过给DFS搜索过程中给每一个顶点加时间戳，就可以实现拓扑排序了。实现拓扑排序需要：

对于每一个顶点，都有两个时间戳，分别这样来定义：

在一顶点刚被发现的时候，标记此顶点的第一个时间戳；在结束此顶点的访问的时候，标记此顶点的第二个时间戳。时间戳可以用简单的123456来标记，只要能区分大小就行。

因此，你会发现，越早发现的点，他的第一个时间戳会越小，但是他的第二个时间戳会越大。 

总结

两个算法都是O(V+E)，在用到的时候适当选取。在使用白灰黑标志的时候，突然明白了如何用深度优先搜索来判断有向图中是否存在环。

深度优先和广度优先各有各的优缺点:

 

广优的话，占内存多，能找到最优解，必须遍历所有分枝. 广优的一个应用就是迪科斯彻单元最短路径算法.深优的话，占内存少，能找到最优解（一定条件下），但能很快找到接近解（优点），可能不必遍历所有分枝（也就是速度快）, 深优的一个应用就是连连看游戏.

 

在更多的情况下，深优是比较好的方案。

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 4081Qin Shi Huang's National Road System（最小生成树+最小瓶颈路）

﻿﻿
题意：秦始皇要修路，把N个城市用N-1条边连通。且他希望花费最小，但是这时候有一个多管闲事的道士出来说他有魔法可以帮助秦始皇变成一条路，但是只能变出一条。但是，两个人对修路的法案存在歧义，道士希望修路可以给更多的百姓带来福利，而秦始皇希望修路要尽量使花费小。最后，秦始皇拿出了一个公式A/B，A表示两个城市的人数，B表示出了用魔法变出来的路外，最短的总距离。现在要你求出A/B的最大值。
思路：枚举连接哪两个城市，因为这条边是免费的，我们要求算上这条边的最小生成树，如果每次都求一次最小生成树会超时，所以先跑一遍整个图的最小生成树，然后再预处理出这个mst上的任意两点之间路径的最大值，因为添加免费边时，去掉的就是这个最大边，这样一样时间复杂度降为O(n*n)。
#include<cstdio>  
#include<cstring>  
#include<cmath>  
#include<cstdlib>  
#include<iostream>  
#include<algorithm>  
#include<vector>  
#include<map>  
#include<queue>  
#include<stack> 
#include<string>
#include<map> 
#include<set>
#define eps 1e-6 
#define LL long long  
using namespace std;  

const int maxn = 1050;
const int maxm = maxn*maxn;
//const int INF = 0x3f3f3f3f;
vector<int> G[maxn];
int vis[maxn];
int n, m, ple[maxn], x[maxn], y[maxn];
int u[maxm], v[maxm], p[maxn], r[maxm];
double w[maxm], W[maxn][maxn], maxcost[maxn][maxn];;
bool cmp(const int i, const int j) {
	return w[i] < w[j];
} 
int find(int x) {
	return p[x] == x ? x : p[x] = find(p[x]);
}
double Kruscal() {
	double ans = 0;
	for(int i = 0; i < n; i++) p[i] = i; //初始化并查集 
	for(int i = 0; i < m; i++) r[i] = i; //初始化边序号
	sort(r, r+m, cmp);
	for(int i = 0; i < m; i++) {
		int e = r[i]; 
		int x = find(u[e]), y = find(v[e]);
		if(x != y) {
			ans += w[e];
			p[x] = y;
			G[u[e]].push_back(v[e]); G[v[e]].push_back(u[e]);
		}
	}
	return ans;
}
void init() {
	memset(vis, 0, sizeof(vis));
	for(int i = 0; i < n; i++) G[i].clear();
}
void dfs(int cur, int fa) {
	maxcost[cur][cur] = 0;
	if(fa != -1) {
		for(int i = 0; i < n; i++) if(vis[i]){
			maxcost[i][cur] = maxcost[cur][i] = max(maxcost[i][fa], W[fa][cur]);
		}
	}
	vis[cur] = 1;
	for(int i = 0; i < G[cur].size(); i++) {
		int u = G[cur][i];
		if(u == fa) continue;
		dfs(u, cur);
	}
}
int main() {
	//freopen("input.txt", "r", stdin);
	int T; cin >> T;
	while(T--) {
		cin >> n;
		for(int i = 0; i < n; i++) scanf("%d%d%d", &x[i], &y[i], &ple[i]);
		m = 0;
		for(int i = 0; i < n; i++) {
			for(int j = i+1; j < n; j++) {
				u[m] = i; v[m] = j;
				w[m] = sqrt((double)((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
				W[i][j] = W[j][i] = w[m];
				m++;
			}
		}
		init();
		double mst = Kruscal(); 
		//cout << mst << endl;
		dfs(0, -1);
		double ans = 0;
		for(int i = 0; i < n; i++) {
			for(int j = i+1; j < n; j++) {
				ans = max(ans, (double)(ple[i]+ple[j])/(mst-maxcost[i][j]));
			}
		}
		printf("%.2lf\n", ans);
	} 
	return 0;
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

poj 3164 Command Network 【最小树形图】【朱刘算法 入门】

Command Network




Time Limit: 1000MS
 
Memory Limit: 131072K


Total Submissions: 14782
 
Accepted: 4249




Description


After a long lasting war on words, a war on arms finally breaks out between littleken’s and KnuthOcean’s kingdoms. A sudden and violent assault by KnuthOcean’s force has rendered a total failure of littleken’s command network. A provisional network must
 be built immediately. littleken orders snoopy to take charge of the project.
With the situation studied to every detail, snoopy believes that the most urgent point is to enable littenken’s commands to reach every disconnected node in the destroyed network and decides on a plan to build a unidirectional communication network. The
 nodes are distributed on a plane. If littleken’s commands are to be able to be delivered directly from a node A to another node B, a wire will have to be built along the straight line segment connecting the two nodes. Since it’s in wartime, not between all
 pairs of nodes can wires be built. snoopy wants the plan to require the shortest total length of wires so that the construction can be done very soon.

Input


The input contains several test cases. Each test case starts with a line containing two integer N (N ≤ 100), the number of nodes in the destroyed network, and M (M ≤ 104), the number of pairs of nodes between
 which a wire can be built. The next N lines each contain an ordered pair xi and yi, giving the Cartesian coordinates of the nodes. Then follow M lines each containing two integers i and j between
 1 and N (inclusive) meaning a wire can be built between node i and node j for unidirectional command delivery from the former to the latter. littleken’s headquarter is always located at node 1. Process to end of file.

Output


For each test case, output exactly one line containing the shortest total length of wires to two digits past the decimal point. In the cases that such a network does not exist, just output ‘poor snoopy’.

Sample Input
4 6
0 6
4 6
0 0
7 20
1 2
1 3
2 3
3 4
3 1
3 2
4 3
0 0
1 0
0 1
1 2
1 3
4 1
2 3
Sample Output
31.19
poor snoopy

题意：给你N个点的坐标和M条有向边，问你以点1为根的最小树形图的边权之和。

入门题：因为犯二把缩点那部分放到记录环的for循环里面，找bug找了好久。

#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#define MAXN 110
#define MAXM 20000+10
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to;
    double cost;
};
Edge edge[MAXM];
int pre[MAXN];
int vis[MAXN];
int id[MAXN];
double in[MAXN];
int N, M;
struct Node
{
    double x, y;
};
Node num[MAXN];
double dis(Node a, Node b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}
void getMap()
{
    for(int i = 0; i < N; i++)
        scanf("%lf%lf", &num[i].x, &num[i].y);
    int a, b;
    for(int i = 0; i < M; i++)
    {
        scanf("%d%d", &a, &b);
        a--, b--;
        edge[i].from = a;
        edge[i].to = b;
        edge[i].cost = a==b ? INF : dis(num[a], num[b]);//去除自环 自己到自己无穷大
    }
}
double zhuliu(int root, int n, int m, Edge *edge)
{
    double res = 0;
    int u, v;
    while(1)
    {
        for(int i = 0; i < n; i++) in[i] = INF;
        for(int i = 0; i < m; i++)
        {
            Edge E = edge[i];
            if(E.from != E.to && E.cost < in[E.to])
            {
                pre[E.to] = E.from;
                in[E.to] = E.cost;
            }
        }
        for(int i = 0; i < n; i++)
            if(i != root && in[i] == INF)
                return -1;
        int tn = 0;
        memset(id, -1, sizeof(id));
        memset(vis, -1, sizeof(vis));
        in[root] = 0;
        for(int i = 0; i < n; i++)
        {
            res += in[i];
            v = i;
            while(vis[v] != i && id[v] == -1 && v != root)
            {
                vis[v] = i;
                v = pre[v];
            }
            if(v != root && id[v] == -1)
            {
                for(u = pre[v]; u != v; u = pre[u])
                    id[u] = tn;
                id[v] = tn++;
            }
        }
        if(tn == 0) break;
        for(int i = 0; i < n; i++)
            if(id[i] == -1)
                id[i] = tn++;
        for(int i = 0; i < m; )
        {
            v = edge[i].to;
            edge[i].from = id[edge[i].from];
            edge[i].to = id[edge[i].to];
            if(edge[i].from != edge[i].to)
                edge[i++].cost -= in[v];
            else
                swap(edge[i], edge[--m]);
        }
        n = tn;
        root = id[root];
    }
    return res;
}
int main()
{
    while(scanf("%d%d", &N, &M) != EOF)
    {
        getMap();
        double ans = zhuliu(0, N, M, edge);
        if(ans == -1)
            printf("poor snoopy\n");
        else
            printf("%.2lf\n", ans);
    }
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU Cut Pieces (计数+求逆元)
题目链接：传送门 
题意：
n个人每个人有n种选择，确定这n个人的排列，使得最后的块数最多。块数是这样算的。1 1 2 算成2块，举一个例子来说明：
1 , 2, 3 
然后根据排列来计算块数， 1 1 1 （1块）1 1 2（2块） 1 1 3（两块）1 2 1 （1块）1,2,3（3块） 1 2 2（两块）
下面来分析如何排列与如何计算总的块数。
分析：
构造排列的时候我们首先要想到这个问题，只考虑相邻的两个元素，他们相同的情况就是min(ai,ai+1),因此我们要使相邻的两个元素相差尽可能的大，因此对原来的序列排序，最小，最大，次小，次大。。。
然后再计算的时候我们从反面考虑，不算重复的情况下的块数为a1*a2*...*an，然后减去重复的块数，重复的块数我们只考虑相邻的两个他们有min(ai,ai+1)种，然后我a1*..ai-1*ai+1*..*an种排列可以使他们重复，然后减去就可以了。
代码如下：
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

#define lson num<<1
#define rson num<<1|1
#define gl l,m,lson
#define gr m+1,r,rson
using namespace std;

const int maxn = 1e6+10;

typedef long long LL;

const LL mod = 1e9+7;

LL a[maxn];

LL b[maxn];

LL quick_mod(LL a,LL b){
    LL ans = 1;
    while(b){
        if(b&1) ans = ans*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return ans;
}

int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        LL n;
        scanf("%I64d",&n);
        LL ans = 1,fuck;
        for(int i=1;i<=n;i++){
            scanf("%I64d",a+i);
            ans=ans*a[i]%mod;
        }
        fuck = ans;
        sort(a+1,a+n+1);
        int cnt = 1;
        for(int i=1;i<=n/2+1;i++){
            b[cnt++]=a[i];
            b[cnt++]=a[n-i+1];
        }
        ans = ans*n%mod;
        for(int i=2;i<=n;i++){
            LL tmp = fuck*quick_mod(b[i-1]*b[i]%mod,mod-2)%mod;
            ans=(ans-tmp*min(b[i],b[i-1])%mod)%mod;
        }
        printf("%I64d\n",(ans+mod)%mod);
    }
    return 0;
}

/****
555
5
1 2 3 4 5
492
***/



版权声明：本文为博主原创文章，未经博主允许不得转载。

关于使用matplotlib-legend方法失效问题


在使用matplotlib画图时， legend方法失效，





着了好长时间，才在stackoverflow上找到这篇文章
http://stackoverflow.com/questions/11983024/matplotlib-legends-not-working

改完之后就好了













版权声明：本文为博主原创文章，未经博主允许不得转载。

topcoders 666
早起切两水：
222:
class DevuAndGame
{
        public:

        int vis[55];
        int a[55];
        int dfs(int u)
        {
            if(u == -1) return 1;
            vis[u] = 1;
            int v = a[u];
            if(vis[v])
                return 0;

            return dfs(v);
        }

        string canWin(vector <int> nextLevel)
        {
            for(int i = 0; i < nextLevel.size(); i++)
                a[i] = nextLevel[i];

                memset(vis, 0,sizeof vis);
                int ans = dfs(0);
                if(ans) return "Win";
                else return "Lose";
        }
};


444:
class GoodString
{
        public:
        string isGood(string s)
        {
            int len = s.size();
            int cnt = 0;
            for(int i = 0; i < len; i++)
            {
                if(s[i] == 'a')
                    cnt++;
                else cnt--;
                if(cnt < 0) break;
            }
            if(cnt < 0 || cnt > 0)
                return "Bad";
            else return "Good";
        }
};



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5371(Hotaru's problem-2次回文串)

Hotaru's problem
Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 2432    Accepted Submission(s): 841


Problem Description
Hotaru Ichijou recently is addicated to math problems. Now she is playing with N-sequence.
Let's define N-sequence, which is composed with three parts and satisfied with the following condition:
1. the first part is the same as the thrid part,
2. the first part and the second part are symmetrical.
for example, the sequence 2,3,4,4,3,2,2,3,4 is a N-sequence, which the first part 2,3,4 is the same as the thrid part 2,3,4, the first part 2,3,4 and the second part 4,3,2 are symmetrical.

Give you n positive intergers, your task is to find the largest continuous sub-sequence, which is N-sequence.

 

Input
There are multiple test cases. The first line of input contains an integer T（T<=20）, indicating the number of test cases.


For each test case:

the first line of input contains a positive integer N（1<=N<=100000）, the length of a given sequence

the second line includes N non-negative integers ,each interger is no larger than
109
 , descripting a sequence.

 

Output
Each case contains only one line. Each line should start with “Case #i: ”,with i implying the case number, followed by a integer, the largest length of N-sequence.

We guarantee that the sum of all answers is less than 800000.

 

Sample Input

1
10
2 3 4 4 3 2 2 3 4 4

 

Sample Output

Case #1: 9

 

Author
UESTC
 

Source
2015 Multi-University Training Contest 7

 

Recommend
wange2014   |   We have carefully selected several similar problems for you:  5421 5420 5419 5418 5417 
 





先匹配第一个，再暴力找第二个，
注意只找比当前答案优的优化速度








#include<bits/stdc++.h> 
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define Rep(i,n) for(int i=0;i<n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i>=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define Forpiter(x) for(int &p=iter[x];p;p=next[p])  
#define Lson (x<<1)
#define Rson ((x<<1)+1)
#define MEM(a) memset(a,0,sizeof(a));
#define MEMI(a) memset(a,127,sizeof(a));
#define MEMi(a) memset(a,128,sizeof(a));
#define INF (2139062143)
#define F (100000007)
#define MAXN (300000+10)
#define Sp_char1 (-1)
#define Sp_char2 (-2)
typedef long long ll;
ll mul(ll a,ll b){return (a*b)%F;}
ll add(ll a,ll b){return (a+b)%F;}
ll sub(ll a,ll b){return (a-b+llabs(a-b)/F*F+F)%F;}
void upd(ll &a,ll b){a=(a%F+b%F)%F;}
int a[MAXN],n,r[MAXN];
class manacher
{
public:
	int n;
	int s[MAXN];
	int p[2*MAXN+2];
	void mem(){n=0; MEM(s) MEM(p)}
	int str[MAXN*2+2];
	void work()
	{
		str[0]=Sp_char1;
		Rep(i,n) str[2*i+1]=Sp_char2,str[2*i+2]=s[i]; 
		str[2*n+1]=Sp_char2; str[2*n+2]=-3;
		
		n=2*n+2; MEM(p) 
		int mx=0,id=0;
		For(i,n-1) 
		{
			if (i<mx) p[i]=min(p[2*id-i],mx-i);
			
			while(str[i-p[i]]==str[i+p[i]]) ++p[i];
			if (mx<i+p[i]) //mx为已查明的最右端 
			{
				mx=i+p[i];
				id=i;
			}
		}
	}
}S;

int main()
{
//	freopen("C.in","r",stdin);
	
	int T;cin>>T;
	For(kcase,T) {
		S.mem();
		scanf("%d",&n);
		For(i,n) scanf("%d",&a[i]),S.s[i-1]=a[i];
		S.n=n;
	
		S.work();
		int ans=0;
		for(int i=3;i<S.n;i+=2) 
		{ 
			 for(int j=S.p[i];j>ans;j-=2)
			 {
			 	if (S.p[i+(j-1)]>=j) ans=max(ans,j); 
			 }
		}
		ans=(ans-1)/2*3;
		printf("Case #%d: %d\n",kcase,ans);
	} 
	
	
	return 0;
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

VB.NET反序列化XML
序列化，是将对象状态转换为可保持或传输的格式的过程。
与序列化相反的是反序列化，它将流转换为对象。这两个过程结合起来，就可以存储和传输数据。这就是序列化的意义所在。


在VB.NET中转换、处理和生成XML文档时，需要用到一些XML专用名称空间中的类，这些名称空间包括：
System.Xml    该名称空间提供了对各种XML标准（包括DTD、名称空间、DOM、XDR（XML Data Reduced，XML架构标准的旧版本）、XPath、XSLT和SOAP（以前表示Simple Object Access Protocol标准，现在什么也不表示））的核心支持。
System.Xml.Serialization    该名称空间提供的对象使用序列化技术进行对象与XML文档或流之间的转换。
System.Xml.Schema    该名称空间提供一组用于加载、创建和输出架构的对象，这些对象可以在内存中操作组成XML架构的各种实体
System.Xml.Xpath    该名称空间为XPath（XML Path Language）提供语法分析程序和估算引擎。
System.Xml.Xsl    该名称空间提空了使用XSL（Extensible Stylesheet Language）和XSLT（XSL Transformation）时必须用到的对象。

System.Xml.Linq    该名称空间提供了使用LINQ查询XML的支持。



今天我想讨论的是VB.NET反序列化XML。

以下是我想反序列化的XML的结构：
<card>
	<sCodeBorder y1='34' y2='120' x2='568' x1='360' />
	<border y1='0' y2='1008' x2='1650' x1='0' />
	<area>
		<question id='1' x1='70' y1='274' x2='180' y2='288' >
			<option id='A' x1='70' y1='274' x2='90' y2='288' />
		</question>
		<question id='2' x1='70' y1='298' x2='180' y2='312' >
			<option id='A' x1='70' y1='298' x2='90' y2='312' />
			<option id='B' x1='100' y1='298' x2='120' y2='312' />
		</question>
		<question id='3' x1='70' y1='322' x2='180' y2='336' >
			<option id='A' x1='70' y1='322' x2='90' y2='336' />
			<option id='B' x1='100' y1='322' x2='120' y2='336' />
			<option id='C' x1='130' y1='322' x2='150' y2='336' />
		</question>
	</area>
</card>
我们首先要做的是创建与XML相对应的对象，然后再把XML转换成我们想要的对象。
创建的类中需要引用System.Xml.Serialization 命名空间。这一命名空间包含用于将对象序列化为XML格式文档或流的类。
Public Class card
    <XmlElementAttribute("sCodeBorder")> Public sCodeBorder As sCodeBorder
    <XmlElementAttribute("border")> Public border As border
    <XmlElementAttribute("area")> Public area As area

    Public Sub New()
    End Sub

    Public Sub New(ByVal sCodeBorder As sCodeBorder, ByVal border As border, ByVal area As area )
        Me.sCodeBorder = sCodeBorder
        Me.border = border
        Me.area = area
    End Sub
End Class
Public Class sCodeBorder
    <XmlAttributeAttribute("x1")> Public x1 As Integer
    <XmlAttributeAttribute("x2")> Public x2 As Integer
    <XmlAttributeAttribute("y1")> Public y1 As Integer
    <XmlAttributeAttribute("y2")> Public y2 As Integer

    Public Sub New()
    End Sub
    Public Sub New(ByVal x1 As Integer, ByVal x2 As Integer, ByVal y1 As Integer, ByVal y2 As Integer)
        Me.x1 = x1
        Me.x2 = x2
        Me.y1 = y1
        Me.y2 = y2
    End Sub
End Class
Public Class border
    <XmlAttributeAttribute("x1")> Public x1 As Integer
    <XmlAttributeAttribute("x2")> Public x2 As Integer
    <XmlAttributeAttribute("y1")> Public y1 As Integer
    <XmlAttributeAttribute("y2")> Public y2 As Integer

    Public Sub New()
    End Sub
    Public Sub New(ByVal x1 As Integer, ByVal x2 As Integer, ByVal y1 As Integer, ByVal y2 As Integer)
        Me.x1 = x1
        Me.x2 = x2
        Me.y1 = y1
        Me.y2 = y2
    End Sub
End Class
Public Class area
    <XmlElementAttribute("question")> Public Ques_List() As question
    Public Sub New()
    End Sub

    Public Sub New(ByVal multiQ() As question)
        Me.Ques_List = multiQ
    End Sub
End Class


question类中维护了option类的对象集合。
Public Class question
    <XmlAttributeAttribute("x1")> Public x1 As Integer
    <XmlAttributeAttribute("x2")> Public x2 As Integer
    <XmlAttributeAttribute("y1")> Public y1 As Integer
    <XmlAttributeAttribute("y2")> Public y2 As Integer
    <XmlAttributeAttribute("id")> Public id As String
    <XmlElementAttribute("option")> Public multiOptions_List() As option_
    Public Sub New()
    End Sub

    Public Sub New(ByVal x1 As Integer, ByVal x2 As Integer, ByVal y2 As Integer, ByVal y1 As Integer, ByVal id As String, ByVal multiO() As option_)
        Me.x1 = x1
        Me.x2 = x2
        Me.y2 = y2
        Me.y1 = y1
        Me.id = id
        Me.multiOptions_List = multiO
    End Sub
End Class
Public Class option_
    <XmlAttributeAttribute("x1")> Public x1 As Integer
    <XmlAttributeAttribute("x2")> Public x2 As Integer
    <XmlAttributeAttribute("y1")> Public y1 As Integer
    <XmlAttributeAttribute("y2")> Public y2 As Integer
    <XmlAttributeAttribute("id")> Public id As String

    Public Sub New()
    End Sub

    Public Sub New(ByVal x1 As Integer, ByVal x2 As Integer, ByVal y2 As Integer, ByVal y1 As Integer, ByVal id As String)
        Me.x1 = x1
        Me.x2 = x2
        Me.y2 = y2
        Me.y1 = y1
        Me.id = id
    End Sub
End Class
这样XML要反序列化的类就建立好了。虽然说有些复杂，但是有了这些类，我们就不用一个一个地处理XML的节点了~
具体到反序列化的代码，就很简单了。代码如下：
Dim cardXML As FileStream = New FileStream(xmlPath, FileMode.Open)
'card是类名，也是根节点
Dim serialize As XmlSerializer = New XmlSerializer(GetType(card))
Dim wholeCard As card = serialize.Deserialize(cardXML)
cardXML.Close()
上面代码的xml来源是磁盘上的文件。
但有的时候，xml是以字符串的形式给出的。这时候我们该如何处理呢？
从反序列化的定义可知，反序列化是把流转为对象。
上面的代码是以文件流的形式来反序列化。如果是字符串的话，我们就需要把字符串存入内存流中，再把内存流反序列化。
Dim descBytes() As Byte = System.Text.Encoding.Unicode.GetBytes(xmlString)
Dim serialize As XmlSerializer = New XmlSerializer(GetType(card))
Dim wholeCard As card = serialize.Deserialize(New MemoryStream(descBytes))
以上就是xml反序列化的过程。



参考文献：Visual.Basic.2010 & NET 4 高级编程

版权声明：本文为博主原创文章，未经博主允许不得转载。

C代码中如何调用C++ C++中如何调用C
1. 在C++中调用C：使用extern "C"则是告诉编译器依照C的方式来编译封装接口，当然接口函数里面的C++语法还是按C++方式编译。包装（wrapper）2. 在C中调用C++：extern "C" 的作用是：让C++连接器找调用函数的符号时采用C的方式注意这里的C调用C++或者C++调用C意思是.c文件中调用.cpp文件中代码，或者相反。集成开发环境如VC++6.0或者vs都是以文件后缀来区别当前要编译的是C代码还是Ｃ＋＋代码，然后采用响应的编译、调用协议等。使用extern "C" 主要是因为C编译器编译函数时不带参数的类型信息，只包含函数的符号名字。如 int foo( float x )C编译器会将此函数编译成类似_foo的符号，C连接器只要找到了调用函数的符号，就认为连接成功。而C++编译器为了实现函数重载，会在编译时带上函数的参数信息。如它可以把上面的函数编译成类似于_foo_float这样的符号。所以，C调用C++，使用extern "C"则是告诉编译器依照C的方式来编译封装接口，当然接口函数里面的C++语法还是按C++方式编译。如：1 普通函数// C++ Codeextern "C" int foo( int x );int foo( int x ){   //...}这样,编译器会将foo函数编译成类似_foo符号，而不会编译成类似_foo_int符号则C可以这样调用C++函数// C Codeint foo( int x );void cc( int x ){    foo( x );    //...}2 如果想调用重载的C++函数，则须封装单独的接口共C调用。如// C++ Codevoid foo( int x );void foo( float x );extern "C" void foo_i( int x ){    foo( x );}extern "C" void foo_f( float x ){    foo( x );}则C中可这样调用// C Codevoid foo_i( int x );void foo_f( float x );void ccc( int x1, float x2 ){    foo_i( x1 );    foo_f( x2 );    // ...} 3 C中想调用C++中的成员函数（包括虚函数），则需要提供一个简单的包装（wrapper）。例如： // C++ code:class C{  ...  virtual double f(int);};extern "C" double call_C_f(C* p, int i) // wrapper function{return p->f(i);}然后，你就可以这样调用 C::f()：//C codedouble call_C_f(struct C* p, int i);//声明void ccc(struct C* p, int i){   double d=call_C_f(p,i); ...}问题：参数struct C* p从哪里来，即怎么在C中定义C++对象，其实上面只是说了思想，真实的c中使用C++类需要把原来的类都封装一下，参看下面的文章http://blog.csdn.net/caspiansea/article/details/9676153而C++调用C，extern "C" 的作用是：让C++连接器找调用函数的符号时采用C的方式 如：// C Codevoid foo( int x );C++这样调用C函数// C++ Codeextern "C" void foo( int x );就是让C++连接器能过类似于_foo来查找此函数，而非类似于_foo_int这样的符号。 时常在cpp的代码之中看到这样的代码: 特别是C ++中引入C的头文件，这些C头文件中出现很多如下代码。#ifdef __cplusplus extern "C" { #endif//一段代码#ifdef __cplusplus } #endif 　其中__cplusplus是C++编译器的保留宏定义．就是说C++编译器认为这个宏已经定义了．所以关键是extern "C" {}extern "C"是告诉Ｃ＋＋编译器件括号里的东东是按照C的obj文件格式编译的，要连接的话按照C的命名规则去找．　　要明白为何使用extern "C"，还得从cpp中对函数的重载处理开始说起。在c++中，为了支持重载机制，在编译生成的汇编码中，要对函数的名字进行一些处理，加入比如函数的返回类型等等.而在C中，只是简单的函数名字而已，不会加入其他的信息.也就是说:C++和C对产生的函数名字的处理是不一样的.明白了加入与不加入extern "C"之后对函数名称产生的影响，我们继续我们的讨论:为什么需要使用extern "C"呢？C++之父在设计C++之时，考虑到当时已经存在了大量的C代码，为了支持原来的C代码和已经写好C库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。　　试想这样的情况:一个库文件已经用C写好了而且运行得很良好，这个时候我们需要使用这个库文件，但是我们需要使用C++来写这个新的代码。如果这个代码使用的是C++的方式链接这个C库文件的话，那么就会出现链接错误.现在我们有了一个C库文件，它的头文件是f.h，产生的lib文件是f.lib，那么我们如果要在C++中使用这个库文件，我们需要这样写:extern "C" {#include "f.h"}

版权声明：本文为【借你一秒】原创文章，转载请标明出处。

centos 安装golang
vim  $HOME/.profile


export GOROOT=$HOME/go
export PATH=$PATH:$GOROOT/bin
export GOPATH=/home/work/gopath


source ./profile


在安装目录下新建两个目录
mkdir go
mkdir gopath


下载源文件 
wget https://storage.googleapis.com/golang/go1.5.linux-amd64.tar.gz


解压
tar -C /usr/local -xzf go1.5.linux-amd64.tar.gz


搞定！

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU4185Oil Skimming（行列匹配||棋盘匹配||黑白染色||1X2矩形覆盖）
题意：找出最多的形如“##”横着竖着都可以，明显的1X2矩形覆盖，直接按坐标和的奇偶来分为二分图。

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<set>
#include<map>
#include<string>
#include<cstring>
#include<stack>
#include<queue>
#include<vector>
#include<cstdlib>
#define lson (rt<<1),L,M
#define rson (rt<<1|1),M+1,R
#define M ((L+R)>>1)
#define cl(a,b) memset(a,b,sizeof(a));
#define LL long long
#define P pair<int,int>
#define X first
#define Y second
#define pb push_back
#define fread(zcc)  freopen(zcc,"r",stdin)
#define fwrite(zcc) freopen(zcc,"w",stdout)
using namespace std;
const int maxn=610;
const int inf=999999;


vector<int> G[maxn*maxn];
int matching[maxn*maxn];//因为对坐标是按行展开的编号，所以这里都要对应变大
bool vis[maxn*maxn];
int Nx;
bool dfs(int u){
    int N=G[u].size();
    for(int i=0;i<N;i++){
        int v=G[u][i];
        if(vis[v])continue;
        vis[v]=true;
        if(matching[v]==-1||dfs(matching[v])){
            matching[v]=u;
            return true;
        }
    }
    return false;
}
int hungar(){
    int ans=0;
    cl(matching,-1);
    for(int i=0;i<Nx;i++){
        cl(vis,false);
        if(dfs(i))ans++;
    }
    return ans;
}
char s[maxn][maxn];
int dir[][2]={1,0,0,1,-1,0,0,-1};
int main(){
    int T,cas=1;
    scanf("%d",&T);
    while(T--){
        int n;
        scanf("%d",&n);
        for(int i=0;i<n;i++){
            scanf("%s",s[i]);//图要全部读完，再去建立图
        }
        for(int i=0;i<n;i++){//建立二分图
            for(int j=0;j<n;j++)if((i+j)%2==0&&s[i][j]=='#'){
                for(int k=0;k<4;k++){
                    int xx=dir[k][0]+i;
                    int yy=dir[k][1]+j;
                    if(xx>=0&&xx<n&&yy>=0&&yy<n&&s[xx][yy]=='#'){
                        G[i*n+j].pb(xx*n+yy);
                    }
                }
            }
        }

        Nx=n*n;
        printf("Case %d: %d\n",cas++,hungar());
        for(int i=0;i<=n*n;i++)G[i].clear();
    }
    return 0;
}














            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

《Java实战开发经典》第五章5.5
package five;
public class Five { 
public static void main(String[] args) { 
    User p1=new User(); 
    p1.tell(); 
    User p2=new User(“xpq”); 
    p2.tell(); 
    User p3=new User(“xpq”,”mima123”); 
    p3.tell(); 
} 
} 
class User{ 
    private String userName; 
    private String password; 
    private static int num;             //使用static属性统计一个类到底产生了多少个实例化对象 
    public User(){                                  //定义无参构造方法 
        num++; 
    }; 
    public User(String userName){                   //定义单参构造方法 
        num++; 
        this.userName=userName; 
    } 
    public User(String userName,String password){   //定义双参构造方法 
        num++; 
        this.userName=userName; 
        this.password=password; 
    } 
    public String getPassword(){                    //获取口令的方法 
         return password; 
    } 
    public void setPassword(String password){       //设置口令的方法 
        this.password=password; 
    } 
    public void tell(){ 
        System.out.println(“用户名为”+userName+”对应口令为”+password+”用户个数为”+num); 
    } 
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java实体Date类型属性值无法保存到数据表对应字段的问题
Java实体Date类型属性值无法保存到数据表对应字段的问题项目框架：maven+springMVC+mybatis实体属性：//推荐时间private java.util.Date recommendDate;数据库字段：ALTER TABLE `resource`ADD COLUMN `RECOMMEND_DATE`  date NULL COMMENT '推荐时间';属性赋值：resource.setRecommendDate(DateUtils.getNowDate());相关方法：获取现在时间	/**
	 * 获取现在时间
	 * 
	 * @return 返回时间类型 yyyy-MM-dd HH:mm:ss
	 */
	public static Date getNowDate() {
		Date currentTime = new Date();
		SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateString = formatter.format(currentTime);
		ParsePosition pos = new ParsePosition(8);
		Date currentTime_2 = formatter.parse(dateString, pos);
		return currentTime_2;
	}问题：执行保存时跟踪MySql日志发现字段值是NULLresourceManager.saveOrUpdate(resource);RECOMMEND_DATE = null原因分析：产生此问题的原因估计是类型不匹配的问题！但即没有异常，也没有警告；解决方法：后来由于需要保存日期时间，所以将数据库类型改为datetime；实体属性映射为：//推荐时间private java.sql.Timestamp recommendDate;

版权声明：本文为博主原创文章，未经博主允许不得转载。

每日五题（java基础）
 今天宿舍断网了，在网吧写了这篇文章，所以大家要像我一样坚持，啊哈哈哈

1.说出Service的生命周期，并说出Servlet和CGI的区别
Servlet的生命周期分为5个阶段: 
实例化：Servlet容器创建Servlet类的实例。 
初始化：该容器调用init()方法，通常会申请资源。 
服务：由容器调用service()方法，（也就是doGet()和doPost()）。 
破坏：在释放Servlet实例之前调用destroy()方法，通常会释放资源。 
不可用：释放内存的实例。
CGI（Common Gateway Interface通用网关接口）程序来实现数据在Web上的传输，使用的是如Perl这样的语言编写的，它对于客户端作出的每个请求，必须创建CGI程序的一个新实例，这样占用大量的内存资源。由此才引入了Servlet技术。
Servlet是一个用java编写的应用程序，在服务器上运行，处理请求信息并将其发送到客户端。对于客户端的请求，只需要创建Servlet的实例一次，因此节省了大量的内存资源。Servlet在初始化后就保留在内存中，因此每次作出请求时无需加载。
2.说出ArrayList，Vector,LinkedList的存储性能和特性
ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢. 
Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差 
而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
3.EJB是基于那些技术实现的？并说出SessionBean和EntityBean的区别,StatefulBean和StatelassBean的区别
EJB包括Session Bean、Entity Bean、Message Driven Bean，基于JNDI、RMI、JAT等技术实现。 
SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他EJB组件。EntityBean被用来代表应用系统中用到的数据。 
对于客户机，SessionBean是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。 
对于客户机，EntityBean是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。 
Session Bean 还可以再细分为 Stateful Session Bean 与 Stateless Session Bean ，这两种的 Session Bean都可以将系统逻辑放在 method之中执行，不同的是 Stateful Session Bean 可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的 Stateful Session Bean 的实体。Stateless Session Bean 虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫 Stateless Session Bean 的时候，EJB Container 并不会找寻特定的 Stateless Session Bean 的实体来执行这个 method。换言之，很可能数个使用者在执行某个 Stateless Session Bean 的 methods 时，会是同一个 Bean 的 Instance 在执行。从内存方面来看， Stateful Session Bean 与 Stateless Session Bean 比较， Stateful Session Bean 会消耗 J2EE Server 较多的内存，然而 Stateful Session Bean 的优势却在于他可以维持使用者的状态。
4.Coleection和Collections的区别.
Collection 和 Collections的区别。  
Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。 
Collection是个java.util下的接口，它是各种集合结构的父接口。 
List, Set, Map是否继承自Collection接口? List，Set是  Map不是 
ArrayList和Vector的区别。 
一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的  
二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半 
HashMap和Hashtable的区别 
一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 
二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 
三.值：只有HashMap可以让你将空值作为一个表的条目的key或value 
5.&和&&的区别
按位与：a&b是把a和b都转换成二进制数然后再进行与的运算； 
逻辑与：a&&b就是当且仅当两个操作数均为 true时，其结果才为 true；只要有一个为零，a&&b就为零。
a&b  9&8 
1001 
1000
结果是1000 

例如：char a=1,b=0,c=-1;那么a真b假c真。a&&b和c&&b为假值为0，a&&c为真值为1
&对每一个都判断； 
&&只要前面是false就输出false，而不继续判断后面了

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

java设计模式学习 ----- 抽象工厂模式（Abstract Factory）
抽象工厂模式（Abstract Factory）工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。请看例子：[java] view plaincopypublic interface Sender {      public void Send();  }  两个实现类：[java] view plaincopypublic class MailSender implements Sender {      @Override      public void Send() {          System.out.println("this is mailsender!");      }  }  [java] view plaincopypublic class SmsSender implements Sender {        @Override      public void Send() {          System.out.println("this is sms sender!");      }  }  两个工厂类：[java] view plaincopypublic class SendMailFactory implements Provider {            @Override      public Sender produce(){          return new MailSender();      }  }  [java] view plaincopypublic class SendSmsFactory implements Provider{        @Override      public Sender produce() {          return new SmsSender();      }  }  在提供一个接口：[java] view plaincopypublic interface Provider {      public Sender produce();  }  测试类：[java] view plaincopypublic class Test {        public static void main(String[] args) {          Provider provider = new SendMailFactory();          Sender sender = provider.produce();          sender.Send();      }  }  这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就可以了，无需去改动现成的代码。这样做，拓展性较好！

版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题23-从上往下打印二叉树
题目：
 从上往下打印出二叉树的每个节点，每一层的节点展昭从左到右的顺序打印。




就是树的广度遍历。
用队列，把树的子节点放到队列中。




public class BinaryTreeNode {
	Integer value;
	BinaryTreeNode left;
	BinaryTreeNode right;

	public BinaryTreeNode(Integer value) {
		this.value = value;
	}

	@Override
	public String toString() {
		return "BinaryTreeNode [value=" + value + "]";
	}

}



/**
 * 从上往下打印出二叉树的每个节点，每一层的节点展昭从左到右的顺序打印。<br/>
 * 即树的广度遍历
 * */
public class PrintFromTopToBottom {

	public void print(BinaryTreeNode root) {
		if (root == null) {
			return;
		}
		BinaryTreeNode current = root;
		Queue<BinaryTreeNode> children = new LinkedList<BinaryTreeNode>();
		while (current != null) {
			System.out.println(current);
			if (current.left != null) {
				children.offer(current.left);
			}
			if (current.right != null) {
				children.offer(current.right);
			}
			if (children.isEmpty()) {
				break;
			} else {
				current = children.poll();
			}
		}
	}
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

寻找和为定值的多个数
问题： 
1. 找出一个序列中和为sum的两个数 
2. 找出一个序列中和为sum的多个数（不限个数） 
3. 找出一个序列中和为sum的4个数
解析：
1. 找出一个序列中和为sum的两个数

将序列排序
用左右2个指针指向序列的头部和尾部
如果当前2个指针指向数的当前和等于sum，则这两个数是一个结果；如果当前和小于sum，说明当前和应该大一点，则将左指针右移 1 位；如果当前和大于sum，说明当前和应该小一点，则将右指针左移 1 位

2. 找出一个序列中和为sum的多个数（不限个数）
0-1 背包问题，考虑是否取第 n 个数可以转化为只和前 n-1 个数有关的问题

取第 n 个数，则问题转为“对 n - 1 个数中，找出和为 sum - input[n-1]的数”（第 n 个数的下标是 n-1）:sumOfkNumber(sum - input[n-1], n - 1)；
不取第 n 个数，则问题转为“对 n - 1 个数中，找出和为 sum的数”:sumOfkNumber(sum, n - 1)；

3. 找出一个序列中和为sum的4个数
针对找出和为sum的多个数，控制加入数的数量，只有恰好有 4 个数，才看做一个结果。
#include <iostream>
#include <vector>
#include <algorithm>
#include <stdlib.h>
using namespace std;
class Solution {
public:
    // 两个数
    void PrintTwoNumWithSum(vector<int> input, int sum)
    {
        if (input.size() < 1 || sum < 0)
            return;
        int i = 0;
        int j = input.size() - 1;
        while (i < j) {
            int curSum = input[i] + input[j];
            if (curSum == sum) {
                cout << input[i] << " " << input[j] << endl;
                ++i;
            } else if (curSum < sum) {
                ++i;
            }   else {
                --j;
            }
        }
    }
    // 多个数
    void PrintNNumWithSum(vector<int> &input, int sum) {
        if (input.size() < 1 || sum < 0)
            return;
        vector<int> result;
        PrintNNumWithSumHelper(input, input.size()-1, sum, result);
    }
    // 四个数
    void Print4NumsWithSum(vector<int> &input, int sum, int m) {
        if (input.size() < 1 || sum < 0)
            return;
        vector<int> result;
        Print4NumWithSumHelper(input, input.size() - 1, sum, m, result);
    }
private:
    // 多个数
    void PrintNNumWithSumHelper(vector<int> &input, int n, int sum, vector<int> &result) {
        if (n < 0 || sum < 0)
            return;
        if (sum == input[n]) {
            cout << input[n] << " ";
            if (result.size() > 0) {
                for (int i = result.size() - 1; i >= 0; i--) {
                    cout << result[i] << " ";
                }
            }
            cout << endl;
        }
        result.push_back(input[n]);
        PrintNNumWithSumHelper(input, n - 1, sum - input[n], result);
        result.pop_back();
        PrintNNumWithSumHelper(input, n - 1, sum, result);
    }
    // 四个数
    void Print4NumWithSumHelper(vector<int> &input, int n, int sum, int m, vector<int> &result) {
        if (n < 0 || sum < 0 || result.size() == m)
            return;
        if (result.size() == m-1 && sum == input[n]) {
            cout << input[n] << " ";
            if (result.size() > 0) {
                for (int i = result.size() - 1; i >= 0; i--) {
                    cout << result[i] << " ";
                }
            }
            cout << endl;
        }
        result.push_back(input[n]);
        Print4NumWithSumHelper(input, n - 1, sum - input[n], m, result);
        result.pop_back();
        Print4NumWithSumHelper(input, n - 1, sum, m, result);
    }
};

int main()
{
    vector<int> input;
    for (int i = 0; i < 50; i++) {
        input.push_back(i + 1);
    }
    sort(input.begin(), input.end());
    Solution sol;
    int sum = 20;
    cout << "======打印和为 " << sum <<" 的两个数=======" << endl;
    sol.PrintTwoNumWithSum(input, sum);
    cout << "======打印和为 " << sum << " 的数=======" << endl;
    sol.PrintNNumWithSum(input, sum);
    cout << "======打印和为 " << sum << " 的4个数=======" << endl;
    sol.Print4NumsWithSum(input, sum, 4);
}
参考资料：https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/02.03.md

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA 11346 Probability (几何概型， 积分)
题目链接：https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2321


题目大意：在A是一个点集 A = {(x, y) | x ∈[-a, a]，y∈[-b, b]}，求取出的点和(0, 0)构成的矩形面积大于S的概率


题目分析：由对称性，考虑第一象限即可，不妨先设xy = S，得到反比例函数y = S / x，先求小于S的概率，就是反比例函数与边界以及x轴y轴围成的面积，这部分面积分为两块，一块是高为b，宽为min(s / b, a)的矩形，另一块需要积分，不过y = S / x这个积分也太简单Y = S*ln(x)，区间就是min(s / b, a)到a，然后用a * b减去那两块面积和就是第一象限中选点大于S的概率，一开始要特判一下100%的情况，不然会变成无穷大
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
double const EPS = 1e-10;

int main()
{
    int T;
    scanf("%d", &T);
    while(T --)
    {
        double a, b, s;
        scanf("%lf %lf %lf", &a, &b, &s);
        if(s - 0 < EPS)
        {
            printf("100.000000%%\n");
            continue;
        }
        double x1 = min(s / b, a);
        double s1 = b * x1 + s * log(a / x1);
        double s2 = a * b - s1;
        double sum = a * b;
        double part = s2;
        double ans = part / sum * 100.0;
        printf("%.6f%%\n", fabs(ans));
    }
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

Java两整数相除保留两位小数
在Java中 两个整数相除 会做取整运算，此时如果希望得到运算结果为浮点数 
则必须将两整数其一或两者都强制转为为浮点数
 
例如：
int a = 9;
int b = 2;
System.out.println((float)a/b);
System.out.println(a/(float)b);
System.out.println((float)a/(float)b);
保留两位小数
DecimalFormat df = new DecimalFormat("0.00");
String s = df.format((float)a/b);
 
作者：itmyhome

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

如何使用Node Profiler

楔子

我们在写代码的时候，往往开始的时候关注功能实现，然后进行性能测试，如果性能满足需求，皆大欢喜，否则，优化之路就开始了。

作为一名合格的屌丝码农，应该把性能优化始终铭记在心，哪怕满足需求了，也要想想是否可以做得更好呢。

然而，JS作为动态语言，与c/c++有很多不同之处。我们知道，JS代码是JS引擎动态编译的。动态语言的一个巨大优势就是引擎可以根据运行时产生的profile对已经在执行的代码尤其是被频繁调用的热点函数进行重新优化编译（V8的crankshaft模块），这依稀就是控制论里面的闭环控制，负反馈嘛，终于发现教科书知识的用途了。哇哈哈～～～

做任何事情都是有规则限制的，JS引擎优化JS代码也不例外，如果我们能够在JS代码里面尽量避免使用JS引擎无法优化的格式，无疑能够最大程度的发挥引擎的能力。

web-inspector里面的cpu-profilor模块能够很好的评测某个JS函数运行十几年占整个工程的比率，这样就可以盯着排名靠前的函数进行优化。 然而，原生的web-inspector只给出了JS函数的执行占用比，并没有列出该函数是否被优化过，如果没有优化，原因又是什么。

我们在深入阅读JS引擎V8代码后，将这些十分关键/有用的信息通过web-inspector展现给码农。这样，那些排名靠前的没有被优化的函数就需要被好好修理一番了，更重要的是未被优化的原因也呈现出来，这样只要对症下药就可以了。

下载安装

安装成功后，文件会位于/usr/local/bin/node-profiler

使用示例

var http = require('http');
http.createServer(function (req, res) {
  res.writeHead(200);
  res.end('hello world!');
}).listen(1334);


$ node-profiler server.js
start agent            
webkit-devtools-agent: A proxy got connected.
webkit-devtools-agent: Waiting for commands...
webkit-devtools-agent: Websockets service started on 0.0.0.0:9999  <==启动成功


如出现如下：

Error: listen EADDRINUSE           <== 可能是由于端口被占用


成功启动后，则用chrome(推荐)手动打开url (http://alinode.aliyun.com/profiler/inspector.html?host=localhost:9999&page=0)
 出现如下界面： 

默认Collect JavaSript CPU Profile，单击Start。

可以采用压测脚本实现对服务进行压力测试，保证更多的结果：

$ wrk http://localhost:1334/ # 这里使用wrk，也可以使用其他工具，如ab


点击Stop，得到如下图的结果： 

可以看到更多关于函数在运行时的信息。

UI含义



UI 栏目
示意




Self
exclusive time


Total
inclusive time


# of Hidden Classes
隐藏类个数


Bailout
v8中提取的最后一次去优化原因


Function
函数名称 script : line




红色表示函数未被优化， 淡绿色表示函数被V8优化过。

注意事项

该工具目前只支持X64平台（Linux, Mac, Win)。切勿部署到线上，仅供自己调试使用。

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU1257最少拦截系统
题目要求：


Problem Description

某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.
怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.


 


Input

输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)


 


Output

对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.


解题思路：
        刚看到这道题目的时候，觉得特别简单，就是每次和前一个导弹的高度比较，比它大就增加1。后来仔细一想就有问题了，也许下一个导弹的高度高于当前的高度，这颗导弹无法拦截，但其仍可继续拦截后续高度小于他的导弹。
       有了这种想法之后，设置一个数组cannon[],其中cannon[i]用来存储第i个拦截系统当前能拦截的最大高度。每次读入一个导弹的高度，就在当前的拦截系统数组里找当前的拦截高度是否能拦截，如果能，那么拦截它的系统的最大高度就变为当前导弹的高度，如果不能，则需要一个新的拦截系统，最大拦截高度就是当前导弹的高度。
代码如下：
# include <iostream>
# include <algorithm>
using namespace std;

int cannon[10000];

int main()
{
	freopen("input.txt","r",stdin);
	int n;
	while(scanf("%d",&n)!=EOF && n)
	{
		memset(cannon,0,sizeof(cannon));
		int i,j,count,x;
		cannon[0]=0;
		count=0;
		for(i=0;i<n;i++)
		{
			scanf("%d",&x);
			for(j=0;j<count;j++)
			{
				if(x<=cannon[j])
				{
					cannon[j]=x;
					break;
				}
			}
			if(j==count)
			{	
				cannon[j++]=x;
				count++;
			}		
		}

		printf("%d\n",count);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Java画图
//利用awt.Graphics画图
//Graph用于显示图形
//Shape的子类定义可绘制的图形
//要改变图形，可以利用Graphics类提供的方法实现
//要在同一窗口显示更多图形，通过重载paint()实现。



import java.awt.Graphics;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class Graph extends JPanel {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private Shape shape;
	
	public Graph(Shape shp) {
		super();
		this.shape = shp;
		
	}

	@Override
	public void paint(Graphics g) {
		super.paint(g);
		shape.draw(g);

	}
	
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		JFrame frame = new JFrame();
		frame.setTitle("Shape");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Rect rect = new Rect(10,10,100,100);
		Graph grp = new Graph(rect);
		frame.add(grp);
		frame.setLocationRelativeTo(null);
		frame.setSize(600,400);
		frame.setVisible(true);
	}
}

abstract class Shape{
	public abstract void draw(Graphics g);
}

class Rect extends Shape{
	private int x,y,sizeX,sizeY;
	public Rect(int x,int y,int sizeX,int sizeY){
		this.x = x;
		this.y = y;
		this.sizeX = sizeX;
		this.sizeY = sizeY;
	}
	public void draw(Graphics g){
	g.drawRect(x,y,sizeX,sizeY);
}
}

class Line extends Shape{
		private int x,y,sizeX,sizeY;
		public Line(int x,int y,int sizeX,int sizeY){
			this.x = x;
			this.y = y;
			this.sizeX = sizeX;
			this.sizeY = sizeY;
		}
		public void draw(Graphics g){
			g.drawLine(x,y,sizeX,sizeY);
	}
	}


版权声明：本文为博主原创文章，未经博主允许不得转载。

【STL容器学习】-迭代器

STL中的容器类广泛使用迭代器，迭代器是一种对象，使用它可方便地对容器中的元素进行遍历。迭代器与内置指针很相似，都提供了一种访问和操纵容器中元素的方便途径。迭代器可以分为以下5个类型：
输入迭代器：用于从容器中读取元素，每一步只能沿向前的方向移动一个元素。
输出迭代器：用于向容器中写入元素，每一步只能沿向前的方向移动一个元素。
向前迭代器：包含输入输出迭代器的所有功能，既支持读操作又支持写操作。
双向迭代器：包含向前迭代器的所有操作，还有向后移动的能力。每一步可以自由选择向前还是向后移动。
随机访问迭代器：包含双向迭代器的所有功能，具有按任意顺序访问任意元素的能力，即能向前或向后跳过任意多个位置。
其中，vector和deque支持随机访问迭代器，list、set、multiset、map和multimap支持双向迭代器，stack、queue和priority_queue不支持迭代器。
迭代器支持的运算符有以下这些：
1）所有迭代器
++p： 迭代器先进
p++： 迭代器后进
2）输入迭代器
*p： 解引用一个迭代器，作为右值使用
p1 == p2： 若p1和p2指向同一个元素，结果为真
p1 != p2： 若p1和p2指向不同的元素，则结果为真
3）输出迭代器
*p： 解引用一个迭代器，作为左值使用
4）双向迭代器
--p： 迭代器先退
p--： 迭代器后退
5）随机访问迭代器
p+=i： 迭代器向前移动i个位置
p-=i： 迭代器向后移动i个位置
p+i： 返回p后面第i个位置的迭代器
p-i： 返回p之前第i个位置的迭代器
p1<p2： 若p1在p2之前，返回真
p1<=p2： 若p1在p2之前，或相等，返回真
p1>p2： 若p1在p2之后，返回真
p1>=p2： 若p1在p2之后，或相等，返回真
p[i]： 返回距p偏移为i的元素
以下为vector使用迭代器的一个小例子：

#include <iostream>
#include <vector>
using namespace std;

int _tmain(int argc, _TCHAR* argv[])
{
	vector<int> vec;
	vec.push_back(10);
	vec.push_back(20);
	vec.push_back(30);
	vec.push_back(40);
	vec.push_back(50);
	vec.push_back(60);
	vector<int>::iterator it;
	for(it=vec.begin();it!=vec.end();it++)
	{
		cout<<*it<<"\t";
	}
	cout<<endl<<*(--it)<<endl;
	cout<<*(it-3)<<endl;
	cout<<it[-3]<<endl;
	*it=1234;
	for(it=vec.begin();it!=vec.end();it++)
	{
		cout<<*it<<"\t";
	}
	return 0;
}执行后的结果为：
10 20 30 40 50 60
60
30
30
10 20 30 40 50 1234

下面重点介绍以下迭代器失效的问题。
1）vector迭代器失效情况：
   当插入一个元素后，end操作返回的迭代器肯定失效。
   当插入一个元素后，如果容器中元素的个数超过了vector的容量，则vector会自动重新分配原来容量的两倍内存，并把原来的元素都拷贝    到新的vector中，因此，这种情况下，所有的迭代器都会失效。
   当进行删除操作时，指向该删除点的迭代器以及删除点后面的迭代器全部都会失效。
2）deque迭代器失效情况：
   在deque容器首部或者尾部插入元素不会使得任何迭代器失效。 
   在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。 
   在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。 
3）list、set和map迭代器失效情况：
     只是在删除时，会导致删除点的迭代器失效。





版权声明：本文为博主原创文章，未经博主允许不得转载。

DFS解马走日问题
问题描述

在n*n的棋盘中，马只能走"日"字。马从位置(0,0)出发，把棋盘的每一格都走一次且只走一次。找出所有路径。 5*5的棋盘上，有304种解。


问题分析
搜索过程是从(0,0)出发，按照深度优先的原则，从8个方向中尝试一个可以走的点，直到尝试过所有的方向，走完棋盘上的所有点，得出所有的解。

马走日问题可以看成是在层数为n*n的8叉树中，找出所有的解。
#include "stdio"

int N =5;//棋盘大小为5*5
int martic[N][N];//代表棋盘的数组
int count = 0;//走的步数
int solution = 0;//方法数量
int step[8][2] = {{-1,-2},{-2,-1}, {-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2}};//要走的八个方向

int isok(int x,int y)//判断这一步是否符合规则
{
	if ((x>=0&&x<N&&y>=0&&y<N&&martic == 0))
	{
		return true;
	}
	else
	{
		return false;
	}
}

void display()//如果整个棋盘已经走满,就输出整个棋盘
{
	printf("the %d solution:\n",++solution);
	for(int i = 0;i < N;i++)
	{
		for(int j = 0;j < N;j++)
		{
			printf("%d  ",martic[i][j]);
		}
		printf("\n");
	}	
}

void DFS(int x,int y)
{
	int nextx,nexty;
	for (int i = 0; i < 8; ++i)
	{
		nextx = x + step[i][0];
		nexty = y + step[i][1];

		if (isok(nextx,nexty))//发现
		{
			
			if (count != (N*N-1))
			{
				count++;
				martic[nextx][nexty] = count;
				DFS(nextx,nexty);//递进 和 回溯
				martic[nextx][nexty] = 0;
				count--;
			}
			else
			{
				display();//满足条件,输出
			}
		}
	}}

int int main(int argc, char const *argv[])
{
	count = 1;
	martic[0][0] = 1;
	DFS(0,0);
	return 0;
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

MyEclipse快捷键大全


-------------------------------------
MyEclipse 快捷键1(CTRL)
-------------------------------------

Ctrl+1 快速修复
Ctrl+D: 删除当前行 
Ctrl+Q  定位到最后编辑的地方 
Ctrl+L  定位在某行  
Ctrl+O  快速显示 OutLine 
Ctrl+T  快速显示当前类的继承结构 
Ctrl+W  关闭当前Editer 
Ctrl+K  快速定位到下一个 
Ctrl+E 快速显示当前Editer的下拉列表
Ctrl+J  正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,)    
Ctrl+Z 返回到修改前的状态 
Ctrl+Y 与上面的操作相反
Ctrl+/  注释当前行,再按则取消注释 
Ctrl+D删除当前行。
Ctrl+Q跳到最后一次的编辑处
Ctrl+M切换窗口的大小 
Ctrl+I格式化激活的元素Format Active Elements。
Ctrl+F6切换到下一个Editor
Ctrl+F7切换到下一个Perspective
Ctrl+F8切换到下一个View
------------------------------------------
MyEclipse 快捷键2(CTRL+SHIFT)
------------------------------------------
Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) 
Ctrl+Shift+/ 自动注释代码 
Ctrl+Shift+\自动取消已经注释的代码 
Ctrl+Shift+O 自动引导类包 
Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) 
Ctrl+Shift+F4 关闭所有打开的Editer 
Ctrl+Shift+X  把当前选中的文本全部变为小写 
Ctrl+Shift+Y  把当前选中的文本全部变为小写 
Ctrl+Shift+F  格式化当前代码
Ctrl+Shift+M(先把光标放在需导入包的类名上) 作用是加Import语句 
Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) 
Ctrl+Shift+F格式化文件Format Document。
Ctrl+Shift+O作用是缺少的Import语句被加入，多余的Import语句被删除。 
Ctrl+Shift+S保存所有未保存的文件。
Ctrl+Shift+/ 在代码窗口中是这种/*~*/注释，在JSP文件窗口中是 <!--~-->。 
Shift+Ctrl+Enter 在当前行插入空行(原理同上条)
-----------------------------------------
MyEclipse 快捷键3(ALT)
-----------------------------------------
Alt+/ 代码助手完成一些代码的插入 ，自动显示提示信息
Alt+↓  当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) 
Alt+↑  当前行和上面一行交互位置(同上) 
Alt+←  前一个编辑的页面 
Alt+→  下一个编辑的页面(当然是针对上面那条来说了) 
Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性

MyEclipse 快捷键4(ALT+CTRL)

Alt+CTRL+↓ 复制当前行到下一行(复制增加) 
Alt+CTRL+↑ 复制当前行到上一行(复制增加)
-------------------------------------------
MyEclipse 快捷键5(ALT+SHIFT)
-------------------------------------------
Alt+Shift+R 重命名 
Alt+Shift+M 抽取方法
Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) 
Alt+Shift+L 抽取本地变量
Alt+Shift+F 把Class中的local变量变为field变量
Alt+Shift+I 合并变量
Alt+Shift+V 移动函数和变量
Alt+Shift+Z 重构的后悔药(Undo) Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后) 
Alt+Shift+O(或点击工具栏中的Toggle Mark Occurrences按钮) 当点击某个标记时可使本页面中其他地方的此标记黄色凸显，并且窗口的右边框会出现白色的方块，点击此方块会跳到此标记处。 
下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开头的了)

--------------------------------------------
MyEclipse 快捷键(6) 
--------------------------------------------
F2当鼠标放在一个标记处出现Tooltip时候按F2则把鼠标移开时Tooltip还会显示即Show Tooltip Description。 
F3跳到声明或定义的地方。 
F5单步调试进入函数内部。 
F6单步调试不进入函数内部，如果装了金山词霸2006则要把“取词开关”的快捷键改成其他的。 
F7由函数内部返回到调用处。 
F8一直执行到下一个断点。

版权声明：本文为博主原创文章，未经博主允许不得转载。

跟我一起写Makefile:概述


什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的集成开发环境(integrateddevelopment
 environment,IDE)都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。


因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计其数，并且按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。


makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，VisualC++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。


现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同厂商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHatLinux
 8.0，make的版本是3.80。畢竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE1003.2-1992标准的（POSIX.2）。


在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。


关于程序的编译和链接
在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是.obj文件，UNIX下是.o文件，即ObjectFile，这个动作叫做编译（compile）。然后再把大量的ObjectFile合成执行文件，这个动作叫作链接（link）。


编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。


链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（ObjectFile），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（LibraryFile)，也就是.lib文件，在UNIX下，是ArchiveFile，也就是.a文件。


总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成ObjectFile。而在链接程序时，链接器会在所有的ObjectFile中找寻函数的实现，如果找不到，那到就会报链接错误码（LinkerError），在VC下，这种错误一般是：Link2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.


好，言归正传，gnu的make有许多的内容，闲言少叙。


from Ubuntu wiki


版权声明：本文为博主原创文章，未经博主允许不得转载。

OJ刷题---立方和等式
 题目要求：




输入代码：
#include<iostream>
#include<cmath>
using namespace std;
typedef struct node
{
    int data[4];
    struct node *next;
} node,*nodep;
int arr[30];
void Power()
{
    arr[0]=0;
    for(int i=0; i<30; i++)
    {
        arr[i]=i*i*i;
    }
}
void sort(int arr[],int n)//冒泡法将数组array中的元素按从小到大的顺序排序
{
    int i,j,temp;
    for(j=0; j<n-1; j++)
        for(i=0; i<n-1-j; i++)
            if(arr[i]>arr[i+1])
            {
                temp=arr[i];
                arr[i]=arr[i+1];
                arr[i+1]=temp;
            }
}
int main()
{
    Power();
    nodep head,p,q;
    head=new(node);//用于存放数据的链表头结点
    head->next=NULL;
    q=head;
    int i,j,k,t;
    for(i=1; i<=29; i++)
    {
        for(j=1; j<=29; j++)
        {
            if(i==j)
            {
                continue ;
            }
            for(k=1; k<=29; k++)
            {
                if(i == k || j == k)
                    continue;
                for(t=1; t<=29; t++)
                {
                    if(i == t || j == t || k == t)//避免出现重复数据
                        continue;
                    if((arr[i] + arr[j]) == (arr[k] +arr[t]))
                    {
                        int flag=0;
                        p=new(node);
                        p->data[0]=i;
                        p->data[1]=j;
                        p->data[2]=k;
                        p->data[3]=t;
                        sort(p->data,4);//排序方根数
                        nodep px=head;
                        while(px)
                        {
                            int m;
                            for(m=0; m<4; m++)
                            {
                                if(px->data[m]!=p->data[m])//判断新结点中的数据是否与已存在的数据重复
                                    break;
                            }
                            if(m==4)//当新结点中的数据与已存在的数据重复时将结束标志置为1，并结束while循环
                            {
                                flag=1;
                                break;
                            }
                            else
                                px=px->next;//否则指针后移
                        }
                        if(flag)//结束标志为1时，即新结点中的数据与已存在的数据重复时，释放新结点，并结束本次循环
                        {
                            delete(p);
                            continue;
                        }
                        //将新结点连接到链表中
                        p->next=NULL;
                        q->next=p;
                        q=p;
                        //输出找到的组合
                        for(int a=0; a<3; a++)
                        {
                            cout<<p->data[a]<<",";
                        }
                        cout<<p->data[3]<<endl;
                    }

                }
            }
        }
    }
    return 0;
}




运行结果：




总结：一开始打算只用穷举法，看能否列出所有情况，但后来发现那根本解决不了问题。因为不仅需要立方相等，还需要从小到大列出方根的情况，而且不能重复，于是思考了半天，还是解决不了，最终选择了参考别人的解答，用到了链表，这个自己最薄弱的知识点。用链表读取数据，而后指向数组的地址排序方根，果然方便多了，而且没有重复，自己在用穷举出现的列举重复问题，链表得以解决了。虽然解不出，但收获还是蛮大的。。。

版权声明：本文为博主原创文章，未经博主允许不得转载。

《Java实战开发经典》第五章5.3
package five; 
//第五章练习3，统计字符串”want you know one thing”中字母n和o出现的次数 
public class Three { 
public static void main(String[] args) { 
    int n1=0,n2=0; 
    String str=”want you to know one thing”; 
    char c[]=str.toCharArray(); 
    for(int i=0;i

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【SCOI2003】【BZOJ1089】严格n元树
Description
如果一棵树的所有非叶节点都恰好有n个儿子，那么我们称它为严格n元树。如果该树中最底层的节点深度为d（根的深度为0），那么我们称它为一棵深度为d的严格n元树。例如，深度为２的严格２元树有三个，如下图：

给出n, d，编程数出深度为d的n元树数目。
Input
仅包含两个整数n, d( 0   <   n   <   =   32,   0  < =   d  < = 16)
Output
仅包含一个数，即深度为d的n元树的数目。
Sample Input
【样例输入1】
2 2
【样例输入2】
2 3
【样例输入3】
3 5 
Sample Output
【样例输出1】
3
【样例输出2】
21
【样例输出2】
58871587162270592645034001 
HINT
Source
用排列组合推一推发现递推式
f[i]=f[i-1]^n+1 
ans=f[d]-f[d-1]
高精度所以Python大法 
答案太长了光输出就T了 
然而数据傻逼
#本来应该A的Python3代码...但是BZOJ上WA了
n,d=map(int, input().split(' '))
if d==0:
        print(1)
else:
        f=[1]
        for i in range(0,d+1):
                f.append(f[i]**n+1)
        print(f[d]-f[d-1])


但是换成Python2.7写法就A了
n,d=map(int, raw_input().split())
if d==0:
    print 1
else:
    f=[1]
    for i in range(0, d+1):
        f.append(f[i]**n+1)
    print f[d]-f[d-1]

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

强连通分量+poj2186
强连通分量：两个点可以互相连通。
算法分解：第一步，正向dfs所有顶点，并后序遍历
第二步，将边反向，从最大边dfs，构成强连通分量
标号最大的节点属于DAG头部，cmp存一个强连通分量的拓扑序。
poj2186
解就是拓扑后的最后一个强连通分量
#include<cstdio>
#include<algorithm>
#include<vector>
#include<iostream>
#include<cstring>
#include<string.h>
using namespace std;
#define MAX_V 10000
#define MAX_M 50000

int V,N,M;
int A[MAX_M],B[MAX_M];
vector<int> G[MAX_V];
vector<int> rG[MAX_V];
vector<int> vs;
bool used[MAX_V];
int cmp[MAX_V];
void add_edge(int from,int to){
    G[from].push_back(to);
    rG[to].push_back(from);
}
void dfs(int v){
    used[v]=true;
    for(int i=0;i<G[v].size();i++){
        if(!used[G[v][i]]) dfs(G[v][i]);
    }
    vs.push_back(v);
}
void rdfs(int v,int k){
    used[v]=true;
    cmp[v]=k;
    for(int i=0;i<rG[v].size();i++)
        if(!used[rG[v][i]]) rdfs(rG[v][i],k);
}
int scc(){
    memset(used,0,sizeof(used));
    vs.clear();
    for(int v = 0;v<V;v++){
        if(!used[v]) dfs(v);
    }
    memset(used,0,sizeof(used));
    int k=0;
    for(int i=vs.size()-1;i>=0;i--)
        if(!used[vs[i]]) rdfs(vs[i],k++);
    return k;
}
void solve(){
    V = N;
    for(int i=0;i<M;i++)
        add_edge(A[i]-1,B[i]-1);
    int n=scc();
    int u=0,num=0;
    for(int v=0;v<V;v++)
    if(cmp[v]==n-1){
        u=v;
        num++;
    }
    memset(used,0,sizeof(used));
    rdfs(u,0);
    for(int v=0;v<V;v++)
    if(!used[v]){
        num=0;
        break;
    }
    printf("%d\n",num);
}
int main()
{
    while(~scanf("%d%d",&N,&M)){
        for(int i=0;i<M;i++) scanf("%d%d",&A[i],&B[i]);
        solve();
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

java测试类调用LDAP服务器客户端信息实行增删改查
如下是我自写的java测试类调用客户端配置好的用户信息:
package com;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.Hashtable;

import javax.naming.Context;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.BasicAttribute;
import javax.naming.directory.BasicAttributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;
import javax.naming.ldap.Control;
import javax.naming.ldap.InitialLdapContext;
import javax.naming.ldap.LdapContext;

public class UserAuthenticate {
    private String URL = "ldap://localhost:10389";
    private String BASEDN = "cn=zhangsan,ou=users,ou=system";
    private String FACTORY = "com.sun.jndi.ldap.LdapCtxFactory";
    private LdapContext ctx = null;
    private Hashtable env = null;
    private Control[] connCtls = null;

    @SuppressWarnings({ "unchecked", "rawtypes", "unused" })
    public void LDAP_connect() {
        env = new Hashtable();
        env.put(Context.INITIAL_CONTEXT_FACTORY, FACTORY);
        env.put(Context.PROVIDER_URL, URL);
        env.put(Context.SECURITY_AUTHENTICATION, "simple");
        env.put(Context.SECURITY_PRINCIPAL, "cn=lisi;ou=users;ou=system");
        env.put(Context.SECURITY_CREDENTIALS, "123456");
        // env.put("", "secret");
        try {
            ctx = new InitialLdapContext(env, connCtls);
        } catch (NamingException e) {
            e.printStackTrace();
        }
    }

    public void getUserDN() {
        String dn = "zhangsan";
        SearchControls controls = new SearchControls();
        //限制要查询的字段内容
        controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
        //设置过滤条件
        String filter = "(&(objectClass=top)(objectClass=person)(cn=" + dn
                + "))";
        //设置被返回的attribute
        controls.setReturningAttributes(new String[] { "uid", "userPassword",
                "displayName", "cn", "sn", "mail", "description" });
        try {
            //控制搜索的搜索条件，如果为null则使用默认的搜索控件，要搜索的属性如果为null则返回目标上下文中的所有对象
            NamingEnumeration answer = ctx
                    .search("ou=system", filter, controls);
            while (answer.hasMore()) {
                SearchResult result = (SearchResult) answer.next();
                NamingEnumeration en = result.getAttributes().getAll();
                if (en == null) {
                    System.out.println("Have no NamingEnumeration");
                }
                if (!en.hasMoreElements()) {
                    System.out.println("Have no element");
                }
                //输出查询到的结果
                while (en.hasMore()) {
                    Attribute attr = (Attribute) en.next();
                    System.out.println(attr.getID() + "=" + attr.get());
                }
            }

        } catch (NamingException e) {
            e.printStackTrace();
        }

    }

    public void testAdd() throws Exception {
        Attributes attrs = new BasicAttributes(true);
        Attribute objclass = new BasicAttribute("objectclass");
        String[] attrObjectClassPerson = { "inetOrgPerson",
                "organizationalPerson", "person", "top" };

        Arrays.sort(attrObjectClassPerson);
        for (String ocp : attrObjectClassPerson) {
            objclass.add(ocp);
        }
        attrs.put(objclass);
        String uid = "zhangsan";
        String userDN = "uid=" + uid + "," + "ou=system";
        attrs.put("cn", uid);
        attrs.put("sn", uid);
        attrs.put("displayName", "张三");
        attrs.put("description", "not null");
        attrs.put("mail", "abc@126.com");
        attrs.put("userPassword", "11111".getBytes("UTF-8"));
        ctx.createSubcontext(userDN, attrs);
    }
    public void testDelete(){
        String uid = "zhangsan";
        String userDN = "uid="+ uid +","+"ou=system";
        try {
            ctx.destroySubcontext(userDN);
        } catch (NamingException e) {
            e.printStackTrace();
        }
    }
    public boolean testEdit(){
        boolean result = true;
        String uid = "zhangsan";
        String userDN = "uid="+ uid +","+"ou=system";
        Attributes attr = new BasicAttributes(true);
        attr.put("mail","zhangsan@163.com");
        try {
            ctx.modifyAttributes(userDN, DirContext.REPLACE_ATTRIBUTE, attr);
        } catch (NamingException e) {
            e.printStackTrace();
        }
        return result;
    }
    public static void main(String[] args) {
        UserAuthenticate test = new UserAuthenticate();
        // test.getUserDN("zhangsan;ou=users;ou=system");
        try {
            test.LDAP_connect();
             //test.testAdd();
            test.getUserDN();
            //test.testEdit();
            //test.testDelete();
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Mac 安装Django

这是DJango学习系列的第一篇：主要介绍在Mac环境下如何安装DJango，以及创建新工程，通过LocalHost的测试。

一：写在前面
DJango系列学习笔记主要以学习为主，并没有抱着写成一个产品做市场的心态。所以很多框架配置博主都是本着简单至上的原则，大家如果想在这里找到追求稳定、高性能的DJango相关内容，恐怕得失望了。但是我认为如果你是个和我一样的新手，不妨我们一起学习，一起进步。

二：关于Python
既然是Python的Web Framework,那当然得安装Python啦。不过Mac下默认安装了最稳定的Python，所以我们不用担心。如果你是Win下的同学，可以参考《安装Python》。有了最基础的环境，我们便开始下一步。

三：下载Django
从这里下载最新的稳定版本：DJango-1.x.y.tar.gz,记住是最新的官方版本哦.其中x.y是版本号。~接下来进入你下载该文件的文件夹目录，执行如下命令:（Mac下默认是/Users/xxx/Downloads，xxx是你的用户名）








tar
 xzvf Django-1.x.y.tar.gz








四：安装Django
博主在安装Django前一直很纠结的事情是：把Django安装到哪呢？我想这是深受window下安装程序过程的影响，其实在Mac下完全不必关心这个问题。比如说你的Python默认在/Library/Python/2.7中，那么无论如何你在哪里安装完DJango，都会在/Library/Python/2.7/site-packages中生成一个django的文件夹，这样你以后所有的django的api都无需你的关心它的位置问题。说了这么多，其实想说安装很简单：








/*第三步中解压出来的文件夹*/

cd

Django-1.x.y

sudo
 python setup.py install








五：测试LocalHost是否成功
一般而言，在本地搭建任何网站框架第一步都是测试localhost是否能成功访问。下面我们就以此作为本篇的结束:








/*创建一个Django目录，以后我们所有的测试样例都将储存在这里*/

sudo
 mkdir ~/Document/DJango

cd

~/Document/DJango

 

/*创建一个用于测试Localhost的网站样例*/

django-admin.py
 startproject testLocalHost

 

/*启动网站服务*/

cd

testLoacalHost

python
 manage.py runserver








此时会得到一些服务启动的信息，在你的浏览器输入:http://localhost:8000测试一下是否成功了呢？有It works即可

六：下一步
到现在为止，我们已经搭建了DJango的基本框架。我决定在下一篇建立简单的HelloWorld，并解释各个文件的用途。

版权声明：本文为博主原创文章，未经博主允许不得转载。

spring mvc第一个helloword
web.xml配置文件
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

<!-- 配置 DispatcherServlet -->
    <servlet>
        <servlet-name>dispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- 配置 DispatcherServlet 的一个初始化参数: 配置 SpringMVC 配置文件的位置和名称 -->
        <!-- 
            实际上也可以不通过 contextConfigLocation 来配置 SpringMVC 的配置文件, 而使用默认的.
            默认的配置文件为: /WEB-INF/<servlet-name>-servlet.xml
        -->
        
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>
        
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>dispatcherServlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    
</web-app>

springmvc.xml配置文件：
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:mvc="http://www.springframework.org/schema/mvc"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd">


<context:component-scan base-package="com.feiniu.test"></context:component-scan>

    
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/views/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>
</beans>



hello.java
package com.feiniu.test;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;


@Controller
public class HelloWord {
    @RequestMapping("/helloword")
 public String hello(){
        /**
         * /WEB-INF/views+"success" +".jsp" =WEB-INF/views/success.jsp
         */
     System.out.println("hellword");
     return "success";
 }
}

在/WEB-INF下面创建views文件夹 并创建success.jsp
body内容为:
 <body>
    This is my JSP page. <br>
  </body>
执行结果为：http://localhost:8080/springmvc/helloword
This is my JSP page.




版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 1719 Friend
Friend
Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2234    Accepted Submission(s): 1121


Problem Description
Friend number are defined recursively as follows.
(1) numbers 1 and 2 are friend number;
(2) if a and b are friend numbers, so is ab+a+b;
(3) only the numbers defined in (1) and (2) are friend number.
Now your task is to judge whether an integer is a friend number.

 

Input
There are several lines in input, each line has a nunnegative integer a, 0<=a<=2^30.

 

Output
For the number a on each line of the input, if a is a friend number, output “YES!”, otherwise output “NO!”.

 

Sample Input

3
13121
12131

 

Sample Output

YES!
YES!
NO! 思路： 设c是Friend数，题中给出公式ab+a+b，则c=ab+a+b。c+1=ab+a+b+1=(a+1)*(b+1),所以判断n+1是否满足这个公式即可，又因为1,2是最小的Friend数。所以判断n+1=(a+1)^x*(b+1)^y即n+1=2^x*3^y是否成立。  代码： #include<stdio.h>
int main()
{
	int n,x,y;
	while(scanf("%d",&n)!=EOF)
	{
		n+=1;//n先加1； 
		x=0;y=0;
		while(n%2==0)
		{
			n=n/2;
			x++;
		}
		while(n%3==0)
		{
			n=n/3;
			y++;
		}
		if(n==1&&(x>0||y>0))//n=0时不是Friend数； 
		printf("YES!\n");
		else
		printf("NO!\n");
	}
	return 0;
} 


版权声明：本文为博主原创文章，未经博主允许不得转载。

序列化类型 System.Data.Entity.DynamicProxies 的对象时检测到循环引用
    根据我们不同的需要，我们会在不同的时候选择序列化和反序列化，从而得到我们想要的对象或者字符串。

    今天在用MVC+EF做一个简单查询的时候，当返回json格式的数据时出现问题了。
<span style="font-family:KaiTi_GB2312;font-size:18px;">    public ActionResult QueryBasicInfo()
        {
            //获得B层
            IBasicInfoBll test = SpringHelper.GetObject<IBasicInfoBll>("BasicInfoBll");

            //获得页码索引值
            int pageIndex = Request["page"] == null ? 1 : int.Parse(Request["page"]);
            //获得页容量
            int pageSize = Request["rows"] == null ? 10 : int.Parse(Request["rows"]);
            int total = 0;

            //调用B层的方法，进行分页查询
            List<T_BasicInformation> BasicRes = test.QueryBasicInfo(pageSize, pageIndex, out total);

            var data = BasicRes.Select(
                p=>new
            {
                total,
                Rows=BasicRes
            });
            return Json(data, JsonRequestBehavior.AllowGet);

        }</span>    很简单的一个查询，能返回数据，但是就在最后一句序列化报错：

    于是上网搜索解决办法，网上提供了很多办法，主要有以下几种：

    1.最简单的方式就是从Entity Framework着手,停用LazyLoading与ProxyCreation.因为LazyLoading停用后，那么当JSON.Net解析Order对象时其属性Order_Details会返回null(不会自动加载).所以也就避免了此问题。
    当然此方式的缺点会导致后续程序存取Entity Object时牺牲了LazyLoading的方便性,需要手动处理此问题.
<span style="font-family:KaiTi_GB2312;font-size:18px;">  db.Configuration.LazyLoadingEnabled = false;
  db.Configuration.ProxyCreationEnabled = false;
  return db.Orders.AsEnumerable();</span>    2.设定JSON.Net忽略循环参考，透过APP_Start的WebApiConfig.cs设定  
  config.Formatters.JsonFormatter.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore;   使用这个方式时要注意,它只是忽略循环参考的错误,但实际上还是会自动一层层解析要输出的对象之属性,所以若数据会相依有可能会产生无穷循环.
    3.设定JSON.Net避免循环参考，透过APP_Start的WebApiConfig.cs,设定
<span style="font-size:18px;">config.Formatters.JsonFormatter.SerializerSettings.ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Serialize;
config.Formatters.JsonFormatter.SerializerSettings.PreserveReferencesHandling = Newtonsoft.Json.PreserveReferencesHandling.Objects;</span>    这种做法与2的差异在于它会将重复过的对象用一个代表取代,譬如底下JSON格式：
    [{"$id":"1","Category":{"$id":"2","Products":[{"$id":"3","Category":{"$ref":"2"},"Id":2,"Name":"Yogurt"},{"$ref":"1"}],"Id":1,"Name":"Diary"},"Id":1,"Name":"Whole
 Milk"},{"$ref":"3"}]
    所以对于数据而言这种作法还是会自动一层层解析要输出的对象之属性,只是避免输出太大量数据.
    4.手动设定避免循环参考
    如同3的模式,透过[JsonIgnore] 与[JsonObject(IsReference = true)] 细部设定,可以更精确的设定每个要输出的属性.
    缺点是1.设定繁杂. 2.只能通用设定无法例外. 3.因为必须直接或透过 partial class方式设定,故无法将设定与Entity Object class做分离。
    查了很多资料之后，自己好像懂了，原因就是，因为这个表和另一个表是有一对多关系的,当序列化表1的时候,会找到和另一个表2关联的字段,就会到另一个表2中序列化,然后另一个表2中也有一个字段和表1相关联.这样.序列化就会发生这种错误!
    最后将上面的LINQ语句改成了下面语句：

<span style="font-family:KaiTi_GB2312;font-size:18px;">   var data = BasicRes.Select(
                p=>new
            {
                p.name,
                p.sex,
                p.idNumber,
                p.receivemode,
                p.myidentity,
                p.position,
                p.oldworkplace,
                p.nowworkplace,
                p.isrecord,
                total,
                Rows=BasicRes.Count
            });</span>    为什么能够解决呢，我想是因为这样做，我就只拿我需要的字段，不需要的字段，我就不拿。网上的解决办法不一定适用我们的问题，但是可以帮我们打开一些思路，所以我们要更加积极地区思考问题。


版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题15——链表中倒数第K个节点
题目：
          输入一个链表，输出该链表中倒数第K个结点，为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点的值为4的节点。
链表结点的定义如下：

public class ListNode
{
	int val;
	ListNode next;
	ListNode(int x)
	{
		val=x;
	}
}


示意图：





分析：

          为了得到倒数第K个结点，很自然的想法是先走到链表的尾端，再从尾端回溯K步。可是我们从链表结点的定义可以看出本题中的链表是单向链表，单向链表的节点只有从前往后的指针而没有从后往前的指针，因此这个思路不通
          既然不能从尾结点开始遍历这个链表，我们还是把思路回到从头结点上来。假设整个链表有n个结点，那么倒数第K个结点就是从头结点开始的第n-k+1个结点。如果我们能够得到链表中节点的个数n，那我们只要从头结点开始往后走n-k+1步就可以了，如何得到节点数n？这个不难，只需要从头开始遍历链表，每经过一个结点，计数器加1就行了。也就是说我们需要遍历链表两次，第一次统计出链表中结点的个数，第二次就能找到倒数第K个结点。
         但是以上思路需要遍历两次链表，有没有只需要遍历一次链表的算法呢？为了实现只遍历一次链表就能找到倒数第K个结点，我们可以定义两个指针，如上面示意图所示。第一个指针从链表的头指针开始遍历向前走K-1步，第二个指针保持不动；从第K步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在K-1，当第一个指针到达链表的尾节点时，第二个指针正好是倒数第K个结点。




注意：
           （1）输入的头结点head为空时
           （2）输入的以head为头结点的链表的结点总数少于K
           （3）输入的参数K为0时


代码：

package offer;

public class find_NthToTail
{
	public ListNode find(ListNode head,int k)
	{
		if (head==null||k==0)
		{
			return null;
		}
		ListNode pAhead=head;
		ListNode pBehind=null;
		for (int i = 0; i < k-1; i++)
		{
			if (pAhead.next!=null)
			{
				pAhead=pAhead.next;
			}
			else
			{
				return null;
			}
		}
		pBehind=head;
		while (pAhead.next!=null)
		{
			pAhead=pAhead.next;
			pBehind=pBehind.next;
		}
		return pBehind;
	}
}
相关题目：






版权声明：本文为博主原创文章，未经博主允许不得转载。

Mybatis执行Update返回行数为负数
获取mybatis的update行数，总是返回负数。后来在官网上找到原因，是由于defaultExecutorType的引起的，defaultExecutorType有三个执行器SIMPLE、REUSE和BATCH。其中BATCH可以批量更新操作缓存SQL以提高性能，但是有个缺陷就是无法获取update、delete返回的行数。defaultExecutorType的默认执行器是SIMPLE。



名称
描述



SIMPLE
执行器执行其它语句


REUSE
可能重复使用prepared statements 语句


BATCH
可以重复执行语句和批量更新


 
由于项目配置中启用了BATCH执行器，UPDATE和DELETE返回的行数就丢失了，把执行器改为SIMPLE即可。
<?xml version="1.0" encoding="UTF-8" ?> 
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <settings>
        <!-- 全局映射器启用缓存 -->
        <setting name="cacheEnabled" value="true" />
        <!-- 查询时，关闭关联对象即时加载以提高性能 -->
        <setting name="lazyLoadingEnabled" value="true" />
        <!-- 设置关联对象加载的形态，此处为按需加载字段(加载字段由SQL指 定)，不会加载关联表的所有字段，以提高性能 -->
        <setting name="aggressiveLazyLoading" value="false" />
        <!-- 对于未知的SQL查询，允许返回不同的结果集以达到通用的效果 -->
        <setting name="multipleResultSetsEnabled" value="true" />
        <!-- 允许使用列标签代替列名 -->
        <setting name="useColumnLabel" value="true" />
        <!-- 允许使用自定义的主键值(比如由程序生成的UUID 32位编码作为键值)，数据表的PK生成策略将被覆盖 -->
        <setting name="useGeneratedKeys" value="true" />
        <!-- 给予被嵌套的resultMap以字段-属性的映射支持 -->
        <setting name="autoMappingBehavior" value="FULL" />
        <!-- 对于批量更新操作缓存SQL以提高性能 -->
        <!-- defaultExecutorType设置为BATCH有个缺陷就是无法获取update、delete返回的行数 -->
        <!-- <setting name="defaultExecutorType" value="BATCH" />-->
        <!-- 数据库超过25000秒仍未响应则超时 -->
        <setting name="defaultStatementTimeout" value="25000" />
        <!-- 日志 -->
        <!-- <setting name="logImpl" value="SLF4J"/> -->
    </settings>

    <!-- 注册mybatis插件 -->
    <plugins>
        <!-- mysql分页插件 -->
        <plugin interceptor="com.rvho.mybatis.interceptor.MybatisPageInterceptor">
            <property name="databaseType" value="mysql"/>
        </plugin>
    </plugins>
</configuration>

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

如何禁止某些代码调用 System.exit()
如何禁止调用 System.exit()
说明
System.exit() 的本质是通知 JVM 关闭。
一般来说，有两种禁用 System.exit() 的办法：

安全管理器
安全策略

本质都是JRE 提供的本地实现，在执行之前进行权限判断。
因为System.exit() 是一种很暴力的手段，如果在 Client 模式下自己写个小程序无所谓,但是在 Server 上多个程序、或者多线程时就会有很大的麻烦。
底层源码
1.先来看看静态方法 System.exit() 的源码:
// System.exit()
public static void exit(int status) {
    Runtime.getRuntime().exit(status);
}

应该说很简单, 只是简单地调用运行时的 exit 方法.
2.然后我们看运行时的实例方法 exit:
// Runtime.exit()
public void exit(int status) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkExit(status);
    }
    Shutdown.exit(status);
}

如果有安全管理器，那么就让安全管理器执行 checkExit退出权限检查。
如果检查不通过，安全管理器就会抛出异常(这就是约定！)。 
然后当前线程就会往外一路抛异常，如果不捕获，那么该线程就会退出。
此时如果没有其他的前台线程正在运行，那么JVM也会跟着退出。
3.Shutdown 是 java.lang 包下面的一个类。
访问权限是 default, 所以我们在API中是不能调用的。
// Shutdown.exit()
static void exit(int status) {
    boolean runMoreFinalizers = false;
    synchronized (lock) {
        if (status != 0) runFinalizersOnExit = false;
        switch (state) {
        case RUNNING:       /* Initiate shutdown */
            state = HOOKS;
            break;
        case HOOKS:         /* Stall and halt */
            break;
        case FINALIZERS:
            if (status != 0) {
                /* Halt immediately on nonzero status */
                halt(status);
            } else {
                /* Compatibility with old behavior:
                 * Run more finalizers and then halt
                 */
                runMoreFinalizers = runFinalizersOnExit;
            }
            break;
        }
    }
    if (runMoreFinalizers) {
        runAllFinalizers();
        halt(status);
    }
    synchronized (Shutdown.class) {
        /* Synchronize on the class object, causing any other thread
         * that attempts to initiate shutdown to stall indefinitely
         */
        sequence();
        halt(status);
    }
}

其中有一些同步方法进行锁定。 退出逻辑是调用了 halt 方法。
// Shutdown.halt()
static void halt(int status) {
    synchronized (haltLock) {
        halt0(status);
    }
}

static native void halt0(int status);

然后就是调用 native 的 halt0() 方法让 JVM “自杀“了。
示例
使用安全管理器的实现代码如下所示:
1.定义异常类, 继承自 SecurityException

ExitException.java

package com.cncounter.security;

public class ExitException extends SecurityException {
    private static final long serialVersionUID = 1L;
    public final int status;

    public ExitException(int status) {
        super("忽略 Exit方法调用!");
        this.status = status;
    }
}

2.定义安全管理器类, 继承自 SecurityManager

NoExitSecurityManager.java

package com.cncounter.security;

import java.security.Permission;

public class NoExitSecurityManager extends SecurityManager {
    @Override
    public void checkPermission(Permission perm) {
        // allow anything.
    }

    @Override
    public void checkPermission(Permission perm, Object context) {
        // allow anything.
    }

    @Override
    public void checkExit(int status) {
        super.checkExit(status);
        throw new ExitException(status);
    }
}

其中直接拒绝系统退出。
3.增加一个辅助和测试类，实际使用时你也可以自己进行控制。

NoExitHelper.java

package com.cncounter.security;

public class NoExitHelper {

    /**
     * 设置不允许调用 System.exit(status)
     * 
     * @throws Exception
     */
    public static void setNoExit() throws Exception {
        System.setSecurityManager(new NoExitSecurityManager());
    }

    public static void main(String[] args) throws Exception {
        setNoExit();
        testNoExit();
        testExit();
        testNoExit();
    }

    public static void testNoExit() throws Exception {
        System.out.println("Printing works");
    }

    public static void testExit() throws Exception {
        try {
            System.exit(42);
        } catch (ExitException e) {
            //
            System.out.println("退出的状态码为: " + e.status);
        }
    }
}

在其中，使用了一个 main 方法来做简单的测试。 控制台输出结果如下:
Printing works
退出的状态码为: 42
Printing works

原问题
原来的问题如下:

I’ve got a few methods that should call System.exit() on certain inputs. Unfortunately, testing these cases causes JUnit to terminate! Putting the method calls in a new Thread doesn’t seem to help, since System.exit() terminates the JVM, not just the current thread. Are there any common patterns for dealing with this? For example, can I subsitute a stub for System.exit()?

大意是:

有一些方法需要测试, 但是在某些特定的输入时就会调用 System.exit()。这就杯具了,这时候 JUnit 测试也跟着退出了! 用一个新线程来调用这种方法也没什么用, 因为 System.exit() 会停止JVM , 而不是退出当前线程。有什么通用的模式来处理这种情况吗? 例如,我能替换掉 System.exit() 方法吗?

建议如下:

Instead of terminating with System.exit(whateverValue), why not throw an unchecked exception? In normal use it will drift all the way out to the JVM’s last-ditch catcher and shut your script down (unless you decide to catch it somewhere along the way, which might be useful someday).
In the JUnit scenario it will be caught by the JUnit framework, which will report that such-and-such test failed and move smoothly along to the next.

翻译如下:

在程序中调用 System.exit(whateverValue) 是一种很不好的编程习惯, 这种情况为什么不抛出一个未检测的异常(unchecked exception)呢? 如果程序中不进行捕获(catch), 抛出的异常会一路漂移到 JVM , 然后就会退出程序(只有主线程的话)。
在 JUnit 的测试场景中异常会被 JUnit 框架捕获, 然后就会报告说某某某测试执行失败,然后就继续下一个单元测试了。

当然,给出的解决方案就是前面的那段代码. 你还可以阅读下面的参考文章，查找其他的解决方案。
参考文章:

Java: 如何单元测试那种会调用 System.exit() 的方法?
Java中如何禁止 API 调用  System.exit() 
如何配置 Tomcat 的安全管理器

日期: 2015年08月25日
人员: 铁锚 http://blog.csdn.net/renfufei

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

STL源码剖析——deque的实现原理和使用方法详解
Deque 简介
    deque是“double—ended queue”的缩写，和vector一样都是STL的容器，deque 是双端数组，而 vector 是单端的。
    deque 在接口上和 vector 非常相似，在许多操作的地方可以直接替换。
    deque 可以随机存取元素（支持索引值直接存取，用[]操作符或at()方法，这个等下会详讲）。
    deque 头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。
    使用时需要包含头文件 
#include<deque> 。
Deque 实现原理
  
deque 的中控器
    deque是连续空间（至少逻辑上看来如此），连续线性空间总令我们联想到array或vector。array无法成长，vector虽可成长，却只能向尾端成长，而且其所谓的成长原是个假象，事实上是（1）另觅更大空间；（2）将原数据复制过去；（3）释放原空间三部曲。如果不是vector每次配置新空间时都有留下一些余裕，其成长假象所带来的代价将是相当高昂。
    deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。
 
   受到分段连续线性空间的字面影响，我们可能以为deque的实现复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既是分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。
 
   deque采用一块所谓的map（注意，不是STL的map容器）作为主控。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。SGI
 STL 允许我们指定缓冲区大小，默认值0表示将使用512 bytes 缓冲区。
 
   deque的整体架构如下图所示：
 
   
 
 deque 的迭代器
 
   让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针，分别为cur,
 first, last, node。
 
   指针结构如下图所示：
 
   
 
   在上面介绍中我们大致了解了deque 的基本概念和实现原理，现在我就开始介绍如何使用 deque。
deque
 对象的默认构造
 
   deque 采用模板类实现，deque 对象的默认构造形式：deque<T> dequeT； 
  

deque<int> deqInt;            //一个存放int的deque容器。
deque<float> deqFloat;       //一个存放float的deque容器。
deque<string> deqString;     //一个存放string的deque容器。
...				        尖括号内还可以设置指针类型或自定义类型。

deque
 元素添加移除操作

deque.push_back(elem);	     //在容器尾部添加一个数据
deque.push_front(elem);	    //在容器头部插入一个数据
deque.pop_back();    		//删除容器最后一个数据
deque.pop_front();	     	//删除容器第一个数据    示例代码： 


	deque<int> deqInt;
	deqInt.push_back(1);
	deqInt.push_back(3);
	deqInt.push_back(5);
	deqInt.push_back(7);
	deqInt.push_back(9);
	deqInt.pop_front();
	deqInt.pop_front();
	deqInt.push_front(11);
	deqInt.push_front(13);
	deqInt.pop_back();
	deqInt.pop_back();
	
       //deqInt  { 13,11,5}deque 的数据存取   


deque.at(idx);    //返回索引idx所指的数据，如果idx越界，抛出out_of_range。
deque[idx];      //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。
deque.front();   //返回第一个数据。
deque.back();    //返回最后一个数据    示例代码： 


	deque<int> deqInt;
	deqInt.push_back(1);
	deqInt.push_back(3);
	deqInt.push_back(5);
	deqInt.push_back(7);
	deqInt.push_back(9);

	int iA = deqInt.at(0);		//1
	int iB = deqInt[1];		//3
	deqInt.at(0) = 99;		//99
	deqInt[1] = 88;			//88

	int iFront = deqInt.front();	//99
	int iBack = deqInt.back();		//9
	deqInt.front() = 77;			//77
	deqInt.back() = 66;			//66deque 与迭代器   


deque.begin();  //返回容器中第一个元素的迭代器。
deque.end();  //返回容器中最后一个元素之后的迭代器。
deque.rbegin();  //返回容器中倒数第一个元素的迭代器。
deque.rend();   //返回容器中倒数最后一个元素之后的迭代器。    示例代码：  


	deque<int> deqInt;
	deqInt.push_back(1);
	deqInt.push_back(3);
	deqInt.push_back(5);
	deqInt.push_back(7);
	deqInt.push_back(9);

	for (deque<int>::iterator it=deqInt.begin(); it!=deqInt.end(); ++it)
	{
		cout << *it;
		cout << "";
	}
	// 1 3 5 7 9

	for (deque<int>::reverse_iterator rit=deqInt.rbegin(); rit!=deqInt.rend(); ++rit)
	{
		cout << *rit;
		cout << "";
	}
	//9 7 5 3 1deque 对象的带参数构造   


deque(beg,end);    //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。
deque(n,elem);   //构造函数将n个elem拷贝给本身。
deque(const deque &deq);  //拷贝构造函数。    示例代码：


	deque<int> deqIntA;
	deqIntA.push_back(1);
	deqIntA.push_back(3);
	deqIntA.push_back(5);
	deqIntA.push_back(7);
	deqIntA.push_back(9);

	deque<int> deqIntB(deqIntA.begin(),deqIntA.end());	//1 3 5 7 9
	deque<int> deqIntC(5,8);			//8 8 8 8 8
	deque<int> deqIntD(deqIntA);			//1 3 5 7 9deque 的赋值


deque.assign(beg,end);   //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。
deque.assign(n,elem);  //将n个elem拷贝赋值给本身。
deque& operator=(const deque &deq);	//重载等号操作符 
deque.swap(deq);  // 将deq与本身的元素互换    示例代码：  	deque<int> deqIntA,deqIntB,deqIntC,deqIntD;
	deqIntA.push_back(1);
	deqIntA.push_back(3);
	deqIntA.push_back(5);
	deqIntA.push_back(7);
	deqIntA.push_back(9);

	deqIntB.assign(deqIntA.begin(),deqIntA.end());	// 1 3 5 7 9
		
	deqIntC.assign(5,8);		//8 8 8 8 8

	deqIntD = deqIntA;		//1 3 5 7 9

	deqIntC.swap(deqIntD);		//互换deque 的大小


deque.size();	   //返回容器中元素的个数
deque.empty();	   //判断容器是否为空

deque.resize(num);   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。
					//如果容器变短，则末尾超出容器长度的元素被删除。
					
deque.resize(num, elem);  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。
						//如果容器变短，则末尾超出容器长度的元素被删除。    示例代码：  	deque<int> deqIntA;
	deqIntA.push_back(1);
	deqIntA.push_back(3);
	deqIntA.push_back(5);

	int iSize = deqIntA.size();  //3

	if (!deqIntA.empty())
	{
		deqIntA.resize(5);	//1 3 5 0 0
		deqIntA.resize(7,1);	//1 3 5 0 0 1 1
		deqIntA.resize(2);	//1 3
	}deque 的插入


deque.insert(pos,elem);   //在pos位置插入一个elem元素的拷贝，返回新数据的位置。
deque.insert(pos,n,elem);   //在pos位置插入n个elem数据，无返回值。
deque.insert(pos,beg,end);   //在pos位置插入[beg,end)区间的数据，无返回值。    示例代码： 


	deque<int> deqA;
	deque<int> deqB;

	deqA.push_back(1);
	deqA.push_back(3);
	deqA.push_back(5);
	deqA.push_back(7);
	deqA.push_back(9);

	deqB.push_back(2);
	deqB.push_back(4);
	deqB.push_back(6);
	deqB.push_back(8);
	
	deqA.insert(deqA.begin(), 11);		
	//{11, 1, 3, 5, 7, 9}
	deqA.insert(deqA.begin()+1,2,33);		
	//{11,33,33,1,3,5,7,9}
	deqA.insert(deqA.begin() , deqB.begin() , deqB.end() );	
	//{2,4,6,8,11,33,33,1,3,5,7,9}deque 的删除   


deque.clear();	//移除容器的所有数据
deque.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置。
deque.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。    示例代码：


假设 deqInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素
for(deque<int>::iterator it=deqInt.being(); it!=deqInt.end(); )    //小括号里不需写  ++it
{
   if(*it == 3)
   {
        it  =  deqInt.erase(it);      //以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。
         //此时，不执行  ++it；  
   }
   else
   {
       ++it;
   }
}

//删除deqInt的所有元素
deqInt.clear();		//容器为空


版权声明：本文为博主原创文章，未经博主允许不得转载。

ThinkPHP使用入门实例
如今，国产php框架ThinkPHP还是比较火爆的，所有现在我们就简单的使用ThinkPHP来操作一下。
我做的是一下简单的登录操作，意思就是：实现登录功能，但是不能非法访问其它页面，否则跳到登录界面
一：到官方下载最新的ThinkPHP，我下载的是3.2.3完整版

二 ：创建项目，我使用的是wampserver这款php的集成环境，当然也可以使用phpstudy或者xampp，这里就不详细说明了
在www目录下创建think-demo文件夹，也就是项目名，这里可以随便取，然后将下载的thinkphp压缩包解压到think-demo目录下



解压之后出现这些目录，然后我们配置index.php，此时Application中只有一个index.html，我们通过配置index.php，然后浏览器访问生成项目的目录

<?php
// +----------------------------------------------------------------------
// | ThinkPHP [ WE CAN DO IT JUST THINK ]
// +----------------------------------------------------------------------
// | Copyright (c) 2006-2014 http://thinkphp.cn All rights reserved.
// +----------------------------------------------------------------------
// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )
// +----------------------------------------------------------------------
// | Author: liu21st <liu21st@gmail.com>
// +----------------------------------------------------------------------

// 应用入口文件

// 检测PHP环境
if(version_compare(PHP_VERSION,'5.3.0','<'))  die('require PHP > 5.3.0 !');

// 开启调试模式 建议开发阶段开启 部署阶段注释或者设为false
define('APP_DEBUG',True);

// 定义应用目录
define('APP_PATH','./Application/');

/*缓存目录设置*/

define("RUNTIME_PATH",'./Runtime/');
// 引入ThinkPHP入口文件
require './ThinkPHP/ThinkPHP.php';


此时我们知道，一个web项目有前台系统和后台系统之分，所以，我们还要生成后台系统的目录，和index.php一样，我们在同级目录下新建一个admin.php，代码为

<?php
// +----------------------------------------------------------------------
// | ThinkPHP [ WE CAN DO IT JUST THINK ]
// +----------------------------------------------------------------------
// | Copyright (c) 2006-2014 http://thinkphp.cn All rights reserved.
// +----------------------------------------------------------------------
// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )
// +----------------------------------------------------------------------
// | Author: liu21st <liu21st@gmail.com>
// +----------------------------------------------------------------------

// 后台入口文件

// 检测PHP环境
if(version_compare(PHP_VERSION,'5.3.0','<'))  die('require PHP > 5.3.0 !');

// 开启调试模式 建议开发阶段开启 部署阶段注释或者设为false
define('APP_DEBUG',True);
define('BIND_MODULE','Admin');

// 定义后台Admin目录
define('APP_PATH','./Application/');

/*缓存目录设置*/
define('RUNTIME_PATH','./Runtime/');

// 引入ThinkPHP入口文件
require './ThinkPHP/ThinkPHP.php';
好了，我们启动wamp，打开浏览器，分别访问index.php和admin.php




然后我们观察Application目录，发现出现了Admin和Home目录，还有Common和Runtime目录，Admin（后台系统目录）和Home（前台系统目录）主要就是之前的index.php和admin.php访问自动生成的


创建数据库think，创建表admin：

插入数据1,admin,admin（密码使用md5加密）

然后我们这里只完成后台的登录模块，所以Home目录不需要使用，只需Admin目录，我们在Admin下的Controller目录下新建CommonController.class.php和LoginController.php这两个文件
代码分别是：

<?php
/*
 * 公共控制器
 */
 namespace Admin\Controller;
 use Think\Controller;
 class CommonController extends Controller{
	 /*判断用户是否登录*/
	 public function _initialize(){
		 if(!isset($_SESSION['uid']) || !isset($_SESSION['username'])){
			 redirect(U('Login/index'));
		 }
	 }
 }
 ?>
<?php
/*
 * 后台登录控制器
 */
 namespace Admin\Controller;
 use Think\controller;
 class LoginController extends Controller{
	 /*登录页视图*/
	 public function index(){
		 $this->display();
	 }

	 /*登录处理*/
	 public function login(){
		 if(!IS_POST) $this->error('访问页面不存在');


		 $name = I('username');
		 $pwd = md5(I('password'));
		 $db = M('admin');
		 $admin = $db->where(array('username'=>$name))->find();

		 if(!$admin || $admin['password'] != $pwd){
			 $this->error('账号或密码错误');
		 }

		 session('uid',$user['id']);
		 session('username',$user['username']);

		 $this->success('登录成功！', __APP__);
	 }
 }我们完成Admin目录下Conf中config的配置:


<?php
return array(
     /*数据库配置*/
	 'DB_TYPE' => 'mysql',   //数据库类型
	 'DB_HOST' => '127.0.0.1',  //数据库地址
	 'DB_NAME' => 'wldt',    //数据库名称
	 'DB_USER' => 'root',   //用户名
	 'DB_PWD'  => '',      //密码
	 //'DB_PREFIX' => 'dt_',  //数据库表前缀
	/*模板配置*/
	'TMPL_PARSE_STRING' => array(
	    '__PUBLIC__' => '/think-demo/Application/Admin/View/Public',
	),

	/*SESSION和COOKIE配置*/
	'SESSION_PREFIX'  => 'dt_admin'


);


我们在Admin下的View目录下新建目录Login和Public，Login存放登录视图页面，Public存放使用的css,js和图片等资源，然后在Login目录下新建index.html，这就是登录页，我完成的这个demo中使用的js里initjs中路径做了相应的处理

登录页代码：

<html>
<!DOCTYPE html>
<html lang="en" class="no-js">

    <head>

        <meta charset="utf-8">
        <title>登录(Login)</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="">
        <meta name="author" content="">

        <!-- CSS -->
        <link rel="stylesheet" href="__PUBLIC__/assets/css/reset.css">
        <link rel="stylesheet" href="__PUBLIC__/assets/css/supersized.css">
        <link rel="stylesheet" href="__PUBLIC__/assets/css/style.css">

        <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
            <script src="__PUBLIC__/assets/js/html5.js"></script>
        <![endif]-->

    </head>

    <body>

        <div class="page-container">
            <h1>登录(Login)</h1>
            <form action="{:U('login')}" method="post">
                <input type="text" name="username" class="username" placeholder="请输入您的用户名！">
                <input type="password" name="password" class="password" placeholder="请输入您的用户密码！">
                <button type="submit" class="submit_button">登录</button>
                <div class="error"><span>+</span></div>
            </form>
        </div>
		
        <!-- Javascript -->
        <script src="__PUBLIC__/assets/js/jquery-1.8.2.min.js" ></script>
        <script src="__PUBLIC__/assets/js/supersized.3.2.7.min.js" ></script>
        <script src="__PUBLIC__/assets/js/supersized-init.js" ></script>
        <script src="__PUBLIC__/assets/js/scripts.js" ></script>

    </body>
</html>

然后我们输入地址http://localhost/think-demo/index.php/Admin/login进行访问，输入正确账户则访问正确，否则返回登录页



到此，一个小demo就完成了，整个流程比较罗嗦，实现的功能也比较简单，这个小demo我已经上传到资源列表里了，点击这里下载




版权声明：本文为博主原创文章，未经博主允许不得转载。

Tinking in Java--使用NIO实现非阻塞Socket通信
Java1.4提供了一种新的IO读取方式，称为NIO。NIO中使用了通道和缓冲器的概念，并且以块的形式操作数据，这样更接近操作系统IO操作的形式，提高了JavaIO的效率。NIO的核心类有两个Channel和Buffer。但是其实除了提升了基本IO操作的性能外，NIO还提供了非阻塞IO的功能。这里先介绍下阻塞IO和非阻塞IO的概念。考虑到应用程序发送出IO请求，如果这个IO请求会阻塞线程（就是线程停在这里直到读取到了数据再继续运行下去），那么就是阻塞IO；如果这个IO请求没有阻塞线程(线程发出了IO请求，但是并停在这里等数据的到来而是先去做别的事情)就称为非阻塞IO。可以很显然的看到，非阻塞的IO可以提高程序的性能。这篇博客下面会先介绍用于Socket通信的非阻塞IO的具体类，然后再利用这些类实现一个非阻塞的Socket通信服务器。
一.用于非阻塞Socket通信的几个类 
(1).Selector类 
    它是SelectableChannel对象的多路复用器，所有希望采用非阻塞方式进行通信的Channel都应该注册到Selector对象。但是这个类的对象是不能通过调用构造器得到的，而是通过这个类静态的open()方法得到，该方法将使用系统默认的Selector来返回新的Selector。 
    Selector对象可以同时监听多个SelectableChannel的IO状况，是非阻塞IO的核心。一个Selector实例有3个SelectionKey集合。 
    1)所有的SelectionKey集合：代表了注册在该Selector上的Channel，这个集合可以通过keys()方法返回 
    2)被选择的SelectionKey集合：代表了所有可以通过select()方法获取的，需要进行IO处理的Channel，这个集合可以通过selectedKeys()返回。 
    3)被取消的SelectionKey集合：代表了所有被取消注册关系的Channel，下一次执行select()方法时，这些Channel对应的SelectionKey就会被彻底删除，程序通常无须直接访问这个集合。 
Selector类还提供了一系列和select()相关的方法，这些方法比较重要，需要了解一下： 
int select()：监控所有注册的Channel，当他们中有需要处理的IO操作时，该方法返回，并将对应的SelectionKey加入到被选择的SelectionKey集合中，并返回这些Channel的数量。 
int select(long timeout):可以设置超时时长的select()操作 
int selectNow():执行一个立即返回的select()操作，相对与无参数的select()方法而言，该方法不会阻塞线程 
Selector wakeup():使一个还未返回的select()方法立刻返回。
(2)SelectableChannel类 
Selectabel类是一种支持阻塞I/O和非阻塞I/O的通道。应用程序可以调用SelectabelChanel的register()方法将其注册到指定的Selector上。SelectableChannel对象支持阻塞和非阻塞两种模式，但是默认情况下是阻塞的(所有的Channel默认都是阻塞模式)，必须使用非阻塞模式才能支持非阻塞IO。但是不同的SelectableChannel支持的操作是不一样的，向ServerSocketChannel代表一个ServerSocket，它只支持OP_ACCEPT操作。而SocketChannle代表一个socket，支持OP_READ操作。下面是几个SelectableChannel常用的方法： 
boolean isBlocking():返回该Channel是否为阻塞模式 
SelectabelChannel configureBlocking(boolean block):设置是否采用阻塞模式。 
int valiOps():返回一个整数值，表示这个Channel所支持的操作。 
boolean isRegistered():返回该Channel是否已经注册在一个或多个Selector上。
(3)SelectionKey类 
   该类对象代表SelectableChannel和Selector之间的注册关系。
(4)ServerSocketChannel类 
支持非阻塞操作，对应与ServerSocket这个类，支持OP_ACCEPT操作；该类也提供了accept()方法，功能相当于ServerSocket提供的accept()方法。
(5).SocketChannel类 
支持非阻塞操作，对应Socket这个类，支持OP_CONNECT,OP_READ和OP_WRITE操作。这个类还实现了ByteChannel，可以通过SocketChannel来读写ByteBuffer对象。
二.利用非阻塞IO实现一个聊天室的服务器 
  前面我自己写了一个仿QQ的C/S局域网聊天工具，在这个工具中，服务器使用SeverSocket进行监听，每新加入一个人就新建一个socekt与其通信并且还要单独为其开启一个服务线程。这样如果加入的用户比较多，那么就要开启很多的服务线程了，服务器的压力就会比较大。现在我们用非阻塞IO，服务器只需要一个线程就可以同时与多个客户端进行通信。 
  具体的思路是：原先服务器中使用ServerSocket进行监听，现在改用ServerSocketChannel对象进行监听。原先每接入一个客户端，就新建一个Socket进行通信，现在新建一个SocketChannel进行通信。最重要的是这些SelectableChannel对象，都必须注册到一个Selector对象上；然后我们只需要检测这个Selector对象就行了，我们可以调用这个Selector对象的select()方法监听，这样就可以实时监听所有客户端的行为，并可以通过selectedKeys()方法返回需要处理的SelectionKey对象，SelectionKey对象可以判定返回消息的内容(是连接请求还是具体的消息)，并且这个对象的Channel方法可以返回被选中的客户端的Channel。更具体的思路见下面的代码及注释：
package IO;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.Channel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.nio.*;


public class NServer {

    //用于检测所有Channel状态的Selector
    private Selector selector = null;
    ///默认端口
    static final int PORT = 30000;
    //定义实现编码和解码的字符集对象
    private Charset charset = Charset.forName("UTF-8");
    public void init() throws IOException
    {
        //Selector对象是不能通过构造器得到的，必须通过静态的open()方法得到
        selector=Selector.open();

        //SeverSocktChannel对象也不能通过构造器得到，所以需要通过open()方法打开
        ServerSocketChannel server = ServerSocketChannel.open();
        InetSocketAddress isa  = new InetSocketAddress("127.0.0.1",PORT);

        //将ServerSocketChannel绑定到指定的IP地址
        server.bind(isa);

        //设置ServerSocketChannel以非阻塞方式工作(默认是阻塞的)
        server.configureBlocking(false);

        //将server注册到指定的Selector对象
        server.register(selector, SelectionKey.OP_ACCEPT);

        //返回值大于0，表示有Channel中含有需要处理的数据
        while(selector.select()>0){

            //依次处理selector上的每个已选择的SelectionKey
            for(SelectionKey sk : selector.selectedKeys()){

                //从selector已选择的Key集中删除正在处理的SelectionKey
                selector.selectedKeys().remove(sk);
                //如果sk对应的Channel包含客户端的连接请求
                if(sk.isAcceptable()){
                    //调用accept方法接受连接，产生服务端的SocketChannel
                    SocketChannel sc = server.accept();
                    //设置采用非阻塞模式
                    sc.configureBlocking(false);
                    //将该SocketChannel也注册到selector上去
                    sc.register(selector, SelectionKey.OP_READ);
                    //将sk的Channel设置成准备接收其它的请求
                    sk.interestOps(SelectionKey.OP_ACCEPT);
                }
                //如果sk对应的Channel有数据需要读取
                if(sk.isReadable()){
                    //获取SelectionKey对应的Channel，该Channel中有需要读取的数据
                    SocketChannel sc =(SocketChannel)sk.channel();
                    //定义准备执行读取数据的ByteBufferer
                    ByteBuffer buff = ByteBuffer.allocate(1024);
                    String content="";
                    try{
                        while(sc.read(buff)>0){
                            buff.flip();
                            content+=charset.decode(buff);
                        }
                        //将sk对应的Channel设置成准备洗一次读取
                        sk.interestOps(SelectionKey.OP_READ);
                    }

                    //如果捕获到该sk对应的Channel出现了异常，即表明该Channel
                    //对应的Client出现了异常，所以从Selector中取消掉sk的注册
                    catch(IOException e){

                        //从Selector中删除掉指定的SelectionKey
                        sk.cancel();
                        if(sk.channel()!=null){
                            sk.channel().close();
                        }
                    }
                    //如果content的长度不为空，即该聊天信息不为空
                    if(content.length()>0){

                        //遍历该selector中注册的所有SelectionKey
                        for(SelectionKey key: selector.keys()){

                            //获取key对应的Chanel
                            Channel targetChannel = key.channel();
                            //如果该Channel是SocketChannel对象
                            if(targetChannel instanceof SocketChannel){
                                //将读到的内容写入到Channel中
                                SocketChannel dest =(SocketChannel)targetChannel;
                                dest.write(charset.encode(content));
                            }
                        }
                    }
                }
            }
        }
    }
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

poj 2488 DFS
A Knight's Journey




Time Limit: 1000MS
 
Memory Limit: 65536K


Total Submissions: 35974
 
Accepted: 12272




Description
Background
The knight is getting bored of seeing the same black and white squares again and again and has decided to make a journey
around the world. Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. The world of a knight is the chessboard he is living on. Our knight lives on a chessboard that has a smaller area than a regular 8 * 8 board,
 but it is still rectangular. Can you help this adventurous knight to make travel plans?

Problem
Find a path such that the knight visits every square once. The knight can start and end on any square of the board.
Input
The input begins with a positive integer n in the first line. The following lines contain n test cases. Each test case consists of a single line with two positive integers p and q, such that 1 <= p * q <= 26. This represents a
 p * q chessboard, where p describes how many different square numbers 1, . . . , p exist, q describes how many different square letters exist. These are the first q letters of the Latin alphabet: A, . . .
Output
The output for every scenario begins with a line containing "Scenario #i:", where i is the number of the scenario starting at 1. Then print a single line containing the lexicographically first path that visits all squares of the
 chessboard with knight moves followed by an empty line. The path should be given on a single line by concatenating the names of the visited squares. Each square name consists of a capital letter followed by a number.
If no such path exist, you should output impossible on a single line.
Sample Input
3
1 1
2 3
4 3
Sample Output
Scenario #1:
A1

Scenario #2:
impossible

Scenario #3:
A1B3C1A2B4C2A3B1C3A4B2C4

Source
TUD Programming Contest 2005, Darmstadt, Germany
题意是:看 马 是否可以在不重复走相同点的情况下,将所有的点都遍历一遍,并按字典序输出 .

     A B C D E F
1
2
3
4


</pre><pre name="code" class="cpp">#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define INF 0x3f3f3f3f

using namespace std;

int n,m,num=0,flag=0;
int hang[100];
char lie[100];
int vis[100][100];
int dx[]= {-1,1,-2,2,-2,2,-1,1};  //注意顺序,为字典序输出
int dy[]= {-2,-2,-1,-1,1,1,2,2};
int Judge(int x,int y)
{
    if(x<=n&&y<=m&&x>0&&y>0)
        return 1;
    return 0;
}
int DFS(int x,int y,int ans)
{
    if(!Judge(x,y))
        return 0;
    if(ans==n*m)
    {
        hang[ans]=x;
        lie[ans]=(char)(y-1+'A');
        flag=1;
        return ans;
    }
    if(vis[x][y]==0&&!flag) //!flag 会保证第一次遍历成功后就不遍历了.
    {
        hang[ans]=x;
        lie[ans]=(char)(y-1+'A');
        vis[x][y]=1;
        for(int i=0; i<8; i++)
        {
            int fx=dx[i]+x;
            int fy=dy[i]+y;
            if(Judge(fx,fy)&&vis[fx][fy]==0)
            {
			  DFS(fx,fy,ans+1);
            }
        }
        vis[x][y]=0; //找不到还原
    }
}
int main()
{
    int T;
    int Case=0,kk=1;
    while(~scanf("%d",&T))
    {
        while(T--)
        {
		    if(kk==1)
				kk=0;
			else
				printf("\n");
        	flag=0;
            num=0;
            memset(vis,0,sizeof(vis));
            scanf("%d%d",&n,&m);
            DFS(1,1,1);
            Case++;
            printf("Scenario #%d:\n",Case);
            if(flag==0)
			{
			 printf("impossible\n");
			 continue;
			}
            for(int i=1; i<=n*m; i++)
				printf("%c%d",lie[i],hang[i]);
            printf("\n");
        }
    }
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

深入浅出CChart 每日一课——快乐高四第十课 见微知著，CChart内置功能介绍之数据处理篇
CChart内置数据处理功能默认是不打开的。要打开数据处理功能，请点击菜单“绘图状态-->特别功能-->允许数据处理”，这时菜单“曲线数据-->数据名”下，将多出一个“数据处理”菜单，如图所示。



可以看到，笨笨内置了四种数据处理功能，线性变换、微积分、数据平滑、数据拟合。
A10.1 线性变换
“线性变换”菜单提供了三个功能，分别是偏移、缩放、变换。这三个功能都非常简单，只要看看弹出的对话框就全明白了。



可见，对于偏移功能，分别设置X、Y方向的偏移值即可，对于缩放功能，需设置缩放中心和缩放系数，对于变换功能，需设置仿射变换的6个系数。实际上，仿射变换功能完全覆盖了偏移和缩放功能。
对话框中“Reserveold data”表示变换处理后是否保留原曲线。
由于这几个功能都非常简单，就不演示效果了。
A10.2 微积分
“微积分”菜单提供了两个功能，分别是微分和积分。下面是微分和积分两个功能分别弹出的对话框。



对于微分功能，微分方法分后向微分、前向微分和双向微分三种，对于积分功能，积分方法分左积分、右积分、中心积分三种。
下面先画一个正弦曲线。


选择“微分”后的状态。



选择积分后的状态。




A10.3 数据平滑
“数据平滑”菜单提供了两个功能，分别是中值滤波和均值滤波。弹出的对话框如下。




在这里设置滤波的点数。
效果这里也不演示了。
A10.4 数据拟合
“数据拟合”菜单提供了多种功能，笨笨添加了多项式拟合、指数函数拟合、对数函数拟合、单峰高斯函数拟合、多峰高斯函数拟合等。这些是笨笨平时用得较多的，对于其它函数，如有需要也可以添加。
下面笨笨演示一下复杂一点的多峰高斯拟合。
我们知道高斯分布的表达式为y=a*exp(-0.5*((x-b)/c)^2)，其中b就是这个分布的中心位置，c代表峰的宽度，a代表峰的高度。多峰的话，就是在多个位置都有一个高斯峰。
我们画三个峰叠加，三个峰的(a,b, c)分别为(3, 2, 0.3)，(2, 6,0.5)，(5, 10, 0.4)，另外我们还添加一个本底0.6。
这样得到的曲线如图。


我们点击多峰高斯拟合的菜单，弹出如下对话框。



由于我们这里有三个峰，GaussianPeaks应该选择3。
在Peak No下拉列表框中，选择第几个峰，然后在下面ak，bk，ck中设置该峰的初值。初值的关键是峰的位置bk不要差得太远，峰的高度ak和宽度ck无所谓。
前面已知三个峰的位置在2，6，10。我们设置三个峰bk初值分别为1.5，7，10.5。拟合后将弹出一个结果对话框。

可以看到拟合出来的结果和我们设置的初值完全一样。我们看看拟合曲线和原曲线的情况，两条曲线也完全重合。



下面我们在原曲线上加上一个随机噪声。



按上述方法拟合，拟合结果如图。



这时拟合得到的值和我们设置的初值非常接近，说明拟合成功。




可见拟合曲线完美地描述了原曲线的包络。
CChart内置数据处理功能介绍结束。当然功能还不算多，以后将根据需要继续添加。



版权声明：本文为博主原创文章，未经博主允许不得转载。

Java基础 笔记（八）-http
URL方式：使用get方式获取服务器端的一张图片
String path = "http://localhost:8080/Web/mokey.png";
        FileOutputStream fos = null;
        InputStream in = null;
        URL url = new URL(path);
        URLConnection conn = url.openConnection();
        HttpURLConnection con = (HttpURLConnection) conn;
        // 设置请求方式
        con.setRequestMethod("GET");
        // 设置连接的超时时间
        con.setConnectTimeout(5000);
        // 设置可以从服务器端读取数据
        con.setDoInput(true);

        // 获取服务器端的响应码
        if (con.getResponseCode() == 200) {
            // 读取服务器端返回的请求资源的数据
            in = con.getInputStream();
            fos = new FileOutputStream("file\\s1.png");
            byte[] arr = new byte[1024];
            int len = 0;
            while ((len = in.read(arr)) != -1) {
                fos.write(arr, 0, len);
            }
        }
//关闭资源
        in.close();
       fos.close();
URL方式：使用post方式向服务器端提交数据并获取服务器端返回的数据
String path = "http://localhost:8080/web/servlet/LoginServlet";
        //定义要提交到服务器端的数据
        HashMap<String,String> data = new HashMap<String,String>();
        data.put("username", "呵呵");
        data.put("pwd", "1234");

        //把要提交的数据组织成username=weqe&pwd=123格式
        StringBuilder sb = new StringBuilder();
        for(Map.Entry<String,String> en:data.entrySet())
        {
            sb.append(en.getKey()).append("=")
              .append(URLEncoder.encode(en.getValue(),"utf-8")).append("&");
        }
        //去掉最后的&
        sb.deleteCharAt(sb.length()-1);

        //连接服务器并发送头信息
        URL url = new URL(path);
        HttpURLConnection conn = (HttpURLConnection)url.openConnection();
        conn.setRequestMethod("POST");
        conn.setConnectTimeout(5000);
        conn.setDoInput(true);
        //设置可以向服务器端发送数据
        conn.setDoOutput(true);     
        //设置请求的头信息
        //设置提交的数据的类型
        conn.setRequestProperty("Content-Type"," application/x-www-form-urlencoded");       
        //设置提交的数据的长度
        byte[] b = sb.toString().getBytes("utf-8");     conn.setRequestProperty("Content-Length",String.valueOf(b.length));     
        //发送用户名和密码
        OutputStream out = conn.getOutputStream();
        out.write(b,0,b.length);
        out.close();

        //获取响应的信息
        if(conn.getResponseCode()==200)
        {
            InputStream in = conn.getInputStream();
            byte[] arr  = new byte[1024];
            int len =in.read(arr);
            System.out.println(new   String(arr,0,len,"utf-8"));            
}
通过Apache开源工具包：
public static String sendByPost(HashMap<String,String> map,String path,String encode) throws ClientProtocolException, IOException
    {
        List<NameValuePair> list = new ArrayList<NameValuePair>();
        for(Map.Entry<String,String> en:map.entrySet())
        {
            list.add(new BasicNameValuePair(en.getKey(),en.getValue()));
        }
        //把要提交的表单数组织成username=weqe&psw=123格式
        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list,encode);        
        HttpPost post = new HttpPost(path);//提交方式对象
        post.setEntity(entity);     
        HttpClient client = new DefaultHttpClient();//执行提交的对
        //执行提交
        HttpResponse response = client.execute(post);       
        if(response.getStatusLine().getStatusCode()==200)
        {
            //获取读取流
            InputStream in = response.getEntity().getContent();
            return checkLogin(in,encode);
        }
        return null;
    }
    private static String checkLogin(InputStream in, String encode) throws IOException {
//把从服务器得到的数据暂存在内存流中
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        byte[] arr = new byte[1024];
        int len =0;
        while((len = in.read(arr))!=-1)
        {
            bos.write(arr,0,len);
        }
        byte[] b= bos.toByteArray();
        String ss = new String(b,0,b.length,encode);
        return ss;
}
调用：
String path = "http://localhost:8080/web/servlet/LoginServlet";
HashMap<String,String> map = new HashMap<String,String>();
map.put("username", "呵呵");
map.put("pwd", "123");
String result = HttpUtil.sendByPost(map, path, "utf-8");
System.out.println(result);
引用： 
jvm垃圾收集器与内存分配 
强引用—> 
指在程序中普遍存在，类似Object obj = new Object();这类的引用，只要强引用还存在，垃圾收集器永远不会回收被引用的对象。 
软引用–> 
给”hello”创键了一个软引用，这时有一个强引用str,还有一个软引用指向”hello” 
        泛型是引用所指向的对象的类型 
当内存不足时，具备软引用的对象会被回收 
String str = “hello”; 
SoftReference soft = new SoftReference(str);
弱引用–> 
给”hello”创键了一个弱引用，这时有一个强引用str,还有一个弱引用指向”hello” 
只要被垃圾回收线程发现，就会被回收，不管内存足不足 
WeakReference weak = new WeakReference(str);
虚引用–> 
//给”hello”创键了一个 虚引用，这时有一个强引用str,还有一个虚引用指向”hello” 
//虚引用实际并没有指向这个对象,创建虚引用只是为了提高对象被回收的机率， 
//因为它并没有指向这个对象，所以必须结合着队列，当虚引用指向的对象被回收了，虚引用会被放入队列 
ReferenceQueue queue = new ReferenceQueue<>(); 
PhantomReference phantom = new PhantomReference(str, queue);

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

JAVA并发编程6_线程协作/生产者-消费者
前面通过同步锁来同步任务的行为，两个任务在交替访问共享资源的时候，可以通过使用同步锁使得任何时候只有一个任务可以访问该资源，见博客：线程同步之synchronized关键字。下面主要讲的是如何使任务彼此间可以协作，使得多个任务可以一起工作去解决木某个问题，因为有些问题中，某些部分必须在其他部分被解决之前解决，就像在餐厅服务员要端菜就必须有厨师做好了菜。在任务协作时，可以让任务自身挂起，直至某些外部条件发生变化，表示是时候让这个任务向前推动了为止。
wait/notify
wait方法会在等待外部世界产生变化的时候将任务挂起，并且只有在notify或notifyAll发生时即表示发生了某些感兴趣的事物，这个任务才会被唤醒并去检查所产生的变化。
wait方法表示主动释放同步锁并将任务挂起，当前任务处于waiting状态。由于会释放锁，意味着该对象的其他synchronized方法可以在wait期间被调用。而恰好在这些方法里面发生了唤醒被挂起任务所感兴趣的变化。
当调用wait方法时，就是再声明：“我已经刚刚做完能做的所有事情，因此我要在这里等待，但是我希望其他的synchronized操作在条件适合的情况下通知我让我继续执行。”
notify方法用来唤醒处于wait状态的任务，当notify/notifyAll因某个特定的锁而被调用时，只有等待这个锁的任务才会被唤醒。
注：
wait/notify/notifyAll这些方法是基类Object的一部分。因为任何Object都可以作为同步锁。并且只能在同步控制方法或者同步代码块里面才能调用这些方法，如果在非同步方法里面调用，程序能通过编译，运行的时候会报错IllegalMonitorStateException。也就是说调用这些方法必须拥有对象锁（同步锁）。


生产者消费者
在一个饭店里，有一个厨师和一个服务员，这个服务员必须等待厨师准备好膳食，当厨师准备好时，他会通知服务员，之后服务员上菜，然后返回继续等待。这是一个任务协作的实例。厨师代表生产者，而服务员代表消费者。

class Restaurant{
	private Object obj;
	public void put(){
		while (true) {
			synchronized (this) {
				while (obj != null) {
					try {
						wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				obj = new Object();
				System.out.print("Order up!  ");
		        notifyAll();
			}
		}
	}
	
	public void get(){
		while (true) {
			synchronized (this) {
				while (obj == null) {
					try {
						wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				
				System.out.println("waiter get meal");
				obj = null;
				notifyAll();
			}
			
		}
	}
	
}

class Chef extends Thread{
	private Restaurant restaurant;
	public Chef(Restaurant restaurant){
		this.restaurant = restaurant;
	}
	@Override
	public void run() {
		restaurant.put();
	}
}

class Waiter extends Thread{
	private Restaurant restaurant;
	public Waiter(Restaurant restaurant){
		this.restaurant = restaurant;
	}
	@Override
	public void run() {
		restaurant.get();
	}
}

public class Test {
	public static void main(String[] args) {
		Restaurant restaurant = new Restaurant();
		Chef produce = new Chef(restaurant);
		Waiter consumer = new Waiter(restaurant);
		produce.start();
		consumer.start();
	}
}输出：


Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
Order up!  waiter get meal
...


Chef和Waiter通过Resaurant打交道，在两个线程中，一个线程也就是厨师线程挂起等待服务员线程消费做好的meal，他所感兴趣的事物就是obj是否为null。一旦obj为null也就是服务员将这份meal消费了，就会唤醒服务员消费这份meal。
另一个线程也就是服务员线程挂起等待厨师做好meal，他所感兴趣的事物也是obj是否为null。一旦obj不为null，他会消费这份meal，并且唤醒厨师做下一份meal。


一般，wait会被包装在while()语句中，这个语句在不断地测试正在等待的事物。可否换成if？初步看上去，一旦被唤醒，这个obj必然时刻获得的，因为任务被唤醒就是发生了其感兴趣的事物，可是，正事由于问题发生在并发应用中。其他任务有可能会在当前任务被唤醒时，突然插足拿走obj。因为常用下面wait的惯用法
while(conditiopnIsNotMet)
wait();
这样才能更加安全，保证了在退出循环之前条件得到满足。








TCO 2015 2D

250分题：给一段只有‘0’，‘1’构成的字符串，然后给出串上平衡点的定义：在串上找到某个点（位置是p），这个点将串分成左右两部分（可以为空），左右分别计算字符的值的和，如果左边有字符是‘1’，那么字符值加上当前位置（i）与平衡点位置的距离（p - i），同理计算右边，如果左右的字符值相等，则就是平衡点。举例：100111是一个中第二个1将串分成100和11，左右的值都是3，是平衡点。

问这段’0′, ‘1’字符串中能找到多少个包含平衡点的子串?
串长度 < 2500

解析：看数据量是一个不能超过O(N^3)的题目，所以不能枚举子串的头尾，然后再枚举每一个点是否是平衡点。这题有很多种做法，可以枚举枚举平衡点的位置，也可以枚举子串，再检测子串是不是含有平衡点。

枚举平衡点的做法是先枚举每个点位置作为平衡点，然后分别扫描左边，记录所有值出现的次数，然后再扫描右边，计算字符值，如果左边出现了相同的字符值，就是一个含有平衡点的子串，所以结果加上左边出现当前字符值的次数。这样计算的复杂度是O(N^2 * logN)，时间没有问题，但是有一个trick，就是枚举的是平衡点，算子串的时候会有重复计算，想一下可以发现，只有全’0’的字符串中的平衡点可以任意移动，其他字符串要么没有平衡点，要么仅有一个平衡点，所以这里要小心处理0的情况，比赛的时候脑袋蒙全，一直没理清楚。

另外一种就是枚举子串，一旦确定子串就要在非常短的时间内判断子串是否包含平衡点，想一下，’平衡点’如果在串中移动会有什么效果（假定向右）：

左边的值 += 左边‘1’的个数右边的值 -= 右边‘1’的个数

结果就是左值 – 右值加上了全部‘1’的个数，反向移动就是减去全部‘1’的个数。考虑另外一个事实:’平衡点’左端点时，左值 – 右值 <= 0;右边,左值 – 右值 >= 0;加上前面的推论，点在串中移动如果存在 左值 – 右值 == 0的情况，左值 – 右值一定是串中’1’个数的倍数。端点处的左右值差用前缀和，’1’个数也用前缀和来求，这样得到复杂度为O(N^2)的算法。

还有另外O(N^2)的算法，也挺优美，不再表述，可以通过右（左）值的单调性，来移动平衡点。

法一代码：class BalancedSubstrings {
	public:
	int countSubstrings(string s) {
		int res = 0;

		for(int i = 0;i < s.size();i++) {
			int sum = 0;
			map<int, int> sumMap;
			sumMap[0] = 1;
			for(int j = i - 1;j >= 0;j--) {
				if (s[j] == '1') {
					sum += (i - j);
				}
				if (sumMap.find(sum) == sumMap.end()) {
					sumMap[sum] = 1;
				} else {
					sumMap[sum]++;
				}
			}

			sum = 0;
			res += sumMap[0];
			for(int j = i + 1;j < s.size();j++) {
				if (s[j] == '1') {
					sum += (j - i);
				}
				if (sum == 0 && s[i] == '0') {
					continue;
				}

				if (sumMap.find(sum) != sumMap.end()) {
					res += sumMap[sum];
				}
			}
		}
		return res;
	}
};


法二代码：

class BalancedSubstrings {
	public:
	int countSubstrings(string s) {

		int sum[2550], cnt[2550];
		memset(sum, 0, sizeof(sum));
		memset(cnt, 0, sizeof(cnt));
		for(int i = 0;i < s.size();i++) {
			cnt[i + 1] = cnt[i] + (s[i] == '1');
			sum[i + 1] = sum[i] + (s[i] == '1') * i;
		}

		int res = 0;
		for(int i = 0;i < s.size();i++) {
			for(int j = i;j < s.size();j++) {
				if (cnt[j + 1] - cnt[i] == 0 || 
						(sum[j + 1] - sum[i]) % (cnt[j + 1] - cnt[i]) == 0)
					res++;
			}
		}
		
		return res;
	}
};



500分题：给一个顺序排列的N个箱子，这N个箱子里有连续K个是有东西的箱子，其余的都是空的。某人用最优的方法去确定这K个箱子的位置，问最坏情况下要多少次？
N，K都是long long。

解析：这种关于策略的问题很烦，如果没有见过类似的题目可能会心理发慌，不过冷静一下，很多问题都是纸老虎。考虑这样一个问题：如果不知道箱子个数，我们如何确定有东西箱子的头呢。想想看能不能用二分呢？答案是否定的，因为如果找到一个空箱子，不能确定有东西箱子是在前面还是后面，那什么时候可以二分呢？知道有K个箱子可以吗？不完全行，因为如果当前二分位置前面有超过K个箱子没有被检测，那我们是不知道前面有没有有东西的箱子的。聪明的读者可能想到，如果箱子数 <= 2K个不就可以了吗？第一次枚举在K处，如果有箱子则向前二分，否则箱子在后面。最有策略就是这样的，至于为什么是二分，因为基于比较的最快的查找就是二分。。

考虑了前面的子问题，如何处理箱子数超过2K的情况呢，超过2K的箱子，我们是不能用二分的，只能用贪心的方法粗略的确定有东西箱子的位置，就是每隔K个箱子检测一次，如果检测到，可以用二分去找到头部。最坏的情况就是剩下2K时还没有找到箱子的位置，最后2K个箱子用二分来确定。这里还有一个小trick，最后K – 1个是不用二分的，他们肯定不是头，直接把这K – 1减去即可。

代码：

class BallsInBoxes {
	public:
	long long maxTurns(long long N, long long K) {
		if (N <= K) {
			return 0;
		}

		N -= K;
		long long left = N - max((N + K - 1) / K - 2, 0LL) * K;
		long long res = max((N + K - 1) / K - 2, 0LL);

		while(left > 0) {
			left /= 2;
			res++;
		}

		return res;
	}
};


版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        （多）线程、（多）进程总结
什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。
现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？
答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。
真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。
对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。
有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。
由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。
我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？
有两种解决方案：
一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。
还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。
当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。
总结一下就是，多任务的实现有3种方式：
多进程模式；
多线程模式；
多进程+多线程模式。

同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。
因为复杂度高，调试困难，所以，不是迫不得已，我们也不想编写多任务。但是，有很多时候，没有多任务还真不行。想想在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频，否则，单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频，这显然是不行的。
Python既支持多进程，又支持多线程，我们会讨论如何编写这两种多任务程序。
多进程 
要让Python程序实现多进程（multiprocessing），我们先了解操作系统的相关知识。
Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。
子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。
Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：
multiprocessing.py


import os

print 'Process (%s) start...' % os.getpid()
pid = os.fork()
if pid==0:
    print 'I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid())
else:
    print 'I (%s) just created a child process (%s).' % (os.getpid(), pid)

运行结果如下：
Process (876) start...
I (876) just created a child process (877).
I am child process (877) and my parent is 876.

由于Windows没有fork调用，上面的代码在Windows上无法运行。由于Mac系统是基于BSD（Unix的一种）内核，所以，在Mac下运行是没有问题的，推荐大家用Mac学Python！
有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。 
multiprocessing
如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有fork调用，难道在Windows上无法用Python编写多进程的程序？
由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。
multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：
from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print 'Run child process %s (%s)...' % (name, os.getpid())

if __name__=='__main__':
    print 'Parent process %s.' % os.getpid()
    p = Process(target=run_proc, args=('test',))
    print 'Process will start.'
    p.start()
    p.join()
    print 'Process end.'

执行结果如下：
Parent process 928.
Process will start.
Run child process test (929)...
Process end.

创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。
join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 
Pool
如果要启动大量的子进程，可以用进程池的方式批量创建子进程：
from multiprocessing import Pool
import os, time, random

def long_time_task(name):
    print 'Run task %s (%s)...' % (name, os.getpid())
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print 'Task %s runs %0.2f seconds.' % (name, (end - start))

if __name__=='__main__':
    print 'Parent process %s.' % os.getpid()
    p = Pool()
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print 'Waiting for all subprocesses done...'
    p.close()
    p.join()
    print 'All subprocesses done.'

执行结果如下：

Parent process 669.
Waiting for all subprocesses done...
Run task 0 (671)...
Run task 1 (672)...
Run task 2 (673)...
Run task 3 (674)...
Task 2 runs 0.14 seconds.
Run task 4 (673)...
Task 1 runs 0.27 seconds.
Task 3 runs 0.86 seconds.
Task 0 runs 1.41 seconds.
Task 4 runs 1.91 seconds.
All subprocesses done.

代码解读：
对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。
请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：
p = Pool(5)
就可以同时跑5个进程。
由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。 
进程间通信
Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。
我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：
from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    for value in ['A', 'B', 'C']:
        print 'Put %s to queue...' % value
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    while True:
        value = q.get(True)
        print 'Get %s from queue.' % value

if __name__=='__main__':
    # 父进程创建Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()

运行结果如下：

Put A to queue...
Get A from queue.
Put B to queue...
Get B from queue.
Put C to queue...
Get C from queue.

在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。
多线程 
多任务可以由多进程完成，也可以由一个进程内的多线程完成。
我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。
由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。
Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。
启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：


import time, threading

# 新线程执行的代码:
def loop():
    print 'thread %s is running...' % threading.current_thread().name
    n = 0
    while n < 5:
        n = n + 1
        print 'thread %s >>> %s' % (threading.current_thread().name, n)
        time.sleep(1)
    print 'thread %s ended.' % threading.current_thread().name

print 'thread %s is running...' % threading.current_thread().name
t = threading.Thread(target=loop, name='LoopThread')
t.start()
t.join()
print 'thread %s ended.' % threading.current_thread().name

执行结果如下：

thread MainThread is running...
thread LoopThread is running...
thread LoopThread >>> 1
thread LoopThread >>> 2
thread LoopThread >>> 3
thread LoopThread >>> 4
thread LoopThread >>> 5
thread LoopThread ended.
thread MainThread ended.

由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2…… 
Lock
多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。
来看看多个线程同时操作一个变量怎么把内容给改乱了：
import time, threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print balance

我们定义了一个共享变量balance，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0，但是，由于线程的调度是由操作系统决定的，当t1、t2交替执行时，只要循环次数足够多，balance的结果就不一定是0了。
原因是因为高级语言的一条语句在CPU执行时是若干条语句，即使一个简单的计算：

balance = balance + n

也分两步：

    计算balance + n，存入临时变量中；
    将临时变量的值赋给balance。

也就是可以看成：

x = balance + n
balance = x

由于x是局部变量，两个线程各自都有自己的x，当代码正常执行时：

初始值 balance = 0

t1: x1 = balance + 5 # x1 = 0 + 5 = 5
t1: balance = x1     # balance = 5
t1: x1 = balance - 5 # x1 = 5 - 5 = 0
t1: balance = x1     # balance = 0

t2: x2 = balance + 8 # x2 = 0 + 8 = 8
t2: balance = x2     # balance = 8
t2: x2 = balance - 8 # x2 = 8 - 8 = 0
t2: balance = x2     # balance = 0

结果 balance = 0

但是t1和t2是交替运行的，如果操作系统以下面的顺序执行t1、t2：

初始值 balance = 0

t1: x1 = balance + 5  # x1 = 0 + 5 = 5

t2: x2 = balance + 8  # x2 = 0 + 8 = 8
t2: balance = x2      # balance = 8

t1: balance = x1      # balance = 5
t1: x1 = balance - 5  # x1 = 5 - 5 = 0
t1: balance = x1      # balance = 0

t2: x2 = balance - 5  # x2 = 0 - 5 = -5
t2: balance = x2      # balance = -5

结果 balance = -5

究其原因，是因为修改balance需要多条语句，而执行这几条语句时，线程可能中断，从而导致多个线程把同一个对象的内容改乱了。
两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙地变成了负数，所以，我们必须确保一个线程在修改balance的时候，别的线程一定不能改。
如果我们要确保balance计算正确，就要给change_it()上一把锁，当某个线程开始执行change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时执行change_it()，只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现：
balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire()
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()

当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。
获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。
锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。 
多核CPU
如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。
如果写一个死循环的话，会出现什么情况呢？
打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。
我们可以监控到一个死循环线程会100%占用一个CPU。
如果有两个死循环线程，在多核CPU中，可以监控到会占用200%的CPU，也就是占用两个CPU核心。
要想把N核CPU的核心全部跑满，就必须启动N个死循环线程。
试试用Python写个死循环：
import threading, multiprocessing

def loop():
    x = 0
    while True:
        x = x ^ 1

for i in range(multiprocessing.cpu_count()):
    t = threading.Thread(target=loop)
    t.start()

启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有160%，也就是使用不到两核。
即使启动100个线程，使用率也就170%左右，仍然不到两核。
但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？
因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。
GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。
所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。
不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。
ThreadLocal
在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。
但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：


def process_student(name):
    std = Student(name)
    # std是局部变量，但是每个函数都要用它，因此必须传进去：
    do_task_1(std)
    do_task_2(std)

def do_task_1(std):
    do_subtask_1(std)
    do_subtask_2(std)

def do_task_2(std):
    do_subtask_2(std)
    do_subtask_2(std)

每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的Student对象，不能共享。
如果用一个全局dict存放所有的Student对象，然后以thread自身作为key获得线程对应的Student对象如何？
global_dict = {}

def std_thread(name):
    std = Student(name)
    # 把std放到全局变量global_dict中：
    global_dict[threading.current_thread()] = std
    do_task_1()
    do_task_2()

def do_task_1():
    # 不传入std，而是根据当前线程查找：
    std = global_dict[threading.current_thread()]
    ...

def do_task_2():
    # 任何函数都可以查找出当前线程的std变量：
    std = global_dict[threading.current_thread()]
    ...

这种方式理论上是可行的，它最大的优点是消除了std对象在每层函数中的传递问题，但是，每个函数获取std的代码有点丑。
有没有更简单的方式？
ThreadLocal应运而生，不用查找dict，ThreadLocal帮你自动做这件事：
import threading

# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
    print 'Hello, %s (in %s)' % (local_school.student, threading.current_thread().name)

def process_thread(name):
    # 绑定ThreadLocal的student:
    local_school.student = name
    process_student()

t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')
t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')
t1.start()
t2.start()
t1.join()
t2.join()

执行结果：

Hello, Alice (in Thread-A)
Hello, Bob (in Thread-B)

全局变量local_school就是一个ThreadLocal对象，每个Thread对它都可以读写student属性，但互不影响。你可以把local_school看成全局变量，但每个属性如local_school.student都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。
可以理解为全局变量local_school是一个dict，不但可以用local_school.student，还可以绑定其他变量，如local_school.teacher等等。
ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。
两者对比
我们介绍了多进程和多线程，这是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。
首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。
如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。
如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。
多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。
多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。
多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。
在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。 
线程切换
无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？
我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。
如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型，或者批处理任务模型。
假设你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以幼儿园小朋友的眼光来看，你就正在同时写5科作业。
但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。
所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。 
计算密集型 vs. IO密集型
是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。
计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。
第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。
IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 
异步IO
考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。
现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。
对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。
分布式进程
在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。
Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。
举个例子：如果我们已经有一个通过Queue通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？
原有的Queue可以继续使用，但是，通过managers模块把Queue通过网络暴露出去，就可以让其他机器的进程访问Queue了。
我们先看服务进程，服务进程负责启动Queue，把Queue注册到网络上，然后往Queue里面写入任务：


# taskmanager.py

import random, time, Queue
from multiprocessing.managers import BaseManager

# 发送任务的队列:
task_queue = Queue.Queue()
# 接收结果的队列:
result_queue = Queue.Queue()

# 从BaseManager继承的QueueManager:
class QueueManager(BaseManager):
    pass

# 把两个Queue都注册到网络上, callable参数关联了Queue对象:
QueueManager.register('get_task_queue', callable=lambda: task_queue)
QueueManager.register('get_result_queue', callable=lambda: result_queue)
# 绑定端口5000, 设置验证码'abc':
manager = QueueManager(address=('', 5000), authkey='abc')
# 启动Queue:
manager.start()
# 获得通过网络访问的Queue对象:
task = manager.get_task_queue()
result = manager.get_result_queue()
# 放几个任务进去:
for i in range(10):
    n = random.randint(0, 10000)
    print('Put task %d...' % n)
    task.put(n)
# 从result队列读取结果:
print('Try get results...')
for i in range(10):
    r = result.get(timeout=10)
    print('Result: %s' % r)
# 关闭:
manager.shutdown()

请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到Queue不可以直接对原始的task_queue进行操作，那样就绕过了QueueManager的封装，必须通过manager.get_task_queue()获得的Queue接口添加。
然后，在另一台机器上启动任务进程（本机上启动也可以）：
# taskworker.py

import time, sys, Queue
from multiprocessing.managers import BaseManager

# 创建类似的QueueManager:
class QueueManager(BaseManager):
    pass

# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:
QueueManager.register('get_task_queue')
QueueManager.register('get_result_queue')

# 连接到服务器，也就是运行taskmanager.py的机器:
server_addr = '127.0.0.1'
print('Connect to server %s...' % server_addr)
# 端口和验证码注意保持与taskmanager.py设置的完全一致:
m = QueueManager(address=(server_addr, 5000), authkey='abc')
# 从网络连接:
m.connect()
# 获取Queue的对象:
task = m.get_task_queue()
result = m.get_result_queue()
# 从task队列取任务,并把结果写入result队列:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print('run task %d * %d...' % (n, n))
        r = '%d * %d = %d' % (n, n, n*n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print('task queue is empty.')
# 处理结束:
print('worker exit.')

任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。
现在，可以试试分布式进程的工作效果了。先启动taskmanager.py服务进程：
$ python taskmanager.py 
Put task 3411...
Put task 1605...
Put task 1398...
Put task 4729...
Put task 5300...
Put task 7471...
Put task 68...
Put task 4219...
Put task 339...
Put task 7866...
Try get results...

taskmanager进程发送完任务后，开始等待result队列的结果。现在启动taskworker.py进程：

$ python taskworker.py 127.0.0.1
Connect to server 127.0.0.1...
run task 3411 * 3411...
run task 1605 * 1605...
run task 1398 * 1398...
run task 4729 * 4729...
run task 5300 * 5300...
run task 7471 * 7471...
run task 68 * 68...
run task 4219 * 4219...
run task 339 * 339...
run task 7866 * 7866...
worker exit.

taskworker进程结束，在taskmanager进程中会继续打印出结果：

Result: 3411 * 3411 = 11634921
Result: 1605 * 1605 = 2576025
Result: 1398 * 1398 = 1954404
Result: 4729 * 4729 = 22363441
Result: 5300 * 5300 = 28090000
Result: 7471 * 7471 = 55815841
Result: 68 * 68 = 4624
Result: 4219 * 4219 = 17799961
Result: 339 * 339 = 114921
Result: 7866 * 7866 = 61873956

这个简单的Manager/Worker模型有什么用？其实这就是一个简单但真正的分布式计算，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算n*n的代码换成发送邮件，就实现了邮件队列的异步发送。
Queue对象存储在哪？注意到taskworker.py中根本没有创建Queue的代码，所以，Queue对象存储在taskmanager.py进程中
而Queue之所以能通过网络访问，就是通过QueueManager实现的。由于QueueManager管理的不止一个Queue，所以，要给每个Queue的网络调用接口起个名字，比如get_task_queue。
authkey有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果taskworker.py的authkey和taskmanager.py的authkey不一致，肯定连接不上。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 4135 Co-prime 容斥原理
题意是求a到b的闭区间内有多少个数与n互质，考虑到数据范围比较大，所以我们先用欧拉函数的方式将n的因子分解出来。对于每个因子我们采用dfs来组合他们，并求出范围内和他们不互质的数的个数。这里我们采用容斥原理来处理重复。
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll ans,a,b,c[2048],n;
int cnt;

ll gcd(ll u,ll v)
{
    return v==0?u:gcd(v,u%v);
}

void dfs(int cur,ll lcm,int num)
{
    lcm=c[cur]/gcd(c[cur],lcm)*lcm;
    //printf("%lld\n",lcm);
    if(num%2==1) ans+=(b/lcm-(a-1)/lcm);
    else ans-=(b/lcm-(a-1)/lcm);

    for(int i=cur+1;i<cnt;i++)
        dfs(i,lcm,num+1);
}

int main()
{
    ll i;
    int _,k,j;
    scanf("%d",&_);
    for(k=1; k<=_; k++)
    {
        scanf("%lld%lld%lld",&a,&b,&n);
        memset(c,0,sizeof(c));
        ans=cnt=0;
        for(i=2;i*i<=n&&n>1;i++)
        {
            while(n%i==0)
            {
                c[cnt++]=i;
                while(n%i==0)
                    n/=i;
            }
        }
        if(n>1) c[cnt++]=n;
        for(j=0; j<cnt; j++)
            dfs(j,c[j],1);
        ans=b-a+1-ans;
        printf("Case #%d: %lld\n",k,ans);
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。http://xiang578.top/

hdu 1874 畅通工程续(Floyd算法)

题目链接：hdu-1874 畅通工程续
畅通工程续
Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 37414 Accepted Submission(s): 13812


Problem Description
某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。

现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。


Input
本题目包含多组数据，请处理到文件结束
每组数据第一行包含两个正整数N和M(0<N<200,0<M<1000)，分别代表现
有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。
接下来是M行道路信息。每一行有三个整数A,B,X(0<=A,B<N,A!=B,0<X<10000),表示城镇A和城镇B之间有一条长度为X的双向道路。
再接下一行有两个整数S,T(0<=S,T<N)，分别代表起点和终点。


Output
对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1.



Sample Input
3 3
0 1 1
0 2 3
1 2 1
0 2
3 1
0 1 1
1 2


Sample Output
2
-1

题目大意：
       输入一个n,m，表示有n个城市，编号从1到n，有m条路，每条路输入连接的两个城市编号A,B，及路的长度X，题目说X表示从A到B的双向长度，故应建无向图。然后输入起点S与终点T，求从S到T得最短路径，若不存在，就输出-1。
题目分析：
       基础的求最短路径题，使用Floyd算法可求出任意两个顶点间的最短距离，给出起点与终点，将map[S][T]进行输出即可，判断是否起点与终点是否连通也很简单，就看map[S][T]是否等于初始值INF即可，若等，说明不存在到两点的路径。

AC代码：

#include<stdio.h>
#include<string.h>
#define INF 0x3f3f3f3f		//定义一个较大的值，用来初始化 
#define MAX 220				//最多有多少点 
int n,m;					//n代表点数，m代表边数 
int map[MAX][MAX];			//用来存放两点间路径的权值 
void Floyd()				//Floyd算法 
{
	for(int k=0;k<n;k++)
		for(int i=0;i<n;i++)
			for(int j=0;j<n;j++)
				if(map[i][j]>map[i][k]+map[k][j])
				map[i][j]=map[i][k]+map[k][j];
}
int main()
{
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		for(int i=0;i<n;i++)	//先将map数组初始化 
		for(int j=0;j<n;j++)
		if(i==j)
			map[i][j]=0;
		else
			map[i][j]=INF;
		for(int i=0;i<m;i++)
		{
			int a,b,d;
			scanf("%d%d%d",&a,&b,&d);
			if(map[a][b]>d)		//存边，并去重 
			{
				map[a][b]=d;
				map[b][a]=d;	//无向图 
			}
		}
		Floyd();
		int s,e;
		scanf("%d%d",&s,&e);
		if(map[s][e]==INF)
			printf("-1\n");
		else
			printf("%d\n",map[s][e]);	//输出起点到终点的最短距离 
	}
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

[笔记][Java7并发编程实战手册]4.2 创建线程执行器newCachedThreadPool无界线程池
[笔记][Java7并发编程实战手册]系列目录

简介
newCachedThreadPool()创建的线程池的特性是： 
　　自动回收不使用的线程（终止并从缓存中移除那些已有 60 秒钟未被使用的线程），（在无可用线程的情况下）自动的为新来的task创建新线程。 
使用场景： 
　　在小任务量，任务时间执行短的场景下能提高性能。
在jdk api中的介绍如下一部分，其他的请查看api文档

　　ThreadPoolExecutor是一个一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 
　　线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 
为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但是，强烈建议程序员使用较为方便的 Executors 工厂方法构建服务： 
  1. Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收） 
  2. Executors.newFixedThreadPool(int)（固定大小线程池） 
  3. Executors.newSingleThreadExecutor()（单个后台线程），它们均为大多数使用场景预定义了设置。


本章使用心得newCachedThreadPool()

使用Executors来构建预置服务。
要记得使用shutdown() 来关闭执行器，如果不关闭，则一直等待新任务的到来，该方法在api中的解释：按过去执行已提交任务的顺序发起一个有序的关闭，但是不接受新任务。如果已经关闭，则调用没有其他作用。 

上手使用伪代码：
ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool(); //创建线程池执执行器服务
executor.execute(task); //把Runnable交给执行器执行
executor.shutdown(); //申请关闭执行器

简单的示例示例
场景描述：以下示例就是演示了，把一组线程交给执行器执行，在执行器中打印执行器中线程池中的一些任务信息。
/**
 * Created by zhuqiang on 2015/8/24 0024.
 */
public class Client {
    public static void main(String[] args) throws InterruptedException {
        Service s = new Service();
        for (int i = 0; i <  3; i++) {
            Task task = new Task(new Date(), "task" + i);
            TimeUnit.SECONDS.sleep(3); // 休眠3秒，以便等待有任务执行完的线程。在信息里面能看到更丰富的 执行器的管理信息
            s.executorTask(task);
        }
        s.endService();  // 1  如果注释此代码，本程序将挂起。不会结束
    }
}
/** 模拟任务类*/
class  Task implements  Runnable{
    private Date initDate; //初始化时间
    private String name;  //任务名称

    public Task(Date initDate, String name) {
        this.initDate = initDate;
        this.name = name;
    }

    @Override
    public void run() {
        Thread t = Thread.currentThread();
        System.out.printf("  start-------------%s,任务名称：%s,时间:%s\n", t.getName(),this.name,initDate);
        try {
            long  time = (long)(Math.random() * 10); //模拟工作时间
            TimeUnit.SECONDS.sleep(time);
            System.out.printf("  end-------------%s,任务名称：%s,耗时:%s\n", t.getName(),this.name,time);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
/** 服务类，接收每一个任务*/
class Service{
    private ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();

    /** 接受任务，直接丢给了 线程池执行*/
    public void executorTask(Task task){
        System.out.println("service：接收了一个task");
        executor.execute(task);
        System.out.printf("service:pool执行器中线程中实际的线程数量:%d，执行器中正在执行任务的线程数量：%d，执行器中已经完成的任务数量:%d\n",executor.getPoolSize(),executor.getActiveCount(),executor.getCompletedTaskCount());
    }
    /** */
    public void endService(){
        System.out.printf("service-----------------shutdown--------------:pool执行器中线程中实际的线程数量:%d，执行器中正在执行任务的线程数量：%d，执行器中已经完成的任务数量:%d\n",executor.getPoolSize(),executor.getActiveCount(),executor.getCompletedTaskCount());
        executor.shutdown();
    }
}
某一次的运行结果：
service：接收了一个task
  start-------------pool-1-thread-1,任务名称：task0,时间:Mon Aug 24 22:33:23 CST 2015
service:pool执行器中线程中实际的线程数量:1，执行器中正在执行任务的线程数量：1，执行器中已经完成的任务数量:0
service：接收了一个task
service:pool执行器中线程中实际的线程数量:2，执行器中正在执行任务的线程数量：2，执行器中已经完成的任务数量:0
  start-------------pool-1-thread-2,任务名称：task1,时间:Mon Aug 24 22:33:26 CST 2015
  end-------------pool-1-thread-1,任务名称：task0,耗时:4
service：接收了一个task
service:pool执行器中线程中实际的线程数量:2，执行器中正在执行任务的线程数量：1，执行器中已经完成的任务数量:1
  start-------------pool-1-thread-1,任务名称：task2,时间:Mon Aug 24 22:33:29 CST 2015
service-----------------shutdown--------------:pool执行器中线程中实际的线程数量:2，执行器中正在执行任务的线程数量：2，执行器中已经完成的任务数量:1
  end-------------pool-1-thread-2,任务名称：task1,耗时:4
  end-------------pool-1-thread-1,任务名称：task2,耗时:9
结果说明 
仔细看上面的线程名称，和task名称，可以看出来，3个任务只使用了2个线程。如果在更多的任务中，线程得到了复用。性能更好了 
可以看到上面打印的信息。一些api打印出来的线程池中的一些任务信息。 没什么可说，先上手。再深入

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

MFC截图工具（不断更新）
基于MFC 开发的截图工具
文件名:Draw
创建单个文档，MFC标准
一.将视图显示
			1.MainFrm.cpp 中
			int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
							SetMenu(NULL);  去掉菜单
							CBRS_BOTTOM  将工具栏现实在下面
							将状态显示的代码去掉
			BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
			cs.style=WS_POPUP;
			2.Draw.cpp(App类)
			BOOL CDrawApp::InitInstance()
			m_pMainWnd->ShowWindow(SW_MAXIMIZE);
			3.添加按ESC退出界面
			在类视图CDrawView添加消息OnKeyDown
			if(nChar ==VK_ESCAPE)
			{
				::PostQuitMessage(0);
			}
			4.在资源视图新创建一个ToolBar，并添加消息处理
			在CDrawView.h
				afx_msg void OnQuit();//退出
				afx_msg void OnCureve();
				afx_msg void OnLine();
				afx_msg void OnEllipse();
				afx_msg void OnRect();
				afx_msg void OnTriangle();
				afx_msg void OnFill();
				afx_msg void OnColor();
				afx_msg void OnSave();
			在CDrawView.cpp
				ON_COMMAND(ID_QUIT,&CMainFrame::OnQuit)
				ON_COMMAND(ID_CURVE,&CMainFrame::OnCureve)
				ON_COMMAND(ID_ONLINE,&CMainFrame::OnLine)
				ON_COMMAND(ID_ELS,&CMainFrame::OnEllipse)
				ON_COMMAND(ID_RECT,&CMainFrame::OnRect)
				ON_COMMAND(ID_TRA,&CMainFrame::OnTriangle)
				ON_COMMAND(ID_RECT,&CMainFrame::OnRect)
				ON_COMMAND(ID_FILL,&CMainFrame::OnFill)
				ON_COMMAND(ID_SAVE,&CMainFrame::OnSave)
				ON_COMMAND(ID_COLOR,&CMainFrame::OnColor)
			5.将桌面图片显示到视图上
			在CMainFram.h
				list<CBitmap *> m_lstDesktopBmp;//每次画一笔都要装到链表里
				int m_nScreenX;
				int m_nScreenY;
			在CMainFrame.cpp
			CMainFrame::CMainFrame()
			{
				m_nScreenX=GetSystemMetrics(SM_CXSCREEN);
				m_nScreenY=GetSystemMetrics(SM_CYSCREEN);
				//获取桌面的图片
				CWindowDC m_dcDesktop(GetDesktopWindow());
				//保存这张图片
				CBitmap *bitmap=new CBitmap;
				bitmap->CreateCompatibleBitmap(&m_dcDesktop,m_nScreenX,m_nScreenY);
				//创建一个DC
				CDC cdc;
				cdc.CreateCompatibleDC(&m_dcDesktop);
				cdc.SelectObject(bitmap);
				//把桌面的图片放到cdc里
				cdc.BitBlt(0,0,m_nScreenX,m_nScreenY,&m_dcDesktop,0,0,SRCCOPY);
				//把bitmap放到链表里
				m_lstDesktopBmp.push_back(bitmap);
			}
			在CDrawView.h中
			void CDrawView::OnDraw(CDC* /*pDC*/)
				//  把 链表的  尾节点的图片 放到 view 上
			CMainFrame* frame = (CMainFrame*)AfxGetMainWnd();
			
			CClientDC dc(this);  //  窗口
			
			CDC cdc;               //  装 链表 尾节点里的 图片
			cdc.CreateCompatibleDC(&dc);
			cdc.SelectObject(frame->m_lstDesktopBmp.back());    // 把 链表 尾节点里的 图片 装到 cdc

			dc.BitBlt(0,0,frame->m_nScreenX,frame->m_nScreenY,&cdc,0,0,SRCCOPY);
二.画图
            1,鼠标左键抬起保存图片到链表尾部(m_nDrawStyle判断画的是什么图形,m_nbDrawFlag判断是否画图,要在构造函数初始化)
			void CDrawView::OnLButtonUp(UINT nFlags, CPoint point)
			{
				// TODO: 在此添加消息处理程序代码和/或调用默认值
				m_bDrawFlag=false;
				//保存图片到链表
				CMainFrame *frame=(CMainFrame*)AfxGetMainWnd();
				CClientDC dc(this);

				CBitmap *bitmap=new CBitmap;
				bitmap->CreateCompatibleBitmap(&dc,frame->m_nScreenX,frame->m_nScreenY);

				CDC cdc;
				cdc.CreateCompatibleDC(&dc);
				cdc.SelectObject(bitmap);
				cdc.BitBlt(0,0,frame->m_nScreenX,frame->m_nScreenY,&dc,0,0,SRCCOPY);
				frame->m_lstDesktopBmp.push_back(bitmap);
				CView::OnLButtonUp(nFlags, point);
			}
			2.画图
			void CDrawView::OnMouseMove(UINT nFlags, CPoint point)
			{
				// TODO: 在此添加消息处理程序代码和/或调用默认值
				if(m_bDrawFlag==true)
				{
					CMainFrame *frame=(CMainFrame*)AfxGetMainWnd();
					CClientDC dc(this);
					//创建兼容性  DC
					//拿链表的最后一张图片刷新
					CDC cdc;
					cdc.CreateCompatibleDC(&dc);
					cdc.SelectObject(frame->m_lstDesktopBmp.back());
					//创建一个位图Bitmap
					//复制链表尾结点的图片
					CBitmap bitmap;
					bitmap.CreateCompatibleBitmap(&dc,frame->m_nScreenX,frame->m_nScreenY);

					CDC tempdc;
					tempdc.CreateCompatibleDC(&dc);
					tempdc.SelectObject(bitmap);
					tempdc.BitBlt(0,0,frame->m_nScreenX,frame->m_nScreenY,&cdc,0,0,SRCCOPY);
					//不能传输dc到tempdc
					//看画什么图形
					switch (m_nDrawStyle)
					{
					case ID_CURVE:
						dc.MoveTo(m_pointMouseDown.x,m_pointMouseDown.y);
						dc.LineTo(point.x,point.y);
						m_pointMouseDown=point;
						break;
					case ID_ONLINE:
						//不能用cdc画图，因为cdc就是链表的最后一张位图，更改cdc就是更改最后一张图片
						//所以在tempdc上面画图
						//移动一次创建的Bitmap就删除，没有改变
						tempdc.MoveTo(m_pointMouseDown.x,m_pointMouseDown.y);
						tempdc.LineTo(point.x,point.y);
						dc.BitBlt(0,0,frame->m_nScreenX,frame->m_nScreenY,&tempdc,0,0,SRCCOPY);
						break;
					case ID_ELS:
						tempdc.SelectStockObject(NULL_BRUSH);
						tempdc.Ellipse(m_pointMouseDown.x,m_pointMouseDown.y,point.x,point.y);
						dc.BitBlt(0,0,frame->m_nScreenX,frame->m_nScreenY,&tempdc,0,0,SRCCOPY);
						break;
					case ID_RECT:
						tempdc.Rectangle(m_pointMouseDown.x,m_pointMouseDown.y,point.x,point.y);
						dc.BitBlt(0,0,frame->m_nScreenX,frame->m_nScreenY,&tempdc,0,0,SRCCOPY);
						break;
					case ID_TRA:
						tempdc.SelectStockObject(NULL_BRUSH);
						POINT rect[3]={{(point.x+m_pointMouseDown.x)/2,m_pointMouseDown.y},{m_pointMouseDown.x,point.y},{point.x,point.y}};
						tempdc.Polygon(rect,3);
						dc.BitBlt(0,0,frame->m_nScreenX,frame->m_nScreenY,&tempdc,0,0,SRCCOPY);
						break;
					}
				}
				CView::OnMouseMove(nFlags, point);
			}


版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 1853 Cyclic Tour 【最小费用最大流 or KM算法】【构图后可以判断图中是否存在哈密顿环】






Cyclic Tour
Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/65535 K (Java/Others)
Total Submission(s): 1948    Accepted Submission(s): 982



Problem Description

There are N cities in our country, and M one-way roads connecting them. Now Little Tom wants to make several cyclic tours, which satisfy that, each cycle contain at least two cities, and each city belongs to one cycle exactly. Tom wants the total length of
 all the tours minimum, but he is too lazy to calculate. Can you help him?

 


Input

There are several test cases in the input. You should process to the end of file (EOF).
The first line of each test case contains two integers N (N ≤ 100) and M, indicating the number of cities and the number of roads. The M lines followed, each of them contains three numbers A, B, and C, indicating that there is a road from city A to city B,
 whose length is C. (1 ≤ A,B ≤ N, A ≠ B, 1 ≤ C ≤ 1000).

 


Output

Output one number for each test case, indicating the minimum length of all the tours. If there are no such tours, output -1. 

 


Sample Input

6 9
1 2 5
2 3 5
3 1 10
3 4 12
4 1 8
4 6 11
5 4 7
5 6 9
6 5 4
6 5
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1

 


Sample Output

42
-1

Hint In the first sample, there are two cycles, (1->2->3->1) and (6->5->4->6) whose length is 20 + 22 = 42.  

 









题意：同hdoj3488，给出N个点M个有向边，求走过一个哈密顿环的最小花费。 若不存在哈密顿环，输出-1，否则输出最小费用。


思路：把每个点i拆分成左点i和右点i+N
1，超级源点连左点，容量为1，费用为0
2，所有右点连超级汇点，容量为1，费用为0
3，每条单向边—— 起点左点 连 终点右点 容量为1,费用为边权。
最后跑一下最小费用最大流流。 若满流说明存在哈密顿环，否则不存在。




AC代码：

#include <cstdio>
#include <cstring>
#include <queue>
#include <stack>
#include <vector>
#include <algorithm>
#define MAXN 200+10
#define MAXM 30000+10
#define INF 0x3f3f3f3f
using namespace std;
struct Edge
{
    int from, to, cap, flow, cost, next;
};
Edge edge[MAXM];
int head[MAXN], edgenum;
int pre[MAXN], dist[MAXN];
bool vis[MAXN];
int N, M;
int sink, source;//超级源点 超级汇点
void init()
{
    edgenum = 0;
    memset(head, -1, sizeof(head));
}
void addEdge(int u, int v, int w, int c)
{
    Edge E1 = {u, v, w, 0, c, head[u]};
    edge[edgenum] = E1;
    head[u] = edgenum++;
    Edge E2 = {v, u, 0, 0, -c, head[v]};
    edge[edgenum] = E2;
    head[v] = edgenum++;
}
void getMap()
{
    int a, b, c;
    sink = 0, source = 2*N+1;
    for(int i = 1; i <= N; i++)
        addEdge(sink, i, 1, 0),//超级源点 连左点
        addEdge(i + N, source, 1, 0);//右点 连超级汇点
    while(M--)
    {
        scanf("%d%d%d", &a, &b, &c);
        addEdge(a, b+N, 1, c);//左点 连 右点
    }
}
bool SPFA(int s, int t)
{
    queue<int> Q;
    memset(dist, INF, sizeof(dist));
    memset(vis, false, sizeof(vis));
    memset(pre, -1, sizeof(pre));
    dist[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            Edge E = edge[i];
            if(dist[E.to] > dist[u] + E.cost && E.cap > E.flow)
            {
                dist[E.to] = dist[u] + E.cost;
                pre[E.to] = i;
                if(!vis[E.to])
                {
                    vis[E.to] = true;
                    Q.push(E.to);
                }
            }
        }
    }
    return pre[t] != -1;
}
void MCMF(int s, int t, int &cost, int &flow)
{
    cost = flow = 0;
    while(SPFA(s, t))
    {
        int Min = INF;
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            Edge E = edge[i];
            Min = min(Min, E.cap-E.flow);
        }
        for(int i = pre[t]; i != -1; i = pre[edge[i^1].to])
        {
            edge[i].flow += Min;
            edge[i^1].flow -= Min;
            cost += edge[i].cost * Min;
        }
        flow += Min;
    }
}
int main()
{
    while(scanf("%d%d", &N, &M) != EOF)
    {
        init();
        getMap();
        int cost, flow;
        MCMF(sink, source, cost, flow);
        if(flow == N)//满流
            printf("%d\n", cost);
        else
            printf("-1\n");
    }
    return 0;
}



KM算法：重刷


注意KM算法结束后，要判断是否完美匹配。



#include <cstdio>
#include <cstring>
#include <algorithm>
#define INF 0x3f3f3f3f
using namespace std;
int lx[110], ly[110];
int Map[110][110];
bool visx[110], visy[110];
int slack[110];
int match[110];
int N, M;
void getMap()
{
    for(int i = 1; i <= N; i++)
    {
        for(int j = 1; j <= N; j++)
            Map[i][j] = -INF;
    }
    int a, b, c;
    while(M--)
    {
        scanf("%d%d%d", &a, &b, &c);
        if(-c > Map[a][b])
            Map[a][b] = -c;
    }
}
int DFS(int x)
{
    visx[x] = true;
    for(int y = 1; y <= N; y++)
    {
        if(visy[y]) continue;
        int t = lx[x] + ly[y] - Map[x][y];
        if(t == 0)
        {
            visy[y] = true;
            if(match[y] == -1 || DFS(match[y]))
            {
                match[y] = x;
                return 1;
            }
        }
        else if(slack[y] > t)
            slack[y] = t;
    }
    return 0;
}
void KM()
{
    memset(match, -1, sizeof(match));
    memset(ly, 0, sizeof(ly));
    for(int x = 1; x <= N; x++)
    {
        lx[x] = -INF;
        for(int y = 1; y <= N; y++)
            lx[x] = max(lx[x], Map[x][y]);
    }
    for(int x = 1; x <= N; x++)
    {
        for(int i = 1; i <= N; i++)
            slack[i] = INF;
        while(1)
        {
            memset(visx, false, sizeof(visx));
            memset(visy, false, sizeof(visy));
            if(DFS(x)) break;
            int d = INF;
            for(int i = 1; i <= N; i++)
            {
                if(!visy[i] && slack[i] < d)
                    d = slack[i];
            }
            for(int i = 1; i <= N; i++)
            {
                if(visx[i])
                   lx[i] -= d;
            }
            for(int i = 1; i <= N; i++)
            {
                if(visy[i])
                    ly[i] += d;
                else
                    slack[i] -= d;
            }
        }
    }
    //判断是否存在完美匹配
    int ans = 0;
    bool flag = true;
    for(int i = 1; i <= N; i++)
    {
        if(match[i] == -1 || Map[match[i]][i] == -INF)
        {
            flag = false;
            break;
        }
        ans += Map[match[i]][i];
    }
    if(flag)
        printf("%d\n", -ans);
    else
        printf("-1\n");
}
int main()
{
    while(scanf("%d%d", &N, &M) != EOF)
    {
        getMap();
        KM();
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA - 1161 Objective: Berlin(最大流＋时序模型)
题目大意：有n个城市m条航线，给出每条航线的出发地，目的地，座位数，起飞时间和到达时间(所给形式为HHMM，记得转化)，再给出城市A和B，和到达城市B的最晚时间，现在问一天内最多有多少人能从A飞到B，可以在其他城市中转
解题思路：将飞机票拆点，拆成i–>i ＋ m,容量为座位数。 
接着判断一下，航线之间的连线 
如果航线的起点是A的话，那么就和超级源点相连，容量为INF 
如果航线的终点是B且到达时间小于等于最晚时间，那么连线，容量为INF 
如果航线i的终点和航线j的起点相同，且航线i的到达时间+30<=航线j的起始时间，那么连线，容量为INF
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#include <map>
#include <iostream>
using namespace std;
#define N 10010
#define INF 0x3f3f3f3f

struct Edge{
    int from, to, cap, flow;
    Edge() {}
    Edge(int from, int to, int cap, int flow) : from(from), to(to), cap(cap), flow(flow) {}
};

struct Dinic{
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[N];
    bool vis[N];
    int d[N], cur[N];

    void init(int n) {
        this->n = n;
        for (int i = 0; i <= n; i++) {
            G[i].clear();
        }
        edges.clear();
    }

    void AddEdge(int from, int to, int cap) {
        edges.push_back(Edge(from, to, cap, 0));
        edges.push_back(Edge(to, from, 0, 0));
        int m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    } 

    bool BFS() {
        memset(vis, 0, sizeof(vis));
        queue<int> Q;
        Q.push(s);
        vis[s] = 1;
        d[s] = 0;

        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for (int i = 0; i < G[u].size(); i++) {
                Edge &e = edges[G[u][i]];
                if (!vis[e.to] && e.cap > e.flow) {
                    vis[e.to] = true;
                    d[e.to] = d[u] + 1;
                    Q.push(e.to);
                }
            }
        }
        return vis[t];
    }

    int DFS(int x, int a) {
        if (x == t || a == 0)
            return a;

        int flow = 0, f;
        for (int i = cur[x]; i < G[x].size(); i++) {
            Edge &e = edges[G[x][i]];
            if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0) {
                e.flow += f;
                edges[G[x][i] ^ 1].flow -= f;
                flow += f;
                a -= f;
                if (a == 0)
                    break;
            }
        }
        return flow;
    }

    int Maxflow(int s, int t) {
        this->s = s; this->t = t;
        int flow = 0;
        while (BFS()) {
            memset(cur, 0, sizeof(cur));
            flow += DFS(s, INF);
        }
        return flow;
    }
};


Dinic dinic;
#define M 5100
#define S 160
int n, m, source, sink, Time;
int num[S];
map<string, int> Map;
struct Node {
    int u, v, c, s, t;
}node[M];

int getTime(string T) {
    int a = (T[0] - '0') * 10 + (T[1] - '0');
    int b = (T[2] - '0') * 10 + (T[3] - '0');
    return a * 60 + b;
}

void solve() {
    Map.clear();
    int cnt = 3;
    string a, b, s, t;

    cin >> a >> b >> s >> m;
    Map[a] = 1; Map[b] = 2;
    Time = getTime(s);

    memset(num, 0, sizeof(num));
    source = 0; sink = 2 * m + 1;
    dinic.init(sink);

    for (int i = 1; i <= m; i++) {
        cin >> a >> b >> node[i].c >> s >> t;

        if (!Map[a]) Map[a] = cnt++;
        if (!Map[b]) Map[b] = cnt++;

        node[i].u = Map[a]; 
        node[i].v = Map[b];
        node[i].s = getTime(s);
        node[i].t = getTime(t);

        num[node[i].u]++; num[node[i].v]++;
        dinic.AddEdge(i, i + m, node[i].c);
    }

    if (!num[1] || !num[2]) {
        printf("0\n");
        return ;
    }

    for (int i = 1; i <= m; i++) {
        int u = node[i].u, v = node[i].v;
        if (u == 1) dinic.AddEdge(source, i, INF);
        if (v == 2 && node[i].t <= Time) dinic.AddEdge(i + m, sink, INF);

        for (int j = 1; j <= m; j++) {
            if (i == j) continue;
            if (v != node[j].u) continue;
            if (node[i].t + 30 <= node[j].s) dinic.AddEdge(i + m, j, INF);

        }
    }
    int ans = dinic.Maxflow(source, sink);
    printf("%d\n", ans);
}

int main() {
    while (scanf("%d\n", &n) != EOF)  solve();
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

C++中的引用在初始化时占用内存吗？
这个问题，还没有完全研究完，先贴上一部分实验结果。 
这里比较疑惑的有两个问题，c++中是怎么实现引用的和引用会和指针一样占用内存吗？ 
其实是一个问题，下面的实验都是在linux64 g++编译器平台 
看第一段代码
#include<iostream>
using namespace std;

int main()
{
 int a=10;
 int* p =&a;
 int &q =a;

 cout<<&a<<endl;
 cout<<&p<<endl;
 cout<<&q<<endl;

 (*p)++;
 q++;
 cout<<a<<endl;
 return 0;
}
三个cout是将变量的地址打印出来 
结果是
0x7fffffffe32c
0x7fffffffe330
0x7fffffffe32c
12
表面上看引用和变量是一个地址，看看目标代码的反汇编代码
int main()
{
  40087d:   55                      push   %rbp
  40087e:   48 89 e5                mov    %rsp,%rbp
  400881:   48 83 ec 20             sub    $0x20,%rsp
int a=10;
  400885:   c7 45 ec 0a 00 00 00    movl   $0xa,-0x14(%rbp)
int* p =&a;
  40088c:   48 8d 45 ec             lea    -0x14(%rbp),%rax
  400890:   48 89 45 f0             mov    %rax,-0x10(%rbp)
int &q =a;
  400894:   48 8d 45 ec             lea    -0x14(%rbp),%rax
  400898:   48 89 45 f8             mov    %rax,-0x8(%rbp)

cout<<&a<<endl;
  40089c:   48 8d 45 ec             lea    -0x14(%rbp),%rax
  4008a0:   48 89 c6                mov    %rax,%rsi
  4008a3:   bf 80 10 60 00          mov    $0x601080,%edi
  4008a8:   e8 b3 fe ff ff          callq  400760 <_ZNSolsEPKv@plt>
  4008ad:   be 80 07 40 00          mov    $0x400780,%esi
  4008b2:   48 89 c7                mov    %rax,%rdi
  4008b5:   e8 b6 fe ff ff          callq  400770 <_ZNSolsEPFRSoS_E@plt>
cout<<&p<<endl;
  4008ba:   48 8d 45 f0             lea    -0x10(%rbp),%rax
  4008be:   48 89 c6                mov    %rax,%rsi
  4008c1:   bf 80 10 60 00          mov    $0x601080,%edi
  4008c6:   e8 95 fe ff ff          callq  400760 <_ZNSolsEPKv@plt>
  4008cb:   be 80 07 40 00          mov    $0x400780,%esi
  4008d0:   48 89 c7                mov    %rax,%rdi
  4008d3:   e8 98 fe ff ff          callq  400770 <_ZNSolsEPFRSoS_E@plt>
cout<<&q<<endl;
  4008d8:   48 8b 45 f8             mov    -0x8(%rbp),%rax
  4008dc:   48 89 c6                mov    %rax,%rsi
  4008df:   bf 80 10 60 00          mov    $0x601080,%edi
  4008e4:   e8 77 fe ff ff          callq  400760 <_ZNSolsEPKv@plt>
  4008e9:   be 80 07 40 00          mov    $0x400780,%esi
  4008ee:   48 89 c7                mov    %rax,%rdi
  4008f1:   e8 7a fe ff ff          callq  400770 <_ZNSolsEPFRSoS_E@plt>
。。。。。
}
主要看这段代码
int &q =a;
  400894:   48 8d 45 ec             lea    -0x14(%rbp),%rax
  400898:   48 89 45 f8             mov    %rax,-0x8(%rbp)
实际q这个所谓的别名是占有内存的， 
那么为什么输出其地址时，输出的引用变量的地址，看看反汇编代码就知道了
cout<<&q<<endl;
  4008d8:   48 8b 45 f8             mov    -0x8(%rbp),%rax
cout<<&p<<endl;
  4008ba:   48 8d 45 f0             lea    -0x10(%rbp),%rax
看看这两者的区别，对于取引用地址，是获取的原变量的地址，而取指针地址，则是将自己的内存地址输出去。
为了进一步说明这个问题 ，再用一段代码
struct  test1
{
 int a;
 int& p;
};
struct test2
{
 int a;
};
struct test3
{
 int a;
 int* p;
};
int main()
{
 cout<<sizeof(test1)<<endl;
 cout<<sizeof(test2)<<endl;
 cout<<sizeof(test3)<<endl;
}
运行结果为 
16 
4 
16 
好像看来引用是占内存的。。 
可是真实这样吗？。。。。。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

DFS解八皇后问题
仔细思考深度优先搜索其实可以分为大概四步.
1.发现,找到想要找的节点,如八皇后就是找到当前行放置皇后的那个点,马走日就是下一步的落点.
2.递进,如果不满足结束条件就继续递归,进入下一层.如八皇后问题就是进入下一行.
3.满足,条件满足了之后,就输出结果,一般都是用一个全局变量来控制数量,一旦==N,就输出结果.
4.返回,dfs得回溯才能遍历所有的结果.


问题描述
八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？
也就是说，使得棋盘中每个横向、纵向、左上至右下斜向、右上至左下斜向均只有一枚皇后。



代码如下:
#include"stdio.h"
#include"math.h"
const int N = 8;
int a[N] = {0};
int solution = 0;

bool isok(int row,int col)//判断这个位置是否可以放置皇后
{
	for (int i = 0; i < row; i++)
	{
		//a[i]的值代表着列,i代表着行,所以重0开始遍历验证行和列有没有重复的
		if(a[i] == col || abs(a[i] - col) == row - i)
		{
			return false;
		}
	}	

}


void Display()//如果数组中个数到达了N个则输出,相当于dfs的结束条件
{
	printf("第%d种解: \n",++soulution);
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)
		{
			if (a[i] == j)
			{
				printf("%d",i);
			}
			else
			{
				printf("#");
			}
		}
		printf("\n");
	}
	printf("---------------------\n");
}

/*
从0,0这个位置开始循环,因为注定每一行都会有一个皇后,所以在第0行就有8种放法,之后依次下移.
相当于递归,结束条件就是row=N-1,也就是每一行都放了一个皇后,相当于一种解法.

*/
void DFS(int row)
{
	for(int col = 0;col < N;col++)
	{
		if (isok(row,col))
		{
			a[row] = col;
			if (row != N-1)
			{
				DFS(row + 1);
			}
			else
			{
				Display();
			}
		}
	}
}

int main()
{
	DFS(0);
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

在linux和windows上安装qt及creator
qt是个跨平台的好东西。
因为考虑到将来的需求，新做的软件需要能够跨平台，因为是用qt来做，所以一开始搭环境就考虑到跨平台的迁移。
一，windows平台
windows上用的是qt5.5+mingw+qtcreator 3.5
其实windows没什么可说的
1，从qt64ng里下载最新的qt5.5+mingw的环境，然后安装包安装。
2，下载最新的qtcreator，然后安装
3，打开qtcreator，工具->选项->构建与运行
添加一个kit


然后选择qt版本




然后选择编译器和调试器


设置的方法跟qt版本差不多
编译器选择mingw64\bin\x86_64-w64-mingw32-g++.exe
调试器选择mingw64\bin\gdb.exe


都选择好后，编译即可通过。
二，linux平台
用的ubuntu kylin 15.04
linux平台下载的官方发布的整合包，qt5.5+qtcreator3.4.2
下载下来是一个.run文件
执行以下命令
chmod +x qt-opensource-linux-x64-5.5.0-2.run

给run加上可执行属性
然后执行.run文件即可


然后打开qtcreator，设置已经自动搞好了，不用再设置了。
但是发现编译不了
于是需要运行sudo apt-get install libqt4-dev
运行完了，编译即可通过。


用qtcreator构建的工程在两个系统上都可以运行了，初步的跨平台就算完成。



版权声明：本文为博主原创文章，未经博主允许不得转载。

DSAPI多功能组件编程应用-DS提示气泡
首先下载DSAPI.dll，并在项目中引用。
该功能包含在DSAPI1.0.1.1及更高版本，DLL请到本人资源里查找。

  Private Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click
        Dim F As New DSAPI.DS提示气泡(Me)
        With F
            .背景色 = Color.Red
            .气泡最大宽度 = 300
            .图标 = Bitmap.FromFile("G:\图标_Icon\png\png-0047.png")
            .文字颜色 = Color.DarkBlue
            .显示方向 = DSAPI.DS提示气泡.方向.下
            .字体 = New Font("微软雅黑", 10)
            .字体清晰度 = Drawing.Text.TextRenderingHint.AntiAliasGridFit
            .文本 = "DS提示气泡" & vbCrLf & "气泡弹出时不抢占原焦点"
        End With
        AddHandler F.气泡被点击, AddressOf Mevent
        F.显示气泡(Button1.PointToScreen(New Point(0, 0) + New Point(0, Button1.Height)))
    End Sub
    Public Sub Mevent(ID As Integer)
        MsgBox("ID为" & ID & "的气泡被点击了")
    End Sub












注：应网友要求，自动消失功能已经提供，当设置‘自动消失时间“为非零时，气泡将在指定时间之后自动消失。

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ--1385--Minimum Transport Cost（最短路记录路径）

Minimum Transport Cost
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 8895    Accepted Submission(s): 2342



Problem Description

These are N cities in Spring country. Between each pair of cities there may be one transportation track or none. Now there is some cargo that should be delivered from one city to another. The transportation fee consists of two parts: 
The cost of the transportation on the path between these cities, and

a certain tax which will be charged whenever any cargo passing through one city, except for the source and the destination cities.

You must write a program to find the route which has the minimum cost.


 


Input

First is N, number of cities. N = 0 indicates the end of input.

The data of path cost, city tax, source and destination cities are given in the input, which is of the form:

a11 a12 ... a1N
a21 a22 ... a2N
...............
aN1 aN2 ... aNN
b1 b2 ... bN

c d
e f
...
g h

where aij is the transport cost from city i to city j, aij = -1 indicates there is no direct path between city i and city j. bi represents the tax of passing through city i. And the cargo is to be delivered from city c to city d, city e to city f, ..., and
 g = h = -1. You must output the sequence of cities passed by and the total cost which is of the form:


 


Output

From c to d :
Path: c-->c1-->......-->ck-->d
Total cost : ......
......

From e to f :
Path: e-->e1-->..........-->ek-->f
Total cost : ......

Note: if there are more minimal paths, output the lexically smallest one. Print a blank line after each test case.



 


Sample Input

5
0 3 22 -1 4
3 0 5 -1 -1
22 5 0 9 20
-1 -1 9 0 4
4 -1 20 4 0
5 17 8 3 1
1 3
3 5
2 4
-1 -1
0


 


Sample Output

From 1 to 3 :
Path: 1-->5-->4-->3
Total cost : 21

From 3 to 5 :
Path: 3-->4-->5
Total cost : 16

From 2 to 4 :
Path: 2-->1-->5-->4
Total cost : 17


 
题意：大体上意思就是给你一个无向图，并且给你这几个城市的税收情况，当你经过一个城市（不是起点城市，也不是终点城市）的时候要加生这个城市收税情况。最后要让你输出路径。
思路；设置一个前驱数组，来记录每一步走的路径。最后输出这个路径即可。
ac代码：
#include<stdio.h>
#define INF 0x3f3f3f3f 
int n,dis[550][550],pre[550][550],c[550];
void getmap(){
	int cost;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			scanf("%d",&cost);
			if(cost==-1)
				dis[i][j]=INF;
			else
				dis[i][j]=cost;
			pre[i][j]=j; //创建一个前驱数组来记录每一步，对前驱数组进行初始化。
		}
	for(int i=1;i<=n;i++)
		scanf("%d",&c[i]);
}
void floyd(){
	int i,j,k;
	for(k=1;k<=n;k++)
		for(i=1;i<=n;i++)
			if(dis[i][k]!=INF){//一种剪枝优化。
				for(j=1;j<=n;j++){
					if(dis[i][j]>dis[i][k]+dis[k][j]+c[k]){//对前驱数组和花费数组进行更新。
						dis[i][j]=dis[i][k]+dis[k][j]+c[k];
						pre[i][j]=pre[i][k];
					}
						
					else if(dis[i][j]==dis[i][k]+dis[k][j]+c[k]){//如果花费相同的话，按字典序记录前驱数组；
						if(pre[i][j]>pre[i][k])
							pre[i][j]=pre[i][k];
					}
				}
			}
}
int main(){
	while(scanf("%d",&n)!=EOF&&n!=0){
		getmap();
		floyd();
		int a,b;
		while(scanf("%d%d",&a,&b)!=EOF&&a!=-1&&b!=-1){
			printf("From %d to %d :\nPath: %d",a,b,a);
			int temp=a;
			while(temp!=b){//输出路径。
				temp=pre[temp][b];
				printf("-->%d",temp);
			}
			printf("\nTotal cost : %d\n\n",dis[a][b]);
		}
	}
	return 0;
} 



版权声明：本文为小小呆原创文章，欲转载，请在后台勾搭本呆。

codecombat之边远地区的森林12-22关及地牢39关代码分享
codecombat中国游戏网址：http://www.codecombat.cn/
所有代码为javascript代码分享

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

12、兽人营地

// 如果有敌人，则攻击之
// 如果没有敌人，则攻击财宝箱
loop {
    // 使用if/else语句
    var enemy = this.findNearestEnemy();
    if (enemy) {
        this.attack(enemy);
    }
    else {
        this.attack("Chest");
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

13、强攻 Areth 塔

this.moveXY(55, 14);
this.moveXY(92, 9);
// 在红色的 X 位置建造一个火焰陷阱
// 撤退到木的 X 位置，来避免伤害。
// 等雇佣兵发现闪亮的火焰陷阱
// 进入营地，放置火焰陷阱在红色的 X 位置
// 冲你的部队喊撤退（提示：使用 say 命令, "Retreat!"）
// 逃回到左边的木的 X 位置
this.buildXY("fire-trap", 94, 19);
this.moveXY(79, 6);
this.moveXY(55, 9);
this.moveXY(79, 6);
this.moveXY(90, 53);
this.buildXY("fire-trap", 90, 53);
this.moveXY(60, 63);
this.buildXY("fire-trap", 60, 63);
this.moveXY(83, 56);
this.say("Retreat");
this.moveXY(79, 6);
this.moveXY(55, 14);
this.moveXY(11, 28);

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

14、森林劈裂者

// 尽可能经常使用你的新技能“cleave”
this.moveXY(23, 23);
loop {
    var enemy = this.findNearestEnemy();
    if (this.isReady("cleave")) {
        // “Cleave”掉敌人！
        this.cleave(enemy);
    }
    else {
        // 否则（如果“cleave”还没准备好），就用你的普通攻击
        this.attack(enemy);
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

15、盾击

// 用shield盾牌和cleave顺势斩在两波进攻中活下来
// 如果cleave顺势斩没有准备好，就用你的shield盾牌技能。
// 你将会需要至少142健康值来保证活下来
loop {
    var enemy = this.findNearestEnemy();
    if (this.isReady("cleave")) {
        this.cleave(enemy);
    }
    else {
        this.shield();   
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

16、竞技场


// 在决斗中击败敌人的英雄！
loop {
    // 在一个循环中找到并攻击敌人
    // 当你完成的时候，提交到多人天梯系统中！
    var enemy = this.findNearestEnemy();
    if (enemy) {
        if (this.isReady("cleave")) {
            this.cleave(enemy);
        }
        else {
            this.attack(enemy);
        }
    }
    else {
        this.say("Hi Guy ! Come here !");
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

17、保护农民

loop {
    var enemy = this.findNearestEnemy();
    var distance = this.distanceTo(enemy);
    if (distance < 10) {
        // 如果他们与农民太近，就攻击他们
        if (this.isReady("cleave")) {
            this.cleave(enemy);
        }
        else {
            this.attack(enemy);
        }
    }
    // 否则的话，呆在农民旁边！
    else {
        this.moveXY(40, 37);
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

18、奥法盟友

// 拿下那些兽人
//注意提升装备
loop {
    var enemy = this.findNearestEnemy();
    if (enemy) {
        this.attack(enemy);
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

19、收割小食人魔

// 铲除所有遗留的小食人魔
// 确保你有足够的护甲。
loop {
    var enemy = this.findNearestEnemy();
    if (enemy) {
        if (this.isReady("cleave")) {
            this.cleave(enemy);
        }
        else {
            this.attack(enemy);          
        }
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

20、测距仪

var enemy1 = "Gort";
var enemy2 = "Smasher";
var enemy3 = "Charles";
var enemy4 = "Gorgnub";
var distance1 = this.distanceTo(enemy1);
this.say(distance1);
// 大炮会毁掉 Gort！
// 找到另外两个食人魔的距离
var distance2 = this.distanceTo(enemy2);
this.say(distance2);
var distance3 = this.distanceTo(enemy4);
this.say(distance3);
// 说出距离，下指令开炮！

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

21、一大群小食人魔

loop {
    // 检查与最近敌人的距离
    var enemy = this.findNearestEnemy();
    var distance = this.distanceTo(enemy);
    // 如果它接近到10m以内，cleave掉它！
    if (distance < 10) {
        if (this.isReady("cleave")) {
            this.cleave(enemy);
        }
        else {
           this.attack(enemy);
        }
    }
    // 否则，通过名字攻击宝箱（“Chest”）
    else {
        this.attack("Chest");
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

22、移动中的静止

// 你可以将一个if语句放到另一个if语句当中。
// 但是，这样语句会变得很复杂，因此你必须注意这些if语句是如何互相影响的。
// 用注释来描述你的代码逻辑
// 在一个if/else语句中，对其里面的if/else进行注释将会很有帮助，如下所示：
loop {
    var enemy = this.findNearestEnemy();
    // 如果这是一名敌人，就...
    if(enemy) {
        // 声明一个名为distanceTo的变量来代表距离
        var distance = this.distanceTo(enemy);
        // 如果这名敌人小于5米的距离，那么attack()
        if (distance < 5) {
            this.attack(enemy);
        }
        // 否则（这名敌人还离很远），就shield()
        else {
            this.shield();
        }
    // 否则（没有敌人...）
    } 
    else {
        // ...回到位置X
        this.moveXY(40, 34);
    }
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

番外篇：地牢39关~Kithgard斗殴

No、1
// 在一波波的食人魔攻击中活下来。
// 如果你赢了，本关会变得更难，但给更多的奖励。
// 如果你输了，你必须等一天之后才能重新提交。
// 每次提交都会获得新的随机种子。
loop {
    var enemy = this.findNearestEnemy();
    if (enemy) {
        this.attack(enemy);
    }
}

No、2
//如果你的装备足够好
// 在一波波的食人魔攻击中活下来。
// 如果你赢了，本关会变得更难，但给更多的奖励。
// 如果你输了，你必须等一天之后才能重新提交。
// 每次提交都会获得新的随机种子。
loop {
    var enemy = this.findNearestEnemy();
    if (enemy) {
        if (this.isReady("cleave")) {
        this.cleave(enemy);
        }
        else {
            if (this.isReady("bash")) {
                this.bash(enemy);
            }
            else {
                this.attack(enemy); 
            }
        }
    }
    var item = this.findNearestItem();
    if (item) {
        var pos = item.pos;
        var x = pos.x;
        var y = pos.y;
        this.moveXY(x, y); 
    }
}

版权声明：本文为博主原创文章，喜欢就拿去吧！^-^

LeetCode -- Candy
题目：There are N children standing in a line. Each child is assigned a rating value.You are giving candies to these children subjected to the following requirements:Each child must have at least one candy.Children with a higher rating get more candies than their neighbors.What is the minimum candies you must give?就是给定1个rating数组，表示每个娃所得的评分。现在要求：1.给每个娃至少分1个candy2.分高的娃要比邻居所得的candy多3.尽量少分candy思路：此题采用贪心法。贪心策略：1. 先分给谁？ 从得分最少的娃开始分，因此不妨构造child对象，对得分排序，以此存入child。2. 分多少？ 由于是按照得分从低到高分candy的。 如果邻居已经有人得了candy，那么就分别将当前娃的得分与左右两边娃进行对比：a.如果当前得分与左或右相等，只给1个b.如果当前得分大于左或右，需要给对方所得的candy数+1个综合a,b，取最大的那个。如果两边没人得candy，只给当前娃1个。实现代码：class Child
{
	public Child(int i , int v){
		index = i;
		rating = v;
	}
	
	public int index;
	public int rating;
}


public int Candy(int[] ratings) 
{
if(ratings == null || ratings.Length == 0){
	return 0;
}


if(ratings.Length == 1){
	return 1;
}


var arr = new List<Child>();
var candies = new int[ratings.Length];
    for(var i = 0 ;i < ratings.Length; i++){
	candies[i] = 0;
	arr.Add(new Child(i, ratings[i]));
}


arr = arr.OrderBy(x=>x.rating).ToList();


for(var i = 0 ;i < arr.Count ; i++){
	var index = arr[i].index;
	if(candies[index] != 0){
		continue;
	}
	
	if(index == 0){
		candies[index] = ratings[index] == ratings[index + 1]  ? 1 : candies[index + 1] + 1;
	}
	else if(index == candies.Length - 1){
		candies[index] = ratings[index] == ratings[index - 1]  ? 1 : candies[index - 1] + 1;
	}
	else{
		var left = ratings[index-1] == ratings[index] ? 1 : candies[index - 1] + 1;
		var right = ratings[index+1] == ratings[index] ? 1 : candies[index + 1] + 1;
		
		candies[index] = Math.Max(left , right);
	}
	
}


var s = 0;
for(var i = 0;i < candies.Length; i++){
	s += candies[i];
}


return s;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

【Java关键字-Interface】为什么Interface中的变量只能是 public static final


三个关键字在接口中的存在原因：
public：接口可以被其他接口继承，也可以被类实现，类与接口、接口与接口可能会形成多层级关系，采用public可以满足变量的访问范围；
static：如果变量不是static的，那么接口必须实例化才可以访问自己的变量，接口不能被实例化，故非static的变量是无效的；
final：如果变量不是final的，而方法是abstract的，因此接口中的方法又不可以修改变量值，虽然可以直接修改静态成员变量，但所有实现类对应的值都被修改了，此做法等同于抽象类，故需要final修饰成员变量；

何为接口？何为抽象类？
1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个
 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

最后，接口只是对事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则（Open-Closed Principle）的一种体现。


参考文章：
深入理解Java的接口和抽象类

http://shaomeng95.iteye.com/blog/998820


版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 2481 Cows && POJ 2352 Stars(树状数组妙用)
题目链接：POJ 2481 Cows
                    POJ 2352 Stars



发现这两个题目都跟求逆序数有着异曲同工之妙，通过向树状数组中插入点的位置，赋值为1，或者++，然后通过求和来判断比当前 点 ”小“ 的有多少点。


Cows需要自己排序， Stars题目已经给排好序。


POJ 2352 Stars


题目大意为在二维坐标上给出一些星星的坐标，求某一个星星左方，下方，左下方的星星个数。题目已经把星星按照Y坐标从小到大，X从小到大排序。因此，在每次对一个星星进行统计时，之前出现过的星星，只要X坐标比其小，则必在其左，下，左下方。
树状数组储存X的坐标。 就像 
求逆序数 的方法一样， 统计有多少之前的星星的X坐标小于当前的X坐标。
需要注意的是 X 坐标的范围是32000 ，所以树状数组要开到32000 而不是节点数15000。


【源代码】
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn = 32010;
int s[maxn];
int level[maxn];
	int n;
int lowbit(int x){
	return x&(-x);
}
int sum(int x){
	int ans = 0;
	for(int i=x;i>0;i-=lowbit(i)){
		ans+=s[i];
	}
	return ans;
}
void add(int x){
	for(int i=x;i<=maxn;i+=lowbit(i)){
		s[i]++;
	}
}
int main(){
	while(scanf("%d",&n)!=EOF){
		int a,b;
		memset(s,0,sizeof(s));
		memset(level,0,sizeof(level)); //初始化
		for(int i=1;i<=n;i++){
			scanf("%d%d",&a,&b);
			++a; //希望节点从1开始而不是0 ，所以++
			level[sum(a)]++; //直接将统计的数量当做level的下标
			add(a); //添加节点
		}
		for(int i=0;i<n;i++){
			printf("%d\n",level[i]);
		}
	}
	return 0;
}
POJ 2481 Cows


和上一题类似的思想，不过需要手动排序。具体怎么做只要上一题弄懂了应该很容易写出来。
坑点在于可能出现相同的区间，在统计的时候简单处理一下就好。


【源代码】

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int n;
const int maxn = 100100;
struct node{
	int st,end;int id;
}cow[maxn];
int s[maxn];
int level[maxn];
int lowbit(int x){ return x&(-x);}
void add(int x){
	for(int i=x;i<=maxn;i+=lowbit(i))
		s[i]++;
}
int sum(int x){
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i)){
		ans+=s[i];
	}
	return ans;
}
bool cmp(const node&a, const node&b){
	if(a.end==b.end)
		return a.st<b.st;
	return a.end>b.end;
}
int main(){
	while(scanf("%d",&n)!=EOF&&n){
		memset(s,0,sizeof(s));
		for(int i=1;i<=n;i++){
			scanf("%d%d",&cow[i].st,&cow[i].end);
			cow[i].st++; //希望节点从1开始 而不是0 ，所以++
			cow[i].id=i;
		}
		sort(cow+1,cow+n+1,cmp);
		for(int i=1;i<=n;i++){
			if(i>1&&cow[i].st==cow[i-1].st&&cow[i].end==cow[i-1].end){ //判重
				level[cow[i].id]=level[cow[i-1].id];
			}
			else
				level[cow[i].id]=sum(cow[i].st);
			add(cow[i].st);
		}
		for(int i=1;i<=n;i++)
		{
			if(i!=1)
				printf(" ");
			printf("%d",level[i]);
		}
		puts("");
	}
	return 0;
}








版权声明：本文为博主原创文章，未经博主允许不得转载。

杭电（hdu）2085 核反应堆 水题

核反应堆
Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 12219    Accepted Submission(s): 5547



Problem Description

某核反应堆有两类事件发生：
高能质点碰击核子时，质点被吸收，放出3个高能质点和1个低能质点；
低能质点碰击核子时，质点被吸收，放出2个高能质点和1个低能质点。
假定开始的时候（0微秒）只有一个高能质点射入核反应堆，每一微秒引起一个事件发生(对于一个事件，当前存在的所有质点都会撞击核子)，试确定n微秒时高能质点和低能质点的数目。


 


Input

输入含有一些整数n(0≤n≤33)，以微秒为单位，若n为-1表示处理结束。


 


Output

分别输出n微秒时刻高能质点和低能质点的数量，高能质点与低能质点数量之间以逗号空格分隔。每个输出占一行。


 


Sample Input

5 2
-1


 


Sample Output

571, 209
11, 4
代码如下：#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;

long long a[34],b[34];

void initial()
{
	a[0]=1;a[1]=3;
	b[0]=0;b[1]=1;
	for(int i=1;i<=33;i++)
	{
		a[i]=a[i-1]*3;
		b[i]=a[i-1]+b[i-1];
		a[i]+=2*b[i-1];
	}
}

int main()
{
	int n;
	initial();
	while(cin>>n&&n!=-1)
	{
		cout<<a[n]<<", "<<b[n]<<endl;
	}
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。欢迎读者评论和指正

变量在内存中的存储方式-----“大端”和“小端”
     “大端”和“小端”可以追溯到1726年的Jonathan Swift的《格列佛游记》，其中一篇讲到有两个国家因为吃鸡蛋究竟是先打破较大的一端还是先打破较小的一端而争执不休，甚至爆发了战争。1981年10月，Danny Cohen的文章《论圣战以及对和平的祈祷》（On holy wars and a plea for peace）将这一对词语引入了计算机界(《程序设计实践》第9章)。这么看来，所谓大端和小端，也就是big-endian和little-endian，其实是从描述鸡蛋的部位而引申到计算机地址的描述，也可以说，是从一个俚语衍化来的计算机术语。在计算机里，对于地址的描述，很少用“大”和“小”来形容；对应地，用的更多的是“高”和“低”；很不幸地，这对术语直接按字面翻译过来就成了“大端”和“小端”，让人产生迷惑也不是很奇怪的事了。如果将一个32位的整数0x12345678存放到一个整型变量（int）中，这个整型变量采用大端或者小端模式在内存中的存储由下表所示。为简单起见，此处使用OP0表示一个32位数据的最高字节MSB（Most Significant Byte），使用OP3表示一个32位数据最低字节LSB（LeastSignificant Byte）。  地址偏移 大端模式 小端模式   0x00 12（OP0） 78（OP3）   0x01 34（OP1） 56（OP2）   0x02 56（OP2） 34（OP1）   0x03 78（OP3） 12（OP0） 如果将一个16位的整数0x1234存放到一个短整型变量（short）中。这个短整型变量在内存中的存储在大小端模式由下表所示。  地址偏移 大端模式 小端模式   0x00 12（OP0） 34（OP1）   0x01 34（OP1） 12（OP0） 由上表所知，采用大小模式对数据进行存放的主要区别在于在存放的字节顺序，大端方式将高位存放在低地址，小端方式将高位存放在高地址。采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。到目前为止，采用大端或者小端进行数据存放，其孰优孰劣也没有定论。有的处理器系统采用了小端方式进行数据存放，如Intel的奔腾。有的处理器系统采用了大端方式进行数据存放，如IBM半导体和Freescale的PowerPC处理器。不仅对于处理器，一些外设的设计中也存在着使用大端或者小端进行数据存放的选择。因此在一个处理器系统中，有可能存在大端和小端模式同时存在的现象。这一现象为系统的软硬件设计带来了不小的麻烦，这要求系统设计工程师，必须深入理解大端和小端模式的差别。大端与小端模式的差别体现在一个处理器的寄存器，指令集，系统总线等各个层次中。     在裘宗燕翻译的《程序设计实践》里，这对术语并没有翻译为“大端”和小端，而是“高尾端”和“低尾端”，这就好理解了：如果把一个数看成一个字符串，比如11223344看成"11223344"，末尾是个'\0'，'11'到'44'个占用一个存储单元，那么它的尾端很显然是44，前面的高还是低就表示尾端放在高地址还是低地址，它在内存中的放法非常直观，“高/低尾端”比“大/小端”更不容易让人迷惑。但是根据个人经验，在市面上的书籍、网络上的各种资料中，很遗憾，前者已经很少见了，多见的是后者。好在这两对形容词中，恰好“高”和“大”对应，“低”和“小”对应；既然高尾端对应的是大端，低尾端对应的是小端，那么当你再见到大端和小端这一对术语，就可以在脑中把它们转化成高尾端和低尾端，这时凭着之前的理解，甚至不用回忆，想着高低的字面含义就能回想起它们的含义。但是很奇怪的是，同样是裘宗燕翻译的《编程原本》（Elements of Programming），却把big-endian翻译成大尾格式（第一章）。　　理解之后，总结一下，记忆的方法是：　（数据看成字符串）大端——高尾端，小端——低尾端稍一思索什么是“高”、什么是"低"，"尾端"又是什么，问题迎刃而解，再不用担心被“大端”和“小端”迷惑。用这种方式，是时候放弃原先的死记硬背和容易把自己绕进去而发生迷惑的理解了。如何判断系统中的CPU 是Little endian 还是Big endian 模式？分析：作 为一个计算机相关专业的人，我们应该在计算机组成中都学习过什么叫Little endian 和Big endian。Little endian 和Big endian 是CPU 存放数据的两种不同顺序。对于整型、长整型等数据类型，Big endian 认为第一个字节是最高位字节（按照从低地址到高地址的顺序存放数据的高位字节到低位字节）；而Little endian 则相反，它认为第一个字节是最低位字节（按照从低地址到高地址的顺序存放数据的低位字节到高位字节）。例如，假设从内存地址0x0000 开始有以下数据：0x12 0x34 0xab 0xcd如 果我们去读取一个地址为0x0000 的四个字节变量，若字节序为big-endian，则读出结果为0x1234abcd；若字节序位little-endian，则读出结果为 0xcdab3412。如果我们将0x1234abcd 写入到以0x0000 开始的内存中，则Little endian 和Big endian 模式的存放结果如下：地址              0x0000 0x0001 0x0002 0x0003big-endian         0x12  0x34   0xab   0xcdlittle-endian      0xcd   0xab0x34   0x12一般来说，x86 系列CPU 都是little-endian 的字节序，PowerPC 通常是Big endian，还有的CPU 能通过跳线来设置CPU 工作于Little endian 还是Big endian 模式。解答：显然，解答这个问题的方法只能是将一个字节（CHAR/BYTE 类型）的数据和一个整型数据存放于同样的内存开始地址，通过读取整型数据，分析CHAR/BYTE 数据在整型数据的高位还是低位来判断CPU 工作于Littleendian 还是Big endian 模式。得出如下的答案：typedef unsigned char BYTE;int main(int argc, char* argv[]){   unsigned int num,*p;   p = &num;   num = 0;   *(BYTE *)p = 0xff;   if(num == 0xff)   {      printf("little\n");   }   else //num == 0xff000000    {      printf("big\n");   }   return 0;} 除了上述方法(通过指针类型强制转换并对整型数据首字节赋值，判断该赋值赋给了高位还是低位)外，还有没有更好的办法呢？我们知道，union 的成员本身就被存放在相同的内存空间（共享内存，正是union 发挥作用、做贡献的去处），因此，我们可以将一个CHAR/BYTE 数据和一个整型数据同时作为一个union 的成员，得出如下答案：int checkCPU(){   {   union w   {      int a;      char b;   } c;   c.a=1;   return (c.b==1);   }} 实现同样的功能，我们来看看Linux 操作系统中相关的源代码是怎么做的：static union { char c[4]; unsigned long mylong; } endian_test = {{ 'l', '?','?', 'b' } };#define ENDIANNESS ((char)endian_test.mylong)Linux 的内核作者们仅仅用一个union 变量和一个简单的宏定义就实现了一大段代码同样的功能！由以上一段代码我们可以深刻领会到Linux 源代码的精妙之处！(如果ENDIANNESS=’l’表示系统为little endian,为’b’表示big endian ) 参考文章1参考文章2
UVALive	6959 Judging Troubles map应用
#include<bits/stdc++.h>
using namespace std;

map<string,int>m;
int a[200000+5];

int main()
{
    int i,n,tot;
    string s;
    while(~scanf("%d",&n))
    {
        m.clear();
        tot=0;
        memset(a,0,sizeof(a));
        for(i=0;i<n;i++)
        {
            cin>>s;
            if(m[s]==0)
            {
                tot++;
                //printf("%d\n",tot);
                m[s]=tot;
                a[tot]=1;
            }
            else
            {
                a[m[s]]++;
            }
        }
        int ans=0;
        for(i=0;i<n;i++)
        {
            cin>>s;
            if(m[s]==0) ;
            else if(a[m[s]]!=0)
            {
                ans++;
                a[m[s]]--;
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。http://xiang578.top/

【php】开启与关闭调试与报错信息
开启调试与报错信息有利于编程人员掌握出错的位置，从而更快地解决问题。
关闭调试信息，则在你的网页发布时候，用户看不到你的php出现运行错误，当然也不会看到正确东西，仅仅会是一篇空白。
关键是在php安装之后，忘记开启调试与报错信息，在你编程的时候写错代码，却发现php没有报错，会产生一头雾水，此时你要关注你的php安装目录下的php.ini
如下图，找到display_errors那行，注意把Off，改成On，On的第一个字母注意大写。反之亦然。


同时，重启一下你的 Apache服务器。
此时你就可以轻松地开启与关闭调试与报错信息。

版权声明：本文为博主原创文章，未经博主允许不得转载。

NBUT1586 买票回家啦
题意简述：给定一个字符串，问最少删除多少个字符，使该字符串能变成回文字符串。
POJ 1159 有一道一样得题，那边是问增加多少个字符能构成回文。链接：http://poj.org/problem?id=1159
思路：将输入的字符X串逆序存入另一数组Y中，求出两者的最大公共子序列。那么最少需要删除的字符个数  len=X的长度-（X与Y最长子序列长度）。
此题的范围较小，不用考虑时间以及空间问题。POJ1159  就需要考虑了。各位同学可以试着将这两道题一起AC。。




[1586] 买票回家啦

时间限制: 1000 ms　内存限制: 65535 K
问题描述

集训要结束了，同学们就准备回家了。好舍不得回家阿。（那就再待一个月嘛，就这么愉快地决定了。）超哥要回家了，可是他没有挤进12306官网， 
可怜的他就随便找了个能代购车票的网站。结果，当他付钱时傻眼了，这个网站竟然要验证码。验证码嘛就照着样子输入就好了呀，哦不，这个网站管理员是蛇精病阿，
弄了一个特别长的字符串，让登陆的人找最少删减最长回文串 = = 喜(sang)闻(xin)乐(bing)见(kuang). 超爷不服, 哥是ACMer啊，怎么可以被小小验证码难倒......然后,没然后了...
超哥到底买到票了吗？ 预知下文如何，请看本题statistics.（Alex)


输入

第一行是一个数N. N <= 20
接下来N行，每行有一个字符串,只包含小写字母. 长度不大于1000

输出

每个字符串最少删减多少个字符可以成为一个回文字符串.

样例输入
3
abab
aeqa
baab

样例输出
1
1
0

提示
所谓回文字符串，就是一个字符串，从左到右读和从右到左读是完全一样的，比如"aba"。

来源
zyvas

#include<iostream>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;
int dp[2][5000];
int main()
{   string s1,s2;
    int T,i,j;
    cin>>T;
    while(T--){
    	cin>>s1;
    	int len=s1.length();
    	s2=s1;
    	reverse(s1.begin(),s1.end());
    	memset(dp,0,sizeof(dp));
    	for(i=1;i<=len;i++){
    		for(j=1;j<=len;j++){
    			dp[i%2][j]=max(dp[(i-1)%2][j],dp[i%2][j-1]);
    			if(s1[i-1]==s2[j-1]){
    				int temp=dp[(i-1)%2][j-1]+1;
    				dp[i%2][j]=max(dp[i%2][j],temp);
				}
			}
		}
		cout<<len-dp[len%2][len]<<endl;
	}
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ - 2236 Wireless Network（简单并查集）

Wireless Network




Time Limit: 10000MS
 
Memory Limit: 65536KB
 
64bit IO Format: %I64d & %I64u




Submit Status


Description


An earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by
 one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the
 communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B. 

In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations. 





Input


The first line contains two integers N and d (1 <= N <= 1001, 0 <= d <= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers
 xi, yi (0 <= xi, yi <= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats: 
1. "O p" (1 <= p <= N), which means repairing computer p. 
2. "S p q" (1 <= p, q <= N), which means testing whether computer p and q can communicate. 

The input will not exceed 300000 lines. 





Output


For each Testing operation, print "SUCCESS" if the two computers can communicate, or "FAIL" if not.




Sample Input

4 1
0 1
0 2
0 3
0 4
O 1
O 2
O 4
S 1 4
O 3
S 1 4





Sample Output

FAIL
SUCCESS





简单并查集，输入n电脑数量和d两台电脑的最大通信距离，下面n行是1-n台电脑的位置坐标，接下来输入到文件结束是操作O a，表示修好第a台电脑，S a b查询这两台电脑是否可以通信。每次修好一台电脑遍历存在的电脑，把通信范围内的电脑并入一个集合就好了。注意输入到文件结束。


#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;

struct Point
{
	int x, y;
};

const int MAXN = 1000 + 100;
int parent[MAXN];
int n, d;
Point p[MAXN];
bool isrep[MAXN];

void make_set()
{
	for (int i = 0; i <= n; i++)
	{
		parent[i] = i;
		isrep[i] = false;
	}
}

int find_set(int t)
{
	if (parent[t] == t)
		return t;
	else
		return parent[t] = find_set(parent[t]);
}

void union_set(int a, int b)
{
	int t1 = find_set(a);
	int t2 = find_set(b);
	if (t1 != t2)
	{
		parent[t2] = t1;
	}
}

bool isIn(Point a, Point b)
{
	int dd = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);
	if (dd <= d*d) return true;
	return false;
}

int main()
{
	scanf("%d%d", &n, &d);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d%d", &p[i].x, &p[i].y);
	}

	char op;
	int a, b;

	make_set();

	while(cin>>op)
	{
		if (op == 'S')
		{
			scanf("%d%d", &a, &b);
			if (find_set(parent[a]) == find_set(parent[b]))
				printf("SUCCESS\n");
			else
				printf("FAIL\n");
		}
		else
		{
			scanf("%d", &a);
			for (int j = 1; j <= n; j++)
			{
				if (isrep[j])
				{
					if (isIn(p[a], p[j]))
						union_set(a, j);
				}
			}
			isrep[a] = true;
		}
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

从错误中学python(5)——list的sort方法
题目：
对一个列表进行排序
错误的解法
>>> lst=[9,2,6,4,1]
>>> lst
[9, 2, 6, 4, 1]
>>> y=lst.sort()
>>> y
>>> 
list的sort是本地排序的，返回的是None,所以结果lst是排序后的列表,y是None。 
相似的原因，下面的做法也是错的
>>> lst=[9,2,6,4,1]
>>> lst
[9, 2, 6, 4, 1]
>>> (lst.sort()).reverse()
Traceback (most recent call last):
  File "<pyshell#10>", line 1, in <module>
    (lst.sort()).reverse()
AttributeError: 'NoneType' object has no attribute 'reverse'
也就是方法不能连用了。 
那么我们就知道sort方法的特点了：1是本地排序，2是返回None 
这样我们就需要处理一些问题了。
不想本地排序怎么办
最容易想到的办法是使用另一个变量复制一份要排序的内容
>>> x=lst
>>> x.sort()
>>> x
[1, 2, 4, 6, 9]
>>> lst
[1, 2, 4, 6, 9]
这里我们发现，虽然使用了另一个变量依然改变了原来的值，这是因为我们等号传递的是地址。那么我们如果想使用另一变量解决本地排序的问题可以用下面的方法做。
>>> lst=[9,2,6,4,1]
>>> x=lst[:]
>>> x.sort()
>>> lst
[9, 2, 6, 4, 1]
>>> x
[1, 2, 4, 6, 9]
当然我们也可以使用一个sorted函数（不是list的方法，而是一个函数）
>>> lst=[9,2,6,4,1]
>>> y=sorted(lst)
>>> lst
[9, 2, 6, 4, 1]
>>> y
[1, 2, 4, 6, 9]
这个函数不是本地排序的，而是把结果的list返回出来。
这个sorted方法和reversed方法有点像，不过reversed方法返回的reverse iterator对象，sorted返回的是一个列表。
>>> z=reversed(lst)
>>> z
<list_reverseiterator object at 0x0000000003BC5BE0>
>>> list(z)
[1, 4, 6, 2, 9]
两个可选参数
函数指针型key与布尔型reverse
>>> lst.sort(key = lambda x:-1*x)
>>> lst
[9, 6, 4, 2, 1]
>>> lst.sort(key = lambda x:-1*x,reverse=True)
>>> lst
[1, 2, 4, 6, 9]

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，欢迎转载和分享，但请声明出处http://blog.csdn.net/zhzz2012

java填坑
慢慢填坑咯~ 
1. 观察运行结果
package javaBasic;

public class Dervied extends Base {

    private String name = "dervied";

    public Dervied() {
        tellName();
        printName();
    }

    public void tellName() {
        System.out.println("Dervied tell name: " + name);
    }

    public void printName() {
        System.out.println("Dervied print name: " + name);
    }

    public static void main(String[] args){
        new Dervied();    
    }
}

class Base {

    private String name = "base";

    public Base() {
        tellName();
        printName();
    }

    public void tellName() {
        System.out.println("Base tell name: " + name);
    }

    public void printName() {
        System.out.println("Base print name: " + name);
    }
}
原因：

结果是： 
  Dervied tell name: null 
  Dervied print name: null 
  Dervied tell name: dervied 
  Dervied print name: dervied 
  原因有两个  
  构造方法的调用顺序中规定了  
  先调用父类的构造方法 ，然后才去调用子类的构造方法 
  至于为什么父类中的tellName（）和printName（）方法没有调到， 
  是因为java里面重载的概念，子类重写了方法，所以调用子类的相应方法， 
  而为什么name是null，因为这里还没有加载到子类里面的变量name属性，

2.守护线程:只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。守护线程最典型的应用就是 GC (垃圾回收器) 
3.i + 1 < i的数是Integer.MAX_VALUE 
4. 接口中字段：public static final  方法是 public abstract  
5. 
public class NULL {
    public static void haha(){
        System.out.println("haha");
    }
    public static void main(String[] args) {
        ((NULL)null).haha();
    }
}

null值可以强制转换为任何java类类型,(String)null也是合法的。但null强制转换后是无效对象，其返回值还是为null，而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。反过来，没有static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错了



6.抽象类遵循的原则： 
  （1）abstract关键字只能修饰类和方法，不能修饰字段。 
  （2）抽象类不能被实例化（无法使用new关键字创建对象实例），只能被继承。 
  （3）抽象类可以包含属性，方法，构造方法，初始化块，内部类，枚举类，和普通类一样，普通方法一定要实现，变量可以初始化或不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。 
  （4）抽象类中的抽象方法（加了abstract关键字的方法）不能实现。 
  （5）含有抽象方法的类必须定义成抽象类。  
  扩展：抽象类和接口的区别 
  （1）接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。 
  （2）abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。 
  （3）在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。 
  （4）abstract class和interface所反映出的设计理念不同。其实abstract class表示的是”is-a”关系，interface表示的是”has-a”关系。 
  （5）实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。 
  （6）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 2048 神、上帝以及老天爷 错排应用
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <math.h>
#include <stdlib.h>
#include <time.h>
using namespace std;
typedef long long ll;
int main()
{
    int _,n,i;
    ll f[25],c[25];
    double a[25];
    f[1]=0;f[2]=1;
    for(i=3;i<=20;i++)
        f[i]=(i-1)*(f[i-2]+f[i-1]);
    for(i=2,c[1]=1;i<=20;i++)
        c[i]=i*c[i-1];
    for(i=1;i<=20;i++)
        a[i]=1.0*f[i]/c[i]*100;
    scanf("%d",&_);
    while(_--)
    {
        scanf("%d",&n);
        printf("%.2f%%\n",a[n]);
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。http://xiang578.top/

最长递增子序列的数量
数组A包含N个整数（可能包含相同的值）。设S为A的子序列且S中的元素是递增的，则S为A的递增子序列。如果S的长度是所有递增子序列中最长的，则称S为A的最长递增子序列（LIS）。A的LIS可能有很多个。例如A为：{1 3 2 0 4}，1 3 4，1 2 4均为A的LIS。给出数组A，求A的LIS有多少个。由于数量很大，输出Mod 1000000007的结果即可。相同的数字在不同的位置，算作不同的，例如 {1 1 2} 答案为2。 
Input 
第1行：1个数N，表示数组的长度。(1 <= N <= 50000) 
第2 - N + 1行：每行1个数A[i]，表示数组的元素(0 <= A[i] <= 10^9) 
Output 
输出最长递增子序列的数量Mod 1000000007。 
Input示例 
5 
1 
3 
2 
0 
4 
Output示例 
2
必须用nlogn算法，否则超时，那么我们如何计算LIS的个数呢?
先开始我想到的是o(n^2)的做法,很容易理解
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
const int M = 500000+100;

int a[M];
int c[M];
int dp[M];
long long cent[M];

int INF = 1e9 + 1000;
const int mod =1000000007;

int input()
{
    int ans=0;
    char a;
    while((a=getchar())<'0'||a>'9');
    ans=a-'0';
    while((a=getchar())>='0'&&a<='9')
    {
        ans=ans*10+a-'0';
    }
    return ans;
}

int main()
{
    int n;
    #ifdef xxz
     freopen("in.txt","r",stdin);
    #endif // xxz

    while(~scanf("%d",&n))
    {
        for(int i = 0; i < n; i++) a[i] = input() , cent[i] = 1;
        int Max = 0;

        fill(dp,dp+n,0);
        long long ans = 0;
        for(int i = 0; i < n; i++)
        {
            dp[i] = 1;
            for(int j = 0; j < i; j++)
            {
                if(a[j] < a[i])
                {
                    if(dp[i] < dp[j] + 1)
                    {
                        dp[i] = dp[j] + 1;
                        cent[i] = cent[j];
                    }
                    else if(dp[i] == dp[j] + 1)  cent[i] = (cent[i] +cent[j])%mod;
                }
            }

            Max = max(Max,dp[i]);

        }

        for(int i = 0; i < n; i++)
        {
            if(dp[i] == Max) ans = (ans + cent[i]) % mod;
        }

        printf("%d\n",ans%mod);
    }

    return 0;
}
然后从网上搜nlogn的算法没搜到，然后问了好多大神，九爷，鸟神,rabbit,都说用线段树或者树状数组搞，好吧，没搞出来。
然后问tyh，他搜到了一篇国外高手写的思路，看完以后直接转换为代码 
二分+前缀和，orz….膜拜田博士…….. 
果然搜索姿势要正确呀 
思路地址: 
http://stackoverflow.com/questions/22923646/number-of-all-longest-increasing-subsequences
我用中文解释下: 
就是取二元组(i,j),i表示以i元素结尾的序列，j表示方案数 
比如: 
add 1 
len1: (1,1);
add 2:
len1(1,1); 
len2(2,1);
add 5 
len1 (1,1); 
len2 (2,1); 
len3 (5,1);
add 4 
len1 (1,1); 
len2 (2,1); 
len3 (5,1) (4,1); 
……
我们可以找到规律，就是没一行j都是从达到小减少 
新插入一个数，我们先找它应该处于哪一行，用 
就是用LIS的nlogn算法找，它的方案数就等于它上一行比这个数小的所有方案和

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
using namespace std;

typedef long long LL;
const int MOD = 1e9 + 7;
const int INF = 0x7fffffff;
const int N = 50000 + 10;

vector <int> val[N];        // val[i]: 最大长度为i+1的序列的最后一个元素组成的序列
vector <int> sum[N];        // sum[i]: 对应val中每个序列数量的组成的前缀和。
vector <int> last(N, INF);  // last[i]: val[i].back()

int input()
{
    int ans=0;
    char a;
    while((a=getchar())<'0'||a>'9');
    ans=a-'0';
    while((a=getchar())>='0'&&a<='9')
    {
        ans=ans*10+a-'0';
    }
    return ans;
}

void add(int x, int len, int v)
{
    val[len].push_back(x); 
    if(sum[len].size() == 0)
    {
        sum[len].push_back(v);
    }
    else
    {
        sum[len].push_back((sum[len].back() + v) % MOD);
    }
    last[len] = x;
}

int main()
{

    int n, x;
    while (scanf("%d", &n) != EOF)
    {
        int Max = 0;
        for(int i = 0; i < n; i++)
        {
            x = input();
            int len = lower_bound(last.begin(), last.end(), x) - last.begin();
            Max = max(Max, len);
            if(len == 0)
            {
                add(x, len, 1);
            }
            else
            {
                int pos = upper_bound(val[len - 1].begin(), val[len - 1].end(), x,greater<int>() ) - val[len - 1].begin();
                int cnt;
                if(pos == 0)
                {
                    cnt = sum[len - 1].back();
                }
                else
                {
                    cnt = (sum[len - 1].back() - sum[len - 1][pos - 1] + MOD) % MOD;
                }
                add(x, len, cnt);
            }
        }
        printf("%d\n", sum[Max].back());
    }




    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

python并行化介绍及使用 Pool
本篇将要介绍python的并行化，及简单的应用。
主要介绍map函数的使用，一手包办了序列操作、参数传递和结果保存等一系列的操作。 
首先是引入库： 
from multiprocessing.dummy import Pool 
pool=Pool(4) 
results=pool.map(爬取函数，网址列表)
本文将一个简单的例子来看一下如何使用map函数以及这种方法与普通方法的对比情况。
import time
from multiprocessing.dummy import Pool

def getsource(url):
    html=requests.get(url)

urls=[]
for i in range(1,21):
    newpage='http://tieba.baidu.com/p/3522395718?pn='+str(i)
    urls.append(newpage)

timex=time.time()  #测试一
for i in urls:
    getsource(i)
print (time.time()-timex)

#这里是输出的结果：
#10.2820000648 


time1=time.time()  #测试二
pool=Pool(4)
results=pool.map(getsource,urls)
pool.close()
pool.join()
print (time.time()-time1)

#这里是输出结果：
#3.23600006104
对比以上两种方法，可以很明显地看出 测试二比测试一要快很多。
对程序做一下解释： 
测试一种 
for i in urls: 
    getsource(i) #使程序一直遍历urls列表中的网址，然后循环调用getsource函数
测试二中： 
pool=Pool(4)  #声明了4个线程数量，这里的个数根据你电脑的CPU个数来定。 
results=pool.map(getsource,urls) #这里使用map函数，并且函数的参数为自定义函数名称，以及函数中的参数（这里为一个列表） 
pool.close() #关闭pool对象 
pool.join() #join函数的主要作用是等待所有的线程（4个）都执行结束后 
print (time.time()-time1) #输出所用时间差

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Item 9：在析构/构造时不要调用虚函数 Effective C++笔记

Item 9: Never call virtual functions during construction or destruction.


父类构造期间，对虚函数的调用不会下降至子类。如果这并非你的意图，请不要这样做！ 这个问题阿里实习面试曾经问到过，看这篇文章： 2014阿里巴巴面试经历

看Scott Meyers举的例子：

class Transaction {                               // base class for all
public:                                           // transactions
    Transaction(){                                // base class ctor           
        logTransaction();                         // as final action, log this               
    }
    virtual void logTransaction() const = 0;      // make type-dependent
};

class BuyTransaction: public Transaction {        // derived class
public:
    virtual void logTransaction() const;          // how to log trans-
};
...
BuyTransaction b;



b在构造时，调用到父类Transaction的构造函数，其中对logTransaction的调用会被解析到Transaction类。
 那是一个纯虚函数，因此程序会非正常退出。

其实，对于构造函数中直接的虚函数调用，某些编译器会发出警告。


这一点很好理解，因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化， 因此调用子类的函数是不安全的，因此C++不允许这样做。除此之外， 在子类对象的父类构造期间，对象类型为父类而非子类。 不仅虚函数会被解析至父类，运行时类型信息也为父类（dynamic_cast, typeid）。

C++提供了RTTI（Run-Time Type Identification，运行时类型识别）机制， 我们通过typeid操作符便可以得到动态的类型信息，我们在父类的构造函数中输出当前对象的类型：

class Transaction{
public:
    Transaction(){
        cout<<typeid(this).name()<<endl;
    }
};
class BuyTransaction: public Transaction{
public:
    BuyTransaction(){
        cout<<typeid(this).name()<<endl;
    }
};
void main(){
    BuyTransaction b;
}



输出：

P11Transaction
P14BuyTransaction



可见，子类对象在父类构造时期，运行时类型确实为父类。与此同时，dynamic_cast也会解析到父类，
 父类构造函数中调用虚函数就是例子~


除非注明，本博客文章均为原创，转载请以链接形式标明本文地址： http://harttle.com/2015/07/27/effective-cpp-9.html


版权声明：本文为博主原创文章，转载请附上原文链接。

10288 - Coupons （数学期望）
没什么好说的了，看代码吧：
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
int n,m;
ll gcd(ll a,ll b) {
    return b == 0 ? a : gcd(b,a%b);
}
int gainLen(ll a) {
    int cnt = 0;
    while(a > 0) {
        a /= 10; cnt++;
    }
    return cnt;
}
int main() {
    while(~scanf("%d",&n)) {
        ll u = 1 , v = 1;
        for(int i=2;i<=n;i++) {
            u *= i; u += v; v *= i;
            ll c = gcd(u,v);
            u /= c; v /= c;
        }
        u *= n;
        ll c = gcd(u,v);
        u /= c; v /= c;
        if(u % v == 0) printf("%lld\n",u/v);
        else {
            ll a = u / v;
            u -= a*v;
            int len = gainLen(a);
            int len2 = gainLen(v);
            for(int i=0;i<=len;i++) printf(" ");
            printf("%lld\n%lld ",u,a);
            for(int i=0;i<len2;i++) printf("-");
            printf("\n");
            for(int i=0;i<=len;i++) printf(" ");
            printf("%lld\n",v);
        }
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

c++实现单链表
#include<iostream>
#include<assert.h>
using namespace std;
typedef int DataType;

struct LinkNode   //创建一个节点
{
    DataType _data;
    LinkNode* _next;

    LinkNode(const DataType &x) :_data(x), _next(NULL)
    {}
};
class SList
{
public:
    SList(LinkNode* head = NULL, LinkNode* tail = NULL) 
        :_Head(head), _Tail(tail) 
    {}
    void Swap( SList &s)
    {
        swap(_Head, s._Head);
        swap(_Tail, s._Tail);
    }
    SList(const SList &s)
         :_Head(NULL)
        , _Tail(NULL)
    {
        if (s._Head == NULL)
        {
            return;
        }
        LinkNode* begin = s._Head;
        do{
            PushBack(begin->_data);
            begin = begin->_next;
        } while (begin != s._Head);
    }
    ~SList()
    {
        while (_Head)
        {
            if (_Head == _Tail)
            {
                delete _Head;
                _Head = NULL;
                _Tail = NULL;
            }
            else
            {
                LinkNode *del = _Head;
                _Head = _Head->_next;
                delete del;
                _Tail->_next = _Head;
            }
        }
    }
    SList operator= ( SList& s)
    {
        SList tmp(s);
        Swap(tmp);
        return *this;
    }
public:
    void Destory()
    {
        if (_Head == NULL)
        {
            return;
        }
        //先不管_Head和_Tail等全部删完将_Head和_Tail置为NUL
        LinkNode* begin = _Head;
        do{
            LinkNode* del = begin;
            begin = begin->_next;
            delete del;
        } while (begin != _Head);
        _Head = NULL;
        _Tail = NULL;
    }
    void Print()
    {
        //1.没有节点
        //2.多个节点
        if (_Head == NULL)
        {
            return;
        }
        LinkNode *begin = _Head;
        do{
            cout << begin->_data<< "->";
            begin = begin->_next;
        } while (begin != _Head);
        cout<< endl;
    }
    void PushBack(const DataType& x)//尾插
    {//1.没有节点
     //2.有多个节点
        if (_Head == NULL)
        {
            _Head = new LinkNode(x);
            _Tail = _Head;
            _Tail->_next = _Head;
        }
        else
        {
            LinkNode *tmp = new LinkNode(x);
            _Tail->_next = tmp;
            tmp->_next = _Head;
            _Tail = tmp;
        }
    }
    void PopBack()//尾删
    {
        if (_Head == NULL) //没有节点
        {
            cout << "SList is empty" << endl;
            return;
        }
        else if (_Head == _Tail) //有一个节点
        {
            delete _Head;
            _Head = NULL;
            _Tail = NULL;
        }
        else    //有多个节点
        {
            LinkNode *prev = _Head;
            while (prev->_next != _Tail)
            {
                prev = prev->_next;
            } 
            prev->_next = _Head;
            delete _Tail;
            _Tail = prev;
        }
    }

    void PopFront()//头删
    {
        if (_Head == NULL) //没有节点
        {
            cout << "SList is empty" << endl;
            return;
        }
        else if (_Head == _Tail) //有一个节点
        {
            delete _Head;
            _Head = NULL;
            _Tail = NULL;
        }
        else
        {
            LinkNode* del = _Head;
            _Head = _Head->_next;
            delete del;
            _Tail->_next = _Head;
        }
    }

    void PushFront(DataType x)//头插
    {
        if (_Head == NULL)  //没有节点
        {
            _Head = new LinkNode(x);
            _Tail = _Head;
            _Tail->_next = _Head;
        }
        else    //有多个节点
        {
            LinkNode* tmp = new LinkNode(x);
            tmp->_next = _Head;
            _Head = tmp;
            _Tail->_next = _Head;
        }
    }

    LinkNode* Find(DataType x)
    {
        if (_Head == NULL) //没有节点
        {
            cout << "SList is empty" << endl;
            return NULL;
        }
        LinkNode* begin = _Head;
        do{
            if (begin->_data == x)
            {
                cout << "find " << x << endl;
                return begin;
            }
            begin = begin->_next;
        } while (begin != _Head);
        cout << "not find " << x << endl;
        return NULL;
    }

    bool Remove(LinkNode * n)
    {
        assert(n);
        if (_Head == NULL) //没有节点
        {
            cout << "SList is empty" << endl;
            return false;
        }
        if (n == _Head)  //n是头指针
        {
            _Head = _Head->_next;
            delete n;
            _Tail->_next = _Head;
            return true;
        }

        LinkNode* prev = _Head;
        do{
            if (prev->_next == n)  //n是中间指针
            {
                prev->_next = n->_next;
                delete n;
                if (n == _Tail)    //n是尾指针
                {
                    _Tail = prev;
                    _Tail->_next = _Head;
                }
                return true;
            }
            prev = prev->_next;

        } while (prev != _Head);
        return false;
    }
    void Insert(LinkNode * n, DataType x) //先找到节点n，在n后面插一个节点
    {
        assert(n);
        if (_Head == NULL) //没有节点
        {
            cout << "SList is empty" << endl;
            return ;
        }
        LinkNode* begin = _Head;
        do{
            if (begin == n)
            {
                LinkNode* tmp = new LinkNode(x);
                tmp->_next = n->_next;
                n->_next = tmp;
                if (n == _Tail)
                {
                    _Tail = tmp;
                    _Tail->_next = _Head;
                }
                return;
            }
            begin = begin->_next;
        } while (begin != _Head);
        cout << "not find " << n << endl;
    }
    void Reverse()  //翻转
    {
        if (_Head == NULL) //没有节点
        {
            cout << "SList is empty" << endl;
            return;
        }
        if (_Head == _Tail)
        {
            cout << "只有一个节点" << endl;
            return;
        }
        LinkNode* tmp = _Head;
        LinkNode* newhead = tmp, *newtail = tmp;
        do{
            LinkNode* prev = tmp;
            tmp = tmp->_next;
            prev->_next = newhead;
            newhead = prev;
        } while (tmp != _Head);
        newtail->_next = newhead;
        _Head = newhead;
    }
private:
    LinkNode* _Head;
    LinkNode* _Tail;
};

void test()
{
    SList s1;
    s1.PushBack(1);
    s1.PushBack(2);
    s1.PushBack(3);
    s1.Print();
    SList s2 = s1;
    /*s2.PushBack(4);
    s2.PushBack(5);
    s2.PushBack(6);*/
    s2.Print();
    /*s1 = s2;
    s1.Print();*/
    //s1.PopBack();
    //s1.PopBack();
    //s1.PopBack();
    //s1.PopBack(); //没有节点的时候删除
    //s1.Print();
}

void test2()
{
    SList s1;
    s1.PushFront(1);
    s1.PushFront(2);
    s1.PushFront(3);
    s1.Print();
    /*s1.Reverse();
    s1.Print();*/
    LinkNode* node = s1.Find(1); 
    s1.Insert(node, 4);
    /*s1.Remove(node);*/
    s1.Print();
    /*s1.PopFront();
    s1.PopFront();
    s1.PopFront();
    s1.PopFront();
    s1.Find(2);
    s1.Print();*/

}


int main()
{
    test();
    getchar();
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

pat(B) 1011. A+B和C
代码：
#include<cstdio>
#include<iostream>
#include<cstring>
#define LL long long
using namespace std;

int main()
{
	int t;
	scanf("%d",&t);
	LL a,b,c;
	for(int i=1;i<=t;i++)
	{
		scanf("%lld%lld%lld",&a,&b,&c);
		if(a+b>c)
			printf("Case #%d: true\n",i);
		else
			printf("Case #%d: false\n",i);
	}
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

06==函数(头文件,声明,封装)
#include <stdio.h>

练习:



/*
 ******************
 ***                             ***
 ****          ****
 ******************

 

 日历显示
 1~30
 */
int main()
{
    //课程简介
    printf("********************\n");
    printf("***                             ***\n");
    printf("***                             ***\n");
    printf("********************\n");
    //日历
    for(int i=1;i<=30;i++)
    {
        printf("%2d ",i);
        if(i%7==0)
        {
            printf("\n");
        }
    }
}




1:

/*

 函数: 
功能性代码的封装;

 函数的好处

 1:减少了重复代码;

 2:给main函数减负,main函数只确定调用流程;

 3:便于维护,方便阅读,扩展,移植;

 4:方便开发分工;

 */



void print_string()
{
    printf("********************\n");
    printf("<span style="font-size: 14px; font-family: Menlo;"> ***</span><span style="font-family:Heiti SC Light;font-size: 14px;">                             </span><span style="font-family:Menlo;font-size: 14px;">***</span>\n");
    printf("<span style="font-size: 14px; font-family: Menlo;"> ***</span><span style="font-family:Heiti SC Light;font-size: 14px;">                             </span><span style="font-family:Menlo;font-size: 14px;">***</span>\n");
    printf("********************\n");
}
void print_number()
{
    for(int i=1;i<=30;i++)
    {
        printf("%2d ",i);
        if(i%7==0)
        {
            printf("\n");
        }
    }
}
int main()
{
    print_string();
    print_number();
    return 0;
}





2:

/*

 如何定义函数:

 

 返回值类型 
函数名(参数列表)

 {

    //函数语句,函数体;函数体可以只有return语句,可以先写接口,调试过再写实现;

 }

 

 返回值类型

  返回关键字 return
语句可以有多条,但是以执行到的第一句为准;

 

 void 空类型,表示没什么东西返回;在调用函数的时候,不能用任何类型的数据来接受函数的返回值;

 

 int类型,或其他数据类型:return表达式的类型要和返回值类型保持一致;调用函数的时候定义的接收变量类型三者保持一致;

 

 函数名:要有意义(名字和干的事情相符合),符合标示符的定义;

 

 参数列表:可以有多个参数,也可以没有参数;

 (类型1 
形参1,类型2 
形参2,...)

 */


void print_number_count(int n)
{
    for(int i=1;i<=n;i++)
    {
        printf("%2d ",i);
        if(i%7==0)
        {
            printf("\n");
        }
    }
}

//增加参数,可以增加代码的扩展性;
void print_string()
{
    printf("********************\n");
    printf("****千锋是个好学校****\n");
    printf("*****IOS  有前途*****\n");
    printf("********************\n");
    return  ;//void类型的函数,return 语句可以省略;
}
int add(int a,int b)
{
    return a+b;
}
int main()
{
    int x=10,y=20,sum;
    sum = add(x,y);
    print_string();
    printf("sum = %d\n",sum);
    print_number_count(28);
    add(x,y);//可以不用其他数据来接收返回值;函数调用会发生;
    return 0;
}





3:

//函数执行过程

/*

 1:给形参分配空间;

 2:实参给形参赋值;

 3:形参参与运算;

 4:函数返回时,形参要销毁;

 */


int add(int a,int b)//形式参数;并没有自己的空间和内存;
{
    return a+b;
}
//下面的函数不能完成交换,交换的是形参,形参返回时被销毁;
void swap(int a,int b)
{
    int temp =a;
    a = b;
    b = temp;
}
int main()
{
    int x=10,y=20;//实际参数;有确定的值和类型;
    int sum;
    sum = add(x,y);
    printf("sum = %d\n",sum);
    swap(x,y);
    printf("x=%d,y=%d",x,y);
    return 0;
}



//练习:是否是闰年,(只能被4正处,但是不能被100整除,或者能被400整除)



/*函数名:

 参数:入参,和出参
 更能:

 注意点:
 ...
 */


int isLeapYear(int year)
{
    if (((year%4==0) || (year%400 == 0))
        && (year%100 != 0))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
int main()
{
    int n;
    printf("请输入年份:\n");
    scanf("%d",&n);
    if(isLeapYear(n))
    {
        printf("%d是闰年",n);
    }
    else
    {
        printf("%d不是闰年",n);
    }
    return 0;
}





4:

/*

 函数在使用过程中注意点:

 1:函数的功能要单一

 2:命名要有意义

 3:参数要精简

 4:函数要合理注释

 */



/*
 main函数的2中写法;
 return 0;最好写一下,编程的规范性;
 */


int main(int argc,const char *argv[])
{
    return 0;
}

int main()
{
    return 0;
}








5:

/*

 变量的作用域

 局部变量和全局变量

 局部变量:定义在代码块中的变量叫局部变量,生命周期从定义开始,到定义所在的}结束;

 全部变量:不定义在{}里的变量;在编译的时候就存储了,全局都能用;能实现资源共享,但是很容易被其他函数修改;

 */




int add(int a,int b)
{
    return a+b;
}
int main()
{
    int x=10,y=20,sum;
    sum = add(x,y);
    printf("sum = %d\n",sum);
    for(int i=0;i<4;i++)//在循环中定义的局部变量i,出循环不能访问;
    {
        printf("hello~\n");
    }
    {
        int c=100;
        printf("c = %d\n",c);//c = 100
    }
//    printf("c = %d\n",c);//不能访问;
    {
        int x=1000;
        printf("x = %d\n",x);//访问代码块里面的内容  x = 1000
    }//当遇到}里面定义的变量销毁;
    return 0;
}




int gClassId = 1518;
int getId();//函数生命
int main()
{
    printf("id = %d\n",gClassId);
    getId();
    return 0;
}
int getId()
{
    return gClassId;
}











二:函数头文件






//

//  main.c

//四则运算,+,-,*,///可以将功能封装在main函数之外的.c文件里

#include <stdio.h>

#include "calculator.h”//调用函数声明的头文件









1:

/*

 如何声明:

 返回值类型 
函数名(形参的类型列表);//形参可以只写类型,形参名只是参考文档;

 */


int main(int argc, const char * argv[]) {

    int rst1,rst2,rst3,rst4;
    rst1 = add(10,20);
    rst2 = sub(21,10);
    rst3 = mul(32,5);
    rst4 = divl(32,2);
    
    printf("add 10,20,rst=%d\n",rst1);
    printf("sub 21,20,rst=%d\n",rst2);
    printf("mul 32,5,rst=%d\n",rst3);
    printf("divl 32,2,rst=%d\n",rst4);
    gClassId = 100;//访问其他.c定义的全局变量;
    return 0;
}







//

//  calculator.c//封装功能文件



#include "calculator.h"
int gClassId = 1518;//全局变量

int add(int a,int b)
{
    return a+b;
}

int sub(int a,int b)
{
    return a-b;
}

int mul(int a,int b)
{
    return a*b;
}

int divl(int a,int b)
{
    return a/b;
}




//

//  calculator.h//函数声明头文件




#ifndef _CALCULATOR_H_
//#ifndef:预编译指令,条件编译指令.如果没有定义这个头文件,那么就会执行#define到#endif;如果已经定义,就不会编译这个头文件;防止头文件重复包含引入的问题;
#define _CALCULATOR_H_

#include <stdio.h>
//extern 外部的,用来声明函数和变量,在声明函数的时候可以省略;声明变量的时候不可以省略
extern int add(int ,int );
int sub(int a,int b);
int mul(int a,int b);
int divl(int a,int b);
extern int gClassId;//声明了一个全局变量,
#endif /* defined(_CALCULATOR_H_) */




版权声明：本文为博主原创文章，未经博主允许不得转载。

HDC、CDC、CWindowDC、CClientDC……
DC（DeviceContex）叫做设备环境或设备描述表、设备上下文，是MFC绘图的基础。 
经常用到的有CDC、CWindowDC、CClientDC、CPaintDC、CMetaFileDC还有HDC。
一、HDC与CDC的区别和联系 
首先要明确HDC是资源句柄，其他都是MFC的类。HDC和CDC的关系与HWnd和CWnd的关系类似，CWnd中有一个HWnd类型的成员变量m_hWnd，同样CDC中有一个HDC类型的成员变量m_hDC。
二、CDC、CWindowDC、CClientDC、CPaintDC、CMetaFileDC的关系 
查阅MFC Hierarchy Chart可以看到CWindowDC、CClientDC、CPaintDC和CMetaDC都是由CDC派生得到的。
CDC： Object provides member functions for working with a device context, such as a display or printer, as well as members for working with a display context associated with the client area of a window.
CClientDC：Device context associated with a CClientDC object is the client area of a window.
CWindowDC：CWindowDC object accesses the entire screen area of a CWnd (both client and nonclient areas).
CPaintDC：A CPaintDC object can only be used when responding to a WM_PAINT message, usually in your OnPaint message-handler member function.
CMetaFileDC : Implements a Windows metafile, which contains a sequence of graphics device interface (GDI) commands that you can replay to create a desired image or text.
CPaintDC只能在WM_PAINT消息响应中使用，CMetaFileDC包含了一序列图形设备接口(GDI)命令，可以用来创建需要的图像或文本。 
CDC、CClientDC和CWindowDC最容易混淆，下面具体区分一下这三者之间的异同。
三、CDC、CClientDC和CWindowDC的使用——客户区与非客户区
以vs2010编辑器为例，图中蓝色部分为窗体框架的客户区，蓝色的部分外侧为窗体框架的非客户区（包括程序图标，标题栏，菜单，最大最小，关闭按纽和状态栏）；图中绿色部分为文档视图的客户区，绿色部分外侧为文档视图的 非客户区（包括文件图标，标题栏和两个滚动条）。 

弄清楚了窗体的客户区和非客户区，CDC、CClientDC和CWindowDC三者的使用就很简单了，CDC适用于显示设备或窗体客户区；CClientDC只能用于窗体客户区；CWindowDC适用于CWnd整个窗口。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

PHPExcel生成图表
PHPExcel下载
自带的例子：




生成折线图示例：
<?php
	$dir = dirname(__FILE__);
	require $dir."/db.php";
	require $dir."/PHPExcel.php";

	$db = new db($phpexcel);
	$objPHPExcel = new PHPExcel();
	$objSheet = $objPHPExcel->getActiveSheet();

	$data = array(
		array("","一班","二班","三班"),
		array("不及格",20,30,40),
		array("良好",30,50,70),
		array("优秀",14,12,30)
	);
	$objSheet->fromArray($data);

	//图表
	$labels = array(
		new PHPExcel_Chart_DataSeriesValues('String','Worksheet!$B$1',null,1),//一班
		new PHPExcel_Chart_DataSeriesValues('String','Worksheet!$C$1',null,1),//二班
		new PHPExcel_Chart_DataSeriesValues('String','Worksheet!$D$1',null,1),//三班
	);
	$xLabels = array(
		new PHPExcel_Chart_DataSeriesValues('String','Worksheet!$A$2:$A$4',null,3),//取x轴刻度
	);
	$datas = array(
		new PHPExcel_Chart_DataSeriesValues('Number','Worksheet!$B$2:$B$4',null,3),//取一班数据
		new PHPExcel_Chart_DataSeriesValues('Number','Worksheet!$C$2:$C$4',null,3),//取二班数据
		new PHPExcel_Chart_DataSeriesValues('Number','Worksheet!$D$2:$D$4',null,3),//取三班数据
	);

	$series = array(
		new PHPExcel_Chart_DataSeries(
			PHPExcel_Chart_DataSeries::TYPE_LINECHART,
			PHPExcel_Chart_DataSeries::GROUPING_STANDARD,
			range(0, count($labels)-1),
			$labels,
			$xLabels,
			$datas
		)
	); //图表框架

	$layout=new PHPExcel_Chart_Layout();
	$layout->setShowVal(true);
	$areas = new PHPExcel_Chart_PlotArea($layout,$series);
	$legend = new PHPExcel_Chart_Legend(PHPExcel_Chart_Legend::POSITION_RIGHT,$layout,false);
	$title = new PHPExcel_Chart_Title("高一学生成绩分布");
	$ytitle = new PHPExcel_Chart_Title("人数");
	$chart = new PHPExcel_Chart('line_chart',$title,$legend,$areas,true,false,null,$ytitle);
	$chart->setTopLeftPosition("A7")->setBottomRightPosition("K25"); //图表位置

	$objSheet->addChart($chart);


	$excel = 'Excel2007';
	$objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel,$excel);
	$objWriter->setIncludeCharts(true); //图表必须
	// $objWriter->save($dir.'/export.xls'); //生成excel文件
	browser_export($excel,"browser_chart.xlsx"); //浏览器输出

	SaveViaTempFile($objWriter);

	function browser_export($type, $filename){
		if($type == "Excel5"){
			header('Content-Type: application/vnd.ms-excel'); //excel2003
		}else{
			header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); //excel2007
		}
		header('Content-Disposition: attachment;filename="'.$filename.'"');
		header('Cache-Control: max-age=0');
	}

	/*解决Excel2007不能导出*/
	function SaveViaTempFile($objWriter){
	    $filePath = dirname(__FILE__) . rand(0, getrandmax()) . rand(0, getrandmax()) . ".tmp";
	    $objWriter->save($filePath);
	    readfile($filePath);
	    unlink($filePath);
	}
		

	



效果图：

参考文章：
PHPExcel 
PHPExcel+MySQL 
PHPExcel样式



版权声明：本文为博主原创文章，未经博主允许不得转载。

归并排序，树状数组 两种方法求逆序对

我们知道,求逆序对最典型的方法就是树状数组，但是还有一种方法就是Merge_sort(),即归并排序。




实际上归并排序的交换次数就是这个数组的逆序对个数，为什么呢？




我们可以这样考虑：




归并排序是将数列a[l,h]分成两半a[l,mid]和a[mid+1,h]分别进行归并排序，然后再将这两半合并起来。

在合并的过程中（设l<=i<=mid，mid+1<=j<=h），当a[i]<=a[j]时，并不产生逆序数；当a[i]>a[j]时，在

前半部分中比a[i]大的数都比a[j]大，将a[j]放在a[i]前面的话，逆序数要加上mid+1-i。因此，可以在归并

排序中的合并过程中计算逆序数.




题目:http://poj.org/problem?id=1804




题意:给定一个序列a[],每次只允许交换相邻两个数,最少要交换多少次才能把它变成非递降序列.


#include <iostream>
#include <string.h>
#include <stdio.h>

using namespace std;
const int N = 1005;

int a[N],tmp[N];
int ans;

void Merge(int l,int m,int r)
{
    int i = l;
    int j = m + 1;
    int k = l;
    while(i <= m && j <= r)
    {
        if(a[i] > a[j])
        {
            tmp[k++] = a[j++];
            ans += m - i + 1;
        }
        else
        {
            tmp[k++] = a[i++];
        }
    }
    while(i <= m) tmp[k++] = a[i++];
    while(j <= r) tmp[k++] = a[j++];
    for(int i=l;i<=r;i++)
        a[i] = tmp[i];
}

void Merge_sort(int l,int r)
{
    if(l < r)
    {
        int m = (l + r) >> 1;
        Merge_sort(l,m);
        Merge_sort(m+1,r);
        Merge(l,m,r);
    }
}

int main()
{
    int n,T,tt=1;
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        for(int i=0;i<n;i++)
            scanf("%d",&a[i]);
        ans = 0;
        Merge_sort(0,n-1);
        printf("Scenario #%d:\n%d\n\n",tt++,ans);
    }
    return 0;
}


树状数组求逆序：


http://poj.org/problem?id=2299


思路: 离散化+树状数组
分析:
1 题目的意思就是要求逆序数对
2 题目的输入个数有500000的规模但是每个数的最大值为999999999，因此我们需要离散化这些数据
3 对于数据9 1 0 5 4我们离散化成5 2 1 4 3
那么对于输入一个树a[i]我们去求一下它的离散化后的id，然后去求前面比这个id大的个数
4 由于getSum(x)函数的求和是求[1,x]而不是[x，MAXN),所以我们可以换成求小于等于id的个数即getSum(id),然后i-1-getSum(id)就是比id大的个数，最后在更新一下treeNum[id]

代码:


#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

const int MAXN = 500010;

int n;
int tmpNum[MAXN] , num[MAXN];
int treeNum[MAXN];

int lowbit(int x){
    return x&(-x);
}

int getSum(int x){
    int sum = 0;
    while(x){
        sum += treeNum[x];
        x -= lowbit(x);
    }
    return sum;
}

void add(int x , int val){
    while(x < MAXN){
         treeNum[x] += val;
         x += lowbit(x);
    }
}

long long solve(){
    long long ans = 0;
    memcpy(tmpNum , num , sizeof(num));
    memset(treeNum , 0 , sizeof(treeNum));
    sort(num+1 , num+1+n);
    int len = unique(num+1 , num+1+n)-(num+1);
    for(int i = 1 ; i <= n ; i++){
        int id = lower_bound(num+1 , num+1+n,tmpNum[i])-num;
        ans += i-getSum(id)-1;
        add(id , 1);
    }
    return ans;
}

int main(){
    while(scanf("%d" , &n) && n){
         for(int i = 1 ; i <= n ; i++)
             scanf("%d" , &num[i]);
         printf("%lld\n" , solve());
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

LeetCode263——Ugly Number

Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
 For example, 6, 8 are ugly while 14 is
 not ugly since it includes another prime factor 7.

Note that 1 is typically treated as an ugly number.

实现：

class Solution {
public:
    bool isUgly(int num) {
        if (num == 0) return false;
        if (num == 1) return true;
        if (num % 2 == 0) return isUgly(num/2);
        else if (num % 3 == 0) return isUgly(num/3);
        else if (num % 5 == 0) return isUgly(num/5);
        return false;
    }
};


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 4135-Co-prime(容斥求区间内与N互质的个数(队列||位运算))
题目地址：HDU 4135 
题意：求[A,B]区间内与N互质的数的个数。 
思路：我们可以用容斥计算出[1,B]之间和[1,A-1]之间的与N互质的数，然后相减即可。然后我们用一种快速的方法求出[1,X]之间的与N互质的数，首先我们求出N的质因子，[1,X]之间与N的质因子成倍数关系的数肯定与N不成互质关系。 
Eg：X=12,N=30 ,N的质因子为2,3,5。 
(2,4,6,8,10)->X/2  6个； 
(3,6,9,12)->X/3  4个； 
(5,10)->X/5 ； 
然后根据容斥原理X/2+X/3+X/5-X/(2*3)-X/(2*5)-X/(3*5)+X/(2*3*5)。 
方法一：
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <bitset>
using namespace std;
typedef __int64 LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
using namespace std;
const int Maxn=2*1e5+10;
LL prime[Maxn];
LL sprime[Maxn];
bitset<Maxn>pri;
LL k,cnt;
void is_prime()
{
    pri.set();
    for(LL i=2; i<Maxn; i++) {
        if(pri[i]) {
            prime[k++]=i;
            for(LL j=i+i; j<Maxn; j+=i)
                pri[j]=0;
        }
    }
}
void Divide(LL n)//分解质因子
{
    cnt=0;
    LL t=(LL)sqrt(1.0*n);
    for(LL i=0; prime[i]<=t; i++) {
        if(n%prime[i]==0) {
            sprime[cnt++]=prime[i];
            while(n%prime[i]==0)
                n/=prime[i];
        }
    }
    if(n>1)
        sprime[cnt++]=n;
}
LL Ex(LL n)//容斥原理之队列实现
{
    LL q[Maxn];
    LL sum=0;
    LL t=1;
    q[0]=-1;
    for(LL i=0; i<cnt; i++) {
        LL x=t;
        for(LL j=0; j<x; j++){
            q[t]=q[j]*sprime[i]*(-1);
            t++;
        }
    }
    for(LL i=1; i<t; i++)
        sum+=n/q[i];
    return sum;
}
int main()
{
    int T;
    int icase=1;
    LL A,B,N;
    LL res;
    is_prime();
    scanf("%d",&T);
        while(T--) {
            scanf("%I64d %I64d %I64d",&A,&B,&N);
            Divide(N);
            res=(B-Ex(B))-(A-1-Ex(A-1));
            printf("Case #%d: ",icase++);
            printf("%I64d\n",res);
        }
    return 0;
}

方法二： 
对于X=12,N=30来说，N的质因子为2,3,5。如果用”0”,”1”标记2,3,5。为”1”时需要，为”0”时不需要，那么，二进制数010,011，······，111，刚好对应上式中的2,3,5在除数中出现的情况。
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <bitset>
using namespace std;
typedef __int64 LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
using namespace std;
const int Maxn=1e5+10;
LL prime[Maxn];
LL sprime[Maxn];
bitset<Maxn>pri;
LL k,cnt;
void is_prime()
{
    pri.set();
    for(LL i=2; i<Maxn; i++) {
        if(pri[i]) {
            prime[k++]=i;
            for(LL j=i+i; j<Maxn; j+=i)
                pri[j]=0;
        }
    }
}
void Divide(LL n)//分解质因子
{
    cnt=0;
    LL t=(LL)sqrt(1.0*n);
    for(LL i=0; prime[i]<=t; i++) {
        if(n%prime[i]==0) {
            sprime[cnt++]=prime[i];
            while(n%prime[i]==0)
                n/=prime[i];
        }
    }
    if(n>1)
        sprime[cnt++]=n;
}
/*
1<<n是将1向前推动n位,例如n=5,那么1<<5=100000,i<(1<<5)的话就是在[00001,11111]中选择
i&j是只有对应位都为1的时候才是1,例如101和001的结果为001.
*/
LL Ex(LL n)
{
    LL ans=0;
    LL tmp,flag;
    LL i,j;
    for(i=1;i<(LL)(1<<cnt);i++)
    {
        tmp=1;
        flag=0;
        for(j=0;j<cnt;j++)
            if(i&((LL)(1<<j))){//这个就可以代表用了第几个
                flag++;
                tmp*=sprime[j];
            }
        if(flag&1)
            ans+=n/tmp;
        else
            ans-=n/tmp;
    }
    return ans;
}
int main()
{
    int T;
    int icase=1;
    LL A,B,N;
    LL res;
    is_prime();
    scanf("%d",&T);
        while(T--) {
            scanf("%I64d %I64d %I64d",&A,&B,&N);
            Divide(N);
            res=(B-Ex(B))-(A-1-Ex(A-1));
            printf("Case #%d: ",icase++);
            printf("%I64d\n",res);
        }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        安贫乐道
家徒四壁发奋读圣贤书颜回高风，不亦乐乎？
鹏程万里立志建大同世孔圣情怀，皆大欢喜！



版权声明：本文为博主原创文章，未经博主允许不得转载。

C++ 将string转换成char*字符串
我们经常会使用C和C++的混合编程，在某些情况下，需要将C++的string，转换成char* 的字符串。下面说两种可行的方法，作为总结。
1. data();
如：
string str="abc";
char*p=(char*)str.data();
2.c_str();
如：
string str="adcd";
char *p=(char*)str.c_str();
暂时就记这两种吧，简单而且差不多够用了。



版权声明：本文为博主原创文章，未经博主允许不得转载。

PHPExcel样式控制
使用PHPExcel导出文件
PHPExcel导出mysql数据库数据

以上文章作为参考
下面是PHPExcel样式设置的代码：
<span style="font-size:24px;"><?php
	$dir = dirname(__FILE__);
	require $dir."/db.php";
	require $dir."/PHPExcel.php";

	$db = new db($phpexcel);
	$objPHPExcel = new PHPExcel();

	for($i=0; $i<3; $i++){
		if($i>0){
			$objPHPExcel->createSheet();
		}
		$objPHPExcel->setActiveSheetIndex($i);
		$objSheet = $objPHPExcel->getActiveSheet();
		$objSheet->getColumnDimension('D')->setWidth(21); //设置列宽
		$objSheet->getColumnDimension('E')->setWidth(16);
		$objSheet->getColumnDimension('F')->setWidth(21);
		$objSheet->getRowDimension('1')->setRowHeight(80); //设置行高
		$objSheet->getRowDimension('2')->setRowHeight(29);
		$objSheet->getDefaultStyle()->getAlignment()->setVertical(PHPExcel_Style_Alignment::VERTICAL_CENTER)
							->setHorizontal(PHPExcel_Style_Alignment::HORIZONTAL_CENTER);
													//设置水平垂直居中
		$objSheet->getDefaultStyle()->getFont()->setName("微软雅黑")->setSize(12); //设置默认字体大小
		$objSheet->getStyle("A1:F1")->getFont()->setSize(20)->setBold(true); //标题字体
		$objSheet->getStyle('A1:F1')->getFill()->setFillType(PHPExcel_Style_Fill::FILL_SOLID)
						->getStartColor()->setARGB('FFFF0000'); //设置标题背景颜色
		$objSheet->getStyle("A1:F1")->applyFromArray(getBorderStyle("#66FF99")); //设置标题边框

		$data = $db->getUserinfo();

		$j = 1;
		$objSheet->setCellValue("A".$j,"****\n****");
		$objSheet->getStyle('A1')->getAlignment()->setWrapText(true); //设置换行
		$objSheet->mergeCells("A".$j.":F".$j); //合并单元格

		$j++;
		$objSheet->setCellValue("A".$j,"编号")->setCellValue("B".$j,"登陆名")
				->setCellValue("C".$j,"昵称")->setCellValue("D".$j,"电子邮箱")
				->setCellValue("E".$j,"学校")->setCellValue("F".$j,"最后登陆时间")
				->setCellValue("G".$j,"随机数");

		$j++;
		foreach ($data as $key => $value) {
			# code...
			$objSheet->setCellValue("A".$j,$value['id'])->setCellValue("B".$j,$value['user_login'])
					->setCellValue("C".$j,$value['user_nicename'])->setCellValue("D".$j,$value['user_email'])
					->setCellValue("E".$j,$value['sch_name'])->setCellValue("F".$j,$value['last_login_time'])
					//显示数字的方法 1.指定为字符串 2.设置格式
					//->setCellValueExplicit("G".$j,rand(1000000000,9999999999),PHPExcel_Cell_DataType::TYPE_STRING);
					->setCellValue("G".$j,rand(100000000,999999999)); //下面以文本格式显示数字
			$objSheet->getStyle('G'.$j)->getNumberFormat()->setFormatCode(PHPExcel_Style_NumberFormat::FORMAT_TEXT);

			$j++;
		}
	}

	$objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel,"Excel5");
	// $objWriter->save($dir.'/export.xls'); //生成excel文件
	browser_export("Excel5","browser_excel03.xls"); //浏览器输出
	$objWriter->save("php://output");

	function browser_export($type, $filename){
		if($type == "Excel5"){
			header('Content-Type: application/vnd.ms-excel'); //excel2003
		}else{
			header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); //excel2007
		}
		header('Content-Disposition: attachment;filename="'.$filename.'"');
		header('Cache-Control: max-age=0');
	}


	/*
	*获得不同颜色的边框
	*/
	function getBorderStyle($color){
		$styleArray = array(
			'borders' => array(
				'outline' => array(
					'style' => PHPExcel_Style_Border::BORDER_THICK,
					'color' => array('rgb' => $color),
				),
			),
		);
		return $styleArray;
	}

	

	
</span>




PHPExcel样式函数可以参考编程文档


比如我们上面用到的数字格式显示：


Ctrl + 鼠标左键打开


代码都以写好，我们只要用就行了，还是很方便的，文档里面有所有的设置函数，需要的时候可以在里面查找。

版权声明：本文为博主原创文章，未经博主允许不得转载。

进程间通讯的方法
1.使用共享内存
代码如下：


[cpp] 
view plaincopy


void FileMapping(void)  {      //打开共享的文件对象。      m_hMapFile = ::OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE,_T("TestFileMap"));      if (m_hMapFile)      {          //显示共享的文件数据。          LPTSTR lpMapAddr = (LPTSTR)MapViewOfFile(m_hMapFile,FILE_MAP_ALL_ACCESS,0,0,0);          OutputDebugString(lpMapAddr);      }      else      {          //创建共享文件。          m_hMapFile = ::CreateFileMapping((HANDLE)0xFFFFFFFF, NULL, PAGE_READWRITE, 0, 1024, "TestFileMap");          //拷贝数据到共享文件里。          LPTSTR lpMapAddr = (LPTSTR)MapViewOfFile(m_hMapFile,FILE_MAP_ALL_ACCESS,0,0,0);                    StrCpy(lpMapAddr,"TestFileMap");          FlushViewOfFile(lpMapAddr,12+1);      }  }  

注意：使用完成共享内存后，要删除共享内存，否则会生成很多临时文件。
UnmapViewOfFile(m_hMapFile)
2.使用dll在进程间共享内存
#pragma data_seg (".IdleUI")  // you must define as SHARED in .def
HHOOK g_hHookKbd = NULL;        // one instance for all processes
HHOOK g_hHookMouse = NULL;        // one instance for all processes
DWORD    g_dwLastInputTick = 0;    // tick time of last input event
#pragma data_seg ()
然后在def文件中定义：SECTIONS         .IdleUI READ WRITE SHARED
注意：共享数据必须初始化，否则微软编译器会把没有初始化的数据放到.BSS段中，从而导致多个进程之间的共享行为失败。
3.使用WM_COPYDATA在窗体程序间传递消息。
 
发送的时候的代码如下：WM_COPYDATA消息主要目的是允许在进程间传递只读数据。SDK文档推荐用户使用SendMessage函数，接受方在数据拷贝完成前不返回，这样发送方就不可能删除和修改数据：


[cpp] 
view plaincopy


HWND hWnd=::FindWindow(NULL,"b");  if(hWnd!=NULL)     {         COPYDATASTRUCT   cpd;   /*给COPYDATASTRUCT结构赋值*/         cpd.dwData   =   0;               cpd.cbData   =   strlen("字符串");               cpd.lpData   =   (void*)"字符串";                ::SendMessage(hWnd,WM_COPYDATA,NULL,(LPARAM)&cpd);//发送！           }  

接收的时候：
afx_msg BOOL OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct);
 

BOOL CMyDlg::OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct) 
{
    // TODO: Add your message handler code here and/or call default
    AfxMessageBox((LPCSTR)(pCopyDataStruct->lpData));/*利用对话框表示收到消息*/  
    return CDialog::OnCopyData(pWnd, pCopyDataStruct);
}
 
4.调用ReadProcessMemory以及WriteProcessMemory函数.

  调用ReadProcessMemory以及WriteProcessMemory函数用户在发送进程中分配一块内存存放数据，调用GlobalAlloc或VirtualAlloc函数实现：

pApp->m_hGlobalHandle=GlobalAlloc(GMEM_SHARE,1024); 
可以得到指针地址： 
pApp->mpszGlobalHandlePtr=(LPSTR)GlobalLock 
(pApp->m_hGlobalHandle); 
在接收进程中要用到用户希望影响的进程的打开句柄。为了读写另一进程，按如下方式调用OpenProcess函数： 
HANDLE hTargetProcess=OpenProcess( 
      STANDARD_RIGHTS_REQUIRED| 
      PROCESS_VM_REDA| 
      PROCESS_VM_WRITE| 
      PROCESS_VM_OPERATION,//访问权限 
      FALSE,//继承关系 
     dwProcessID);//进程ID 
为保证OpenProcess函数调用成功，用户所影响的进程必须由上述标志创建。 
用户获得一个进程的有效句柄，就可调用ReadProcessMemory函数读取该进程的内存： 
BOOL ReadProcessMemory( 
             HANDLE hProcess,    // 进程指针 
             LPCVOID lpBaseAddress,    // 数据块的首地址 
             LPVOID lpBuffer,    // 读取数据所需缓冲区 
            DWORD cbRead,    // 要读取的字节数 
            LPDWORD lpNumberOfBytesRead     
); 
   使用同样的句柄也可以写入该进程的内存： 
BOOL WriteProcessMemory( 
           HANDLE hProcess,    // 进程指针 
           LPVOID lpBaseAddress,    // 要写入的首地址 
           LPVOID lpBuffer,    // 缓冲区地址 
           DWORD cbWrite,    // 要写的字节数 
           LPDWORD lpNumberOfBytesWritten 
    );   


版权声明：本文为博主原创文章，未经博主允许不得转载。

ABAP inner join 性能影响
业务背景：
ERP系统中有一个程序ZPPR0002,每次对MES系统发布ERP里的生产订单。 
生产订单数据里面，包含有BOM组件，即组成成品车的1500条物料信息。


症状：
近日，业务人员反馈生产订单传输慢，一个订单要2分钟时间，一天80个订单，做完传输要几个小时。
 
原因：
通过SE30调试，发现程序90%的时间花费在一条inner join语句上。
该语句的作用是，查找3个字段的信息，放到每一个物料信息中。

程序对1500条物料做1500次查询，填充3个字段的信息。


解决办法：

原来一条inner join语句，最后的结果是得到一条STPO的数据，这给拆分该语句留下了空间。
既然最后结果只是为了得到一条数据，inner join 连接2张表的查询就应该可以分开成2次select single.
          
            "原来的代码 一条语句

            SELECT SINGLE A~POTX1 A~POTX2 A~SORTF INTO (GS_STPO-POTX1,GS_STPO-POTX2,GS_STPO-SORTF) FROM STPO  AS A
            INNER JOIN  RESB AS B ON A~STLNR = B~STLNR AND A~STLKN = B~STLKN AND A~STPOZ = B~STPOZ
            WHERE B~RSNUM = '0000009884'
            AND B~RSPOS = '0001'.
 
 
 
 


            "修改后的代码，两条语句

            SELECT SINGLE STLNR STLKN STPOZ INTO (GS_RESB-STLNR,GS_RESB-STLKN,GS_RESB-STPOZ)
            FROM RESB
            WHERE RSNUM = '0000009884'
            AND RSPOS = '0001'.

            SELECT SINGLE POTX1 POTX2 SORTF INTO (GS_STPO-POTX1,GS_STPO-POTX2,GS_STPO-SORTF)
            FROM STPO
            WHERE  STLNR = GS_RESB-STLNR AND STLKN = GS_RESB-STLKN AND STPOZ = GS_RESB-STPOZ.



把修改前和修改后的代码都跑一跑，性能差别很大，新代码几乎不花时间。下图中 红色是原代码时间，绿色是新代码时间。



结果：
修改后用户使用，74个订单传输，原来要几个小时，现在半个小时内干完。。。



版权声明：本文为博主原创文章，未经博主允许不得转载。

poj 1562 DFS+枚举
Oil Deposits




Time Limit: 1000MS
 
Memory Limit: 10000K


Total Submissions: 14611
 
Accepted: 7961




Description
The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square
 plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be
 quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.
Input
The input contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 <= m <= 100 and
 1 <= n <= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either `*', representing the absence of oil, or `@', representing an oil pocket.


Output
are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.
Sample Input
1 1
*
3 5
*@*@*
**@**
*@*@*
1 8
@@****@*
5 5 
****@
*@@*@
*@**@
@@@*@
@@**@
0 0
Sample Output
0
1
2
2

Source   //DFS主要是用于全部遍历方面,  用BFS求最小值比较好.
Mid-Central USA 1997
题意叫求有几个连续的大油田


#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#define INF 0x3f3f3f3f

using namespace std;

int n,m;
char a[200][200];
int dx[]={-1,0,1,0,-1,-1,1,1};
int dy[]={0,-1,0,1,1,-1,-1,1};
int panduan(int x,int y)
{
	if(x<n&&y<m&&x>=0&&y>=0&&a[x][y]=='@')
		return 1;
	return 0;
}
int DFS(int x,int y)
{
	if(!panduan(x,y))
		return 0;
	a[x][y]='*';    //将走过的点全部的变为非油田.
	for(int i=0;i<8;i++)
	{
		int fx=dx[i]+x;
		int fy=dy[i]+y;
		if(panduan(fx,fy))
		 DFS(fx,fy);
	}
}
int main()
{
	while(~scanf("%d%d",&n,&m))
	{
		if(!n&&!m)  break;
		for(int i=0;i<n;i++)
		{
			scanf("%s",a[i]);
		}
		int num=0;
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
		{
			if(a[i][j]=='@')//看有几个连续的部分
			{
				DFS(i,j);
				num++;
			}
		}
		printf("%d\n",num);
	}
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

再谈面向对象--【J2SE】


  面向对象总结 V1.0     2014.9.14








  面向对象总结V2.0   2015.8.14








        对比之前的J2SE总结，发现如今的似乎更加的注重联系，开始能把细节的东西都编制到知识网络里面，导图的图片真的很赏心悦目。





版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题13——在O（1）删除链表节点
题目要求：给定单向链表的头指针和一个节点指针，定义一个函数在O（1）时间删除该节点。其中，链表节点与函数的定义如下：

package offer;

public class ListNode
{
	int val;
	ListNode next;
	ListNode(int x)
	{
		val=x;
	}
}

分析：在单向链表中删除一个节点，最常规的做法无疑是从链表的头结点开始，顺序遍历查找要删除的节点，并在链表中删除该节点，在下图（1）中，我们想删除链表i，可以从链表的头节点a开始顺序遍历，发现节点h的next节点指向要删除的节点i，于是我们可以把节点h的next指向i的下一个节点，即节点j，指针调整之后，我们就可以安全的删除节点i并保证链表没有断开（如（2）所示），这个思路由于需要顺序查找，时间复杂度自然就是O（1）






继续分析：那怎样才能实现时间复杂度是O（1）的算法呢，我们发现要删除节点i，可以先把i的下一节点j的内容复制到i上，然后把i的指针指向节点j的下一个节点。此时再删除节点j，其效果刚好是把节点i给删除了（如图（3）所示）
注意：如果链表中只有一个节点，而我们又要删除链表的头节点（也是尾节点），此时我们在删除节点之后，还需要把链表的头节点设置为null
代码如下：

package offer;

public class delete_SelectedNode
{
	public void DeleteNode(ListNode head,ListNode pToBeDeleted)
	{
		if (head==null||pToBeDeleted==null)
		{
			return;
		}
		//要删除的节点不是尾节点
		if (pToBeDeleted.next!=null)
		{
			//pNext指向pToBeDeleted下一节点
			ListNode pNext=pToBeDeleted.next;
			//复制pNext到pToBeDeleted
			pToBeDeleted.val=pNext.val;
			//删除pNext，等效删除pToBeDeleted，等效指针操作
			pToBeDeleted.next=pNext.next;
			pNext=null;
		}
		//当删除为头指针时
		else if (pToBeDeleted==head)
		{
			pToBeDeleted=null;
			head=null;
		}
		//当链表有多个节点，删除尾节点
		else 
		{
			ListNode pNode=head;
			while (pNode.next!=pToBeDeleted)
			{
				pNode=pNode.next;
			}
			pNode.next=null;
			pToBeDeleted=null;
			
		}
	}
}
时间复杂度分析：对于n-1个非尾节点而言，我们可以再O（1）时把下一个节点的内存复制覆盖要删除的节点，并删除下一个节点，对于尾节点而言，由于仍然需要顺序查找，时间复杂度是O（n），因此中的平均时间复杂度是[（n-1）*O（1）+O（n）]/n，结果还是O（1），符合题意







版权声明：本文为博主原创文章，未经博主允许不得转载。

.net 异步编程小结
.net 异步编程小结
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Test
{
    public class MyMain
    {
        public delegate void Show();
        public delegate int Get(int key);


        /// <summary>
        /// .net4.5之前实现异步编程的四种方式(用BeginInvoke和EndInvoke实现)
        /// </summary>
        /// BeginInvoke 返回值可以判断异步是否执行完毕， 后两个参数第一个为回调方法，第二个为调用委托本身，前面的参数为调用委托的参数
        /// EndInvoke   返回值为调用委托的返回值
        static void show1()
        {
            Console.WriteLine("异步执行开始...");
            for (int i = 0; i < 200; i++)
            {
                Console.WriteLine(i);
            }
            Console.WriteLine("异步执行完毕...");
        }
        static int get(int key)
        {
            return key * 10;
        }


        /// <summary>
        /// .net4.5开始使用async和await进行异步编程
        /// </summary>
        /// 一个async方法里通常包含一个或多个的对应的await操作符，
        /// 但如果没有await表达式也不会导致编译错误。
        /// 但如果调用一个async方 法，
        /// 却不使用await关键字来标记一个挂起点的话，
        /// 程序将会忽略async关键字并以同步的方式执行
        async static Task<int> show3(int key)
        {
            Console.WriteLine("异步执行开始...");
            await Task.Delay(5000); //表示5秒后继续执行异步线程
            for (int i = 0; i < 100; i++)
            {
                Console.WriteLine(i);
            }
            Console.WriteLine("异步执行完毕...");
            return key * 10;
        }

        static void Main()
        {
            //第一种方法：BeginEnvoke EndEnvoke方法，属于“等待”类。
            /*
            Show show = show1;
            Console.WriteLine("主线程执行开始...");
            IAsyncResult result = show.BeginInvoke(null, null);
            Console.WriteLine("主线程继续执行...");
            for (int i = 0; i < 100; i++)
            {
                Console.WriteLine(i * -1);
            }
            show.EndInvoke(result);//在这之前可以同时执行异步线程和主线程，在这之后异步线程结束，这行代码之后的行为才能开始执行，意思就是这行代码之后的行为需要等待异步线程执行完毕才能执行
            Console.WriteLine("主线程执行结束...");
             */


            //第二种方法：WaitOne。同样属于“等待”类。
            /*
            Show show = show1;
            Console.WriteLine("主线程执行开始...");
            IAsyncResult result = show.BeginInvoke(null, null);
            Console.WriteLine("主线程继续执行...");
            for (int i = 0; i < 100; i++)
            {
                Console.WriteLine(i * -1);
            }
            result.AsyncWaitHandle.WaitOne(); //WaitOne方法有多重重载体，具体查阅MSDN
            Console.WriteLine("主线程执行结束...");
             */


             //第三种方法：轮询。也是属于“等待”类。
            /*
            Show show = show1;
            Console.WriteLine("主线程执行开始...");
            IAsyncResult result = show.BeginInvoke(null, null);
            Console.WriteLine("主线程继续执行...");
            while(!result.IsCompleted)//可以在异步线程执行完毕之前做些事情
            {
                Console.WriteLine("...");
                Thread.Sleep(1000);
            }
            Console.WriteLine("主线程执行完毕...");
            */


            //第四种方法：回调。当然属于“回调”类.
            //异步方法没有返回值
            /*
            Show show = show1;
            Console.WriteLine("主线程开始执行...");
            show.BeginInvoke(callback1, show);
            Console.WriteLine("主线程执行完毕...");
            */
            /*
            //异步方法有返回值
            Get get_ = get;
            get_.BeginInvoke(1, callback2, get_);
            */

            //第五种方法：使用async 和 await 关键字 可以使异步使用像平常方法那样简单
            Console.WriteLine("主线程执行开始...");
            var tmp = show3(1);
            Console.WriteLine("主线程继续执行...");
            for (int i = 0; i < 100; i++)
            {
                Console.WriteLine(i * -1);
            }
            Console.WriteLine("主线程执行完毕...");
            Console.WriteLine(tmp.Result);


            Console.ReadKey();
        }
        //回调方法要求
        //1.返回类型为void
        //2.只有一个参数IAsyncResult
        static void callback1(IAsyncResult result)
        {
            (result.AsyncState as Show).EndInvoke(result);
            Console.WriteLine("异步线程执行已经完毕");
        }
        static void callback2(IAsyncResult result)
        {
            int key = ((Get)result.AsyncState).EndInvoke(result);
            Console.WriteLine(key);

        }
    }
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

python爬取ajax动态生成的数据 以抓取淘宝评论为例子
在学习python的时候，一定会遇到网站内容是通过ajax动态请求、异步刷新生成的json数据的情况，并且通过python使用之前爬取静态网页内容的方式是不可以实现的，所以这篇文章将要讲述如果在python中爬取ajax动态生成的数据。
至于读取静态网页内容的方式，有兴趣的可以查看博客内容。 
这里我们以爬取淘宝评论为例子讲解一下如何去做到的。
这里主要分为了四步： 
一 获取淘宝评论时，ajax请求链接（url） 
二 获取该ajax请求返回的json数据 
三 使用python解析json数据 
四 保存解析的结果
步骤一： 
获取淘宝评论时，ajax请求链接（url） 
这里我使用的是Chrome浏览器来完成的。打开淘宝链接，在搜索框中搜索一个商品，比如“鞋子”，这里我们选择第一项商品。

然后跳转到了一个新的网页中。在这里由于我们需要爬取用户的评论，所以我们点击累计评价。

然后我们就可以看到用户对该商品的评价了，这时我们在网页中右击选择审查元素（或者直接使用F12打开）并且选中Network选项，如图所示：

我们在用户评论中，翻到底部 点击下一页或者第二页，我们在Network中看到动态添加了几项，我们选择开头为list_detail_rate.htm?itemId=35648967399的一项。

然后点击该选项，我们可以在右边选项框中看到有关该链接的信息，我们要复制Request URL中的链接内容。

我们在浏览器的地址栏中输入刚才我们获得url链接，打开后我们会发现页面返回的是我们所需要的数据，不过显得很乱，因为这是json数据。

二 获取该ajax请求返回的json数据
下一步，我们就要获取url中的json数据了。 
我所使用的python编辑器是pycharm，下面看一下python代码：
# -*- coding: utf-8 -*-
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import requests
url='https://rate.tmall.com/list_detail_rate.htm?itemId=35648967399&spuId=226460655&sellerId=1809124267&order=3&currentPage=1&append=0&content=1&tagId=&posi=&picture=&ua=011UW5TcyMNYQwiAiwQRHhBfEF8QXtHcklnMWc%3D%7CUm5OcktyT3ZCf0B9Qn9GeC4%3D%7CU2xMHDJ7G2AHYg8hAS8WKAYmCFQ1Uz9YJlxyJHI%3D%7CVGhXd1llXGVYYVVoV2pVaFFvWGVHe0Z%2FRHFMeUB4QHxCdkh8SXJcCg%3D%3D%7CVWldfS0RMQ47ASEdJwcpSDdNPm4LNBA7RiJLDXIJZBk3YTc%3D%7CVmhIGCUFOBgkGiMXNwswCzALKxcpEikJMwg9HSEfJB8%2FBToPWQ8%3D%7CV29PHzEfP29VbFZ2SnBKdiAAPR0zHT0BOQI8A1UD%7CWGFBET8RMQszDy8QLxUuDjIJNQA1YzU%3D%7CWWBAED4QMAU%2BASEYLBksDDAEOgA1YzU%3D%7CWmJCEjwSMmJXb1d3T3JMc1NmWGJAeFhmW2JCfEZmWGw6GicHKQcnGCUdIBpMGg%3D%3D%7CW2JfYkJ%2FX2BAfEV5WWdfZUV8XGBUdEBgVXVJciQ%3D&isg=82B6A3A1ED52A6996BCA2111C9DAAEE6&_ksTS=1440490222698_2142&callback=jsonp2143' #这里的url比较长
content=requests.get(url).content
print content #打印出来的内容就是我们之前在网页中获取到的json数据。包括用户的评论。
这里的content就是我们所需要的json数据，下一步就需要我们解析这些个json数据了。
三 使用python解析json数据
# -*- coding: utf-8 -*-
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import requests
import json
import re
url='https://rate.tmall.com/list_detail_rate.htm?itemId=35648967399&spuId=226460655&sellerId=1809124267&order=3&currentPage=1&append=0&content=1&tagId=&posi=&picture=&ua=011UW5TcyMNYQwiAiwQRHhBfEF8QXtHcklnMWc%3D%7CUm5OcktyT3ZCf0B9Qn9GeC4%3D%7CU2xMHDJ7G2AHYg8hAS8WKAYmCFQ1Uz9YJlxyJHI%3D%7CVGhXd1llXGVYYVVoV2pVaFFvWGVHe0Z%2FRHFMeUB4QHxCdkh8SXJcCg%3D%3D%7CVWldfS0RMQ47ASEdJwcpSDdNPm4LNBA7RiJLDXIJZBk3YTc%3D%7CVmhIGCUFOBgkGiMXNwswCzALKxcpEikJMwg9HSEfJB8%2FBToPWQ8%3D%7CV29PHzEfP29VbFZ2SnBKdiAAPR0zHT0BOQI8A1UD%7CWGFBET8RMQszDy8QLxUuDjIJNQA1YzU%3D%7CWWBAED4QMAU%2BASEYLBksDDAEOgA1YzU%3D%7CWmJCEjwSMmJXb1d3T3JMc1NmWGJAeFhmW2JCfEZmWGw6GicHKQcnGCUdIBpMGg%3D%3D%7CW2JfYkJ%2FX2BAfEV5WWdfZUV8XGBUdEBgVXVJciQ%3D&isg=82B6A3A1ED52A6996BCA2111C9DAAEE6&_ksTS=1440490222698_2142&callback=jsonp2143'
cont=requests.get(url).content
rex=re.compile(r'\w+[(]{1}(.*)[)]{1}')
content=rex.findall(cont)[0]
con=json.loads(content,"gbk")
count=len(con['rateDetail']['rateList'])
for i in xrange(count):
    print con['rateDetail']['rateList'][i]['appendComment']['content']

解析： 
这里需要导入所要的包，re为正则表达式需要的包，解析json数据需要import json 
cont=requests.get(url).content #获取网页中json数据 
rex=re.compile(r’\w+[(]{1}(.*)[)]{1}’) #正则表达式去除cont数据中多余的部分，是数据成为真正的json格式的数据{“a”:”b”,”c”:”d”}
con=json.loads(content,”gbk”) 使用json的loads函数 将content内容转化为json库函数可以处理的数据格式，”gbk”为数据的编码方式，由于win系统默认为gbk
count=len(con[‘rateDetail’][‘rateList’]) #获取用户评论的个数（这里只是当前页的） 
for i in xrange(count): 
    print con[‘rateDetail’][‘rateList’][i][‘appendComment’] 
 #循环遍历用户的评论 并输出（也可以根据需求保存数据，可以查看第四部分）
这里的难点是在杂乱的json数据中查找用户评论的路径
四 保存解析的结果
这里用户可以将用户的评论信息保存到本地，如保存为csv格式。 
可以查看博客信息。 
保存为csv数据->http://blog.csdn.net/winterto1990/article/details/47667941 
保存为mysql数据->http://blog.csdn.net/winterto1990/article/details/47704509

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        hdoj  3466  【01背包】【DP】


Proud Merchants
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 131072/65536 K (Java/Others)
Total Submission(s): 3574    Accepted Submission(s): 1491



Problem Description

Recently, iSea went to an ancient country. For such a long time, it was the most wealthy and powerful kingdom in the world. As a result, the people in this country are still very proud even if their nation hasn’t been so wealthy any more.
The merchants were the most typical, each of them only sold exactly one item, the price was Pi, but they would refuse to make a trade with you if your money were less than Qi, and iSea evaluated every item a value Vi.
If he had M units of money, what’s the maximum value iSea could get?



 


Input

There are several test cases in the input.

Each test case begin with two integers N, M (1 ≤ N ≤ 500, 1 ≤ M ≤ 5000), indicating the items’ number and the initial money.
Then N lines follow, each line contains three numbers Pi, Qi and Vi (1 ≤ Pi ≤ Qi ≤ 100, 1 ≤ Vi ≤ 1000), their meaning is in the description.

The input terminates by end of file marker.



 


Output

For each test case, output one integer, indicating maximum value iSea could get.



 


Sample Input

2 10
10 15 10
5 10 5
3 10
5 10 5
3 5 6
2 7 3


 


Sample Output

5
11


 







#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
struct node{
	int p,q,v;
}boy[555];
int cmp(node a,node b)
{   //一开始输入老是一个对一个不对，原因是没有按照q-p排序
	return (a.q-a.p) < (b.q-b.p);
}
/*要保证动归方程无后效性
	j-p[i]一定要比j先算
	算i时,最小能算到q[i]-p[i]
	因此以q[i]-p[i]排序*/ 
int bag[5005];
int main(){
	int n,m,i,j,k;
	while(~scanf("%d%d",&n,&m))
	{
		memset(bag,0,sizeof(bag));
		for(i = 0;i < n; i++)
		scanf("%d%d%d",&boy[i].p, &boy[i].q, &boy[i].v);
		sort(boy,boy+n,cmp);
		for(i = 0; i < n;i++)
		{
			for(j = m; j >= boy[i].q; j--)
			{
				bag[j] = max(bag[j], bag[j-boy[i].p]+boy[i].v);
			}
		}
		printf("%d\n",bag[m]);
	}
	return 0;
} 


版权声明：原创文章，若要转载，请与博主联系，谢谢

UVALIVE 3211 Now or later（2-sat）
﻿﻿
题意：有n架飞机需要着陆，每架飞机都可以选择“早着陆”或“晚着陆”两种方式，第i架飞机早着陆时间为Ei，晚着陆时间为Li，不得在其他时间着陆。你的任务是为这些飞机安排着陆方式，使得整个着陆计划尽量安全。换言之，如果把所有飞机的实际着陆时间从小到大排序，相邻两个着陆时间间隔的最小值应尽量大。
思路：二分判定可能的时间t，用布尔变量xi表示飞机i是否早着陆，对于一个t，判定任意两架飞机要满足的约束条件，时间复杂度是O(n*n*logT)。
#include<cstdio>  
#include<cstring>  
#include<cmath>  
#include<cstdlib>  
#include<iostream>  
#include<algorithm>  
#include<vector>  
#include<map>  
#include<queue>  
#include<stack> 
#include<string>
#include<map> 
#include<set>
#define eps 1e-6 
#define LL long long  
using namespace std;  

const int maxn = 2000*2000+10000;
//const int INF = 0x3f3f3f3f;

//2-sat
struct TwoSat {
	int n;
	vector<int> G[maxn*2];
	bool mark[maxn*2];
	int S[maxn*2], c;
	
	bool dfs(int x) {
		if(mark[x^1]) return false;
		if(mark[x]) return true;
		mark[x] = true;
		S[c++] = x;
		for(int i = 0; i < G[x].size(); i++) {
			if(!dfs(G[x][i])) return false;
		}
		return true;
	}
	
	void init(int n) {
		this->n = n;
		for(int i = 0; i < n*2; i++) G[i].clear();
		memset(mark, 0, sizeof(mark));
	}
	
	void add_clause(int x, int xval, int y, int yval) {
		x = x*2 + xval;
		y = y*2 + yval;
		G[x^1].push_back(y);
		G[y^1].push_back(x);
	}
	
	bool solve() {
		for(int i = 0; i < n*2; i += 2) {
			if(!mark[i]&&!mark[i+1]) {
				c = 0;
				if(!dfs(i)) {
					while(c > 0) mark[S[--c]] = false;
					if(!dfs(i+1)) return false;
				}
			}
		}
		return true;
	}
} solver;
int n, T[3000][2];

bool check(int t) {
	solver.init(n);
	for(int i = 0; i < n; i++) {
		for(int j = i+1; j < n; j++) {
			if(abs(T[i][0]-T[j][0]) < t) solver.add_clause(i, 0, j, 0);
			if(abs(T[i][0]-T[j][1]) < t) solver.add_clause(i, 0, j, 1);
			if(abs(T[i][1]-T[j][0]) < t) solver.add_clause(i, 1, j, 0);
			if(abs(T[i][1]-T[j][1]) < t) solver.add_clause(i, 1, j, 1);
		}
	}
	if(solver.solve()) return true;
		 
}

int main() {
	//freopen("input.txt", "r", stdin);
	while(cin >> n) {
		for(int i = 0; i < n; i++) scanf("%d%d", &T[i][0], &T[i][1]);
		int l = 0, r = 1e7;
		while(l <= r) {
			int mid = (l+r) >> 1;
			if(check(mid)) l = mid + 1;
			else r = mid - 1;
		}
		cout << r << endl; 
	} 
	return 0;
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

Mysql查询数据时，自动为结果编上序号
Mysql数据库。
有时候我们需要对查询的数据进行排序，并显示序号，那么我们可以通过以下的sql语句为查询结果的数据都加上一个序号字段，序号字段不会增加到原来的表中，只是在结果中会有这个字段。 
 SELECT drug_productor,@y:=@y+1 as num FROM ts_drug c,(SELECT @y:=0) d


如果需要分组后再进行序号显示
 SELECT drug_productor,@y:=@y+1 as num FROM( SELECT drug_productor FROM ts_drug a GROUP BY drug_productor) c,(SELECT @y:=0) d






版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        递归
例题一：
题目来源：HDOJ-2041：超级楼梯
题目大意：有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？
题目分析：倒着思考，当到达M级时有两种可能：一种是从M-1级走到M级，一种是从M-2级走到M级，两种可能加起来就是到达M级的总共走法；同理，当到达M-1级时有两种可能：一种是从M-2级走到M-1级，一种是从M-3级走到M-1级，两种可能加起来就是到达M-1级的总共走法；……当到达3级时有两种可能：一种是从2级走到3级，一种是从1级走到3级，两种可能加起来就是到达3级的总共走法；当到达2级时只有一种可能：一种就是从1级走到2级。找到出口，运用递归。
 AC代码：
 #include <stdio.h>
int a[50];
int main()
{
    int n,m,i;
    scanf("%d",&n);
    while(n--)
    {
        a[1]=1;a[2]=1;
        scanf("%d",&m);
        for(i=3;i<=m;i++)
            a[i]=a[i-1]+a[i-2];		//递归的优化 
        printf("%d\n",a[m]);
    }
    return 0;
}
例题二：
题目来源：HDOJ-1312：Red and Black
题目大意：在一个铺满红色和黑色方块瓷砖的矩形房间里，一个人站在黑色瓷砖上，他可以向四个方向的瓷砖上移动，但是不能移动到红色瓷砖上，问他最多能到达多少个瓷砖上。（'.'代表黑色瓷砖，'#' 代表红色瓷砖 ，'@'代表人的出发地(仅仅出现一次)）。
题目分析：利用递归从出发地向各个方向扩散，并标记计数。
AC代码：
 #include <stdio.h>
#include <string.h>
#include <math.h>
char a[30][30];
int n,m,x,y,i,j,num;
void f(int x,int y)
{
    if(x<0||x>=m||y<0||y>=n||a[x][y]=='#')		//防止走出房间 
        return ;
    a[x][y]='#';		//走过的瓷砖改为红色 
    num++;		//统计走过的黑色瓷砖 
    f(x-1,y);		//递归 
    f(x,y-1);
    f(x+1,y);
    f(x,y+1);
}
int main()
{
    while(scanf("%d%d",&n,&m),n|m)
    {
        num=0;
        for(i=0;i<m;i++)
        {    
            getchar();
            for(j=0;j<n;j++)
            {
                scanf("%c",&a[i][j]);
                if(a[i][j]=='@')		//找出人的初始位置 
                {
                    x=i;
                    y=j;
                }
            }
        }
        f(x,y);
        printf("%d\n",num);
    }
    return 0;
}
例题三：
题目来源：HDOJ-2553：N皇后问题
题目大意：在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。
你的任务是，对于给定的N，求出有多少种合法的放置方法。 
题目分析：从第一排第一个位置放第一个皇后，在第二排放第二个皇后，不符合要求就放到下一个位置，以此类推，直到所有的皇后放的位置符合要求。统计一共有多少种不同的放置方法。
AC代码：
 #include <stdio.h>
#include <math.h>
int n,sum,a[11],b[11];
bool place(int k)
{
    for(int j=1;j<k;j++)
        if(b[k]==b[j]||abs(k-j)==abs(b[k]-b[j]))		//判断此行此列此位置的对角线上是否已存在皇后 
            return false;
    return true;
}

void find(int k)		//递归 
{
    if(k>n)		//判断是否所有的皇后已经放置好 
        sum++;		//统计共有多少种方法放置 
    else
    {
        for(int i=1;i<=n;i++)
        {
            b[k]=i;
            if(place(k))
                find(k+1);
        }
    }
}

int main()
{
    for(n=1;n<11;n++)
    {
        sum=0;
        find(1);
        a[n]=sum;
    }
    while(scanf("%d",&n)&&n)
        printf("%d\n",a[n]);
    return 0;
}
例题四：
题目来源：HDOJ-1016：Prime Ring Problem
题目大意：输入一个数字n，用n个数字1~n组成素数环（相邻两个数字相加为素数），问一共可以组成多少个素数环。Ps:素数环的首位为数字“1”。
题目分析：首先将“1”放入首位，再依次将2~n放入，看是否符合题意。
AC代码：
 #include <stdio.h>
#include <math.h>
#include <algorithm>
#include <string.h>
using namespace std;
int vis[21];
int huan[21];
int n;

bool prime(int x)		//判断x是否为素数 
{
    for(int i=2;i<=sqrt(x);i++)
        if(x%i==0)
            return false;
        return true;
}

bool dfs(int y)		//递归 
{
    if(y>=n&&prime(huan[n]+1))		//判断是否可以组成一个环，并且最后一个数与“1”相加为素数 
    {
        for(int i=1;i<=n;i++)
            printf("%d%c",huan[i],(i<n?' ':'\n'));
    }
    else
    {
        for(int i=2;i<=n;i++)
        {
            if(vis[i]&&prime(huan[y]+i))		//i没有加入素数环，并且 与上一个数相加为素数 
            {
                vis[i]=0;
                huan[y+1]=i;
                dfs(y+1);		//递归 
                vis[i]=1;
            }
        }
    }
}

int main()
{
    int sum=0;
    while(~scanf("%d",&n))
    {
        memset(vis,1,sizeof(vis));		//标记i是否加入素数环 
        memset(huan,0,sizeof(huan));		//环的初始化 
        sum++;
        printf("Case %d:\n",sum);
        vis[1]=0;		//“1”进入素数环 
        huan[1]=1;		//素数环的首位为“1” 
        dfs(1);
        puts("");
    }
    return 0;
}
例题五：
题目来源：HDOJ-1241：Oil Deposits
题目大意：在给定的矩形中判断一共有多少个油田。（相邻、对角线算是一个公共油田，“*”代表没有油，“@”代表有油）。
题目分析：从第一行第一列开始搜索，并标记计数。
AC代码：
#include <stdio.h>
char a[110][110];
int m,n,i,j,num;
void find(int x,int y)		//递归 
{
    if(x<1||x>n||y<1||y>m||a[x][y]=='*')		//防止搜索到矩形外部 
        return ;
    a[x][y]='*';		//搜索过的地方标记为无油 
    find(x,y-1);		//递归 
    find(x,y+1);
    find(x-1,y);
    find(x+1,y);
    find(x-1,y-1);
    find(x+1,y-1);
    find(x-1,y+1);
    find(x+1,y+1);
}
int main()
{
    while(scanf("%d%d",&n,&m)&&(n||m))
    {
        num=0;
        for(i=1;i<=n;i++)
        {
            getchar();
            for(j=1;j<=m;j++)
                scanf("%c",&a[i][j]);
        }
        for(i=1;i<=n;i++)
            for(j=1;j<=m;j++)
            {
                if(a[i][j]=='@')		//搜索有油的地方 
                {
                    num++;		//计数 
                    find(i,j);		//递归 
                }
            }
        printf("%d\n",num);
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

面试--Java基础知识
1、  Java的工作原理 
1）  Java源程序（.java）需要通过编译器编译成字节码（.class）文件; 
2）  Java程序的跨平台主要指字节码可以在任何具有Java虚拟机的设备上运行； 
3）  Java虚拟机的建立需要针对不同的软硬件平台（处理器、操作系统）做专门的实现。 
4）  字节码首先由类装载器加载到Java虚拟机中，其次由字节码校验器检查是否有非法操作，校验通过后再由Java解释器把字节码解释成机器码执行。 
5）  Java虚拟机采用沙箱模式运行，即把Java程序的代码和数据限制在一定的内存空间里执行，不允许程序访问该内存空间外的内存。

2、  八种基本数据类型 
名称                  字节数       名称                       字节数 
boolean布尔型      1           int 整型                   4 
byte    字节型         1          long 长整型              8 
short短整型            2           float   浮点型              4 
char    字符型         2           double  双精度型         8

3、  基本数据类型间的转换 
1）  自动转换：参与运算的数据类型不一致时，精度低的会自动向精度高的转换。 
byte-> short\char\int\long\float\double 
short->char\int\long\float\double 
char->int\long\float\double 
long->float\double 
float->double 
2）  强制转换：强制转换又叫显示转换，有可能造成数据精度的损失，应慎用。

4、  运算符 
算术运算符   ++,–,+,-,*,/,% 
逻辑运算符   &,|,!,^,&&,|| 
关系运算符   >,<,==,!=,<=,>= 
位运算符    &,|,^,~,>>,<<,>>>

5、  switch（表达式） 
在Java1.6（包括）之前，表达式只支持能等价成int类型的数据：byte\char\short\int，其他类型均不可以。在Java1.7以后，可以支持String类型的数据。

6、  面向对象的特征 
1）  封装：把对象的全部属性和全部方法结合成一个独立的单位，并尽可能屏蔽对象的内部细节。 
2）  继承：子类拥有父类的所有非private属性和方法，并且子类中还可以增加新的属性和方法；Java支持单继承多实现 
3）  重载：同一个类中用相同的方法名定义多个方法，同名方法之间以所带参数个数、参数类型、参数顺序的不同来区分，参数的返回值类型、访问权限、抛出的异常不构成方法重载的标志。 
4）  覆盖：子类中使用与父类同名的方法，且方法的参数（个数、类型、顺序）和返回值类型完全一样，即子类方法的代码覆盖父类方法的代码。被覆盖的方法不能是私有的。 
5）  多态：程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。其实现机制是：父类或接口定义的引用变量可以指向子类或者具体实现类的实例对象。 
6）  子类在隐藏父类的成员后，往往还要用到父类的成员。在子类中引用被隐藏的父类成员时需要用super指明。 
访问父类方法：super.方法名(参数) 
访问父类成员：super.成员变量 
调用父类构造方法：super(参数)

7、  抽象类和接口 
1）  含有抽象方法的类必须定义成抽象类，抽象类中的方法可以不是抽象方法； 
2）  抽象类中定义的方法必须在子类中实现，所以，不能有抽象构造方法和抽象静态方法； 
3）  如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义成抽象类； 
4）  接口可以说是抽象类的一种特例，接口中的所有方法都必须是抽象的； 
5）  接口中的方法类型默认为：public abstract，变量类型默认为：public static final； 
6）  一个类可以实现多个接口，但只能继承一个抽象类。

8、  方法调用时参数传递 
1）  值传递：当方法的参数是基本数据类型时是值传递。值传递传递给方法的是参数的数据值，方法接收实际参数的值，但不改变实际参数的值。 
2）  引用传递：当方法的参数是对象或者数组时是引用传递。引用传递传递给方法的是参数在内存中的地址，方法中对参数的操作会改变参数的数据值。

9、  作用域 public ，private ，protected ，以及不写时的区别 
说明：如果在元素前面没有写任何访问修饰符，则表示 friendly。 
作用域 当前类 同一包 子孙类 其他包 
Public            
Protected             
Friendly              
Private          

10、 异常 
1）  所有的异常都是由Throwable继承而来，分为Error和Exception两类； 
2）  Error表示Java运行时系统的内部错误和资源耗尽错误，应用程序不应该抛出这种类型的异常。 
3）  Exception分为两类，所有RuntimeException类及其子类的实例被称为Runtime异常，不属于该范畴的异常则被称为CheckedException； 
4）  Java认为CheckedException是可以被处理的异常，所以Java程序必须显式处理这类异常，如果不处理这类异常，编译时就会发生错误而无法编译； 
5）  空指针异常、数组越界异常、类型转换异常、除数为零等都是RuntimeException。

11、 内部类 
1）  内部类是指将一个类定义在另一个类的内部，甚至方法的内部。 
2）  内部类可以无条件的访问其内部声明的成员和外部类的成员，外部类不能直接访问内部类的成员。 
3）  内部类分为静态内部类和非静态内部类，两者的区别如下： 
3.1）静态内部类和外部类对象独立，它可以直接创建对象（new Outer.Inner()），也可以通过外部类对象创建对象（outer.new Inner()）； 
3.2）静态内部类只能使用外部类的静态成员，不能使用外部类的非静态成员，而非静态内部类可以使用外部类的所有成员； 
3.3）静态内部类中可以定义静态成员和非静态成员，非静态内部类中只能定义非静态成员。 
4）  匿名类：没有类名的内部类，多用在事件处理的程序中。

12、 Java虚拟机运行时数据区 
1）  程序计数器：每个线程都有自己的程序计数器，它可以看作是线程所执行的字节码的行号指示器； 
2）  Java虚拟机栈：描述的是java方法执行内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接、方法出口等信息； 
3）  本地方法栈：与Java虚拟机栈差不多，区别是Java虚拟机栈是为执行Java方法服务，本地方法栈是为执行Native方法服务； 
4）  Java堆：被所有线程共享的内存区域，所有对象的实例和数组都在堆上分配存储空间； 
5）  方法区：也是被所有线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量等

13、 Equals和==的区别 
==：比较基本类型变量或者引用类型变量的值是否相等； 
equals：比较引用类型变量对应的对象的内容是否相同；
String s1 = "qaz";
String s2 = "qaz";
String s3 = new String("qaz");
System.out.println(s1 == s2);             //true 
System.out.println(s1.equals(s2));         //true
System.out.println(s1 == s3);             //false
System.out.println(s1.equals(s3));         //true

14、 String s=new String(“qaz”);创建了几个字符串对象？ 
1）  ”qaz”是一个字符串对象（字符串常量），它存放在常量池中； 
2）  new String(“qaz”)会根据字符串常量”qaz”的内容创建一个字符串对象，存放在堆内存中； 
3）  在2）执行之前，如果常量池中不存在常量”qaz”，则会在常量池中创建字符串对象”qaz”，否则不用创建。 
综上可知答案为：一个或者两个。

15、 如何把一段逗号分隔的字符串转换成一个数组？ 
1）  用String.spilt(“,”); 
2）  用StringTokenizer，代码如下：
String str = "a,bc,d,efg";
        StringTokenizer tokenizer = new StringTokenizer(str, ",");
        String[] words = new String[tokenizer.countTokens()];
        int i = 0;
        while (tokenizer.hasMoreTokens()) {
            words[i++] = tokenizer.nextToken();
        }

16、 Try-catch-finally语句中，finally语句最后执行，即使在try或者catch中已经return了finally语句也会执行；
    public static void main(String[] args) {
        System.out.println(getInt() + "");
    }
    public static int getInt() {
        try {
            return 2;
        } finally {
            return 3;
        }
    }
———–执行结果 3——-

17、 类在实例化时成员的初始化顺序 
1）  初始化父类的静态成员变量和静态代码块； 
2）  初始化子类的静态成员变量和静态代码块； 
3）  初始化父类的普通成员变量和代码块； 
4）  初始化子类的普通成员变量和代码块。

18、 原码、反码、补码 
1）  机器数：一个数在机器中的二进制表示形式叫做机器数，机器数是带符号的，在计算机中用最高位表示符号位，0表示正数，1表示负数。 
2）  真值：带符号数在计算机中用补码表示，机器数表示的真实数值叫做真值。 
3）  原码：符号位加上真值的绝对值，比如8位二进制数： 
[+1]原=00000001       [-1]原=10000001 
4）  反码：正数的反码是其本身，负数的反码是符号位不变，其余各位取反： 
[+1]反=00000001       [-1]反=11111110 
5）  补码：正数的补码是其本身，负数的补码是在反码的基础上加一： 
[+1]补=00000001       [-1]补=11111111

19、 左移、右移、无符号右移 
1）  左移：向左移动指定位，符号位跟着移动，超出高位截断，低位补0； 
2）  右移：向右移动指定位，符号位跟着移动，超出低位截断，高位补符号位； 
3）  无符号右移：向右移动指定位，符号位跟着移动，超出低位截断，高位补0；

20、 Java垃圾回收机制 
1）  垃圾回收器的任务是回收垃圾对象所占用的空间供新的对象使用； 
2）  如果一个对象没有任何引用与之关联，那么这个对象就成了可回收的对象； 
3）  引用计数法和可达性分析法来判断对象是否还有引用与之关联； 
4）  比较常见的将对象判定为可回收对象的情况： 
1、显式的将引用赋值为null； 
2、将已经指向某个对象的引用指向新的对象； 
3、局部引用指向的对象 
4、只有弱引用与之关联的对象； 
5）  典型的垃圾回收算法： 
1、  Mark-Sweep（标记-清除法）：标记阶段标记所有需要被回收的对象，清除阶段回收所有被标记对象占用的空间，这种方法简单但容易产生内存碎片； 
2、  Copying（复制）算法：将内存划分为大小相同的两块，每次使用其中一块。当使用的这一块内存满了之后，就将活着的对象复制到另一块内存上，然后回收整块内存。虽然解决了内存碎片问题，但可以使用的内存缩减为原来的一半； 
3、  Mark-Compact（标记-整理法）：标记阶段标记所有需要回收的对象，整理阶段将活着的对象移到一端，然后清除边界以外的内存； 
4、  Generational Collection（分代收集）算法：该算法是目前大部分JVM垃圾回收器采用的算法。它将堆内存划分为老年代和新生代，每次垃圾回收时老年代只有少数对象需要回收，新生代中大部分对象都需要回收。老年代采用标记-整理法，新生代采用复制法。

21、 对于JVM内存配置参数：-Xmx10240m  -Xms10240m  -Xmn5120m  -XX：SurvivorRatio=3，其中最小内存值和Survivor区总大小分别是（10240）和（2048）。 
1）  -Xmx：最大堆大小； 
2）  -Xms：初始堆大小，即为最小内存值； 
3）  -Xmn：年轻代大小，年轻代由一个Eden区和两个Survivor区组成； 
4）  -XX：SurvivorRatio：年轻代中Eden区与Survivor区的大小比值；

22、 Java内存模型 
Java内存模型规定了JVM有主内存，主内存是多个线程共享的。每个线程都有自己的工作内存，工作内存中保存了被该线程用到的变量的主内存拷贝副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。 
Java内存模型定义了以下八种操作来完成主内存和工作内存之间的交互： 
(1) Lock（锁定）：作用于主内存变量，把一个变量标识为一个线程独占的状态； 
(2) Unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定； 
(3) Read（读取）：作用于主内存变量，把一个变量从主内存传输到工作内存； 
(4) Load（载入）：作用于工作内存，把从主内存得到的变量值赋给工作内存中的变量副本； 
(5) Use（使用）：作用于工作内存，把工作内存变量副本的值传递给执行引擎； 
(6) Assign（赋值）：作用于工作内存变量，把从执行引擎接收到的值赋给工作内存中的变量副本； 
(7) Store（存储）：作用于工作内存，把工作内存中变量副本的值传输到主内存； 
(8) Write（写入）：作用于主内存，把从工作内存得到的变量副本的值赋给主内存中的变量

23、 线程与进程的区别 
1）  进程是资源的组织单位，进程中有一个包含了程序内容和数据的地址空间，不同进程的地址空间是相互隔离的； 
2）  线程是CPU的调度单位，表示的是程序的执行流程，线程有自己的程序计数器、寄存器、栈和帧等； 
3）  引入线程的动机在于阻塞式i/o的存在，当一个线程执行的i/o操作被阻塞时，同一进程的其他线程可以用CPU来进行计算，从而提高了应用的执行效率。

24、 创建线程的方法 
1）  通过继承Thread类创建线程； 
2）  通过实现Runnable接口创建线程类； 
3）  使用Callable和FutureTask创建线程类。

25、 线程的状态转换 
1）  新建状态：程序使用new关键字新建一个线程后，该线程处于新建状态； 
2）  新建—>就绪：处于新建状态的线程调用start()方法； 
3）  就绪—>运行：处于就绪状态的线程得到处理器资源进入运行状态； 
4）  运行—>就绪：失去处理器资源或者调用yield()方法； 
5）  运行—>阻塞：1、sleep()，2、IO阻塞，3、等待同步锁，4、suspend()方法（易导致死锁）； 
6）  运行—>死亡：1、run()或call()方法执行完成，线程正常结束，2、线程抛出一个未捕获的Exception或Error，3、调用stop()方法（易导致死锁）; 
7）  阻塞—>就绪：1、sleep()时间到，2、IO方法返回，3、获得同步锁，4、resume()。

26、 线程控制 
1）  join()方法：调用join()方法的线程完成run()后再执行join()方法后面的代码； 
2）  后台线程：在后台运行，为其他线程提供服务的线程。JVM垃圾回收线程就是典型的后台线程。如果所有的前台线程都死亡了，后台线程会自动死亡； 
3）  sleep()方法：让线程暂停一段时间，线程转入阻塞状态； 
4）  yield()方法：让线程暂停一下，线程转入就绪状态；

27、 互斥同步 
1）  互斥同步是一种常见的并发正确性保障手段。同步是指在多个线程并发访问共享数据时，共享数据在同一时刻只被一个或者几个（使用信号量的时候）线程访问。 
2）  互斥是实现同步的一种手段，使方法，同步是目的。临界区、互斥量、信号量是实现互斥的主要方式； 
3）  synchronized关键字和重入锁ReentrantLock是实现同步的基本手段，相比synchronized，ReentrantLock增加了一些高级功能，主要有一下3项： 
1、  等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待； 
2、  公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。Synchronized锁是非公平的，ReentrantLock默认也是非公平的，但可以使用带布尔值的构造函数要求使用公平锁； 
3、  ReentrantLock锁可以绑定多个条件，即一个ReentrantLock对象可以同时绑定多个Condition对象。

28、 线程协作 
方式一：wait()、notify()和notifyAll() 
1）  wait()、notify()和notifyAll()是Object类中的方法，并且为final方法； 
2）  调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor； 
3）  调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程； 
4）  调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程； 
5）  这三个方法必须在同步块或者同步方法中执行，notify()和notifyAll()方法只是唤醒等待该对象的monitor的线程，并不决定哪个线程能够获取到monitor。
方式二：使用Condition的await()、signal()和signalAll() 
1）  采用这种方式实现线程间协作更加安全高效； 
2）  Condition是一个接口，基本方法是await()，signal()，signalAll()； 
3）  Condition依赖于Lock接口，生成一个Condition的基本代码是lock. new Condition；  
4）  Condition的三个基本方法跟wait()、notify()、notifyAll()对应； 
5）  调用这三个方法都必须在lock的保护之内，就是说必须在lock.lock()和lock.unlock()之间才可以使用

29、 HashMap和HashTable的区别 
1）  HashTable继承Dictionary，HashMap继承AbstractMap； 
2）  HashTable的方法是同步的，而HashMap的方法不是同步的，效率上HashMap高于HashTable； 
3）  HashMap允许key，value为空，HashTable不允许。

30、 sleep()和wait()的区别 
1）sleep()是定义在Thread类中的方法，wait()是定义在Object类中的方法； 
2）wait()方法只能在同步控制方法或同步控制块中调用，sleep()可以在任何地方使用； 
3）sleep()方法没有释放锁，wait()方法释放了锁，使得其他线程可以使用同步代码块； 
4）sleep()方法不出让系统资源，wait()方法出让系统资源。

31、 synchronized关键字  
1）  synchronized既保证了多线程的并发有序性，又保证了多线程的内存可见性。 
2）  一个线程执行临界区代码过程如下：1 获得同步锁；2 清空工作内存；3 从主内存拷贝变量副本到工作内存；4 对这些变量进行计算；5 将变量从工作内存写回到主存；6 释放锁。 
3）  public synchronized void method()这种情况，锁就是方法所在的对象，public static synchronized void method()，那么锁就是这个方法所在的类。

32、 volatile关键字 
1）volatile只能保证多线程的内存可见性，不能保证多线程的执行有序性 
2）对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的，并不能解决并发带来的问题， 
例如线程1，线程2 在进行read,load 操作中，发现主内存中count的值都是5，那么都会加载这个最新的值5。在线程1对count进行修改之后，会write到主内存中，主内存中的count变量就会变为6。线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6。即使使用了volatile关键字，也没能解决并发带来的问题。

33、 写一个单例模式
public class SingleInstance {
    private SingleInstance() {}
    public static SingleInstance getInstance() {
        return SingleInstanceHolder.INSTANCE;
    }
    private static class SingleInstanceHolder {
        private final static SingleInstance INSTANCE = new SingleInstance();
    }
}
public class SingleInstance {
    private volatile static SingleInstance sInstance;
    private SingleInstance() {
    }
    public static SingleInstance getInstance() {
        if (sInstance == null) {
            synchronized (SingleInstance.class) {
                if (sInstance == null) {
                    sInstance = new SingleInstance();
                }
            }
        }
        return sInstance;
    }
}
public enum SingleInstance {
    INSTANCE;
    private SingleInstance() {
    }
}

34、 final finally finalize 区别 
1）final：Java中的关键字、修饰符，如果一个类被声明为final，意味着它不能派生出新的子类，不能作为父类被继承，因此一个类不能同时声明为abstract和final；被声明为final的变量必须在声明时给定初始值，在以后的使用中只能读取不能修改；被声明为final的方法只能使用，不能重载。 
2）finally：try-catch-finally异常处理语句的一部分，finally结构里的代码总会执行，而不管有无异常发生，关闭数据库连接的close()方法通常放在finally中。 
3）finalize：Java中的一个方法，在Object类中定义的，finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

将一个数插入到另一个数中指定位置处

int  updateBits(int n, int m, int i, int j)
{
/*创建掩码，用来清除n中i到j的位，
示例：i=2，j=4.掩码为11100011*/
int allOnes = ~0;//等同于一连串的1
//在位置j之前的位均为1，其余为0，left=11100000
int  left = allOnes << (j + 1);
//在位置i之后的位均为1，right=00000011
int right = ((1 << i) - 1);
//除i到j的位为0，其余位均为1，mask=11100011
int mask = left | right;
/*清除位置j到位置i的位，然后将m放进去*/
int n_cleared = n&mask;//清除j到i的位
int  m_shifted = m << i;//将m移至相应的位置
return n_cleared | m_shifted;//对两者执行位或操作
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

如何自创一门计算机语言
如何自创一门计算机语言


需要有基本的编译原理常识。构造基本的编译原理常识，一方面来自于对已有语言的使用经验，了解基本术语。比如用C，那么起码知道语言要素包括宏、表达式、语句、语句块、函数、指针等；还知道C语言有编译、链接和执行三个阶段。这些基本概念对宏观掌握学习进程是很有必要的。另外一方面编译原理的常识，要来自图书。比如龙书、SICP。在这一步，得知道大部分语言的处理都要分为词法、语法、语义和代码生成四个阶段。每个阶段，分别是做什么的。了解具体的编译算法。了解到什么程度，取决于使用第三方工具，还是需要自己从字符开始处理。个人建议，乔姆斯基文法体系、（扩展）巴克斯范式（EBNF），正则表达式，和LL(1)的递归下降分析法是必须要掌握的。对LL(k)，LR(k)要有概念。其中，四则运算表达式的分析是很好的练习。对语法的感觉。初学者设计语言的难度有两点。第一，不知道什么样的语法/语义是需要的；第二，不知道设计的文法能否实现。如果练习过递归下降法，应该已经有了基本的感觉。这个时候可以试图实现熟悉的语言。一些常用语言的Grammar Rule都是可以查到的。虽然这些语法，特别是C++，可能是上下文相关的所以用书上的办法难以实现，但是可以实现它的一个子集。通过这样的练习，能对掌握的分析算法能完成什么样的工作就有了个大致的体验。深入了解自己的领域，明确需求。是需要一个类似于自然语言的脚本，还是只是一个表达式。经过3阶段的训练已经有了独立撰写语法的能力。可以写一个基础版本的出来。实现自己的语言，特别是词法和语法部分。这一步最好能Log出尽可能多的信息，例如词列表并打印出分析树。当有了分析树后，就可以去做语义分析了。对于初学者而言，语言的规模要尽可能小，这样语言的解释和语义分析可以合为一体，不用担心哪个部分算是代码生成，哪个部分算是语义分析。所以这一步最好能把解释器也写出来。这一步的要求很简单，知道符号表是做什么的，学会归纳和推导类型，能正确的处理分支和循环语句（如果有的话）。设计一门类似于ASM的VM语言，可以是堆栈机模型，也可以是寄存器机模型。撰写代码生成从语法树上生成这个VM语言出来。并写一个VM的执行器。这一步看起来无从下手，实际上只要肯写，不出一个礼拜就知道怎么做了。一开始这个VM语言可以只用做整数的加减乘除就行了，以后可以慢慢加其他比较重要的特性，比如运行栈啦、代码地址啦，跳转啦等等。另外，把LLVM作为目标也是不错的选择，起码指令的解释不用自己费工夫了，LLVM的手册读起来也很容易。那个Tutorial写的特别好。
至此，语言就初步建立完成了。但是因为一开始能力有限，所以设计出来的语言是磕磕巴巴的。这个时候可以选择：

向某个现有的语言靠拢；自己去了解现有语言的机制并进行权衡。这个时候什么动态/静态类型，函数是first class，类和对象才是该考虑的问题。这个时候一定要多读、多用现有的语言。拜编译器经验所赐，会站在一个不同角度上来对待现有的语言；学习Functional Programming，这对设计更好用的文法、更快的编写和修改编译器都有莫大的帮助。例如可以使用Combinator在C++中以类似于DSL的方式配置语法；剩下的就是在Language领域无止尽的挖掘了。上下文相关的语法、语法糖的设计、运行时的辅助机制（例如async，await这些广义上的控制流语句），GC，类型推导和静态分析等等。；最后也是最重要的，充分理解需求，才能在诸多语言要素间做出取舍。

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU   4273  Rescue（三维凸包 + 重心）

Rescue
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 398    Accepted Submission(s): 296



Problem Description

I work at NASA outer space rescue team which needs much courage and patient. In daily life, I always receive a lot of mission, and I must complete it right now.
Today, team leader announced me that there is a huge spaceship dropping anchor in the out space, and we should reach there for rescue. As a working principle, at first, we should check whether there are persons living in the spaceship. So we carry a kind of
 machine called life sensor which can sense the life phenomenon when the distance between the machine and the living is not farther than the sense radius.
I have read the designing paper of the spaceship in advance. It has a form of a convex polyhedron, and we can assume it is isodense. For best control, control center of the whole ship is located at the center of the mass. It is sure that if someone is still
 alive, he will stay at the control center.
It's unfortunately that I find the door is stocked when I try to enter into the spaceship, so I can only sense the living out of the space ship. Now I have opened the machine and it's time to set the sense radius of it. I wonder the minimal radius of the machine
 which can allowe me to check whether there are persons living in the spaceship.


 


Input

There are multiple test cases.
The first line contains an integer n indicating the number of vertices of the polyhedron. (4 <= n <= 100)
Each of the next n lines contains three integers xi, yi, zi, the coordinates of the polyhedron vertices (-10,000 <= xi, yi, zi <= 10,000).
It guaranteed that the given points are vertices of the convex polyhedron, and the polyhedron is non-degenerate.


 


Output

For each test case, output a float number indicating the minimal radius of the machine. Your answer should accurate up to 0.001.


 


Sample Input

4
0 0 0
1 0 0
0 1 0
0 0 1

8
0 0 0
0 0 2
0 2 0
0 2 2
2 0 0
2 0 2
2 2 0
2 2 2


 


Sample Output

0.144
1.000


 


Source

2012 ACM/ICPC Asia Regional Changchun Online









  kuangbin大神的模板一遍过。。。膜拜一下




#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#define eps 1e-8
#define N 110
using namespace std;
struct point
{
    double x,y,z;
    point() {}
    point(double xx,double yy,double zz): x(xx),y(yy),z(zz) {}
    point operator -(const point p)
    {
        return point(x-p.x, y-p.y, z-p.z);
    }
    point operator +(const point p)
    {
        return point(x+p.x, y+p.y, z+p.z);
    }
    point operator *(const point p)
    {
        return point(y*p.z-z*p.y, z*p.x-x*p.z, x*p.y-y*p.x);
    }
    point operator *(double p)
    {
        return point(x*p, y*p,z*p);
    }
    point operator /(double p)
    {
        return point(x/p, y/p,z/p);
    }
    double operator ^( point p)
    {
        return x*p.x+y*p.y+z*p.z;
    }

};
struct node
{
    struct face
    {
        int a,b,c;
        bool ok;
    };
    int n;
    point tn[N];
    int num;
    face F[8*N];
    int g[N][N];
    double vlen(point a)
    {
        return sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
    }
    point cross(const point &a,const point &b,const point &c)
    {
        return point ( (b.y-a.y)*(c.z-a.z) - (b.z-a.z)*(c.y-a.y),
                       (b.z-a.z)*(c.x-a.x) - (b.x-a.x)*(c.z-a.z),
                       (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x)

                     );
    }
    double area(point a,point b,point c)
    {
        return vlen((b*a)*(c-a));
    }
    double volume(point a,point b,point c,point d)
    {
        return (b-a)*(c-a)^(d-a);
    }
    double dbcmp(point &p,face &f)
    {
        point m = tn[f.b] - tn[f.a];
        point n = tn[f.c] - tn[f.a];
        point t = p - tn[f.a];
        return (m*n)^t;
    }
    void deal(int p,int a,int b)
    {
        int f = g[a][b];
        face add;
        if(F[f].ok)
        {
            if(dbcmp(tn[p],F[f]) > eps)
                dfs(p,f);
            else
            {
                add.a=b;
                add.b=a;
                add.c=p;
                add.ok=true;
                g[p][b] = g[a][p] = g[b][a] =num;
                F[num++] = add;
            }
        }
    }
    void dfs(int p,int now)
    {
        F[now].ok = false;
        deal(p,F[now].b,F[now].a);
        deal(p,F[now].c,F[now].b);
        deal(p,F[now].a,F[now].c);

    }
    bool same(int s,int t)
    {
        point &a = tn[F[s].a];
        point &b = tn[F[s].b];
        point &c = tn[F[s].c];
        return fabs( volume(a,b,c,tn[F[t].a])) < eps &&
               fabs( volume(a,b,c,tn[F[t].b])) < eps &&
               fabs( volume(a,b,c,tn[F[t].c])) < eps ;
    }
    void create()
    {
        int i,j,tmp;
        face add;
        num = 0;
        if(n<4) return ;
        bool flag =true;
        for(i=1; i<n; i++)
        {
            if(vlen(tn[0]-tn[i]) > eps)
            {
                swap(tn[1],tn[i]);
                flag = false;
                break;
            }
        }
        if(flag) return ;
        flag =true;
        for(i=2; i<n; i++)
        {
            if(vlen((tn[0]-tn[1])*(tn[1]-tn[i])) > eps )
            {
                swap(tn[2],tn[i]);
                flag =false;
                break;
            }
        }
        if(flag) return ;
        flag =true;
        for(i =3; i<n; i++)
        {
            if(fabs((tn[0]-tn[1])*(tn[1]-tn[2])^(tn[0]-tn[i])) >eps    )
            {
                swap(tn[3],tn[i]);
                flag =false;
                break;
            }
        }
        if(flag) return ;
        for(i=0; i<4; i++)
        {
            add.a = (i+1)%4;
            add.b = (i+2)%4;
            add.c = (i+3)%4;
            add.ok = true;
            if(dbcmp(tn[i],add) > 0)
            {
                swap(add.b,add.c);
            }
            g[add.a][add.b] =   g[add.b][add.c] =  g[add.c][add.a] =num;
            F[num++]=add;
        }
        for(i =4; i<n; i++)
        {
            for(j =0; j<num; j++)
            {
                if(F[j].ok && dbcmp(tn[i],F[j])>eps)
                {
                    dfs(i,j);
                    break;
                }
            }
        }
        tmp =num;
        for(i=num=0; i<tmp; i++)
        {
            if(F[i].ok)
                F[num++] = F[i];
        }
    }
    double area()
    {
        double res=0;
        if(n==3)
        {
            point p = cross(tn[0],tn[1],tn[2]);
            res = vlen(p)/2.0;
            return res;
        }
        for(int i=0; i<num; i++)
        {
            res += area(tn[F[i].a],tn[F[i].b],tn[F[i].c]);
        }
        return res/2.0;
    }
    double volume()
    {
        double res=0;
        point tmp(0,0,0);
        for(int i = 0; i<num; i++)
            res += volume(tmp,tn[F[i].a],tn[F[i].b],tn[F[i].c]);
        return fabs(res/6.0);
    }
    int triangle()
    {
        return num;
    }
    int polygon()
    {
        int i,j,res,flag;
        for(i=res=0; i<num; i++)
        {
            flag=1;
            for(j=0; j<i; j++)
            {
                if(same(i,j))
                {
                    flag=0;
                    break;
                }
            }
            res+=flag;
        }
        return res;
    }
    point barycenter()
    {
        point ans(0,0,0),o(0,0,0);
        double all=0;
        for(int i=0; i<num; i++)
        {
            double vol = volume(o,tn[F[i].a],tn[F[i].b],tn[F[i].c]);
            ans = ans+(o+tn[F[i].a]+tn[F[i].b]+tn[F[i].c])/4.0*vol;
            all+=vol;
        }
        ans = ans/all;
        return ans;
    }
    double ptoface(point p,int i)
    {
        return fabs(volume(tn[F[i].a],tn[F[i].b],tn[F[i].c],p) /
                    vlen( (tn[F[i].b]-tn[F[i].a])*(tn[F[i].c]-tn[F[i].a]) ));
    }
};
node ans;
int main()
{
    while(~scanf("%d",&ans.n))
    {
        for(int i=0; i<ans.n; i++)
        {
            scanf("%lf%lf%lf",&ans.tn[i].x,&ans.tn[i].y,&ans.tn[i].z);
        }
        ans.create();
        point p=ans.barycenter();
        double answer=1e20;
        for(int i=0; i<ans.num; i++)
        {
            answer=min(answer,ans.ptoface(p,i));
        }
        printf("%.3lf\n",answer);
    }
    return 0;
}



版权声明：本文为博主原创文章，如有特殊需要请与博主联系  QQ ： 793977586。

快学Scala习题解答—第十五章 注解

15  注解  


16.1  编写四个JUnit测试用例，分别使用带或不带某个参数的@Test注解。用JUnit执行这些测试 
import org.junit.Test
class ScalaTest {
  @Test
  def test1(){
    print("test1")
  }

  @Test(timeout = 1L)
  def test2(){
    print("test2")
  }
}



16.2  创建一个类的示例，展示注解可以出现的所有位置。用@deprecated作为你的示例注解。 
@deprecated
class Test{

  @deprecated
  val t = _;

  @deprecated(message = "unuse")
  def hello(){
    println("hello")
  }
}

@deprecated
object Test extends App{
  val t = new Test()
  t.hello()
  t.t
}



16.3  Scala类库中的哪些注解用到了元注解@param,@field,@getter,@setter,@beanGetter或@beanSetter? 



16.4  编写一个Scala方法sum,带有可变长度的整型参数，返回所有参数之和。从Java调用该方法。 
import annotation.varargs

class Test{

  @varargs
  def sum(n : Int*)={
    n.sum
  }
}
public class Hello {
    public static void main(String[] args){
        Test t = new Test();
        System.out.println(t.sum(1,2,3));
    }
}



16.5  编写一个返回包含某文件所有行的字符串的方法。从Java调用该方法。 




import io.Source

class Test{

  def read()={
    Source.fromFile("test.txt").mkString
  }
}
public class Hello {
    public static void main(String[] args){
        Test t = new Test();
        System.out.println(t.read());
    }
}



16.6  编写一个Scala对象，该对象带有一个易失(volatile)的Boolean字段。让某一个线程睡眠一段时间，之后将该字段设为true，打印消息，然后退出。而另一个线程不停的检查该字段是否为true。如果是，它将打印一个消息并退出。如果不是，则它将短暂睡眠，然后重试。如果变量不是易失的，会发生什么？ 



这里只有一个线程修改Boolean字段，所以字段是否为volatile应该是没有区别的

import scala.actors.Actor

class T1(obj:Obj) extends Actor{
  def act() {
    println("T1 is waiting")
    Thread.sleep(5000)
    obj.flag = true
    println("T1 set flag = true")
  }
}

class T2(obj:Obj) extends Actor{
  def act() {
    var f = true
    while (f){
      if(obj.flag){
        println("T2 is end")
        f = false
      }else{
        println("T2 is waiting")
        Thread.sleep(1000)
      }
    }
  }
}

class Obj{
//  @volatile
  var flag : Boolean = false
}

object Test{
  def main(args: Array[String]) {
    val obj = new Obj()
    val t1 = new T1(obj)
    val t2 = new T2(obj)
    t1.start()
    t2.start()
  }
}




16.7  给出一个示例，展示如果方法可被重写，则尾递归优化为非法 



import annotation.tailrec
class Test{
  @tailrec
  def sum2(xs : Seq[Int],partial : BigInt) : BigInt = {
    if (xs.isEmpty) partial else sum2(xs.tail,xs.head + partial)
  }
}
编译报错,修改如下

import annotation.tailrec
object Test extends App{
  @tailrec
  def sum2(xs : Seq[Int],partial : BigInt) : BigInt = {
    if (xs.isEmpty) partial else sum2(xs.tail,xs.head + partial)
  }

  println(sum2(1 to 1000000,0))
}16.8  将allDifferent方法添加到对象，编译并检查字节码。@specialized注解产生了哪些方法? 

object Test{
  def allDifferent[@specialized T](x:T,y:T,z:T) = x != y && x!= z && y != z
}javap Test$得到




public final class Test$ extends java.lang.Object{
    public static final Test$ MODULE$;
    public static {};
    public boolean allDifferent(java.lang.Object, java.lang.Object, java.lang.Ob
ject);
    public boolean allDifferent$mZc$sp(boolean, boolean, boolean);
    public boolean allDifferent$mBc$sp(byte, byte, byte);
    public boolean allDifferent$mCc$sp(char, char, char);
    public boolean allDifferent$mDc$sp(double, double, double);
    public boolean allDifferent$mFc$sp(float, float, float);
    public boolean allDifferent$mIc$sp(int, int, int);
    public boolean allDifferent$mJc$sp(long, long, long);
    public boolean allDifferent$mSc$sp(short, short, short);
    public boolean allDifferent$mVc$sp(scala.runtime.BoxedUnit, scala.runtime.Bo
xedUnit, scala.runtime.BoxedUnit);
}

16.9  Range.foreach方法被注解为@specialized(Unit)。为什么？通过以下命令检查字节码: 


javap -classpath /path/to/scala/lib/scala-library.jar scala.collection.immutable.Range

并考虑Function1上的@specialized注解。点击Scaladoc中的Function1.scala链接进行查看 首先来看Function1的源码

......
trait Function1[@specialized(scala.Int, scala.Long, scala.Float, scala.Double/*, scala.AnyRef*/) -T1, @specialized(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double/*, scala.AnyRef*/) +R] extends AnyRef { self =>
  /** Apply the body of this function to the argument.
   *  @return   the result of function application.
   */
  def apply(v1: T1): R
......

可以看到Function1参数可以是scala.Int,scala.Long,scala.Float,scala.Double，返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double 再来看Range.foreach的源码

...... 
@inline final override def foreach[@specialized(Unit) U](f: Int => U) {
    if (validateRangeBoundaries(f)) {
      var i = start
      val terminal = terminalElement
      val step = this.step
      while (i != terminal) {
        f(i)
        i += step
      }
    }
  }
......

首先此方法是没有返回值的，也就是Unit。而Function1的返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double 如果不限定@specialized(Unit),则Function1可能返回其他类型，但是此方法体根本就不返回，即使设置了也无法获得返回值




16.10  添加assert(n >= 0)到factorial方法。在启用断言的情况下编译并校验factorial(-1)会抛异常。在禁用断言的情况下编译。会发生什么？用javap检查该断言调用 
object Test {
  def factorial(n: Int): Int = {
    assert(n > 0)
    n
  }
  def main(args: Array[String]) {
    factorial(-1)
  }
}



编译报错
Exception in thread "main" java.lang.AssertionError: assertion failed
        at scala.Predef$.assert(Predef.scala:165)
        at Test$.factorial(Test.scala:6)
        at Test$.main(Test.scala:11)
        at Test.main(Test.scala)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)

禁用assert
-Xelide-below 2011

反编译此类javap -c Test$ 得到

......
public int factorial(int);
  Code:
   0:   getstatic       #19; //Field scala/Predef$.MODULE$:Lscala/Predef$;
   3:   iload_1
   4:   iconst_0
   5:   if_icmple       12
   8:   iconst_1
   9:   goto    13
   12:  iconst_0
   13:  invokevirtual   #23; //Method scala/Predef$.assert:(Z)V
   16:  iload_1
   17:  ireturn
......



版权声明：本文为博主原创文章，未经博主允许不得转载。

cJSON库使用教程
CSJON库基本数据格式 cJSON 定义



typedef struct cJSON {  
    struct cJSON *next,*prev;   // 数组 对象数据中用到  
    struct cJSON *child;        // 数组 和对象中指向子数组对象或值  
  
    int type;           // 元素的类型，如是对象还是数组  
  
    char *valuestring;          // 如果是字符串  
    int valueint;               // 如果是数值  
    double valuedouble;         // 如果类型是cJSON_Number  
  
    char *string;               // The item's name string, if this item is the child of, or is in the list of subitems of an object.  
} cJSON; 


构造JSON：
首先创建JSON主对象 

	cJSON* root=cJSON_CreateObject();

类似的创建数组对象

cJSON* array=cJSON_CreateArray();

向对象中增加（字符）节点

cJSON_AddStringToObject(root,"名称","字符串");

向对象中增加对象（字符串、数组、数字）
  cJSON_AddItemToObject(root,"名称",cJSON_CreateString("邝东宇")) ;
  cJSON_AddItemToObject(root,"名称",cJSON_CreateNumber(100))  ;
 
向数组中增加元素（元素类型不一定相同）
cJSON_AddItemToArray(array,cJSON_CreateString("Linux"));
	cJSON_AddItemToArray(array,cJSON_CreateNumber(26));


解析JSON:
首先获取字符串形式的JSON数据，例：存储于char data[1024];
获取JSON对象

cJSON* root=cJSON_Parse(data);获取指定名称的节点指针,


	cJSON* tmp=cJSON_GetObjectItem(root,"name");解析数组，首先按上步获取数组指针 如 cJSON* array


获取数组大小 int size=cJSON_GetArraySize(array);获取数组元素 cJSON* tmp=cJSON_GetArrayItem(array,1);	//下标从0开始



最后释放对象

 cJSON_Delete(root);


根据对象指针获取JSON字符串形式数据

char *data=cJSON_Print(root);




附件cJSON库以及demo源码在本人CSDN资源中获取。 点击下载

版权声明：本文为博主原创文章，未经博主允许不得转载。

算法题：最长上升子序列
题目描述 
广场上站着一支队伍，她们是来自全国各地的扭秧歌代表队，现在有她们的身高数据，请你帮忙找出身高依次递增的子序列。 例如队伍的身高数据是（1、7、3、5、9、4、8），其中依次递增的子序列有（1、7），（1、3、5、9），（1、3、4、8）等，其中最长的长度为4。 
输入描述:
输入包含多组数据，每组数据第一行包含一个正整数n（1≤n≤1000）。
紧接着第二行包含n个正整数m（1≤n≤10000），代表队伍中每位队员的身高。
输出描述:
对应每一组数据，输出最长递增子序列的长度。
输入例子:
7 
1 7 3 5 9 4 8 
6 
1 3 5 2 4 6
输出例子:
4 
4
#include <iostream>
using namespace std;
int main()
{

    int n;
    while(cin>>n)
    {
        int m = n;
        int val;
        int *a = new int[n];
        int k = 0;
        while(m--)
        {
            cin>>val;
            a[k++]=val;
        }
        int max=1;
        int *b = new int[n];
        for(int i=0;i<k;i++)
        {
            b[i]=1;
            for(int j=0;j<i;j++)
            {
                if(a[j]<a[i])
                {
                  if(b[j]+1>b[i])
                  {
                      b[i]=b[j]+1;
                      if(max<b[i])
                                            max=b[i];
                  }  
                }
            }
        }
        cout<<max<<endl;
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA - 11248 Frequency Hopping(网络流＋割)
题目大意：有N个点，M条有向边，每条边都有相应的容量。现在要求你从点1运送东西到点N，运送的量为C 
如果可以运送，输出possible 
如果不能运送，看能不能只增大一条弧，使得运送成功，如果可以的话，输出所有可增大的弧 
如果都不行，另外输出
解题思路：先跑一次最大流，最大流如果大于等于C，就不用括弧了 
如果不行的话，就进行括弧。 
 扩大哪些弧的容量呢。答案是割边的容量，因为最小割==最大流 
 我们先找出所有的割边，如何找割边呢，如果是dinic算法的话，就找到vis[u] == ture 而vis[v] == false 且该边容量大于0的边，这些边就是割边了 
 接着将割边一条一条的扩容，只需要扩大到C的容量就可以了，然后在残余网络上跑最大流就可以了 
 还有一个问题是怎么求残余网络，只需要将所有边的容量减去流量就是残余网络了
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
#define N 1010
#define INF 0x3f3f3f3f

struct Edge{
    int from, to, cap, flow;
    Edge() {}
    Edge(int from, int to, int cap, int flow) : from(from), to(to), cap(cap), flow(flow) {}
};

struct Dinic{
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[N];
    bool vis[N];
    int d[N], cur[N];

    void init(int n) {
        this->n = n;
        for (int i = 0; i <= n; i++) {
            G[i].clear();
        }
        edges.clear();
    }

    void AddEdge(int from, int to, int cap) {
        edges.push_back(Edge(from, to, cap, 0));
        edges.push_back(Edge(to, from, 0, 0));
        int m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    } 

    bool BFS() {
        memset(vis, 0, sizeof(vis));
        queue<int> Q;
        Q.push(s);
        vis[s] = 1;
        d[s] = 0;

        while (!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for (int i = 0; i < G[u].size(); i++) {
                Edge &e = edges[G[u][i]];
                if (!vis[e.to] && e.cap > e.flow) {
                    vis[e.to] = true;
                    d[e.to] = d[u] + 1;
                    Q.push(e.to);
                }
            }
        }
        return vis[t];
    }

    int DFS(int x, int a) {
        if (x == t || a == 0)
            return a;

        int flow = 0, f;
        for (int i = cur[x]; i < G[x].size(); i++) {
            Edge &e = edges[G[x][i]];
            if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0) {
                e.flow += f;
                edges[G[x][i] ^ 1].flow -= f;
                flow += f;
                a -= f;
                if (a == 0)
                    break;
            }
        }
        return flow;
    }

    int Maxflow(int s, int t) {
        this->s = s; this->t = t;
        int flow = 0;
        while (BFS()) {
            memset(cur, 0, sizeof(cur));
            flow += DFS(s, INF);
        }
        return flow;
    }

    void clear() {
        for (int i = 0; i < edges.size(); i++)
            edges[i].flow = 0;
    }

    void remmant() {
        for (int i = 0; i < edges.size(); i++)
            edges[i].cap -= edges[i].flow;
    }

    vector<int> MinCut() {
        vector<int> tmp;
        for (int i = 0; i < edges.size(); i++)
            if (vis[edges[i].from] && !vis[edges[i].to] && edges[i].cap > 0) tmp.push_back(i);
        return tmp;
    }
};

Dinic dinic;
#define M 10010
int n, m, c;
int cas = 1;
struct Cut{
    int u, v;
    bool operator <(const Cut &a) const {
        if (u == a.u)
            return v < a.v;
        return u < a.u;
    }
}cut[M];

int cmp(const Cut &a, const Cut &b) {
    if (a.u == b.u)
        return a.v < b.v;
    return a.u < b.u;
}

void solve() {
    dinic.init(n);
    int u, v, cost;
    for (int i = 0; i < m; i++) {
        scanf("%d%d%d", &u, &v, &cost);
        dinic.AddEdge(u, v, cost);
    }
    printf("Case %d: ", cas++);
    int Maxflow = dinic.Maxflow(1, n);
    if (Maxflow >= c) printf("possible\n");
    else {
        int cnt = 0;
        vector<int> tmp = dinic.MinCut();
        dinic.remmant();
        for (int i = 0; i < tmp.size(); i++) {
            Edge &e = dinic.edges[tmp[i]];
            dinic.clear();
            e.cap = c;
            int ans = dinic.Maxflow(1,n);
            if (ans + Maxflow >= c) { 
                cut[cnt].u  = dinic.edges[tmp[i]].from;
                cut[cnt++].v = dinic.edges[tmp[i]].to;
            }
            e.cap = 0;
        }

        if (cnt == 0)
            printf("not possible\n");
        else {
            sort(cut, cut + cnt);
            printf("possible option:(%d,%d)", cut[0].u, cut[0].v);
            for (int i = 1; i < cnt; i++) printf(",(%d,%d)", cut[i].u, cut[i].v);
            printf("\n");
        }
    }
}

int main() {
    while (scanf("%d%d%d", &n, &m, &c) != EOF && n + m + c) solve();
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ - 1088 滑雪
题目大意：给出一个图，求图上的一条最长的下降路径。
解题思路：很经典的DP，求二维的最长下降子序列。用记忆化的搜索，构造以每个点为起点的最长下降路径，结合DP的状态方程：DP[i][j] = max(DP[i-1][j], DP[i+1][j], DP[i][j-1], DP[i][j+1]) + 1。(if map[i][j] > map[x][y]  && (x,y) in the map)。
#include <cstdio>
#include <algorithm>
using  namespace std;

struct Point {
    int x, y, h;
    bool operator < (const Point a) const {
        return h < a.h;
    }
} A[10010];

int main() {
    int R, C, M[110][110][2];
    int dx[4] = {1, -1, 0, 0};
    int dy[4] = {0, 0, -1, 1};
    while (scanf("%d%d", &R, &C) != EOF) {
        for (int i = 0; i < R; i++)
            for (int j = 0; j < C; j++) {
                scanf("%d", &M[i][j][0]);
                M[i][j][1] = 1;
                A[i*C+j].h = M[i][j][0];
                A[i*C+j].x = i;
                A[i*C+j].y = j;
            }

        sort(A, A + R*C);
        int ans = 1;
        for (int i = 0; i < R*C; i++) {
            int x = A[i].x, y = A[i].y;
            for (int j = 0; j < 4; j++) {
                int xx = x + dx[j], yy = y + dy[j];
                if (xx >= 0 && xx < R && yy >= 0 && yy < C && M[x][y][0] > M[xx][yy][0])
                    M[x][y][1] = max(M[x][y][1], M[xx][yy][1] + 1);
            }
            ans = max(ans, M[x][y][1]);
        }

        printf("%d\n", ans);
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ 题目3966 Aragorn's Story（Link Cut Tree成段加减点权，查询点权）
Aragorn's Story
Time Limit: 10000/3000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 5505    Accepted Submission(s): 1441


Problem Description
Our protagonist is the handsome human prince Aragorn comes from The Lord of the Rings. One day Aragorn finds a lot of enemies who want to invade his kingdom. As Aragorn knows, the enemy has N camps out of his kingdom and M edges connect
 them. It is guaranteed that for any two camps, there is one and only one path connect them. At first Aragorn know the number of enemies in every camp. But the enemy is cunning , they will increase or decrease the number of soldiers in camps. Every time the
 enemy change the number of soldiers, they will set two camps C1 and C2. Then, for C1, C2 and all camps on the path from C1 to C2, they will increase or decrease K soldiers to these camps. Now Aragorn wants to know the number of soldiers in some particular
 camps real-time. 
 

Input
Multiple test cases, process to the end of input.

For each case, The first line contains three integers N, M, P which means there will be N(1 ≤ N ≤ 50000) camps, M(M = N-1) edges and P(1 ≤ P ≤ 100000) operations. The number of camps starts from 1.

The next line contains N integers A1, A2, ...AN(0 ≤ Ai ≤ 1000), means at first in camp-i has Ai enemies.

The next M lines contains two integers u and v for each, denotes that there is an edge connects camp-u and camp-v.

The next P lines will start with a capital letter 'I', 'D' or 'Q' for each line.

'I', followed by three integers C1, C2 and K( 0≤K≤1000), which means for camp C1, C2 and all camps on the path from C1 to C2, increase K soldiers to these camps.

'D', followed by three integers C1, C2 and K( 0≤K≤1000), which means for camp C1, C2 and all camps on the path from C1 to C2, decrease K soldiers to these camps.

'Q', followed by one integer C, which is a query and means Aragorn wants to know the number of enemies in camp C at that time.
 

Output
For each query, you need to output the actually number of enemies in the specified camp.
 

Sample Input

3 2 5
1 2 3
2 1
2 3
I 1 3 5
Q 2
D 1 2 2
Q 1 
Q 3

 

Sample Output

7
4
8
Hint
1.The number of enemies may be negative.

2.Huge input, be careful. 
 

 

Source
2011 Multi-University Training Contest 13 - Host by HIT
 

Recommend
We have carefully selected several similar problems for you:  3965 3962 3963 3967 3968 
 瞬秒一A~~
题目大意：一个图，每个点都有点权，3种操作，I a b,a到b的点点权加一个值，D是减一个值，Q是查询这个点的点权
网上大都是树链剖分写的，提交了俩发现速度并不比我的快，，真的不知道前边300多毫秒的咋写的



#include<stdio.h>           
#include<string.h>       
#include<queue>     
#include<iostream>     
#define INF 0x7fffffff     
#define max(a,b) (a>b?a:b)     
using namespace std;    
int vis[50050];        
struct LCT        
{        
    int bef[50050],pre[50050],next[50050][2],key[50050],add[50050];        
    void init()        
    {        
        memset(pre,0,sizeof(pre));        
        memset(next,0,sizeof(next));  
        memset(key,0,sizeof(key));
        memset(add,0,sizeof(add));
    }      
    void pushdown(int x)
    {
        if(add[x])
        {
            int a,b;
            a=next[x][0];
            b=next[x][1];
            if(a)//不用加，实际上，同下边那个b<span id="transmark"></span>
            {
                add[a]+=add[x];
                key[a]+=add[x];
            }
            if(b)
            {
                add[b]+=add[x];
                key[b]+=add[x];
            }
            add[x]=0;
        }
    }
    void rotate(int x,int kind)        
    {        
        int y,z;        
        y=pre[x];        
        z=pre[y];
        pushdown(y);
        pushdown(x);
        next[y][!kind]=next[x][kind];        
        pre[next[x][kind]]=y;        
        next[z][next[z][1]==y]=x;        
        pre[x]=z;        
        next[x][kind]=y;        
        pre[y]=x;        
    }        
    void splay(int x)        
    {        
        int rt;        
        for(rt=x;pre[rt];rt=pre[rt]);        
        if(x!=rt)        
        {        
            bef[x]=bef[rt];        
            bef[rt]=0;  
            pushdown(x);
            while(pre[x])        
            {        
                if(next[pre[x]][0]==x)        
                {        
                    rotate(x,1);        
                }        
                else      
                    rotate(x,0);        
            }         
        }        
    }        
    void access(int x)        
    {        
        int fa;        
        for(fa=0;x;x=bef[x])        
        {        
            splay(x); 
            pushdown(x);
            pre[next[x][1]]=0;        
            bef[next[x][1]]=x;        
            next[x][1]=fa;        
            pre[fa]=x;        
            bef[fa]=0;        
            fa=x;         
        }        
    }        
    void change(int x,int y,int val)    
    {    
       access(y);    
        for(y=0;x;x=bef[x])    
        {    
            splay(x);    
            if(!bef[x])    
            {    
                 key[x]+=val;
                 key[y]+=val;
                 key[next[x][1]]+=val;
                 add[next[x][1]]+=val;
                 add[y]+=val;
                 return;
            }   
            pushdown(x);
            pre[next[x][1]]=0;    
            bef[next[x][1]]=x;    
            next[x][1]=y;    
            pre[y]=x;    
            bef[y]=0;    
            y=x;       
        }       
    }    
    int query(int x)    
    {    
       splay(x);
       return key[x];
    }    
}lct;    
struct s    
{    
    int u,v,next;    
}edge[100020<<1];    
int head[100020],cnt;    
void add(int u,int v)    
{    
    edge[cnt].u=u;    
    edge[cnt].v=v;    
    edge[cnt].next=head[u];    
    head[u]=cnt++;    
}    
void bfs(int u)       
{                     
    queue<int>q;            
    memset(vis,0,sizeof(vis));            
    vis[u]=1;            
    q.push(u);            
    while(!q.empty())            
    {                
        u=q.front();                
        q.pop();                
        for(int i=head[u];i!=-1;i=edge[i].next)                
        {                    
            int v=edge[i].v;                    
            if(!vis[v])                    
            {                        
                lct.bef[v]=u;                                      
                vis[v]=1;                        
                q.push(v);                    
            }                
        }            
    }        
}  
int main()
{
    int n,m,q;
    while(scanf("%d%d%d",&n,&m,&q)!=EOF)
    {
        int i;
        lct.init();
        cnt=0;
        memset(head,-1,sizeof(head));
        for(i=1;i<=n;i++)
        {
            scanf("%d",&lct.key[i]);
        }
        for(i=0;i<m;i++)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            add(u,v);
            add(v,u);
        }
        bfs(1);
        while(q--)
        {
            char op[2];
            scanf("%s",op);
            if(op[0]=='I')
            {
                int x,y,val;
                scanf("%d%d%d",&x,&y,&val);
                lct.change(x,y,val);
            }
            else
                if(op[0]=='D')
                {
                    int x,y,val;
                    scanf("%d%d%d",&x,&y,&val);
                    lct.change(x,y,-val);
                }
                else
                    if(op[0]=='Q')
                    {
                        int x;
                        scanf("%d",&x);
                        printf("%d\n",lct.query(x));
                    }
        }
    }
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

SPOJ VLATTICE Visible Lattice Points (莫比乌斯反演基础题)

Visible Lattice Points




Consider a N*N*N lattice. One corner is at (0,0,0) and the opposite one is at (N,N,N). How many lattice points are visible from corner at (0,0,0) ? A point X is visible from point Y iff no other lattice point lies on the segment
 joining X and Y. 
 
Input : 
The first line contains the number of test cases T. The next T lines contain an interger N
 
Output : 
Output T lines, one corresponding to each test case. 
 
Sample Input : 
3 
1 
2 
5 
 
Sample Output : 
7 
19 
175 
 
Constraints : 
T <= 50 
1 <= N <= 1000000






Added by:
Varun Jalan


Date:
2010-07-29


Time limit:
1.368s


Source limit:
50000B


Memory limit:
1536MB


Cluster:
Cube (Intel Pentium G860 3GHz)


Languages:
All except: NODEJS objc PERL 6 VB.net 


Resource:
own problem used for Indian ICPC training camp







题目链接：http://www.spoj.com/problems/VLATTICE/en/


题目大意：求在(0,0,0)到(n,n,n)这个立方体里从(0,0,0)能看到多少个点


题目分析：(2,2,2)就看不到，因为被(1,1,1)挡住了，做过能量采集的都知道，就是求gcd(a, b, c) = 1的组数，其中1 <= a, b, c <= n，裸的莫比乌斯反演题，注意两点，三个数轴上还有三点(0, 0, 1)，(0 ,1, 0)，(1, 0, 0)，另外xoy面，yoz面，xoz面，三个面上还有一些点，这些都要单独算，然后再加上立方体中不包括轴和面的点，分块求和优化10ms解决


#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
int const MAX = 1000005;
int mob[MAX], p[MAX], sum[MAX];
bool noprime[MAX];

int Min(int a, int b, int c)
{
    return min(a, min(b, c));
}

void Mobius()
{
    int pnum = 0;
    mob[1] = 1;
    sum[1] = 1;
    for(int i = 2; i < MAX; i++)
    {
        if(!noprime[i])
        {
            p[pnum ++] = i;
            mob[i] = -1;
        }
        for(int j = 0; j < pnum && i * p[j] < MAX; j++)
        {
            noprime[i * p[j]] = true;
            if(i % p[j] == 0)
            {
                mob[i * p[j]] = 0;
                break;
            }
            mob[i * p[j]] = -mob[i];
        }
        sum[i] = sum[i - 1] + mob[i];
    }
}

ll cal(int l, int r)
{
    if(l > r)
        swap(l, r);
    ll ans = 0;
    for(int i = 1, last = 0; i <= l; i = last + 1)
    {
        last = min(l / (l / i), r / (r / i));
        ans += (ll) (l / i) * (r / i) * (sum[last] - sum[i - 1]);
    }
    return ans;
}

ll cal(int l, int m, int r)
{
    if(l > r)
        swap(l, r);
    if(l > m)
        swap(l, m);
    ll ans = 0;
    for(int i = 1, last = 0; i <= l; i = last + 1)
    {
        last = Min(l / (l / i), m / (m / i), r / (r / i));
        ans += (ll) (l / i) * (m / i) * (r / i) * (sum[last] - sum[i - 1]);
    }
    return ans;
}

int main()
{
    Mobius();
    int T;
    scanf("%d", &T);
    while(T --)
    {
        int n;
        scanf("%d", &n);
        ll ans = 3;
        ans += (ll) cal(n, n, n);
        ans += (ll) cal(n ,n) * 3;
        printf("%lld\n", ans);
    }
}









版权声明：本文为博主原创文章，未经博主允许不得转载。

Java模拟公司置办货物系统（二）

采用MVC风格，将数据写入文件，模拟公司置办货物系统。 
A类表示普通员工，B类表示部门精力，C类表示采购部，D类表示资源管理部。
订单状态 1.表示申请状态 2.表示通过审批 3.表示未通过审批 4.表示订单完成，购物完成
第三步：创建Po类，代表采购部批准的订单类.


package com.jereh14;

public class Po implements java.io.Serializable{

    public int getPor_no() {
        return por_no;
    }
    public void setPor_no(int por_no) {
        this.por_no = por_no;
    }
    public String getPart_desc() {
        return part_desc;
    }
    public int getPo_no() {
        return po_no;
    }
    public void setPo_no(int po_no) {
        this.po_no = po_no;
    }
    public double getPrice() {
        return price;
    }
    public void setPrice(double price) {
        this.price = price;
    }
    public String getComp() {
        return comp;
    }
    public void setComp(String comp) {
        this.comp = comp;
    }
    public String getOrd_date() {
        return ord_date;
    }
    public void setOrd_date(String ord_date) {
        this.ord_date = ord_date;
    }
    public String getOrd_emp() {
        return ord_emp;
    }
    public void setOrd_emp(String ord_emp) {
        this.ord_emp = ord_emp;
    }
    public void setPart_desc(String part_desc) {
        this.part_desc = part_desc;
    }
    public String getPart_type() {
        return part_type;
    }
    public void setPart_type(String part_type) {
        this.part_type = part_type;
    }
    public int getCount() {
        return count;
    }
    public void setCount(int count) {
        this.count = count;
    }

    public String getPnd() {
        return pnd;
    }
    public void setPnd(String pnd) {
        this.pnd = pnd;
    }

    public int getStus() {
        return stus;
    }
    public void setStus(int stus) {
        this.stus = stus;
    }

    private int po_no;
    private int por_no;
    private String part_desc;
    private String part_type;
    private int count;
    private double price;
    private String comp;
    private String pnd;
    private String ord_date;
    private String ord_emp;
    private int stus;

}

定义PoBiz类，实现购买的物品入库方法.


package com.jereh14;

import java.io.*;
import java.util.*;

public class PoBiz {

private List<Po> list = new ArrayList<Po>();

    public void addPo(Po po){

        readDb();
        list.add(po);
        writeDb();
    }
    public void showPo(){

        readDb();
        Iterator<Po> i = list.iterator();
            while(i.hasNext()){
                Po p = i.next();
                System.out.println(p.getPo_no()+"\t"+p.getPor_no()+"\t"+p.getPart_desc()+"\t"+p.getPart_type()+"\t"+
                        p.getCount()+"\t"+p.getPrice()+"\t"+p.getStus()+"\t"+p.getComp()+"\t"+p.getPnd()+"\t"+p.getOrd_date()+"\t"+
                        p.getOrd_emp());
            }
        writeDb();
    }

    public boolean check(int por_no){
        Iterator<Po> i = list.iterator();
        boolean bool = false;
        while(i.hasNext()){
            Po p = i.next();
            if(p.getPor_no() == por_no){
                bool = true;
                break;
            }else{
                bool = false;
            }
        }
        return bool;
    }

    public void readDb(){

        FileInputStream fis  = null;
        ObjectInputStream is = null;
        try {
            fis = new FileInputStream("F:\\test\\Po.txt");
            is = new ObjectInputStream(fis);
            list = (List<Po>) is.readObject();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

    }

    public void writeDb(){

        FileOutputStream fos  = null;
        ObjectOutputStream os = null;
        try {
            fos = new FileOutputStream("F:\\test\\Po.txt");
            os  = new ObjectOutputStream(fos);
            os.writeObject(list);
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                os.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}
定义PoView类，用于采购部确定经过审批的界面，订单状态变为4。


package com.jereh14;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class PoView {

    private int i = 0;
    public void showInfoView(){

        Scanner scn = new Scanner(System.in);
        PorBiz pb   = new PorBiz();
        PoBiz  pbz  = new PoBiz();
        Po po = null;
        Por por = null;


        System.out.println("=======================================订单审批=======================================\n");
        System.out.println("编号\t名称\t型号\t数量\t用途\t需要日期\t申请日期\t状态\t申请者\t批准日期\t审核者\n");
        pb.showPor(3);
        while(true){

            System.out.println("\n******************************1、选单订货\t\t2、退出*******************************");
            System.out.print("请选择您的操作：");
            int chooseNum = scn.nextInt();
            int porId = -1;
            switch(chooseNum){
            case 1:
                System.out.print("请输入您要操作的单号：");
                porId = scn.nextInt();
                if((por=pb.getPor(porId))!=null){
                    System.out.print("请输入订货数量：");
                    int por_num = scn.nextInt();
                    System.out.print("请输入单价：");
                    double price = scn.nextDouble();
                    System.out.print("请输入供应商：");
                    String comp = scn.next();

                    Date date = new Date();
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM");
                    po = new Po();
                    po.setPo_no(i++);
                    po.setPor_no(por.getPor_no());
                    po.setPart_desc(por.getPart_desc());
                    po.setPart_type(por.getPart_type());
                    po.setCount(por_num);
                    po.setPrice(price);
                    po.setComp(comp);
                    po.setPnd(por.getPnd());
                    po.setOrd_date(sdf.format(date));
                    po.setOrd_emp(por.getRgdt_emp());
                    po.setStus(4);

                    pbz.addPo(po);
                    pb.changeStuts(porId, 3);
                    if(pb.check(porId)){
                        System.out.println("--添加成功！--");
                    }else{
                        System.out.println("--添加失败！--");
                    }
                }else{
                    System.out.println("--该订单不存在！--\n");
                }
                break;
            case 2:
                System.exit(0);
                System.out.println("谢谢您的使用!");
                break;
                default:
                    System.out.println("--输入有误！--");
                    break;
            }
        }
    }
}

定义PoCfView类，用来仓库物品查询.


package com.jereh14;

import java.util.Scanner;

public class PoCfView {

    public void showInfoView(){
        Scanner scn = new Scanner(System.in);
        PorBiz pb   = new PorBiz();
        PoBiz  pbz  = new PoBiz();

        while(true){
            System.out.println("=======================================仓库查询=======================================\n");
            System.out.println("========================请选择您的操作：1、查看仓库\t\t2、退出======================");
            int chooseNum = scn.nextInt();
            switch(chooseNum){
            case 1:
                System.out.println("\n订货编号\t申请编号\t名称\t型号\t数量\t单价\t状态\t供应商\t需要日期\t订货日期\t订货者\n");
                pbz.showPo();
                System.out.println("\n************************************************************************************");               break;
            case 2:
                System.out.println("谢谢您的使用！");
                System.exit(0);
                break;
                default:
                    System.out.println("--输入有误！--");
                    break;
            }
        }
    }

}
运行效果图：
第四歩：定义Test类将各个View组合起来。


package com.jereh14;

import java.util.Scanner;

public class Test {

    public static void main(String[] args){

        Scanner scn      = new Scanner(System.in);
        EmployeerBiz elb = new EmployeerBiz();
        EmployeerView elv = new EmployeerView();
        PorView prv       = new PorView();
        PorCfView pcv    = new PorCfView();
        PoCfView pfv      = new PoCfView();
        PoView pv        = new PoView();


        System.out.println("==========================欢迎来到大冰公司===========================");
        while(true){    
            System.out.print("\n\t\t\t请输入工号：");
            int userId = scn.nextInt();
            System.out.print("\t\t\t请输入密码：");
            String password = scn.next();
            String type = elb.searchPor(userId, password);
            if(type!=null){
                char ch = type.charAt(0);
                switch(ch){
                case 'A':
                    System.out.println("\n经检测，你的身份是普通员工，可以进行订单申请\n");
                    prv.porView();
                    break;
                case 'B':
                    System.out.println("\n经检测，你的身份是部门经理,可以进行订单处理\n");
                    pcv.showInfoView();
                    break;
                case 'C':
                    System.out.println("\n经检测，你的身份是采购部人员，可以将批准的订单\n");
                    pv.showInfoView();
                    break;
                case 'D':
                    System.out.println("\n经检测，你的身份是资源管理部人员\n");
                    pfv.showInfoView();
                    break;
                    default:
                        break;
                }
            }else if(userId==0&&password.equals("0")){
                System.out.println("\n经检测您是尊贵的管理员\n");
                elv.empView();
            }else{
                System.out.println("你不是本公司员工！");
            }
        }
    }
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

leetcode： Binary Tree Postorder Traversal

Given a binary tree, return the postorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3},

   1
    \
     2
    /
   3




return [3,2,1].

Note: Recursive solution is trivial, could you do it iteratively?

题目表述：

二叉树的后序遍历。先访问左子树，再访问右子树，最后访问根节点。

代码实现：

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
    vector<int> re;
    const TreeNode *p;//表示正在访问的节点
    const TreeNode *q;//表示访过节点
    p=root;
    stack<const TreeNode *>s;
    do
    {
        while(p!=NULL)
        {
            s.push(p);
            p=p->left;//表示往左子走；
        }
        q=NULL;
        while(!s.empty())
        {
            p=s.top();
            s.pop();
            if(p->right==q)
            {
                re.push_back(p->val);
                q=p;
            }
            else
            {
                s.push(p);
                p=p->right;
                break;
            }
        }
        }while(!s.empty());
        return re;
    }
};

版权声明：本文为博主原创文章，未经博主允许不得转载。

05==数组(查找,添加,删除,排序)
// int a
// int a[65]
/*

 1:数组:同类型的一组数,在类存上连续分布

 定义数组

 类型 
数组名[数组元素的个数];
 int score[65];//里面有65个int类型的数据,并且连续分布
 占有的内存=sizeof(类型)*元素个数

 引用数组的元素:数组名[下标],数组的下标从0开始

 数组元素不能越界访问

 

 数组定义后未初始化,里面的内容随机,是不确定的,不能用

 

 数组的下标必须是常量,不可以为变量
 例如 
 int len = 5;
 int a[len] = {1,2,3,4,5};//事件错误的

 
 */




#include <stdio.h>
#include <string.h>

int main(int argc, const char * argv[]) {

    int a[5];//元素a[0]~a[4],可以通过a[i]来访问元素
    printf("a[0]=%d\n",a[0]);
    
    //遍历:挨个访问
    for (int i = 0; i<5; i++)
    {
        printf("a[%d]=%d\n",i,a[i]);
    }
    a[4] = 100;//通过下标,设置数组元素
   return 0;
}

#include <stdio.h>
#include <string.h>











//int main()
//{
//    int a[5] = {1,2,3,4,5};//完全初始化,用集合的方式,给每个元素赋值

//   // a = {1,2,3,4,5};// 
除了初始化,不可以给数组元素以集合方式进行集体赋值;
//    int b[5] = {1,0,0,0,0};//完全初始化
//    int c[5] = {1};//和b[5]是等价的,后面的0是可以省略的.叫做部分初始化
//    int d[5] = {};//部分初始化,所有元素都是0,跟不带"="的不一样,
//    int e[ ] = {1,2,3,4,5};
//    int f[ ] = {1};
//    int g[ ] = {};
//    printf("sizeof(d)=%lu\n",sizeof(d));//sizeof(d)=20,他与里面是否存储内容没有关系.
//    printf("sizeof(e)=%lu\n",sizeof(e));//sizeof(e)=20,定义时省略数组的下标,是完全初始化;
//    printf("sizeof(f)=%lu\n",sizeof(f));//sizeof(f)=4,一个元素完全初始化.
//    printf("sizeof(g)=%lu\n",sizeof(g));//sizeof(g)=0,0个元素,完全初始化,不能使用,没有存储空间
//    for (int i = 0 ; i<5; i++)
//    {
//        printf("d[%d]=%d\n",i,d[i]);
//    }
//    return 0;
//}



//int main()
//{
//    int len = 5;
//    int a[5] = {1,2,3,4,5};
//    int a[len] = {1,2,3,4,5} //错误的示范
//    
//}



//int main()
//{

//    double score[5] = {};//score保存的是数组的首个元素地址.数组名是常量,数组元素才是变量,
//    double sum = 0;
//    printf("请输入五位学生成绩\n");
//    for (int i = 0 ; i<5; i++)//编译器是不能检查越界错误    for(int i = 0 ; i<80; i++)
//    {
//        scanf("%lf",&score[i]);
//        sum += score[i];
//    }
//    printf("学生成绩平均值是:%.2lf",sum/5);
//}



//int main()
//{
//    int a[5];
//    int a[5] = {43,54,32,21,7};
//    printf("请输入五个数\n");
//    for (int i = 0 ; i<5; i++)
//    {
//        scanf("%d",&a[i]);
//    }
//    printf("数组元素为:   ");
//    for (int i = 0 ; i<5; i++)
//    {
//        printf("%3d   ",a[i]);
//    }
//    printf(" \n");









//    for (int i = 0 ; i<5-1; i++)
//    {
//        for (int j = i+1 ; j<5; j++)
//        {
//            if (a[i]>a[j])
//            {
//                int temp = a[i];
//                a[i] = a[j];
//                a[j] = temp;
//            }
//        }
//        printf("第%d次打印结果",i+1);
//        for (int i = 0 ; i<5; i++)
//        {
//            printf("%3d   ",a[i]);
//        }
//        printf("\n");
//    }
//    printf("排序后打印结果");
//    for (int i = 0 ; i<5; i++)
//    {
//        printf("%3d   ",a[i]);
//    }

    
    /*
    
冒泡排序法
     */



//    for (int i = 0 ; i<5-1; i++)
//    {
//        for (int j = 0 ; j<5-i-1; j++)
//        {
//            if (a[j]>a[j+1])
//            {
//                int temp = a[j];
//                a[j] = a[j+1];
//                a[j +1] = temp;
//            }
//        }
//        printf("第%d次打印结果",i+1);
//        for (int i = 0 ; i<5; i++)
//        {
//            printf("%3d   ",a[i]);
//        }
//        printf("\n");
//    }
//    printf("排序后打印结果");
//    for (int i = 0 ; i<5; i++)
//    {
//        printf("%3d   ",a[i]);
//    }
//}



//输出1 1 2 3 5 8 13 21 34 55
//a[i]=a[i-1]+a[i-2]






//int main()
//{
//    int a[20] = {};
//    //求数组的元素
//    for (int i = 0; i<20; i++)
//    {
//        if(i==0 || i==1)
//        {
//            a[i]=1;
//        }
//        else
//        {
//            a[i]=a[i-1]+a[i-2];
//        }
//        printf("%d  ",a[i]);//正序打印
//    }
//    printf("\n");
//    //逆序打印
//    for (int i = 19; i>=0; i--)
//    {
//        printf("%d  ",a[i]);
//    }
//}






/*

 数组常用的操作:
 查找,
 */



//int main()
//{

//    //在分数数组里查找是否有60分,找到第一个就结束
//    int score[5] = {12,45,60,78,60},number = 60,count = 0;
//    int i;
//    for (i = 0; i<5; i++)
//    {
//        if (score[i] == number)//把所有符合条件的值都遍历出来
//        {
//            printf("score[%d]的成绩符合条件\n",i);
//            count++;//如果有符合的元素就记录一下;
//            continue;
//        }
//    }
//    if (count == 0)//如果遍历真个数组没有符合要找的元素
//    {
//        printf("没有符合条件的值");
//    }
//    return 0;
//}



//int main()
//{
//    int score[] = {12,45,60,78,60,78},max=score[0],count=0,min=score[0],j=0;//max记录最大数字,count记录最大数的角标;
//    for(int i=1;i<6;i++)
//    {
//        if (max<score[i])
//        {
//            max = score[i];//max记录最大数;
//            count = i;
//        }
//        if(min>score[i])
//        {
//            min = score[i];
//            j = i;
//        }
//    }
//    for(int m=0;m<6;m++)//把所有的相同的最大数全部打印出来
//    {
//        if (max == score[m])
//        {
//            printf("\n最大数值是score[%d]=%d",m,max);
//        }
//    }
//    printf("\n最小数值是score[%d]=%d",j,min);
//}



/*

 插入和删除
 有序序列 int a[10] ={23,45,60,88,98};

 删除一个元素60
 删除前 int a[10] ={23,45,60,88,98};
 删除后 int a[10] ={23,45,88,98};
 */
//int main()
//{
//    int a[10] ={23,45,60,88,98},valid = 5;//当前有效的元素个数,人为认为有效
//    int value = 60;
//    int pos = 2;//需要删除的元素的下标
    //1,后面的元素前移
    //待移动a[pos+1],最后一个元素a[valid-1]
    //前移 
用前面的元素来接收 a[i-1]=a[i]

    //2,清理最后一个元素残留拷贝
//    for (int i=0; i<valid ; i++)
//    {
//        if (a[i] == value )//查找是否有需要删除的元素,如果有记录当前元素的下标
//        {
//            pos = i;
//        }
//    }
//    for(int i=pos;i<valid;i++)//定义从记录位置到数组末尾
//    {
//        a[i] = a[i+1];//记录位置之后开始依次赋值给前面的元素
//        if (i == valid-1)//当元素到最后的一个位置时,需要清除最后一个元素值
//        {
//            a[i]=0;
//        }
//    }
//    for (int i=0; i<10; i++)
//    {
//        printf("%d ",a[i]);
//    }
//




    
//    for (int i=pos+1; i<valid;i++)
//    {
//        a[i-1]=a[i];
//    }
//    for (int i=0; i<10; i++)
//    {
//        printf("%d ",a[i]);
//    }
//}









/*
 
有序序列 int a[10] ={23,45,60,88,98};
 插入 65
 插入前  int a[10] ={23,45,60,88,98};
 插入后  int a[10] ={23,45,60,65,88,98};
 */



//int main()
//{
//    int a[10] ={23,45,60,88,98},valid = 5;
//    int pos = 0;//用来记录插入的下标
//    int value = 65;//用来记录需要插入的数字
//    for (int i=0; i<5; i++)
//    {
//        if (a[valid-1]<value)//判断是否需要插入的元素比数组所有元素大
//        {
//            pos=valid;
//            a[pos]=value;
//        }
//        if (a[i]>=value)//用来查找value插入的位置,并记录
//        {
//            pos = i;
//            break;//当找到这个元素后退出for循环;
//        }
//    }
//    for (int i=valid-1; i>=pos; i--)//需要移动的边界,右边界为valid-1,左边界为pos
//    {
//        a[i+1]=a[i];//把当前的有效元素移动到后一位
//    }

//    a[pos]=value;//原来左边界位置已经移动,直接将需要插入的元素赋值即可
//    for (int i=0; i<10; i++)
//    {
//        printf("%d ",a[i]);
//    }
//}



/*

 字符数组:数组里存储的是字符
 int a[10]
 char str[100]
 */
//int main()
//{
//    char str[100];//字符数组,里面有100个char;只定义没有初始化,里面的字符是不确定的
//    char str1[10] = {};//部分初始化,全0
//    char str2[10] = {'h','e','l','l','o'};//前面是hello
后面是'\0'=0;
//    char str3[10] = "hello";//和上面是等价的,用一个常量字符串来初始化字符数组,部分初始化,
//    char str4[] = "hello";//完全初始化,sizeof(str4)=6,系统给字符串加上一个结束符{'h','e','l','l','o','\0'};
//    //for循环遍历数组的元素
//    printf("sizeof(str4)=%lu\n",sizeof(str4));
//    for (int i=0; i<10; i++)
//    {
//        printf("str3[%d]=%c \n",i,str3[i]);
//    }
//    return 0;
//}






/*

 sizeof() 运算符
存储的概念,数据类型或者表达式,数据在内存中占有的字节数,与里面存储的内容没有关系

 strlen() 字符串处理函数 
表示字符串的有效长度,从首地址开始到'\0'结束;'\0'不是有效字符,不统计;头文件<string.h>,与当前字符串中存储的字符(内容)有关系.
 */
//int main()
//{
//    char str[10]="hello";
//    char str1[10]="hello\0abc";
//    char str2[]="hello";
//    for(int i=0;i<10;i++)
//    {
//        printf("str1[%d]=%c\n",i,str1[i]);
//    }
//    printf("%s\n",str1);//从str地址开始,打印到'\0'结束;
//    printf("sizeof(str2)=%lu\n",sizeof(str2));
//    printf("strlen(str2)=%lu\n",strlen(str2));
//    printf("sizeof(str1)=%lu\n",sizeof(str1));
//    printf("strlen(str1)=%lu\n",strlen(str1));
//}



/*
 练习:char str[100]= "hello";中的l替换成L
 */






//int main()
//{
//    char str[100]= "hello";
//    for(int i=0;i<strlen(str);i++)
//    {
//        if(str[i] == 'l')
//        {
//            str[i] = str[i]-32;
//        }
//    }
//    printf("%s",str);
//}






//int main()
//{
//    int a[10]={23,45,600,88,90};
//    int number = 600;//待插入的数据
//    int pos=5;//插入的位置,默认插入到最后
//    for(int i=0;i<5;i++)
//    {
//        if(a[i]>number)
//        {
//            pos = i;//pos=第一个比number大的数的位置
//            break;
//        }
//    }
//    printf("pos=%d\n",pos);
//}






//int a[5]={60,23,90,88,45}
/*

 选择排序:每一次从待排序的数据元素中选出最小(或最大的)大一个元素,存放在序列的起始位置,直到全部待排序的数据排完

 通过交换把最小的元素放到前面

 
待排序: 60,23,90,88,45
 第一次:23],60,90,88,45.  i=0.无序数列从开始到最后结束a[0]~a[4],选出最小的数,放在a[0]位置
 第二次:23,45],90,88,60//第二次直接从23之后开始对比,23不需要参加排序
 i=1.无序数列从a[1]~a[4],选出最小的数,放在a[1]位置
 第三次:23,45,60],88,90   i=2.无序数列从a[2]~a[4]
 第四次:23,45,60,88],90

 

 N个元素的无序数组,每次排序拿出一个添加到有序数组,N-1次排序,剩下一个必然是有序的
 i从0开始,每次无序数列a[i]~a[4],选出最小的放在a[i]位置
 */









//int main()
//{
//    int a[5]={60,23,90,88,45};
//    int len = sizeof(a)/sizeof(a[0]);//数组中元素个数
//    int k;
//    int temp;
//    for(int i=0;i<len-1;i++)
//    {
//        k = i;//a[k]是当前最小的数,
//        for (int j=i+1; j<len; j++)
//        {
//            //a[k] a[j]
相比,如果a[j]更小,更新k=j
//            if (a[j]<a[k])
//            {
//                k = j;
//            }
//        }
//        //把a[k]放到a[i]的位置,交换
//        if(k != i)
//        {
//            temp = a[k];
//            a[k] = a[i];
//            a[i] = temp;
//        }
//    }
//    for (int i=0; i<len; i++)
//    {
//        printf("%d ",a[i]);
//    }
//}






/*
 int a[5]={60,23,90,88,45};

 冒泡排序:从左往右,依次捉对,如果前面的数比后面的数大,就交换
 待排序: 60,23,90,88,45
 第一对: [23,60],90,88,45
 第二对: 23,[60,90],88,45
 第三对: 23,60,[88,90],45

 第四对: 23,60,88,[45,90]-->经过一次排序(4对),把最大的数传到了最后面;产生一个有序数,在最后面;每次产生一个最大的数,放在后面有序数列

 

 N个数的数组,N-1次排序,有序数列有N-1,剩下一个必然是最小的;

 
 第一次捉了4=len-1对
 a[0]~a[len-1]捉对
 第二次 i=1
 a[0]~a[len-1-1]捉对
 第i次
 a[0]~a[len-1-i]
一共捉len-1-i对

 
 */






//
//int main()
//{
//    int a[5]={60,23,90,88,45};
//    int len = sizeof(a)/sizeof(a[0]);//数组中元素个数
//    for(int i=0;i<len-1;i++)
//    {
//        for (int j=i; j<len; j++)
//        {
//            if (a[i]>a[j])
//            {
//                int temp = a[i];
//                a[i] = a[j];
//                a[j] = temp;
//            }
//        }
//    }
//    for (int i=0; i<len; i++) {
//        printf("%d ",a[i]);
//    }
//}



//int main()
//{
//    int a[5]={60,23,90,88,45};
//    int len = sizeof(a)/sizeof(a[0]);//数组中元素个数
//    for(int i=0;i<len-1;i++)//需要排序的次数
//    {
//        //无序数列a[0]~a[len-1-i],去两两捉对比较
//        for(int j=0;j<len-1-i;j++)
//        {
//            //a[j]和a[j+1]对比
//            if(a[j]>a[j+1])
//            {
//                int temp = a[j];
//                a[j] = a[j+1];
//                a[j+1] =temp;
//            }
//        }
//    }
//    for (int i=0; i<len; i++)
//    {
//        printf("%d ",a[i]);
//    }
//}



/*

 二维数组:数据的矩阵;
 a[2][3] 2行3列
 int a[2][3];定义
 第一行: {a[0][0],a[0][1],a[0][2];//i=0} = a[0]数组
 第二行: {a[1][0],a[1][1],a[1][2];//i=1} = a[1]数组

 二维数组可以看成是一维数组的数组(行数组)
 */



//int main()
//{
////    int a[2][3] = {1,2,3,4,5,6};//完全初始化;
////    int a[2][3] = {{1,2,3},{4,5,6}};//和上面等价;
////    int b[2][3] = {{1},{2,5}};
//    int c[ ][3] = {1,2,3,4,5,6};//二维数组的省略形式,可以省略行,但是列必须有,告诉系统每行元素个数;
//    //遍历访问
//    for(int i=0;i<2;i++)
//    {
//        for(int j=0;j<3;j++)
//        {
//            printf("c[%d][%d]=%d ",i,j,c[i][j]);
//        }
//        printf("\n");
//    }
//}




/*输出杨辉三角

 

 请输入行数:7
 1
 1
1
 1
2 1
 1
3 3 
1
 1
4 6 
4 1
 1
5 10 
10 5 1
 1
6 15 
20 15 6
1
 */
//int main()
//{
//    int a[20][20]={0};
//    int n;
//    printf("请输入行数:");
//    scanf("%d",&n);
//    for(int i=0;i<n;i++)//行数
//    {
//        for(int j=0;j<=i;j++)//列数
//        {
//            if ((i == j) || (j == 0))//每行的开始,结束赋值为1
//            {
//                a[i][j] = 1;
//            }
//            else
//            {
//                a[i][j] = a[i-1][j] + a[i-1][j-1];//结果为上一行对应前两位的数之和
//            }
//            printf("%d \t",a[i][j]);
//        }
//        printf("\n");
//    }
//}



//int main()
//{
//    char str[100] = {};//一维的字符数组,可以存储一个字符串,有效字符数99,要预留结束符
//    char str1[5] = {};//接收4个有效字符;非常容易出界,不要使用
//    printf("请输入一个字符串\n");
//    scanf("%s",str1);//接收字符串,但是容易越界,例如输入:wwwwwwwww;输出结果是wwwwwwwww;
//    printf("%s",str1);//str1首地址开始,打印到'\0'结束;
//    
//}



//练习: char str[5][10]
接收5个字符串
/*

 char str[5][10] 二维数组,5个行数组的数组,每个行数组最多接收99个有效字符
 5个行数组: str[0],str[1],...,str[4]
 */
int main()
{
    char str[5][100] = {};
    for(int i=0;i<5;i++)
    {
        printf("请输入一个字符串:\n");
        scanf("%s",str[i]);//str[i]是个数组,就是str[i][0]的地址,元素str[i][0]~str[i][0]===========>多理解数组地址????
    }
    for(int i=0;i<5;i++)
    {
        printf("%s\n",str[i]);
    }
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 3939-Sticks and Right Triangle(毕达哥拉斯三元组+欧拉函数)
题目地址：HDU 3939 
题意：给出勾股方程X^2+Y^2=Z^2，满足X,Y,Z不超过L，问存在多少个解满足X,Y,Z两两互素。 
思路：其实就是求有多少个毕达哥拉斯本原三元组，因为数据很大，所以不能像上一道题一样，直接暴力枚举。那下面我们来分析一下： 
由X^2+Y^2+Z^2我们可以知道，方程的解为X=m^2-n^2，Y=2*m*n，Z=m^2+n^2，其中m>n，m与n一奇一偶，且gcd(m,n)=1。由式子我们可以知道Z最大，这样只需要Z=m^2+n^2<=L即可。所以我们可以确定一下m和n的大体范围，m<=sqrt(L) ;n<=sqrt(l-m*m)=Nmax。 
1）当m为偶数,此时n为奇数： 
1.如果m<=Nmax，那么n的取值就是[1,m)中与m互素的数的个数(m的欧拉函数值)； 
2.如果m>Nmax，对m进行素因子分解，然后通过容斥原理来计算[1,Nmax)内与m互素的个数。 
2）当m为奇数时，此时n为偶数： 
1.如果m<=Nmax，那么n的选择就是[1,m/2)内与m互素的数的个数（这样我们乘以2以后得到的就一定是偶数了）； 
2.如果m>Nmax，那么n的选择就是[1,Nmax/2)内与m互素的个数。
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <bitset>
#pragma comment(linker, "/STACK:102400000,102400000")
using namespace std;
typedef __int64 LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
using namespace std;
const int Maxn=1e6+10;
bitset<Maxn>pri;
LL prime[Maxn];
LL sprime[Maxn];
LL phi[Maxn];
LL k,cnt;
void is_prime()
{
    pri.set();
    for(LL i=2; i<Maxn; i++) {
        if(pri[i]) {
            prime[k++]=i;
            for(LL j=i+i; j<Maxn; j+=i)
                pri[j]=0;
        }
    }
}

void Divide(LL n)
{
    cnt=0;
    for(LL i=0;i<k&&prime[i]*prime[i]<=n; i++) {
        if(n%prime[i]==0) {
            sprime[cnt++]=prime[i];
            while(n%prime[i]==0)
                n/=prime[i];
        }
    }
    if(n>1)
        sprime[cnt++]=n;
}
LL Ex(LL n)
{
    LL ans=0;
    LL tmp,flag;
    LL i,j;
    for(i=1; i<(LL)(1<<cnt); i++) {
        tmp=1;
        flag=0;
        for(j=0; j<cnt; j++)
            if(i&((LL)(1<<j))) {
                flag++;
                tmp*=sprime[j];
            }
        if(flag&1)
            ans+=n/tmp;
        else
            ans-=n/tmp;
    }
    return ans;
}
void Euler()
{
    LL i,j;
    memset(phi,0,sizeof(phi));
    phi[1]=1;
    for(i=2;i<=Maxn;i++)
    {
        if(!phi[i])
        {
            for(j=i;j<=Maxn;j+=i)
            {
                if(!phi[j])
                    phi[j]=j;
                phi[j]=phi[j]/i*(i-1);
            }
        }
    }
}
int main()
{
    int T;
    LL L,res;
    is_prime();
    Euler();
    scanf("%d",&T);
    while(T--)
    {
        res=0;
        scanf("%lld",&L);
        LL t=(LL)sqrt(1.0*L);
        for(LL m=1;m<=t;m++)
        {
            LL Nmax=(LL)sqrt(L-m*m);
            if(m&1)
            {
                Divide(m);
                if(m<=Nmax){
                    res+=m/2-Ex(m/2);
                }
                else{
                    res+=Nmax/2-Ex(Nmax/2);
                }
            }
            else
            {
                if(m<=Nmax) res+=phi[m];
                else
                {
                    Divide(m);
                    res+=Nmax-Ex(Nmax);
                }
            }
        }
        printf("%lld\n",res);
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【bzoj1037】【ZJOI2008】【生日聚会Party】【dp】
Description

今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。 hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：对于任意连续的一段，男孩与女孩的数目之差不超过k。很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题……
 假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。

Input

仅包含一行共3个整数，分别为男孩数目n, 女孩数目m, 常数k。

Output

应包含一行，为题中要求的答案。

Sample Input

1 2 1
Sample Output

1
HINT




对于100%的数据, n , m ≤ 150，k ≤ 20。

题解：胡乱猜了一个dp方程，然后竟然一不小心A了。。真感动。。

用 f[i][j][p][q]表示男生选i个，女生选j个，男生最多比女生多p个，女生最多比男生多q个的方案数。

那么                     

       f[i+1][j][p+1][max(0,q-1)]+=f[i][j][p][q]

       f[i][j+1][max(0,p-1)][q+1]+=f[i][j][p][q]
初始状态f[0][0][0][0]=1; 转移即可。
#include<iostream>
#include<cstdio>
#define pp 12345678 
using namespace std;
int n,m,k,f[160][160][30][30],ans;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	f[0][0][0][0]=1;
	for (int i=0;i<=n;i++)
	  for (int j=0;j<=m;j++)
	    for (int p=0;p<=k;p++)
	      for (int q=0;q<=k;q++)
	        {
	          (f[i+1][j][p+1][max(0,q-1)]+=f[i][j][p][q])%=pp;
	          (f[i][j+1][max(0,p-1)][q+1]+=f[i][j][p][q])%=pp;
	        }
    for (int i=0;i<=k;i++)
      for (int j=0;j<=k;j++)
        (ans+=f[n][m][i][j])%=pp;
    cout<<ans<<endl;   
}


                             


版权声明：本文为博主原创文章，未经博主允许不得转载。

暑期报修项目经验分享二（附原码）

楔子
第二期项目经验分享，其实整个项目流程，我们只是参与了其中一小部分，仅仅是添加了材料管理模块的内容，在第一期的实践里面，主要维护材料类别的增查改操作。二期维护做的是材料出入库处理，因为我处理的是入库管理这一块，所以分享下做这一块的经验。


需求分析：
在分析业务需求的时候，因为考虑到出入库在一张数据表里面，即是共用数据，那么type区分出入库，在写代码的时候一个反人类的操作就是把流水号设置成整形，虽然影响不大，另外关于材料类别代码这里，因为材料类别是三级联动设置，所以我们只取最后一级的代码，因为材料领取者和领取时间涉及出库，所以不必考虑，最后就是入库操作人员和入库时间，操作人员和时间都可以由系统获取。


代码编写过程：
我先考虑的是显示出数据库里的数据，由controller里面的list方法通过设置type字段来查询，之前一直尝试去修改底层代码（增加底层方法，因为sql要多处理一个查询），后来是确定在bo里面设置属性即可，list能成功显示后，在处理add时，因为流水号是递增的，所以通过createCode方法（底层是sql语句查询最大max_id），设置每次new出的id是max_id+1,因为你要中文可视化材料类别，所以getCodeAll必须获取到一级类别，然后利用传递过来的值赋给add界面，提交add表单后，在save方法里面，因为user和time默认获取系统值，之后通过saveCodeBean插入到数据库里面，代码层面，要写的有点多，后来小付老师说为什么baseDao的save方法不直接用呢，一句话即可解决（没用过。。果然底层封装的再好，不会用也是白搭），编辑操作通过request.getParameter获取选中的记录，用getAllByCode查询出所有记录，然后封装到Map里面，再赋给界面层，因为三级联动在编辑的时候要默认显示之前的数据，所以这里你要通过编辑选中的材料三级类别代码查询二级代码，并且要查询出一级类别对应二级类别的所有数据和二级类别对应三级类别的所有数据，用四个方法实现这个功能，对应四个sql语句（小付老师教的，果断不会这么高大上的东西），之后update界面即可，因为考虑到权限问题，所以设置n天后不可编辑，设定经过系统参数天后不能修改，我先找到实体类SystemPara，系统参数是存放在t_system_parameter表里面的，字段是par_value，记录是14，所以我在service里面添加findMaxLimitedById这个方法，因为系统参数一般是不会变的，所以我直接在sql语句里面默认查找id=14的记录select
 * from t_system_parameter where id=14，然后通过findUniqueMapByArray方法查询出记录，赋给Map，在Map里面直接用get获取集合内为par_value的值，返回，因为考虑到编辑和删除操作都会涉及到时间限制，所以我封装returnDayDiffer方法，得到时间差，那么在编辑和删除直接调用这个方法即可，最后测试了下，效果还不错。本来想尝试折旧数量必须小于入库数量，用js获取到入库数量后，发现貌似不能传递给折旧数量的max里，不过应该有其他的方法可以解决吧。。后台验证也可以解决，在后台只要判定结构体内loss_number值不超过input_number,直接返回即可。。


细节操作：
1.copy的时候记得把pagerform的路径改下，因为文件的目录不匹配
2.出现no mapping的错误一定是路径有错，在web.xml映射没有错误的情况下，先查看controller层里的类对应的注解，和方法对应的注解，然后再仔细查看web-inf下的jsp路径，肯定是有错的，因为我在这里被坑了不止n次了，再全部修改过后，还是不行的话，重启服务器
3.add界面自设参数后，是通过name传给controller层里对应的save方法，然后通过savebean存储到数据库的
4.在材料入库操作中，如果需要将数据从界面传到controller里面，除了再界面设置隐藏字段外，还可以通过
private SimpleOrmGenericDao<MaterialManage, Long> materialDao;
封装到结构体中，然后再setDataSource注入数据源
因为materialDao = new SimpleOrmGenericDao<MaterialManage, Long>(dataSource,
MaterialManage.class);本身就将实体封装到了materialDao里面，看底层可以发现其实用的就是jdbc通用Dao工厂分配。
还有一种方法是通过SimpleDateF置好格式，然后强转为Date型，这种方式不太喜欢。。。因为坑
5.upateCodeBean语句里面传过来的参数要匹配，另外sql语句要和底层baseDao.jdbcTemplate.executeArray相匹配
@javax.annotation.Resource
public void setDataSource(DataSource dataSource) {
//paraDao = new SimpleOrmGenericDao<SystemParameter, Long>(dataSource,
// SystemParameter.class);
baseDao = new BaseDao(dataSource);
}
注意这个也可以作为注入，如果没有会出现空指针错误。


package com.wisdom.repair.web.management.materialManage;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.sql.DataSource;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import com.wisdom.core.orm.BaseDao;
import com.wisdom.core.security.domain.User;
import com.wisdom.core.security.resource.SecurityUtils;
import com.wisdom.core.utils.CollectionUtils;
import com.wisdom.core.utils.Page;
import com.wisdom.core.web.BaseController;
import com.wisdom.example.commons.ValidationUtils;
import com.wisdom.repair.entity.MaterialManage;
import com.wisdom.repair.entity.RepairView;
import com.wisdom.repair.entity.UploadType;
import com.wisdom.repair.entity.pageBo.CodePageBo;
import com.wisdom.repair.service.material.MaterialServiceImpl;
import com.wisdom.repair.service.materialClass.MaterialClassServiceImpl;
import com.wisdom.repair.service.materialManage.*;
import com.wisdom.repair.service.pub.PublicService;
import com.wisdom.repair.service.user.UserManageService;
import com.wisdom.repair.web.management.user.UserPageBo;

/**
 * 
 * 类名称：MaterialManageController 类描述： 材料入库管理 创建人：Jxufe Kong De Wei 创建时间：2015-8-25
 * 上午10:09:02 修改备注：
 * 
 * @version
 */
@Controller("management.MaterialManageController")
@RequestMapping("/management/materialManage/input")
public class MaterialManageController extends BaseController {

	@Resource
	private MaterialManageService materialManageService;

	@Resource
	private MaterialServiceImpl materialService;

	@Resource
	private MaterialClassServiceImpl materialClassService;

	/**
	 * 
	 * 方法名: list 方法作用: 列表显示 创建人：Jxufe Kong De Wei 创建时间：2015-8-25 上午10:14:44
	 * 
	 * @param @param request
	 * @param @param page
	 * @param @param bo
	 * @param @return 返回值类型： String
	 * @throws
	 */

	@RequestMapping("/list")
	public String list(HttpServletRequest request, Page page, CodePageBo bo) {

		/*
		 * request.setAttribute("page",materialManageService.
		 * getAllRepairByFilterBean(page, materialView));
		 */
		bo.setInputType(1);
		request.setAttribute("page", materialManageService.getPageByFilterBean(
				page, "t_material_manage", MaterialManage.class, bo));

		System.out.println(materialManageService.getPageByFilterBean(page,
				"t_material_manage", MaterialManage.class, bo));

		return "/repair/management/materialManage/input/list";

	}

	/**
	 * 
	 * 方法名: add 方法作用: TODO 创建人：Jxufe Kong De Wei 创建时间：2015-8-25 上午10:14:38
	 * 
	 * @param @param request
	 * @param @return 返回值类型： String
	 * @throws
	 */
	@RequestMapping("/add")
	public String add(HttpServletRequest request) {

		List repTypeGroup = new ArrayList();

		System.out.println("nihao");
		try {
			request.setAttribute("id",
					materialManageService.createCode("t_material_manage"));
			request.setAttribute("repType", materialManageService
					.getCodeAll("t_code_repair_type_group"));
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		return "/repair/management/materialManage/input/add";
	}

	/**
	 * 
	 * 方法名: materialClass 方法作用: 编辑界面获取三级联动默认值 创建人：Jxufe Kong De Wei
	 * 创建时间：2015-8-26 上午11:15:04
	 * 
	 * @param @param value
	 * @param @return
	 * @param @throws Exception 返回值类型： List<List>
	 * @throws
	 */
	@RequestMapping("/materialClass")
	@ResponseBody
	public List<List> materialClass(String value) throws Exception {
		System.out.println("11111111111input value" + value);
		List list = new ArrayList();
		List listReturn = new ArrayList();
		List listTop = new ArrayList();
		listTop.add("");
		listTop.add("--请选择--");
		listReturn.add(listTop);
		if (value == null || value.isEmpty()) {
			return listReturn;
		}
		List list2 = new ArrayList();
		list = materialClassService.getMaterialSubAll(value.trim());

		for (int i = 0; i < list.size(); i++) {
			List listTemp = new ArrayList();
			Map temMap = (Map) list.get(i);
			listTemp.add(temMap.get("code").toString().trim());
			listTemp.add(temMap.get("name").toString().trim());
			listReturn.add(listTemp);
		}

		return listReturn;
	}

	/**
	 * 
	 * 方法名: material 方法作用: 编辑界面获取三级联动默认值 创建人：Jxufe Kong De Wei 创建时间：2015-8-26
	 * 上午11:15:41
	 * 
	 * @param @param value
	 * @param @return
	 * @param @throws Exception 返回值类型： List<List>
	 * @throws
	 */
	@RequestMapping("/material")
	@ResponseBody
	public List<List> material(String value) throws Exception {
		System.out.println("1111111111111111111112input value" + value);
		List list = new ArrayList();
		List listReturn = new ArrayList();
		List listTop = new ArrayList();
		listTop.add("");
		listTop.add("--请选择--");
		listReturn.add(listTop);
		if (value == null || value.isEmpty()) {
			return listReturn;
		}
		List list2 = new ArrayList();
		list = materialService.getMaterialSubAll(value.trim());

		for (int i = 0; i < list.size(); i++) {
			List listTemp = new ArrayList();
			Map temMap = (Map) list.get(i);
			listTemp.add(temMap.get("code").toString().trim());
			listTemp.add(temMap.get("name").toString().trim());
			listReturn.add(listTemp);
		}

		return listReturn;
	}

	/**
	 * 
	 * 方法名: edit 方法作用: 编辑 创建人：Jxufe Kong De Wei 创建时间：2015-8-25 上午10:14:06
	 * 
	 * @param @param request
	 * @param @return 返回值类型： String
	 * @throws
	 */
	@RequestMapping("/edit")
	public String edit(HttpServletRequest request) {
		/*
		 * if(true) { ceshi(); return null; } else {
		 */

		List repTypeGroup = new ArrayList();
		int code = Integer.parseInt(request.getParameter("id"));
		try {
			Map matairlManageMap = materialManageService.getAllByCode(code,
					"t_material_manage");
			System.out.println(matairlManageMap);
			request.setAttribute("materialManage", matairlManageMap);
			request.setAttribute("repType", materialManageService
					.getCodeAll("t_code_repair_type_group"));
			request.setAttribute(
					"materialList",
					materialManageService.getMaterialList(matairlManageMap.get(
							"code_material").toString()));
			request.setAttribute("materialClassList", materialManageService
					.getMaterialClassList(matairlManageMap.get("code_material")
							.toString()));
			request.setAttribute("materialClassCode", materialManageService
					.getMaterialClassCode(matairlManageMap.get("code_material")
							.toString()));
			request.setAttribute(
					"groupCode",
					materialManageService.getGroupCode(matairlManageMap.get(
							"code_material").toString()));

			// request.setAttribute("topValue",
			// publicService.getCodeAll("t_code_repair_type_group"));
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}

		return "/repair/management/materialManage/input/edit";
		// }

	}

	public ModelAndView ceshi() {

		return ajaxDoneSuccess("123456789");

	}

	/**
	 * 
	 * 方法名: save 方法作用: 添加保存 创建人：Jxufe Kong De Wei 创建时间：2015-8-25 上午10:14:17
	 * 
	 * @param @param materialView
	 * @param @param request
	 * @param @return 返回值类型： ModelAndView
	 * @throws
	 */
	@RequestMapping(value = "/save", method = RequestMethod.POST)
	public ModelAndView save(MaterialManage materialManage,
			HttpServletRequest request) {
		List<String> errors = ValidationUtils.validator(materialManage);
		Date nowDate = new Date();
		if (errors != null) {
			request.setAttribute("errors", errors);
			return ajaxDoneError("失败!");
		} else if (materialManage.getLoss_number() >= materialManage
				.getInput_number())
			return ajaxDoneError("折旧数量不可超过入库数量!");
		else {
			try {
				materialManage.setInputUser(SecurityUtils.getCurrentUserName());
				materialManage.setInputTime(nowDate);
				materialManage.setInputType(1);
				materialManage.setControlTime(nowDate);

				System.out.println(materialManage.getId()
						+ materialManage.getCodeMaterial()
						+ materialManage.getBrands()
						+ materialManage.getPrice()
						+ materialManage.getInput_number()
						+ materialManage.getInputType()
						+ materialManage.getInputUser()
						+ materialManage.getInputTime()
						+ materialManage.getLoss_number()
						+ materialManage.getMemo()
						+ materialManage.getControlTime()
						+ "00000000000000000000");

				int info = materialManageService.saveCodeBean(
						"t_material_manage", materialManage.getId(),
						materialManage.getCodeMaterial(),
						materialManage.getBrands(), materialManage.getPrice(),
						materialManage.getInput_number(),
						materialManage.getInputType(),
						materialManage.getInputUser(),
						materialManage.getInputTime(),
						materialManage.getLoss_number(),
						materialManage.getMemo());
				if (info > 0) {
					return ajaxDoneSuccess("成功!");
				} else
					return ajaxDoneError("失败!");
			} catch (Exception e) {
				return ajaxDoneError("失败!" + "<br/>系统报错信息：<br/>"
						+ e.getMessage());
			}

		}

	}

	/**
	 * @throws Exception
	 * 
	 *             方法名: update 方法作用: TODO 创建人：Jxufe Kong De Wei 创建时间：2015-8-25
	 *             上午10:14:23
	 * 
	 * @param @param materialView
	 * @param @param request
	 * @param @return 返回值类型： ModelAndView
	 * @throws
	 */
	@RequestMapping(value = "/update", method = RequestMethod.POST)
	public ModelAndView update(MaterialManage materialManage,
			HttpServletRequest request) throws Exception {
		List<String> errors = ValidationUtils.validator(materialManage);

		Long day = returnDayDiffer(materialManageService.findMaterialById(
				materialManage.getId().longValue()).getInputTime());

		if (errors != null) {
			request.setAttribute("errors", errors);
			return ajaxDoneError("失败!");

		} else if (day > Integer.parseInt(materialManageService
				.findMaxLimitedById()))
			return ajaxDoneError("材料入库已超过 "
					+ Integer.parseInt(materialManageService
							.findMaxLimitedById()) + " 日，数据不可更改!");
		else if (materialManage.getLoss_number() >= materialManage
				.getInput_number())
			return ajaxDoneError("折旧数量不可超过入库数量!");
		else {
			try {
				materialManage.setInputType(1);
				/*
				 * System.out.println(materialManage
				 * .getId()+" "+materialManage.
				 * getCodeMaterial()+" "+materialManage
				 * .getBrands()+" "+materialManage .getPrice()+
				 * " "+materialManage
				 * .getInput_number()+" "+materialManage.getInputType
				 * ()+" "+materialManage.getInputUser()+" "+
				 * materialManage.getInputTime
				 * ()+" "+materialManage.getLoss_number
				 * ()+" "+materialManage.getMemo()+"111111111111111");
				 */

				materialManageService.upateCodeBean("t_material_manage",
						materialManage.getId(),
						materialManage.getCodeMaterial(),
						materialManage.getBrands(), materialManage.getPrice(),
						materialManage.getInput_number(),
						materialManage.getInputType(),
						materialManage.getLoss_number(),
						materialManage.getMemo());
				return ajaxDoneSuccess("成功!");
			} catch (Exception e) {
				return ajaxDoneError("失败!" + "<br/>系统报错信息：<br/>"
						+ e.getMessage());
			}

		}
	}

	/**
	 * 
	 * 方法名: delete 方法作用: 删除操作 创建人：Jxufe Kong De Wei 创建时间：2015-8-26 上午11:14:01
	 * 
	 * @param @param request
	 * @param @return
	 * @param @throws Exception 返回值类型： ModelAndView
	 * @throws
	 */
	@RequestMapping("/delete")
	public ModelAndView delete(HttpServletRequest request) throws Exception {

		Integer id = Integer.parseInt(request.getParameter("id"));

		Long day = returnDayDiffer(materialManageService.findMaterialById(
				id.longValue()).getInputTime());

		// System.out.println("8888888888888888888888888888"+day);

		if (day > Integer.parseInt(materialManageService.findMaxLimitedById())) {
			return ajaxDoneError("材料入库已超过 "
					+ Integer.parseInt(materialManageService
							.findMaxLimitedById()) + " 日，数据不可更改!");
		} else {

			int i = materialManageService.deleteById(id);
			if (i > 0) {
				return ajaxDoneSuccess("删除成功");
			} else {
				return ajaxDoneError("删除失败");
			}
		}
	}

	/**
	 * 
	 * 方法名: returnDayDiffer 方法作用: 返回日期差 创建人：Jxufe Kong De Wei 创建时间：2015-8-26
	 * 上午11:13:34
	 * 
	 * @param @param date
	 * @param @return 返回值类型： Long
	 * @throws
	 */
	public Long returnDayDiffer(Date date) {
		Date nowDate = new Date();
		long day = (nowDate.getTime() - date.getTime()) / (24 * 60 * 60 * 1000) > 0 ? (nowDate
				.getTime() - date.getTime()) / (24 * 60 * 60 * 1000)
				: (date.getTime() - nowDate.getTime()) / (24 * 60 * 60 * 1000);
		return day;
	}

}

<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8"%><%@ include
	file="/include.inc.jsp"%>
<c:import url="../../_frag/pager/pagerForm.jsp"></c:import>

<form method="post" rel="pagerForm"
	action="<c:url value='${base}/management/materialManage/input/list.htm'/>"
	onsubmit="return navTabSearch(this)">
	<div class="pageHeader">
		<div class="searchBar">
			<ul class="searchContent">
				<li><label>品牌：</label> <input type="text" name="brands"
					value="${param.brands}" /></li>

			</ul>
			<div class="subBar">
				<ul>
					<li><div class="buttonActive">
							<div class="buttonContent">
								<button type="submit">查询</button>
							</div>
						</div>
					</li>
				</ul>
			</div>
		</div>
	</div>
</form>

<div class="pageContent">

	<div class="panelBar">
		<ul class="toolBar">
			<li><a class="add" target="dialog" rel="addNav"
				href="<c:url value='/management/materialManage/input/add.htm'/>"
				title="添加记录"><span>添加</span> </a>
			</li>
			<li><a class="edit" target="dialog" rel="editNav"
				href="<c:url value='/management/materialManage/input/edit.htm?id={slt_objId}'/>"
				title="编辑记录"><span>编辑</span> </a>
			</li>
			<li><a class="delete" target="ajaxTodo"
				href="<c:url value='/management/materialManage/input/delete.htm?id={slt_objId}'/>"
				title="删除记录"><span>删除</span> </a>
			</li>



			<li class="line">line</li>
		</ul>
	</div>
	<table class="table" width="100%" layoutH="138">
		<thead>
			<tr>
				<th width="50" orderField="ID"
					class="${param.orderField eq 'ID' ? param.orderDirection : ''}">代码</th>
				<th width="100" orderField="BRANDS"
					class="${param.orderField eq 'BRANDS' ? param.orderDirection : ''}">品牌</th>
				<th width="70" orderField="PRICE"
					class="${param.orderField eq 'PRICE' ? param.orderDirection : ''}">材料价格</th>
				<th width="70" orderField="input_number" 
					class="${param.orderField eq 'input_number' ? param.orderDirection : ''}">入库数量</th>
				<th width="70" orderField="input_number"
					class="${param.orderField eq 'input_number' ? param.orderDirection : ''}">操作人员</th>
				<th width="90" orderField="input_number"
					class="${param.orderField eq 'input_number' ? param.orderDirection : ''}">入库时间</th>
				<th width="70" orderField="loss_number"
					class="${param.orderField eq 'loss_number' ? param.orderDirection : ''}">折旧数量</th>
				<th width="100" orderField="memo"
					class="${param.orderField eq 'memo' ? param.orderDirection : ''}">备注</th>
				<th width="120">服务器当前时间</th>

			</tr>
		</thead>
		<tbody>

			<jsp:useBean id="now" class="java.util.Date" />
			<c:forEach var="MaterialManage" items="${page.result}" varStatus="s">
				<tr target="slt_objId" rel="${MaterialManage.id}">
					<td>${MaterialManage.id}</td>
					<td>${MaterialManage.brands}</td>
					<td>${MaterialManage.price}</td>
					<td>${MaterialManage.input_number}</td>
					<td>${MaterialManage.inputUser}</td>
					<td><fmt:formatDate value="${MaterialManage.inputTime}"
							pattern="yyyy-MM-dd HH:mm:ss" />
					</td>
					<td>${MaterialManage.loss_number}</td>
					<td>${MaterialManage.memo}</td>
					<td><fmt:formatDate value="${now}"  pattern="yyyy-MM-dd HH:mm:ss" /></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>

	<c:import url="../../_frag/pager/panelBar.jsp"></c:import>
</div>
<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8"%><%@ include
	file="/include.inc.jsp"%>

<div class="pageContent">
	<form method="post"
		action="<c:url value='/management/materialManage/input/save.htm?callbackType=closeCurrent'/>"
		class="pageForm required-validate"
		onsubmit="return validateCallback(this, dialogAjaxDone)">
		<div class="pageFormContent" layoutH="57">



			<input type="hidden" id="id" name="id" value="${id}"
				remote="/management/public/checkUnique.htm?tableName=t_material_manage"
				class="required digits" />
			<!-- <input type="button" value="重新生成"
					id="regenCode" style="padding:0px; margin: 0px 0px 0px 5px; "/> -->


			<div>
				<label>材料编号：</label> <select name="codeRepType" class="combox"
					ref="codeClaimerType"
					refUrl="${base}/management/materialManage/input/materialClass.htm?value={value}">
					<option value="">--请选择--</option>
					<c:forEach var="ur" items="${repType}">
						<option value="${ur.code}">${ur.name}</option>
					</c:forEach>
				</select> <select name="codeClaimerType" id="codeClaimerType"
					class="required combox" ref="codeMaterial"
					refUrl="${base}/management/materialManage/input/material.htm?value={value}">
					<option value="">---请选择---</option>

				</select> <select name="codeMaterial" id="codeMaterial"
					class="required combox">
					<option value="">--请选择--</option>
				</select>

			</div>


			<p>
				<label>品牌: </label> <input type="text" name="brands"
					class="required" maxlength="20" />
			</p>
			<p>
				<label>价格: </label> <input type="text" name="price" class="required"
					maxlength="20" />
			</p>
			<p>
				<label>入库数量: </label> <input type="text" name="input_number"
					max="9999" min="1" class="required textInput" maxlength="4" alt = "数据范围：1-9999"/>
			</p>
			<p>
				<label>折旧数量: </label> <input type="text" name="loss_number"
					id="loss_number12" max="9999" class="required" maxlength="4" alt = "折旧不得大于入库数量!"/>
			</p>
			<p>
				<label>备注: </label> <input type="text" name="memo" maxlength="20" />
			</p>

		</div>
		<div class="formBar">
			<ul>
				<li><div class="buttonActive">
						<div class="buttonContent">
							<button type="submit">保存</button>
						</div>
					</div></li>
				<li><div class="button">
						<div class="buttonContent">
							<button type="button" class="close">关闭</button>
						</div>
					</div></li>
			</ul>
		</div>
	</form>
</div>

<%@ page contentType="text/html;charset=UTF-8" pageEncoding="UTF-8"%><%@ include
	file="/include.inc.jsp"%>

<div class="pageContent">
	<form method="post"
		action="<c:url value='/management/materialManage/input/update.htm?callbackType=closeCurrent'/>"
		class="pageForm required-validate"
		onsubmit="return validateCallback(this, dialogAjaxDone)">
		<div class="pageFormContent" layoutH="57">
			<input type="hidden" id="id" name="id" value="${materialManage.id}"
				remote="/management/public/checkUnique.htm?tableName=t_material_manage"
				class="required digits" />
			<!-- <input type="button" value="重新生成"
					id="regenCode" style="padding:0px; margin: 0px 0px 0px 5px; "/> -->


			<div>
				<label>材料编号：</label> <select name="codeRepType"
					class="required combox" ref="codeClaimerType"
					refUrl="${base}/management/materialManage/input/materialClass.htm?value={value}">
					<option value="">--请选择--</option>
					<c:forEach var="ur" items="${repType}">
						<option value="${ur.code}"
							<c:if test="${ur.code==groupCode }"> selected </c:if>>${ur.name}</option>
					</c:forEach>
				</select> <select name="codeClaimerType" id="codeClaimerType"
					class="required combox" ref="codeMaterial"
					refUrl="${base}/management/materialManage/input/material.htm?value={value}">
					<option value="">---请选择---</option>
					<c:forEach var="urclass" items="${materialClassList}">
						<option value="${urclass.code}"
							<c:if test="${urclass.code==materialClassCode }"> selected </c:if>>${urclass.name}</option>
					</c:forEach>
				</select> <select name="codeMaterial" id="codeMaterial"
					class="required combox">
					<option value="">--请选择--</option>
					<c:forEach var="urmaterial" items="${materialList}">
						<option value="${urmaterial.code}"
							<c:if test="${urmaterial.code==materialManage.code_Material }"> selected </c:if>>${urmaterial.name}</option>
					</c:forEach>
				</select>

			</div>


			<p>
				<label>品牌: </label> <input type="text" name="brands"
					value="${materialManage.brands}" class="required" maxlength="20" />
			</p>
			<p>
				<label>价格: </label> <input type="text" name="price"
					value="${materialManage.price}" class="required" maxlength="20" />
			</p>
			<p>
				<label>入库数量: </label> <input type="text" name="input_number"
					value="${materialManage.input_number}" class="required"
					maxlength="4" />
			</p>
			<p>
				<label>折旧数量: </label> <input type="text" name="loss_number"
					value="${materialManage.loss_number}" max="9999" class="required"
					maxlength="4" />
			</p>
			<p>
				<label>备注: </label> <input type="text" name="memo"
					value="${materialManage.memo}" maxlength="20" />
			</p>

		</div>

		<div class="formBar">
			<ul>
				<li><div class="buttonActive">
						<div class="buttonContent">
							<button type="submit">保存</button>
						</div>
					</div>
				</li>
				<li><div class="button">
						<div class="buttonContent">
							<button type="button" class="close">关闭</button>
						</div>
					</div>
				</li>
			</ul>
		</div>
	</form>
</div>




版权声明：转载请注明出处

二分查找和循环数组查找
1. 二分查找
<?php
//二分查找 数组有序
function binary_search($arr, $key){
    if(empty($arr) || empty($key)){
        return ;
    }
    $len = count($arr);
    $low  = 0;
    $high = $len - 1;
    while($high > $low){
        $mid = ($low + $high) >> 1;
        if($arr[$mid] == $key){
            var_dump('查找OK 下标是:', $mid);
            return;
        }else if($arr[$mid] > $key){
            $high = $mid - 1;
        }else{
            $low = $mid + 1;
        }
    }
    var_dump('数组中不存在该元素');
}
$arr = [1,3,4,5,6,7,8,9,23];
binary_search($arr, 34);
?>
2. 循环数组中查找一个元素 – 前几天有个公司问的面试题

循环数组查找的思想:
循环递增数组有这么一个性质：以数组中间元素将循环递增数组划分为两部分，则一部分为一个严格递增数组，而另一部分为一个更小的循环递增数组。当中间元素大于首元素时，前半部分为严格递增数组，后半部分为循环递增数组；当中间元素小于首元素时，前半部分为循环递增数组；后半部分为严格递增数组。

a[mid] > a[low]，即数组前半部分为严格递增数组，后半部分为循环递增数组时，若key小于a[mid]并且不小于a[low]时，则key落在数组前半部分；否则，key落在数组后半部分。
a[mid] < a[high]，即数组前半部分为循环递增数组，后半部分为严格递增数组时，若key大于a[mid]并且不大于a[high]时，则key落在数组后半部分；否则，key落在数组前半部分。


<?php
//循环数组中查找 比如 [5,6,7,8,1,3,4] 这个都成为循环数组
function loop_search($arr, $key){
    if(empty($arr) || empty($key)){
        return ;
    }
    $len = count($arr);
    $low = 0;
    $high = $len - 1;
    while($high >= $low){
        $mid = ($high + $low) >> 1;
        if($arr[$mid] == $key){
            var_dump('查找成功 下标是: ', $mid);
            return;
        }
        if($arr[$low] < $arr[$mid]){    //左半部分是递增, 有半部分是循环数组
            if($arr[$low] <= $key && $key < $arr[$mid]){
                $high = $mid - 1;
            }else{
                $low = $mid + 1;
            }
        }else{
            if($arr[$mid] < $key && $key <= $arr[$high]){
                $low = $mid + 1;
            }else{
                $high = $mid - 1;
            }
        }
    }
    var_dump('数组中不存在该元素');
}
$arr = [5,6,7,8,1,3,4];
loop_search($arr, 66);
?>

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 2049 不容易系列之(4)——考新郎 错排
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <math.h>
#include <stdlib.h>
#include <time.h>
using namespace std;
typedef long long ll;

int main()
{
    int i,_,n,m;
    ll f[25],a[25],ans;
    f[1]=0;f[2]=1;
    for(i=3;i<=20;i++)
        f[i]=(i-1)*(f[i-1]+f[i-2]);
    a[0]=1;
    a[1]=1;
    for(i=2;i<=20;i++)
        a[i]=a[i-1]*i;
    scanf("%d",&_);
    while(_--)
    {
        scanf("%d%d",&n,&m);
        ans=a[n]/a[m]/a[n-m];
        printf("%lld\n",ans*f[m]);
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。http://xiang578.top/

ＨＤＯＪ　１８６９　六度分离

http://acm.hdu.edu.cn/showproblem.php?pid=1869


题目来源：HPU 1869—六度分离


Problem Description
1967年，美国著名的社会学家斯坦利·米尔格兰姆提出了一个名为“小世界现象(small worldphenomenon)”的著名假说，大意是说，任何2个素不相识的人中间最多只隔着6个人，即只用6个人就可以将他们联系在一起，因此他的理论也被称为“六度分离”理论(six degrees of separation)。虽然米尔格兰姆的理论屡屡应验，一直也有很多社会学家对其兴趣浓厚，但是在30多年的时间里，它从来就没有得到过严谨的证明，只是一种带有传奇色彩的假说而已。

Lele对这个理论相当有兴趣，于是，他在HDU里对N个人展开了调查。他已经得到了他们之间的相识关系，现在就请你帮他验证一下“六度分离”是否成立吧。
 
 
Input
本题目包含多组测试，请处理到文件结束。
对于每组测试，第一行包含两个整数N,M(0<N<100,0<M<200),分别代表HDU里的人数（这些人分别编成0~N-1号)，以及他们之间的关系。
接下来有M行，每行两个整数A,B(0<=A,B<N)表示HDU里编号为A和编号B的人互相认识。
除了这M组关系，其他任意两人之间均不相识。
 
 
Output
对于每组测试，如果数据符合“六度分离”理论就在一行里输出"Yes"，否则输出"No"。
 
 
Sample Input
8 7
0 1
1 2
2 3
3 4
4 5
5 6
6 7
8 8
0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 0
 
 
Sample Output
Yes
Yes
 
考察点：最短路&&Floyd算法
 
题目大意：给定n个人（编号0--n-1）和m组关系（两两之间的关系），判断任意两个有关系的人之间是否最多通过6个人相识。符合情况就输出“Yes”,否则输出“No”。
 
题目解析： 因为这道题目要判断任意两个人之间的最短路是否<=7,且要求的数据不大，所以使用Floyd算法会比较方便。


#include<cstdio>
#include<algorithm>
using namespace std;
#define INF 0x3f3f3f3f
int graph[105][105];
void init(int n)//初始化n个人之间的关系 
{
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			if(i==j)//同一个人 
				graph[i][j]=0;
			else
				graph[i][j]=INF;
		}
	}
}
void Floyd(int n)//Floyd算法 
{
	for(int k=0;k<n;k++)//三重for循环更新最短路 
	{
		for(int j=0;j<n;j++)
		{
			if(graph[k][j]!=INF)//剪掉不必要的循环 
			{
				for(int i=0;i<n;i++)
				{
					graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);
					//i到j的距离记录为i到j的原距离与通过k的距离的最小值 
				}
			}
		}
	}	
}
int main()
{
	int n,m;//n个人（编号0到n-1），m组关系  
	int a,b;//a，b认识 
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		init(n);
		for(int i=0;i<m;i++)
		{
			scanf("%d%d",&a,&b);
			graph[a][b]=graph[b][a]=1;//两个有直接关系的人之间权值为1 
		}
		Floyd(n);
		int lap=0;
		for(int i=0;i<n;i++)//判断是否有两人之间的权值>7 
		{
			for(int j=0;j<n;j++)
			{
				if(graph[i][j]>7)
				{
					lap=1;
					break;
				}
			}
			if(lap)
				break;
		}
		if(lap)
			printf("No\n");
		else
			printf("Yes\n");
	}
	return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

zjnu(1181)——石子合并
这道题算是最简单的区间dp了。。很久之前写的，搞懂原理了就1A。
传送门：http://acm.zjnu.edu.cn/CLanguage/showproblem?problem_id=1181
状态方程定义：
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[i][j]);
然后利用三层for就好了。

for(int len=2;len<=n;len++){
		for(int s=1;s<=n-len+1;s++){
			int e=s+len-1;
			f[s][e]=inf;
			for(int k=s;k<=e-1;k++){
				if(f[s][e]>f[s][k]+f[k+1][e]+sum[s][e])
					f[s][e]=f[s][k]+f[k+1][e]+sum[s][e];
			}
		}
	}
最重要的是这个循环，但是其实也挺简单，首先枚举区间长度，齐次枚举起点s，当然这里每次都要对f[s][e]都初始化为正无穷（视题目情况而定），因为这里每一次的s与e都是不相同的。

然后第三层枚举的是k，k相当于跳板的作用，然后在里面进行dp就好了。

#include<stdio.h>
#include<string.h>
#include<iostream>
#include<algorithm>
using namespace std;
#define maxn 111
#define inf 99999999
int f[maxn][maxn],sum[maxn][maxn],spone[maxn];
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&spone[i]);
	for(int i=1;i<=n;i++){
		sum[i][i]=spone[i];
		for(int j=i+1;j<=n;j++){
			sum[i][j]=sum[i][j-1]+spone[j];
		}
	}
	int min1=inf;
	for(int len=2;len<=n;len++){
		for(int s=1;s<=n-len+1;s++){
			int e=s+len-1;
			f[s][e]=inf;
			for(int k=s;k<=e-1;k++){
				if(f[s][e]>f[s][k]+f[k+1][e]+sum[s][e])
					f[s][e]=f[s][k]+f[k+1][e]+sum[s][e];
			}
		}
	}
	if(min1>f[1][n]) min1=f[1][n];
	for(int i=1;i<n;i++){
		swap(spone[i],spone[i+1]);
		for(int l=1;l<=n;l++){
			sum[l][l]=spone[l];
			for(int q=l+1;q<=n;q++){
				sum[l][q]=sum[l][q-1]+spone[q];
			}
		}
		for(int len=2;len<=n;len++){
			for(int s=1;s<=n-len+1;s++){
				int e=s+len-1;
				f[s][e]=inf;
				for(int k=s;k<=e-1;k++){
					if(f[s][e]>f[s][k]+f[k+1][e]+sum[s][e])
						f[s][e]=f[s][k]+f[k+1][e]+sum[s][e];
				}
			}
		}
		if(min1>f[1][n]) min1=f[1][n];
		swap(spone[i],spone[i+1]);
	}
	printf("%d\n",min1);
}
/*
3
2 5 1
*/



版权声明：本文为博主原创文章，未经博主允许不得转载。

将Python脚本打包成可执行文件
Python是一个脚本语言，被解释器解释执行。它的发布方式：

.py文件：对于开源项目或者源码没那么重要的，直接提供源码，需要使用者自行安装Python并且安装依赖的各种库。（Python官方的各种安装包就是这样做的）
.pyc文件：有些公司或个人因为机密或者各种原因，不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。
可执行文件：对于非码农用户或者一些小白用户，你让他装个Python同时还要折腾一堆依赖库，那简直是个灾难。对于此类用户，最简单的方式就是提供一个可执行文件，只需要把用法告诉Ta即可。比较麻烦的是需要针对不同平台需要打包不同的可执行文件（Windows,Linux,Mac,…）。

本文主要就是介绍最后一种方式，.py和.pyc都比较简单，Python本身就可以搞定。将Python脚本打包成可执行文件有多种方式，本文重点介绍PyInstaller，其它仅作比较和参考。

Freezing Your Code
各种打包工具的对比如下(来自文章Freezing Your Code)：



Solution
Windows
Linux
OS X
Python 3
License
One-file mode
Zipfile import
Eggs
pkg_resources support



bbFreeze
yes
yes
yes
no
MIT
no
yes
yes
yes


py2exe
yes
no
no
yes
MIT
yes
yes
no
no


pyInstaller
yes
yes
yes
no
GPL
yes
no
yes
no


cx_Freeze
yes
yes
yes
yes
PSF
no
yes
yes
no


py2app
no
no
yes
yes
MIT
no
yes
yes
yes



PS.其中pyInstaller和cx_Freeze都是不错的，stackoverflow上也有人建议用cx_Freeze，说是更便捷些。pkg_resources新版的pyInstaller貌似是支持的。

安装PyInstaller
对于那些网络比较稳定，能够流畅使用pip源地址的用户，直接下面的命令就可以搞定：
pip install pyinstaller
通常我们会下载源码包，然后进入包目录，执行下面的命令（需要安装setuptools）：
python setup.py install

安装完后，检查安装成功与否：
pyinstaller --version
安装成功后，就可以使用下面的命令了：

pyinstaller : 打包可执行文件的主要命令，详细用法下面会介绍。
pyi-archive_viewer :   查看可执行包里面的文件列表。
pyi-bindepend  : 查看可执行文件依赖的动态库（.so或.dll文件）
pyi-... : 等等。 

使用PyInstaller
pyinstaller的语法：
pyinstaller [options] script [script ...] | specfile
最简单的用法，在和myscript.py同目录下执行命令：
pyinstaller mycript.py
然后会看到新增加了两个目录build和dist，dist下面的文件就是可以发布的可执行文件，对于上面的命令你会发现dist目录下面有一堆文件，各种都动态库文件和myscrip可执行文件。有时这样感觉比较麻烦，需要打包dist下面的所有东西才能发布，万一丢掉一个动态库就无法运行了，好在pyInstaller支持单文件模式，只需要执行：
pyinstaller -F mycript.py
你会发现dist下面只有一个可执行文件，这个单文件就可以发布了，可以运行在你正在使用的操作系统类似的系统的下面。
当然，pyinstaller还有各种选项，有通用选项，如-d选项用于debug，了解pyInstaller执行的过程；还有一些针对不同平台的选项，具体用法可以访问PyInstaller官方WIKI。
在执行pyInstaller命令的时候，会在和脚本相同目录下，生成一个.spec文件，该文件会告诉pyinstaller如何处理你的所有脚本，同时包含了命令选项。一般我们不用去理会这个文件，若需要打包数据文件，或者给打包的二进制增加一些Python的运行时选项时…一些高级打包选项时，需要手动编辑.spec文件。可以使用：
pyi-makespec options script [script ...]
创建一个.spec文件，对于手动编辑的.spec文件，我们可以使用下面任意一条命令：
pyinstaller specfile
pyi-build specfile

PyInstaller的原理简介
PyInstaller其实就是把python解析器和你自己的脚本打包成一个可执行的文件，和编译成真正的机器码完全是两回事，所以千万不要指望成打包成一个可执行文件会提高运行效率，相反可能会降低运行效率，好处就是在运行者的机器上不用安装python和你的脚本依赖的库。在Linux操作系统下，它主要用的binutil工具包里面的ldd和objdump命令。
PyInstaller输入你指定的的脚本，首先分析脚本所依赖的其他脚本，然后去查找，复制，把所有相关的脚本收集起来，包括Python解析器，然后把这些文件放在一个目录下，或者打包进一个可执行文件里面。
可以直接发布输出的整个文件夹里面的文件，或者生成的可执行文件。你只需要告诉用户，你的应用App是自我包含的，不需要安装其他包，或某个版本的Python，就可以直接运行了。
需要注意的是，PyInstaller打包的执行文件，只能在和打包机器系统同样的环境下。也就是说，不具备可移植性，若需要在不同系统上运行，就必须针对该平台进行打包。
参考资料

Freezing Your Code
PyInstaller官方WIKI
PyInstaller源码


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Taekwondo

Taekwondo

There are an individual match and group match in Taekwondo. An individual match is between two players and a group match is repetition of matches between two different individual players of each group.
You plan to make a group match which is comprised of several individual matches by selecting each player from each group. Every player of the group can play one match only. Therefore, the number of matches is the same as the
 smaller number of the players of the two groups. Like other sports, Taekwondo has a rule to make a weight difference minimal between two players of a match to be fair. 
In a given two players’ groups, create a program to make a group match with the total sum of absolute weight differences to a minimum between each two players who participate in each individual
 game. 

Time limit: 1 second (java: 2 seconds)

[Input]
Several test cases can be included in the inputs. T, the number of cases is given in the first row of the inputs. After that, the test cases as many as T (T ≤ 30) are given in a row. 
The number of players in the first group, N and the number of players in the second group, M are given as being separated with a blank. (1 ≤ N, M ≤ 500) 
The players’ weights of the second group are given respectively from the next row to M number rows. Each player weight is a real number over 40.0 below 130.0, and a weight to be inputted has
 an accuracy of one place of decimal. 

[Output]
For each test case, you should print "Case #T" in the first line where T means the case number.

For each test case, you should outputthe total sum of absolute values of two players’ weights participating in an individual game included in a group match to one decimal place on the first row of each
 test case. 

[I/O Example]

Input
2
2 4
55.0
50.0
60.0
48.0
53.5
43.0
1 5
106.8
55.7
46.4
78.8
103.1
56.0

Output
Case #1

3.5

Case #2

3.7

题意大概有一下四点：

1.         两队人做跆拳道比赛；

2.         比赛场次等于人少的一组；

3.         比赛中两个选手会存在重量差；

4.         求一种能够安排的最小重量差；

 

解题思路为动态规划（贪婪算法并不一定是最优解，有反例），核心伪代码如下：

f(i,j) = min {f(i,j-1), f(i-1, j-1)+d(I,j)}  i<j

    = f(i-1,j-1)+d(i,j)             i=j

    = 0                       i=0 or j=0 or i>j

 

 

C代码如下：

/*

You should use the statndard input/output

 

in order to receive a score properly.

 

Do not use file input and output

 

Please be very careful.

*/

#include <stdio.h>

 

#define MAX_N 501

 

float Array_one[MAX_N];

float Array_two[MAX_N];

float temp[MAX_N];

 

float Answer[MAX_N] ;

 

 

float Dif_Abs(float a , float b)//对a和b进行做差并返回绝对值{

if(a >= b)

return (a-b);

else

return (b-a);

}

 

/********************************************************************

归并排序算法，对拆分之后的数组进行排序合并

a[]：需要排序的数组；

temp[]：临时存放排序过程中的a[]的临时数组；

start：开始排序的数组的位置；

Middle：从start到end中间的位置；

end：结束排序的数组的位置；

********************************************************************/

void MeageArray(float a[],float temp[] ,int start ,int middle ,int end)

{

    int s,m,e,k,i;

    s = start ;

    m = middle + 1 ;

    e = end ;

    k = start ;

   

    while((s<=middle)&&(m<=end))

    {

        if(a[s] <= a[m])

        {

            temp[k++] = a[s++] ;

        }

   

        else//if(a[s] > a[m])

        {

            temp[k++] = a[m++] ;

        }

    }

   

    while(s <= middle)

    {

        temp[k++] = a[s++];

    }

   

    while(m <= end)

    {

        temp[k++] = a[m++];

    }

   

    for(i = start ; i <= end ; i++)

    {

        a[i] = temp[i];

    }  

}

 

/********************************************************************

归并排序算法，对数组进行拆分，分别将左边和右边拆分成最小单元，然后再合并；

a[]：需要排序的数组；

temp[]：临时存放排序过程中的a[]的临时数组；

start：开始排序的数组的位置；

end：结束排序的数组的位置；

********************************************************************/

void MergeSort(float a[],float temp[],int start,int end)

{

    int middle ;

   

    if(start < end)

    {

        middle = (start + end)/2 ;

        MergeSort(a , temp , start , middle);

        MergeSort(a , temp , middle+1 , end);

        MeageArray(a,temp , start , middle , end);

    }

}

 

int main(void)

{

   

   

    int T, test_case;

   

   

    /*

   

   

    The freopen function below opens input.txt file in read only mode, and afterward,

   

   

    the program will read from input.txt file instead of standard(keyboard) input.

   

   

    To test your program, you may save input data in input.txt file,

   

   

    and use freopen function to read from the file when using scanf function.

   

   

    You may remove the comment symbols(//) in the below statement and use it.

   

   

    But before submission, you must remove the freopen function or rewrite comment symbols(//).

   

   

    */

   

   

    freopen("sample_input.txt", "r", stdin);

 

    /*

   

   

    If you remove the statement below, your program's output may not be rocorded

   

   

    when your program is terminated after the time limit.

   

   

    For safety, please use setbuf(stdout, NULL); statement.

   

   

    */

   

   

    setbuf(stdout, NULL);  

   

   

    scanf("%d", &T);

   

    for(test_case = 0; test_case < T; test_case++) 

    {

        int N,M;

        int i,j;

        int n1,m1;

        scanf("%d",&N);

        scanf("%d",&M);

       

        for(i=0;i<N;i++)

        {

            scanf("%f",&Array_one[i]);

        }

       

        for(j=0;j<M;j++)

        {

            scanf("%f",&Array_two[j]);

        }

 

        for(j=0;j<MAX_N;j++)//初始化每一个case的Answer数组

        {

            Answer[j] = 0;

        }

       

        MergeSort(Array_one,temp,0,N-1);//对第一队人按照体重由小到大进行排序

        MergeSort(Array_two,temp,0,M-1);//对第二队人按照体重由小到大进行排序

        if(N<M) //判断两队人数的多少，用人数少的一队去遍历人数多的一队

        {

            n1 = N ;

            m1 = M ;

        }

        else

        {

            n1 = M ;

            m1 = N ;

        }

       

        for(i=0;i<n1;i++) //核心代码部分

        {

            for(j=0;j<m1-n1+1;j++)

            {

                Answer[j] +=Dif_Abs(Array_one[i] , Array_two[i+j]);

 

                if((j > 0) && (Answer[j] > Answer[j-1]))

                {

                    Answer[j] = Answer[j-1];

                }

            }

        }  

       

        /////////////////////////////////////////////////////////////////////////////////////////////

       

       

        /*

       

       

        Implement your algorithm here.

       

       

        The answer to the case will be stored in variable Answer.

       

       

        */

       

       

        /////////////////////////////////////////////////////////////////////////////////////////////

       

       

        //Answer = 0;

 

        // Print the answer to standard output(screen).

       

       

    printf("Case #%d\n", test_case+1);

       

    printf("%.1f\n", Answer[m1-n1]);

   

   

    }

    return 0;//Your program should return 0 on normal termination.

   

}

版权声明：本文为博主原创文章，未经博主允许不得转载。

【水题】【SCOI 2005】【bzoj 1088】扫雷Mine
1088: [SCOI2005]扫雷Mine
Time Limit: 10 Sec  Memory Limit: 162 MB
Submit: 2180  Solved: 1272

Description
相信大家都玩过扫雷的游戏。那是在一个n*m的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了，“余”人国流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字表示和它8连通的格子里面雷的数目。现在棋盘是n×2的，第一列里面某些格子是雷，而第二列没有雷，如下图： 由于第一列的雷可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息确定第一列雷有多少种摆放方案。
Input
第一行为N，第二行有N个数，依次为第二列的格子中的数。（1<= N <= 10000）
Output
一个数，即第一列中雷的摆放方案数。
Sample Input
2
1 1

Sample Output
2

题解：
在lcomyn的指导下发现了这一水题。。 
一开始想的是dp，后来惊讶地发现前面的知道了后面的就能算出来了，于是直接暴力就好了。
Code：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

int n,ans,a[10010],b[10010]; 

int in(){
    int x=0; char ch=getchar();
    while (ch<'0' || ch>'9') ch=getchar();
    while (ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}

bool judge(){
    for (int i=2; i<n; i++){
        int k=a[i]-b[i-1]-b[i];
        if (k<0 || k>1)
            return false;
        else if (!k) b[i+1]=0;
        else b[i+1]=1;
    }
    int k=a[n]-b[n-1]-b[n];
    if (!k) return true;
    return false;
}

void work(){
    ans=0;
    if (!a[1]){
        if (judge()) ans++;
    }
    else if (a[1]==1){
        b[1]=1;
        if (judge()) ans++;
        b[1]=0,b[2]=1;
        if (judge()) ans++;
    }
    else if (a[1]==2){
        b[1]=b[2]=1;
        if (judge()) ans++;
    }
}

int main(){
    n=in();
    for (int i=1; i<=n; i++){
        a[i]=in();
        if (((i==1 || i==n) && a[i]>2) || a[i]>3){
            ans=0; break;
        }
    }

    work(); printf("%d\n",ans);
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        hdoj 2546  饭卡【0-1背包】【dp思想】


饭卡
Time Limit: 5000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 16609    Accepted Submission(s): 5776



Problem Description

电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。
某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。


 


Input

多组数据。对于每组数据：
第一行为正整数n，表示菜的数量。n<=1000。
第二行包括n个正整数，表示每种菜的价格。价格不超过50。
第三行包括一个正整数m，表示卡上的余额。m<=1000。

n=0表示数据结束。


 


Output

对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。

 


Sample Input

1
50
5
10
1 2 3 2 1 1 2 3 2 1
50
0


 


Sample Output

-45
32


 



#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
int bag[1100],val[1100];
int main()
{
	int i,j,k,n,m;
	while(~scanf("%d",&n),n!=0)//菜的种类 
	{
		memset(bag, 0, sizeof(bag));
		memset(val,0,sizeof(val));
		for( i = 0; i < n ;i++)
			scanf("%d",&val[i] );//每种菜的价格 
		sort(val,val+n);
		scanf("%d",&m );//余额 
		if(m < 5)
		{
			printf("%d\n",m);
			continue;
		}
		m -= 5;//不这样测试数据过得去,结果居然WA... 
		for( i = 0; i < n-1; i++)//m-5买了一个菜,先不管余额正负，还有n-1个菜 
		{
			for( j = m; j >= val[i];j--)//判断 当前余额 >=0 
			{
				bag[j] = max(bag[j], bag[j-val[i]]+val[i]);//先dp求出最大花费 
			}
		}
		printf("%d\n", m+5-bag[m]-val[n-1]);//之前减去五再加上,再减去n-1个菜的最大花费和第n个菜的价格 
	}
	return 0;
}


版权声明：原创文章，若要转载，请与博主联系，谢谢

二叉树中和为某一值的路径
题目： 
    　　输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径．从树的根结点开始往下一直到叶结点所经过的结点形成一条路径．
#include <vector>
#include <stdio.h>
using std::vector;
void FindPath(BinaryTreeNode* pRoot, int expectedSum, vector<int>& path,
              int currentSum);
void FindPath(BinaryTreeNode* pRoot, int expectedSum)
{
    if (pRoot == NULL)
        return;
    vector<int> path;
    int currentSum = 0;
    FindPath(pRoot, expectedSum, path, currentSum);
}

void FindPath(BinaryTreeNode* pRoot, int expectedSum, vector<int>& path,
              int currentSum)
{
    currentSum += pRoot->m_nValue;
    path.push_back(pRoot->m_nValue);
    bool isLeaf = (pRoot->m_pLeft == NULL && pRoot->m_pRight == NULL);
    //如果是叶子结点并且当前和值和传入整数相等，则打印路径
    if (isLeaf && currentSum == expectedSum)
    {
        vector<int>::iterator iter = path.begin();
        for (; iter != path.end(); ++iter)
        {
            printf("%d ",*iter);
        }
        printf("\n");
    }

    if (pRoot->m_pLeft)
        FindPath(pRoot->m_pLeft, expectedSum, path, currentSum);
    if (pRoot->m_pRight)
        FindPath(pRoot->m_pRight, expectedSum, path, currentSum);
  //返回父结点前，在路径上删除当前结点
    path.pop_back();
}



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

共享库C/C++
                                            共享库---共享对象的集合
  1.产生原因
随着软件规模的越来越大，我们的函数越来越多，为了简化这些极为庞大的共享对象。所以就将这些函数根据相应的需求规划成一些集合，进行一些处理生成共享库文件，这样可以极大的减少函数的数量便于管理和升级。
  2。共享库的版本
更新：
兼容更新。所有的更新只是在原有的共享库基础上添加一些内容，所有的接口都保持不变。
不兼容跟新。改变了所有的原有接口，更新后原有的程序可能不能运行
    就是ABI 接口改变，一般二进制接口改变，程序是不能运行的。
  3。ABI改变情况以及兼容性分析
。导出函数的行为发生改变，也就是说调用这个函数以后产生的结果与以前不一样，不再满足旧版本规定的函数行为准则。
      。导出函数被删除
      。导出数据的结构发生变化，比如共享库定义的结构变量的结构发生改变。
      。当然一般改变结构体，例如给结构体增加一些项目只要是动态分配的都是没有太大影响的。
。导出函数的接口发生变化，如函数返回值，参数被更改
      。对于C++来说，ABI变化就是灾难性的
      
      如果需要开发一个C++的共享库，需要注意以下事项。
      不要在接口中使用虚函数，万不得已时，不要随意删除，添加或在子类中添加新的实现函数，这样会导致类的函数表发生变化。
      不要改变任何成员变量的位置和类型
不要删除非内嵌的Public 或 protected 成员函数
不要将非嵌入式的成员函数改变成内嵌成员函数
      不要改变成员函数的访问权限
      不要在接口中使用模版
      最重要的是，不要改变接口的任何部分或干脆不要使用C++作为共享库接口，使用C吧少年！
 
  4。共享库的版本名
Linux有一套较为完善的命名机制。
Libname.so.x.y.z  
      这就是我们经常看到的共享库的标准命名形式，最前面是lib 中间是库的名字 最后是 .so 后缀
最后是它的版本号。
      X：主版本号，不同版本号之间是不能兼容的。改变后需要重新编译。
      Y：次版本号，表示库的增量升级，即增加一些新的接口符号，且保持原来的接口不变，一般是高的次版本号向后兼容底的版本号。
      Z：发布版本号，表示库的一些错误的修正，性能的改进等，并不需要添加任何新的接口，也不对接口进行更改。相同主版本号，次版本号的共享库，不同发布版本号之间完全兼容。是完全可以运行的。
 
  5.SO-NAME
共享库的主版本号和次版本号决定了一个共享库的接口。程序中必须包含被依赖的共享库的名字和主版本号。由于历史原因，动态链接库和C语言的共享对象文件名规则不按Linux标准的共享库命名方法，但是C语言的SO-NAME是按照正常的规则。
实际上这个软链接会指向目录中主版本号相同的，次版本号和发布版本号最新的共享库。保证了所有的以SO—NAME 这样就保证了所有的以SO—NAME 为名的软链接都指向系统中最新的共享库。
一般这个软链接在的 dynamic 段的DT_NEED类型项中。
 
 6.共享库的系统路径
目前大多数的Linux都遵循一项标准，FHS的标准，这个标准规定了一个系统中的系统文件如何存放
包括各个目录的组织，结构和作用。这个标准规定一个系统主要有三个存放共享库的位置。
 
    Lib ，这个位置主要存放系统最关键和基础的共享库，比如动态链接器，C语言库运行库，数学库，这些库主要支持/bin/和/sbin 需要用到的库。
 
    /usr/local/lib，这个位置放置了一些跟操作系统本身无关的库，主要是第三方应用程序的库，
    
    /usr/lib,这个目录主要保存的是一些非系统运行时所需要的关键性的共享库。
 
 
 
7.共享库查找过程
动态链接的ELF 文件在启动时会同时启动动态链接器。程序所依赖的的模块路径保存在 dynamic 
段里面，由DT_NEED类型的项表示，动态链接器对于模块的查找有一定的规则；如果DT_NEED里面保存的时绝对路径，那么动态链接器就会按照这个路径去查找；如果DT_NEED里面保存的是相对路径，那么动态链接器就会在/lib/,/usr/lib 和由/etc/ld.so.conf 配置文件指定的目录中查找共享库。为了程序的可以移植性和兼容性，共享库的路径往往是相对的。
 
 
两个环境变量：
 
LD_LIBRARY_PATH  这是一个由若干条路径组成的环境变量，每个环境变量由冒号隔开。默认情况下，这个路径为空，进程在启动的时候会首先查找共享库时，会首先查找由这个变量指定的路径。
 
例如我们想使用一个修改过的libc.so.6 可以将这个库放到/home/usr/下通过改变变量指向就可以达成改变链接指向的目的
 
$ LD_LIBRARY_PATH =  /home/user /bin/ls
 
也可以直接时用动态链接器
 
$ /lib/ld-linux.so.2 -library-path /home/user /bin/ls
 
动态链接器会按照下列顺序依次装载或查找共享对象
 
由环境变量LD_LIBRARY_PATH 指定的路径
由路径缓存文件/etc/ld.so.cache 指定的路径
默认共享库目录，先是/usr/lib 然后/lib
 
其实也可以使用GCC 的——L 参数
 
LD_PRELOAD
 
系统中另外还有一个环境变量叫做LD_PRELOAD,这个文件中我们可以指定预先加载的一些共享库或是目标文件。在这个文件里面指定的文件会在动态链接器按照固定规则搜索共享库之前装载，它比上一个路径里面锁指定的目录中的共享库还要优先。由于全局符号介入这个机制的存在，LD_PRELOAD里面指定的共享库或目标文件文件中的全局符号就会覆盖后面加载的同名全局符号，就可以使我们方便的改写标准C 库中的某几个函数或影响某几个其它函数。
 
另外还有一个有用的全局变量：LD_DEBUG
使用方法：
 $LD_DEBUG = files ./helloword.out
直接在命令行使用就可以看到这个可执行文件的的装载整个过程。
 
Bindings  :  显示-动态链接与符号的全过程
files     :  显示装载过程
libs      :  显示共享库的查找过程
versions  :  显示符号的版本依赖关系
reloc     :  显示重定位的过程
symbols   :  显示符号表的查找的过程
statistics:  显示动态链接过程中的各种统计信息
all       :  显示以上的所有信息
help      :  显示上面的各种可选值的帮助信息
 
共享库的创建与安装：

创建共享库：
首先GCC 有一个参数-wl 参数这个参数可以将指定的参数传递给链接器
      例如：
     gcc -shared -fPIC -Wl,-soname,my_soname -o libray_name source_files
        library_files
 
比如，我们拥有连各个C文件我们想把他们做成库文件。
 
两种方法：
 
gcc -shared -fPIC -Wl,-soname,libfoo.so.1 -o libfoo.so.1.0.0 libfoo1.c libfoo2.c
-lbar1 -lbar2
 
 也可以分开制作：
 
gcc -c -g -Wall -o libfoo1.o libfoo1.c
gcc -c -g -Wall -o libfoo2.o libfoo1.c
ld -shared -soname libfoo.so.1 -o libfoo.so.1.0.0 libfoo1.o libfoo2.o -lbar1 -lbar2
 
几个注意事项:
 
不要把输出共享库中的符号和调试信息去掉，也不要使用gcc 的 -fomit-frame-pointer 选项
 
有时候如果需要调试程序但是又不希望影响现有的程序正常运行。使用LD_LIBRARY_PATH是一个很好的方法。一可以使用-rpath 这是链接器参数，GCC 参数(-Wl ,rpath)指定链接产生的目标程序的共享库查找路径
$ld -rapth /home/mylib -o program.out program.o -lsomelib
这样产生的输出可执行文件program.out 在被动态链接器装载时，动态链接器会首先在/home/mylib下查找动态库。
 
还有一个放止反向引用失败的参数 -Wl ,-export-dynamic
 
 
8.清除符号信息

正常情况下编译出来的共享库或者可执行文件里面带有符号信息和调试信息，这些信息在调试时非常有用，但是对于最终发布版本来说，这些符号信息用处并不大，并且使得文件尺寸边大。我们可以使用一个叫做strip 工具 。
$strip libfoo.so
也可以使用链接器的-S -s 两个参数，-S消除调试符号信息，-s消除所有符号信息，GCC 使用-Wl,-s
或者-Wl ,-S
 
9.共享库的安装
 
首先将库复制到某个标准的库目录中，然后使用ldconfig即可。
 
9.共享库构造函数与析构函数
 
很多时候我们希望在加载的时候能执行一些函数，其实只要在函数声明时加上__attribute__((constructor)) 的属性，就是指定该函数为共享库构造函数，这种函数就会在加载时执行，就是在main ( )函之前执行。如果打开共享库，就会在打开函数返回之前执行。
 
相对应的就是析构函数，同样也会私一个参数__attribute__((destoructor)),析构函数会在关闭共享库函数返回前执行完毕。
eg.void __attribute__((constructor)) add(int a ,int b)
 
当有多个函数的时候是有优先级之分的。
例如：
void __attribute__((constructor(5)) init_fun1(void)
    数子5就是优先级。
对于构造函数来说，属性中优先级数子越小的函数将会在优先级大的函数之前执行，对于析构函数正好向反。
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

杭电（hdu）2097 Sky数

Sky数
Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 17086    Accepted Submission(s): 9773



Problem Description

Sky从小喜欢奇特的东西，而且天生对数字特别敏感，一次偶然的机会，他发现了一个有趣的四位数2992，这个数，它的十进制数表示，其四位数字之和为2+9+9+2=22，它的十六进制数BB0，其四位数字之和也为22，同时它的十二进制数表示1894，其四位数字之和也为22，啊哈，真是巧啊。Sky非常喜欢这种四位数，由于他的发现，所以这里我们命名其为Sky数。但是要判断这样的数还是有点麻烦啊，那么现在请你帮忙来判断任何一个十进制的四位数，是不是Sky数吧。


 


Input

输入含有一些四位正整数，如果为0，则输入结束。


 


Output

若n为Sky数，则输出“#n is a Sky Number.”，否则输出“#n is not a Sky Number.”。每个结果占一行。注意：#n表示所读入的n值。


 


Sample Input

2992
1234
0


 


Sample Output

2992 is a Sky Number.
1234 is not a Sky Number.


 


Source

2007省赛集训队练习赛（2）

 
主要考察的是进制转换，掌握了进制转换，也就是水题一道了，呵呵！！
代码如下：
#include <iostream>
#include <cstring>
#include <stack>
using namespace std;

stack<int> s;
void hex(int x,int y)
{
	int r=1;
	while(x)
	{
		r=x%y;
		s.push(r);
		x=x/y;
	}
}

int main()
{
	int n,sum1,sum2,sum3;
	while(cin>>n,n)
	{
		int k=n;
		sum1=sum2=sum3=0;
		while(k)
		{
			sum1+=k%10;
			k=k/10;
		}
		hex(n,12);
		while(!s.empty())
		{
			sum2+=s.top();
			s.pop();
		}
		hex(n,16);
		while(!s.empty())
		{
			sum3+=s.top();
			s.pop();
		}
		if(sum1==sum2&&sum2==sum3)
		cout<<n<<" is a Sky Number."<<endl;
		else cout<<n<<" is not a Sky Number."<<endl;
	}
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。欢迎读者评论和指正

poj 1988 Cube Stacking(并查集)
题目来源：poj-1988 
题目大意： 
       给出n个立方体，可以将立方体移到其他立方体上形成堆；有p个如下操作： 
       ⑴M X Y； 将X堆移动到Y所在堆上面； 
       ⑵C X ； 输出在X所在堆下面的堆的个数。 
题目分析： 
       使用并查集来解决，关键在于如何存储和更新每个立方体，在并查集基础上，再添加两个数组，dis[]用来存放在x下面的立方体个数，sum[]用来存放x所在堆的立方体总个数。对每一堆立方体，用立方体堆底的元素表示根节点，并且只用堆底元素表示该堆的立方体总个数。dis为0表示在堆底。在查找函数中，向上查找根节点，并保存当前节点的父节点,记为t，找到根节点后依次向下更新节点的dis，sum值。sum[x]==0时，表示x不在堆底，所以将x的dis加上其父节点的dis值；sum[x]！=0时，表示x在堆底需进行三个操作：dis[x]+=sum[t];sum[t]+=sum[x]; sum[x]=0;在合并函数中，合并完后再对x,y执行一次查找，来更新对应堆的值，因为在下次合并的时候，可能未来得及更新。 
AC代码：
#include<stdio.h>
#include<string.h>
#define MAX 30010
int per[MAX];       //存放父节点 
int dis[MAX];       //dis[x]表示x下面的立方体个数 
int sum[MAX];       //sum[x]表示x所在立方体总个数 
int n;
void init()         //初始化 
{
    for(int i=1;i<=MAX;i++)
    {
        per[i]=i;
        sum[i]=1;
        dis[i]=0;
    }
}
int find(int x)     //查找函数 
{
    if(x!=per[x])
    {
        int t=per[x];
        per[x]=find(per[x]);
        if(sum[x])      //sum[x]！=0时 
        {
            dis[x]+=sum[t]; //父节点的个数加到x上 
            sum[t]+=sum[x]; //总个数加到父节点上 
            sum[x]=0;       //每个堆只用最底的表示总个数 
        }
        else
        dis[x]+=dis[t];     //sum[x]==0,说明不是堆底，就加到x上继续查找 
    }
    return per[x];
}
void join(int x,int y)      //合并函数 
{
    int fx=find(x);
    int fy=find(y);
    per[fx]=fy;
    find(x);                //再次查找，防止未更新堆值 
    find(y);
}
int main()
{   
    init();
    scanf("%d",&n);
    getchar();
    char ch;
    int x,y;
    for(int i=0;i<n;i++)
    {
        scanf("%c",&ch);
        getchar();
        if(ch=='M')             //输入'M'则连接两个堆 
        {
            scanf("%d%d\n",&x,&y);
//          getchar();          //用此吸收则输入老出错 
            join(x,y);
        }
        else                    //输入'C'则输出x所在堆下面的个数 
        {
            scanf("%d",&x);
            getchar();
            find(x);
            printf("%d\n",dis[x]);
        }
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

ZOJ问题(2010浙江大学研究生复试上机题目[找规律] hdoj 3788)


ZOJ问题

点击打开链接
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 3341    Accepted Submission(s): 1002



Problem Description

对给定的字符串(只包含'z','o','j'三种字符),判断他是否能AC。

是否AC的规则如下：
1. zoj能AC；
2. 若字符串形式为xzojx，则也能AC，其中x可以是N个'o' 或者为空；
3. 若azbjc 能AC，则azbojac也能AC，其中a,b,c为N个'o'或者为空；

 


Input

输入包含多组测试用例，每行有一个只包含'z','o','j'三种字符的字符串，字符串长度小于等于1000；

 


Output

对于给定的字符串，如果能AC则请输出字符串“Accepted”，否则请输出“Wrong Answer”。

 


Sample Input

zoj
ozojo
ozoojoo
oozoojoooo
zooj
ozojo
oooozojo
zojoooo


 


Sample Output

Accepted
Accepted
Accepted
Accepted
Accepted
Accepted
Wrong Answer
Wrong Answer


 


Source

浙大计算机研究生复试上机考试-2010年

 
题目来源:点击打开链接  点击打开链接  点击打开链接
思路:
    z前面'o'的个数×z和j中间o的个数=j后面o的个数
    oozoojoooo：
    若azbjc 能AC，则azbojac也能AC，其中a,b,c为N个'o'或者为空；
    这里的话a=oo b=o c=oo
    把a,b,c带进去翻译过来是
                      若oozojoo能AC（当然能AC 根据第1条） 则oozoojoooo也能AC，所以能AC
      zooj ： 
      也是根据第3条 这里a=空 c=空 b=o
      翻译过来是
       若zoj能AC 则zooj能AC
       若azbjc 能AC，则azbojac也能AC，其中a,b,c为N个'o'或者为空；
   这里azbojac和azbjc相比 z和j中间+了一个o   j后面就+了一个a 而z前面也有一个a
   以此类推
   如果再执行一次这个规定
    那么z和j中间就+了2个o   后面也+了2个前面的a 
   ...
   所以z前面'o'的个数乘以z和j中间o的个数=j后面o的个数。


#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
#define M 1010
char s[M];
int main()
{
    while(~scanf("%s",s))
    {
         int len=strlen(s)-1;
         int  i=0,a=0;
          while(s[i++]=='o')
              a++;    
          int c=0;
          while(s[len--]=='o')
              c++;
              
           int p1=0,p2=0,b=0;
          for(int j=i-1;j<=len+1;j++)
          {
               if(s[j]=='z')
                p1++;
               if(s[j]=='o')
                 b++;
                if(s[j]=='j')
                  p2++;   
          }
          
        if(s[i-1]=='z'&&s[len+1]=='j')
        {
          if(b>0&&b*a==c&&(p1==1)&&(p2==1))
           printf("Accepted\n");
          else
           printf("Wrong Answer\n");
        }
        else
           printf("Wrong Answer\n");
    }
    return 0;
}

























版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 题目 3693 Maximum repetition substring（后缀数组+RMQ+枚举求最小字典序的重复次数最多的子串）
Maximum repetition substring




Time Limit: 1000MS
 
Memory Limit: 65536K


Total Submissions: 8067
 
Accepted: 2463




Description


The repetition number of a string is defined as the maximum number R such that the string can be partitioned into
R same consecutive substrings. For example, the repetition number of "ababab" is 3 and "ababa" is 1.
Given a string containing lowercase letters, you are to find a substring of it with maximum repetition number.


Input


The input consists of multiple test cases. Each test case contains exactly one line, which
gives a non-empty string consisting of lowercase letters. The length of the string will not be greater than 100,000.
The last test case is followed by a line containing a '#'.


Output


For each test case, print a line containing the test case number( beginning with 1) followed by the substring of maximum repetition number. If there are multiple substrings of maximum repetition number, print the lexicographically smallest one.


Sample Input
ccabababc
daabbccaa
#
Sample Output
Case 1: ababab
Case 2: aa
思路先求重复次数最多的子串的重复次数，重复次数一样的存下他的循环节长度，然后枚举sa，先符合的一定是最小字典序的
ac代码
Problem: 3693		User: kxh1995
Memory: 10500K		Time: 422MS
Language: C++		Result: Accepted
#include<stdio.h>         
#include<string.h>         
#include<algorithm>         
#include<iostream>        
#define min(a,b) (a>b?b:a)     
#define max(a,b) (a>b?a:b)      
using namespace std;        
char str[103030];      
int sa[103030],Rank[103030],rank2[103030],height[103030],c[103030],*x,*y,s[103030],ans[100010];    
int n;    
void cmp(int n,int sz)    
{    
    int i;    
    memset(c,0,sizeof(c));    
    for(i=0;i<n;i++)    
        c[x[y[i]]]++;    
    for(i=1;i<sz;i++)    
        c[i]+=c[i-1];    
    for(i=n-1;i>=0;i--)    
        sa[--c[x[y[i]]]]=y[i];    
}    
void build_sa(char *s,int n,int sz)    
{    
    x=Rank,y=rank2;    
    int i,j;    
    for(i=0;i<n;i++)    
        x[i]=s[i],y[i]=i;    
    cmp(n,sz);    
    int len;    
    for(len=1;len<n;len<<=1)    
    {    
        int yid=0;    
        for(i=n-len;i<n;i++)    
        {    
            y[yid++]=i;    
        }    
        for(i=0;i<n;i++)    
            if(sa[i]>=len)    
                y[yid++]=sa[i]-len;    
            cmp(n,sz);    
        swap(x,y);    
        x[sa[0]]=yid=0;    
        for(i=1;i<n;i++)    
        {    
            if(y[sa[i-1]]==y[sa[i]]&&sa[i-1]+len<n&&sa[i]+len<n&&y[sa[i-1]+len]==y[sa[i]+len])    
                x[sa[i]]=yid;    
            else    
                x[sa[i]]=++yid;    
        }    
        sz=yid+1;    
        if(sz>=n)    
            break;    
    }    
    for(i=0;i<n;i++)    
        Rank[i]=x[i];    
}    
void getHeight(char *s,int n)    
{    
    int k=0;    
    for(int i=0;i<n;i++)    
    {    
        if(Rank[i]==0)    
            continue;    
        k=max(0,k-1);    
        int j=sa[Rank[i]-1];    
        while(s[i+k]==s[j+k])    
            k++;    
        height[Rank[i]]=k;    
    }    
}  
int minv[103010][20],lg[103030];    
void init_lg()  
{  
    int i;  
    lg[1]=0;  
    for(i=2;i<102020;i++)  
    {  
        lg[i]=lg[i>>1]+1;  
    }  
}  
void init_RMQ(int n)  
{  
    int i,j,k;  
    for(i=1;i<=n;i++)  
    {  
        minv[i][0]=height[i];  
    }  
    for(j=1;j<=lg[n];j++)    
    {    
        for(k=0;k+(1<<j)-1<=n;k++)    
        {    
            minv[k][j]=min(minv[k][j-1],minv[k+(1<<(j-1))][j-1]);     
        }    
    }  
}  
int lcp(int l,int r)  
{  
    l=Rank[l];  
    r=Rank[r];  
    if(l>r)  
        swap(l,r);  
    l++;  
    int k=lg[r-l+1];  
    return min(minv[l][k],minv[r-(1<<k)+1][k]);    
} 
int main()
{
	int c=0;
	while(scanf("%s",str)!=EOF)
	{
		int i,j,k;
		if(str[0]=='#')
			break;
		n=strlen(str);
		build_sa(str,n+1,128);
		getHeight(str,n);
		init_lg();
		init_RMQ(n);
		int maxn=0,num=0;
		for(i=1;i<n;i++)
		{
			for(j=0;j+i<n;j+=i)
			{
				int k=lcp(j,j+i);
				int now=k/i;
				int tj=j-(i-k%i);
				if(tj>=0)
				{
					if(lcp(tj,tj+i)>=i-k%i)
						now++;
				}
				if(now>maxn)
				{
					num=0;
					ans[num++]=i;
					maxn=now;
				}
				else
					if(now==maxn)
						ans[num++]=i;
			}
		}
		int flag=0,len,st;
		for(i=1;i<=n;i++)
		{
			if(flag)
				break;
			for(j=0;j<num;j++)
			{
				int temp=ans[j];
				if(lcp(sa[i],sa[i]+temp)>=maxn*temp)
				{
					st=sa[i];
					len=temp*(maxn+1);
					flag=1;
				}
			}
		}
		printf("Case %d: ",++c);
		for(i=0;i<len;i++)
		{
			printf("%c",str[st+i]);
		}
		printf("\n");
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

LeetCode-Best Time to Buy and Sell Stock I II III IV


此处的三个题跟Maximum Subarray，可以先看此题

I)

Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

此题的第一个，动态规划算法。状态转移方程f(i) = Max(maxProfit, prices[i]-minPrice)

    public int maxProfit(int[] prices) {
        int maxPro = 0;
        int minPrice = Integer.MAX_VALUE;
        for(int i = 0; i < prices.length; i++){
            minPrice = Math.min(minPrice, prices[i]);
            maxPro = Math.max(maxPro, prices[i] - minPrice);
        }
        return maxPro;
    }算法从前向后遍历这个数组，minPrice是指prices[0...i]的最小值，maxPro是指在prices[0...i]的最大利润

当然也可以从后向前遍历，如下：

    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
		int max = prices[prices.length-1];
		int maxProfit = 0;
		for (int i = prices.length-1; i >= 0; i--) {
			max = Math.max(max, prices[i]);
			maxProfit = Math.max(maxProfit, max-prices[i]);
		}
		return maxProfit;
    }max是指prices[i...n-1]的最大值，maxPro是指在prices[i...n-1]的最大利润

还有一种解法，如下：

    public int maxProfit(int[] prices) {
        int maxPro = 0;
        int maxCur = 0;
        for(int i = 1; i < prices.length; i++){
            maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);
            maxPro = Math.max(maxPro, maxCur);
        }
        return maxPro;
    }II）

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock
 before you buy again).
第二题，没有限制次数，很显然贪心算法，如下：

    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int max = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i]-prices[i-1] > 0) max += prices[i]-prices[i-1];
        }
        return max;
    }III)



Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

第三题的限制为最多交易两次，所以我们就可以根据第一题。把此题分解为在i之前交易一次，在i之后交易一次。状态转移方程为：

f(2, 0, n) = Max{ f(1, 0, i)+f(1, i, n) } i = 1, 2, 3...n 其中f(k, m, n)表示交易在prices[m...n]直接交易k次的最大利润，代码如下：

public int maxProfit1(int[] prices) {
    	if (prices == null || prices.length == 0) return 0;
    	int max = 0;
    	for (int i = 0; i < prices.length; i++) {
    		int curProfit = maxProfit1(prices, 0, i) + maxProfit1(prices, i, prices.length);
    		max = Math.max(max, curProfit);
    	}
    	return max;
    }
    private int maxProfit1(int[] prices, int s, int e) {
    	if (s > e) return 0;
    	int min = prices[s];
    	int maxProfit = 0;
    	for (int i = s; i < e; i++) {
    		min = Math.min(min, prices[i]);
    		maxProfit = Math.max(maxProfit, prices[i]-min);
    	}
    	return maxProfit;
    }代码超时，因为有重复子问题。所以我们可以根据问题I，将结果保存在数组中，之后在查询。

    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
    	int max = 0;
    	//以i为结尾的最大利润，即[0...i]
    	int[] maxEH = maxEndingHere(prices);
    	//以i为起始的最大利润，即[i...n]
    	int[] maxBH = maxBeginingHere(prices);
    	for (int i = 0; i < prices.length; i++) {
    		int curProfit = maxEH[i]+maxBH[i];
    		max = Math.max(max, curProfit);
    	}
    	return max;
	}
	
	private int[] maxEndingHere(int[] prices) {
		int[] ret = new int[prices.length];
		int min = prices[0];
		for (int i = 1; i < prices.length; i++) {
			min = Math.min(min, prices[i]);
			ret[i] = Math.max(ret[i-1], prices[i]-min);
		}
		return ret;
	}
	
	private int[] maxBeginingHere(int[] prices) {
		int[] ret = new int[prices.length];
		int max = prices[prices.length-1];
		for (int i = prices.length-1; i > 0; i--) {
			max = Math.max(max, prices[i]);
			ret[i] = Math.max(ret[i-1], max-prices[i]);
		}
		return ret;
    }当然可以把代码中的三个循环合并为两个。此题还有其他解法，一会在讲解。

IV)


Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
最难的一个，先写出来状态转移方程。

f(k, i) = max{ f(k, i-1), max { f(k-1, j-1)+prices[i]-prices[j] } } j = 0, 1, 2...i-1
f(0, i) = 0, f(k, 0) = 0

其中f(k,i)是指在用prices[0...i]，k次交易所得到的最大利润，分析状态转移方程，对于prices[i]来说，有两种选择：

1）不参加，则问题退化为在k次交易的前提下，只用prices[0...i-1]，即f(k, i-)

2）参加交易，则此时i必须为出售的价格，因为这是交易的最后一天。所以有prices[i]-prices[j]  + f(k-1, j-1) j = 0. 1. i-1找最大值

对上述问题求最大值。

代码如下：


    public int maxProfit(int k, int[] prices) {
    	if (prices == null || prices.length == 0) return 0;
        if (k >= prices.length/2) {
        	//退化成问题II
        	return maxProfit(prices);
        }
        //f(k, i) = max{ f(k, i-1), max { f(k-1, j-1)+prices[i]-prices[j] } } j = 0, 1, 2...i-1
        //f(0, i) = 0, f(k, 0) = 0
        //f(k, i) = max{ f(k, i-1), prices[i]+max { f(k-1, j-1)-prices[j] } } j = 0, 1, 2...i-1
        //令tempMax = max { f(k-1, j-1)-prices[j] } j = 0, 1, 2...i-1
        int[][] dp = new int[k+1][prices.length];
        for (int i = 1; i <= k; i++) {
        	int tempMax = -prices[0];
        	for (int j = 1; j < prices.length; j++) {
        		dp[i][j] = Math.max(dp[i][j-1], tempMax+prices[j]);
        		tempMax = Math.max(tempMax, dp[i-1][j-1]-prices[j]);
        	}
        }
        return dp[k][prices.length-1];
    }
    
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int max = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i]-prices[i-1] > 0) max += prices[i]-prices[i-1];
        }
        return max;
    }其中，tempMax是指，在进行i-1次交易，并且只用前j-1的prices，并且此时已经买了price[j]的最大值。而内层循环一直在寻找进行了i-1次交易，并且买了prices[j]的股票的最大值。tempMax+prices[j]是指之前已经买了股票，现在要在prices[j]出售

有了上述解法，问题三也有了新的解法，即k=2。但是还有更简单的表述方式。如下：

public int maxProfit(int[] prices) {
        int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;
        int release1 = 0, release2 = 0;
        for(int i:prices){                              // Assume we only have 0 money at first
            release2 = Math.max(release2, hold2+i);     // The maximum if we've just sold 2nd stock so far.
            hold2    = Math.max(hold2,    release1-i);  // The maximum if we've just buy  2nd stock so far.
            release1 = Math.max(release1, hold1+i);     // The maximum if we've just sold 1nd stock so far.
            hold1    = Math.max(hold1,    -i);          // The maximum if we've just buy  1st stock so far. 
        }
        return release2; ///Since release1 is initiated as 0, so release2 will always higher than release1.
    }其实也是基于上述递推公式的。



























版权声明：本文为博主原创文章，未经博主允许不得转载。

有时候，事情就是很简单，可是你就是找不到原因
如果使用CI框架，修改php.ini文件的
display_errors = Off
还不能将输出错误到页面关闭掉，
只有修改index.php文件中的
define('ENVIRONMENT', 'production');
才可以将输出错误到页面真正关闭掉。
之所以需要关闭错误是因为，有时候返回前台json时，被php输出的警告和错误搞的json格式都不对了。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：欢迎转载，转载请注明原地址，谢谢！

排序方法总结和实现
由于很多大神已经总结过各种排序算法的性能及适合坏境，这里便不再总结，只是强调几个重点。
（1）快排的空间复杂度不是o(1)，是o(logn)~o(n)；
（2）四种不稳定的排序算法：简单选择，快排，希尔和堆排序
（3）冒泡排序最有情况下时间复杂度可优化为o(n)；
（4）归并排序的空间复杂度为o(n)；
（5）快排在整体倒序的情况下时间复杂度为o(n2)
（6）建一个最大堆的复杂度为o(n)：具体证明可参考算法导论相关章节
（7）本文代码的归并排序的范围是[   )
（8）本文代码的堆排序为了方便从a[1]开始
（9）在添加了语句using namespace std;语句之后，swap函数才可以使用
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<iostream>
using namespace std;

void print(int *number, int length)
{
    if(number == NULL || length < 1)
        return;

    for(int i = 0; i < length; ++i)
    {
        printf("%d ", number[i]);
    }

    printf("\n");
}

void SelectSort(int number[], int length)
{
    if(number == NULL || length < 1)
        return;

    for(int i = 0; i < length - 1; ++i)
    {
        int k = i;
        for(int j = i + 1; j < length; ++j)
        {
            if(number[k] > number[j])//注意大小于号
                k = j;
        }
        if(k != i)
        {
            swap(number[k], number[i]);
        }
    }
}

void BubbleSort(int number[], int length)
{
    if(number == NULL || length < 1)
        return;

    for(int i = 1; i < length; ++i)
    {
        for(int j = 0; j < length - i; ++j)
            if(number[j] > number[j + 1])
                swap(number[j], number[j + 1]);
    }
}

void InsertSort(int *number, int length)
{
    if(number == NULL || length < 1)
        return;

    for(int i = 1; i < length; ++i)
    {
        int tmp = number[i];
        int j;                   //在外面定义
        for(j = i - 1; j >= 0; j--)
        {
            if(number[j] > number[i])//比较的顺序别弄错了
                number[j + 1] = number[j];//最好检查一下
            else
                break;
        }
        
        number[j+1] = tmp;
    }
}

void ShellSort(int number[], int length)
{
    if(number == NULL || length < 1)
        return;

    int i, j, d;
    d = length/2;

    while(d >= 1)
    {
        for(i = d; i < length; ++i)
        {
            int tmp = number[i];
            for(j = i - d; j >= 0; j -= d)
            {
                if(number[j] > number[i])
                    number[j + d] = number[j];
                else
                    break;
            }
            number[j + d] = tmp;
        }
        d /= 2;
    }
}

int partion(int number[], int length, int start, int end)
{
    if(number == NULL || length < 1 || start < 0 || end >= length)
        return -1;

    int small = start - 1;
    for(int index = start; index < end; ++index)
    {
        ++small;
        if(number[index] < number[end])
        {
            if(small != index)
                swap(number[small], number[index]);
        }
    }
    ++small;
    swap(number[small], number[end]);

    return small;
}
void QuickSort(int number[], int length, int start, int end)// [start, end]
{
    if(number == NULL || length < 1)
        return;

    if(start == end)
        return;

    int index = partion(number, length, start, end);
    if(index > start)
        QuickSort(number, length, start, index - 1);
    if(index < end)
        QuickSort(number, length, index + 1, end);
}

void MergeSort(int number[], int length, int start, int end, int tmp[])//[start, end)
{
    if(number == NULL || length < 1 || start < 0 || end < 1)
        return;

    //int middle = start + (end - start)/2;
    if(end - start > 1)//while(start < end)
    {
       int middle = start + (end - start)/2;
       int p = start;
       int q = middle;
       int i = start;
       MergeSort(number, length, start, middle, tmp);
       MergeSort(number, length, middle, end, tmp);

       while(p < middle || q < end)
       {
           if(q >= end || (p < middle && number[p] < number[q]))// q < end 
                tmp[i++] = number[p++];
           else
               tmp[i++] = number[q++];
       }

       for(int index = start; index < end; ++index)
           number[index] = tmp[index];
    }
}

void AjustHeap(int number1[], int i, int size)
{
    if(number1 == NULL || i < 1 || size < 1)
        return;

    int leftChild = 2 * i;
    int rightChild = 2 * i + 1;
    int max = i;

    if(i <= size/2 )// max <= size 是错的
    {
        if(leftChild <= size && number1[leftChild] > number1[max])
            max = leftChild;
        if(rightChild <= size && number1[rightChild] > number1[max])
            max = rightChild;
        if(max != i)
        {
            swap(number1[max], number1[i]);
            AjustHeap(number1, max, size);
        }

    }

}
void BuildMaxHeap(int number1[], int size)
{
    if(number1 == NULL || size < 1)
        return;

    for(int i = size/2; i >= 1; --i)
        AjustHeap(number1, i, size);
}
void HeapSort(int number1[], int size)
{
    if(number1 == NULL || size < 1)
        return;

    BuildMaxHeap(number1, size);

    for(int i = size; i >= 1; --i)
    {
        swap(number1[1], number1[i]);
        AjustHeap(number1, 1, i - 1);
    }
}
int main()
{
    int number[10] = {3, 5, 2, 10, 4, 1, 8, 7, 6, 9};
    //简单选择排序
    SelectSort(number, 10);
    print(number, 11);
    //冒泡排序
    BubbleSort(number, 10);
    print(number, 10);
    //插入排序
    InsertSort(number, 10);
    print(number, 10);
    //希尔排序
    ShellSort(number, 10);
    print(number, 10);
    //快速排序
    QuickSort(number, 10, 0, 9);
    print(number, 10);
    
    //归并排序
    int tmp[10];
    MergeSort(number, 10, 0, 10, tmp);
    print(number, 10);
    //堆排序，为了方便，堆排序从a[1]开始
    int number1[11] = {0, 3, 5, 2, 10, 4, 1, 8, 7, 6, 9};
    HeapSort(number1, 10);
    print(number1, 10);
    printf("%d\n",number1[10]);
    return 0;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

Leet -- Plus One
题目描述：Given a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list.给定1个数组，完成加1的操作。本题和大整数加法非常类似。 逻辑比较简单，直接实现就可以了当前位= num[i]%10进位= num[i]/10实现代码：public class Solution {
    public int[] PlusOne(int[] digits) {
        if (digits == null || digits.Length == 0){
		return null;
    	}
    	
    	
    	var len = digits.Length;
    	var c = digits[len-1] == 9 ? 1: 0;
    	
    	digits[len-1] = digits[len-1] == 9 ? 0 : digits[len-1] + 1;
    	
    	for(var i = len - 2;i >= 0 ; i--){
    		var s = digits[i] + c ;
    		c = s / 10;
    		digits[i] = s % 10;
    	}
    	
    	if(c > 0){
    		var arr = new List<int>{1};
    		arr.AddRange(digits);
    		return arr.ToArray();
    	}
    	
    	return digits;
    }
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

笔画
import java.util.*;



public class Main {
	static Main ybh = new Main();
	private class StackX {
		private final int SIZE=1000;
		private int[] st;
		private int top;
		public StackX(){
			st = new int[SIZE];
			top = -1;
		}
		public void push(int j){
			st[++top] = j;
		}
		
		public int pop(){
			return st[top--];
		}
		
		public int peek(){
			return st[top];
		}
		
		public boolean isEmpty(){
			return top==-1;
		}
	}

	private class Vertex {
		public int value;
		public boolean wasVisited;
		public Vertex(int a){
			this.value = a;
			this.wasVisited = false;
		}
	}

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int num = scan.nextInt();
		Vertex vertexList[] = new Vertex[num];
		int[][]adjArr = new int[num][num];
		int m = 1;
		int nVerts = 0;
		
		
		while(num>0){
			vertexList[nVerts++] = ybh.new Vertex(m);
			m++;
			int a = scan.nextInt();
			int b = scan.nextInt();
			adjArr[a-1][b-1] = 1;
			adjArr[b-1][a-1] = 1;
			num--;
		}
		//判断是否是连通图
		boolean flag = dfs(vertexList,adjArr,nVerts);
		if(flag){
			//判断每行1的个数，放进数组，循环数组，若素组元素均是偶数返回true,如果素组中有两个元素是奇数页返回true,否则返回false;
			int itemCount = 0;
			List<Integer> ll = new ArrayList<Integer>();
			for (int i = 0; i < adjArr.length; i++) {
				for (int j = 0; j < adjArr.length; j++) {
					if(adjArr[i][j] == 1)
						itemCount++;
				}
				ll.add(itemCount);
				itemCount = 0;
			}
			int []arr = new int[adjArr.length];
			Iterator<Integer> it = ll.iterator();
			int index = 0;
			while (it.hasNext()) {
				arr[index++] = it.next();
			}
			int odd = 0;
			int even = 0;
			for (int i = 0; i < arr.length; i++) {
				if(arr[i]%2==0)
					even++;
				else
					odd++;
			}
			if(even==arr.length || odd==2)
				System.out.println(true);
			else
				System.out.println(false);
		}
		else 
			System.out.println(false);
	}

	private static boolean dfs(Vertex[] vertexList, int[][] adjArr,int n) {
		StackX theStack = ybh.new StackX();
		vertexList[0].wasVisited = true;
		theStack.push(0);
		int count = 1;
		
		while (!theStack.isEmpty()) {
			int v = getAdjUnvisiedVertex(vertexList,theStack.peek(),adjArr,n);
			if(v==-1)
				theStack.pop();
			else{
				vertexList[v].wasVisited = true;
				theStack.push(v);
				count++;
			}
		}
		for (int i = 0; i < n; i++) {
			vertexList[i].wasVisited = false;
		}
		if(count == n)
			return true;
		else
			return false;
	}

	private static int getAdjUnvisiedVertex(Vertex[] vertexList,int v,int[][] adjArr,int nVerts) {
		for (int j = 0; j < nVerts; j++) {
			if(adjArr[v][j]==1 && vertexList[j].wasVisited == false)
				return j;
		}
		return -1;
	}

}


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 1695-GCD(容斥)
题目地址：HDU 1695 
题意：在[1,b]和[1,d]中各选一个数x,y,使得GCD(x,y)=k,求满足的（x,y）对数，(x,y)和(y,x)算一种。 
思路：GCD(x,y)=k 可以变换成GCD(x/k,y/k)=1。这也就变成了在[1,b/k]和[1,d/k]之间找到一个i,j，使得GCD[i,j]=1。因为(3,5)和(5,3)是同一种，所以我们让[1,b/k]为两个区间的小的区间,因为两个区间有相同的部分和不相同的部份,对于相同的部分按照容斥求完和之后/2，对于不同的部分直接按照容斥搞就好。注意K=0的情况。
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <bitset>
#pragma comment(linker, "/STACK:102400000,102400000")
using namespace std;
typedef __int64 LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
using namespace std;
const int Maxn=101000;
LL prime[Maxn];
LL sprime[Maxn];
bitset<Maxn>pri;
LL k,cnt;
void is_prime()
{
    pri.set();
    for(LL i=2; i<Maxn; i++) {
        if(pri[i]) {
            prime[k++]=i;
            for(LL j=i+i; j<Maxn; j+=i)
                pri[j]=0;
        }
    }
}
void Divide(LL n)
{
    cnt=0;
    LL t=(LL)sqrt(1.0*n);
    for(LL i=0; prime[i]<=t; i++) {
        if(n%prime[i]==0) {
            sprime[cnt++]=prime[i];
            while(n%prime[i]==0)
                n/=prime[i];
        }
    }
    if(n>1)
        sprime[cnt++]=n;
}

LL Ex(LL n)
{
    LL ans=0;
    LL tmp,flag;
    LL i,j;
    for(i=1; i<(LL)(1<<cnt); i++) {
        tmp=1;
        flag=0;
        for(j=0; j<cnt; j++)
            if(i&((LL)(1<<j))) {
                flag++;
                tmp*=sprime[j];
            }
        if(flag&1)
            ans+=n/tmp;
        else
            ans-=n/tmp;
    }
    return ans;
}
int main()
{
    int T;
    int icase=1;
    LL a,b,c,d,k;
    LL res;
    is_prime();
    scanf("%d",&T);
    while(T--) {
        res=0;
        scanf("%lld %lld %lld %lld %lld",&a,&b,&c,&d,&k);
        if(b>d) swap(b,d);
        if(k==0){
            printf("Case %d: 0\n",icase++);
            continue;
        }
        b=b/k;
        d=d/k;
        for(LL i=1; i<=b; i++) {
            Divide(i);
            res+=b-Ex(b);
        }
        res=(res+1)/2;
        for(LL j=b+1; j<=d; j++) {
            Divide(j);
            res+=b-Ex(b);
        }
        printf("Case %d: %lld\n",icase++,res);
    }

return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

poj 2506 Tiling(大数+规律)
poj2506Tiling 
            此题规律：A[0]=1;A[1]=1;A[2]=3;……A[n]=A[n-1]+2*A[n-2];用大数来写，AC代码：
#include<stdio.h>
#include<string.h>
#define MAX 300
int num[MAX][MAX];
int main()
{
    int n;
    while(scanf("%d",&n)!=EOF)
    {
        memset(num,0,sizeof(num));
        num[0][0]=1;
        num[1][0]=1;
        for(int i=2;i<=MAX;i++)
        {
            int t=0,k;
            for(int j=0;j<=MAX;j++)
            {
                k=2*num[i-2][j]+num[i-1][j]+t;
                num[i][j]=k%10;
                t=k/10;
            }       
        }
        int i;
        for(i=MAX-1;num[n][i]==0;i--);
        printf("%d",num[n][i]);
        while(i)
            printf("%d",num[n][--i]);
        printf("\n");
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU   4272  LianLianKan（模拟）

LianLianKan
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 3292    Accepted Submission(s): 996



Problem Description

I like playing game with my friend, although sometimes looks pretty naive. Today I invent a new game called LianLianKan. The game is about playing on a number stack.
Now we have a number stack, and we should link and pop the same element pairs from top to bottom. Each time, you can just link the top element with one same-value element. After pop them from stack, all left elements will fall down. Although the game seems
 to be interesting, it's really naive indeed. 


To prove I am a wisdom among my friend, I add an additional rule to the game: for each top element, it can just link with the same-value element whose distance is less than 6 with it. 
Before the game, I want to check whether I have a solution to pop all elements in the stack.


 


Input

There are multiple test cases.
The first line is an integer N indicating the number of elements in the stack initially. (1 <= N <= 1000)
The next line contains N integer ai indicating the elements from bottom to top. (0 <= ai <= 2,000,000,000)

 


Output

For each test case, output “1” if I can pop all elements; otherwise output “0”.

 


Sample Input

2
1 1
3
1 1 1
2
1000000 1


 


Sample Output

1
0
0


 


Source

2012 ACM/ICPC Asia Regional Changchun Online









    题意:给出一个序列，其中距离不超过6的两个相同的数字可以消除掉，现在问把能消除的全部消除之后序列中是不是还有数字，有的话输出0，没有的话输出1


思路：按照题意模拟一遍然后判断是不是为空就可以了


点击打开链接







#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<queue>
#include<stack>
#include<vector>
#include<map>

using namespace std;

int n;
__int64 a[10010];
int v[10010];
__int64 b[10010];

int main() {
    while(scanf("%d",&n)!=EOF) {
        for(int i=1; i<=n; i++) {
            scanf("%I64d",&a[i]);
        }
        memset(v,0,sizeof(v));
        int t = 0;
        int flag;
        for(int i=1; i<=n; i++) {
            int pt = t;
            flag = 0;
            if(v[i] == 1){
				continue;
            }
            for(int k=1; k<=t; k++) {
                if(a[i] == b[k]) {
                    for(int pi=k; pi<t; pi++) {
                        b[pi] = b[pi+1];
                    }
                    t--;
                    flag = 1;
                }
            }
            if(pt == t) {
                int pf = 0;
                for(int j=i+1; j<=i+5 && j<=n; j++) {
                    if(a[i] == a[j]) {
                        v[i] = 1;
                        v[j] = 1;
                        pf = 1;
                        break;
                    }
                }
                if(pf == 0) {
                    b[++t] = a[i];
                }
            }
        }
        if(t == 0) {
            printf("1\n");
        } else {
            printf("0\n");
        }
    }
    return 0;
}



 

版权声明：本文为博主原创文章，如有特殊需要请与博主联系  QQ ： 793977586。

归并排序

归并排序

归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。

归并操作

归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。

如　设有数列{6，202，100，301，38，8，1}

初始状态：6,202,100,301,38,8，1

第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；

第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；

第三次归并后：{1,6,8,38,100,202,301},比较次数：4；

总的比较次数为：3+4+4=11,；

逆序数为14；

用途

排序

（速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列，应用见2011年普及复赛第3题“瑞士轮”的标程）

求逆序对数

具体思路是，在归并的过程中计算每个小区间的逆序对数，进而计算出大区间的逆序对数（也可以用树状数组来求解）.





对于原始的数组2,1,3,8,5,7,6,4,10，在整个过程执行的是顺序是途中红色编号1-20。虽然我们描述中说的是程序先分解，再归并，但实际过程是一边分解一边归并，前半部分分先排好序，后半部分再排好，最后整个归并为一个完整的序列，途中的merge过程它所在层的两个序列的merge过程：下图展示了每个merge过程对作用于数组的哪部分（红色）。





整个过程就像一个动态的树，执行顺序就是对树的先序遍历顺序。

 

C代码：

#include <stdio.h>

#include <stdlib.h>

 

void MergeArray(int a[], int temp[] , int start , int middle , int end)

{

     int i,j,s,m,e;

     i=start;

     s = start ;

     m = middle+1 ;

     e = end ;

    

     while((s <= middle)&&(m <= end))//因为包含开始和结束字符，所以用 <=

     {

         if(a[s] < a[m])

         {

              temp[i++] = a[s++] ;

         }

        

         else

         {

              temp[i++] = a[m++] ;

         }

     }

    

     while(s <= middle)

     {

         temp[i++] = a[s++] ;

     }

    

     while(m <= end)

     {

         temp[i++] = a[m++] ;

     }

    

     for(j = start ; j <= end ; j++)

     {

         a[j] = temp[j];

     }   

}

 

void MergeSort(int a[],int temp[],int start ,int end)

{

     int middle ;

     if(start < end)

     {

         middle = (start + end)/2 ;

         MergeSort(a , temp , start , middle);//通过递归层层划分，使左边有序

         MergeSort(a , temp , middle+1 , end);//右边有序

         MergeArray(a, temp , start , middle , end);//序列合并

     }

}

 

int main(int argc, char *argv[])

{

     int a[9] = {2,1,3,8,5,7,6,4,10};

     int temp[9] ;

     int i;

     MergeSort(a , temp , 0 ,8);

     for(i = 0 ; i <= 8 ; i ++)

     {

         printf("%d ",a[i]);

     }

     return 0;

}

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

更改点后输出把集合里的点通过树的边连在一起所需要的最小代价  LCA+树状数组 HDU 5296 Annoying problem

Annoying problem
Time Limit: 16000/8000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 1127    Accepted Submission(s): 369



Problem Description

Coco has a tree, whose nodes are conveniently labeled by 1,2,…,n, which has n-1 edge，each edge has a weight. An existing set S is initially empty.
Now there are two kinds of operation:

1 x： If the node x is not in the set S, add node x to the set S
2 x： If the node x is in the set S,delete node x from the set S

Now there is a annoying problem: In order to select a set of edges from tree after each operation which makes any two nodes in set S connected. What is the minimum of the sum of the selected edges’ weight ?



 


Input

one integer number T is described in the first line represents the group number of testcases.( T<=10 ) 
For each test:
The first line has 2 integer number n,q(0<n,q<=100000) describe the number of nodes and the number of operations.
The following n-1 lines each line has 3 integer number u,v,w describe that between node u and node v has an edge weight w.(1<=u,v<=n,1<=w<=100)
The following q lines each line has 2 integer number x,y describe one operation.（x=1 or 2,1<=y<=n）




 


Output

Each testcase outputs a line of "Case #x:" , x starts from 1.
The next q line represents the answer to each operation.



 


Sample Input

1
6 5
1 2 2
1 5 2
5 6 2
2 4 2
2 3 2
1 5
1 3
1 4
1 2
2 5


 


Sample Output

Case #1:
0
6
8
8
4


 


Author

FZUACM

 


Source

2015 Multi-University Training Contest 1

 


题意

给定一棵树以及q个询问。初始一个空的集合。两种询问，一种是往集合里添加一个点，一种是从集合里删除已经存在的点。对于每次询问，输出把集合里的点通过树的边连在一起所需要的最小代价（每条边都有权值）
思路



首先对这棵树预处理出DFS序。对集合的操作相当于构造了一棵新的树。


首先我们考虑插入操作。在已有的集合里寻找DFS序比操作点u大的最小点y以及小于操作点的最大点x。我们可以得到一个结论，联通这三点的路径是必须要加在新构造的树上的。（从x访问到y之间的路上不会出现集合上的点，加入u后，从x到u，u到y的路上也同样不会有集合上的点）所以我们只需要在现有的答案上加上u点到xy链的距离即可。这个距离就要通过求LCA来计算，公式




假设节点要连接到一个链中，链的定点(x,y)，那么 u连接到x的距离是dfn[u] + dfn[x] - 2dfn[ lca(u,x) ] ;

u连接到y的距离dfn[u] + dfn[y] - 2dfn[ lca(u,x) ] :

x连接到y的距离dfn[x] + dfn[y] - 2dfn[ lca(x,y) ] :

u连接到x-y这个链的距离 = (u到y+u到x-x到y)/2


当找不到这样的两个点时，说明操作点的DFS序为最大或者最小。故我们只需要取出集合中DFS序最大和最小的两个点，同上来求即可。


删除时同理。注意在集合操作时，若添加则在添加前查找，删除则在删除后查找。

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#include<set>
#include<time.h>
#include<string>
#define cl(a,b)	memset(a,b,sizeof(a))
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define REP(i,n) for(int i=0;i<n;++i)
#define REP1(i,a,b) for(int i=a;i<=b;++i)
#define REP2(i,a,b) for(int i=a;i>=b;--i)
#define MP make_pair
#define LL long long
#define ULL unsigned long long
#define X first
#define Y second
#define MAXN 100050
using namespace std;
vector<int> e[MAXN], c[MAXN];
set<int> st;
int fa[MAXN][20];
int p[MAXN];
int dfn[MAXN];
int dis[MAXN];
int cid;
int d[MAXN];
void dfs(int cur, int f) {
	dfn[++cid] = cur;
	p[cur] = cid;
	for (int i = 1; i < 20; ++i)
		fa[cur][i] = fa[fa[cur][i - 1]][i - 1];

	for (int i = 0; i < e[cur].size(); ++i) {
		int u = e[cur][i];
		if (u == f)
			continue;
		d[u] = d[cur] + 1;
		dis[u] = dis[cur] + c[cur][i];
		fa[u][0] = cur;
		dfs(u, cur);
	}
}

int lca(int u, int v) {
	if (d[u] < d[v])
		swap(u, v);
	for (int i = 19; i >= 0; --i) {
		if (d[fa[u][i]] >= d[v])
			u = fa[u][i];
		if (u == v)
			return u;
	}
	for (int i = 19; i >= 0; --i) {
		if (fa[u][i] != fa[v][i]) {
			u = fa[u][i];
			v = fa[v][i];
		}
	}
	return fa[u][0];
}
int add(int u) {
	if (st.empty())
		return 0;
	int x, y;
	set<int>::iterator it = st.lower_bound(p[u]), itx = it;
	itx--;
	if (it == st.end() || it == st.begin()) {
		it = st.begin();
		itx = st.end();
		itx--;
	}
	y = (*it);
	x = (*itx);
	y = dfn[y];
	x = dfn[x];
	return dis[u] - dis[lca(x, u)] - dis[lca(y, u)] + dis[lca(x, y)];
}
bool bo[MAXN];
int main() {
	//freopen("data.in", "r", stdin);
	//freopen("data.out", "w", stdout);
	int tt, ri = 0;
	scanf("%d", &tt);
	while (tt--) {
		int n, q;
		st.clear();
		cid=0;
		scanf("%d%d", &n, &q);
		for (int i = 0; i <= n; ++i)
		{
			bo[i] = false;
			e[i].clear();
			c[i].clear();
		}
		for (int i = 1; i < n; ++i) {
			int x, y, z;
			scanf("%d%d%d", &x, &y, &z);
			e[x].push_back(y);
			c[x].push_back(z);
			e[y].push_back(x);
			c[y].push_back(z);
		}
		for (int i = 0; i < 20; ++i)
			fa[1][0] = 1;
		d[1] = 1;
		dis[1] = 0;
		dfs(1, -1);
		int sum = 0;
		printf("Case #%d:\n", ++ri);
		for (int i = 1; i <= q; ++i) {
			int x, y;
			scanf("%d%d", &x, &y);
			int tmp;
			if (x == 1) {
				if (!bo[y]){
					bo[y]=true;
					if (st.size() == 0) {
						st.insert(p[y]);
					} else {
						tmp = add(y);
						st.insert(p[y]);
						sum += tmp;
					}
				}
			} else {
				if (bo[y]){
					bo[y] = false;
					st.erase(p[y]);
					if (!st.empty()) {
						sum -= add(y);

					}
				}
			}

			printf("%d\n", sum);
//		printf("%d %d %d %d\n",now,i,sum,add(i));
		}
	}
	return 0;
}
代码中LCA使用倍增算法。

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
using namespace std;
int n,q;
const int MAXN = 100005;
int head[MAXN],cnt;
int dir[MAXN],p[MAXN][20],dep[MAXN],tme[MAXN],t;
int dfn[MAXN];
struct edge{
    int u,v,w,next;
    edge(){}
    edge(int u,int v,int w):u(u),v(v),w(w){}
}e[MAXN<<1];
struct point{
    int id;
    point(){};
    point(int id):id(id){}
    bool operator < (const point & b) const{
        return dfn[id] < dfn[b.id];
    }
};
set<point> se;
void addedge(int u,int v,int w){
    e[cnt] = edge(u,v,w),e[cnt].next = head[u];
    head[u] = cnt++;
    e[cnt] = edge(v,u,w),e[cnt].next = head[v];
    head[v] = cnt++;
}
void dfs(int u){
    tme[t++] = u;
    for(int i = head[u];i!=-1;i = e[i].next){
        int v = e[i].v;
        if(!dep[v]){
            dir[v] = dir[u] + e[i].w;
            dep[v] = dep[u]+1;
            p[v][0] = u;
            dfs(v);
        }
    }
}
void makep(int st){
    dfs(st);
    for(int j=1;(1<<j)<=n;j++)
        for(int i=1;i<=n;i++)
            if(p[i][j-1]!=-1)
                p[i][j] = p[p[i][j-1]][j-1];
}
int LCA(int a,int b){
    if(dep[a] < dep[b])swap(a,b);
    int i;
    for(i = 0; (1<<i)<=dep[a];i++);
    i--;
    for(int j=i;j>=0;j--)
        if(dep[a]-(1<<j)>=dep[b])
            a = p[a][j];
    if(a == b)return a;
    for(int j = i;j >= 0;j--){
        if(p[a][j] != -1 && p[a][j] != p[b][j]){
            a = p[a][j];
            b = p[b][j];
        }
    }
    return p[a][0];
}
int main(){
    int T;
    cin>>T;
    for(int cas = 1;cas <= T;cas++){
        se.clear();
        printf("Case #%d:\n",cas);
        memset(head,-1,sizeof(head));
        memset(p,-1,sizeof(p));
        memset(dep,0,sizeof(dep));
        memset(dir,0,sizeof(dir));
        cnt = t = 0;
        scanf("%d%d",&n,&q);
        int u,v,w;
        dep[1] = 1;
        for(int i=1;i<n;i++){
            scanf("%d%d%d",&u,&v,&w);
            addedge(u, v, w);
        }
        makep(1);
        for(int i=0;i<t;i++)dfn[tme[i]] = i;
        //for(int i=0;i<t;i++)printf("%d ",tme[i]);
        int st = 0;
        while(q--){
            int op,num;
            scanf("%d%d",&op,&num);
            if(op == 1){
                if(se.empty()){
                    puts("0");
                    se.insert(point(num));
                    continue;
                }
                if(se.find(point(num))!=se.end()){
                    printf("%d\n",st);
                    continue;
                }
                set<point>::iterator it = se.lower_bound(point(num));
                if(it == se.begin() || it == se.end()){
                        int x = (se.begin())->id,y = (--se.end())->id;
                        st += (dir[num] - dir[LCA(x,num)]-dir[LCA(y,num)] + dir[LCA(x,y)]);
                }
                else{
                    int x = (it--)->id, y = (it)->id;
                    st += (dir[num] - dir[LCA(x,num)]-dir[LCA(y,num)] + dir[LCA(x,y)]);
                }
                se.insert(point(num);
                printf("%d\n",st);
            }else{
                if(se.find(point(num))==se.end()){
                    printf("%d\n",st);
                    continue;
                }
                se.erase(point(num));
                if(se.empty()){
                    puts("0");
                    se.insert(point(num));
                    continue;
                }
                set<point>::iterator it = se.lower_bound(point(num));
                if(it == se.begin() || it == se.end()){
                        int x = (se.begin())->id,y = (--se.end())->id;
                        st -= (dir[num] - dir[LCA(x,num)]-dir[LCA(y,num)] + dir[LCA(x,y)]);
                }
                else{
                    int x = (it--)->id, y = (it)->id;
                    st -= (dir[num] - dir[LCA(x,num)]-dir[LCA(y,num)] + dir[LCA(x,y)]);
                }
                printf("%d\n",st);
            }
        }
    }
    return 0;
}用树状数组维护
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <queue>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <set>
#include <vector>
using namespace std;
template <class T>
inline bool rd(T &ret) {
	char c; int sgn;
	if (c = getchar(), c == EOF) return 0;
	while (c != '-' && (c<'0' || c>'9')) c = getchar();
	sgn = (c == '-') ? -1 : 1;
	ret = (c == '-') ? 0 : (c - '0');
	while (c = getchar(), c >= '0'&&c <= '9') ret = ret * 10 + (c - '0');
	ret *= sgn;
	return 1;
}
template <class T>
inline void pt(T x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9) pt(x / 10);
	putchar(x % 10 + '0');
}
typedef long long ll;
typedef pair<int, int> pii;
const int N = 100000 + 100;
struct Edge {
	int from, to, dis, nex;
}edge[N << 1];
int head[N], edgenum;
void add(int u, int v, int d) {
	Edge E = { u,v,d, head[u] };
	edge[edgenum] = E;
	head[u] = edgenum++;
}
int dis[N], fa[N][20], dep[N];
void bfs(int root) {
	queue<int> q;
	fa[root][0] = root;dep[root] = 0;dis[root] = 0;
	q.push(root);
	while (!q.empty()) {
		int u = q.front();q.pop();
		for (int i = 1;i<20;i++)fa[u][i] = fa[fa[u][i - 1]][i - 1];
		for (int i = head[u]; ~i;i = edge[i].nex) {
			int v = edge[i].to;if (v == fa[u][0])continue;
			dep[v] = dep[u] + 1;dis[v] = dis[u] + edge[i].dis;fa[v][0] = u;
			q.push(v);
		}
	}
}
int Lca(int x, int y) {
	if (dep[x]<dep[y])swap(x, y);
	for (int i = 0;i<20;i++)if ((dep[x] - dep[y])&(1 << i))x = fa[x][i];
	if (x == y)return x;
	for (int i = 19;i >= 0;i--)if (fa[x][i] != fa[y][i])x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}

int n, q;
int c[N];
set<int>s;
inline int Lowbit(int x) { return x&(-x); }
void change(int i, int x)//i点增量为x
{
	while (i <= n)
	{
		c[i] += x;
		i += Lowbit(i);
	}
}
int sum(int x) {//区间求和 [1,x]
	int ans = 0;
	for (int i = x; i >= 1; i -= Lowbit(i))
		ans += c[i];
	return ans;
}
int p[N], fp[N], top;
void dfs(int u, int fa) {
	p[u] = ++top;
	fp[top] = u;
	for (int i(head[u]); ~i; i = edge[i].nex) {
		int v = edge[i].to; if (v == fa)continue;
		dfs(v, u);
	}
}
int Low(int l, int r) {
	int ans = -1;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (sum(mid) - sum(l-1))r = mid - 1, ans = mid;
		else l = mid + 1;
	}
	return ans;
}
int Up(int l, int r) {
	int ans = -1;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (sum(r) - sum(mid-1))l = mid + 1, ans = mid;
		else r = mid - 1;
	}
	return ans;
}
int main() {
	int T, Cas = 1; rd(T);
	while (T--) {
		memset(c, 0, sizeof c);
		memset(head, -1, sizeof head); edgenum = 0;
		rd(n); rd(q);
		for (int i = 1, u, v, w; i < n; i++) {
			rd(u); rd(v); rd(w);
			add(u, v, w); add(v, u, w);
		}
		bfs(1);
		top = 0;
		dfs(1, 1);
		printf("Case #%d:\n", Cas++);
		s.clear();
		int ans = 0;
		while (q--) {
			int op; int u; rd(op); rd(u);
			if (op == 1) {
				if (!s.count(u))
				{
					s.insert(u);
					if (s.size() > 1) 
					{
						int x = Up(1, p[u]), y = Low(p[u], n);
						if (x == -1 || y == -1)
						{
							x = Low(1, n); y = Up(1, n);
						}
						x = fp[x]; y = fp[y];
						ans += dis[u] - dis[Lca(x, u)] - dis[Lca(y, u)] + dis[Lca(x, y)];
					}
					change(p[u], 1);
				}
			}
			else {
				if (s.count(u)) 
				{
					s.erase(u);
					change(p[u], -1);
					if (s.size())
					{
						int x = Up(1, p[u]), y = Low(p[u], n);
						if (x == -1 || y == -1)
						{
							x = Low(1, n); y = Up(1, n);
						}
						x = fp[x]; y = fp[y];
						ans -= dis[u] - dis[Lca(x, u)] - dis[Lca(y, u)] + dis[Lca(x, y)];
					}
				}
			}
			pt(ans); puts("");
		}
	}
	return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

UVALIVE 3713 Astronauts（2-SAT）
﻿﻿
题意:有A,B,C三个任务要分给n个宇航员,年龄大于等于平均年龄的分A, 年龄小于平均年龄的分在B,C组没有界限,互为敌人的两个宇航员不可以在同一组.求出一个分配的方案。
思路：可以发现每个宇航员只有两种选择，选c或者不选c，用一个布尔变量xi代表第i个宇航员的选择，
对于相互为敌的两个年龄同时大于等于或同时小于平均年龄的宇航员，需要满足!(xi && xj)和!((!xi) && !(!xj))
对于年龄在平均年龄两侧的两个宇航员，只需要满足!(xi && xj)，得到这些条件就可以建图然后用2-SAT算法求得答案。
#include<cstdio>  
#include<cstring>  
#include<cmath>  
#include<cstdlib>  
#include<iostream>  
#include<algorithm>  
#include<vector>  
#include<map>  
#include<queue>  
#include<stack> 
#include<string>
#include<map> 
#include<set>
#define eps 1e-6 
#define LL long long  
using namespace std;  

const int maxn = 100000 + 1000;
//const int INF = 0x3f3f3f3f;

//2-sat
struct TwoSat {
	int n;
	vector<int> G[maxn*2];
	bool mark[maxn*2];
	int S[maxn*2], c;
	
	bool dfs(int x) {
		if(mark[x^1]) return false;
		if(mark[x]) return true;
		mark[x] = true;
		S[c++] = x;
		for(int i = 0; i < G[x].size(); i++) {
			if(!dfs(G[x][i])) return false;
		}
		return true;
	}
	
	void init(int n) {
		this->n = n;
		for(int i = 0; i < n*2; i++) G[i].clear();
		memset(mark, 0, sizeof(mark));
	}
	
	void add_clause(int x, int xval, int y, int yval) {
		x = x*2 + xval;
		y = y*2 + yval;
		G[x^1].push_back(y);
		G[y^1].push_back(x);
	}
	
	bool solve() {
		for(int i = 0; i < n*2; i += 2) {
			if(!mark[i]&&!mark[i+1]) {
				c = 0;
				if(!dfs(i)) {
					while(c > 0) mark[S[--c]] = false;
					if(!dfs(i+1)) return false;
				}
			}
		}
		return true;
	}
} solver;
int n, m, age[maxn];
int main() {
	//freopen("input.txt", "r", stdin);
	while(scanf("%d%d", &n, &m)==2 && n) {
		solver.init(n);
		int su = 0, ave;
		for(int i = 0; i < n; i++) scanf("%d", &age[i]), su += age[i];
		ave = su%n==0 ? su/n : su/n+1;
		for(int i = 0; i < m; i++) {
			int u, v; scanf("%d%d", &u, &v);
			u--; v--;
			if(age[u]<ave&&age[v]<ave || age[u]>=ave&&age[v]>=ave) {
				solver.add_clause(u, 0, v, 0);
				solver.add_clause(u, 1, v, 1);
			}
			else {
				solver.add_clause(u, 0, v, 0);
			}
		}
		if(!solver.solve()) puts("No solution.");
		else {
			for(int i = 0; i < n; i++) {
				if(solver.mark[2*i]) {
					if(age[i] >= ave) puts("A");
					else puts("B");
				} 
				else puts("C");
			}
		}
	} 
	return 0;
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 2264 Advanced Fruits--最长公共子序列
 
题目来源：POJ2264
Advanced Fruits
Description
Thecompany "21st Century Fruits" has specialized in creating new sortsof fruits by transferring genes from one fruit into the genome of another one.Most times this method doesn't work, but sometimes, in very rare
 cases, a newfruit emerges that tastes like a mixture between both of them. 

A big topic of discussion inside the company is "How should the newcreations be called?" A mixture between an apple and a pear could becalled an apple-pear, of course, but this doesn't sound very interesting. Theboss finally decides to use the shortest string
 that contains both names of theoriginal fruits as sub-strings as the new name. For instance, "applear"contains "apple" and "pear" (APPLEar and apPlEAR), andthere is no shorter string that has the same property. 
A combination of a cranberry and a boysenberry would therefore be called a"boysecranberry" or a "craboysenberry", for example. 

Your job is to write a program that computes such a shortest name for acombination of two given fruits. Your algorithm should be efficient, otherwiseit is unlikely that it will execute in the alloted time for long fruitnames. 
Input
Each lineof the input contains two strings that represent the names of the fruits thatshould be combined. All names have a maximum length of 100 and only consist ofalphabetic characters. 
Input is terminated by end of file.
Output
For eachtest case, output the shortest name of the resulting fruit on one line. If morethan one shortest name is possible, any one is acceptable.
SampleInput
apple peach
ananas banana
pear peach
SampleOutput
appleach
bananas
pearch
 
考察点：LCS最长公共子序列路径记录


题目大意：给定两个长度不超过100的字符串A,B。从中找出一个最短的字符串C， 使得A,B都是C的子序列(不一定是子串)。


题目解析：我们很容易看出这道题目需要求出A,B串的最长公共子序列，因为要求得到的新字符串包含A，B且最短。但同时题目要求A,B都是C的子序列，所以在输出的时候需要注意不能改变A,B串的原顺序。


#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char s1[105],s2[105];//要输入的字符串s1,s2 
int str1,str2;//s1,s2字符串的长度 
int dp[105][105],flag[105][105];//dp数组用于更新LCS，flag数组记录最长公共子序列 
int a[105],b[105];//记录最长公共子序列在s1,s2中的位置 
void init()//初始化 
{
	str1=strlen(s1+1);
	str2=strlen(s2+1);
	memset(dp,0,sizeof(dp));
}
void LCS()//求解LCS 
{
	for(int i=1;i<=str1;i++)
	{
		for(int j=1;j<=str2;j++)
		{
			if(s1[i]==s2[j])
			{
				dp[i][j]=dp[i-1][j-1]+1;
				flag[i][j]=1;//来自左上 
			} 	
			else
			{
				if(dp[i][j-1]>=dp[i-1][j])
				{
					dp[i][j]=dp[i][j-1];
					flag[i][j]=2;//来自左 
				}
				else
				{
					dp[i][j]=dp[i-1][j];
					flag[i][j]=3;//来自上 
				} 
			}
		}
	}
}
void LCS_print()//输出结果 
{
	int i=str1,j=str2,k=0,h1,h2;
	while(i>0&&j>0)//反向记录LCS在s1，s2中出现的位置 
	{
		if(flag[i][j]==1)
		{
			a[k]=i;
			b[k++]=j;
			i--,j--;
		}
		else if(flag[i][j]==2)
			j--;
		else
			i--;
	}
	j=0,h1=1,h2=1;
	//先后输出s1,s2在每个最长公共子序列字符之前的字符，随后输出最长公共子序列中的一个字符 
	for(i=k-1;i>=0;i--)
	{
		for(;h1<a[i];h1++)
			putchar(s1[h1]);
		for(;h2<b[i];h2++)
			putchar(s2[h2]);
		h1++,h2++;//跳过最长公共子序列字符 
		putchar(s1[a[i]]);//输出最长公共子序列中的一个字符
	}
	//输出最后一个最长公共子序列字符之后的字符 
	for(int i=h1;i<=str1;i++)
		putchar(s1[i]);
	for(int i=h2;i<=str2;i++)
		putchar(s2[i]);
	putchar('\n');
} 
int main()
{
	while(~scanf("%s %s",s1+1,s2+1))
	{
		init();
		LCS();
		LCS_print();
	}
	return 0;
} 




版权声明：本文为博主原创文章，未经博主允许不得转载。

java通过rJava调用R失败的问题总结


尝试使用Java通过rJava来调用R，但是一直出现如下错误

Cannot find JRI native library!
Please make sure that the JRI native library is in a directory listed in java.library.path.

网上找了许多解决方法，总结一下原因就是jri.dll有两个，一个是32的，一个是64位系统的，我的操作系统是64的，一直找不到准确的jri.dll所致。

网上的解决方案多为更改环境变量，这里我就不再重复了。

但是，我改完之后还是没能解决。

后来通过将jir文件夹下的jri.dll文件复制到jir文件外一层目录后就成功了。

这个jri.dll仅有126k

而x64中的这个文件

有149k

我们把x64中的jri.dll文件复制到它的上一级目录，覆盖掉原来的文件，

同时，在执行java程序时（rJava的rtest样例程序），需要在虚拟机参数中加

-Djava.library.path=D:\Program Files\R\R-3.2.1\library\rJava\jri

文件路径时我在安装rJava包时自动安装的路径，但是执行过程中又出现了另外一个问题。

错误: 找不到或无法加载主类 Files\R\R-3.2.1\library\rJava\jri

初步估计是我的R安装路径的问题：

D:\Program Files\R\R-3.2.1\library\rJava\jri

中Program Files中有空格，可能引用jar包中的处理是没有对这类字段进行处理判断，导致文件路径定位错误。

解决方法：

将library文件目录下的rJava整个文件夹拷贝到另外 一个文件路径下：

E:\home\ssf\R\lib

然后重新写虚拟机参数制定的路径

-Djava.library.path=E:\home\ssf\R\lib\rJava\jri

执行成功！！


版权声明：本文为博主原创文章，未经博主允许不得转载。

C++动态链接库的兼容性
一.动态链接库的ABI
    动态链接库的兼容性是由于库的ABI(Application binary interface)引起，ABI与API类似，但是主要包括一些诸如函数调用的堆栈结构、符号命名、参数规则、数据结构的内存分布等方面的规定。




二.引起动态链接库不兼容的行为


删除一个导出类；改变导出类的继承层次改变模板的模板参数删除一个导出函数改变函数的inline属性改变函数的签名在一个非虚基类或者没有含有虚函数的类中添加一个虚函数改变虚函数的声明次序......





三.一般不会引起动态链接库不兼容的行为


增加一个非虚函数删除没有被inline函数调用的非虚函数改变一个函数的默认参数增加新的static数据成员导出一个新的参数增加或者删除一个友元声明......





四.详细的内容(英文)
    详细的内容可以参考：https://techbase.kde.org/Policies/Binary_Compatibility_Issues_With_C++


Note about ABI

This text applies to most C++ ABIs used by compilers which KDE can be built with. It is mostly based on the Itanium
 C++ ABI Draft, which is used by the GCC C++ compiler since version 3.4 in all platforms it supports. Information about Microsoft Visual C++ mangling scheme mostly comes from this
 article on calling conventions (it's the most complete information found so far on MSVC ABI and name mangling).

Some of the constraints specified here may not apply to a given compiler. The goal here is to list the most restrictive set of conditions when writing cross-platform C++ code, meant to be compiled with several different compilers.

This page is updated when new binary incompatibility issues are found.

The Do's and Don'ts

You can...

add new non-virtual functions including signals and slots and constructors.add a new enum to a class.append new enumerators to an existing enum.

Exeption: if that leads to the compiler choosing a larger underlying type for the enum, that makes the change binary-incompatible. Unfortunately, compilers have some leeway to choose the underlying
 type, so from an API-design perspective it's recommended to add a Max.... enumerator with an explicit large value (=255, =1<<15, etc) to create an interval of numeric enumerator values that is guaranteed to
 fit into the chosen underlying type, whatever that may be.
reimplement virtual functions defined in the primary base class hierarchy (that is, virtuals defined in the first non-virtual base class, or in that class's first non-virtual base class, and so forth) if it
 is safe that programs linked with the prior version of the library call the implementation in the base class rather than the derived one. This is tricky and might be dangerous. Think twice before doing it. Alternatively see below for a workaround.

Exception: if the overriding function has a covariant return
 type, it's only a binary-compatible change if the more-derived type has always the same pointer address as the less-derived one. If in doubt, do not override with a covariant return type.
change an inline function or make an inline function non-inline if it is safe that programs linked with the prior version of the library call the old implementation. This is tricky
 and might be dangerous. Think twice before doing it.remove private non-virtual functions if they are not called by any inline functions (and have never been).remove private static members if they are not called by any inline functions (and have never been).add new static data members.change the default arguments of a method. It requires recompilation to use the actual new default argument values, though.add new classes.export a class that was not previously exported.add or remove friend declarations to classes.rename reserved member typesextend reserved bit fields, provided this doesn't cause the bit field to cross the boundary of its underlying type (8 bits for char & bool, 16 bits for short, 32 bits for int, etc.)add the Q_OBJECT macro to a class if the class already inherits from QObjectadd a Q_PROPERTY, Q_ENUMS or Q_FLAGS macro as that only modifies the meta-object generated by moc and not the class itself

You cannot...

For existing classes:

unexport
 or remove an exported class.change
 the class hierachy in any way (add, remove, or reorder base classes).
For template classes:

change
 the template arguments in any way (add, remove or reorder).
For existing functions of any type:

unexport it.remove it.

Remove the implementation of existing declared functions. The symbol comes from the implementation of the function, so this is effectively the function.
inline it
 (this includes moving a member function's body to the class definition, even without the inline keyword).add an overload (BC, but not SC: makes &func ambiguous), adding overloads to already overloaded functions is ok (any use of &func already
 needed a cast).change its signature. This includes:

changing any of the types of the arguments in the parameter
 list, including changing the const/volatile qualifiers of the existing parameters (instead, add a new method)changing the const/volatile qualifiers of the functionchanging the access
 rights to some functions or data members, for example from private to public. With some compilers, this information may
 be part of the signature. If you need to make a private function protected or even public, you have to add a new function that calls the private one.changing the CV-qualifiers
 of a member function: the const and/or volatile that apply to the function itself.extending a function with another parameter, even if this parameter has a default argument. See below for a suggestion on how to avoid this issuechanging the return
 type in any wayException: non-member functions declared with extern "C" can change parameter types (be very careful).

For virtual member functions:

add
 a virtual function to a class that doesn't have any virtual functions or virtual bases.add
 new virtual functions to non-leaf classes as this will break subclasses. Note that a class designed to be subclassed by applications is always a non-leaf class. See below for some workarounds or ask on mailing lists.add new virtual functions for any reason, even to leaf classes, if the class is intended to remain binary compatible on Windows. Doing so may reorder
 existing virtual functions and break binary compatibility.change
 the order of virtual functions in the class declaration.override
 an existing virtual function if that function is not in the primary base class (first non-virtual base class, or the primary base class's primary base class and upwards).override
 an existing virtual function if the overriding function has a covariant return type for which the more-derived
 type has a pointer address different from the less-derived one (usually happens when, between the less-derived and the more-derived ones, there's multiple inheritance or virtual inheritance).Remove a virtual function, even if it is a reimplementation of a virtual function from the base class
For static non-private members or for non-static non-member public data:

Remove or unexport itChange its typeChange its CV-qualifiers
For non-static members:

add new, data members to an existing class.change the order of non-static data members in a class.change the type of the member, except for signednessremove existing non-static data members from an existing class.


If you need to add extend/modify the parameter list of an existing function, you need to add a new function instead with the new parameters. In that case, you may want to add a short note that the two functions shall be merged with
 a default argument in later versions of the library:


void functionname( int a );void functionname( int a, int b ); //BCI: merge with int b = 0



You should...

In order to make a class to extend in the future you should follow these rules:

add d-pointer. See below.add non-inline virtual destructor even if the body is empty.reimplement event in QObject-derived classes, even if the body for the function is just calling the base class' implementation.make all constructors non-inline.write non-inline implementations of the copy constructor and assignment operator unless the class cannot be copied by value (e.g. classes inherited from QObject can't be)







版权所有，欢迎转载，转载请注明出处，谢谢



版权声明：本文为博主原创文章，未经博主允许不得转载。

itext生成PDF文件报错“Font 'STSong-Light' with 'UniGB-UCS2-H' is not recognized.”
最近需要写一个抽取表结构的工具，类似于powerdesigner中的表图，其中有一步用到了itext这个第三方jar包来生成pdf文件，碰到了一个问题，记录于此。 问题描述：工程使用maven构建，pom.xml中对于jar包的定义如下：<dependency>
   <groupId>com.lowagie</groupId>
   <artifactId>itext</artifactId>
   <version>2.1.7</version>
  </dependency>
  <dependency>
   <groupId>com.itextpdf</groupId>
   <artifactId>itext-asian</artifactId>
   <version>5.2.0</version>
  </dependency>
执行BaseFont bfChinesebfChinese = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H", BaseFont.NOT_EMBEDDED);时报错："Font 'STSong-Light' with 'UniGB-UCS2-H' is not recognized." 解决1. 首先尝试替换itext的包版本，他在maven中央库的位置是/maven2/com/lowagie/itext/，最高版本是4.2.2，但尝试后发现问题依旧。2. 注意到itext-asian的包路径是com.itextpdf，于是继续找，发现/maven2/com/itextpdf/itextpdf中有itextpdf的各个版本，从5.0.6到5.5.6。3. 搜索一些帖子，发现itext从5.x版本开始，改名为itextpdf，符合上面(1)和(2)对应的版本号。4. 问题可以确定了，就是上面itext-asian和itext的版本不对应，改为：<dependency>
    <groupId>com.itextpdf</groupId>
    <artifactId>itextpdf</artifactId>
    <version>5.4.3</version>
</dependency>再次运行，ok了。有些文章提到了itextasian包名未更新也会导致这个问题，但我用的5.2.0这个包，解压后看到包名是正确的，也许新版本已经改了，这点不深究了。摘要：找到CJKFont类, 从中看到 
   InputStream is = getResourceStream(RESOURCE_PATH + "cjkfonts.properties"); 
   cjkFonts.load(is); 
   is.close(); 
   is = getResourceStream(RESOURCE_PATH + "cjkencodings.properties"); 
   cjkEncodings.load(is); 
   is.close(); 他的font和encoding文件都是从String RESOURCE_PATH = "com/itextpdf/text/pdf/fonts/"; 这里加载的,而老itextasian.jar的包名是com.lowagie.text.pdf.fonts, 应该是包名重新命名了, 而没有及时更新itextasian.jar, 改了一下itextasian.jar包路径, 重新运行程序, OK,搞定. 

×××××××××××××××××××××××××××××××××××××××××××

更改iTextAsian.jar包名的方法如下
1)使用winrar解压缩程序将原来的iTextAsian.jar解压，目录结构如下
  iTextAsian
      --com
         --lowagie
           --text
             --pdf
               --fonts
                 --...(字体属性文件)
2)将加压后com目录下的包名lowagie更改为itextpdf
3)在命令行转至iTextAsian目录，重新打包为iTextAsian.jar文件
  命令如下：
  jar cvf iTextAsian.jar com/itextpdf/text/pdf/fonts/*
  执行后，将新的iTextAsian.jar加入到classpath路径 参考：http://endual.iteye.com/blog/1623327http://blog.csdn.net/wang12/article/details/5661106http://bbs.csdn.net/topics/390283201

版权声明：本文为博主原创文章，未经博主允许不得转载。

ZOJ 题目3587 Marlon's String（KMP）
Marlon's String

Time Limit: 2 Seconds      
Memory Limit: 65536 KB 

Long long ago, there was a coder named Marlon. One day he picked two string on the street.A problem suddenly crash his brain...
Let Si..j denote the i-th character to the 
j-th character of string S. 
Given two strings S and T. Return the amount of tetrad (a,b,c,d) which satisfy
Sa..b + Sc..d = T , a≤b and
c≤d.
The operator + means concate the two strings into one.
Input
The first line of the data is an integer Tc.Following Tc test cases, each contains two line. The first line is
S. The second line is T.The length of S and 
T are both in range [1,100000]. There are only letters in string S and T.
Output
For each test cases, output a line for the result.
Sample Input
1
aaabbb
ab

Sample Output
9
题目大意：Return the amount of tetrad (a,b,c,d) which satisfy
Sa..b + Sc..d = T , a≤b and
c≤d.

ac代码

#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
char a[200010],b[200010];
int c1[200010],c2[200010];
int next[200010];
void getnext(char *a)
{
	next[0]=next[1]=0;
	int i;
	int m=strlen(a);
	for(i=1;i<m;i++)
	{
		int j=next[i];
		while(j&&a[i]!=a[j])
			j=next[j];
		next[i+1]=(a[i]==a[j])?j+1:0;
	}
}
void kmp(char *a,char *b,int *c)
{
	getnext(b);
	int j=0,i;
	int n=strlen(a);
	int m=strlen(b);
	for(i=0;i<n;i++)
	{
		while(j&&a[i]!=b[j])
			j=next[j];
		if(a[i]==b[j])
		{
			j++;
			c[j]++;
		}
	}
	for(i=m;i>=0;i--)
		if(next[i])
			c[next[i]]+=c[i];
} 
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int i;
		memset(c1,0,sizeof(c1));
		memset(c2,0,sizeof(c2));
		scanf("%s%s",a,b);
		int len1=strlen(a);
		int len2=strlen(b);
		kmp(a,b,c1);
		reverse(a,a+len1);
		reverse(b,b+len2);
		kmp(a,b,c2);
		long long ans=0;
		for(i=0;i<len2;i++)
			ans+=(long long)c1[i]*c2[len2-i];
		printf("%lld\n",ans);
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU   4268  Alice and Bob（贪心）

Alice and Bob
Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 3700    Accepted Submission(s): 1174



Problem Description

Alice and Bob's game never ends. Today, they introduce a new game. In this game, both of them have N different rectangular cards respectively. Alice wants to use his cards to cover Bob's. The card A can cover the card B if the height of A is not smaller than
 B and the width of A is not smaller than B. As the best programmer, you are asked to compute the maximal number of Bob's cards that Alice can cover.
Please pay attention that each card can be used only once and the cards cannot be rotated.


 


Input

The first line of the input is a number T (T <= 40) which means the number of test cases. 
For each case, the first line is a number N which means the number of cards that Alice and Bob have respectively. Each of the following N (N <= 100,000) lines contains two integers h (h <= 1,000,000,000) and w (w <= 1,000,000,000) which means the height and
 width of Alice's card, then the following N lines means that of Bob's.


 


Output

For each test case, output an answer using one line which contains just one number.


 


Sample Input

2
2
1 2
3 4
2 3
4 5
3
2 3
5 7
6 8
4 1
2 5
3 4 


 


Sample Output

1
2


 


Source

2012 ACM/ICPC Asia Regional Changchun Online






   题意：两个人A,B分别有n个卡片，问A的卡片最多能覆盖住B的多少个卡片，其中A的一个卡片只能覆盖B的一个卡片，并且卡片不可以旋转。


点击打开链接





#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<set>
using namespace std;
struct node
{
    int a;
    int b;
};
node q[200110],q1[200110];
__int64 vis[200110];
multiset<int>s;
std::multiset<int>::iterator it;
bool cmp(node a,node b)
{
    if(a.b==b.b)
    {
        return a.a<b.a;
    }
    return a.b<b.b;
}
int main()
{
    int T,n;
    scanf("%d",&T);
    while(T--)
    {
        s.clear();
        scanf("%d",&n);
        for(int i=1; i<=n; i++)
        {
            scanf("%d%d",&q[i].a,&q[i].b);
        }
        for(int i=1; i<=n; i++)
        {
            scanf("%d%d",&q1[i].a,&q1[i].b);
        }
        sort(q+1,q+1+n,cmp);
        sort(q1+1,q1+1+n,cmp);
        int x=1;
        int ans=0;
        memset(vis,0,sizeof(vis));
        for(int i=1; i<=n; i++)
        {
            while(x<=n&&q1[x].b<=q[i].b)
            {
                s.insert(q1[x].a);
                x++;
            }
            if(s.size()==0)
            {
                continue;
            }
            it=s.lower_bound(q[i].a);
            if(*(it)==q[i].a)
            {
                    s.erase(it);
                    ans++;
            }
            else
            {
                if(it!=s.begin())
                {
                    --it;
                    s.erase(it);
                    ans++;

                }
            }

        }
        printf("%d\n",ans);
    }
    return 0;
}



 



版权声明：本文为博主原创文章，如有特殊需要请与博主联系  QQ ： 793977586。

poj 2251 BFS

Dungeon Master




Time Limit: 1000MS
 
Memory Limit: 65536K


Total Submissions: 21312
 
Accepted: 8283





Description
You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You
 cannot move diagonally and the maze is surrounded by solid rock on all sides. 

Is an escape possible? If yes, how long will it take? 

Input
The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).

L is the number of levels making up the dungeon. 
R and C are the number of rows and columns making up the plan of each level. 
Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a '#' and empty cells are represented by a '.'. Your starting position is indicated by 'S' and the
 exit by the letter 'E'. There's a single blank line after each level. Input is terminated by three zeroes for L, R and C.

Output
Each maze generates one line of output. If it is possible to reach the exit, print a line of the form

Escaped in x minute(s). 

where x is replaced by the shortest time it takes to escape. 
If it is not possible to escape, print the line 
Trapped! 

Sample Input
3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###

0 0 0

Sample Output
Escaped in 11 minute(s).
Trapped!

Source
Ulm Local 1997
给出一三维空间的地牢,要求求出由字符'S'到字符'E'的最短路径
移动方向可以是上，下，左，右，前，后，六个方向
每移动一次就耗费一分钟，要求输出最快的走出时间。
用BFS求最短路 比DFS好;

#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cmath>

using namespace std;

struct node
{
	int x,y,z;
}p,s,e,q;
queue<node>Q;
int n,m,h;
char a[100][100][100];  //三维
int vis[100][100][100];
int dx[]={1,-1,0,0,0,0};
int dy[]={0,0,1,-1,0,0};
int dz[]={0,0,0,0,-1,1};
int step[100][100][100];
int Judge(node q)
{
	if(q.x>=0&&q.y>=0&&q.z>=0&&q.x<n&&q.y<m&&q.z<h&&a[q.x][q.y][q.z]!='#') //存在E
		return 1;
	return 0;
}
int BFS()
{
	while(!Q.empty())   //  <span id="transmark"></span>队列必须清空
		Q.pop();
	
	Q.push(s);
	vis[s.x][s.y][s.z]=1;
	step[s.x][s.y][s.z]=0;
	while(!Q.empty())
	{
		p=Q.front();
		Q.pop();
		for(int i=0;i<6;i++)
		{
			q.x=dx[i]+p.x;
			q.y=dy[i]+p.y;
			q.z=dz[i]+p.z;
			if(!Judge(q))
				continue;
			if(vis[q.x][q.y][q.z]==0)
			{
				Q.push(q);
				step[q.x][q.y][q.z]=step[p.x][p.y][p.z]+1;
				vis[q.x][q.y][q.z]=1;
			}
			if(a[q.x][q.y][q.z]=='E')
				return step[q.x][q.y][q.z];
		}
	}
	return -1;
}
int main()
{
	while(~scanf("%d%d%d",&n,&m,&h))
	{
		int flag=1;
		if(!n&&!m&&!h)
		break;
		memset(vis,0,sizeof(vis));
		for(int i=0;i<n;i++)
		{
			for(int j=0;j<m;j++)
			{
				scanf("%s",a[i][j]);
				if(flag)
				for(int k=0;k<h;k++)
				{
					if(a[i][j][k]=='S')
					{
						s.x=i;s.y=j;s.z=k;
						flag=0;
						break;
					}
				}
			}
		}
		int x=BFS();
		if(x==-1)
		{
			printf("Trapped!\n");
	        continue;
		}
		printf("Escaped in %d minute(s).\n",x);
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

PAT的C++编译器
1.PAT的C++编译器是g++4.7.2 所以64位的整型得用long long定义，用%lld的占用符。
2.VC++6.0的编译器的64位整型得用__int64定义，用%I64d的占用符。

版权声明：本文为博主原创文章，未经博主允许不得转载。

OJ刷题---信用卡号校验（Luhn算法)
  题目要求：






输入代码：
#include<iostream>
#include<cstdio>
#include<stdlib.h>//导入C语言头文件，将要用到其中的函数 
using namespace std;
void getln(int a[])//输入数据的同时将数据反置并存放在数组a中
{
    char p=getchar();
    if(p!='\n')
        getln(a-1);//当不按下回车键时递归输入
    else return ;
    int x=strtol(&p,NULL,10); //用<stdlib.h>中到的strtol函数将输入的字符转换成十进制整数
    *(a)=x;
}
int main()
{
    int x=0;//最终求得的和
    int arr[15];//用于存储输入的数据
    getln(arr+14);//输入数据
    for(int i=0; i<15; i++)
    {
        if((i+1)%2==0)//该数为偶数位的情况
        {
            int y=arr[i]*2;
            if(y > 9)
            {
                y-=9;
            }
            x += y;
        }
        else
            x+=arr[i];//该数为奇数位的情况
    }

    if(x%10==0)//判断是否成功
    {
        cout<<"成功"<<endl;
    }
    else
    {
        cout<<"失败"<<endl;
    }
    return 0;
}

运行结果：







版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        图论之随机配流02——基于LOGIT的STOCH配流法-改进的dial算法

function dialsuanfaxishujuzhen(T)
%程序说明
clc
disp('======================================================================================');
disp('                   《基于LOGIT的STOCH配流法——改进的dial算法》');
disp('运行环境：MATLAB 8.3.0.532 ');
disp('制 作 人：兰州交通大学   刘志祥');
disp('Q      Q:531548824');
fprintf('说    明：本程序用于进行静态配流，在经典Dial算法的基础上进行修改，重新定义了有效路径，使得在用\n户的容忍绕路范围内比原来多走h倍路（一般情况下0<h<1,针对论断T(i,j))，即最多不超过2倍的路程，若\nh=0则等同经典算法.dial算法分四大步骤：一是求最短路，二是求边权似然数，三是求路权，四是配流\n');
disp('======================================================================================');
disp('按任意键继续...');
pause;

%数据获取，人机交互
disp('    ***请按照提示输入以下参数***');
Q=input('总 需 求 量:');
thita=input('参 数 thita:');
h=input('容忍绕路倍数:');
r=input('起       点:');
s=input('终       点:');
n=size(T,1);

%初始化
L=zeros(n,n);
W=zeros(n,n);
X=zeros(n,n);

%求最短距离矩阵及最短路径
disp('step1->：求最短距离,其中');
disp('---------------------------------------------------------------------------------------');
disp('   R—起点r到其他点的最短距离');
disp('   S—其他点到终点s的最短距离');
disp('按任意键继续...');
pause;
for i=1:n
    for j=1:n
        if T(i,j)==inf
            T(i,j)=0;
        end
    end
end
T=sparse(T);
Tmin=graphallshortestpaths(T);
[dist,path]=graphshortestpath(T,r,s);
disp('________________________________________________________________');
R=Tmin(r,:)
S=Tmin(:,s)'%注意因为方向性，这里作转置处理
disp('________________________________________________________________');


%画出初始图及最短路,边权为阻抗值t
disp('初始图及最短路径(红色）如图所示:');
chushitu=view(biograph(T,[],'showW','ON'));
set(chushitu.Nodes(path),'Color',[1 0 0]);
edges=getedgesbynodeid(chushitu,get(chushitu.Nodes(path),'ID'));
set(edges,'Linecolor',[1 0 0]);
disp('最短路径：');
path
disp('最短路距离：');
dist

%找上游节点和下游节点（显然up和down互为转置——对称，因为若j是i的下游节点，则i必是j的上游节点）
for i=1:n
    for j=1:n
        if T(i,j)>0
            down(i,j)=1;
            up(j,i)=1;
        else
            down(i,j)=0;
            up(j,i)=0;
        end
    end
end
down=sparse(down);
up=sparse(up);

%计算边权
disp('step2->：计算边权似然值(任意键继续）');
disp('---------------------------------------------------------------------------------------');
pause;
for i=1:n
    for j=1:n
        if down(i,j)
            if R(i)+T(i,j)-R(j)<(1+h)*T(i,j)&&S(j)+T(i,j)-S(i)<(1+h)*T(i,j)
                P=1;
            else
                P=0;
            end
            L(i,j)=P*exp(thita*(R(j)-R(i)-T(i,j)));
        end
    end
end
L=sparse(L)
disp('边权如图所示：');
bianquantu=view(biograph(L,[],'showW','ON'));

%计算路权
disp('step3->：计算路权(任意键继续）');
disp('---------------------------------------------------------------------------------------');
pause;
for i=1:n
    for j=1:n
        if down(i,j)~=0
            if R(i)+T(i,j)-R(j)<(1+h)*T(i,j)&&S(j)+T(i,j)-S(i)<(1+h)*T(i,j)
                if i==r
                    W(i,j)=L(i,j);
                else
                    W(i,j)=L(i,j)*(up(i,:)*W(:,i));
                    %这是核心句,先找到上游节点，再写出上游节点到i的W值（若还没有，则递归直到能够算出）,请仔细查阅路权的算法好好理解。
                end
            end
        end
    end
end
W=sparse(W)
disp('路权如图所示：');
luquantu=view(biograph(W,[],'showW','ON'));

%配流
disp('step4->：配流(任意键继续）');
disp('------------------------------------------------------------------------------------------');
pause;
for i=n:-1:1
    for j=n:-1:1
        if down(i,j)==1
            if R(i)+T(i,j)-R(j)<(1+h)*T(i,j)&&S(j)+T(i,j)-S(i)<(1+h)*T(i,j)
                if j==s
                    X(i,j)=Q*W(i,j)/((up(j,:)*W(:,j)));
                else
                    X(i,j)=X(j,:)*down(j,:)'*W(i,j)/(up(j,:)*W(:,j));
                    %注意X（j,:)是1*n行向量，down(j,:)是1*n行向量,因此要将down向量转置为1*n的列向量才能相乘。
                end
            end
        end
    end
end
X=sparse(X)
disp('配流结果如图所示：');
peiliutu=view(biograph(X,[],'showW','ON'));
disp('======================================================================================');
disp('<程序运行完毕>');


例：某路网如图所示，阻抗已标注于边上（这里阻抗用距离值表示），需求为1000，起点为v1，终点为v9，θ=1，用户可容忍的绕路倍数为0.5.请用改进的ial算法进行配流。


解：（1）写权值矩阵
quanzhijuzhen=[
     0     2   Inf     2   Inf   Inf   Inf   Inf   Inf
   Inf     0     2   Inf     2   Inf   Inf   Inf   Inf
   Inf   Inf     0   Inf   Inf     2   Inf   Inf   Inf
   Inf   Inf   Inf     0     1   Inf     2   Inf   Inf
   Inf   Inf   Inf   Inf     0     1   Inf     2   Inf
   Inf   Inf   Inf   Inf   Inf     0   Inf   Inf     2
   Inf   Inf   Inf   Inf   Inf   Inf     0     2   Inf
   Inf   Inf   Inf   Inf   Inf   Inf   Inf     0     2
   Inf   Inf   Inf   Inf   Inf   Inf   Inf   Inf     0];
(2)带入程序(格式整理后输出如下）
>> dialsuanfaxishujuzhen(quanzhijuzhen)

======================================================================================
                   《基于LOGIT的STOCH配流法——改进的dial算法》
运行环境：MATLAB 8.3.0.532 
制 作 人：兰州交通大学   刘志祥
Q      Q:531548824
说    明：本程序用于进行静态配流，在经典Dial算法的基础上进行修改，重新定义了有效路径，使得在用
户的容忍绕路范围内比原来多走h倍路（一般情况下0<h<1,针对论断T(i,j))，即最多不超过2倍的路程，若
h=0则等同经典算法.dial算法分四大步骤：一是求最短路，二是求边权似然数，三是求路权，四是配流
======================================================================================
按任意键继续...
    ***请按照提示输入以下参数***
总 需 求 量:1000
参 数 thita:1
容忍绕路倍数:0.5
起       点:1
终       点:9
step1->：求最短距离,其中
---------------------------------------------------------------------------------------
   R—起点r到其他点的最短距离
   S—其他点到终点s的最短距离
按任意键继续...
________________________________________________________________
R =
     0     2     4     2     3     4     4     5     6
S =
     6     5     4     4     3     2     4     2     0
________________________________________________________________
初始图及最短路径(红色）如图所示:



最短路径：
path =
     1     4     5     6     9
最短路距离：
dist =
     6
step2->：计算边权似然值(任意键继续）
---------------------------------------------------------------------------------------
L =
   (1,2)       1.0000
   (2,3)       1.0000
   (1,4)       1.0000
   (2,5)       0.3679
   (4,5)       1.0000
   (3,6)       0.1353
   (5,6)       1.0000
   (4,7)       1.0000
   (5,8)       1.0000
   (7,8)       0.3679
   (6,9)       1.0000
   (8,9)       0.3679
边权如图所示：




step3->：计算路权(任意键继续）
---------------------------------------------------------------------------------------
W =
   (1,2)       1.0000
   (2,3)       1.0000
   (1,4)       1.0000
   (2,5)       0.3679
   (4,5)       1.0000
   (3,6)       0.1353
   (5,6)       1.3679
   (4,7)       1.0000
   (5,8)       1.3679
   (7,8)       0.3679
   (6,9)       1.5032
   (8,9)       0.6386
路权如图所示：




step4->：配流(任意键继续）
------------------------------------------------------------------------------------------
X =
   (1,2)     298.1420
   (2,3)      63.1887
   (1,4)     701.8580
   (2,5)     234.9533
   (4,5)     638.6693
   (3,6)      63.1887
   (5,6)     638.6693
   (4,7)      63.1887
   (5,8)     234.9533
   (7,8)      63.1887
   (6,9)     701.8580
   (8,9)     298.1420
配流结果如图所示：




======================================================================================
<程序运行完毕>
说明：显然改进的算法更符合实际情况，因为人们通常不会因为需要绕一点点路而长时间等待。


版权声明：博主文章可以被非商用转载，但请务必注明出处，因水平有限，难免出错，在此免责。

HDU 1286：找新朋友【欧拉函数】
Euler函数
欧拉函数是求小于x并且和x互质的数的个数
通式：φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn)
其中p1, p2……pn为x的所有质因数，x是不为0的整数
φ(1)=1（唯一和1互质的数就是1本身）【注意：每种质因数只一个。比如12=2*2*3】 
 
定理：
           （1）若n是素数p的k次幂，φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)，因为除了p的倍数外，其他数都跟n互质 
           （2）欧拉函数是积性函数——若m,n互质，φ(mn)=φ(m)φ(n) 
 
特殊性质：
1）当n为奇数时，φ(2n)=φ(n)
2）p是素数，φ(p) = p - 1，φ(p)称为p的欧拉值
 
证明： 
若n= ∏ p^α 
则φ(n)=∏(p-1)p^(α-1)=n∏(1-1/p) 
∵欧拉函数是积性函数 
所以有：φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn) 
找新朋友
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 9346    Accepted Submission(s): 4943


Problem Description
新年快到了，“猪头帮协会”准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。
 

Input
第一行是测试数据的组数CN（Case number，1<CN<10000），接着有CN行正整数N（1<n<32768），表示会员人数。
 

Output
对于每一个N，输出一行新朋友的人数，这样共有CN行输出。

 

Sample Input

2
25608
24027

 

Sample Output

7680
16016

 

Author
SmallBeer(CML)
 

AC-code:
#include<cstdio>
int main()
{
	int n,i,w,m;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&m);
		w=m;
		for(i=2;i*i<=m;i++)
		{
			if(m%i==0)
			{
				m/=i;
				w=(w-w/i);
				while(m%i==0)
					m/=i;
			}
		}
		if(m>1)
			w=(w-w/m);
		printf("%d\n",w);
	}
	return 0;
} 

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ 2654 tree 二分答案+Kruskal
题目大意：给定一张带权无向图，每条边有一个颜色(黑色/白色)，求一棵生成树满足有needneed条白色边且权值和最小 
二分一个xx，然后将所有白边权值加上xx，跑两遍Kruskal，第一遍白边排在前面，第二遍黑边排在前面，这样可以求出当前白边数量的最大最小值 
如果needneed在最大最小值之间那么直接输出结果，否则如果小于最小值就增大xx，大于最大值就减小xx 
然而我并不会证明正确性。。。
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define M 100100
using namespace std;
struct edge{
    int x,y,z,col;
    friend istream& operator >> (istream &_,edge &e)
    {
        return scanf("%d%d%d%d",&e.x,&e.y,&e.z,&e.col),++e.x,++e.y,_;
    }
}edges[M];
bool Compare1 (const edge &e1,const edge &e2)//白边优先
{
    if( e1.z!=e2.z )
        return e1.z<e2.z;
    return e1.col<e2.col;
}
bool Compare2 (const edge &e1,const edge &e2)//黑边优先
{
    if( e1.z!=e2.z )
        return e1.z<e2.z;
    return e1.col>e2.col;
}
int n,m,need;
namespace Union_Find_Set{
    int fa[M],rank[M];
    void Initialize()
    {
        memset(fa,0,sizeof fa);
        memset(rank,0,sizeof rank);
    }
    int Find(int x)
    {
        if(!fa[x]||fa[x]==x)
            return fa[x]=x;
        return fa[x]=Find(fa[x]);
    }
    void Union(int x,int y)
    {
        x=Find(x);y=Find(y);
        if(x==y) return ;
        if(rank[x]>rank[y])
            swap(x,y);
        if(rank[x]==rank[y])
            ++rank[y];
        fa[x]=y;
    }
}
bool Check(int x)//need小于最少边数返回1 大于最大反回0
{
    using namespace Union_Find_Set;
    int i,min_cnt=0,max_cnt=0,re=0;
    for(i=1;i<=m;i++)
        if(edges[i].col==0)
            edges[i].z+=x;
    Initialize();
    sort(edges+1,edges+m+1,Compare1);
    for(i=1;i<=m;i++)
    {
        int x=Find(edges[i].x);
        int y=Find(edges[i].y);
        if(x==y) continue;
        Union(x,y);
        if(edges[i].col==0)
            ++max_cnt;
    }
    Initialize();
    sort(edges+1,edges+m+1,Compare2);
    for(i=1;i<=m;i++)
    {
        int x=Find(edges[i].x);
        int y=Find(edges[i].y);
        if(x==y) continue;
        Union(x,y);
        re+=edges[i].z;
        if(edges[i].col==0)
            ++min_cnt;
    }
    for(i=1;i<=m;i++)
        if(edges[i].col==0)
            edges[i].z-=x;
    if(need<min_cnt)
        return 1;
    if(need>max_cnt)
        return 0;
    throw re-need*x;
}
void Bisection()
{
    int l=-101,r=101;
    while(r-l>1)
    {
        int mid=l+r>>1;
        if( Check(mid) )
            l=mid;
        else
            r=mid;
    }
    Check(l);
    Check(r);
}
int main()
{
    int i;
    cin>>n>>m>>need;
    for(i=1;i<=m;i++)
        cin>>edges[i];
    try
    {
        Bisection();
    }
    catch(int ans)
    {
        cout<<ans<<endl;
        return 0;
    }
    printf("%d\n",1/0);
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

activemq 在tomcat上部署
1.下载activemq-all-5.9.jar 和activemq-web-console-5.9.0.war.地址：http://pan.baidu.com/s/1CxMUi。
2.将activemq-web-console-5.9.0.war放入tomcat 的webapps目录下面。activemq-all-5.9.jar 放入tomcat的lib下面。jstl.jar和standard.jar放入tomcat的lib下面。启动tomcat。
3.进入localhost:8080/activemq-web-console-5.9.0页面。

版权声明：本文为博主原创文章，未经博主允许不得转载。

阿里2016校招研发类笔试题php
一．  选择题 40分钟： 
1.某操作系统采用分页存储管理方式，下图给出了进程A和进程B的页表结构。如果物理页的大小为512字节，那么进程A与进程B的物理内存总共使用了__字节。 
进程A页表：                         进程B页表： 
逻辑页    物理页                     逻辑页    物理页 
0            9                       0            1 
1            2                       1            3 
2            4                       2            4 
3            6                       3            7 
4                                    4            2 
5                                    5
4608 
3584 
4096 
5120 
2560 
2048
2.以下函数中，和其他函数不属于一类的是__。 
fwrite 
putc 
pwrite 
putchar 
getline 
scanf
3.下面线程间的通讯机制中，关键路径上不会产生系统调用从而减少用户态到内核态的上下文切换的是__。 
pthread_spin_lock 
pthread_mutex 
信号量 
pthread_rwlock 
管道 
消息队列
4.使用KMP算法在文本串S中找模式串P是一种常见的方法。假设S=P={xyxyyxxyx}，亦即将S对自己进行匹配，匹配过程中正确的next数组是__。 
0,1,1,2,2,1,2,2,3 
0,1,2,2,3,1,2,2,3 
0,1,1,2,3,1,2,2,3 
0,1,1,2,3,1,1,2,3 
0,1,2,2,3,1,1,2,3 
0,1,2,2,2,1,1,2,3
5.两人在一个n个点的无向完全图上进行游戏，每次可以选择当前图中两个端点度数奇偶性相同的边删除，谁不能操作谁输，则在n=1,2,3,……,9,10中，有__个图先手有必胜策略。 
2 
3 
4 
5 
6 
7
6.下面数据结构能够支持随机的插入和删除操作、并具有较好的性能的是__。 
数组和链表 
链表和哈希表 
哈希表和队列 
队列和堆栈 
堆栈和双向队列 
双向队列和数组
7.袋子中分别一叠纸币，其中5元面值的纸币6张，10元面值的纸币5张，20元面值的纸币4张，从袋子中任意取4张纸币，则每种面值至少取到一张的概率为__。 
8/91 
25/91 
48/91 
53/91 
60/91 
63/91
8.一台机器对200个单词进行排序花了200秒（使用冒泡排序），那么花费800秒，大概可以对__单词进行排序。 
400 
500 
600 
700 
800 
900
9.一个英雄基础攻击力为100，携带了三件暴击武器，武器A有40%的概率打出2倍攻击，武器B有20%的概率打出4倍攻击，武器C有10%概率打出6倍攻击，各暴击效果触发是独立事件，但是多个暴击效果在一次攻击中同时触发时只有后面武器的暴击真正生效，例如一次攻击中武器A判定不暴击，武器B和武器C都判定触发暴击，那么这次攻击实际是600攻击力。那么这个英雄攻击力的数学期望是__。 
186.6 
200 
232.8 
256.8 
320 
332.6
10.有一个类B继承自类A，他们数据成员如下： 
class A { 
… 
private： 
     int a; 
}; 
class B  : public A { 
… 
private: 
     int a; 
public: 
     const int b; 
     A &c; 
     static const char* d; 
     B* e; 
} 
则构造函数中，成员变量一定要通过初始化列表来初始化的是__。 
a b c 
b c e 
b c d e 
c e 
b d 
b c
11.如果下列的公式成立：78+78=123。则采用的是__进制表示的。 
11 
12 
13 
14 
15 
以上都不对
12.函数f1的定义如下： 
void _cdec1 f1(const int& v1, cont int& v2) 
{ 
    std::cout << v1 << ‘ ’; 
    std::cout << v2 << ‘ ’; 
} 
则以下代码输出结果为__。 
int main (int argc, char* argv[]) 
{ 
    int i=0; 
    func (++i,i++); 
    return 0; 
} 
0 1 
1 2 
2 1 
2 0 
0 2 
1 0
13.设一颗二叉树中有3个叶子节点，有8个度为1的节点，则该二叉树中总的节点数为__。 
12 
13 
14 
15 
16 
17
14.在如下8*6的矩阵中，请计算从A移动到B一共有__种走法。要求每次只能向上或向右移动一格，并且不能经过P。
456 
492 
568 
626 
680 
702
15.有甲、乙、丙三位员工分别负责前端、后端、数据、算法、测试、运维。每人负责两项。已知： 
数据和前端住在一起 
甲是三人中最年轻的 
前端和丙有空一起下棋 
后端比算法年长，又比乙年轻 
三人中最年长的住得最远 
那么，三人分别负责__。 
甲-前端&测试；乙-算法&运维；丙-后端&数据 
甲-后端&算法；乙-前端&运维；丙-测试&数据 
甲-前端&运维；乙-测试&算法；丙-后端&数据 
甲-算法&数据；乙-测试&前端；丙-后端&运维 
甲-前端&算法；乙-后端&运维；丙-测试&数据 
甲-前端&算法；乙-测试&运维；丙-后端&数据
16.在1,2,3,…..1000中，有__个数各位乘积为0。 
100 
101 
172 
181 
190 
191
17.A为整数数组， N为A的数组长度，请问执行以下代码，最坏情况下的时间复杂度为__。 
void fun(int A[], int n) { 
    for (int i = n - 1; i >= 1; i–) { 
        for (int j = 0; j < i; j++) { 
            if (A[j] > A[j+1]) { 
                int tmp = A[j + 1]; 
                A[j + 1] = A[j]; 
                A[j] = tmp; 
         } 
      } 
   } 
} 
O(N) 
O(N^2) 
O(Nlog(N)) 
O(log(N)) 
O(N^3) 
无法确定
18.四维空间中有两个夹角60度的向量A和B，随机生成一个向量C分别与A和B计算内积，那么两个内积符号相同的概率为__。 
1/4 
1/3 
1/2 
2/3 
3/4 
以上都不对
19.一人以d元在XX买入n套《三体》，d为正整数，其中两套他以成本一半送给朋友，余下的每套高于原价8元卖出，加上送给朋友的两套，如果全部利润是72元，那么n最小可能是__。 
18 
17 
15 
13 
12 
10
20.假设基准值为数组首元素的快速排序，要使得数组满足非降序排列，下列数据分布导致快排算法效率最低的是__。 
2-6-3-7-5-1-4 
6-2-3-5-4-1-7 
7-5-3-2-4-1-6 
1-5-7-2-4-6-3 
1-2-3-4-5-6-7 
4-1-3-7-5-6-2
二．  附加大题：
1.在PHP开发过程中，不可避免要处理各种程序错误，你用过哪些PHP函数来跟error打交道呢，请举几个例子并说明其用法。
2.PHP有哪些常用的网络数据抓取方法？
3.mysql的存储引擎有哪些，有什么区别，适用场景？联合索引、前缀索引、覆盖索引的概念，及用sql语句体现三种索引的用法？
4.PHP实现四种基本排序算法(冒泡排序，插入排序，选择排序，快速排序) 
$array = array(1,43,54,62,21,66,32,78,36,76,39);
5.如何防止SQL注入？
6.请写出你所熟悉的设计模式，并且写出应用场景以及伪代码(至少3个以上)

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 1330  大一暑假ACM集训
Description

A rooted tree is a well-known data structure in computer science and engineering. An example is shown below: 

 
In the figure, each node is labeled with an integer from {1, 2,...,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor
 of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node
 x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common
 ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is. 

For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest
 common ancestor of y and z is y. 

Write a program that finds the nearest common ancestor of two distinct nodes in a tree. 


Input

The input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2<=N<=10,000. The nodes are labeled with integers 1, 2,...,
 N. Each of the next N -1 lines contains a pair of integers that represent an edge --the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers
 whose nearest common ancestor is to be computed.
Output

Print exactly one line for each test case. The line should contain the integer that is the nearest common ancestor.
Sample Input
2
16
1 14
8 5
10 16
5 9
4 6
8 4
4 10
1 13
6 15
10 11
6 7
10 2
16 3
8 1
16 12
16 7
5
2 3
3 4
3 1
1 5
3 5

Sample Output
4
3

代码
#include <iostream>
#include <vector>
using namespace std;
const int N =10000;
vector<int> a[N];
int f[N],r[N];
void DFS(int u,int dep)
{
    r[u]=dep;
    for (vector<int>::iterator it =a[u].begin(); it!=a[u].end(); ++it)
        DFS(*it,dep+1);
}
int main()
{
    int casenum,num,n,i,x,y;
    scanf("%d",&casenum);
    for (num=0; num<casenum; num++)
    {
        scanf("%d",&n);
        for (i=0; i<n; i++) a[i].clear();
        memset(f,255,sizeof(f));
        for(i=0; i<n-1; i++)
        {
            scanf ("%d %d",&x,&y);
            a[x-1].push_back(y-1);
            f[y-1]=x-1;
        }
        for (i=0; f[i]>=0; i++);
        DFS(i,0);
        scanf("%d %d",&x,&y);
        x--;
        y--;
        while (x!=y)
        {
            if (r[x]>r[y])x=f[x];
            else y=f[y];
        }
        printf("%d\n",x+1);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

辛星浅析yaf框架中的类的自动加载问题
       由于公司很多项目都是基于yaf的，而很多刚接触yaf的朋友问的第一个问题就是：yaf的自动加载是按照什么规则来的。鉴于此，于是我特别开了一篇博文来记录一下。
       首先在yaf中，models文件夹下的所有类名都需要以Model结尾，而且所有models和所有library下的类名都要根据所处等级加前缀，比如说我在Db目录下有个Mysql目录下有一个QueryGrammar.php文件，那么这个文件中的类名就应该是Db_Mysql_QueryGrammar，我们在实例化的时候直接使用这个名字，yaf就可以根据相应的规则来加载对应的文件啦。
       而且对于models和library下的所有文件名一般都是既无前缀业务后缀的，但是必须在相应层级的目录下面，也就是不允许库文件或者模型文件的二级目录。

版权声明：本文为博主原创文章，未经博主允许不得转载。

【bzoj1956】【Ahoi2005】【SHUFFLE 洗牌】【快速幂】
Description

为了表彰小联为Samuel星球的探险所做出的贡献，小联被邀请参加Samuel星球近距离载人探险活动。 由于Samuel星球相当遥远，科学家们要在飞船中度过相当长的一段时间，小联提议用扑克牌打发长途旅行中的无聊时间。玩了几局之后，大家觉得单纯玩扑克牌对于像他们这样的高智商人才来说太简单了。有人提出了扑克牌的一种新的玩法。 对于扑克牌的一次洗牌是这样定义的，将一叠N（N为偶数）张扑克牌平均分成上下两叠，取下面一叠的第一张作为新的一叠的第一张，然后取上面一叠的第一张作为新的一叠的第二张，再取下面一叠的第二张作为新的一叠的第三张……如此交替直到所有的牌取完。
 如果对一叠6张的扑克牌1 2 3 4 5 6，进行一次洗牌的过程如下图所示：  从图中可以看出经过一次洗牌，序列1 2 3 4 5 6变为4 1 5 2 6 3。当然，再对得到的序列进行一次洗牌，又会变为2 4 6 1 3 5。 游戏是这样的，如果给定长度为N的一叠扑克牌，并且牌面大小从1开始连续增加到N（不考虑花色），对这样的一叠扑克牌，进行M次洗牌。最先说出经过洗牌后的扑克牌序列中第L张扑克牌的牌面大小是多少的科学家得胜。小联想赢取游戏的胜利，你能帮助他吗？
Input

有三个用空格间隔的整数，分别表示N，M，L （其中0＜ N ≤ 10 ^ 10 ，0 ≤ M ≤ 10^ 10，且N为偶数）。
Output

单行输出指定的扑克牌的牌面大小。
Sample Input

6 2 3

Sample Output

6

HINT



Source


Day1
题解：设最后答案为x，显然x*(2^m)≡l(mod n+1)
 然后移项可得 x=(n/2+1)^m*l(mod n+1) 直接快速幂即可。
#include<iostream>
#include<cstdio>
using namespace std;
long long ans,n,m,p,l;
long long quick(long long a,long long b)
{
    long long ans(0);
    while (b>0)
    {
        if (b%2==1) ans=(ans+a)%p;
        b/=2;
        a=(a+a)%p; 
    }
  return ans;
}
long long power(long long a,long long b)
{
    long long ans(1);
    while (b>0)
    {
        if (b%2==1) ans=quick(ans,a);
        b/=2;
        a=quick(a,a);
    }
  return ans;
}
int main()
{
    scanf("%lld%lld%lld",&n,&m,&l);
    p=n+1;
    ans=power(n/2+1,m);
    ans=quick(ans,l);
    cout<<ans<<endl;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

gdb调试多线程


gdb使用
gdb与多线程



gdb使用
gdb是非常强大的调试工具，在文本模式下使用。使用方法可以参考陈皓的两篇文章 
用GDB调试程序（一） 
用GDB调试程序（二）
gdb常用命令在下表列出：



命令
描述



backtrace（或bt）
查看各级函数调用及参数


finish
连续运行到当前函数返回为止，然后停下来等待命令


frame（或f）
帧编号 选择栈帧


info（或i）
locals   查看当前栈帧局部变量的值


list（或l）
列出源代码，接着上次的位置往下列，每次列10行


list 行号
列出从第几行开始的源代码


list 函数名
列出某个函数的源代码


next（或n）
执行下一行语句


print（或p）
打印表达式的值，通过表达式可以修改变量的值或者调用函数


quit（或q）
退出gdb调试环境


set var
修改变量的值


start
开始执行程序，停在main函数第一行语句前面等待命令


step（或s）
执行下一行语句，如果有函数调用则进入到函数中


gdb与多线程
在多线程编程时，当我们需要调试时，有时需要控制某些线程停在断点，有些线程继续执行。有时需要控制线程的运行顺序。有时需要中断某个线程，切换到其他线程。这些都可以通过gdb实现。
先来看一下gdb调试多线程常用命令：

info threads：显示可以调试的所有线程。gdb会为每个线程分配一个ID（和tid不同），编号一般从1开始。后面的ID是指这个ID。
thread ID:切换当前调试的线程为指定ID的线程。
break FileName.cpp:LinuNum thread all:所有线程都在文件FileName.cpp的第LineNum行有断点。
thread apply ID1 ID2 IDN command:多个线程执行gdb命令command。 
thread apply all command：所有线程都执行command命令。
set scheduler-locking off|on|step：在调式某一个线程时，其他线程是否执行。off，不锁定任何线程，默认值。on，锁定其他线程，只有当前线程执行。step，在step（单步）时，只有被调试线程运行。
set non-stop on/off:当调式一个线程时，其他线程是否运行。
set pagination on/off:在使用backtrace时，在分页时是否停止。
set target-async on/ff:同步和异步。同步，gdb在输出提示符之前等待程序报告一些线程已经终止的信息。而异步的则是直接返回。 

来看一个例子： 
gdbTest.cpp。程序很简单，只是让两个线程执行函数ThreadFun，在函数中打印传入的参数。
#include <iostream>
#include <pthread.h>

void* ThreadFun(void* arg)
{
    int *value=static_cast<int*> (arg);
    std::cout<<"This is thread"<<*value<<std::endl;
    pthread_exit(0);
}

int main()
{
    int  ret=0;
    pthread_t thread_id1,thread_id2;

    int* v1=new int(1);
    int* v2=new int(2);
    ret = pthread_create(&thread_id1, NULL, ThreadFun, static_cast<void*>(v1)); //这里笔误,应为thread_id1 就是调试这里的错误
    if (ret)
    {
        std::cout<<"Create pthread error!"<<std::endl;
        return 1;
    }

    ret = pthread_create(&thread_id2, NULL, ThreadFun, static_cast<void*>(v2));
    if (ret)
    {
        std::cout<<"Create pthread error!"<<std::endl;
        return 1;
    }

    pthread_join(thread_id1, NULL);
    pthread_join(thread_id2, NULL);

    return 0;
}
$ gdb gdbThreadTest//调试gdbThreadTest
加断点
(gdb) break 7
Breakpoint 1 at 0x400a19: file kangThread.cpp, line 7.
(gdb) break 35
Breakpoint 2 at 0x400b35: file kangThread.cpp, line 35.
(gdb) info break
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400a19 in ThreadFun(void*) at kangThread.cpp:7
2       breakpoint     keep y   0x0000000000400b35 in main() at kangThread.cpp:35
开始运行
(gdb) r
Starting program: /home/kang/src/mulThread/kangThread 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Traceback (most recent call last):
  File "/usr/share/gdb/auto-load/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.19-gdb.py", line 63, in <module>
    from libstdcxx.v6.printers import register_libstdcxx_printers
ImportError: No module named 'libstdcxx'
[New Thread 0x7ffff6fd5700 (LWP 2773)]
[Switching to Thread 0x7ffff6fd5700 (LWP 2773)]

Breakpoint 1, ThreadFun (arg=0x602010) at kangThread.cpp:7
warning: Source file is more recent than executable.
7       int *value=static_cast<int*> (arg);
查看线程信息
(gdb) info thread
[New Thread 0x7ffff67d4700 (LWP 2774)]
  Id   Target Id         Frame 
  3    Thread 0x7ffff67d4700 (LWP 2774) "kangThread" clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:81
* 2    Thread 0x7ffff6fd5700 (LWP 2773) "kangThread" ThreadFun (arg=0x602010) at kangThread.cpp:7
  1    Thread 0x7ffff7fda780 (LWP 2769) "kangThread" clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:81
可以看到ID为2的线程执行到了断点Breakpoint 1。可以看一下value的值
(gdb) n
8       std::cout<<"This is thread"<<*value<<std::endl;
(gdb) p *value
$2 = 1
切换到线程3,看一下线程3执行到了哪里
(gdb) c
Continuing.
1
[Switching to Thread 0x7ffff67d4700 (LWP 2774)]

Breakpoint 1, ThreadFun (arg=0x602030) at kangThread.cpp:7
7       int *value=static_cast<int*> (arg);
(gdb) info thread
  Id   Target Id         Frame 
* 3    Thread 0x7ffff67d4700 (LWP 2774) "kangThread" ThreadFun (arg=0x602030) at kangThread.cpp:7
  2    Thread 0x7ffff6fd5700 (LWP 2773) "kangThread" __GI__dl_debug_state () at dl-debug.c:74
  1    Thread 0x7ffff7fda780 (LWP 2769) "kangThread" 0x00007ffff7bc566b in pthread_join (threadid=140737337186048, 
    thread_return=0x0) at pthread_join.c:92
(gdb) thread 3
[Switching to thread 3 (Thread 0x7ffff67d4700 (LWP 2774))]
#0  ThreadFun (arg=0x602030) at kangThread.cpp:7
7       int *value=static_cast<int*> (arg);
(gdb) n
8       std::cout<<"This is thread"<<*value<<std::endl;
(gdb) p *value
$3 = 2
可以看出线程3的value为2。
还有其他许多命令和方法，要在实践中慢慢熟悉。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[笔记][Java7并发编程实战手册]系列第四章 4.1 简介
[笔记][Java7并发编程实战手册]系列目录

好把。这一章的任务感觉好难，自己也没有了解过，只能跟着书上的多测试了。

第四章
在本章中，我们将学习： 
1. 创建线程执行器 
2. 创建固定大小的线程执行器 
3. 在执行器中执行任务并返回结果 
4. 运行多个任务并处理第一个结果 
5. 运行多个任务并处理所有结果 
6. 在执行器中延时执行任务 
7. 在执行器中周期性执行任务 
8. 在执行器中取消任务 
9. 在执行器中控制任务的完成 
10. 在执行器中分离任务的启动与结果的处理 
11. 处理在执行器中被拒绝的任务

简介
　　通常用java来开发一些简单的并发应用，会创建一些runnable对象，然后创建对应的Thread对象来执行他们，但是如果需要开发一个程序来运行大量的并发任务，再使用以前的方法，将会带来以下几点劣势： 
1. 必须实现所有与thread对象管理相关的代码，比如线程的创建、执行、结束、以及结果。 
2. 需要为每一个任务创建一个Thread对象，如果需要执行大量的任务，这将大大的影响应用程序的处理能力。 
3. 计算机的资源需要高效的进行控制和管理，如果创建过多的线程，将会导致系统负荷过重。
　　从JDK1.5开始，执行器框架（Executor Framework）围绕着Executor接口和它的子接口ExecutorService，以及实现这两个接口的ThreadPoolExecutor类，来解决以上的问题。 
　　这套机制分离了任务的创建和执行。 通过使用执行器，仅需要实现Runnable接口的对象，然后将这些对象发送给执行器即可。执行器通过创建锁需要的线程，来复杂这些Runnable对象的创建、实例化以及运行。执行器还使用了线程池来提高性能，当发送一个任务给执行器时，执行器会尝试使用线程池中的线程来执行这个任务，避免了不断地创建和销毁线程而导致系统性能下降。 
　　 
　　执行器框架到另一个重要的优势是Callable接口，它类似于Runnable接口，但是却提供了两方面的增强： 
1. 这个接口的主要方法名称为call()，可以返回结果。 
2. 当发送一个Callable对象给执行器事，将获得一个实现了Future接口的对象。可以使用这个对象来控制Callable对象的状态和结果。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

封装类之FileVersion（获取文件属性）
应用此类可以获取应用程序的程序名，产品名称，公司名称，版本号，版权等信息 
1XX.h文件
class CFileVersion  
{   
// Construction  
public:   
    CFileVersion();  
// Operations     
public:   
    BOOL    Open(LPCTSTR lpszModuleName);  
    void    Close();  
    CString QueryValue(LPCTSTR lpszValueName, DWORD dwLangCharset = 0);  
    CString GetFileDescription()  {return QueryValue(_T("FileDescription")); };  
    CString GetFileVersion()      {return QueryValue(_T("FileVersion"));     };  
    CString GetInternalName()     {return QueryValue(_T("InternalName"));    };  
    CString GetCompanyName()      {return QueryValue(_T("CompanyName"));     };   
    CString GetLegalCopyright()   {return QueryValue(_T("LegalCopyright"));  };  
    CString GetOriginalFilename() {return QueryValue(_T("OriginalFilename"));};  
    CString GetProductName()      {return QueryValue(_T("ProductName"));     };  
    CString GetProductVersion()   {return QueryValue(_T("ProductVersion"));  };  
    BOOL    GetFixedInfo(VS_FIXEDFILEINFO& vsffi);  
    CString GetFixedFileVersion();  
    CString GetFixedProductVersion();  
    // Attributes  
protected:  
    LPBYTE  m_lpVersionData;   
    DWORD   m_dwLangCharset;   
    // Implementation  
public:  
    ~CFileVersion();   
};   
2XX.cpp文件
//构造函数初始化
CFileVersion::CFileVersion()   
{   
    m_lpVersionData = NULL;  
    m_dwLangCharset = 0;  
}  
//析构函数 退出释放资源
CFileVersion::~CFileVersion()   
{   
    Close();  
}   
void CFileVersion::Close()  
{  
    delete[] m_lpVersionData;   
    m_lpVersionData = NULL;  
    m_dwLangCharset = 0;  
}  

//打开版本信息文件，获取文件属性的翻译表获取语言编码
BOOL CFileVersion::Open(LPCTSTR lpszModuleName)  
{  
ASSERT(_tcslen(lpszModuleName) > 0);  
ASSERT(m_lpVersionData == NULL);  
// Get the version information size for allocate the buffer  
DWORD dwHandle;       
DWORD dwDataSize = GetFileVersionInfoSize((LPTSTR)lpszModuleName, &dwHandle);   
if ( dwDataSize == 0 )   
return FALSE;  
// Allocate buffer and retrieve version information  
m_lpVersionData = new BYTE[dwDataSize];   
if (!GetFileVersionInfo((LPTSTR)lpszModuleName, dwHandle, dwDataSize,   
    (void**)m_lpVersionData) )  
{  
    Close();  
    return FALSE;  
}  
// Retrieve the first language and character-set identifier  
UINT nQuerySize;  
DWORD* pTransTable;  
if (!VerQueryValue(m_lpVersionData, _T("\\VarFileInfo\\Translation"),  
    (void **)&pTransTable, &nQuerySize) )  
{  
    Close();  
    return FALSE;  
}  
// Swap the words to have lang-charset in the correct format  
    m_dwLangCharset = MAKELONG(HIWORD(pTransTable[0]), LOWORD(pTransTable[0]));  

    return TRUE;    
}  
//获指定文件属性信息   "\StringFileInfo\languagecodepage\stringname"
CString CFileVersion::QueryValue(LPCTSTR lpszValueName,   
                                 DWORD dwLangCharset /* = 0*/)  
{  
    // Must call Open() first  
    ASSERT(m_lpVersionData != NULL);  
    if ( m_lpVersionData == NULL )  
        return (CString)_T("");  
    // If no lang-charset specified use default  
    if ( dwLangCharset == 0 )  
        dwLangCharset = m_dwLangCharset;  
    // Query version information value  
    UINT nQuerySize;  
    LPVOID lpData;  
    CString strValue, strBlockName;  
    strBlockName.Format(_T("\\StringFileInfo\\%08lx\\%s"),   
        dwLangCharset, lpszValueName);  
    if ( VerQueryValue((void **)m_lpVersionData, strBlockName.GetBuffer(0),   
        &lpData, &nQuerySize) )  
        strValue = (LPCTSTR)lpData;  
    strBlockName.ReleaseBuffer();  
    return strValue;  
}  
//获取文件的版本信息   VS_FIXEDFILEINFO包含文件的版本信息
BOOL CFileVersion::GetFixedInfo(VS_FIXEDFILEINFO& vsffi)  
{  
    // Must call Open() first  
    ASSERT(m_lpVersionData != NULL);  
    if ( m_lpVersionData == NULL )  
        return FALSE;  
    UINT nQuerySize;  
    VS_FIXEDFILEINFO* pVsffi;  
    if ( VerQueryValue((void **)m_lpVersionData, _T("\\"),  
        (void**)&pVsffi, &nQuerySize) )  
    {  
        vsffi = *pVsffi;  
        return TRUE;  
    }  
    return FALSE;  
}  
//获取文件的版本信息
CString CFileVersion::GetFixedFileVersion()  
{  
    CString strVersion;  
    VS_FIXEDFILEINFO vsffi;  
    if ( GetFixedInfo(vsffi) )  
    {  
        strVersion.Format (_T("%u,%u,%u,%u"),HIWORD(vsffi.dwFileVersionMS),  
            LOWORD(vsffi.dwFileVersionMS),  
            HIWORD(vsffi.dwFileVersionLS),  
            LOWORD(vsffi.dwFileVersionLS));  
    }  
    return strVersion;  
}  
//获取产品的版本信息
CString CFileVersion::GetFixedProductVersion()  
{  
    CString strVersion;  
    VS_FIXEDFILEINFO vsffi;  
    if ( GetFixedInfo(vsffi) )  
    {  
        strVersion.Format (_T("%u,%u,%u,%u"), HIWORD(vsffi.dwProductVersionMS),  
            LOWORD(vsffi.dwProductVersionMS),  
            HIWORD(vsffi.dwProductVersionLS),  
            LOWORD(vsffi.dwProductVersionLS));  
    }  
    return strVersion;  
}  
3在使用的过程中实例化一个对象，调用相关的函数即可
 
在这里可以查到相关的文件属性信息，也可以在里面修改文件信息

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

qwt插件安装教程（VS2013 64bit，QT5.5.0）

环境介绍
QWT，全称是Qt Widgets for Technical Applications，是一个基于LGPL版权协议的开源项目，可生成各种统计图。它为具有技术专业背景的程序提供GUI组件和一组实用类，其目标是以基于2D方式的窗体部件来显示数据， 数据源以数值，数组或一组浮点数等方式提供， 输出方式可以是Curves（曲线），Slider（滚动条），Dials（圆盘），Compasses（仪表盘）等等。该工具库基于Qt开发，所以也继承了Qt的跨平台特性。 
 操作系统：win8.1 64bit 
 qt版本：5.5.0 
 VS版本：2013 64bit 
 已经安装好vs、qt，测试没问题。
下载源码
下载qwt的源代码：http://sourceforge.net/projects/qwt/
打开项目
解压，进入目录，双击打开：qwt.pro（默认使用qt creator）
编译
直接点击运行按钮，qt creator会自动进行编译工作（最后或提示找不到执行文件，不用管就行，只需要编译后的文件） 
编译完会生成文件夹：build-qwt-Desktop_Qt_5_5_0_MSVC2013_64bit-Debug 
需要用的即该文件夹下以及源代码中的文件。
配置 
（1）将build-qwt-Desktop_Qt_5_5_0_MSVC2013_64bit-Debug\lib下的qwtd.dll、qwt.dll拷贝到…\Qt\Qt5.5.0\5.5\msvc2013_64\bin下 
（2）将build-qwt-Desktop_Qt_5_5_0_MSVC2013_64bit-Debug\lib下的qwtd.lib、qwt.lib拷贝…\Qt\Qt5.5.0\5.5\msvc2013_64\lib下。 
（3）将build-qwt-Desktop_Qt_5_5_0_MSVC2013_64bit-Debug\designer\plugins\designer目录下的qwt_designer_plugin.dll和qwt_designer_plugin.lib拷贝到 
…\Qt\Qt5.5.0\5.5\msvc2013_64\plugins\designer目录下（注意：一种说法是拷贝到…\Qt\Qt5.5.0\5.5.0\Tools\QtCreator\bin\plugins\designer目录下，但是测试表明这样会导致qt designer上不出现插件） 
（4）将qwt源代码src目录下的所有.h和.cpp放入一个空文件夹QWT中，再将该文件夹拷贝到…\Qt\Qt5.5.0\5.5\msvc2013_64\include目录下。
配置 VS2013

新建项目，然后进行配置： 
（1）右键项目名->属性->配置属性->C/C++->常规，附加包含目录：$(QTDIR)\include\QWT 
（2）右键项目名->属性->配置属性->链接器->输入，附加依赖项：qwtd.lib 
（3）右键项目名->属性->配置属性->C/C++->预处理器，预处理器定义：QWT_DLL

测试 

编写demo测试即可，此时的qt designer上应该也会出现qwt的插件 

参考文献： 
QWT编译、配置、使用（VS2010 + Qt5.1.0）：http://blog.sina.com.cn/s/blog_a6fb6cc90101gks5.html 
QWT编译、配置、使用（Qt Creator） ：http://blog.sina.com.cn/s/blog_a6fb6cc90102v25w.html

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

JAVA问题总结之6--强制转换损失精度分析
问题6：JAVA强制转换损失精度分析：强制转换时是去掉高位保存低位

<pre name="code" class="java">package p1;

public class test4 {
	public static void main(String[] args) {
        long l1=12345l;
        byte b1=(byte)l1;
        System.out.println("long is "+l1);
        System.out.println("byte is "+b1);
	}
}




输出结果：

long is 12345
byte is 57

可以看的出来long型为12345，但是byte就变成了57.明显数据不对。

分析：
long为四个字节，12345存储格式为：


byte为一个字节，即8位，强制转换时是去掉高位保存低位，所以保存的是00111001，所以输出的byte型数据是57.
其他依次类推

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1203
I NEED A OFFER!
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 20474 Accepted Submission(s): 8172


Problem Description
Speakless很早就想出国，现在他已经考完了所有需要的考试，准备了所有要准备的材料，于是，便需要去申请学校了。要申请国外的任何大学，你都要交纳一定的申请费用，这可是很惊人的。Speakless没有多少钱，总共只攒了n万美元。他将在m个学校中选择若干的（当然要在他的经济承受范围内）。每个学校都有不同的申请费用a（万美元），并且Speakless估计了他得到这个学校offer的可能性b。不同学校之间是否得到offer不会互相影响。“I NEED A OFFER”，他大叫一声。帮帮这个可怜的人吧，帮助他计算一下，他可以收到至少一份offer的最大概率。（如果Speakless选择了多个学校，得到任意一个学校的offer都可以）。



Input
输入有若干组数据，每组数据的第一行有两个正整数n,m(0<=n<=10000,0<=m<=10000) 
后面的m行，每行都有两个数据ai(整型),bi(实型)分别表示第i个学校的申请费用和可能拿到offer的概率。 
输入的最后有两个0。



Output
每组数据都对应一个输出，表示Speakless可能得到至少一份offer的最大概率。用百分数表示，精确到小数点后一位。



Sample Input

10 3
4 0.1
4 0.2
5 0.3
0 0



Sample Output

44.0%

Hint
You should use printf("%%") to print a '%'.
 



Author
Speakless


#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;

double dp[10005],p[10005];
int a[10005];
int main()
{
    int n,i,j,m;
    while(scanf("%d%d",&n,&m),(n||m))
    {
        for(i=0; i<m; i++)
        {
            scanf("%d%lf",&a[i],&p[i]);
            p[i] = 1 - p[i];
        }
        for(i=0; i<=n; i++)
            dp[i] = 1.0;
        for(i=0; i<m; i++)
        {
            for(j=n; j>=a[i]; j--)
            {
                dp[j] = min(dp[j], dp[j-a[i]]*p[i]);
                //if(dp[j]>dp[j-a[i]]*p[i])
                 //   dp[j]=dp[j-a[i]]*p[i];
            }
        }
        printf("%.1lf%%\n",(1-dp[n])*100);
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题21-包含min函数的栈
题目：
定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。
在该栈中，调用min,push,pop的时间复杂度都是O(1)


public class StackWithMin {

	private Stack<Integer> stack = null;
	private Stack<Integer> minStack = null;

	public StackWithMin() {
		stack = new Stack<Integer>();
		minStack = new Stack<Integer>();
	}

	public Integer pop() {
		minStack.pop();
		return stack.pop();
	}

	public Integer push(Integer item) {
		minStack.push(item < stack.peek() ? item : stack.peek());
		return stack.push(item);
	}

	public Integer min() {
		return minStack.peek();
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

R语言-差分要注意的问题
R语言中，对时间序列数据进行分析处理时，使用差分函数要注意：
差分函数diff()不带参数名的参数指滞后阶数，也就是与滞后第几阶的数据进行差分。如果要指定差分的阶数，则一定要使用带名称的参数:diff=2。
例如：
sample表示样本数据。

1、diff(sample,2)表示是对滞后2阶的数据进行差分，一阶差分，等同于：
diff(sample,lag=2)
2、diff(sample,diff=2)才是表示二阶差分
注意：在函数中尽量避免使用没有命名的参数。

在《时间序列分析及应用-R语言（第2版）》中，P315，描述到：
我们得到的教训就是，除非完全了解相关参数的位置，否则使用未命名参数是非常危险的。


版权声明：本文为博主原创文章，未经博主允许不得转载。

编程之路


Programming Language
 


CoderEssential程序猿必备
Reference参考
DOC文档
Forum论坛社区
New资讯
Magazine杂志期刊
Tutorial教程


Coding
MarkDown
Builder
IDE
Version Control


Open Source
Github




Notes Catalogue
编程语言目录规范Directory For Programming Language
编程语言笔记目录规范Catalogue For Programming Language
客户端学习笔记目录规范WebiOSAndroidWP





Programming Language
 
dynamically typed languages
statically typed languages
type-inferring languages
CoderEssential:程序猿必备
Reference：参考
DOC：文档
查阅各种API文档是程序猿的必备技能，这里列举出部分整合类型的文档查阅网站，方便特别是被墙的情况下查阅文档。


devdocs
这里集合了大量的在线的文档，同时DevDocs还支持离线浏览，主要是依靠IndexDB将数据存放在浏览器的本地缓存中。

Forum：论坛社区
New：资讯

InfoQ
个人感觉InfoQ是国内顶尖的IT资讯聚集地之一，他包含了很多对于前沿技术

Magazine：杂志期刊
Tutorial：教程
Coding
MarkDown
笔者最早记录所有的学习笔记，全是依靠于类似于Word的方式，但是非常不方便，特别是在共享或者随时查阅时。MarkDown应该是程序猿必备的技能之一。

Typora

Typora是一个免费的MAC系统下的MarkDown编辑器，它融合了编辑与及时展现于一体。Typora唯一的缺点在于其不支持流程图，不过真正用MarkDown编辑的人也不是很需要这个功能吧。

小书匠

小书匠是一个开源的MarkDown编辑器，不过其在MAC下面经常会出现莫名其妙的问题。
Builder
IDE
IDE也是程序猿的长期伴侣之一,笔者最早接触到的IDE就是VC6.0，之后有一段时间用了VS系列之后对IDE充满了畏惧，基本上每次开个VS电脑就要卡半天，当时笔者不管写什么都会用Sublime或者Notepad++。

Version Control
Open Source
Github
Github号称是全世界程序猿的搅基之地，也是目前最流行的开源开发者仓库。笔者每天都会翻阅Github的Trending，从中可以发现很多优秀的Repository，也可以瞥见新的技术点和技术发展的方向。


awesome-*系列：awesome系列是Github上非常出名的优秀资源的集合。
awesome-selfhosted:Selfhosting is the process of locally hosting and managing applications instead of renting from SaaS providers. 该Repo攘括了非常多的开源资源，从CMS到Proxy等等，不一而足。

Notes Catalogue
再这样一个优秀编程语言百花齐放的时代，掌握多门编程语言无疑是一件必须要做的事情。学习一门语言的基本语法并无意义，但是这是你真正了解这门语言魅力的基石。语言无论其语法之间具备多大的差异性，从Java、C这样严谨的语言到Ruby、Python、JavaScript这样想怎么写就怎么写的脚本语言，在学习一门语言时需要知道的基本知识却是大同小异。此处就以笔记目录的方式列举出了学习一门编程语言所需要掌握的基本知识结构。

编程语言目录规范（Directory For Programming Language）
此部分主要是阐述了某个语言/框架所包含的内容和应该怎么将需要学习的东西进行分类，这边以Java作为示范。

Advanced:存放编程规范、设计模式、应用架构等相关内容
UI:界面相关内容
Network:存放网络、Socket相关内容
Storage:存放文件系统、数据库等存储相关内容 
MultipleThread：多线程
Thread：线程基本知识
Asynchronous：Promise
Concurrence：并发
TestRelease:存放测试发布相关内容
SysProc:存放系统进程相关内容
Java.md

编程语言笔记目录规范（Catalogue For Programming Language）
此部分即阐述上面提及的Java.md中的相关内容。

入门概述（Introduction）
数据结构（Data Structure）
变量
常量与宏
系统常量
赋值
作用域（Scope）
类型判断
基本类型（Basic）
数值类型
随机数
科学计算
空类型
时间日期
TimeZone(本地化时间)
字符串（String）[长度,空判断]
创建增删
创建添加
复制
替换删除
栈列操作
索引遍历 
存在判断
反向索引
循环遍历
截取分割
类型编码 
Json
HTML
其他操作
Format
Reverse
正则匹配
序列类型（Array）[长度,空判断,序列类型判断]
[若序列类型多种则另开一章，包含数组[]类型]
创建增删 
创建添加
复制
替换删除
栈列操作
索引遍历 
存在判断
反向索引
循环遍历
截取分割
类型转换
其他操作
统计查询
过滤去重
字典类型（Dict）/ Map   #若字典类型多种则另开一章
创建增删
创建添加
替换删除
栈列操作
索引遍历 
存在判断
反向索引
循环遍历
截取分割
类型转换
其他操作
其他类型
时间（DateTime）
流程控制（Control Flow）
运算符
基本运算符
逻辑运算符
运算符重载
闭包（Closure）
代码块（Block）
条件选择
if
循环
for
while
控制
迭代器
函数（Function）/方法（Method）
函数定义
参数调用
默认参数
不定参数
序列函数
map/reduce
filter
模块（Modules）
命名空间
类与对象（Class）
对象分配和初始化
成员变量
成员方法
内存管理
继承
抽象类与接口
匿名类与Lambda
委托（Delegate）
反射
异常处理（Exception）
常用操作（Common APIs）
IO
Console
文件（File）
进程（Proc）
Advanced
内存管理
序列化与反序列化

客户端学习笔记目录规范（Web/iOS/Android/WP）

Advanced：高级内容 
Architect：架构设计
Core：框架底层原理分析
Language：框架常用语言 
Objective-C
Dart
Swift
Java
Network：网络 
Socket
HttpClient 
okHttp(Android)
AFNetworking(iOS)
Storage：存储 
DataBase：数据库
File：文件 
Props：配置文件
Resources：资源文件
Cache：缓存 
UserDefaults(iOS)
SharedPreference(Android)
localStorage(Web)
SysProc：系统与进程 
Components Communication：组件通信 
EventBus(Android)
Notification(iOS)
MultipleThread：多线程
Thread：线程
Asynchronous：异步 
Handler(Android)
PromiseKit(iOS)
Concurrence：并发 
GCD/NSOperation(iOS)
RPC：远程与本地调用 
NDK(Android)
TestRelease：测试与打包发布 
Debug：调试
Release：发布 
Signature(Android)
Ad-hoc/AppStore(iOS)
Confusion：混淆与加密
Test：第三方测试
Optimization：优化
UI 
UI.md：界面呈现的基本原理
Size & Coordinate：尺寸与坐标系
Layout：布局 
AutoLayout(iOS)
AbsoluteLayout(Android)
Basic View：基本的视图提供与控制 
UIView/UIViewController(iOS)
Activity(Android)
iFrame(Web)
Container：常见的作为容器的View/Panel 
ScrollView 
CoordinatorLayout(iOS)
NavigationView
TabBarView
Interaction
Event&Gesture：事件与手势操作 
Event Bind：事件监听与绑定
Event Dispatcher：事件捕获传递与分发
Gesture Recognize：手势监听与识别
Media：音频视频播放、录制与相关操作 
Audio
Video
Sensor：传感器，包括陀螺仪、重力传感器
Widgets 
Dialog：对话框 
Modal Dialog：模态对话框 
iDialog(Web)
Popup：弹出与提示层 
HUD
Popover：覆盖层 
Loading
ActionSheet：底部弹出操作栏
Indicator：指示器 
ProgressBar
Label
Picker 
Button：按钮
Menu：菜单 
Menu：顶部菜单、侧边栏以及底部菜单 
Drawer：抽屉菜单
Toolbar：ActionBar
FAB：浮动按钮、回到顶部按钮
Segment：分段输入器，譬如Ratio Button、Check
Text：文本输入，泛指所有用户的自主输入的内容
TableGrid：网格与表单 
List 
ListView(Android)
UITableView(iOS)
Grid 
UICollectionView(iOS)
RecycleView(Android)
Gallery 
ImageView：图片加载、呈现以及处理 
LazyLoad：图片懒加载
Crop：图片裁剪与美化
Carousel：以Slider/旋转木马等方式呈现块/图片
Waterfall：以瀑布流方式展示块/图片
WebView 
Native Interaction：本地交互 
JS-Patch(iOS)
DVisual：绘图以及数据可视化 
Graphics：基本的绘图相关
Chart：图表相关
Map：地图相关
Animation：动画与变换 
Animation Framework：动画构造库 
KeyFrame：帧动画
Animation Collection：常见动画汇总


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【STL】使用sort类对象对属性的排序

在STL中提供了sort()排序函数，现在我们使用它来实现对类对象特定属性的排序。
首先我们先简单了了解一下sort():
STL容器的排序，支持随机访问的容器vector,deque,string没有sort成员，可调用std::sort排序；list排序调用自带的list::sort。
下面是std::sort函数，有两个版本：
template <classRandomAccessIterator>
void sort (RandomAccessIterator first, RandomAccessIterator last );
template <classRandomAccessIterator, class Compare>
void sort ( RandomAccessIterator first,RandomAccessIterator last, Compare comp );
sort函数有以下特征：
1. 要求输入一个范围[first, last)
2. 随机迭代器，能用此算法的容器是支持随机访问的容器：vector, deque, string。
3.第一个版本使用operator<进行比较，默认升序排序，第二个版本使用comp做比较.
关于参数comp，comp带两个同类型的参数，如果第一个参数排在第二个参数前面，返回true，否则返回false
它可以是函数指针，也可以是函数对象。函数指针好理解，何谓函数对象？
函数对象（Function Object），是重载了operator()函数的类（或结构体）实例化出来的对象，使用起来像函数，又叫仿函数。
STL本身提供了几个比较函数,下面这些都是仿函数：
less(小于)
greater(大于)
equal_to(等于)
not_equal_to(不相等)
less_equal(小于等于)
greater_equal(大于等于)

当容器元素为内建类型时可以使用，注意使用的格式，要加模版参数（由于是模板类）和后面的()，如下：
sort(vec.begin(), vec.end(),greater<int>());
 
对于复合类型，实现排序方式有3种方法：
1）重载operator<操作符
2）写全局的比较函数
3）写仿函数，重载operator()形式为：bool operator()(const 类名& 参数){…}
代码如下：
/*
实现对类中某一属性的排序
三种方法：
1.重载<等符号实现特定的排序（在函数体内）
2.写比较函数
3.仿函数
 
 
*/
 
#include <iostream>
#include <algorithm>
 
 
using namespace std;
class A
{
public:
         voidInit();
         voidPrint();
         intGetA();
         intGetB();
 
         booloperator< (const A& temp)//1.重载operator< 用于排序比较是使用
         {
                   returnthis->a > temp.a;
         }
 
         booloperator()(A &x, A &y)//3.仿函数，也就是重载()
         {
                   returnx.a > y.a;
         }
private:
         inta;
         intb;
         intc;
};
 
 
bool Comp(A &x, A &y)//2.比较函数
{
         returnx.GetB() > y.GetB();
}
 
int A::GetA()
{
         returna;
}
 
int A::GetB()
{
         returnb;
}
 
void A::Init()
{
 
         cin>> a >> b >> c;
}
 
void A::Print()
{
         cout<< "a" << a << " b" << b <<" c" << c << endl;
}
 
 
int main()
{
         Aa[20];
         for(int i = 0; i < 20;i++)
         {
                   a[i].Init();
         }
 
         for(int i = 0; i < 20; i++)
         {
                   a[i].Print();
         }
 
         cout<< endl;
         //sort(a,a + 20);//1.使用operator<
         //sort(a,a + 20, Comp);//2.使用比较函数
         sort(a,a + 20, A());//3.使用仿函数
 
 
         for(int i = 0; i < 20; i++)
         {
                   a[i].Print();
         }
 
         return0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

动态规划 - 最长递增子序列LIS
问题：一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度
样例输入：3 1 2 6 5 4
思路： 首先把问题简单化。可以先求A[1],...A[i]的最长非降子序列，令dp[i]为以A[i]结尾的最长非降子序列。当i = 1 时， 明显是长度dp[1] = 1 ； i = 2 时，前面没有比1小的数字，故dp[2]=1 ， 此时的最长非降子序列为1 ; i = 3 时,比数字2小的数是1 ，并且只有1 ， 分析可知 dp[3] = dp[2]+1；当i = 4 时，找到比数字6小的数有 3 1 2 ，求最长子序列，就应该找到前面的最长子序列的最大值 max{ dp[1],dp[2],dp[3] },此时dp[4]=max{dp[j]+1} ,(j<4
 , A[j]<A[4]) ;通过分析，我们可以归纳出状态转移方程为 dp[i] = max{dp[j]+1 , 1}(j<i , A[j]<A[i]) ;  
下面是代码：

/*
最长非降子序列
2015年8月26日10:19:00
动态规划
*/

#include<iostream>

using namespace std ;

int LIS (int A[] , int n );

int main (){

  int A[] = {3,1,2,6,4,5} ;

  cout << LIS (A,6);

  return 0;

}

int LIS (int A[] , int n ){

  int *dp = new int[n] ;
  dp[0] = 0 ;

  int len  =  1;

  int i , j ;

  for ( i=1 ; i < n ; i ++ ){
    dp[i] = 1 ;
    for ( j = 0 ; j <i ; j ++){

        if (A[j]<A[i]&&dp[j]+1>dp[i])
            dp[i] = dp[j]+1 ;
        if ( len < dp[i] )
            len = dp [i] ;
    }

  }

 delete []dp ;
 return len ;
}



仅作个人理解，希望对没有基础的人有帮助



版权声明：本文为博主原创文章，未经博主允许不得转载。

高精度之重载运算符

这篇文章就纯属自娱自乐啦，受时间以及技术原因的限制，这里面的重载，减法支持的功能仅限于减一次（因为没有同是负号的判断），除法仅限于高精除单精（高精除高精的一个个的减或者二分实在是不想写了）……
结构体片段以及输出操作如下：

struct bignum
{
     int len,s[maxn];
     char flag;
     bignum()
     {
            len=1;
            flag='+';
            memset(s,0,sizeof(s));
     }
     bignum (int num)
     {
            *this=num;
     }
     bignum (const char *num)
     {
            *this=num;
     }              
     bignum operator = (const char *a)
     {
            len=strlen(a);
            for (int i=1;i<=len;++i)
              s[i]=a[len-i]-'0';
            return *this;
     }
     bignum operator = (const int num)
     {
            char a[maxn];
            sprintf(a,"%d",num);
            *this=a;
            return *this;
     }       
     bignum operator + (const bignum &a)
     {
            bignum c;
            c.len=max(len,a.len)+1;
            for (int i=1;i<c.len;++i)
            {
                c.s[i]+=(s[i]+a.s[i]);
                c.s[i+1]+=c.s[i]/10;
                c.s[i]%=10;
            }
            if (c.s[c.len]==0)
              c.len--;
            return c;
     }
     bignum operator += (const bignum &a)
     {
            *this=*this+a;
            return *this;
     }
     bignum operator * (const bignum &a)
     {
            bignum c;
            c.len+=(len+a.len);
            for (int i=1;i<=len;++i)
              for (int j=1;j<=a.len;++j)
              {
                  c.s[i+j-1]+=(s[i]*a.s[j]);
                  c.s[i+j]+=(c.s[i+j-1]/10);
                  c.s[i+j-1]%=10;
              }
            while (c.s[c.len]==0)
               c.len--;
            return c;
     }
     bignum operator *= (const bignum &a)
     {
            *this=(*this) * a;
            return *this;
     }
     bool operator < (const bignum &a) const
     {
          if (len!=a.len)
            return len<a.len;
          for (int i=len;i>=1;--i)
            if (s[i]!=a.s[i])
              return s[i]<a.s[i];
          return false;
     }
     bool operator > (const bignum &a) const
     {
          return a<*this;
     }
     bool operator <= (const bignum &a) const
     {
          return !(*this>a);
     }
     bool operator >= (const bignum &a) const
     {
          return !(*this<a);
     }
     bool operator == (const bignum &a) const
     {
          return !((*this<a) || (*this>a));
     }
     bool operator != (const bignum &a) const
     {
          return !(*this==a);
     }
     void change (bignum &a,bignum &b)
     {
            bignum tmp=a;
            a=b;
            b=tmp;
     }
     bignum operator - (const bignum &a) const
     { 
             bignum b=*this,c;
             if (b<a)
             {
                 c.flag='-';
                 c.len=a.len;
                 for (int i=1;i<=c.len;++i)
                 {
                     c.s[i]+=(a.s[i]-b.s[i]);
                     if (c.s[i]<0)
                     {
                         c.s[i]+=10;
                         c.s[i+1]-=1;
                     }
                 }
                 while (c.len==0)
                    c.len--;
                 return c;
             }
             c.len=b.len;
             for (int i=1;i<=c.len;++i)
             {
                 c.s[i]+=(b.s[i]-a.s[i]);
                 if (c.s[i]<0)
                 {
                      c.s[i]+=10;
                      c.s[i+1]-=1;
                 }
             }
             while (c.len==0)
               c.len--;
             return c;
     }
     bignum operator -= (const bignum &a)
     {
            *this=(*this)-a;
            return *this;
     }
     bignum operator / (const int n)
     {
            bignum c,b=*this;
            c.len=b.len;
            int x=0;
            for (int i=1;i<=n;++i)
            {
                c.s[i]=(x*10+b.s[i])/n;
                x=(x*10+b.s[i])%n;
            }
            while (c.s[c.len]==0)
               c.len--;
            return c;
     }
     bignum operator /= (const int a)
     {
            *this=*this/a;
            return *this;
     }
};

ostream& operator << (ostream &out,const bignum &x)
{
         for (int i=x.len;i>=1;--i)
           printf("%d",x.s[i]);
         return out;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

ios学习之旅--oc对象的关系

1.匿名对象：就是没有名字对象
    1、匿名对象仅用一次
    使用场景：
    1、当我们只要调用一个对象的某个方法一次的时候可以使用匿名对象
    2、匿名对象可以作为函数的实际参数
#import <Foundation/Foundation.h>
#import "CZPerson.h"
#import "CZBook.h"

@interface CZBook : NSObject

@end

@implementation CZBook

@end

@interface CZPerson : NSObject
{
    int _age;//年龄
    NSString *_name;//名字
}
//写方法 setter
- (void) setAge:(int) age;
//读方法 getter
- (int) age;

- (void) setName:(NSString *) name;
- (NSString *) name;
- (void) readBook:(CZBook *) book;

@end

@implementation CZPerson

//写方法 setter
- (void) setAge:(int) age
{
    _age = age;
}
//读方法 getter
- (int) age
{
    return _age;
}
- (void) setName:(NSString *) name
{
    _name = name;
}
- (NSString *) name
{
    return _name;
}
- (void) readBook:(CZBook *) book
{
    
}
@end
int main(int argc, const char * argv[]) {

    [[CZPerson new] setAge:10];
    /*
      1、首先创建一个匿名人对象
      2、调用刚创建出来的人对象的 readBook方法
      3、传入一个匿名的CZBook对象
       [CZPerson new] 创建一个匿名的人对象
       [CZBook new] 创建一个匿名的Book对象
     */   
    [[CZPerson new] readBook:[CZBook new]];    
    NSLog(@"%d",[[CZPerson new] age]);    
    
    return 0;
}2.依赖关系：
   A对象作为B对象的局部变量或是方法形参的，B依赖与A,这时候我们称A与B之间存在一种依赖关系
  面向对象设计中：
  耦合度：当修改一个对象的时候，对另外一个对象的影响程度
  低耦合: 当修改一个对象的对其他对象影响比较小
  高内聚:一个对象仅仅做自己相关的事情
  面向对象设计原则：单一职责原则
#import <Foundation/Foundation.h>
@interface CZBeauty : NSObject
{
    NSString * _name;//姓名
}
- (void) setName:(NSString *) name;
- (NSString *) name;
/**
 *  给土豪打电话
 */
- (void) callTuHaoWithPhone:(CZPhone *) phone;
- (void) sendMessageToDiaoSi;

@end

@implementation CZBeauty

- (void) setName:(NSString *) name
{
    _name = name;
}

- (NSString *) name
{
    return _name;
}
/**
 *  给土豪打电话、
    对象作为形式参数
 */
- (void) callTuHaoWithPhone:(CZPhone *) phone
{
    NSLog(@"给土豪打电话了");
    [phone call:@"土豪的电话号码"];
}
- (void) sendMessageToDiaoSi
{
    NSLog(@"给屌丝发送短信了");
//  对象作为另外一个类的局部变量
    CZPhone *phone = [CZPhone new];   
    [phone sendMessage:@"呵呵，要请我看电影吗？"];
}

@end

@interface CZPhone : NSObject
/**
 *  发短信
 *
 *  @param message 信息内容
 */
- (void) sendMessage:(NSString *) message;
/**
 *  打电话
 */
- (void) call:(NSString *) phoneNum;

@end

@implementation CZPhone

/**
 *  发短信
 *
 *  @param message 信息内容
 */
- (void) sendMessage:(NSString *) message
{
    NSLog(@"发送一条 %@ 短信",message);
}
/**
 *  打电话
 */
- (void) call:(NSString *) phoneNum
{
    NSLog(@"给电话号码为 %@ 的人打电话",phoneNum);
}

@end

int main(int argc, const char * argv[]) {
//  创建一个美女
    CZBeauty *beauty = [CZBeauty new];
//  创建一个电话
    CZPhone *phone = [CZPhone new];
    
    [beauty setName:@"fbb"];
 
    [beauty callTuHaoWithPhone:phone];
    
    [beauty sendMessageToDiaoSi];
    
    return 0;
}
3.关联关系（多文件）
           HasA关系：当一个对象拥有另外一个对象的时候，
          当A对象为B对象的成员变量的时候，
          A对象与B对象之间存在一种关联关系
 
 
 关联关系是面向对象中最常用一种关系
 ---------------------------------------------------以下了解
 关联关系的耦合度要高于依赖关系
 
 一对一 ：单方依赖，双边依赖
 一对多关系 :  班级与学生，一个班级可以有多个学生
 多对多关系 ： 学生与课程，一个学生可以学习多门课程，一个门课程被多个学生学习


#import <Foundation/Foundation.h>
#import "CZBeauty.h"
#import "CZNewBeauty.h"

int main(int argc, const char * argv[]) {  
    CZBeauty *beauty =  [CZBeauty new];
    CZIPad *ipad = [CZIPad new];    
    CZNewBeauty *newBeauty = [CZNewBeauty new];
    [newBeauty setIPad:ipad];    
    [newBeauty lookAtMovie];
    [newBeauty listenToMusic];
    [newBeauty playGame];
    [newBeauty takeSelfPhoto];
    
    return 0;
}

#import <Foundation/Foundation.h>
#import "CZIPad.h"
/*
   当我们在一类中总是使用某个对象，作为形式参数，那么我们就把这个参数提取成员变量 
 */
@interface CZBeauty : NSObject
//使用iPad看电影
- (void) lookAtMovieWithIPad:(CZIPad *) ipad;
//使用IPad听音乐
- (void) listenToMusicWithIPad:(CZIPad *) ipad;
/**
 * 美女玩游戏
 */
- (void) playGameWithIPad:(CZIPad *) ipad;
/**
 *  美女自拍
 */
- (void) takeSelfPhotoWithIPad:(CZIPad *) ipad;
@end

#import "CZBeauty.h"
@implementation CZBeauty
//使用iPad看电影
- (void) lookAtMovieWithIPad:(CZIPad *) ipad
{
     NSLog(@"美女要看电影了！");
     [ipad playMovie];
}
//使用IPad听音乐
- (void) listenToMusicWithIPad:(CZIPad *) ipad
{
    NSLog(@"美女要听音乐了！");
    [ipad playMusic];
}
/**
 * 美女玩游戏
 */
- (void) playGameWithIPad:(CZIPad *) ipad
{
    NSLog(@"美女要玩游戏了！");
    [ipad playGame];
}
/**
 *  美女自拍
 */
- (void) takeSelfPhotoWithIPad:(CZIPad *) ipad
{
    NSLog(@"美女要自拍了！");
    [ipad takePhoto];
}

@end

#import <Foundation/Foundation.h>
@interface CZIPad : NSObject
//播放电影
- (void) playMovie;
//播放音乐
- (void) playMusic;
//玩游戏
- (void) playGame;
//拍照
- (void) takePhoto;

@end

#import "CZIPad.h"
@implementation CZIPad
//播放电影
- (void) playMovie
{
    NSLog(@"iPad播放电影");
}
//播放音乐
- (void) playMusic
{
    NSLog(@"iPad播放音乐");
}
//玩游戏
- (void) playGame
{
    NSLog(@"iPad玩游戏");
}
//拍照
- (void) takePhoto
{
    NSLog(@"iPad自拍");
}

@end

#import <Foundation/Foundation.h>
#import "CZIPad.h"
@interface CZNewBeauty : NSObject
{
//  让美女拥有一个IPad
    CZIPad * _iPad;
}
//写方法，买一个IPad
- (void) setIPad:(CZIPad *) iPad;
//看电影
- (void) lookAtMovie;
//听音乐
- (void) listenToMusic;
/**
 * 美女玩游戏
 */
- (void) playGame;
/**
 *  美女自拍
 */
- (void) takeSelfPhoto;

@end

#import "CZNewBeauty.h"
@implementation CZNewBeauty
//写方法，买一个IPad
- (void) setIPad:(CZIPad *) iPad
{
    _iPad = iPad;
}
//看电影
- (void) lookAtMovie
{
    NSLog(@"美女看电影");
    [_iPad playMovie];
}
//听音乐
- (void) listenToMusic
{
    NSLog(@"美女听音乐");
    [_iPad playMusic];
}
/**
 * 美女玩游戏
 */
- (void) playGame
{
    NSLog(@"美女玩游戏");
    [_iPad playGame];
}
/**
 *  美女自拍
 */
- (void) takeSelfPhoto
{
    NSLog(@"美女自拍");
    [_iPad takePhoto];
}

@end
学习心得：
通过各自对应的例子，熟练掌握面向对象，为以后的学习打好基础


版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1124
Factorial
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 3242 Accepted Submission(s): 2088


Problem Description
The most important part of a GSM network is so called Base Transceiver Station (BTS). These transceivers form the areas called cells (this term gave the name to the cellular phone) and every phone connects to the BTS with the strongest
 signal (in a little simplified view). Of course, BTSes need some attention and technicians need to check their function periodically.

ACM technicians faced a very interesting problem recently. Given a set of BTSes to visit, they needed to find the shortest path to visit all of the given points and return back to the central company building. Programmers have spent several months studying
 this problem but with no results. They were unable to find the solution fast enough. After a long time, one of the programmers found this problem in a conference article. Unfortunately, he found that the problem is so called "Travelling Salesman Problem" and
 it is very hard to solve. If we have N BTSes to be visited, we can visit them in any order, giving us N! possibilities to examine. The function expressing that number is called factorial and can be computed as a product 1.2.3.4....N. The number is very high
 even for a relatively small N. 

The programmers understood they had no chance to solve the problem. But because they have already received the research grant from the government, they needed to continue with their studies and produce at least some results. So they started to study behaviour
 of the factorial function. 

For example, they defined the function Z. For any positive integer N, Z(N) is the number of zeros at the end of the decimal form of number N!. They noticed that this function never decreases. If we have two numbers N1<N2, then Z(N1) <= Z(N2). It is because
 we can never "lose" any trailing zero by multiplying by any positive number. We can only get new and new zeros. The function Z is very interesting, so we need a computer program that can determine its value efficiently.



Input
There is a single positive integer T on the first line of input. It stands for the number of numbers to follow. Then there is T lines, each containing exactly one positive integer number N, 1 <= N <= 1000000000.




Output
For every number N, output a single line containing the single non-negative integer Z(N).



Sample Input

6
3
60
100
1024
23456
8735373



Sample Output

0
14
24
253
5861
2183837



Source
Central Europe 2000 


#include<stdio.h>  
int main()  
{  
    int num,key,sum,temp;  
    scanf ("%d",&key);  
    while(key--)  
    {  
        scanf ("%d",&num);
        sum=0;  
        temp=5;  
        while(num/temp!=0)  
        {  
            sum=sum+num/temp;  
            temp=temp*5;  
        }  
        printf ("%d\n",sum);
    }  
    return 0;  
}  



版权声明：本文为博主原创文章，未经博主允许不得转载。

临时变量作为非const的引用进行参数传递引发的编译错误
1.错误原因即解决办法
Linux环境运行，使用g++编译，观察如下代码，会出现： invalid initialization of non-const reference of type ‘std::string&’ from a temporary of type ‘std::string’的错误。
其中文意思为临时变量无法为非const的引用的初始化。也就是在参数传递的过程中，出现错误。出错的代码如下：
void print(string& str)
{
    cout<<str<<endl;
}
//如此调用会报上面描述的错误
print("hello world");
出错的原因是编译器根据字符串”hello world”构造一个string类型的临时对象，这个临时对象具有const属性。当这个临时对象传递给非const的string&引用类型时，因为非const引用绑定对象时，要求该对象也是非const对象。而在这时，因为string类型的临时对象是const对象，所以就出现错误。
结合引用的性质可知： 
（1）能建立引用的表达式一定是左值； 
（2）不能作为左值的表达式只能建立常引用。
因此，解决办法就是将print()函数的参数改为常引用。代码修改如下，可顺利通过编译。
void print(const string& str)
{
    cout<<str<<endl;
}
//顺利通过编译
print("hello world");
通过以上代码，也可以看出Effective C++中倡导的一个C++的编程原则，即尽可能的使用const。因为这样可以使代码更为健壮，将错误暴露于编译阶段。

2.所有的临时对象都是const对象吗
为什么临时对象作为引用参数传递时，必须是常量引用呢？很多人对此的解释是临时对象是常量，不允许赋值改动，所以作为非常量引用传递时，编译器就会报错。这个解释在关于理解临时对象不能作为非const引用参数这个问题上是可以的，但不够准确。更有甚者，认为所有的临时对象均是const对象，因此，对于网上的观点和资源我们应该持着谨慎怀疑的态度去接受学习，应该坚持鲁迅先生倡导的”拿来主义”。
事实上，临时变量是可以被作为左值(LValue) 并被赋值的，请看下面的代码：
class IntClass{
private:
    int x;
public:
    IntClass(int value):x(value){
    }

    friend  ostream& operator<<( ostream &os, const IntClass &intc);
};

//重载输出operator<<
ostream& operator<<( ostream &os, const IntClass &intc)
{
    os<<intc.x;
    return os;
}

//打印函数
void print(IntClass & intc)
{
    cout<<intc<<endl;
    //通过引用修改这个临时对象
    intc=8;
    cout<<intc<<endl;
}

int main(int argc,char* argv[])
{
    print(IntClass(6));
}
程序输出： 
6 
8
以上代正确编译运行，没有错误。IntClass(6)表示生成一个无名的临时对象，传递给非const引用，在print函数中通过引用修改了这个临时对象。这说明了并非所有的临时对象都是const对象。
那哪些临时对象是const对象，哪些临时对象不是const对象呢？这里贴上摘自网上的一句话：“内置类型产生的临时变量具有常性，而自定义类型产生的临时变量不具有常性”，我想这句话能解释你所谓的临时变量为什么能作为左值的原因。。”此话不知正确与否，但目前还没有发现其错误，待以后考证。

参考文献
[1]http://blog.sina.com.cn/s/blog_4cce4f6a0100piuv.html

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

每天五个java相关面试题（10）--java基础详解篇2
好勒好勒。一起加油
一、HashMap和Hashtable的区别。
答： 
HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。 
HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 
HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。  
Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 
最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。  
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。
上面回答中涉及的知识点：
1、Dictionary类，为抽象类，用来储存键值对，作用与Map相似。（这个类已过时）。 
2、线程安全。这个问题又涉及到了线程安全，所有关于线程安全可以看我前一篇博文中提到的线程安全知识点。
二、final, finally, finalize的区别。
答： 
final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。 
finally是异常处理语句结构的一部分，表示总是执行。 
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。
上面回答中涉及的知识点：
1、每个类都有finalize()方法嘛？为什么？ 
答：都有这个方法。由于finalize()属于Object类，因此所有类都有这个方法，Object的任意子类都可以重写 （override）该方法，在其中释放系统资源或者做其它的清理工作，如关闭输入输出流。
三、sleep() 和 wait() 有什么区别?
答： 
sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
上面回答中涉及的知识点：
关于线程大家可点击我以前的这篇文章熟悉一下关于线程常考的面试题：《每天五个java面试题——线程篇》
四、Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?
答： 
方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。
五、error和exception有什么区别?
答： 
error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 
exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。
有什么问题的地方或是你觉得回答中可能是个“坑”、会被面试官抓住追问的地方欢迎大家一起交流~一起进步~！

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。请多多指教~

剑指offer26:复杂链表的复制
复杂链表的复制第三步，我自己写了一个函数，易于理解。
把第二步得到的链表拆分成两个链表，奇数位置上的结点组成原始链表，偶数位置上的结点组成复制出来的链表。
示例代码如下：
#include <iostream>
using namespace std;
typedef struct ListNode{
	int value;
	struct ListNode* next;
}ListNode;

ListNode* CreateList(int nodeNumber){
	ListNode* head=NULL;
	ListNode* tail=NULL;
	int value;
	for(int i=0;i<nodeNumber;i++){
		cin>>value;
		ListNode* temp=new ListNode();
		temp->value=value;
		temp->next=NULL;
		if(head==NULL){
			head=temp;
			tail=head;//尾插法
		}else{
			tail->next=temp;
			tail=tail->next;
		}
	}
	return head;
}

ListNode* ReconnectList(ListNode* pHead){
	if(pHead==NULL)
		return NULL;
	ListNode* pNewHead=pHead->next;
	ListNode* pNewTail=pNewHead;
	ListNode* pTail=pHead;
	if(pHead->next->next==NULL){ //原链表只有一个结点的情况
		pHead->next=NULL;
	}else{
		int i=3;
		ListNode* traPointer=pNewHead->next;//遍历合并的链表
		while(traPointer!=NULL){
			if(i%2!=0){ //奇数位置的结点属于原链表
				pTail->next=traPointer;
				pTail=pTail->next;
			}else{
				pNewTail->next=traPointer;
				pNewTail=pNewTail->next;
			}
			traPointer=traPointer->next;
			++i;
		}
		pTail->next=NULL;//结尾为NULL
	}
	return pNewHead;
}

void PrintList(ListNode* head){
	if(head==NULL)
		return;
	ListNode *pNode=head;
	while(pNode!=NULL){
		std::cout<<pNode->value<<" ";
		pNode=pNode->next;
	}
	std::cout<<std::endl;
}

void TestProgram26(){
	int nodeNumber;
	cin>>nodeNumber;
	ListNode* head=CreateList(nodeNumber);
	ListNode* newHead=ReconnectList(head);
	PrintList(head);
	PrintList(newHead);
}

运行结果截图：






版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题26-复杂链表的复制
题目：
请实现函数ComplexListNode* Clone(ComplexListNode* pHead)，复制一个复杂链表。
在复杂链表中，每一个节点除了一个m_pNext指针指向下一个节点外，还有一个m_pSibling指向链表中的任意节点或者NULL，节点的定义如下：



package com.aii.algorithm;

public class Node {
	int value;
	Node next;
	Node sibling;

	public Node(int value) {
		this.value = value;
	}


	public Node() {
	}

}







一.思路：
可以分两步来实现：
1.先复制链表，sibling就用旧链表的，照搬。
2.再复制silbing
怎么复制sibling，这个借助一个HashMap（在O(1)时间内能够找到），将Node与其复制的Node'的映射关系存到HashMap中。
在第二步修改sibling的时候，根据原先sibling的Node去Map中找，找到对应的那个就是他应该指向的那个。


代码实现：

package com.aii.algorithm;

import java.util.HashMap;
import java.util.Map;

public class CloneNodes {
	// 第一步：复制链表
	// 第二步：复制sibing的指针位置
	public Node clone(Node head) {
		Map<Node, Node> map = new HashMap<Node, Node>();

		// copy linkedlist
		Node newHead = cloneNode(head, map);

		// copy silbing points
		Node tmpNewHead = newHead;
		while (tmpNewHead != null) {
			// get from mapping
			tmpNewHead.sibling = map.get(tmpNewHead.sibling);
			tmpNewHead = tmpNewHead.next;
		}
		return newHead;
	}

	// 1.递归克隆
	// 2.同时将Node，以及Node'的映射关系放入到map中，方便map.next查找
	private Node cloneNode(Node head, Map<Node, Node> map) {
		if (head == null) {
			return null;
		}
		Node node = new Node();
		node.next = cloneNode(head.next, map);
		node.sibling = head.sibling;
		map.put(head, node);
		node.value = head.value;
		return node;
	}
}





二、
这里借助了HashMap
如果不借助HashMap，又要在O(n)时间完成？


不使用Map，在修改sibling的时候，麻烦之处在哪？
在于找不到新复制的节点。
下图：






比如说要在A'位置找A'的silbing，那就要A'与A一起往前走，直到某个节点Node==A.sibling这个时候对应的Node'也应该是A'.silbing。
但是这样的时间复杂度为O(n*n)


这里有一个好的办法：
分三步走：
1.将新复制的链表穿插到旧的链表中


2.这样子就能够根据左右位置的旧的节点找到sibling位置了


3.还原。




代码实现：

package com.aii.algorithm;

public class CloneNodes2 {

	// 1.将新的节点插入到链表原始节点的后面
	// 2.将新的节点的sibling的指针给赋值，是原先值的next
	// 3.再将新的节点链表从中独立出来
	public Node clone(Node head) {
		Node tmp = head;
		// 1.第一步，插入新的节点
		while (tmp != null) {
			Node next = tmp.next;
			Node node = new Node();
			node.value = tmp.value;
			node.next = tmp.next;
			tmp.next = node;
			//
			tmp = next;
		}

		// 2.第二步，设置sibling
		int count = 0;
		tmp = head;
		Node nodeNext = null;
		while (tmp != null) {
			if (count++ % 2 == 0) {
				nodeNext = tmp.next;
			} else {
				tmp.next = nodeNext.next;
			}
			tmp = tmp.next;
		}

		// 3.第三步，将新的链表独立出来，并且还原原先的链表
		tmp = head;
		Node newHead = null;
		count = 0;
		while (tmp != null) {
			tmp.next = tmp.next.next;
			newHead = tmp.next;

			tmp = tmp.next;
		}

		return newHead;
	}
}



三、测试用例：
由于引用关系比较复杂，toString容易引发空指针，这里附上测试用例：

package com.aii.algorithm;

import org.junit.Before;
import org.junit.Test;

public class CloneNodes2Test {
	private Node head = new Node('a');

	@Before
	public void init() {
		Node n2 = new Node('b');
		Node n3 = new Node('c');
		Node n4 = new Node('d');
		Node n5 = new Node('e');

		head.next = n2;
		n2.next = n3;
		n3.next = n4;
		n4.next = n5;

		//
		head.sibling = n3;
		n2.sibling = n5;
		n3.sibling = n2;
	}

	@Test
	public void test() {
		printNode(head);
		Node node = new CloneNodes().clone(head);
		System.out.println("-----");
		printNode(node);
		System.out.println("-----");
		printNode(head);
	}

	private void printNode(Node node) {
		Node tmp = node;
		while (tmp != null) {
			int sibling = -1;
			if (tmp.sibling != null) {
				sibling = tmp.sibling.value;
			}
			int next = -1;
			if (tmp.next != null) {
				next = tmp.next.value;
			}
			System.out.print("value:" + (char) tmp.value);
			System.out.print("\tsibling:" + (char) sibling);
			System.out.println("\tnext:" + (char) next);
			tmp = tmp.next;
		}
	}
}


结果：
value:a sibling:cnext:b
value:b sibling:enext:c
value:c sibling:bnext:d
value:d sibling:?next:e
value:e sibling:?next:?
-----
value:a sibling:cnext:b
value:b sibling:enext:c
value:c sibling:bnext:d
value:d sibling:?next:e
value:e sibling:?next:?
-----
value:a sibling:cnext:b
value:b sibling:enext:c
value:c sibling:bnext:d
value:d sibling:?next:e
value:e sibling:?next:?






版权声明：本文为博主原创文章，未经博主允许不得转载。

点的双连通分量问题
连通性·四
题目传送：hihoCoder - 1190 - 连通性·四
好吧，这简单题敲了好久。。快一上午了，，基础不好诶。。
AC代码：
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cctype>
#include <cstdio>
#include <string>
#include <vector>
#include <complex>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>
#include <utility>
#include <iostream>
#include <algorithm>
#include <functional>
#define LL long long
#define INF 0x7fffffff
using namespace std;

const int maxn = 20005;
int n, m;
pair<int, int> e[100005];//用pair存边 

vector<int> G[maxn];//整个图 
map<pair<int, int>, int> mp;//标记每条边的分组，刚开始为0 
map<pair<int, int>, int> id;//记录每条边的编号 

int vis[maxn];

int dfn[maxn];
int low[maxn];

stack<pair<int, int> > s;

int cur_time, cnt;
void dfs(int u, int fa) {
    dfn[u] = low[u] = ++ cur_time;
    vis[u] = 1;

    int child = 0;
    int d = G[u].size();
    for(int i = 0; i < d; i ++) {

        int v = G[u][i];
        pair<int, int> pai = make_pair(min(u, v), max(u, v));

        if(mp[pai] != 0) continue;
        if(!vis[v]) {
            child ++;
            s.push(pai);
            dfs(v, u);
            low[u] = min(low[u], low[v]);

            if(fa == -1 && child > 1) {//求出树根为割点的时候的点的双连通分量 
                cnt ++;
                stack<pair<int, int> > ss;
                int MIN = INF;
                while(s.top() != pai) {
                    MIN = min(MIN, id[s.top()]);
                    ss.push(s.top());
                    s.pop();
                }
                MIN = min(MIN, id[pai]);
                ss.push(pai);
                s.pop();

                //cout << MIN << " haha";
                while(!ss.empty()) {
                    mp[ss.top()] = MIN;
                    ss.pop();
                }
            }

            if(fa != -1 && low[v] >= dfn[u]) {//求出树根以外的结点为割点的点的双连通分量 
                //cout << "low " << low[v] << " dfn " << dfn[u] << endl; 
                cnt ++;
                stack<pair<int, int> > ss;
                int MIN = INF;
                while(s.top() != pai) {
                    MIN = min(MIN, id[s.top()]);
                    //cout << id[s.top()] << " " << s.top().first << " " << s.top().second << endl;
                    ss.push(s.top());
                    s.pop();
                }
                //cout << id[pai] << endl;
                MIN = min(MIN, id[pai]);
                ss.push(pai);
                s.pop();

                //cout << MIN << " haha" << endl;
                while(!ss.empty()) {
                    mp[ss.top()] = MIN;
                    ss.pop();
                }
            }
        }
        else if(v != fa) {//反向边的情况 
            s.push(pai);
            low[u] = min(low[u], dfn[v]);
        }
    }
}

int main() {
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= m; i ++) {
        scanf("%d %d", &e[i].first, &e[i].second);
        G[e[i].first].push_back(e[i].second);
        G[e[i].second].push_back(e[i].first);
        mp[e[i]] = 0;
        id[e[i]] = i;
    }

    cur_time = cnt = 0;
    dfs(1, -1);

    //求剩余那部分的点的双连通分量 
    stack<pair<int, int> > ss;
    int MIN = INF;
    while(!s.empty()) {
        ss.push(s.top());
        MIN = min(MIN, id[s.top()]);
        s.pop();
    }
    if(MIN != INF) cnt ++;
    while(!ss.empty()) {
        mp[ss.top()] = MIN;
        ss.pop();
    }

    printf("%d\n", cnt);
    for(int i = 1; i < m; i ++) {
        printf("%d ", mp[e[i]]);
    }
    printf("%d\n", mp[e[m]]);
    return 0;
}




            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

06-图4. Saving James Bond - Hard Version (30)

06-图4. Saving James Bond - Hard Version (30)



时间限制

400 ms




内存限制

65536 kB




代码长度限制

8000 B




判题程序

Standard


作者

CHEN, Yue




This time let us consider the situation in the movie "Live and Let Die" in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he
 performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head... Finally he reached the bank before the last crocodile could bite him
 (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).

Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions.
 Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.

Input Specification:

Each input file contains one test case. Each case starts with a line containing two positive integers N (<=100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x, y) location of a crocodile.
 Note that no two crocodiles are staying at the same position.

Output Specification:

For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x, y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible
 for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.
Sample Input 1:
17 15
10 -21
10 21
-40 10
30 -50
20 40
35 10
0 -10
-25 22
40 -40
-30 30
-10 22
0 11
25 21
25 10
10 10
10 35
-30 10

Sample Output 1:
4
0 11
10 21
10 35

Sample Input 2:
4 13
-12 12
12 12
-12 -12
12 -12

Sample Output 2:

0





#include <stdio.h>
#include <math.h>
#include <stdlib.h>
typedef struct {
	double x, y;
	int pre;				//记录路径上该节点的前一个节点，初始化为-1
	int escape;				//记录该节点能否直接跳上岸逃生
}Vertex;
struct Node {
	int val;
	struct Node *next;
};
int inLake(double x, double y) {				//判断鳄鱼是否在湖里面；在岛上或岸上的鳄鱼不与任何节点相连
	if (7.5 * 7.5 >= x * x + y * y)
		return 0;
	if (fabs(x) >= 50 || fabs(y) >= 50)
		return 0;
	return 1;
}
void createGraph(struct Node *table, Vertex *vertex, int n, int d) {
	for (int i = 1; i <= n; ++i) {				//将第一跳能跳到的节点链接到下标0，升序排序
		if (inLake(vertex[i].x, vertex[i].y) && (d + 7.5)*(d + 7.5) >= vertex[i].x * vertex[i].x + vertex[i].y * vertex[i].y) {
			struct Node *p = (struct Node *)malloc(sizeof(struct Node));
			p->val = i;
			struct Node *pre = &table[0];		//寻找插入位置的前一个节点
			while (pre->next && vertex[i].x * vertex[i].x + vertex[i].y * vertex[i].y > vertex[pre->next->val].x * vertex[pre->next->val].x + vertex[pre->next->val].y * vertex[pre->next->val].y) {
				pre = pre->next;
			}
			p->next = pre->next;
			pre->next = p;
		}
	}
	for (int i = 1; i <= n; ++i) {				//将鳄鱼的节点连成网络
		if (!inLake(vertex[i].x, vertex[i].y))
			continue;
		for (int j = 1; j <= n; ++j) {
			if (j != i && inLake(vertex[j].x, vertex[j].y) && d * d >= (vertex[i].x - vertex[j].x)*(vertex[i].x - vertex[j].x) + (vertex[i].y - vertex[j].y) * (vertex[i].y - vertex[j].y)) {
				struct Node *p = (struct Node *)malloc(sizeof(struct Node));
				p->val = j;
				p->next = table[i].next;
				table[i].next = p;
			}
		}
	}
}
int BFS(struct Node *table, Vertex *vertex, int n, int d) {
	struct Node *p = &table[0];
	while (p = p->next) {				//以第一跳能跳到的节点为起始点广度优先搜索
		//		int pace = 0;					//深度，对应跳的次数
		int v = p->val;					//起始节点
		int queue[101] = {}, head = 0, rear = 0;		//队列
		int visited[101] = {};			//用于标记节点是否已访问
		visited[v] = 1;
		queue[rear++] = v;				//第一个节点入队
		vertex[v].pre = 0;				//起始节点的前一个节点为中心岛
		while (rear - head) {			//队列不为空，循环
			v = queue[head++];			//出队
			if (vertex[v].escape) {		//如果当前节点能跳到岸上，返回逃跑成功
				return v;
			}
			struct Node *q = &table[v];	//否则，将该节点所有没有被访问的邻节点都入队
			while (q = q->next) {		//遍历每个邻接点
				int u = q->val;
				if (!visited[u]) {		//如果该邻节点没有被访问，入队
					visited[u] = 1;
					queue[rear++] = u;
					vertex[u].pre = v;	//记录当前入队节点的前一个节点
				}
			}
		}
	}
	return 0;			//无法逃离
}
void destroyGraph(struct Node* table, int n) {		//释放堆内空间
	for (int i = 0; i <= n; ++i) {
		struct Node* p = table[i].next;
		while (p) {
			struct Node* tmp = p;
			p = p->next;
			free(tmp);
		}
	}
}
int main() {
//	freopen("test.txt", "r", stdin);
	int n;
	double d;
	scanf("%d%lf", &n, &d);
	if (d >= 50 - 7.5) {					//可以直接跳上岸
		printf("1\n");
		return 0;
	}
	Vertex vertex[101];
	for (int i = 1; i <= n; ++i) {			//初始化节点信息，下标1开始分别对应每只鳄鱼，下标0对应中心小岛
		scanf("%lf%lf", &vertex[i].x, &vertex[i].y);
		vertex[i].pre = -1;
		if (fabs(50 - fabs(vertex[i].x)) <= d || fabs(50 - fabs(vertex[i].y)) <= d)		//判断该节点能否直接跳上岸逃生
			vertex[i].escape = 1;
		else
			vertex[i].escape = 0;
	}
	struct Node table[101] = {};			//邻接表形式储存图结构
	createGraph(table, vertex, n, d);		//构造图
	int escape = BFS(table, vertex, n, d);	//广度优先搜索图，返回逃跑成功的最后一个节点，不能逃跑返回0
	if (escape) {						//如果能逃生，回溯寻找路径
		int pace = 1;
		int stack[100] = {}, top = 0;	//栈
		int v = escape;
		while (v) {						//回溯路径，依次压栈
			++pace;
			stack[top++] = v;
			v = vertex[v].pre;
		}
		printf("%d\n", pace);
		while (top) {					//依次弹出栈内元素
			v = stack[--top];
			printf("%d %d\n", (int)vertex[v].x, (int)vertex[v].y);
		}
	}
	else {
		printf("0\n");
	}
	destroyGraph(table, n);

	return 0;
}





注意：

测试点3：有鳄鱼在岸上或中心岛；

测试点4：有多条路径，选择其中第一跳最短的路径；

测试点5：可以直接从中心岛跳到岸上。



题目链接：http://www.patest.cn/contests/mooc-ds/06-%E5%9B%BE4

版权声明：本文为博主原创文章，未经博主允许不得转载。

Picking up Jewels

Picking up Jewels



There is a maze that has one entrance and one exit. 
Jewels are placed in passages of the maze. 
You want to pick up the jewels after getting into the maze through the entrance and before getting out of it through the exit. 
You want to get as many jewels as possible, but you don’t want to take the same passage you used once.


When locations of a maze and jewels are given, 
find out the greatest number of jewels you can get without taking the same passage twice, and the path taken in this case.


Time limit : 1 sec (Java : 2 sec) (If your program exceeds this time limit, the answers that have been already printed are ignored and the score becomes 0. So, it may be better to print a wrong answer when a specific test case
 might cause your program to exceed the time limit. One guide for the time limit excess would be the size of the input.)


[Input]
There can be more than one test case in the input file. The first line has T, the number of test cases. 
Then the totally T test cases are provided in the following lines (T ≤ 10 )


In each test case, 
In the first line, the size of the maze N (1 ≤ N ≤ 10) is given. The maze is N×N square-shaped. 
From the second line through N lines, information of the maze is given. 
“0” means a passage, “1” means a wall, and “2” means a location of a jewel. 
The entrance is located on the upper-most left passage and the exit is located on the lower-most right passage. 
There is no case where the path from the entrance to the exit doesn’t exist.


[Output]
For each test case, you should print "Case #T" in the first line where T means the case number.

For each test case, from the first line through N lines, mark the path with 3 and output it.
In N+1 line, output the greatest number of jewels that can be picked up. 

[I/O Example]

Input
2
5
0 0 0 2 0
2 1 0 1 2
0 0 2 2 0
0 1 0 1 2
2 0 0 0 0
6
0 1 2 1 0 0
0 1 0 0 0 1
0 1 2 1 2 1
0 2 0 1 0 2
0 1 0 1 0 1
2 0 2 1 0 0


Output

Case #1

3 0 3 3 3 
3 1 3 1 3 
3 0 3 2 3 
3 1 3 1 3 
3 3 3 0 3 
6

Case #2

3 1 2 1 0 0 
3 1 3 3 3 1 
3 1 3 1 3 1 
3 2 3 1 3 2 
3 1 3 1 3 1 
3 3 3 1 3 3 
4

/*

You should use the statndard input/output

 

in order to receive a score properly.

 

Do not use file input and output

 

Please be very careful.

*/

 

#include <stdio.h>

 

#define MAX_N  11

#define true   1

#define false  0

 

int Array[MAX_N][MAX_N];

int Path[MAX_N][MAX_N];//保存走过的路径

int Visited[MAX_N][MAX_N];//标记走过的路径

int Answer[MAX_N][MAX_N];

int Max_Jewes;

 

 

int N;

//int total ;

//int Answer = 0 ;

 

void SavePath()

{

     int i,j;

     for(i=0;i<N;i++)

     {

         for(j=0;j<N;j++)

         {

              Answer[i][j] = Path[i][j];

         }

     }

}

 

int Visit(int i, int j, int total)

{

     int ret = 0;

     Path[i][j] = 3 ;

     Visited[i][j] = true ;

 

     if((i ==0)&&(j == 0)&&(Array[i][j] == 2))//如果第一个节点为2，total加1

     {

         total++;

     }

    

     if((i == N-1)&&(j == N-1))//如果到达终点，则判断本次遍历的结果和之前所有次数中最大的结果最比较，如果大于之前的结果，则保存这个最大值和本次路径

     {

         if(total > Max_Jewes)

         {

              Max_Jewes = total ;

              SavePath();

         }

        

         Visited[i][j] = false ;//将终点标记成未扫描过，使下一次遍历还可以扫描到该点

         return 1;

     }   

    

     if((j+1) <= (N-1))//down

     {

         if((!Visited[i][j+1])&&(Array[i][j+1] != 1))//如果该点的下方的点没有被扫描过，并且该点下方的点不为墙（1）

         {

              if(Array[i][j+1] == 2)//如果有宝藏，则总数加1，继续遍历

                   Visit(i, j+1, total+1);

              else

                   Visit(i, j+1, total);//如果没有宝藏，则总数不变，继续遍历

 

              Path[i][j+1] = Array[i][j+1] ;//死角，回退之后恢复path的值          

         }

     }

    

     if((j-1) >= 0)//up

     {

         if((!Visited[i][j-1])&&(Array[i][j-1] != 1))

         {

              if(Array[i][j-1] == 2)

                   Visit(i , j-1, total+1);

              else

                   Visit(i , j-1, total);

 

              Path[i][j-1] = Array[i][j-1] ;             

             

         }

     }

 

     if((i+1) <= (N-1))//right

     {

         if((!Visited[i+1][j])&&(Array[i+1][j] != 1))

         {

              if(Array[i+1][j] == 2)

                   Visit(i+1 , j, total+1);

              else

                   Visit(i+1 , j, total);

 

              Path[i+1][j] = Array[i+1][j] ;             

             

         }

     }

    

    

    

     if((i-1) >= 0)//left

     {

         if((!Visited[i-1][j])&&(Array[i-1][j] != 1))

         {

              if(Array[i-1][j] == 2)

                   Visit(i-1 , j, total+1);

              else

                   Visit(i-1 , j, total);

 

             Path[i-1][j] = Array[i-1][j];               

             

         }

     }

     Visited[i][j] = false ;

 

     return -1;

}

 

int main(void)

{

     int T, test_case;

     /*

        The freopen function below opens input.txt file in read only mode, and afterward,

        the program will read from input.txt file instead of standard(keyboard) input.

        To test your program, you may save input data in input.txt file,

        and use freopen function to read from the file when using scanf function.

        You may remove the comment symbols(//) in the below statement and use it.

        But before submission, you must remove the freopen function or rewrite comment symbols(//).

      */

        freopen("sample_input.txt", "r", stdin);

 

     /*

        If you remove the statement below, your program's output may not be rocorded

        when your program is terminated after the time limit.

        For safety, please use setbuf(stdout, NULL); statement.

      */

     setbuf(stdout, NULL);

 

     scanf("%d", &T);

     for(test_case = 0; test_case < T; test_case++)

     {

         int i ,j ;

         //total = 0 ;

         Max_Jewes = -1 ;

        

         scanf("%d",&N);

         for(i=0;i<N;i++)

         {

              for(j=0;j<N;j++)

              {

                   scanf("%d",&Array[i][j]);

                   Path[i][j] = Array[i][j];

              }

         }

 

         for(i=0;i<N;i++)

         {

              for(j=0;j<N;j++)

              {

                   Visited[i][j] = false ;////初始化遍历标志

              }

         }

 

        

         Visit(0 , 0, 0);

        

         printf("Case #%d\n", test_case+1);

         //printf("%d\n", Answer);

        

         for(i=0;i<N;i++)

         {

              for(j=0;j<N;j++)

              {

                   printf("%d ",Answer[i][j]);

              }

              printf("\n");

         }       

         printf("%d\n", Max_Jewes);

        

         /////////////////////////////////////////////////////////////////////////////////////////////

         /*

            Implement your algorithm here.

            The answer to the case will be stored in variable Answer.

          */

         /////////////////////////////////////////////////////////////////////////////////////////////

         //Answer = 0;

 

         // Print the answer to standard output(screen).

         //printf("Case #%d\n", test_case+1);

         //printf("%d\n", Answer);

     }

 

     return 0;//Your program should return 0 on normal termination.

}

 

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 1698 Just a Hook （线段树区间修改）
题目链接：HDU 1698 Just a Hook



【题目大意】
在Dota里面有个角色叫屠夫，他的武器是 Meat Hook，对所有的英雄都有着致命的威胁， Meat Hook 由一系列连续金属构成（假设有N块金属），金属有 铜 ，银 ，金 三种，分别对应价值 1 2 3。


开始的时候 Meat Hook 都是由 铜 构成，（也就是每一节金属价值都是 1，总价值为N*1），现在我们给出一些操作，让给定区间的 Meat Hook 改变金属等级 ，求出最终整个 Meat Hook的价值；


【样例输入】

1   //1组数据
10 // 10块金属
2   //2组操作
1 5 2  //1 到 5块金属的价值全部变成2
5 9 3  //5 到 3块金属的价值全部变成3


【样例输出】


Case 1: The total value of the hook is 24.





第一次没看模板敲出来的线段树区间修改，贴个代码；
sum记录子节点的和，
val记录当前节点的值 ，看了下以前敲定模板， 也可以不用val ，直接在setv中储存也行；
熟悉了pushdown的写法


【源代码】
#include <iostream>
#include <cstdio>
#define L(m) m<<1
#define R(m) m<<1|1
using namespace std;
const int maxn  =100000+10;
struct node{
	int l,r,sum,val; 
	int setv; //懒惰标记
}tree[maxn<<2];
void pushup(int m){
	tree[m].sum = tree[L(m)].sum + tree[R(m)].sum;
	tree[m].val = tree[L(m)].val;
}
void pushdown(int m){
	if(tree[m].setv){
		tree[L(m)].val = tree[R(m)].val = tree[m].val;
		tree[L(m)].sum = (tree[L(m)].r-tree[L(m)].l+1)*tree[m].val; //这句不要漏了， 子节点的和也要在这里更新
		tree[R(m)].sum = (tree[R(m)].r-tree[R(m)].l+1)*tree[m].val;
		tree[L(m)].setv = tree[R(m)].setv = 1;
		tree[m].setv = 0;
	}
}
void Update(int m,int l,int r,int x){
	if(tree[m].l >=l && tree[m].r <=r){
		tree[m].setv = 1;
		tree[m].val = x;
		tree[m].sum = (tree[m].r - tree[m].l + 1) *x;
		return ;
	}
	pushdown(m);
	int mid = (tree[m].l + tree[m].r)>>1; //注意这里
	if(mid>=r)
		Update(L(m),l,r,x);
	else if(mid<l)
		Update(R(m),l,r,x);
	else{
		Update(L(m),l,mid,x);
		Update(R(m),mid+1,r,x);
	}
	pushup(m); //回溯
}
void Build(int m,int l,int r){
	tree[m].l = l,tree[m].r = r;
	if(l == r){
		tree[m].setv=0; //初始化
		tree[m].sum=1;
		tree[m].val=1;
		return ;
	}
	int mid = (l + r)>>1;
	Build(L(m),l,mid);
	Build(R(m),mid+1,r);
	pushup(m);
}
int main(){
	int T,n,p;
	scanf("%d",&T);
	for(int i=1;i<=T;i++){
		scanf("%d%d",&n,&p);
		Build(1,1,n);
		int a,b,c;
		while(p--){
			scanf("%d%d%d",&a,&b,&c);
			Update(1,a,b,c);
		}
		printf("Case %d: The total value of the hook is %d.\n",i,tree[1].sum); //以为求得是全部的和，所以直接输出根节点的sum
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

[LeetCode] Edit Distance

Edit Distance


Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)

You have the following 3 operations permitted on a word:

a) Insert a character
b) Delete a character
c) Replace a character
解题思路：
这道题计算两个文本的编辑距离。用动态规划的思想做。d[i][j]表示从字符串a(0..i)变换成b(0...j)的最小变换次数。则有：


class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length();
        int n = word2.length();
        if(m == 0 || n == 0){
            return max(m, n);
        }
        vector<vector<int>> d(m + 1, vector<int>(n + 1, 0));
        for(int i = 0; i<=n; i++){
            d[0][i] = i;
        }
        for(int i=0; i<=m; i++){
            d[i][0] = i;
        }
        for(int i = 1; i<=m; i++){
            for(int j = 1; j<=n; j++){
                if(word1[i-1] == word2[j-1]){
                    d[i][j] = d[i-1][j-1];
                }else{
                    d[i][j] = min( min(d[i][j-1], d[i-1][j]), d[i-1][j-1] ) + 1;
                }
            }
        }
        return d[m][n];
    }
};上述代码的时间复杂度和空间复杂度均为O(n^2)。可以将代码改成O(n)的空间复杂度。
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length();
        int n = word2.length();
        if(m == 0 || n == 0){
            return max(m, n);
        }
        vector<int> d(n + 1, 0);
        for(int i = 0; i<=n; i++){
            d[i] = i;
        }
        for(int i = 1; i<=m; i++){
            int left = i;
            int leftUp = i - 1;
            for(int j = 1; j<=n; j++){
                int up = d[j];
                int newVal;
                if(word1[i-1] == word2[j-1]){
                    newVal = leftUp;
                }else{
                    newVal = min(min(left, up), leftUp) + 1;
                }
                leftUp = d[j];
                d[j] = newVal;
                left = d[j];
            }
        }
        return d[n];
    }
};


版权声明：本文为博主原创文章，未经博主允许不得转载。

找新朋友
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 9372    Accepted Submission(s): 4963


Problem Description
新年快到了，“猪头帮协会”准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。
 

Input
第一行是测试数据的组数CN（Case number，1<CN<10000），接着有CN行正整数N（1<n<32768），表示会员人数。
 

Output
对于每一个N，输出一行新朋友的人数，这样共有CN行输出。

 

Sample Input

2
25608
24027

 

Sample Output

7680
16016
本题考查欧拉函数的知识：欧拉函数的定义:    在数论中，对于正整数N,少于或等于N ([1,N]),且与N互质的正整数(包括1)的个数，记作φ(n)。     φ函数的值：    φ(x)=x(1-1/p(1))(1-1/p(2))(1-1/p(3))(1-1/p(4))…..(1-1/p(n))其中p(1),p(2)…p(n)为x的所有质因数;x是正整数; φ(1)=1(唯一和1互质的数，且小于等于1)。注意：每种质因数只有一个。     例如:         φ(10)=10×(1-1/2)×(1-1/5)=4;         1 3 7 9          φ(30)=30×(1-1/2)×(1-1/3)×(1-1/5)=8;         φ(49)=49×(1-1/7)=42;

#include<stdio.h>
#include<math.h>
int Euler(int n)
{
    int ret=n;
    for(int i=2;i<=sqrt(n);i++)
     if(n%i==0)
      {
        ret=ret/i*(i-1);//先进行除法防止溢出(ret=ret*(1-1/p(i))) 
        while(n%i==0)
          n/=i;
     }
    if(n>1)
          ret=ret/n*(n-1);
        return ret;
}
int main()
{
	int n,m;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&m);
		int t=Euler(m);
		printf("%d\n",t);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

【bzoj1968】【Ahoi2005】【COMMON 约数研究】【循环】
Description


Input

只有一行一个整数 N（0 < N < 1000000）。
Output

只有一行输出，为整数M，即f(1)到f(N)的累加和。
Sample Input

3

Sample Output

5

题解：直接枚举每个因子，计算一下会有多少个数含有它，累加进答案即可。。

#include<iostream>
#include<cstdio>
using namespace std;
int n,ans;
int main()
{
   scanf("%d",&n);
   for (int i=1;i<=n;i++) ans+=n/i;
   cout<<ans;	
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

codeforces 343C Read Time  二分 + 贪心
http://codeforces.com/problemset/problem/343/C 
题意： 
有一些磁头，给出了起始的位置，给出了一些磁盘中需要访问的地点。求这些磁头移动的最小的次数。 
思路： 
二分找出满足要求的最小的时间，对于当前尝试的时间进行贪心判断是否可用。对于贪心，因为每一个磁头都需要读到还没有人读过的最左边的地方。如果这个都不能满足，那么这个时间是不可以的。 
在这基础上，对于同样的这么多时间，尽可能的让这个磁头读到能读到的最右边，这样就可以将还没有读过的地方尽可能的往右推。 
如果这样最后能够将所有读取完，那么这个时间是可以的。 
确定能读到的最右边（当然首先要保证读到还未读过的最左边，这是前提。），同样的时间，两种行走的方式，1）先向左走，后向右走。能向右走t−2∗(h[i]−p[step])t - 2*(h[i]-p[step])的距离。2）先向右走，后想左走。能向右走(t−(h[i]−p[step])/2(t - (h[i]-p[step])/2的距离。选择一个最大的。 
再更新尚未访问的最左边的位置。 
总结： 
类似最大化最小值，最小化最大值的题目做了有几道了，但是感觉还是没有什么感觉，经常就想不到，对于直接二分答案这种思想还会不够敏感吧。 
总结一下这些最大化最小值等这类问题吧。 
首先要寻找的这个答案是在一个确定的范围里，超过多少或小于多少就不能作为答案，题目往往要求的是这个答案的最大值，或者最小值， 就要最大化或者最小化这个答案。要找的这个就肯定是在边界附近，对于这题来说就是再小一点的时间就不可以满足了。 
对于这样就要想到二分找答案的方法，因为这个就是一个连续单调的，在一个点将满足与不满足的分开。 
这样的题还有一个地方就是需要构造出一个判断当前找的这个答案是否满足条件的方法，需要快速的判断这个是否可以满足。这题里面运用的就是贪心。
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define M 100009
typedef long long ll;
int n,m;
ll h[M],p[M];
bool judge(ll t)
{
    int step = 0; //表示最左边未读取过的点
    for(int i = 0;i < n;i++)
    {
        if(step >= m) break;
        if(h[i] - p[step] > t) return false;  //走不到最左边
        ll s = h[i];
        if(h[i] < p[step]) //当前磁头已经在要读的最左的地方的右边。
            s = h[i] + t;
        else
        {
            s = max(s,h[i]+t-2*(h[i]-p[step])); //先左走后右走
            s = max(s,h[i]+(t-(h[i]-p[step]))/2); //先右走后左走
        }
        while(step < m && p[step] <= s) step++; //更新最左边未读取的
    }
    if(step < m) return false;
    return true;
}
int main()
{
    while(scanf("%d %d",&n,&m) == 2)
    {
        for(int i = 0;i < n;i++)
            scanf("%I64d",&h[i]);
        for(int i = 0;i < m;i++)
            scanf("%I64d",&p[i]);
        ll low = -1,high = -1;
        if(h[0] < p[0]) //确定high的上限
            high = p[m-1] - h[0];
        else
        {
            high = max((h[0]-p[0])*2+p[m-1]-h[0],(p[m-1]-h[0])*2+h[0]-p[0]);
        }
        while(high - low > 1) //找出最小值，边界的判定要小心
        {
            ll mid = (high+low) >> 1;
            if(judge(mid)) high = mid; //满足缩小上限
            else low = mid;
        }
        printf("%I64d\n",high);
    }
    return 0;
}



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

python中的时间和日期

1. python中的datetime是处理时间和日期的标准库
  
获取当前时间： >>> from datetime import datetime
                             >>> now_time=datetime.now()
                            >>> print(now_time)
                            2015-08-26 09:55:24.042232
                            >>> type(now_time)
                           <class 'datetime.datetime'>
  说明：第二行中的datetime是datetime库中的类，所以now_time的类型是datetime.datetime日期类型


2. python中的所有类型有：字符串，布尔类型，整数，浮点数，数字，列表，元组，字典，日期


3. 获取指定日期，因为datetime模块中有一个datetime类，所以我们可以制定一个实例来获取某个具体时间

举例：>>> from datetime import datetime
            >>> a=datetime(2015,01,06,12,12,12)
            SyntaxError: invalid token
             >>> a=datetime(2015,1,06,12,12,12)
            SyntaxError: invalid token
            >>> a=datetime(2015,1,6,12,12,12)
            >>> a
           datetime.datetime(2015, 1, 6, 12, 12, 12)
           >>> print(a)
           2015-01-06 12:12:12
说明：datetime类来创建实例的时候，初始化的值如果是单数的话不需要在前面加0


4. datetime转换为timestamp，实际上在计算机中，存储的日期并不是我们所看到的年月日，而是将年月日转换为浮点型数字进行存储的

举例：  >>> a=datetime(1993,1,6,12,12,12)
              >>> a.timestamp()
              726293532.0
 注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数


5. timestamp转换为datetime,datetime类提供了一个fromtimestamp函数，调用这个函数可以将浮点型数值转换为datetime日期类型

举例：  >>> a=726293532.0
             >>> datetime.fromtimestamp(a)
             datetime.datetime(1993, 1, 6, 12, 12, 12)
             >>> print(datetime.fromtimestamp(a))
             1993-01-06 12:12:12


6. str转换为datetime,转换方法是通过datetime.strptime()实现

举例： >>> a=datetime.strptime('1993-1-6 12:12:12','%Y-%m-%d %H:%M:%S')
             >>> print(a)
             1993-01-06 12:12:12
 注意：字符串'%Y-%m-%d %H:%M:%S'规定了日期和时间部分的格式，时分秒必须全部大写，年月日其中年必须大写，月日必须小写


7. datetime的加减，是可以直接进行加减的，但必须引入timedelta（）类

举例： >>> from datetime import timedelta
             >>> a+timedelta(days=3,hours=4)
             datetime.datetime(2015, 8, 29, 15, 11, 46, 774470)


8. 时间差

举例： >>> a=datetime.now()
             >>> b=a+timedelta(days=3,hours=4)
             >>> (b-a).days
                     3
             >>> (b-a).seconds
                14400
             >>> (b-a).hours


9. datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间,如果要存储datetime，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。
 
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

C++数组和函数中的指针


一、指针与数组

1、数组：数组是一段连续的空间，数组名表示空间第一个元素的地址。

2、指针：指针包含两个内容，一个是内存地址，这个大小和机器长度有关；另一个是指针类型，这个跟指针定义的类型有关。


int arr[2][3] = { { 1, 2, 3 }, { 4, 5, 6 } };

int (*p1)[3] = arr;

int (*p2)[2][3] = &arr;

int * p3 = (int *)(arr + 1); // p3[0]=4

int * p4 = (int *)(&arr + 1); // p4[-1]=6


    arr是一个int(*)[3]类型，&arr是一个int(*)[2][3]类型(返回指针类型为整个数组)，两者指向的地址相同。数组指针可以强制转化为指针类型(指向地址不变，只是修改了指针类型)。

上例可以看出数组名实质上也是指针，储存的地址是数组第一个元素，指针类型是除过第一维的数组指针。


arr[1]执行过程：arr[1]=*(arr+1)


二、数组指针和指针数组

1、数组指针：指向数组的指针。首先来说数组指针也是指针，只不过指针的类型是数组。例如int (*p)[3]，其中()优先级大于[]，表述指向一个1*3的数组指针。


int a[3] = { 1, 2, 3 };

int(*ptr)[3] = &a;

cout << ptr[0][2] << endl;

int * p=*ptr;

cout << p[2] << endl;

这里首先要注意第2行语句，对数组a取址，因为a本身是一个int*，而不是int (*p)[3]，然后需要注意的就是第三行ptr[0]代表的是&a整体的地址(同理ptr+1，表示a后面sizeof(a)空间的首地址)，所以访问a中第3个元素的时候需要ptr[0][2]。

2、指针数组：首先来说指针数组是一个数组，数组里面的每个元素是一个指针。例如int *ptr[3]，其中[]优先级大于*。


int *ptr[2];

int a[3] = { 1, 2, 3 };

int x = 5;

ptr[0] = &x;

ptr[1] = &a[2];

cout << *ptr[0] << endl;

cout << *(ptr[1]-1) << endl;


三、指针与函数

1、函数指针：可以指向函数的指针，实质是指向函数所在的内存区域


int add(int a, int b)
{

return a + b;

}


void main()

{

int(*p)(int, int);

p = add;

printf("%d\n", p(1,2));

}


2、指针型函数

函数的返回值是一个指针，这里需要注意返回的指针初始化的时候最好使用new分类内存空间，否则容易出现返回的指针指向的内存空间被释放问题。


四、总结：

1、数组名表示降第一维后的数组指针。

2、数组指针是一个指针，它指向一个数组。

3、指针数组是一个数组，它的元素是指针。

4、&a（a是一个数组）是整个数组a的地址。

5、指针数组可以强制转化为指针，其中地址不变，只改变指针类型

版权声明：本文为博主原创文章，未经博主允许不得转载。

Round A APAC Test 2016 Problem B. gCube


Problem B. gCube



This contest is open for practice. You can try every problem as many times as you like, though we won't keep track of which problems you solve. Read the Quick-Start
 Guide to get started.




Small input
8 points




Solve B-small






Large input
16 points




Solve B-large







Problem
Googlers are very interested in cubes, but they are bored with normal three-dimensional cubes and also want to think about other kinds of cubes! A "D-dimensional cube" has D dimensions, all of equal length. (D may be any positive integer; for example, a
 1-dimensional cube is a line segment, and a 2-dimensional cube is a square, and a 4-dimensional cube is a hypercube.) A "D-dimensional cuboid" has D dimensions, but they might not all have the same lengths.
Suppose we have an N-dimensional cuboid. The N dimensions are numbered in order (0, 1, 2, ..., N - 1), and each dimension has a certain length. We want to solve many subproblems of this type:
1. Take all consecutive dimensions between the Li-th dimension and Ri-th dimension, inclusive.

2. Use those dimensions to form a D-dimensional cuboid, where D = Ri - Li + 1. (For example, if Li = 3 and Ri = 6, we would form a 4-dimensional
 cuboid using the 3rd, 4th, 5th, and 6th dimensions of our N-dimensional cuboid.)

3. Reshape it into a D-dimensional cube that has exactly the same volume as that D-dimensional cuboid, and find the edge length of that cube.

Each test case will have M subproblems like this, all of which use the same original N-dimensional cuboid.
Input
The first line of the input gives the number of test cases, T. T test cases follow.
Each test case begins with two integers N and M; N is the number of dimensions and Mis the number of queries. Then there is one line with N positive integers ai,
 which are the lengths of the dimensions, in order. Then, M lines follow. In the ith line, there are two integers Li and Ri, which give the range of dimensions to use for the ith subproblem.
Output
For each test case, output one line containing "Case #x:", where x is the test case number (starting from 1). After that, output M lines, where the ith line has the edge length for the ith subproblem. An edge length will be considered correct
 if it is within an absolute error of 10-6 of the correct answer. See the FAQ for an explanation of what that means,
 and what formats of real numbers we accept.
Limits
1 ≤ T ≤ 100.
1 ≤ ai ≤ 109. 
0 ≤ Li ≤ Ri < N.
Small dataset
1 ≤ N ≤ 10.
1 ≤ M ≤ 10.

Large dataset
1 ≤ N ≤ 1000.
1 ≤ M ≤ 100.

Sample






Input 
 


Output 
 



2
2 2
1 4
0 0
0 1
3 2
1 2 3
0 1
1 2





Case #1:
1.000000000
2.000000000
Case #2:
1.414213562
2.449489743











题意，其实就是很l r区间的数乘积开根号就可以了。

#define N 1005
#define M 100005
#define maxn 205
#define MOD 1000000000000000007
int n,T,m,pri[N],s,e,d;
int main()
{
    freopen("B-large.in", "r", stdin);
    freopen("B-large.out", "w", stdout);
     while(S(T)!=EOF)
    {
        For(ta,1,T+1){
            printf("Case #%d:\n",ta);
            S2(n,m);
            FI(n) S(pri[i]);
            FI(m){
                S2(s,e);
                double ans = 1.0;
                d = e - s + 1;
                For(i,s,e + 1){
                    ans *=  pow( (double)pri[i],1.0/(double)d);
                }
                printf("%.9f\n",ans);
            }
        }

    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

python3爬虫 - 利用浏览器cookie登录
http://blog.csdn.net/pipisorry/article/details/47980653
爬虫爬网站不免遇到需要登录的问题. 登录的时候可能还会碰到需要填验证码的问题, 有的验证码甚至是拖动拼图来完成的. 虽然现在这些都有开源解决方案, 但是假设现在主要的精力想要放在如何解析html, 或者验证抓取算法上, 而不是通过登录验证上, 那么开源解决方案并不是最好的解决方案.更好的方案是获取浏览器的 Cookies, 然后让 requests 这个库来直接使用登录好的 Cookies. 
获取 Chrome 浏览器的 Cookies 信息的函数
程序在 Windows 下调试通过, 因为 C 盘需要特殊权限来读写文件, 因此程序先将 Cookies 数据库文件拷贝到当前目录. 
<pre style="background-color:#272822;color:#f8f8f2;font-family:'SimSun';font-size:10.5pt;"><span style="color:#66d9ef;"><em>import </em></span>subprocess
<span style="color:#66d9ef;"><em>import </em></span>sqlite3
<span style="color:#66d9ef;"><em>import </em></span>win32crypt

SOUR_COOKIE_FILENAME <span style="color:#f92672;">= </span><span style="color:#e6db74;">r'C:\Users\pi\AppData\Local\Google\Chrome\User Data\Default\Cookies'
</span>DIST_COOKIE_FILENAME <span style="color:#f92672;">= </span><span style="color:#e6db74;">'.\python-chrome-cookies'
</span><span style="color:#e6db74;">
</span><span style="color:#e6db74;">
</span><span style="color:#66d9ef;"><em>def </em></span><span style="color:#a6e22e;">get_chrome_cookies</span>(<span style="color:#fd971f;"><em>url</em></span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">    </span>subprocess.call([<span style="color:#e6db74;">'copy'</span>, SOUR_COOKIE_FILENAME, DIST_COOKIE_FILENAME], <span style="color:#fd971f;"><em>shell</em></span><span style="color:#f92672;">=</span><span style="color:#66d9ef;"><em>True</em></span>)
    conn <span style="color:#f92672;">= </span>sqlite3.connect(<span style="color:#e6db74;">".\python-chrome-cookies"</span>)
    ret_dict <span style="color:#f92672;">= </span>{}
    <span style="color:#66d9ef;"><em>for </em></span>row <span style="color:#66d9ef;"><em>in </em></span>conn.execute(<span style="color:#e6db74;">"SELECT host_key, name, path, value, encrypted_value FROM cookies"</span>)<span style="color:#f92672;">:
</span><span style="color:#f92672;">        </span><span style="color:#66d9ef;"><em>if </em></span>row[<span style="color:#ae81ff;">0</span>] <span style="color:#66d9ef;"><em>not in </em></span><span style="color:#fd971f;"><em>url</em></span><span style="color:#f92672;">:  </span><span style="color:#75715e;"># if row[0] != url:
</span><span style="color:#75715e;">            </span><span style="color:#66d9ef;"><em>continue
</em></span><span style="color:#66d9ef;"><em>        </em></span><span style="color:#66d9ef;">print</span>(row[<span style="color:#ae81ff;">0</span>])
        ret <span style="color:#f92672;">= </span>win32crypt.CryptUnprotectData(row[<span style="color:#ae81ff;">4</span>], <span style="color:#66d9ef;"><em>None</em></span>, <span style="color:#66d9ef;"><em>None</em></span>, <span style="color:#66d9ef;"><em>None</em></span>, <span style="color:#ae81ff;">0</span>)
        ret_dict[row[<span style="color:#ae81ff;">1</span>]] <span style="color:#f92672;">= </span>ret[<span style="color:#ae81ff;">1</span>].decode()
    conn.close()
    subprocess.call([<span style="color:#e6db74;">'del'</span>, <span style="color:#e6db74;">'.\python-chrome-cookies'</span>], <span style="color:#fd971f;"><em>shell</em></span><span style="color:#f92672;">=</span><span style="color:#66d9ef;"><em>True</em></span>)
    <span style="color:#66d9ef;"><em>return </em></span>ret_dict

DOMAIN_NAME <span style="color:#f92672;">= </span><span style="color:#e6db74;">'.jobbole.com'
</span>ret_dict <span style="color:#f92672;">= </span>get_chrome_cookies(DOMAIN_NAME)
<span style="color:#66d9ef;">print</span>(ret_dict)



使用方法: x = requests.get(url, cookies = get_chrome_cookies(domain))
登录知乎: x = requests.get("http://www.zhihu.com, cookies=get_chrome_cookies(".zhihu.com"))

Note:
1. chrome浏览器加密后的密钥存储于%APPDATA%\..\Local\Google\Chrome\User Data\Default\Login Data"下的一个SQLite数据库中，可以通过Sqlite浏览器来查看一下登陆文件中的数据。密码是调用Windows API函数CryptProtectData来加密的。这意味着，只有用加密时使用的登陆证书，密码才能被恢复。而这根本不是问题，在用户登陆环境下执行解密就OK。SQLite数据库中password_value（是二进制数据，所以SQLite浏览器不能显示）。而破解密码，只需要调用Windows API中的CryptUnprotectData函数。[谷歌Chrome浏览器是如何存储密码的][浏览器是如何存储密码的]
2. Python为调用Windows API准备了一个完美的叫做pywin32的库。只有安装了pywin32才能调用win32crypt。
http://blog.csdn.net/pipisorry



获取 Chrome 浏览器的 Cookies 信息的的另一种方法
chrome > 更多工具 > javascript控制台 > 对应当前页面输入document.cookie。就可以得到当前网页的cookie相关内容，复制到代码中就可以使用了。
不过document.cookie 只能获取到 www.domain.com 的 cookies, 而不是 .domain.com 的。
Note:domain.com 是一级域名，www.domain.com 是域名 domain.com 的一个比较特殊的二级域名。他的特殊就在于现在的实践中，人们在解析域名的的时候，在惯例和默认的情况下，是把 www.domain.com 这个二级域名指向它的一级域名 domain.com。因此，现在的大部分情况下，domain.com 和 www.domain.com，都是一样的。 但是如果在解析域名的时候，没有做这样的设定，也可能就会有区别。
from:http://blog.csdn.net/pipisorry/article/details/47980653
ref:Python 爬虫解决登录问题的另类方法



版权声明：本文为博主http://blog.csdn.net/pipisorry原创文章，未经博主允许不得转载。

poj--1625Censored!+AC自动机上的dp+大数
题目链接：点击进入 
其实看起来是完全可以用矩阵做的，但是因为用到了大数的，导致内存开不下，所以用dp写了。其实dp的过程依旧就是在我们用禁止出现单词构建的trie上走m步的过程。我们定义dp[i][j]表示走过i步以后到达节点j的方案数，则状态转移应该是dp[i][j]=sum（dp[i-1][k]）,其中k表示可以走到j的节点，并且不能是病毒节点。但是其实这样代码就不是那么好写了，其实我们可以用节点j主动的去更新它的子节点k，这样转移方程就成了dp[i][next[j][k]]+=dp[i-1][j]。要求next[j][k]不能使病毒节点。总而言之，AC自动机上的dp就是要利用我们建立的trie树以及上面的转移方式进行状态转移。
代码如下：
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<map>
using namespace std;

///大数模版
struct BigInteger{
    int A[25];
    enum{MOD = 10000};
    BigInteger(){memset(A, 0, sizeof(A)); A[0]=1;}
    void set(int x){memset(A, 0, sizeof(A)); A[0]=1; A[1]=x;}
    void print(){
        printf("%d", A[A[0]]);
        for (int i=A[0]-1; i>0; i--){
            if (A[i]==0){printf("0000"); continue;}
            for (int k=10; k*A[i]<MOD; k*=10) printf("0");
            printf("%d", A[i]);
        }
        printf("\n");
    }
    int& operator [] (int p) {return A[p];}
    const int& operator [] (int p) const {return A[p];}
    BigInteger operator + (const BigInteger& B){
        BigInteger C;
        C[0]=max(A[0], B[0]);
        for (int i=1; i<=C[0]; i++)
            C[i]+=A[i]+B[i], C[i+1]+=C[i]/MOD, C[i]%=MOD;
        if (C[C[0]+1] > 0) C[0]++;
        return C;
    }
    BigInteger operator * (const BigInteger& B){
        BigInteger C;
        C[0]=A[0]+B[0];
        for (int i=1; i<=A[0]; i++)
            for (int j=1; j<=B[0]; j++){
                C[i+j-1]+=A[i]*B[j], C[i+j]+=C[i+j-1]/MOD, C[i+j-1]%=MOD;
            }
        if (C[C[0]] == 0) C[0]--;
        return C;
    }
}One;

const int maxn=10*10+5;
char alph[maxn];
map<char,int>h;

int getIndex(char ch)
{
     return h[ch];
}

struct Trie
{
    int next[maxn][maxn/2],fail[maxn],flag[maxn];
    int root,L,len;
    int newnode()
    {
        memset(next[L],-1,sizeof(next[L]));
        flag[L++];
        return L-1;
    }
    void init()
    {
        L=0;
        root=newnode();
    }
    void insert(char buf[])
    {
        int len1=strlen(buf);
        int now=root;
        for(int i=0;i<len1;i++)
        {
            int index=getIndex(buf[i]);
            if(next[now][index]==-1)
               next[now][index]=newnode();
            now=next[now][index];
        }
        flag[now]=1;
    }
    void build()
    {
        queue<int>Q;
        fail[root]=root;
        for(int i=0;i<len;i++)
        {
          if(next[root][i]==-1)
             next[root][i]=root;
          else
          {
              fail[next[root][i]]=root;
              Q.push(next[root][i]);
          }
        }
        while(!Q.empty())
        {
            int now=Q.front();
            if(flag[fail[now]])
               flag[now]++;
            Q.pop();
            for(int i=0;i<len;i++)
            {
                if(next[now][i]==-1)
                  next[now][i]=next[fail[now]][i];
                else
                {
                    fail[next[now][i]]=next[fail[now]][i];
                    //flag[next[now][i]]|=flag[next[fail[now]][i]];
                    Q.push(next[now][i]);
                }
            }
        }
    }
};


Trie ac;
char str[maxn];

BigInteger dp[maxn][maxn];

int main()
{
    int n,m,p;
    ///freopen("in.txt","r",stdin);
    One.set(1);
    while(scanf("%d%d%d",&n,&m,&p)!=EOF)
    {
        h.clear();
        scanf("%s",alph);
        for(int i=0;i<strlen(alph);i++)
           h[alph[i]]=i;
        ac.init();
        ac.len=strlen(alph);
        for(int i=0;i<p;i++)
        {
            scanf("%s",str);
            ac.insert(str);
        }
        ac.build();
        for(int i=0;i<=m;i++)
          for(int j=0;j<ac.L;j++)
             dp[i][j].set(0);
        dp[0][0].set(1);
        for(int i=1;i<=m;i++)
          for(int j=0;j<ac.L;j++)
            for(int k=0;k<n;k++)
            {
                if(ac.flag[ac.next[j][k]]) continue;
                dp[i][ac.next[j][k]]=dp[i][ac.next[j][k]]+dp[i-1][j];
            }
        BigInteger ans;
        ans.set(0);
        for(int i=0;i<ac.L;i++)
          ans=ans+dp[m][i];
        ans.print();
    }
  return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Java模拟公司置办货物系统（一）

采用MVC风格，将数据写入文件，模拟公司置办货物系统。 
A类表示普通员工，B类表示部门精力，C类表示采购部，D类表示资源管理部。
订单状态 1.表示申请状态 2.表示通过审批 3.表示未通过审批 4.表示订单完成，购物完成
第一步：首先创建Employeer类，代表员工类.


package com.jereh14;

public class Employeer implements java.io.Serializable{

    private String name;
    private int empNo;
    private String pwd;
    private String lev;

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getEmpNo() {
        return empNo;
    }
    public void setEmpNo(int empNo) {
        this.empNo = empNo;
    }
    public String getPwd() {
        return pwd;
    }
    public void setPwd(String pwd) {
        this.pwd = pwd;
    }
    public String getLev() {
        return lev;
    }
    public void setLev(String lev) {
        this.lev = lev;
    }
}

定义EmployeerBiz类，实现员工增删改查功能.


package com.jereh14;

import java.io.*;
import java.util.*;

public class EmployeerBiz {

    private List<Employeer> list = new ArrayList<Employeer>();

    public void addEmp(Employeer emp){

        readDb();
        list.add(emp);
        writeDb();
    }

    public void updateEmp(Employeer emp){

        readDb();
        Iterator<Employeer> i = list.iterator();
        while(i.hasNext()){
            Employeer e = i.next();
            if(e.getEmpNo()==emp.getEmpNo()){
                list.remove(e);
                list.add(emp);
            }
        }
        writeDb();
    }

    public void deleteEmp(int empNo){

        readDb();
        Iterator<Employeer> i = list.iterator();
        while(i.hasNext()){
            Employeer e = i.next();
            if(e.getEmpNo() == empNo){
                list.remove(e);
                break;
            }
        }
        writeDb();
    }

    public String searchPor(int userId,String pwd){
        readDb();
        String type = "";
        Iterator<Employeer> i = list.iterator();
        while(i.hasNext()){
            Employeer e = i.next();
            if(e.getEmpNo()==userId&&e.getPwd().equals(pwd)){
                type = e.getLev();
                break;
            }else{
                type = null;
            }
        }
        writeDb();
        return type;
    }

    public void showEmp(){

        readDb();
        Iterator<Employeer> i = list.iterator();
        while(i.hasNext()){
            Employeer e = i.next();
            System.out.println("\t"+e.getEmpNo()+"\t"+e.getName()+"\t"+e.getPwd()+"\t"+e.getLev());
        }
        writeDb();
    }

    public boolean check(int upEmpNo){

        Iterator<Employeer> i = list.iterator();
        boolean bool = false;
        while(i.hasNext()){
            Employeer e = i.next();
            if(e.getEmpNo() == upEmpNo){
                bool = true;
                break;
            }else{
                bool = false;
            }
        }
        return bool;
    }

    public void readDb(){

        FileInputStream fis  = null;
        ObjectInputStream is = null;
        InputStreamReader isr = null;
        BufferedReader bis = null;
        try {
            fis = new FileInputStream("F:\\test\\Employeer.txt");
            is = new ObjectInputStream(fis);
            list = (List<Employeer>) is.readObject();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }

    public void writeDb(){
        FileOutputStream fos  = null;
        ObjectOutputStream os = null;
        try {
            fos = new FileOutputStream("F:\\test\\Employeer.txt");
            os  = new ObjectOutputStream(fos);
            os.writeObject(list);
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                os.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}

定义EmployeerView，用于与用户交互。


package com.jereh14;

import java.util.*;

public class EmployeerView {

    public void empView(){

        Scanner scn      = new Scanner(System.in);
        Employeer emp    = null;
        EmployeerBiz elb = new EmployeerBiz();

        System.out.println("===============欢迎来到雇员管理===============");

        while(true){
            System.out.println("\t\t1、添加雇员\n\t\t2、修改雇员\n\t\t3、删除雇员\n\t\t4、查看雇员\n\t\t5、退出系统");
            System.out.println("********************************************");
            System.out.print("请选择您的操作：");

            int chooseNum = scn.nextInt();
            switch(chooseNum){
            case 1:
                System.out.println("===================添加雇员==================");
                System.out.print("请输入雇员编号：");
                int empNo = scn.nextInt();
                System.out.print("请输入雇员姓名：");
                String name = scn.next();
                System.out.print("请输入登录密码：");
                String pwd = scn.next();
                System.out.print("请输入雇员类型：");
                String lev = scn.next();

                emp = new Employeer();
                emp.setEmpNo(empNo);
                emp.setName(name);
                emp.setPwd(pwd);
                emp.setLev(lev);

                elb.addEmp(emp);

                if(elb.check(empNo)){
                    System.out.println("--添加成功！--");
                }else{
                    System.out.println("--添加失败！--");
                }
                System.out.println("********************************************");
                break;
            case 2:
                System.out.println("===================修改雇员==================");
                System.out.print("请输入雇员编号：");
                int upEmpNo = scn.nextInt();
                if(elb.check(upEmpNo)){
                    System.out.print("请输入要修改的姓名：");
                    String upName = scn.next();
                    System.out.print("请输入要修改的密码：");
                    String upPwd = scn.next();
                    System.out.print("请输入要修改的类型：");
                    String upLev = scn.next();

                    emp = new Employeer();
                    emp.setEmpNo(upEmpNo);
                    emp.setName(upName);
                    emp.setPwd(upPwd);
                    emp.setLev(upLev);

                    elb.updateEmp(emp);

                    System.out.println("--修改成功！--");

                }else{
                    System.out.println("没有该雇员！");
                }
                System.out.println("********************************************");
                break;
            case 3:
                System.out.println("===================删除雇员==================");
                System.out.print("请输入雇员编号：");
                int delEmpNo = scn.nextInt();
                if(elb.check(delEmpNo)){
                    elb.deleteEmp(delEmpNo);
                    System.out.println("--删除成功！--");
                }else{
                    System.out.println("没有该雇员！");
                }
                System.out.println("********************************************");
                break;
            case 4:
                System.out.println("===================查看雇员==================");
                System.out.println("\t编号\t姓名\t密码\t类型");
                elb.showEmp();
                System.out.println("********************************************");
                break;
            case 5:
                System.out.println("谢谢您的使用！");
                System.exit(0);
                break;
            }
        }
    }
}
运行效果图： 
 
第二步：创建Por类代表订单类。


package com.jereh14;

public class Por implements java.io.Serializable{

    public int getPor_no() {
        return por_no;
    }
    public void setPor_no(int por_no) {
        this.por_no = por_no;
    }
    public String getPart_desc() {
        return part_desc;
    }
    public void setPart_desc(String part_desc) {
        this.part_desc = part_desc;
    }
    public String getPart_type() {
        return part_type;
    }
    public void setPart_type(String part_type) {
        this.part_type = part_type;
    }
    public int getCount() {
        return count;
    }
    public void setCount(int count) {
        this.count = count;
    }
    public String getPart_use() {
        return part_use;
    }
    public void setPart_use(String part_use) {
        this.part_use = part_use;
    }
    public String getPnd() {
        return pnd;
    }
    public void setPnd(String pnd) {
        this.pnd = pnd;
    }
    public String getRgdt() {
        return rgdt;
    }
    public void setRgdt(String rgdt) {
        this.rgdt = rgdt;
    }
    public int getStus() {
        return stus;
    }
    public void setStus(int stus) {
        this.stus = stus;
    }
    public String getRgdt_emp() {
        return rgdt_emp;
    }
    public void setRgdt_emp(String rgdt_emp) {
        this.rgdt_emp = rgdt_emp;
    }
    public String getCf_date() {
        return cf_date;
    }
    public void setCf_date(String cf_date) {
        this.cf_date = cf_date;
    }
    public String getCf_emp() {
        return cf_emp;
    }
    public void setCf_emp(String cf_emp) {
        this.cf_emp = cf_emp;
    }
    private int por_no;
    private String part_desc;
    private String part_type;
    private int count;
    private String part_use;
    private String pnd;
    private String rgdt;
    private int stus;
    private String rgdt_emp;
    private String cf_date;
    private String cf_emp;
}

定义PorBiz类，实现订单的增删改查。


package com.jereh14;

import java.io.*;
import java.util.*;

public class PorBiz {

    private List<Por> list = new ArrayList<Por>();

    public void addPor(Por por){

        readDb();
        list.add(por);
        writeDb();
    }

    public void updatePor(Por por){

        readDb();
        Iterator<Por> i = list.iterator();
        while(i.hasNext()){
            Por p = i.next();
            if(p.getPor_no()==por.getPor_no()){
                list.remove(p);
                list.add(por);
            }
        }
        writeDb();
    }

    public boolean changeStuts(int porId,int chooseNum){
        readDb();
        boolean bool = false;
        Iterator<Por> i = list.iterator();
        while(i.hasNext()){
            Por p = i.next();
            if(p.getPor_no() == porId){
                if(chooseNum == 1){
                    p.setStus(2);
                }else if(chooseNum == 2){
                    p.setStus(3);
                }else {
                    p.setStus(4);
                }
                bool = true;
                break;
            }else{
                bool = false;
            }
        }
        writeDb();
        return bool;
    }

    public void deletePor(int del_por_no){
        readDb();
        Iterator<Por> i = list.iterator();
        while(i.hasNext()){
            Por p = i.next();
            if(p.getPor_no() == del_por_no){
                list.remove(p);
                break;
            }
        }
        writeDb();
    }


    //传入type,决定输入的订单类型,1表示全部输出,2表示只输出状态为1的订单.
    public void showPor(int type){

        readDb();
        Iterator<Por> i = list.iterator();
        if(type == 1){
            while(i.hasNext()){
                Por p = i.next();
                System.out.println(p.getPor_no()+"\t"+p.getPart_desc()+"\t"+p.getPart_type()+"\t"+p.getCount()+"\t"+
                        p.getPart_use()+"\t"+p.getPnd()+"\t"+p.getRgdt()+"\t"+p.getStus()+"\t"+p.getRgdt_emp()+"\t"+
                        p.getCf_date()+"\t"+p.getCf_emp());
            }
        }else if(type == 2){
            while(i.hasNext()){
                Por p = i.next();
                if(p.getStus()==1){
                System.out.println(p.getPor_no()+"\t"+p.getPart_desc()+"\t"+p.getPart_type()+"\t"+p.getCount()+"\t"+
                        p.getPart_use()+"\t"+p.getPnd()+"\t"+p.getRgdt()+"\t"+p.getStus()+"\t"+p.getRgdt_emp()+"\t"+
                        p.getCf_date()+"\t"+p.getCf_emp());
                }
            }
        }else{
            while(i.hasNext()){
                Por p = i.next();
                if(p.getStus()==2){
                System.out.println(p.getPor_no()+"\t"+p.getPart_desc()+"\t"+p.getPart_type()+"\t"+p.getCount()+"\t"+
                        p.getPart_use()+"\t"+p.getPnd()+"\t"+p.getRgdt()+"\t"+p.getStus()+"\t"+p.getRgdt_emp()+"\t"+
                        p.getCf_date()+"\t"+p.getCf_emp());
                }
            }
        }
        writeDb();
    }

    public boolean check(int por_no){
        Iterator<Por> i = list.iterator();
        boolean bool = false;
        while(i.hasNext()){
            Por p = i.next();
            if(p.getPor_no() == por_no){
                bool = true;
                break;
            }else{
                bool = false;
            }
        }
        return bool;
    }

    public Por getPor(int porId){

        Iterator<Por> i = list.iterator();
        while(i.hasNext()){
            Por p = i.next();
            if(p.getPor_no() == porId){
                return p;
            }else{
                p = null;
            }
        }
        return null;
    }

    public void readDb(){

        FileInputStream fis  = null;
        ObjectInputStream is = null;
        try {
            fis = new FileInputStream("F:\\test\\Por.txt");
            is = new ObjectInputStream(fis);
            list = (List<Por>) is.readObject();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                is.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

    }

    public void writeDb(){

        FileOutputStream fos  = null;
        ObjectOutputStream os = null;
        try {
            fos = new FileOutputStream("F:\\test\\Por.txt");
            os  = new ObjectOutputStream(fos);
            os.writeObject(list);
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            try {
                os.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
}

定义PorView类，用于与用户交互。


package com.jereh14;

import java.util.Scanner;

public class PorView {

    public void porView(){

        Scanner scn = new Scanner(System.in);
        Por por     = null;
        PorBiz pb   = new PorBiz();

        System.out.println("===============欢迎来到采购申请===============");

        while(true){
            System.out.println("\t\t1、添加申请\n\t\t2、修改申请\n\t\t3、删除申请\n\t\t4、查看申请\n\t\t5、退出系统");
            System.out.println("********************************************");
            System.out.print("请选择您的操作：");

            int chooseNum = scn.nextInt();
            switch(chooseNum){
            case 1:
                System.out.println("===================添加申请==================");
                System.out.print("请输入订单编号：");
                int por_no = scn.nextInt();
                System.out.print("请输入订单物品：");
                String part_desc = scn.next();
                System.out.print("请输入物品型号：");
                String part_type = scn.next();
                System.out.print("请输入物品数量：");
                int count = scn.nextInt();
                System.out.print("请输入物品用途：");
                String part_use = scn.next();
                System.out.print("请输入需要日期：");
                String pnd = scn.next();
                System.out.print("请输入申请日期：");
                String rgdt = scn.next();
                System.out.print("请输入订单状态：");
                int stus = scn.nextInt();
                System.out.print("请输入申请者：");
                String rgdt_emp = scn.next();
                System.out.print("请输入批准日期：");
                String cf_date = scn.next();
                System.out.print("请输入审核者：");
                String cf_emp = scn.next();

                por = new Por();
                por.setPor_no(por_no);
                por.setPart_desc(part_desc);
                por.setPart_type(part_type);
                por.setCount(count);
                por.setPart_use(part_use);
                por.setPnd(pnd);
                por.setRgdt(rgdt);
                por.setStus(stus);
                por.setRgdt_emp(rgdt_emp);
                por.setCf_date(cf_date);
                por.setCf_emp(cf_emp);

                pb.addPor(por);

                if(pb.check(por_no)){
                    System.out.println("--添加成功！--");
                }else{
                    System.out.println("--添加失败！--");
                }
                System.out.println("********************************************");
                break;
            case 2:
                System.out.println("===================修改申请==================");
                System.out.print("请输入申请编号：");
                int up_por_no = scn.nextInt();
                if(pb.check(up_por_no)){
                    System.out.print("请输入订单物品：");
                    String up_part_desc = scn.next();
                    System.out.print("请输入物品型号：");
                    String up_part_type = scn.next();
                    System.out.print("请输入物品数量：");
                    int up_count = scn.nextInt();
                    System.out.print("请输入物品用途：");
                    String up_part_use = scn.next();
                    System.out.print("请输入需要日期：");
                    String up_pnd = scn.next();
                    System.out.print("请输入申请日期：");
                    String up_rgdt = scn.next();
                    System.out.print("请输入订单状态：");
                    int up_stus = scn.nextInt();
                    System.out.print("请输入申请者：");
                    String up_rgdt_emp = scn.next();
                    System.out.print("请输入批准日期：");
                    String up_cf_date = scn.next();
                    System.out.print("请输入审核者：");
                    String up_cf_emp = scn.next();

                    por = new Por();
                    por.setPor_no(up_por_no);
                    por.setPart_desc(up_part_desc);
                    por.setPart_type(up_part_type);
                    por.setCount(up_count);
                    por.setPart_use(up_part_use);
                    por.setPnd(up_pnd);
                    por.setRgdt(up_rgdt_emp);
                    por.setStus(up_stus);
                    por.setRgdt_emp(up_rgdt_emp);
                    por.setCf_date(up_cf_date);
                    por.setCf_emp(up_cf_emp);

                    pb.updatePor(por);

                    System.out.println("--修改成功！--");

                }else{
                    System.out.println("--没有该申请！--");
                }
                System.out.println("********************************************");
                break;
            case 3:
                System.out.println("===================删除申请==================");
                System.out.print("请输入申请编号：");
                int del_por_no = scn.nextInt();
                if(pb.check(del_por_no)){
                    pb.deletePor(del_por_no);
                    System.out.println("--删除成功！--");
                }else{
                    System.out.println("--没有该申请！--");
                }
                System.out.println("********************************************");
                break;
            case 4:
                System.out.println("===================查看申请==========================================================\n");
                System.out.println("编号\t名称\t型号\t数量\t用途\t需要日期\t申请日期\t状态\t申请者\t批准日期\t审核者\n");
                pb.showPor(1);
                System.out.println("\n************************************************************************************");
                break;
            case 5:
                System.out.println("谢谢您的使用！");
                System.exit(0);
                break;
                default:
                    System.out.println("--输入有误！--");
                    break;
            }
        }
    }
}

运行效果图： 

定义PorCfView类，用于审批订单。


package com.jereh14;

import java.util.Scanner;

public class PorCfView {

    public void showInfoView(){

        Scanner scn = new Scanner(System.in);
        PorBiz pb   = new PorBiz();

        while(true){
            System.out.println("=======================================订单审批=======================================\n");
            System.out.println("编号\t名称\t型号\t数量\t用途\t需要日期\t申请日期\t状态\t申请者\t批准日期\t审核者\n");
            pb.showPor(2);
            System.out.println("\n******************************1、批准\t2、驳回\t3、退出*******************************");
            System.out.print("请选择您的操作：");
            int chooseNum = scn.nextInt();
            int porId = -1;
            switch(chooseNum){
            case 1:
                System.out.print("请输入您要操作的单号：");
                porId = scn.nextInt();
                if(pb.changeStuts(porId,1)){
                    System.out.println("--订单审批完成！--\n");
                }else{
                    System.out.println("--该订单不存在！--\n");
                }
                break;
            case 2:
                System.out.print("请输入您要操作的单号：");
                porId = scn.nextInt();
                if(pb.changeStuts(porId,2)){
                    System.out.println("--该订单被拒绝！--\n");
                }else{
                    System.out.println("--该订单不存在！--\n");
                }
                break;
            case 3:
                System.out.println("谢谢您的使用！");
                System.exit(0);
                break;
                default:
                    System.out.println("--输入有误！--");
                    break;
            }
        }
    }
}
运行效果图： 

下篇继续。


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ 5421 Victor and String 回文串自动机


如果没有操作1,就是裸的回文串自动机......


可以从头部插入字符的回文串自动机,维护两个last点就好了.....
当整个串都是回文串的时候把两个last统一一下


Victor and String
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 524288/262144 K (Java/Others)
Total Submission(s): 30    Accepted Submission(s): 9



Problem Description

Victor loves to play with string. He thinks a string is charming as the string is a palindromic string.

Victor wants to play n times.
 Each time he will do one of following four operations.

Operation 1 : add a char c to
 the beginning of the string.

Operation 2 : add a char c to
 the end of the string.

Operation 3 : ask the number of different charming substrings.

Operation 4 : ask the number of charming substrings, the same substrings which starts in different location has to be counted.

At the beginning, Victor has an empty string.

 


Input

The input contains several test cases, at most 5 cases.

In each case, the first line has one integer n means
 the number of operations.

The first number of next n line
 is the integer op,
 meaning the type of operation. If op=1 or 2,
 there will be a lowercase English letters followed.

1≤n≤100000.

 


Output

For each query operation(operation 3 or 4), print the correct answer.

 


Sample Input

6
1 a
1 b
2 a
2 c
3
4
8
1 a
2 a
2 a
1 a
3
1 b
3
4


 


Sample Output

4
5
4
5
11


 


Source

BestCoder Round #52 (div.1) ($)

 




/* ***********************************************
Author        :CKboss
Created Time  :2015年08月24日 星期一 10时32分04秒
File Name     :HDOJ5421.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;

const int maxn=200100;
const int C=30;

int L,R;
int nxt[maxn][C];
int fail[maxn];
LL cnt[maxn];
LL num[maxn];
int len[maxn];
int s[maxn];
int last[2],p,n;
LL tot;

int newnode(int x)
{
	for(int i=0;i<C;i++) nxt[p][i]=0;
	num[p]=0; len[p]=x;
	return p++;
}

void init()
{
	p=0;
	newnode(0); newnode(-1);

	memset(s,-1,sizeof(s));
	L=maxn/2; R=maxn/2-1;
	last[0]=last[1]=0;
	fail[0]=1;

	tot=0;
}

/// d=0 add preffix d=1 add suffix

int getfail(int d,int x)
{
	if(d==0) while(s[L+len[x]+1]!=s[L]) x=fail[x];
	else if(d==1) while(s[R-len[x]-1]!=s[R]) x=fail[x];
	return x;
}

void add(int d,int c)
{
	c-='a';
	if(d==0) s[--L]=c;
	else s[++R]=c;

	int cur=getfail(d,last[d]);

	if(!nxt[cur][c])
	{
		int now=newnode(len[cur]+2);
		fail[now]=nxt[getfail(d,fail[cur])][c];
		nxt[cur][c]=now;
		num[now]=num[fail[now]]+1;
	}
	last[d]=nxt[cur][c];
	if(len[last[d]]==R-L+1) last[d^1]=last[d];
	tot+=num[last[d]];
}

int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);

	int _;
	while(scanf("%d",&_)!=EOF)
	{
		init();
		while(_--)
		{
			int kind;
			char ch[5];
			scanf("%d",&kind);
			if(kind<=2)
			{
				kind--;
				scanf("%s",ch);
				add(kind,ch[0]);
			}
			else if(kind==3) printf("%d\n",p-2);
			else if(kind==4) printf("%lld\n",tot);
		}
	}
    
    return 0;
}





版权声明：来自: 码代码的猿猿的AC之路 http://blog.csdn.net/ck_boss 

【笔试】21、二维数组中的查找
/**
 *题目：在一个二位数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二位数组和一个整数，
 *		判断数组中是否含有该整数
 *时间：2015年8月25日09:51:08
 *文件：FindInMatrix.java
 *作者：cutter_point
 */
package bishi.Offer50.y2015.m08.d25;

public class FindInMatrix
{
	/**
	 * 在一个二维数组中寻找到我们要找的数
	 * @param matrix	二维数组
	 * @param rows		行
	 * @param columns	列
	 * @param key		我们要寻找的值
	 * @return
	 */
	public static boolean Find(int matrix[][], int rows, int columns, int key)
	{
		boolean found = false;	//用来判断是否找到
		//首先我们判断数组是否为空
		if(matrix == null || rows <= 0 || columns <= 0)
		{
			System.err.println("数据异常");
			return false;
		}
		
		//我们知道这是一个递增的数组，我们选这个矩阵的一个对角，比如左下角,作为起始基准进行遍历
		int row = rows - 1, col = 0;
		//当我们的数比这个数还大的时候，我们就可以判处当前的列，在右边寻找
		//当我们的数比这个数小的时候，我们就可以排除当前行，在上面寻找，这样不断逼近我们的值，
		while(row > -1 && col < columns)
		{
			if(matrix[row][col] < key)
			{
				//比寻找的数大
				++col;
			}//if
			else if(matrix[row][col] > key)
			{
				//比寻找的数小
				--row;
			}//else if
			else
			{
				found = true;
				break;	//找到了之后退出
			}//else 相等的时候
		}//while在二维数组内寻找
		
		return found;
	}
	
	public static void Test(int key)
	{
		int maxtrix[][] =
			{
				{1, 2, 8, 9},
				{2, 4, 9, 12},
				{4, 7, 10, 14},
				{8, 9, 12, 16}
			};
		
		int columns = maxtrix.length;
		int rows = maxtrix.clone().length;
		boolean find = Find(maxtrix, rows, columns, key);
		System.out.println(find);
	}
	
	public static void main(String[] args)
	{
		Test(998);
	}

}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Columbus’s bargain (hdu 3268 最短路)


Columbus’s bargain
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 1836    Accepted Submission(s): 467



Problem Description

On the evening of 3 August 1492, Christopher Columbus departed from Palos de la Frontera with a few ships, starting a serious of voyages of finding a new route to India. As you know, just in those voyages, Columbus discovered the America continent which he
 thought was India.

Because the ships are not large enough and there are seldom harbors in his route, Columbus had to buy food and other necessary things from savages. Gold coins were the most popular currency in the world at that time and savages also accept them. Columbus wanted
 to buy N kinds of goods from savages, and each kind of goods has a price in gold coins. Columbus brought enough glass beads with him, because he knew that for savages, a glass bead is as valuable as a gold coin. Columbus could buy an item he need only in four
 ways below:

1.  Pay the price all by gold coins.
2.  Pay by ONE glass bead and some gold coins. In this way, if an item’s price is k gold coins, Columbus could just pay k – 1 gold coins and one glass bead.
3.  Pay by an item which has the same price.
4.  Pay by a cheaper item and some gold coins. 

Columbus found out an interesting thing in the trade rule of savages: For some kinds of goods, when the buyer wanted to buy an item by paying a cheaper item and some gold coins, he didn’t have to pay the price difference, he can pay less. If one could buy an
 item of kind A by paying a cheaper item of kind B plus some gold coins less than the price difference between B and A, Columbus called that there was a “bargain” between kind B and kind A. To get an item, Columbus didn’t have to spend gold coins as many as
 its price because he could use glass beads or took full advantages of “bargains”. So Columbus wanted to know, for any kind of goods, at least how many gold coins he had to spend in order to get one – Columbus called it “actual price” of that kind of goods. 

Just for curiosity, Columbus also wanted to know, how many kinds of goods are there whose “actual price” was equal to the sum of “actual price” of other two kinds.


 


Input

There are several test cases. 
The first line in the input is an integer T indicating the number of test cases ( 0 < T <= 10).
For each test case:
The first line contains an integer N, meaning there are N kinds of goods ( 0 < N <= 20). These N kinds are numbered from 1 to N.

Then N lines follow, each contains two integers Q and P, meaning that the price of the goods of kind Q is P. ( 0 <Q <=N, 0 < P <= 30 )
The next line is a integer M( 0 < M <= 20 ), meaning there are M “bargains”. 

Then M lines follow, each contains three integers N1, N2 and R, meaning that you can get an item of kind N2 by paying an item of kind N1 plus R gold coins. It’s guaranteed that the goods of kind N1 is cheaper than the goods of kind N2 and R is none negative
 and less than the price difference between the goods of kind N2 and kind N1. Please note that R could be zero. 


 


Output

For each test case:
Please output N lines at first. Each line contains two integers n and p, meaning that the “actual price” of the goods of kind n is p gold coins. These N lines should be in the ascending order of kind No. . 

Then output a line containing an integer m, indicating that there are m kinds of goods whose “actual price” is equal to the sum of “actual price” of other two kinds.


 


Sample Input

1
4
1 4
2 9
3 5
4 13
2
1 2 3
3 4 6


 


Sample Output

1 3
2 6
3 4
4 10
1


 


Source

2009 Asia Ningbo Regional Contest Hosted by NIT

 


Recommend

lcy   |   We have carefully selected several similar problems for you:  3265 3264 3262 3269 3263 

 




题意：n个物品，每个物品价值为pi，可以用一个玻璃珠和pi-1个金币换的，也可以由其他便宜的物品加上一定量的金币换得，相同价格的物品可以互换。问每个物品通过这样交换若干次后最少要花的金币数是多少。并且有多少物品的actual price等于其他两个物品actual
 price之和，注意每个物品如果有多个组合形式也只算作一种。
代码：
#include <iostream>
#include <functional>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <string>
#include <map>
#include <stack>
#include <vector>
#include <set>
#include <queue>
#pragma comment (linker,"/STACK:102400000,102400000")
#define pi acos(-1.0)
#define eps 1e-6
#define lson rt<<1,l,mid
#define rson rt<<1|1,mid+1,r
#define FRE(i,a,b)  for(i = a; i <= b; i++)
#define FREE(i,a,b) for(i = a; i >= b; i--)
#define FRL(i,a,b)  for(i = a; i < b; i++)
#define FRLL(i,a,b) for(i = a; i > b; i--)
#define mem(t, v)   memset ((t) , v, sizeof(t))
#define sf(n)       scanf("%d", &n)
#define sff(a,b)    scanf("%d %d", &a, &b)
#define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c)
#define pf          printf
#define DBG         pf("Hi\n")
typedef long long ll;
using namespace std;

#define INF 0x3f3f3f3f
#define mod 1000000009
const int maxn = 1005;
const int MAXN = 2005;
const int MAXM = 200010;

typedef pair<int,int> P;

struct Edge
{
    int v,len,next;
}edge[MAXM];

int a[MAXN];
int head[MAXN],dist[MAXN];
int num,n,m;
int vis[MAXN];

void init()
{
    num=0;
    memset(head,-1,sizeof(head));
}

void addedge(int u,int v,int w)
{
    edge[num].v=v;
    edge[num].len=w;
    edge[num].next=head[u];
    head[u]=num++;
}

void Dijkstra()
{
    priority_queue<P,vector<P>,greater<P> >Q;
    memset(dist,INF,sizeof(dist));
    Q.push(P(0,0));
    dist[0]=0;
    while (!Q.empty())
    {
        P p=Q.top();
        Q.pop();
        int u=p.second;
        if (dist[u]<p.first) continue;
        for (int i=head[u];~i;i=edge[i].next)
        {
            int v=edge[i].v;
            if (dist[v]>dist[u]+edge[i].len)
            {
                dist[v]=dist[u]+edge[i].len;
                Q.push(P(dist[v],v));
            }
        }
    }
    for (int i=1;i<=n;i++)
        printf("%d %d\n",i,dist[i]);
    int ans=0;
    memset(vis,0,sizeof(vis));      //每种物品有多种组合方式也只算作一种，用vis来标记
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        {
            if (i==j) continue;
            for (int k=j+1;k<=n;k++)
            {
                if (i==k||j==k) continue;
                if (dist[i]==dist[j]+dist[k]&&!vis[i])
                {
                    ans++;
                    vis[i]=1;
                }
            }
        }
    }
    printf("%d\n",ans);
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("C:/Users/lyf/Desktop/IN.txt","r",stdin);
#endif
    int i,j,t,u,v,w;
    scanf("%d",&t);
    while (t--)
    {
        init();
        scanf("%d",&n);
        for (i=1;i<=n;i++)
        {
            scanf("%d%d",&u,&a[i]);
            a[i]--;
            addedge(0,u,a[i]);
        }
        for (i=1;i<=n;i++)
        {
            for (j=1;j<=n;j++)
            {
                if (a[i]==a[j])
                    addedge(i,j,0);
            }
        }
        scanf("%d",&m);
        while (m--)
        {
            scanf("%d%d%d",&u,&v,&w);
            addedge(u,v,w);
        }
        Dijkstra();
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

g++ 编译选项
g++ 编译参数详解

介绍
代码编译过程分为：

预处理，生成.i文件
编译，转换成汇编语言， 生成.s文件
将汇编代码转换成机器码，生成.o文件
链接目标代码，生成可执行程序

总体选项
-E
只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面.   
gcc -E hello.c > pianoapan.txt   
gcc -E hello.c | more   
慢慢看吧,一个hello word 生成的代码量都非常多

-S
只激活预处理和编译，就是指把文件编译成为汇编代码。 
例子用法   
gcc -S hello.c   
它将生成.s的汇编代码，你可以用文本编辑器察看     

-c
只激活预处理,编译,和汇编,也就是他只把程序做成obj文件   
gcc -c hello.c   
将生成.o的obj文件

目录选项
-I   dir
在你是用#include"file"的时候,gcc/g++会先在当前目录查找你所制定的头文件,如果没有找到,他回到缺省的头文件目录找,如果使用-I制定了目录,他会先在你所制定的目录查找,然后再按常规的顺序去找.   
对于#include,gcc/g++会到-I指定的目录查找,查找不到,然后将到系统的缺省的头文件目录查找    

-i
相当于“#include”包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以用它设定,功能就相当于在代码中使用#include 
gcc hello.c -include /root/pianopan.h   

-L     dir
编译的时候，搜索库的路径。比如你自己的库，可以用它指定目录，不然 
编译器将只在标准库的目录找。这个dir就是目录的名称。  

-l   library
指定编译的时候使用的库   
gcc -l  curses hello.c   
使用ncurses库编译程序   

调试选项
-g
指示编译器，在编译的时候，产生调试信息。   

-g   stabs
此选项以    stabs格式声称调试信息,但是不包括gdb调试信息.   

-g     stabs+
此选项以stabs格式声称调试信息,并且包含仅供gdb使用的额外调试信息.   

-g    gdb
此选项将尽可能的生成gdb的可以使用的调试信息.
-glevel
请求生成调试信息，同时用level指出需要多少信息，默认的level值是2
链接选项
-static
此选项将禁止使用动态库。
优点：程序运行不依赖于其他库
缺点：文件比较大

-shared (-G)
此选项将尽量使用动态库，为默认选项
优点：生成文件比较小
缺点：运行时需要系统提供动态库
-symbolic
建立共享目标文件的时候,把引用绑定到全局符号上.
对所有无法解析的引用作出警告(除非用连接编辑选项-Xlinker -z -Xlinker defs’`取代)。
注：只有部分系统支持该选项.
错误与告警选项
-Wall
一般使用该选项，允许发出GCC能够提供的所有有用的警告。也可以用-W{warning}来标记指定的警告。
-pedantic
 允许发出`ANSI/ISO C`标准所列出的所有警告

-pedantic-errors
允许发出ANSI/ISO C标准所列出的错误
-w error
把所有警告转换为错误，以在警告发生时中止编译过程
-w
关闭所有警告,建议不要使用此项
预处理选项
-Dmacro
相当于C语言中的#define macro 
-Dmacro=defn
相当于C语言中的#define macro=defn 
-Umacro
相当于C语言中的#undef macro 
-undef
取消对任何非标准宏的定义 
其他选项
-o
制定目标名称,缺省的时候,gcc 编译出来的文件是a.out,很难听,如果你和我有同感，改掉它,哈哈
gcc -o hello.exe hello.c (哦,windows用习惯了)   
gcc -o hello.asm -S hello.c   
-O0
-O1
-O2
-O3
编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高
-fpic
编译器就生成位置无关目标码.适用于共享库(shared library).
-fPIC
编译器就输出位置无关目标码.适用于动态连接(dynamic linking),即使分支需要大范围转移.
-v
显示详细的编译、汇编、连接命令
-pipe
使用管道代替编译中临时文件,在使用非gnu汇编工具的时候,可能有些问题   
gcc -pipe -o hello.exe hello.c   
-ansi
关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏,   
-fno-asm
此选项实现ansi选项的功能的一部分，它禁止将asm,inline和typeof用作关键字。   
-fno-strict-prototype
只对g++起作用,使用这个选项,g++将对不带参数的函数,都认为是没有显式的对参数的个数和类型说明,而不是没有参数.而gcc无论是否使用这个参数,都将对没有带参数的函数,认为城没有显式说明的类型   
-fthis-is-varialble
就是向传统c++看齐,可以使用this当一般变量使用.   
-fcond-mismatch
允许条件表达式的第二和第三参数类型不匹配,表达式的值将为void类型   
    -funsigned-char   
    -fno-signed-char   
    -fsigned-char   
    -fno-unsigned-char   
这四个参数是对char类型进行设置,决定将char类型设置成unsigned char(前两个参数)或者 signed char(后两个参数) 
-imacros file
将file文件的宏,扩展到gcc/g++的输入文件,宏定义本身并不出现在输入文件中       
-nostdinc
使编译器不再系统缺省的头文件目录里面找头文件,一般和-I联合使用,明确限定头文件的位置   
-nostdin C++
规定不在g++指定的标准路经中搜索,但仍在其他路径中搜索,.此选项在创建libg++库使用   
-C
在预处理的时候,不删除注释信息,一般和-E使用,有时候分析程序，用这个很方便的   
-M
生成文件关联的信息。包含目标文件所依赖的所有源代码你可以用gcc -M hello.c来测试一下，很简单。   
-MM
和上面的那个一样，但是它将忽略由#include造成的依赖关系。   
-MD
和-M相同，但是输出将导入到.d的文件里面   
-MMD
和-MM相同，但是输出将导入到.d的文件里面   
-Wa,option
此选项传递option给汇编程序;如果option中间有逗号,就将option分成多个选项,然后传递给会汇编程序   
-Wl.option
此选项传递option给连接程序;如果option中间有逗号,就将option分成多个选项,然后传递给会连接程序.
-x language filename
设定文件所使用的语言,使后缀名无效,对以后的多个有效.也就是根 
据约定C语言的后缀名称是.c的，而C++的后缀名是.C或者.cpp,如果 
你很个性，决定你的C代码文件的后缀名是.pig 哈哈，那你就要用这 
个参数,这个参数对他后面的文件名都起作用，除非到了下一个参数 
的使用。 
可以使用的参数吗有下面的这些 
c’,objective-c’, c-header’,c++’, cpp-output’, 
assembler’, and `assembler-with-cpp’. 
看到英文，应该可以理解的。   
gcc -x c hello.pig   
-x none filename
关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型   
gcc -x c hello.pig -x none hello2.c

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 2068 RPG的错排 错排
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <math.h>
#include <stdlib.h>
#include <time.h>
using namespace std;

typedef long long ll;

int main()
{
    int n,i,j,m;
    ll f[30],ans,tp;
    f[1]=0;f[2]=1;
    for(i=3;i<=25;i++)
        f[i]=(i-1)*(f[i-1]+f[i-2]);

    while(~scanf("%d",&n))
    {
        if(n==0) break;
        ans=1;
        if(n%2==0) m=n/2;
        else m=(n+1)/2;
        for(i=m;i<n;i++)
        {
            tp=1;
            for(j=i+1;j<=n;j++)
                tp*=j;
            for(j=1;j<=n-i;j++)
                tp/=j;
            ans+=tp*f[n-i];
        }
        printf("%lld\n",ans);
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。http://xiang578.top/

计数排序C＋＋实现
//counting sort
//计数排序基于一个假设，待排序数列的所有数均出现在（0，k）的区间之内，如果k过大则会引起较大的空间复杂度
//计数排序并非是一种基于比较的排序方法，它直接统计出键值本应该出现的位置
//时间复杂度为O（n），空间复杂度为O（n+k）
#include<iostream>
#include<vector>

using namespace std;

void countSort(vector<int>& vec,vector<int>& objVec)
{
	vector<int> range(10,0);//range的下标即键值
	for(int i=0;i<vec.size();++i)
	{//统计每个键值出现的次数
		range[vec[i]]++;
	}

	for(int i=1;i<vec.size();++i)
	{//后面的键值出现的位置为前面所有键值出现的次数之和
		range[i]+=range[i-1];
	}
	//至此，range中存放的是相应键值应该出现的位置
	int length=vec.size();
	for(int i=length-1;i>=0;--i)//注意一个小细节，统计时最正序的，这里是逆序
	{//如果存在相同的键值，为了保持稳定性，后出现的应该还是位于后面
		//如果正序，则先出现的会放置到后面，因此不再稳定
		objVec[range[vec[i]]]=vec[i];//将键值放到目标位置
		range[vec[i]]--;
	}
}


int main()
{
	int a[14]={0,5,7,9,6,3,4,5,2,8,6,9,2,1};
	vector<int> vec(a,a+14);
	vector<int> objVec(14,0);

	countSort(vec,objVec);

	for(int i=0;i<objVec.size();++i)
		cout<<objVec[i]<<"  ";
	cout<<endl;

	return 0;
}
		
Item 12：完整地拷贝对象（拷贝构造函数、复制运算符） Effective C++笔记

Item 12: Copy all parts of an object


在一个成熟的面向对象的C++系统中，只有两种拷贝对象的方式：复制构造函数和赋值运算符， 不妨称他们为拷贝函数。 拷贝函数属于编译器默认生成的函数（参考：Item
 5：那些被C++默默地声明和调用的函数）， 默认的拷贝函数确实会完整地拷贝对象，但有时我们选择重载拷贝函数，问题就出在这里！

一个正确拷贝函数的实现是这样的：

class Customer{
  string name;
public:
  Customer::Customer(const Customer& rhs): name(rhs.name){}
  Customer& Customer::operator=(const Customer& rhs){
    name = rhs.name;                     // copy rhs's data
    return *this;                        // see Item 10
  }  
};



很完美对吧？但是有一天你新添加了一个数据成员，但忘记了更新拷贝函数：

class Customer{
  string name;
  Date lastTransaction;
public:
  Customer::Customer(const Customer& rhs): name(rhs.name){}
  Customer& Customer::operator=(const Customer& rhs){
    name = rhs.name;                     // copy rhs's data
    return *this;                        // see Item 10
  }  
};



这时lastTransaction便被被你忽略了，编译器也不会给出任何警告（即使在最高警告级别）。
 另外一个常见的情形在你继承父类时：

class PriorityCustomer: public Customer {
int priority;
public:
  PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs)
  : priority(rhs.priority){}

  PriorityCustomer& 
  PriorityCustomer::operator=(const PriorityCustomer& rhs){
    priority = rhs.priority;
  }  
};



上述代码看起来没有问题，但你忘记了拷贝父类的部分：

class PriorityCustomer: public Customer {
int priority;
public:
  PriorityCustomer::PriorityCustomer(const PriorityCustomer& rhs)
  : Customer(rhs), priority(rhs.priority){}

  PriorityCustomer& 
  PriorityCustomer::operator=(const PriorityCustomer& rhs){
    Customer::operator=(rhs);
    priority = rhs.priority;
  }  
};



总之当你实现拷贝函数时，

首先要完整复制当前对象的数据（local data）；调用所有父类中对应的拷贝函数。

你可能注意到了代码的重复，但千万不要让复制构造函数和赋值运算符相互调用，它们的语义完全不同！ C++甚至都没有提供一种语法可以让赋值运算符调用复制构造函数；反过来让复制构造函数调用赋值运算符倒是可以编译， 但由于复制构造函数的前置条件是一个未初始化的对象，而赋值运算符的前置条件是一个已初始化的对象。 这样的调用并非好的设计，恐怕会引起逻辑混乱。

但是代码重复怎么办？Scott Meyers提出可以抽象到一个普通方法中，比如init。是不是联想到了Objective-C的init函数？



除非注明，本博客文章均为原创，转载请以链接形式标明本文地址： http://harttle.com/2015/08/01/effective-cpp-12.html


版权声明：本文为博主原创文章，转载请附上原文链接。

HDU 4390 Number Sequence （容斥原理+组合计数）
HDU 4390
题意：
大概就是这样，不翻译了： 
Given a number sequence b1,b2…bn.b_1,b_2…b_n. 
Please count how many number sequences a1,a2,...,ana_1,a_2,...,a_n satisfy the condition thata1∗a2∗...∗an=b1∗b2∗…∗bn(ai,bi>1). a_1*a_2*...*a_n=b_1*b_2*…*b_n (a_i,b_i>1). 
思路：
我们可以确定一件事：等号两边由相同数量的质因子组成。
如果aia_i可以等于1，答案就是把这些质因子分配进n个位置的方案数。 
设左边的数字共由x个质因子组成，其中第i个质因子出现mim_i次。 
把m个相同小球放进n个不同盒子（盒子可以为空）中的方案数是 Cn−1m+n−1C_{m+n-1}^{n-1}。 
那么把mim_i个相同质因子放进n个不同位置上的方案数是 Cn−1mi+n−1C_{m_i+n-1}^{n-1}，最后答案就是∏xi=1Cn−1mi+n−1\prod_{i=1}^xC_{m_i+n-1}^{n-1}.
但这并不是我们想要的答案，因为我们不允许某个位置为空（即存在ai=1a_i=1），所以我们要减去一些某些位置为空的方案。 
因为至少有一个位置为空与至少有两个位置为空存在重复情况等，减的方法是容斥原理。 
ans=∏xi=1Cn−1mi+n−1−C1n∏xi=1Cn−2mi+n−2+C2n∏xi=1Cn−3mi+n−3−...Cn−1n∏xi=1C0mians = \prod_{i=1}^xC_{m_i+n-1}^{n-1} - C_n^1\prod_{i=1}^xC_{m_i+n-2}^{n-2} +C_n^2\prod_{i=1}^xC_{m_i+n-3}^{n-3}-...C_n^{n-1}\prod_{i=1}^xC_{m_i}^{0}. 
 （答案 = 所有可能 - 一个为空 + 两个为空 - 三个为空 +…） 
代码：
/*
* @author FreeWifi_novicer
* language : C++/C
*/
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<string>
#include<map>
#include<set>
#include<vector>
#include<queue>

using namespace std;

#define clr( x , y ) memset(x,y,sizeof(x))
#define cls( x ) memset(x,0,sizeof(x))
#define mp make_pair
#define pb push_back
typedef long long lint;
typedef long long ll;
typedef long long LL;

const int maxn = 1005 ;
const int mod = 1e9 + 7 ;
lint C[505][505];
lint b[25] ;
map<int , int>m ;

int n ;
void init(){
    cls( C ) ;
    C[0][0] = 1 ;
    for( int i = 1 ; i <= 500 ; i++ ){
        C[i][0] = 1 ;
        for( int j = 1 ; j <= i ; j++ ){
            C[i][j] = C[i-1][j] + C[i-1][j-1] ;
            if( C[i][j] > mod ) C[i][j] -= mod ;
        }
    }
}

lint work(){
    for( int i = 1 ; i <= n ; i++ ){
        for( int j = 2 ; j * j <= b[i] ; j++ ){
            while( b[i] % j == 0 ) {
                m[j] ++ ;
                b[i] /= j ;
            }
        }
        if( b[i] > 1 ) m[b[i]] ++ ;
    }
    map<int,int>::iterator it ;

    lint ans = 1 ;
    for( it = m.begin() ; it != m.end() ; it++ ){
        int num = it->second ;
        ans = ( ans * C[ num + n - 1 ][ n - 1 ] ) % mod ;
    }
    for( int i = 1 ; i < n ; i++ ){
        lint val = C[n][i] ;
        for( it = m.begin() ; it != m.end() ; it++ ){
            int num = it->second ;
            val = ( val * C[ num + n - i - 1 ][ n - i - 1 ] ) % mod ;
        }
        if( i & 1 )
            ans = ( ans - val + mod ) % mod ;
        else
            ans = ( ans + val ) % mod ;
    }
    return ans ;

}
int main(){
//  freopen("input.txt","r",stdin);
    init() ;
    while( cin >> n ){
        m.clear();
        for( int i = 1 ; i <= n ; i++ )
            cin >> b[i] ;
       cout << work() << endl;
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：博主表示授权一切转载啦：）

黑马程序员——29，网络编程UDP
 ------Java培训、Android培训、iOS培训、.Net培训、期待与您交流！
 -------
 黑马程序员——29，网络编程UDP
一：网络传输---->
       网络传输一般是先找到IP地址然后把数据发送到对方指定的应用程序上，网络应用程序都用数字进行标示，就是逻辑端口。通信规则就是协议，国际组织通信规则是TCP/IP。网络参考模型如图1所示。



                    图1
        数据传输的时候都是从应用层开始往下推进，每过一层都会被数据封包，再经过传输线路传输到对方的主机上，再从物理层往上层层递进，每过一层都会被数据拆包，最后获得数据。
         前期学习编程都是在传输层和网际层编程。后期做java开发则是在应用层编程。传输层最常见协议是TCP和UDP，网际层常见协议就是IP。应用层http协议。
二：网络通信三要素---->
1，  IP地址：网络设备标示，本地循环地址127.0.0.1主机名localhost，IP地址是IP使用的32位或128位无符号数字，低级协议，TCP和UDP都是基于它建立而成的。
2，  端口号：标示进程的逻辑地址，0到65535，其中0到1024系统使用或者保留端口。
3，  传输协议：常见的TCP/UDP
Java.net包就是关于网络编程的数据包。
IP地址常用InetAddress类来表示，InetAddress常用的方法：

package momo;
import java.net.*;
public class Wuo
{
 
         publicstatic void main(String[] args)throws Exception
         {
        InetAddress  ia=InetAddress.getLocalHost();//获取本地地址                                      
        String    sAddress=     ia.getHostAddress();//获取IP号 
        String   sName=ia.getHostName();//获取IP名
        sop("sName----"+sName); //sName----PYDAVFTNLUJKQQD
        sop("sAddress----"+sAddress);//sAddress----192.168.1.2
       
        //用getByName方法获取任意一台主机IP地址
        InetAddress   iaget  =InetAddress.getByName("192.168.1.9");
        String  sdizhi=iaget.getHostAddress();
        String  smingzi=iaget.getHostName();
        sop(smingzi);//192.168.1.9
        //找不到名字就返回IP地址号
        sop(sdizhi);//192.168.1.9
        InetAddress  iabaidu=InetAddress.getByName("www.baidu.com");
        sop( iabaidu.getHostAddress());//180.97.33.107
        sop(iabaidu.getHostName());//www.baidu.com
        //因为百度网有多态主机所以返回的IP地址不唯一
        
         }
         public  static void  sop(Object  obj)//打印方法
         {
                   System.out.println(obj);
         }
 
}

三：TCP与UDP-->
UDP：1，将数据，源，目的封装到数据包中。
             2，  不需要建立连接，速度快。
             3，数据包限制在64k。
             4，不可靠协议。
TCP：1，必须建立连接形成数据通道，效率比较低
             2，大量数据传输
            3，  通过三次握手协议完成连接，（客户端：你好。服务端：已收到，你好。客户端：已收到。）可靠协议。
UDP传输：
UDP传输编程步骤：
1，  建立DatagramSocket端点，最好写上端口号
2，  定义数据包，发送端的数据包往标记需要传输的数据和IP地址和端口，接收端的数据包要设定好接收的数组大小。
3，  发送端发送send，接收端接收receive
4，  调用数据包的相关方法获取数据
5，  关闭资源close()  
 
//发送端
public static  void  fsd() throws  Exception
{
           //发送端
           //建立DatagramSocket端点
           DatagramSocket    ds= new  DatagramSocket(10011);
           //定义数据包
           byte[]   by="我是超人".getBytes();
           DatagramPacket dgp=new  DatagramPacket(by,by.length,InetAddress.getByName("192.168.1.2"),10012);
           //发送数据包
           ds.send(dgp);
           //关闭资源
           ds.close();                          
}
//接收端
public  static  void  jsd()throws Exception
{
           //建立DatagramSocket端点
           DatagramSocket   ds=new DatagramSocket(10012);
           //定义数据包
           byte[]   by=new byte[1024];
           DatagramPacket   dgp=new DatagramPacket(by,by.length);
           //接收数据
           ds.receive(dgp);
           //调用数据包相关方法读取数据
           InetAddress    ia=   dgp.getAddress();//获取地址
           String      sAddress=    ia.getHostAddress();//获取地址号
           String      sName=       ia.getHostName();  //获取地址名
           int  i=dgp.getPort();//获取端口号
           sop(sName+"----"+sAddress+"----"+i);
           //关闭资源
           ds.close();
          
}

其中sop是打印方法：

public static  void    sop(Object obj)//打印方法
{
           System.out.println(obj);
}

 
通过键盘读取数据再进行UDP发送，这里就用到了流，所以要导入io包。

import java.net.*;
import java.io.*;
 class Wuo
{
    //发送端     
    publicstatic void main(String[] args) throws  Exception
    {
                   //建立端点
        DatagramSocket   ds=new  DatagramSocket(10011);
     
        //获取键盘数据的读取流
        BufferedReader   bur=new  BufferedReader(new  InputStreamReader(System.in));    
        String   s=null;
        while((s=bur.readLine())!=null)//不断的读取数据
        {
           if(s.equals("over"))//停止读取数据
           {
             break;      
           }
           byte[]   by=s.getBytes();
           //定义数据包
           DatagramPacket   dgp=new DatagramPacket(by,by.length,InetAddress.getByName("192.168.1.2"),10012);
          //192.168.1.255是广播地址，向这个地址发数据可以发到该网络中的所有主机
          //192.168.1.0表示一个网络地址段
         //发送数据
        ds.send(dgp);        
       }
    //关闭资源
   ds.close();
   }
 
}    
    
        所以，利用UDP再配合上多线程，还可以编写一个简陋的聊天程序。（需要注意的是要保持接收端的开启，才能够保持实时接收到对方的数据。）UDP传输也是经常用在视频会谈上。
 
   
  ------Java培训、Android培训、iOS培训、.Net培训、期待与您交流！
 -------

版权声明：本文为博主原创文章，未经博主允许不得转载。

C++ List 双向链表 实现 会用也要会写
这次的代码比较长，原因是比之前的Vector实现增加了许多的操作，而且毕竟指针操作嘛，处理起来稍微麻烦一点。
List实现中非常重要的一点，就是定义一个头指针和一个尾指针，这样可以避免对很多的特殊情况的处理，当链表为空时就是头指针指向尾指针，另外一个就是迭代器的实现，
list的迭代器的实现比vector要麻烦许多，因为内存不连续，所有采用了内部嵌套类的方式，重载了*（解引用），++EXP（前置++），++EXP（后置++），==和！=等操作符。
具体的大家可以看代码。

<span style="font-size:14px;">//链表
template<typename T>
class List{
private:
	 //定义节点，并设置一个节点的初始化函数
	struct Node{
		T t;
		Node* pre;
		Node* next;
		Node(T tVal=T(),Node* preVal=NULL,Node* nextVal=NULL):t(tVal),pre(preVal),next(nextVal){}
	};

public:
	 /*const迭代器和非const迭代器的实现，因为const迭代器只是作为对数据的保护，很多操作都是相同的因此这里采用了继承*/
	class const_iterator{
	public:
		const_iterator():current(NULL){}
		const T& operator*() const{
			return retrieve();
		}
		//重载相关的操作符
		const_iterator& operator++(){
			current=current->next;
			return *this;
		}
		const_iterator operator++(int){
			const_iterator old=*this;
			++(*this);
			return old;
		}
		bool operator==(const_iterator& rhs) const{
			return current==rhs.current;
		}
		bool operator!=(const_iterator& rhs)const{
			return current!=rhs.current;
		}
	protected:
		Node* current;
		T& retrieve() const{
			return current->t;
		}
		const_iterator(Node* p):current(p){}
		friend class List<T>;
	};

	class iterator:public const_iterator{
	public:
		iterator():current(NULL){}
		T& operator*(){
			return retrieve();
		}
		iterator& operator++(){
			current=current->next;
			return *this;
		}
		iterator operator++(int){
			iterator old=*this;
			current=current->next;
			return old;
		}
		const T& operator*()const{
			return const_iterator::operator*();
		}

	protected:
		iterator(Node* p):const_iterator(p){}
		friend class List<T>;
	};

public:
	/* 构造函数和析构函数，init函数属于private成员，因此放在下面*/
	List(){
		init();
	}
	List(const List& rhs){
		init();
		operator=(rhs);
	}
	~List(){
		clear();
		delete head;
		delete tail;
	}
	//重载操作符
	const List& operator=(const List& rhs){
		for(const_iterator cite=rhs.begin();cite!=rhs.end();cite++){
			push_back(*cite);
		}
		return *this;
	}
	
	T& operator[](int index){
		iterator ite=begin();
		for(int i=0;i<index;i++)
			ite++;
		return *ite;
	}
	//相关的操作函数
	T& front(){
		return *begin();
	}
	const T& front()const{
		return *begin();
	}
	T& back(){
		return *(--end());
	}
	const T& back()const{
		return *(--end());
	}

	void push_front(T t){
		Node* p=new Node(t);
		p->next=head->next;
		p->pre=head;
		p->next->pre=p;
		head->next=p;
		theSize++;
	}
	void push_back(T t){
		Node* p=new Node(t);
		p->pre=tail->pre;
		p->next=tail;
		p->pre->next=p;
		tail->pre=p;
		theSize++;
	}
	void pop_front(){
		Node* p=head->next;
		head->next=p->next;
		p->next->pre=head;
		delete p;
		theSize--;
	}
	void pop_back(){
		Node* p=tail->pre;
		tail->pre=p->pre;
		p->pre->next=tail;
		delete p;
		theSize--;
	}

	void insert(iterator itr,T t){
		Node* p=new Node(t);
		p->next=itr.current;
		p->pre=itr.current->pre;
		itr.current->pre->next=p;
		itr.current->pre=p;
		theSize++;
	}
	iterator erase(iterator itr){
		Node* p=itr.current->next;
		p->pre=itr.current->pre;
		p->pre->next=p;
		delete itr.current;
		return iterator(p);
		theSize--;
	}
	void erase(iterator start,iterator end){
		for(iterator ite=start;ite!=end){
			ite=erase(ite);
			theSize--;
		}
	}

	iterator begin(){
		return iterator(head->next);
	}

	const_iterator begin() const{
		return const_iterator(head->next);
	}

	iterator end(){
		return iterator(tail);
	}

	const_iterator end() const{
		return const_iterator(tail);
	}

	int size()const{
		return theSize;
	}
	bool empty()const{
		return theSize==0;
	}
	void clear(){
		while(theSize!=0){
			pop_back();
		}
	}
private:
	int theSize;
	Node* head;
	Node* tail;
	void init(){
		theSize=0;
		head=new Node();
		tail=new Node();
		head->next=tail;
		tail->pre=head;
	}
};</span>
有疑问或是发现错误，欢迎留言。




版权声明：本文为博主原创文章，未经博主允许不得转载。

uva 1292 树形dp

UVA 1292 - Strategic game

守卫城市，城市由n个点和n-1条边组成的树，要求在点上安排士兵，守卫与点相连的边。问最少要安排多少士兵。

典型的树形dp。每个点有两个状态:
dp[t][i]表示t节点在i状态下其所在的子树全部的边都被守卫的最少士兵数量。有士兵守卫和没有士兵守卫。如果有士兵守卫，其子节点的状态任意。如果没有士兵，子节点必须全部都有士兵守卫。

dp[t][0] = sum{dp[ti][1]};
dp[t][1] = sum{min(dp[t1][0], dp[ti][1])};




#include <bits/stdc++.h>

using namespace std;

int n, a, b, c;
int dp[1505][2];
vector<int> v[1505];

void DP(int t, int fa) {
	dp[t][0] = 0;
	dp[t][1] = 1;

	for (int i=0; i<v[t].size(); i++) {
		if (v[t][i] == fa) continue;
		DP(v[t][i], t);
		dp[t][0] += dp[v[t][i]][1];
		dp[t][1] += min(dp[v[t][i]][0], dp[v[t][i]][1]);
	}
}

int main () {
	for (; scanf ("%d", &n) == 1; ) {
		for (int i=0; i<=n; i++) v[i].clear();

		for (int i=1; i<=n; i++) {
			scanf ("%d:(%d)", &a, &b);
			for (int i=1; i<=b; i++) {
				scanf ("%d", &c);
				v[a].push_back(c);
				v[c].push_back(a);
			}
		}

		DP(0, -1);

		printf("%d\n", min(dp[0][0], dp[0][1]));
	}
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

Go web之旅(路由篇)
   据说Go语言设计出来就是为了解决web软件的并发等诸多问题的，所以Go语言又被称为互联网中的c语言。一般的web应用采用的是"请求-响应"模式。在Go web中数据请求与数据返回相当于是基于"请求-响应"模式的web程序的输入输出。而其中数据在不同地方或者叫层次上有不同的表现形式，在客户端上数据一般采用字符串形式体现，而在后台数据一般体现为结构体或对象，这中间的转换需要相应的工具。
    用servlet/jsp直接开发过Java web程序的同学应该知道，在整个架构中必不可少的元素有web容器，web.xml.web容器必不可少大家应该无异议，但web.xml为什么说也必不可少呢？在web程序中一般采用的MVC三层，当在V层(视图层)向服务器端发送请求时，程序会到web.xml进行URL mapping，寻找相应的处理请求程序进行业务逻辑处理。在Java web中我们耳熟能详的三大框架struts2,spring,hibernate都只不过在不同的层次对servlet进行扩展而已.都离不开URL mapping，其实在Go web也是有这部分的，只不过换了一个不同的名字而已，叫路由。
    什么是路由呢？从百度百科中可以得到路由的说明:路由（routing）是指分组从源到目的地时，决定端到端路径的网络范围的进程。其实它的作用就是路径选择。在上次文章中说过，在servlet/jsp中是在web.xml里实现URLmapping的，而使用了struts时，就将实现URLmapping这部分工作放在了struts中的配置文件里。Go web中的路由就路由选择这一功能上其实和URLmapping(URL映射)是相同的，但接触过或熟悉Go web开发的人肯定知道，Go web中的路由是特别的灵活。许多Go web中间件和框架都是对Go web路由进行封装的，将路由匹配这一工作从main中剥离出去成为单独一层。有人肯定有疑惑，为何要如此大费周章呢？其实这样做一可以减轻main的压力，二是让路由选择变得更加通用性；三是路由选择这部分代码实现其实有很多重复工作，这样剥离出去可以减少代码的重复。中间件Negroni就是这样实现的。
   上面讲了这么多，那在Go web中到底什么是路由，路由又是如何实现路由选择的呢？

在go语言的http package里定义了路由的结构和相应的路由的函数:
type ServeMux struct {//定义路由规则

    mu    sync.RWMutex//锁机制，因为并发处理需要一个锁

    m     map[string]muxEntry//路由，采用map结构

    hosts bool // whether any patterns contain hostnames

}
type muxEntry struct {//路由

    explicit bool   //是否精准匹配

    h        Handler//路由匹配后，所选择的处理

    pattern  string //匹配字符串

}
基于路由的函数:
//match根据传递的path进行路由匹配,返回对应的Handler

func (mux *ServeMux) match(path string) (h Handler, pattern string)

//根据给定request中是否连接网络这个状态进行判断并返回对应的路由

//若request的Method 等于"CONNECT"则调用handler(host, path string)函数进行路由匹配

func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)

//handler(host, path string) 函数调用match(path string)进行路由匹配并返回对应的路由

func (mux *ServeMux) handler(host, path string) (h Handler, pattern string)

//ServeHttp实现了Handler接口,故它实际上也是一个Handler,内部调用handler

func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)

 //注册handler

func (mux *ServeMux) Handle(pattern string, handler Handler)

 //注册handler函数（它是直接使用func来注册的)

func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj  2094 产生冠军

产生冠军

Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)

Total Submission(s): 11752    Accepted Submission(s): 5455




Problem Description

有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。
球赛的规则如下：
如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。
如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。
根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。


 


Input

输入含有一些选手群，每群选手都以一个整数n(n<1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。


 


Output

对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。


 


Sample Input

3
Alice Bob
Smith John
Alice Smith
5
a c
c d
d e
b e
a d
0


 


Sample Output

Yes
No只需记录是否只有一个人的入度为零！ #include<stdio.h>
#include<iostream>
#include<algorithm>
#include<map>//用map记录字符串 
#include<queue>
#include<string.h>
#define INF 0xffffff
#define N 1010
using namespace std;
int n,m;
int indegree[N],p[N][N];
void topo(int count)
{
    int i,j,top=0;
    for(i=1;i<count;i++)
     {
         if(indegree[i]==0)
         top++;
     }
     if(top==1)//当入度只有一个人为零时，满足条件 
     printf("Yes\n");
     else
     printf("No\n");
}
int main()
{
    while(scanf("%d",&n),n)
    {
        map<string,int>mp;
        mp.clear() ;
        memset(p,0,sizeof(p));
        memset(indegree,0,sizeof(indegree));
        int i,j;
        char a[50],b[50];
        int count=1;
        while(n--)
        {
            scanf("%s%s",a,b);
            if(!mp[a])
            mp[a]=count++;
            if(!mp[b])
            mp[b]=count++;
            if(!p[mp[a]][mp[b]])//避免重边 
            {
                p[mp[a]][mp[b]]=1;
                indegree[mp[b]]++;
            }
        }
        topo(count);
    }
}


 



版权声明：本文为博主原创文章，未经博主允许不得转载。

【笔试】22、替换字符串的空格
/**
 *题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出”We%20are%20happy.”
 *时间：2015年8月25日10:34:31
 *文件：ReplaceBlank.java
 *作者：cutter_point
 */
package bishi.Offer50.y2015.m08.d25;

public class ReplaceBlank
{
	public static char[] ReplaceBlank(char string[], int length)
	{
		//我们用倒序的方法进行遍历
		if(string == null && length < 0)
		{
			System.err.println("数据异常");
			return null;
		}
		
		//我们先求出需要的空间长度
		int originalLength = length;
		int numberOfBlank = 0;	//空白的字符
		int i = 0;
		while(i < length)
		{
			if(string[i] == ' ')
			{
				++numberOfBlank;
			}
			++i;
		}
		
		//我们需求的长度'
		int newLength = originalLength + numberOfBlank * 2;
		if(newLength > length)
		{
			//我们为新的数组申请空间
			char string2[] = new char[newLength];
			//然后把数据移到新的数组中
			for(int j = 0; j < length; ++j)
				string2[j] = string[j];
			string = string2;
		}
		
		//我们从后往前遍历，把所有的字符进行替换
		int indexOfnewString = newLength - 1;
		int indexOfOriginalString = length - 1;
		while(indexOfnewString >= indexOfOriginalString && indexOfOriginalString > -1)
		{
			//如果是空格我们就替换，如果不是，就直接复制过来
			if(string[indexOfOriginalString] == ' ')
			{
				string[indexOfnewString--] = '0';
				string[indexOfnewString--] = '2';
				string[indexOfnewString--] = '%';
			}//if
			else
			{
				string[indexOfnewString--] = string[indexOfOriginalString];
			}
			--indexOfOriginalString;
		}//while
		
		return string;
	}

	public static void test()
	{
		String ss = "We are happy.";
		char s[] = new char[50];
		s = "We are happy.".toCharArray();
		s = ReplaceBlank(s, s.length);
		for(int i = 0; i < s.length; ++i)
		{
			System.out.print(s[i]);
		}
	}
	
	public static void main(String[] args)
	{
		test();
	}

}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Node 专题一： 起源
Node的诞生

2009年3月，Ryan Dahl 第一次在博客上宣布准备基于v8创建一个轻量级的web服务器并提供一套库。
2010年年底，Node.js获得Joyent资助，创始人Ryan Dahl加入Joyent全职负责Node.js，Joyent 是一个提供云计算服务的公司,github上node的源代码的管理就是joyent这个公司，现在github上已经找不到早起ryan上传的node最初版本。
2012年 ryan将node的版本发布和bug修复任务转交给了Isaac Z Schlueter(npm的作者)。


为什么是javascript
下面为ryan接受采访的一段记录


    BostInno: 你在创建node的时候，是在试图解决什么问题？


我经常需要写一些基于事件的程序，我喜欢设计开发基于事件的服务器，因为我觉得他们很容易理解，状态被保存，有可以不断的修改状态。你可以无限的接收socket请求，我可以只使用非阻塞IO就可以使服务器的延迟非常低。
为什么大多数人不设计一种更简单和有效率的程序，因为他们需要用阻塞的库。基于事件的设计是一种全有或者全无的方式，如果你不阻塞IO的话，你可以仅用一个操作系统线程来处理大量的IO，但是如果你做了，那么了你将锁住你的所有流程。为每个IO使用一个线程也是不错的，他并不是很慢。我想创建一个仅使用非阻塞IO的系统。
同时，我当时正在写大量的小型HTTP服务器。我经常很沮丧，因为我不能从web服务器那里获得原始的请求数据，除非我写一个Apache或者Nginx的模块。而动态分析器可以很容易构造一个服务器。
BostInno: 为什么你开始要选择Javascript作为node的语言呢？

Dahl: 开始我没有那么做，我用C、Lua和Haskell做了几个失败的小项目。Haskell很不错，但是不还没有足够聪明可以去玩通GHC(Haskell的编译器)。Lua是一种不太理想，但是很可爱的语言，我并不喜欢他，因为他已经有了大量的包含阻塞代码的库了。无论我做了什么，有些人总是愿意去读取有阻塞的Lua库。C语言有一些和Lua相似的问题，而且它的开发门槛有些高。我开始的确想写一种像node.js的libc，我也的确做了一段时间。这个时候V8也出来了，我也做了一些研究，我突然意识到，Javascript的确是一种完美的语言，他有我想要的一切：单线程，没有服务端的IO处理，没有各种历史存在的库。
BostInno: 接下来3个月、6个月或者12个月node将如何发展？

Dahl: Node是一个强制不共享服务器的任何资源的单线程、单进程系统。他的确有一些好的网络库，我相信这是一个设计很大型的分布式系统的很好的基础。而这些节点需要被组织，通过一个通信协议，互相通知对方如何连接。接下来几个月,我将致力于写一些能够支持这种网络的库，以使分布式网络程序开发更加容易。
在今年2月，我们将发布第二个稳定版本：V0.4。这个版本将大大提升内存利用率，和一个新的SSL/TLS系统，一个内建的调试器，更快的定时器，删掉了一些缺陷，以及一个新的V8的版本。 有希望在接下来6个月之内，我们将试图发布一个Node 1.0的正式版本。 我的一个想法是限制核心程序的大小，不让他变的太大，我们我们不会无休止的增加一些特性。 V1.0将看上去很像现在的Node， 目前我们仍然有大量的bug需要修复。
BostInno: 还有任何你希望做的东西吗？

Dahl: 是的，许多事情。 例如，我希望我没有用过CommonJS模块系统，它实在太复杂，并且和浏览器的工作方式很不同。 我希望我没有用过WAF构建系统，他可以工作，也不错，但是他做了比需要更多的事情。我也许可以从WAF中挖掘挖掘一些东西出来。


node的特点

异步I/O
我们首先要理解一些关键字的意思：
1.异步与同步的区别

异步就是你可以边吃饭边喝水,同步就是你必须在吃完饭才可以喝水。如果你想从数据库拉取大量数据就需要等待一些时间,那么同步的编程模式会等待数据读取完成后再去做其它任务。如果是异步的编程模式,则程序在等待数据返回的同时可以去执行其他任务。这里的I/O(input , output)接口的功能是负责实现CPU通过系统总线把I/O电路和外围设备联系在一起。
2.阻塞与非阻塞的区别

阻塞( blocking )、非阻塞（ non-blocking ）:可以简单理解为需要做一件事能不能立即得到返回应答,如果不能立即获得返回,需要等待那就阻塞了(进程或线程就阻塞在那了,不能做其它事情),否则就可以理解为非阻塞(在等待的过程中可 
以做其它事情)
同步 I/O 操作:实际的I/O操作将导致请求进程阻塞,直到 I/O 操作完成  
异步 I/O 操作:实际的I/O操作不导致请求进程阻塞。 
阻塞式I/O，非阻塞式I/O，I/O复用，信号驱动I/O模型都属于同步I/O



异步I/O的实现
1.异步I/O与轮询技术

当进行非阻塞I/O调用时，要读到完整的数据，应用程序需要进行多次轮询,才能确保读取数据完成，以进行下一步的操作。轮询技术的缺点在于应用程序要主动调用，会造成占用较多CPU时间片，性能较为低下。现存的轮询技术有以下这些：
read
select
poll
epoll
pselect
kqueue
read是性能最低的一种，它通过重复调用来检查I/O的状态来完成完整数据读取。select是一种改进方案，通过对文件描述符上的事件状态来进行判断。操作系统还提供了poll、epoll等多路复用技术来提高性能。轮询技术满足了异步I/O确保获取完整数据的保证。但是对于应用程序而言，它仍然只能算是一种同步，因为应用程序仍然需要主动去判断I/O的状态，依旧花费了很多CPU时间来等待。
2.理想的异步I/O模型

理想的异步I/O应该是应用程序发起异步调用，而不需要进行轮询，进而处理下一个任务，只需在I/O完成后通过信号或是回调将数据传递给应用程序即可。
幸运的是，在Linux下存在一种这种方式，它原生提供了一种异步非阻塞I/O方式（AIO）即是通过信号或回调来传递数据的。不幸的是，只有Linux下有这么一种支持，而且还有缺陷（AIO仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存。以上都是基于非阻塞I/O进行的设定。另一种理想的异步I/O是采用阻塞I/O，但加入多线程，将I/O操作分到多个线程上，利用线程之间的通信来模拟异步。Glibc的AIO便是这样的典型。然而遗憾在于，它存在一些难以忍受的缺陷和bug。可以简单的概述为：Linux平台下没有完美的异步I/O支持。
所幸的是，libev的作者Marc Alexander Lehmann重新实现了一个异步I/O的库:libeio。libeio实质依然是采用线程池与阻塞I/O模拟出来的异步I/O。那么在Windows平台下的状况如何呢？而实际上，Windows有一种独有的内核异步IO方案：IOCP。IOCP的思路是真正的异步I/O方案，调用异步方法，然后等待I/O完成通知。IOCP内部依旧是通过线程实现,不同在于这些线程由系统内核接手管理。IOCP的异步模型与Node.js的异步调用模型已经十分近似。以上两种方案则正是Node.js选择的异步I/O方案。由于Windows平台和*nix平台的差异，Node.js提供了libuv来作为抽象封装层，使得所有平台兼容性的判断都由这一层次来完成，保证上层的Node.js与下层的libeio/libev及IOCP之间各自独立。Node.js在编译期间会判断平台条件，选择性编译unix目录或是win目录下的源文件到目标程序中。


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

pomodoro源代码
有网友问我要pomodoro源代码，其实这个程序很简单，只是定时器，定时弹出置顶窗口。用c++builder6.0写，放一个TPopupMenu 右键菜单，一个TTrayIcon 一个托盘图标控件 
，一个ImageList1图片列表，显示闪动图片。显示时间的标签。 
源代码如下，如果不用C++builder写，只能参考代码自己写。 
定时器判断时间到了就显示窗口，闪动图标，双击关闭窗口。 
unit1.h
//---------------------------------------------------------------------------

#ifndef Unit1H
#define Unit1H
//---------------------------------------------------------------------------
#include <Classes.hpp>
#include <Controls.hpp>
#include <StdCtrls.hpp>
#include <Forms.hpp>
#include <ExtCtrls.hpp>
#include "trayicon.h"
#include <Menus.hpp>
#include <ImgList.hpp>
//---------------------------------------------------------------------------
class TForm1 : public TForm
{
__published:    // IDE-managed Components
        TTimer *Timer1;
        TLabel *LMinute;
        TLabel *LMaohao;
        TLabel *LSecond;
        TTrayIcon *TrayIcon1;
        TPopupMenu *PopupMenu1;
        TMenuItem *N1;
        TImageList *ImageList1;
        TMenuItem *sinoxorg1;
        TMenuItem *N2;
        void __fastcall Timer1Timer(TObject *Sender);
        void __fastcall N1Click(TObject *Sender);
        void __fastcall FormDblClick(TObject *Sender);
        void __fastcall FormClose(TObject *Sender, TCloseAction &Action);
        void __fastcall TrayIcon1Restore(TObject *Sender);
        void __fastcall FormCreate(TObject *Sender);
        void __fastcall sinoxorg1Click(TObject *Sender);
        void __fastcall FormKeyPress(TObject *Sender, char &Key);
private:    // User declarations
public:     // User declarations
        __fastcall TForm1(TComponent* Owner);
};
//---------------------------------------------------------------------------
extern PACKAGE TForm1 *Form1;
//---------------------------------------------------------------------------
#endif
unit1.cpp
//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop
#include   <registry.hpp>

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "trayicon"
#pragma resource "*.dfm"
TForm1 *Form1;
int iWaitTime=0;
int MaxWaitTime=25*60;
int MaxRestTime=5*60;
int RunState=0;
int IsOwnerPress=false;
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
        : TForm(Owner)
{
 RunState=0;
 IsOwnerPress=false;
}
//---------------------------------------------------------------------------


void __fastcall TForm1::Timer1Timer(TObject *Sender)
{
 iWaitTime+=1;
 if (RunState==0)
 {
        if ( iWaitTime>= MaxWaitTime)
        {
              RunState=1;
              iWaitTime=0;
        }
        Color= clBtnFace;
        LMinute->Color= clBtnFace;
        LMaohao->Color= clBtnFace;
        LSecond->Color= clBtnFace;
        LMinute->Caption=iWaitTime/60;
        LSecond->Caption=iWaitTime%60;
        if ( iWaitTime%5==0)
        {
                if (WindowState!=wsMinimized)
                {
                    WindowState=wsMinimized;
                    Hide();
                }
        }
         IsOwnerPress=false;
         TrayIcon1->Animate=false;
        //randomize();
        //TrayIcon1->SetIconIndex(rand() % 3);
        TrayIcon1->SetIconIndex(1);

 }
 else
 {
        if ( iWaitTime>= MaxRestTime)
        {
              RunState=0;
              iWaitTime=0;
              IsOwnerPress=false;
        }
        Color= clRed;
        LMinute->Color= clRed;
        LMaohao->Color= clRed;
        LSecond->Color= clRed;
        LMinute->Caption=iWaitTime/60;
        LSecond->Caption=iWaitTime%60;
        if(IsOwnerPress)
        {
                if ( iWaitTime%5==0)
                {
                        if (WindowState!=wsMinimized)
                        {
                        WindowState=wsMinimized;
                        Hide();
                        }
                }
        }
        else
        {
                if (WindowState==wsMinimized)
                {
                        WindowState=wsNormal;
                        Show();
                }
                TrayIcon1->Animate=true;
         }
 }


}
//---------------------------------------------------------------------------
void __fastcall TForm1::N1Click(TObject *Sender)
{
        Application->Terminate();

}
//---------------------------------------------------------------------------

void __fastcall TForm1::FormDblClick(TObject *Sender)
{
        WindowState=wsMinimized;
        Hide();
        IsOwnerPress=true;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::FormClose(TObject *Sender, TCloseAction &Action)
{
        WindowState=wsMinimized;
        Action=caNone;
        Hide();
        IsOwnerPress=true;

}
//---------------------------------------------------------------------------
void __fastcall TForm1::TrayIcon1Restore(TObject *Sender)
{
        WindowState=wsNormal;
        Show();
        IsOwnerPress=false;
}
//---------------------------------------------------------------------------
void __fastcall TForm1::FormCreate(TObject *Sender)
{
 TRegistry *Test;
  Test = new TRegistry ();
  Test->RootKey = HKEY_LOCAL_MACHINE;
  if(Test->OpenKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",false))
  {
        AnsiString sKeyval;

     sKeyval=Test->ReadString("sinox_pomodoro");
     if (sKeyval.Length()<=4)
     Test->WriteString("sinox_pomodoro",Application->ExeName);
  }
  delete Test  ;
  randomize();
  TrayIcon1->SetIconIndex(rand() % 3);
}
//---------------------------------------------------------------------------
void __fastcall TForm1::sinoxorg1Click(TObject *Sender)
{
AnsiString   strurl= "http://www.sinox.org/";
ShellExecute(NULL,NULL, strurl.c_str(),NULL,NULL,SW_SHOW);
}
//---------------------------------------------------------------------------
void __fastcall TForm1::FormKeyPress(TObject *Sender, char &Key)
{
    if (Key==VK_SPACE)
    {
          WindowState=wsMinimized;
        Hide();
        IsOwnerPress=true;
    }
}
//---------------------------------------------------------------------------
unit1.dfm
object Form1: TForm1 
  Left = 192 
  Top = 114 
  Width = 870 
  Height = 145 
  BorderIcons = [biSystemMenu] 
  BorderStyle = bsSizeToolWin 
  Color = clBtnFace 
  DefaultMonitor = dmDesktop 
  Font.Charset = DEFAULT_CHARSET 
  Font.Color = clWindowText 
  Font.Height = -24 
  Font.Name = ‘MS Sans Serif’ 
  Font.Style = [] 
  FormStyle = fsStayOnTop 
  OldCreateOrder = False 
  Position = poDesktopCenter 
  OnClose = FormClose 
  OnCreate = FormCreate 
  OnDblClick = FormDblClick 
  OnKeyPress = FormKeyPress 
  PixelsPerInch = 96 
  TextHeight = 29 
  object LMinute: TLabel 
    Left = 349 
    Top = 16 
    Width = 44 
    Height = 33 
    AutoSize = False 
    Caption = ‘0’ 
  end 
  object LMaohao: TLabel 
    Left = 400 
    Top = 16 
    Width = 32 
    Height = 33 
    AutoSize = False 
    Caption = #65306 
  end 
  object LSecond: TLabel 
    Left = 440 
    Top = 16 
    Width = 57 
    Height = 33 
    AutoSize = False 
    Caption = ‘0’ 
  end 
  object Timer1: TTimer 
    OnTimer = Timer1Timer 
    Left = 448 
    Top = 80 
  end 
  object TrayIcon1: TTrayIcon 
    Visible = True 
    Hint = #24037#20316#20241#24687#25552#37266#22120 
    PopupMenu = PopupMenu1 
    Hide = True 
    RestoreOn = imDoubleClick 
    PopupMenuOn = imRightClickUp 
    Icons = ImageList1 
    IconIndex = 1 
    OnRestore = TrayIcon1Restore 
    Left = 320 
    Top = 80 
  end 
  object PopupMenu1: TPopupMenu 
    Left = 88 
    Top = 72 
    object N1: TMenuItem 
      Caption = #20851#38381 
      OnClick = N1Click 
    end 
    object sinoxorg1: TMenuItem 
      Caption = #35775#38382’sinox.org’ 
      OnClick = sinoxorg1Click 
    end 
    object N2: TMenuItem 
      Caption = #21452#20987’/’#25353#31354#26684#38544#34255 
    end 
  end 
  object ImageList1: TImageList 
    AllocBy = 3 
    Left = 200 
    Top = 80 
    Bitmap = { 
      494C010103000400040010001000FFFFFFFFFF00FFFFFFFFFFFFFFFF424D3600 
      0000000000003600000028000000400000001000000001002000000000000010 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      00000000000000000000000000000000000000000000000000000909E9003434 
      760032327C000405F60000000000000000000000000000000000000000003030 
      8300363671000909E900000000000000000000000000000000000909E9003434 
      760032327C000405F70000000000000000000000000000000000000000003030 
      8300363671000909E900000000000000000000000000000000000909E9003131 
      7700313177000505F60000000000000000000000000000000000000000003030 
      8300363671000909E90000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      00000000000000000000000000000000000000000000000000002A2A95005354 
      21004E4C3100311D950029209E0031446E0031446E002B2597002F1B9A004E4C 
      31005354210030308300000000000000000000000000000000002A2A95005253 
      26004E4C2F0031218400282196002F4481002F4481002A2A95002F1A85004F4B 
      2F005253260030308300000000000000000000000000000000002A2A95005454 
      21004B4B33001D1D950021219E0042446E0042446E00252796001B1A9A004B4B 
      3300545421003030830000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      00000000000000000000000000000000000000000000000000001012D600453D 
      54004B3E47002E95210011E9000009F9000009F9000011E9000027A819004844 
      4500473C4F001315CD00000000000000000000000000000000001112D500453D 
      4C004A3F3B002D96880013E5CD0008FAE90008FAE90010EBD30029A291004745 
      4100473C45001315CF00000000000000000000000000000000001212D6003C3C 
      50003C3C500095962000E4E50000FAFB0000FAFB0000E9EB0000A1A21A004445 
      45003C3C50001515CD0000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000003831 
      780019CE0B0000FF000000FF000000FF000000FF000000FF000000FF000012DC 
      07003A4064000000000000000000000000000000000000000000000000003731 
      720018D0BF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0011DD 
      D00039416C000300F80000000000000000000000000000000000000000003131 
      7700CED00A00FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000DCDD 
      0600414164000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      00000000000000000000000000000000000000000000000000002510B50025BF 
      090000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF 
      00001CD302002D1B9D000000000000000000000000000000000025109F0023C0 
      A30000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FF 
      FF001AD5B8002C1C8D0000000000000000000000F8000000F8001010B500BFC0 
      0800FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF 
      0000D4D501001B1A9A0000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      00000000000000000000000000000000000000000000000000003457570000FF 
      000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF 
      000000FF0000336F3F000900F80000000000000000000300F80033587A0002FF 
      F90000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FF 
      FF0000FFFF0032717B000800EB0000000000000000000000000057585600FFFF 
      0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF 
      0000FFFF00006F713E000000F8000000F8000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      000000000000000000000000000000000000000000000F00EF002D8E2B0000FF 
      000000FF000000FF000000FF000019C1190021AD21000BE10B000BE10B000BE1 
      0B0000FF000027A819001400E20000000000000000000F00DB002B8B8E0000FF 
      FF0000FFFF0000FFFF0000FFFF001AC3B9001FAEAE000AE5E3000BDFDD000AE5 
      E30000FFFF0026AA9A001400CC0000000000000000000000EF008E8F2A00FFFF 
      0000FFFF0000FFFF0000FFFF0000C1C21700AEAE1F00E3E50A00DEDF0D00E2E4 
      0A00FFFF0000A8AA17000000E200000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      000000000000000000000000000000000000000000001100EA002A97240000FF 
      000000FF000000FF000000FF00002D8E2B003B663B001EB21E0021A721001EB2 
      1E0000FF000023B612001600DD0000000000000000001000D7002A97910000FF 
      FF0000FFFF0000FFFF0000FFFF002A979100396967001BB7B3001EADA8001BB7 
      B30000FFFF0022B8A6001600C60000000000000000000000EF0097992300FFFF 
      0000FFFF0000FFFF0000FFFF00009092290067693900B3B71B00A8AD1E00B3B7 
      1B00FFFF0000B6B811000000DD00000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      000000000000000000000000000000000000000000000900F8002E7E380000FF 
      000000FF000000FF000000FF00000CE30C000FDF0F0000FF000000FF000000FF 
      000000FF00002A9724000F00EF0000000000000000000A00E7002D84880000FF 
      FF0000FFFF0000FFFF0000FFFF000AE5E3000AE5E30000FFFF0000FFFF0000FF 
      FF0000FFFF002A9791001000D7000000000000000000000000007E803600FFFF 
      0000FFFF0000FFFF0000FFFF0000E2E40A00E2E40A00FFFF0000FFFF0000FFFF 
      0000FFFF0000979923000000EF00000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000303083000DF8 
      000000FF000000FF000000FF00000FDF0F0012D6120000FF000000FF000000FF 
      000000FF0000314A6800000000000000000000000000000000002D348A000BF9 
      DF0000FFFF0000FFFF0000FFFF000DDFDE000FD7D60000FFFF0000FFFF0000FF 
      FF0007FFEC00304C82000000000000000000000000000000000030308300F8F9 
      0000FFFF0000FFFF0000FFFF0000DEDF0D00D6D70F00FFFF0000FFFF0000FFFF 
      0000FFFF00004A4C670000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      000000000000000000000000000000000000000000001C1DB7001C08CD002F82 
      340000FF000000FF000000FF00000FDF0F0012D6120000FF000000FF000000FF 
      00002A9D22001E07CB001C1DB70000000000000000001C1DB7001D07B4002D84 
      880000FFFF0000FFFF0000FFFF000DDFDE000FD7D60000FFFF0000FFFF0000FF 
      FF00299E93001D07B4001C1DB70000000000000000001E1EB2000707CD008384 
      3200FFFF0000FFFF0000FFFF0000DEDF0D00D6D70F00FFFF0000FFFF0000FFFF 
      00009D9E21000707CD001E1EB200000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000202F90043434F003F405800210B 
      C4002C89310009F9000000FF000008F7080009EE090000FF000008FF00002A9D 
      2200230FBB00343476004A4A3E000909E9000405F70043434F003F405800200B 
      AE002B8B8E0009FDE60000FFFF0004F4F30007EFED0000FFFF0007FFEC00299E 
      9300240FA700343476004A4A3D000909E9000505F60043434F00404058000B0B 
      C100898B3000FAFB0000FFFF0000EEEF0700EEEF0700FFFF0000FFFF00009D9E 
      21000F0FBB00313177004A4A3E000909E9000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000034347600535421003F40 
      5800210BC4002F4274002A9827001CBF13001CBF13002A9D2200314A6800210B 
      C4003A386A00535421003F4058000405F6000000000034347600535421003F40 
      5800200BAE0029428C00299E93001BC0B6001BC0B600299E93002E4F8700200B 
      AE003A386900535421003F4058000405F7000000000036367100545421004040 
      58000D0CC0004343730097992300BFC01100BFC011009D9E21004E4F67000B0B 
      C30038386A0054542100404058000505F6000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      000000000000000000000000000000000000000000000909E90032327C003B3B 
      6400181AC100000000000F00EF003B277A003B277A001100EA00000000001012 
      D6003B3B6400343476000E0EDC0000000000000000000909E90032327C003B3B 
      6400181AC300000000000F00DB003B2866003B2866001000D700000000001112 
      D5003B3B6400343476000E0EDC0000000000000000000909E90032327C003B3B 
      64001A1AC100000000000000EF0028287900282879000000EF00000000001212 
      D6003B3B6400363671000E0EDC00000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      00000000000000000000000000000708EE000708EE0000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      00000000000000000000000000000708EF000708EF0000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      00000000000000000000000000000808EE000808EE0000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      0000000000000000000000000000000000000000000000000000000000000000 
      000000000000000000000000000000000000424D3E000000000000003E000000 
      2800000040000000100000000100010000000000800000000000000000000000 
      000000000000000000000000FFFFFF00FFFFFFFFFFFF0000C3E3C3E3C3E30000 
      C003C003C0030000C003C003C0030000E007E003E0070000C003C00300030000 
      C0018001C00000008001800180010000800180018001000080018001C0010000 
      C003C003C0030000800180018001000000000000000000008000800080000000 
      8421842184210000FE7FFE7FFE7F0000} 
  end 
end
可以建立一个项目后替换这三个文件。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

自定义jQValidate校验规则
用jQ的vaildate校验插件，需要对手机号进行校验，具体如下：

<script type="text/javascript">
	$(document).ready(function(){
		<!--自定义校验规则-->
		 $.validator.addMethod("isMobile", function(value, element) {       
		     var length = value.length;   
		     var mobile = /^(((13[0-9]{1})|(15[0-9]{1}))+\d{8})$/;   
		     return this.optional(element) || (length == 11 && mobile.test(value));       
		 }, "请正确填写您的手机号码");
		
		
		var inputForm = $("#inputForm");
		    
		inputForm.validate({
			rules: {
				<!--input的name-->
				telephone:{
					<!--启用校验规则-->
					isMobile:true,
					required:true
				},
				realName: "required",
			},
			messages: {
				realName: "必填",
				telephone: "请正确填写您的手机号码"
			},
			submitHandler:function(form){ 
	            form.submit();
	        }
		});
	});
</script>




下面是在用的时候找到的一些好的资料。

================================================================================================

//扩展验证规则


//邮箱 表单验证规则
jQuery.validator.addMethod("mail", function (value, element) {
	var mail = /^[a-z0-9._%-]+@([a-z0-9-]+\.)+[a-z]{2,4}$/;
	return this.optional(element) || (mail.test(value));
}, "邮箱格式不对");

//电话验证规则
jQuery.validator.addMethod("phone", function (value, element) {
    var phone = /^0\d{2,3}-\d{7,8}$/;
    return this.optional(element) || (phone.test(value));
}, "电话格式如：0371-68787027");

//区号验证规则  
jQuery.validator.addMethod("ac", function (value, element) {
    var ac = /^0\d{2,3}$/;
    return this.optional(element) || (ac.test(value));
}, "区号如：010或0371");

//无区号电话验证规则  
jQuery.validator.addMethod("noactel", function (value, element) {
    var noactel = /^\d{7,8}$/;
    return this.optional(element) || (noactel.test(value));
}, "电话格式如：68787027");

//手机验证规则  
jQuery.validator.addMethod("mobile", function (value, element) {
    var mobile = /^1[3|4|5|7|8]\d{9}$/;
	return this.optional(element) || (mobile.test(value));
}, "手机格式不对");

//邮箱或手机验证规则  
jQuery.validator.addMethod("mm", function (value, element) {
    var mm = /^[a-z0-9._%-]+@([a-z0-9-]+\.)+[a-z]{2,4}$|^1[3|4|5|7|8]\d{9}$/;
	return this.optional(element) || (mm.test(value));
}, "格式不对");

//电话或手机验证规则  
jQuery.validator.addMethod("tm", function (value, element) {
    var tm=/(^1[3|4|5|7|8]\d{9}$)|(^\d{3,4}-\d{7,8}$)|(^\d{7,8}$)|(^\d{3,4}-\d{7,8}-\d{1,4}$)|(^\d{7,8}-\d{1,4}$)/;
    return this.optional(element) || (tm.test(value));
}, "格式不对");

//年龄 表单验证规则
jQuery.validator.addMethod("age", function(value, element) {   
	var age = /^(?:[1-9][0-9]?|1[01][0-9]|120)$/;
	return this.optional(element) || (age.test(value));
}, "不能超过120岁"); 
///// 20-60   /^([2-5]\d)|60$/

//传真
jQuery.validator.addMethod("fax",function(value,element){
    var fax = /^(\d{3,4})?[-]?\d{7,8}$/;
    return this.optional(element) || (fax.test(value));
},"传真格式如：0371-68787027");

//验证当前值和目标val的值相等 相等返回为 false
jQuery.validator.addMethod("equalTo2",function(value, element){
    var returnVal = true;
    var id = $(element).attr("data-rule-equalto2");
    var targetVal = $(id).val();
    if(value === targetVal){
        returnVal = false;
    }
    return returnVal;
},"不能和原始密码相同");

//大于指定数
jQuery.validator.addMethod("gt",function(value, element){
    var returnVal = false;
    var gt = $(element).data("gt");
    if(value > gt && value != ""){
        returnVal = true;
    }
    return returnVal;
},"不能小于0 或空");

//汉字
jQuery.validator.addMethod("chinese", function (value, element) {
    var chinese = /^[\u4E00-\u9FFF]+$/;
    return this.optional(element) || (chinese.test(value));
}, "格式不对");

//指定数字的整数倍
jQuery.validator.addMethod("times", function (value, element) {
    var returnVal = true;
    var base=$(element).attr('data-rule-times');
    if(value%base!=0){
        returnVal=false;
    }
    return returnVal;
}, "必须是发布赏金的整数倍");

//身份证
jQuery.validator.addMethod("idCard", function (value, element) {
    var isIDCard1=/^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/;//(15位)
    var isIDCard2=/^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$/;//(18位)

    return this.optional(element) || (isIDCard1.test(value)) || (isIDCard2.test(value));
}, "格式不对");


// 字符验证       
jQuery.validator.addMethod("stringCheck", function(value, element) {       
    return this.optional(element) || /^[\u0391-\uFFE5\w]+$/.test(value);       
 }, "只能包括中文字、英文字母、数字和下划线");   
------------------------------------------------------------
 // 中文字两个字节       
jQuery.validator.addMethod("byteRangeLength", function(value, element, param) {       
   var length = value.length;       
   for(var i = 0; i < value.length; i++){       
        if(value.charCodeAt(i) > 127){       
         length++;       
         }       
   }       
    return this.optional(element) || ( length >= param[0] && length <= param[1] );       
 }, "请确保输入的值在3-15个字节之间(一个中文字算2个字节)");   
------------------------------------------------------------
// 身份证号码验证       
jQuery.validator.addMethod("isIdCardNo", function(value, element) {       
     return this.optional(element) || isIdCardNo(value);       
}, "请正确输入您的身份证号码");
------------------------------------------------------------
// 手机号码验证       
jQuery.validator.addMethod("isMobile", function(value, element) {       
     var length = value.length;   
      var mobile =/^[1][3-8]+\\d{9}/;   
   return this.optional(element) || (length == 11 && mobile.test(value));       
}, "请正确填写您的手机号码");       
------------------------------------------------------------
 // 电话号码验证       
jQuery.validator.addMethod("isTel", function(value, element) {       
     var tel = /^\d{3,4}-?\d{7,9}$/;    //电话号码格式010-12345678   
    return this.optional(element) || (tel.test(value));       
}, "请正确填写您的电话号码");   
------------------------------------------------------------
// 联系电话(手机/电话皆可)验证   
jQuery.validator.addMethod("isPhone", function(value,element) {   
    var length = value.length;   
    var mobile = /^(((13[0-9]{1})|(15[0-9]{1}))+\d{8})$/;   
     var tel = /^\d{3,4}-?\d{7,9}$/;   
    return this.optional(element) || (tel.test(value) || mobile.test(value));   
 
}, "请正确填写您的联系电话");   
------------------------------------------------------------  
 // 邮政编码验证       
 jQuery.validator.addMethod("isZipCode", function(value, element) {       

     var tel = /^[0-9]{6}$/;       
    return this.optional(element) || (tel.test(value));       
 }, "请正确填写您的邮政编码");    


================================================================================================

转载地址：http://www.51xuediannao.com/js/jquery/808.html




-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=



jQuery校验官网地址：http://bassistance.de/jquery-plugins/jquery-plugin-validation
一、导入js库

<script type="text/javascript" src="<%=path %>/validate/jquery-1.6.2.min.js"></script>
<script type="text/javascript" src="<%=path %>/validate/jquery.validate.min.js"></script>

注：<%=request.getContextPath() %>返回web项目的根路径。
二、默认校验规则


(1)、required:true               必输字段
(2)、remote:"remote-valid.jsp"   使用ajax方法调用remote-valid.jsp验证输入值
(3)、email:true                  必须输入正确格式的电子邮件
(4)、url:true                    必须输入正确格式的网址
(5)、date:true                   必须输入正确格式的日期，日期校验ie6出错，慎用
(6)、dateISO:true                必须输入正确格式的日期(ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性
(7)、number:true                 必须输入合法的数字(负数，小数)
(8)、digits:true                 必须输入整数
(9)、creditcard:true             必须输入合法的信用卡号
(10)、equalTo:"#password"        输入值必须和#password相同
(11)、accept:                    输入拥有合法后缀名的字符串（上传文件的后缀）
(12)、maxlength:5                输入长度最多是5的字符串(汉字算一个字符)
(13)、minlength:10               输入长度最小是10的字符串(汉字算一个字符)
(14)、rangelength:[5,10]         输入长度必须介于 5 和 10 之间的字符串")(汉字算一个字符)
(15)、range:[5,10]               输入值必须介于 5 和 10 之间
(16)、max:5                      输入值不能大于5
(17)、min:10                     输入值不能小于10


三、默认的提示


messages: {
required: "This field is required.",
remote: "Please fix this field.",
email: "Please enter a valid email address.",
url: "Please enter a valid URL.",
date: "Please enter a valid date.",
dateISO: "Please enter a valid date (ISO).",
dateDE: "Bitte geben Sie ein g眉ltiges Datum ein.",
number: "Please enter a valid number.",
numberDE: "Bitte geben Sie eine Nummer ein.",
digits: "Please enter only digits",
creditcard: "Please enter a valid credit card number.",
equalTo: "Please enter the same value again.",
accept: "Please enter a value with a valid extension.",
maxlength: $.validator.format("Please enter no more than {0} characters."),
minlength: $.validator.format("Please enter at least {0} characters."),
rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
range: $.validator.format("Please enter a value between {0} and {1}."),
max: $.validator.format("Please enter a value less than or equal to {0}."),
min: $.validator.format("Please enter a value greater than or equal to {0}.")
},


如需要修改，可在js代码中加入：


$.extend($.validator.messages, {
    required: "必选字段",
    remote: "请修正该字段",
    email: "请输入正确格式的电子邮件",
    url: "请输入合法的网址",
    date: "请输入合法的日期",
    dateISO: "请输入合法的日期 (ISO).",
    number: "请输入合法的数字",
    digits: "只能输入整数",
    creditcard: "请输入合法的信用卡号",
    equalTo: "请再次输入相同的值",
    accept: "请输入拥有合法后缀名的字符串",
    maxlength: $.validator.format("请输入一个长度最多是 {0} 的字符串"),
    minlength: $.validator.format("请输入一个长度最少是 {0} 的字符串"),
    rangelength: $.validator.format("请输入一个长度介于 {0} 和 {1} 之间的字符串"),
    range: $.validator.format("请输入一个介于 {0} 和 {1} 之间的值"),
    max: $.validator.format("请输入一个最大为 {0} 的值"),
    min: $.validator.format("请输入一个最小为 {0} 的值")
});


推荐做法，将此文件放入messages_cn.js中，在页面中引入

<script type="text/javascript" src="<%=path %>/validate/messages_cn.js"></script>

四、使用方式
1、metadata用法，将校验规则写到控件中


<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<%
    String path = request.getContextPath();
    String basePath = request.getScheme() + "://" + request.getServerName() + ":"
            + request.getServerPort() + path + "/";
%>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
    <head>
        <base href="<%=basePath%>">

        <title>jQuery Validate验证框架详解-metadata用法</title>

        <meta http-equiv="pragma" content="no-cache">
        <meta http-equiv="cache-control" content="no-cache">
        <meta http-equiv="expires" content="0">
        <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
        <meta http-equiv="description" content="This is my page">
        <script type="text/javascript" src="<%=request.getContextPath()%>/validate/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="<%=request.getContextPath()%>/validate/jquery.validate.min.js"></script>
        <script type="text/javascript" src="<%=request.getContextPath()%>/validate/jquery.metadata.min.js"></script>
        <script type="text/javascript" src="<%=request.getContextPath()%>/validate/messages_zh.js"></script>
        <script type="text/javascript">
        $(function(){
            $("#myform").validate();
        });
        </script>
    </head>

    <body>
        <form id="myform" method="post" action="">
            <p>
                <label for="myname">用户名：</label>
                <!-- id和name最好同时写上 -->
                <input id="myname" name="myname" class="required" />
            </p>
            <p>
                <label for="email">E-Mail：</label>
                <input id="email" name="email" class="required email" />
            </p>
            <p>
                <label for="password">登陆密码：</label>
                <input id="password" name="password" type="password"
                    class="{required:true,minlength:5}" />
            </p>
            <p>
                <label for="confirm_password">确认密码：</label>
                <input id="confirm_password" name="confirm_password" type="password"
                    class="{required:true,minlength:5,equalTo:'#password'}" />
            </p>
            <p>
                <label for="confirm_password">性别：</label>
                <!-- 表示必须选中一个 -->
                <input  type="radio" id="gender_male" value="m" name="gender" class="{required:true}" />
                <input  type="radio" id="gender_female" value="f" name="gender"/>
            </p>
            <p>
                <label for="confirm_password">爱好：</label>
                <!-- checkbox的minlength表示必须选中的最小个数,maxlength表示最大的选中个数,rangelength:[2,3]表示选中个数区间  -->
                <input type="checkbox" id="spam_email" value="email" name="spam[]" class="{required:true, minlength:2}" />
                <input type="checkbox" id="spam_phone" value="phone" name="spam[]" />
                <input type="checkbox" id="spam_mail" value="mail" name="spam[]" />
            </p>
            <p>
                <label for="confirm_password">城市：</label>
                <select id="jungle" name="jungle" title="Please select something!" class="{required:true}">
                    <option value=""></option>
                    <option value="1">厦门</option>
                    <option value="2">泉州</option>
                <option value="3">Oi</option>
            </select>
            </p>
            <p>
                <input class="submit" type="submit" value="立即注册" />
            </p>
        </form>
    </body>
</html>



使用class="{}"的方式，必须引入包：jquery.metadata.js；
可以使用如下的方法，修改提示内容：class="{required:true,minlength:5,messages:{required:'请输入内容'}}"；
在使用equalTo关键字时，后面的内容必须加上引号，如下代码：class="{required:true,minlength:5,equalTo:'#password'}"。
2、将校验规则写到js代码中


<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<%
    String path = request.getContextPath();
    String basePath = request.getScheme() + "://" + request.getServerName() + ":"
            + request.getServerPort() + path + "/";
%>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
    <head>
        <base href="<%=basePath%>">

        <title>jQuery Validate验证框架详解</title>

        <meta http-equiv="pragma" content="no-cache">
        <meta http-equiv="cache-control" content="no-cache">
        <meta http-equiv="expires" content="0">
        <meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
        <meta http-equiv="description" content="This is my page">
        <script type="text/javascript" src="<%=request.getContextPath()%>/validate/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="<%=request.getContextPath()%>/validate/jquery.validate.min.js"></script>
        <script type="text/javascript">
        $(function(){
            var validate = $("#myform").validate({
                debug: true, //调试模式取消submit的默认提交功能   
                //errorClass: "label.error", //默认为错误的样式类为：error   
                focusInvalid: false, //当为false时，验证无效时，没有焦点响应  
                onkeyup: false,   
                submitHandler: function(form){   //表单提交句柄,为一回调函数，带一个参数：form   
                    alert("提交表单");   
                    form.submit();   //提交表单   
                },   
                
                rules:{
                    myname:{
                        required:true
                    },
                    email:{
                        required:true,
                        email:true
                    },
                    password:{
                        required:true,
                        rangelength:[3,10]
                    },
                    confirm_password:{
                        equalTo:"#password"
                    }                    
                },
                messages:{
                    myname:{
                        required:"必填"
                    },
                    email:{
                        required:"必填",
                        email:"E-Mail格式不正确"
                    },
                    password:{
                        required: "不能为空",
                        rangelength: $.format("密码最小长度:{0}, 最大长度:{1}。")
                    },
                    confirm_password:{
                        equalTo:"两次密码输入不一致"
                    }                                    
                }
                          
            });    
    
        });
        </script>
    </head>

    <body>
        <form id="myform" method="post" action="">
            <p>
                <label for="myname">用户名：</label>
                <!-- id和name最好同时写上 -->
                <input id="myname" name="myname" />
            </p>
            <p>
                <label for="email">E-Mail：</label>
                <input id="email" name="email" />
            </p>
            <p>
                <label for="password">登陆密码：</label>
                <input id="password" name="password" type="password" />
            </p>
            <p>
                <label for="confirm_password">确认密码：</label>
                <input id="confirm_password" name="confirm_password" type="password" />
            </p>
            <p>
                <input class="submit" type="submit" value="立即注册" />
            </p>
        </form>
    </body>
</html>



五、常用方法及注意问题
1、用其他方式替代默认的submit


$(function(){
   $("#signupForm").validate({
        submitHandler:function(form){
            alert("submit!");   
            form.submit();
        }    
    });
});


可以设置validate的默认值，写法如下：
$.validator.setDefaults({
submitHandler: function(form) { alert("submit!"); form.submit(); }
});
如果想提交表单，需要使用form.submit()，而不要使用$(form).submit()
2、debug，只验证不提交表单
如果这个参数为true，那么表单不会提交，只进行检查，调试时十分方便

$(function(){
    $("#signupForm").validate({
        debug:true
    });
});

如果一个页面中有多个表单都想设置成为debug，用
$.validator.setDefaults({
debug: true
})
3、ignore：忽略某些元素不验证
ignore: ".ignore"
4、更改错误信息显示的位置
errorPlacement：Callback 
Default: 把错误信息放在验证的元素后面 
指明错误放置的位置，默认情况是：error.appendTo(element.parent());即把错误信息放在验证的元素后面 
errorPlacement: function(error, element) { 
     error.appendTo(element.parent()); 
}
//示例


<tr>
    <td class="label"><label id="lfirstname" for="firstname">First Name</label></td>
    <td class="field"><input id="firstname" name="firstname" type="text" value="" maxlength="100" /></td>
    <td class="status"></td>
</tr>
<tr>
    <td style="padding-right: 5px;">
        <input id="dateformat_eu" name="dateformat" type="radio" value="0" />
        <label id="ldateformat_eu" for="dateformat_eu">14/02/07</label>
    </td>
    <td style="padding-left: 5px;">
        <input id="dateformat_am" name="dateformat" type="radio" value="1"  />
        <label id="ldateformat_am" for="dateformat_am">02/14/07</label>
    </td>
    <td></td>
</tr>
<tr>
    <td class="label">&nbsp;</td>
    <td class="field" colspan="2">
        <div id="termswrap">
            <input id="terms" type="checkbox" name="terms" />
            <label id="lterms" for="terms">I have read and accept the Terms of Use.</label>
        </div>
    </td>
</tr>

errorPlacement: function(error, element) {
    if (element.is(":radio"))
        error.appendTo(element.parent().next().next());
    else if (element.is(":checkbox"))
        error.appendTo(element.next());
    else
        error.appendTo(element.parent().next());
}


代码的作用是：一般情况下把错误信息显示在<td class="status"></td>中，如果是radio显示在<td></td>中，如果是checkbox显示在内容的后面
errorClass：String Default: "error" 
指定错误提示的css类名，可以自定义错误提示的样式
errorElement：String Default: "label" 
用什么标签标记错误，默认的是label你可以改成em
errorContainer：Selector 
显示或者隐藏验证信息，可以自动实现有错误信息出现时把容器属性变为显示，无错误时隐藏，用处不大
errorContainer: "#messageBox1, #messageBox2"
errorLabelContainer：Selector
把错误信息统一放在一个容器里面。
wrapper：String
用什么标签再把上边的errorELement包起来
一般这三个属性同时使用，实现在一个容器内显示所有错误提示的功能，并且没有信息时自动隐藏
errorContainer: "div.error",
errorLabelContainer: $("#signupForm div.error"),
wrapper: "li"
5、更改错误信息显示的样式
设置错误提示的样式，可以增加图标显示，在该系统中已经建立了一个validation.css专门用于维护校验文件的样式


input.error { border: 1px solid red; }
label.error {
    background:url("./demo/images/unchecked.gif") no-repeat 0px 0px;
    padding-left: 16px;
    padding-bottom: 2px;
    font-weight: bold;
    color: #EA5200;
}
label.checked {
    background:url("./demo/images/checked.gif") no-repeat 0px 0px;
}


6、每个字段验证通过执行函数
success：String,Callback
要验证的元素通过验证后的动作，如果跟一个字符串，会当做一个css类，也可跟一个函数

success: function(label) {
    // set &nbsp; as text for IE
    label.html("&nbsp;").addClass("checked");
    //label.addClass("valid").text("Ok!")
}

添加"valid"到验证元素, 在CSS中定义的样式<style>label.valid {}</style>
success: "valid"
7、验证的触发方式修改
下面的虽然是boolean型的，但建议除非要改为false,否则别乱添加。
a.onsubmit：Boolean Default: true 
提交时验证. 设置唯false就用其他方法去验证
b.onfocusout：Boolean Default: true 
失去焦点是验证(不包括checkboxes/radio buttons)
c.onkeyup：Boolean Default: true 
在keyup时验证.
d.onclick：Boolean Default: true 
在checkboxes 和 radio 点击时验证
e.focusInvalid：Boolean Default: true 
提交表单后，未通过验证的表单(第一个或提交之前获得焦点的未通过验证的表单)会获得焦点
f.focusCleanup：Boolean Default: false 
如果是true那么当未通过验证的元素获得焦点时，移除错误提示。避免和focusInvalid一起用
8、异步验证
remote：URL
使用ajax方式进行验证，默认会提交当前验证的值到远程地址，如果需要提交其他的值，可以使用data选项


示例一：
remote: "check-email.php"
示例二：
remote: {
    url: "check-email.php",     //后台处理程序
    type: "post",               //数据发送方式
    dataType: "json",           //接受数据格式   
    data: {                     //要传递的数据
        username: function() {
            return $("#username").val();
        }
    }
}


远程地址只能输出"true"或"false"，不能有其它输出。
9、添加自定义校验
addMethod：name, method, message
自定义验证方法


// 中文字两个字节
jQuery.validator.addMethod(
    "byteRangeLength", 
    function(value, element, param) {
        var length = value.length;
        for(var i = 0; i < value.length; i++){
            if(value.charCodeAt(i) > 127){
                length++;
            }
        }
        return this.optional(element) || (length >= param[0] && length <= param[1]);   
    }, 
    $.validator.format("请确保输入的值在{0}-{1}个字节之间(一个中文字算2个字节)")
);

// 邮政编码验证   
jQuery.validator.addMethod("isZipCode", function(value, element) {   
    var tel = /^[0-9]{6}$/;
    return this.optional(element) || (tel.test(value));
}, "请正确填写您的邮政编码");


1.要在additional-methods.js文件中添加或者在jquery.validate.js添加
建议一般写在additional-methods.js文件中
2.在messages_cn.js文件添加：isZipCode: "只能包括中文字、英文字母、数字和下划线",
调用前要添加对additional-methods.js文件的引用。
10、radio和checkbox、select的验证


1.radio的required表示必须选中一个
<input  type="radio" id="gender_male" value="m" name="gender" class="{required:true}" />
<input  type="radio" id="gender_female" value="f" name="gender"/>

2.checkbox的required表示必须选中
<input type="checkbox" class="checkbox" id="agree" name="agree" class="{required:true}" />

checkbox的minlength表示必须选中的最小个数,maxlength表示最大的选中个数,rangelength:[2,3]表示选中个数区间
<input type="checkbox" id="spam_email" value="email" name="spam[]" class="{required:true, minlength:2}" />
<input type="checkbox" id="spam_phone" value="phone" name="spam[]" />
<input type="checkbox" id="spam_mail" value="mail" name="spam[]" />

3.select的required表示选中的value不能为空
<select id="jungle" name="jungle" title="Please select something!" class="{required:true}">
    <option value=""></option>
    <option value="1">Buga</option>
    <option value="2">Baga</option>
    <option value="3">Oi</option>
</select>
 
select的minlength表示选中的最小个数（可多选的select）,maxlength表示最大的选中个 数,rangelength:[2,3]表示选中个数区间
<select id="fruit" name="fruit" title="Please select at least two fruits" class="{required:true, minlength:2}" multiple="multiple">
    <option value="b">Banana</option>
    <option value="a">Apple</option>
    <option value="p">Peach</option>
    <option value="t">Turtle</option>
</select>


=====================================================================
转载地址：http://www.cnblogs.com/linjiqin/p/3431835.html


版权声明：本文为博主原创文章，未经博主允许不得转载。

开发笔记-PHP-CI
CI加载并调用类库时不能使用任何大写字母。 
以下代码会报找不到xxxY属性：
$this->load->library('xxxY');
$this->xxxY->methodXXX($aa,$bb);
这样写没问题
$this->load->library('xxxy');
$this->xxxy->methodXXX($aa,$bb);

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：欢迎转载，转载请注明原地址，谢谢！

双栈排序（Java）

题目描述


请编写一个程序，按升序对栈进行排序（即最大元素位于栈顶），要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。

给定一个int[] numbers(C++中为vector<int>)，其中第一个元素为栈顶，请返回排序后的栈。请注意这是一个栈，意味着排序过程中你只能访问到第一个元素。
测试样例：
[1,2,3,4,5]
返回：[5,4,3,2,1]
import java.util.Stack;
import java.util.ArrayList;

public class TwoStacks {
	 public ArrayList<Integer> twoStacksSort(int[] numbers) {
	        // write code here
		 Stack<Integer> stack = new Stack<Integer>();
		 Stack<Integer> stack1 = new Stack<Integer>();
		
		 for(int i=0; i<numbers.length; i++){
			 stack.push(numbers[i]);
		 }
		 
		 while(!stack.isEmpty()){
			 int tmp = stack.pop().intValue();
			 while(!stack1.isEmpty() && stack1.peek() > tmp){
				 stack.push(stack1.pop());
			 }
			 stack1.push(tmp);
		 }
		 ArrayList<Integer> tmp1 = new ArrayList<Integer>();
		 while(!stack1.isEmpty()){
			 tmp1.add(stack1.pop());
		 }
		 return tmp1;
	 }
	 
	 
	 public Stack<Integer> twoStacksSort1(Stack<Integer> s) {
	        // write code here
		 Stack<Integer> stack = new Stack<Integer>();
		 while(!s.isEmpty()){ 
			 int tmp = s.pop();
			 while(!stack.isEmpty() && stack.peek() > tmp){
				 s.push(stack.pop());
			 }
			 stack.push(tmp);
		 }
		 
		 return stack;
	    }

	 public static void main(String[] args) {
		 TwoStacks ts = new TwoStacks();
		 int [] numbers = {1,3,2,6,5};
		 ArrayList<Integer> al = ts.twoStacksSort(numbers);
		 for(int i=0; i<al.size(); i++){
			 System.out.print(al.get(i) + "  ");
		 }
	}

}



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1010
Tempter of the Bone
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 91012 Accepted Submission(s): 24756


Problem Description
The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately
 to get out of this maze.

The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the
 T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for
 more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him.



Input
The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 < N, M < 7; 0 < T < 50), which denote the sizes of the maze and the time at which the door will open, respectively.
 The next N lines give the maze layout, with each line containing M characters. A character is one of the following:

'X': a block of wall, which the doggie cannot enter; 
'S': the start point of the doggie; 
'D': the Door; or
'.': an empty block.

The input is terminated with three 0's. This test case is not to be processed.



Output
For each test case, print in one line "YES" if the doggie can survive, or "NO" otherwise.



Sample Input

4 4 5
S.X.
..X.
..XD
....
3 4 5
S.X.
..X.
...D
0 0 0



Sample Output

NO
YES



Author
ZHANG, Zheng


Source
ZJCPC2004  


#include<stdio.h>
#include<math.h>
int n,m,t,flag;
int sx,sy,dx,dy,wall;
int movex[]={0,-1,0,1},movey[]={-1,0,1,0};
char map[7][7];

void dfs(int sx,int sy,int st)
{
    int i,time;
    if (sx==dx && sy==dy && st==t)
    {
        flag=1;
        return;
    }
    time=t-st-abs(sx-dx)-abs(sy-dy);
    if (time<0||time%2!=0)
        return;
    for (i=0;i<4;i++)
    {
        if (sx+movex[i]<0||sx+movex[i]>n-1||sy+movey[i]<0||sy+movey[i]>m-1)
            continue;
        if (map[sx+movex[i]][sy+movey[i]]!='X')
        {
            map[sx+movex[i]][sy+movey[i]]='X';
            dfs(sx+movex[i],sy+movey[i],st+1);
            map[sx+movex[i]][sy+movey[i]]='.';
        }
        if (flag)
            break;
    }
}

main ()
{
    int i,j;
    while (scanf ("%d%d%d",&n,&m,&t)==3&&(n||m||t))
    {
        getchar();
        wall=0;
        flag=0;
        for (i=0;i<n;i++)
        {
            for (j=0;j<m;j++)
            {
                scanf ("%c",&map[i][j]);
                if (map[i][j]=='S')
                {
                    sx=i;
                    sy=j;
                    map[i][j]='X';
                }
                else if (map[i][j]=='D')
                {
                    dx=i;
                    dy=j;
                }
                else if (map[i][j]=='X')
                    wall++;
            }
            getchar();
        }
        if (n*m-wall>=t)
            dfs(sx,sy,0);
        if (flag)
            printf ("YES\n");
        else
            printf ("NO\n");
    }
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 4786 Fibonacci Tree（最小生成树）
该题其实就是最小生成树的变形，先求一个最小生成树的权值，再求一个最大生成树的权值，显然在这两个权值之间的所有值都可以取到（你总可以拿一条黑边换成一条白边）。那么我们只要看一下这些值中有没有斐波那契数就行了。小于100000的斐波那契数只有几十个，直接枚举就行了 。 
细节参见代码：
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const long long maxn = 100000 + 10;
int T,n,m,p[maxn],kase = 0,tot=0;
ll vis[maxn];
struct node{
    int a,b,c;
    bool operator < (const node& rhs) const {
        return c < rhs.c;
    }
}e[maxn];
int findd(int x) { return p[x] == x ? x : p[x] = findd(p[x]); }
void init() {
    vis[0] = 1; vis[1] = 2;
    tot = 2;
    while(vis[tot-1] < 100000 + 500) {
        vis[tot] = vis[tot-1]+vis[tot-2];
        tot++;
    }
}
bool solve() {
    for(int i=1;i<=n;i++) p[i] = i;
    sort(e,e+m);
    int max_v = 0,min_v = 0 ,cnt = 1;
    for(int i=0;i<m;i++) {
        int x = findd(e[i].a) , y = findd(e[i].b);
        if(x != y) {
            cnt++;
            min_v += e[i].c; p[x] = y;
        }
    }
    if(cnt != n) return false;
    for(int i=1;i<=n;i++) p[i] = i;
    for(int i=m-1;i>=0;i--) {
        int x = findd(e[i].a) , y = findd(e[i].b);
        if(x != y) {
            max_v += e[i].c; p[x] = y;
        }
    }
    for(int i=0;i<tot;i++)
        if(vis[i]>=min_v && vis[i]<=max_v) return true;
    return false;
}
int main() {
    init();
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&m);
        for(int i=0;i<m;i++)
            scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].c);
        printf("Case #%d: ",++kase);
        if(solve()) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

分析公式  Codeforces 528B Clique Problem
http://codeforces.com/contest/528/problem/b


Clique Problem


time limit per test
2 seconds


memory limit per test
256 megabytes


input
standard input


output
standard output



The clique problem is one of the most well-known NP-complete problems. Under some simplification it can be formulated as follows. Consider an undirected graph G.
 It is required to find a subset of vertices C of the maximum size such that any two of them are connected by an edge in graph G.
 Sounds simple, doesn't it? Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph. However, as with many other NP-complete problems, the clique problem is easier if you consider a specific type of a
 graph.

Consider n distinct points on a line. Let the i-th
 point have the coordinate xi and
 weight wi.
 Let's form graph G, whose vertices are these points and edges connect exactly the pairs of points (i, j),
 such that the distance between them is not less than the sum of their weights, or more formally: |xi - xj| ≥ wi + wj.

Find the size of the maximum clique in such graph.



Input

The first line contains the integer n (1 ≤ n ≤ 200 000)
 — the number of points.

Each of the next n lines contains two numbers xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109)
 — the coordinate and the weight of a point. All xi are
 different.



Output

Print a single number — the number of vertexes in the maximum clique of the given graph.



Sample test(s)



input
4
2 3
3 1
6 1
0 2




output
3






Note

If you happen to know how to solve this problem without using the specific properties of the graph formulated in the problem statement, then you are able to get a prize of one million dollars!

The picture for the sample test.





直接分析公式啊啊啊啊啊！！！


题意：

给定数轴上的n个点。

下面n行每行两个数 xi, wi 表示点和点权。

对于任意两个点u, v

若dis(u,v) >= u_w+v_w 则这两个点间可以建一条边。(in other words 若两点间距离大于两点的权值和则可以建边）

找一个最大团，输出这个最大团的点数。






#include <bits/stdc++.h>
#define ll int
using namespace std;
pair<ll,ll>p[200005];
int main()
{
	ll n,i,w,x,s=0,l=-(1<<31);
	cin>>n;
	for(i=0;i<n;i++)
		cin>>x>>w,p[i]=make_pair(x+w,x-w);
	sort(p,p+n);
	for(i=0;i<n;i++)
		if(p[i].second>=l)
			l=p[i].first,s++;
	cout<<s;
}
顺便提一下用DP，线段树或树状数组的同学！


其实对于一个权值点我们可以认为是一个区间

如: 4 5 ,可以认为是区间[-1, 9]

则这个点可以从区间(-inf, 1]转移过来，即val(9) = max(val(9), 区间(-inf, -1]最大值+1)

然后前面区间最值就用树状数组或者线段树维护
#include <stdio.h>  
#include <string.h>  
#include <iostream>  
#include <math.h>  
#include <queue>  
#include <set>  
#include <vector>
#include <string>
#include <algorithm>  
template <class T>
inline bool rd(T &ret) {
    char c; int sgn;
    if (c = getchar(), c == EOF) return 0;
    while (c != '-' && (c<'0' || c>'9')) c = getchar();
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c >= '0'&&c <= '9') ret = ret * 10 + (c - '0');
    ret *= sgn;
    return 1;
}
template <class T>
inline void pt(T x) {
    if (x <0) {
        putchar('-');
        x = -x;
    }
    if (x>9) pt(x / 10);
    putchar(x % 10 + '0');
}
using namespace std;
const int N = 400010;
#define L(x) tree[x].l
#define R(x) tree[x].r
#define Max(x) tree[x].max
#define Lson(x) (x<<1)
#define Rson(x) (x<<1|1)
#define Lazy(x) tree[x].lazy
struct Node{
    int l, r, max, lazy;
}tree[N<<2];
void Down(int id){
    Max(Lson(id)) = max(Lazy(id), Max(Lson(id)));
    Max(Rson(id)) = max(Lazy(id), Max(Rson(id)));
    Lazy(Lson(id)) = max(Lazy(id), Lazy(Lson(id)));
    Lazy(Rson(id)) = max(Lazy(id), Lazy(Rson(id)));
}
void U(int id){
    Max(id) = max(Max(Lson(id)), Max(Rson(id)));
}
void build(int l, int r, int id){
    L(id) = l; R(id) = r;
    Max(id) = Lazy(id) = 0;
    if (l == r)return;
    int mid = (l + r) >> 1;
    build(l, mid, Lson(id)); build(mid + 1, r, Rson(id));
}
int query(int l, int r, int id){
    if (l == L(id) && R(id) == r)return Max(id);
    Down(id);
    int mid = (L(id) + R(id)) >> 1, ans ;
    if (r <= mid)
        ans = query(l, r, Lson(id));
    else if (mid < l)
        ans = query(l, r, Rson(id));
    else ans = max(query(l, mid, Lson(id)), query(mid + 1, r, Rson(id)));
    U(id);
    return ans;
}
void up(int l, int r, int val, int id){
    if (l == L(id) && R(id) == r){
        Max(id) = max(Max(id), val);
        Lazy(id) = max(Lazy(id), val);
        return;
    }
    Down(id);
    int mid = (L(id) + R(id)) >> 1;
    if (r <= mid)
        up(l, r, val, Lson(id));
    else if (mid < l)
        up(l, r, val, Rson(id));
    else {
        up(l, mid, val, Lson(id));
        up(mid + 1, r, val, Rson(id));
    }
    U(id);
}
vector<int>G;
int hehehe;
struct Edge{
    int l, r;
}x[N];
bool cmp(Edge a, Edge b){
    return a.r < b.r;
}
int n, m;
int a[N], b[N];
int main(){
    while (~scanf("%d", &n)){
        G.clear();
        for (int i = 1; i <= n; i++){
            rd(a[i]); rd(b[i]);
            x[i].l = a[i] - b[i];
            x[i].r = a[i] + b[i];
            G.push_back(x[i].l);
            G.push_back(x[i].r);
        }
        sort(G.begin(), G.end());
        G.erase(unique(G.begin(), G.end()), G.end());
        for (int i = 1; i <= n; i++){
            x[i].l = lower_bound(G.begin(), G.end(), x[i].l) - G.begin() + 1;
            x[i].r = lower_bound(G.begin(), G.end(), x[i].r) - G.begin() + 1;
        }
        sort(x + 1, x + n + 1, cmp);
        build(1, G.size(), 1);
        int ans = 1;
        for (int i = 1; i <= n; i++){
            int tmp = query(1, x[i].l, 1) + 1;
            ans = max(ans, tmp);
            up(x[i].r, x[i].r, tmp, 1);
        }
        pt(ans); puts("");
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

Item 13：使用对象（智能指针）来管理资源 Effective C++笔记

Item 13: Use objects to manage resources.


熟悉智能指针的人肯定不会对此觉得陌生。利用C++中对象自动析构的特性，自动地释放资源。 C++编译器并未提供自动的垃圾回收机制，因此释放资源的责任落在了开发者的头上。 我们被要求总是成对地使用new和delete，例如：

Investment *pInv = createInvestment();
...
delete pInv;



createInvestment这样的方法属于工厂方法（factory
 function），用来创建一个对象的实例。


上述代码确实能够在不泄漏内存的情况下很好地执行，但问题出在createInvestment()函数把释放资源的责任交给了客户，
 但并未显式地声明这一点，因而客户有时并不知情。即使客户知道该资源需要销毁， 也可能由于流控制语句或者异常的出现而使得资源未被及时释放。

幸运的是，我们可以用对象来包装资源，并在析构函数中释放它。这样客户便不需要维护资源的内存了。 std::auto_ptr便是这样一个对象，它被称为智能指针（smart
 pointer）。 典型的使用场景是，资源在堆空间中存储但只在局部被使用。

void f(){
  std::auto_ptr<Investment> pInv(createInvestment());
}



关于C++中堆空间、栈空间的使用方式，可以参考：进程的地址空间：TEXT，DATA，BSS，HEAP，STACK


在f()调用结束时pInv退出作用域，析构函数被调用，最终使得资源被释放。
 事实上，让createInvestment直接返回智能指针是更好的设计。
 可以看到，使用对象来管理资源的关键在于：创建资源后立即放入资源管理对象中，并利用资源管理对象的析构函数来确保资源被释放。

资源管理对象的实现框架正是RAII原则：acquisition is initialization，用一个资源来初始化一个智能指针。指针的析构函数中释放资源。


值得注意的是，为了防止对象被多次释放，auto_ptr应当是不可复制的。 复制一个auto_ptr会使它变成空，资源被交付给另一个只能指针。

std::auto_ptr<int> p1 (new int);
*p1.get()=10;

std::auto_ptr<int> p2 (p1);

std::cout << "p2 points to " << *p2 << '\n';
// p2 points to 10
// (p1 is now null-pointer auto_ptr)                           



.get方法返回资源的指针。


auto_ptr古怪的复制行为导致它并不是管理资源的最佳方式，甚至在STL中auto_ptr的容器也是不允许的：
 可以创建这样的容器，但往里面添加元素（例如push_back）时会导致编译错。

auto_ptr<int> p1(new int);

vector<auto_ptr<int>> v;    // OK，可以编译
v.push_back(p1);            // 编译错！



此处我们引入一个引用计数（reference-counting smart pointer，RCSP）的指针shared_ptr。
 它在没有任何其他指针引用到该资源时，进行资源的释放。不同于垃圾回收器，shared_ptr未能解决环状引用的问题。

值得注意的是auto_ptr和shared_ptr只能管理单个资源，因为它们是使用delete而非delete[]来实现资源释放的。常见的错误便是传递数组进去：

std::tr1::shared_ptr<int> spi(new int[1024]);



在最新的C++标准中，智能指针已经归入std命名空间了。我们可以这样使用：std::shared_ptr<int>。


虽然智能指针有这样的问题，但C++并未提供管理数组的智能指针，因为vector等容器就可以很好地完成这个工作。
 如果你真的需要，可以求助与Boost社区的boost::scoped_array和boost::shared_array。


除非注明，本博客文章均为原创，转载请以链接形式标明本文地址： http://harttle.com/2015/08/02/effective-cpp-13.html


版权声明：本文为博主原创文章，转载请附上原文链接。

【并查集】LA3644 X-Plosives
【并查集】LA3644 X-Plosives
n个元素的集合应用问题——并查集。
题目大意
装车，把一些两个元素组成的化合物按输入次序往车上装，如果会发生爆炸(存在k个简单化合物，正好包含k种元素)，记录，输出不能装车的化合物总数。
 

说一下思路
怎样理解“存在k个简单化合物，正好包含k种元素”？
每个化合物在顶点处分摊到1/2个元素，成环！根节点相同！问题都是等价的！
想一想并查集的查找和合并操作，在合并过程中计数那些根节点相同的边就可以了~


参考代码
#include<bits/stdc++.h>
using namespace std;

const int _max = 1e5 + 10;
int a,b,pre[_max],ans;

void init(){//每个点所在的集合初始化为自身
  for(int i = 1;i <= _max;++ i) pre[i] = i;
}

int find(int x){//查找，返回元素x的根节点
  return pre[x] == x? x : pre[x]=find(pre[x]);
}

void  join(int a,int b){//合并
  int x = find(a),y = find(b);
  if(x != y) pre[x] = y;
  else ans++; //加上(a,b)则成环，会发生爆炸booooom!
}

int main(){
 #ifndef ONLINE_JUDGE
 freopen("input.txt","r",stdin);
 #endif // ONLINE_JUDGE
 while(scanf("%d",&a) == 1){
    init();
    ans = 0;
    while(a != -1){
       scanf("%d",&b);
       join(a,b);
       scanf("%d",&a);
    }
    printf("%d\n",ans);
 }
 return 0;
}



加粗    Ctrl + B 
斜体    Ctrl + I 
引用    Ctrl + Q
插入链接    Ctrl + L
插入代码    Ctrl + K
插入图片    Ctrl + G
提升标题    Ctrl + H
有序列表    Ctrl + O
无序列表    Ctrl + U
横线    Ctrl + R
撤销    Ctrl + Z
重做    Ctrl + Y


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Binary Tree Right Side View
思路：：主要用到BFS，把最后边的一个元素存储。
class Solution {
public:
   vector<int> rightSideView(TreeNode* root) 
		{
			vector<int> Result;
			if (root==NULL)
			{
				return Result;
			}
			//BFS
			queue<TreeNode* > q1;
			q1.push(root);
			int cnt=1;
			int level;
			while (!q1.empty())
			{
				level=0;
				for (int i=0;i<cnt;i++)
				{
					TreeNode * tmp=q1.front();
					if (i==cnt-1)
					{
						Result.push_back(tmp->val);
					}
				   q1.pop();
				   if (tmp->left)
				   {
					   q1.push(tmp->left);
					   level++;
				   }
				   if (tmp->right)
				   {
					   q1.push(tmp->right);
					   level++;
				   }
				}
				cnt=level;
			}
			return Result;
		}
};



版权声明：本文为博主原创文章，未经博主允许不得转载。

强连通分量问题
连通性·三
题目传送：hihoCoder - 1185 - 连通性·三
AC代码：
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cctype>
#include <cstdio>
#include <string>
#include <vector>
#include <complex>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>
#include <utility>
#include <iostream>
#include <algorithm>
#include <functional>
#define LL long long
#define INF 0x7fffffff
using namespace std;

const int maxn = 20005;
int n, m;

int dfn[maxn];
int low[maxn];
int in_stack[maxn];
int col[maxn];
int vis[maxn];

int w[maxn];
int W[maxn];
int indeg[maxn];

pair<int, int> e[100005];
vector<int> G[maxn];
vector<int> G2[maxn];

stack<int> s;

int cur_time, color;
void tarjan(int u) {
    dfn[u] = low[u] = ++ cur_time;
    s.push(u);
    in_stack[u] = 1;
    vis[u] = 1;

    int d = G[u].size();
    for(int i = 0; i < d; i ++) {
        int v = G[u][i];
        if(!vis[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(in_stack[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }

    color ++;
    if(dfn[u] == low[u]) {
        int v;
        do {
            v = s.top();
            s.pop();
            in_stack[v] = 0;
            col[v] = color;
            W[color] += w[v];
        } while(v != u);
    }
}

void make_new_graph() {
    for(int i = 0; i < m; i ++) {
        int u = col[e[i].first];
        int v = col[e[i].second];
        if(u == 0 || v == 0) continue;
        //cout << u << " " << v << endl;
        if(u != v) {
            G2[u].push_back(v);
            indeg[v] ++;
        }
    }
}

int ans;
int MAX[maxn];
void toposort() {
    queue<int> que;
    for(int i = 1; i <= color; i ++) {
        if(indeg[i] == 0) {
            que.push(i);
            MAX[i] = W[i];
            //cout << i << " " << W[i] << endl;
            ans = max(MAX[i], ans);
        }
    }

    while(!que.empty()) {
        int u = que.front();
        que.pop();
        int d = G2[u].size();
        for(int i = 0; i < d; i ++) {
            int v = G2[u][i];
            indeg[v] --;
            MAX[v] = max(MAX[v], MAX[u] + W[v]);
            if(indeg[v] == 0) {
                que.push(v);
                ans = max(MAX[v], ans);
                //cout << v << " " << MAX[v] << endl;
            }
        }
    }
}

int main() {
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; i ++) {
        scanf("%d", &w[i]);
    }
    for(int i = 0; i < m; i ++) {
        scanf("%d %d", &e[i].first, &e[i].second);
        G[e[i].first].push_back(e[i].second);
    }

    while(!s.empty()) s.pop();
    memset(col, 0, sizeof(col));
    memset(in_stack, 0, sizeof(in_stack));
    cur_time = color = 0;
    tarjan(1);

    make_new_graph();

    ans = 0;
    toposort();
    printf("%d\n", ans);
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu3622 2-SAT+二分
http://acm.hdu.edu.cn/showproblem.php?pid=3622


Problem Description

Robbie is playing an interesting computer game. The game field is an unbounded 2-dimensional region. There are N rounds in the game. At each round, the computer will give Robbie two places, and Robbie should choose one of them to put a bomb. The explosion area
 of the bomb is a circle whose center is just the chosen place. Robbie can control the power of the bomb, that is, he can control the radius of each circle. A strange requirement is that there should be no common area for any two circles. The final score is
 the minimum radius of all the N circles.
Robbie has cracked the game, and he has known all the candidate places of each round before the game starts. Now he wants to know the maximum score he can get with the optimal strategy.


 


Input

The first line of each test case is an integer N (2 <= N <= 100), indicating the number of rounds. Then N lines follow. The i-th line contains four integers x1i, y1i, x2i, y2i, indicating that the coordinates of the
 two candidate places of the i-th round are (x1i, y1i) and (x2i, y2i). All the coordinates are in the range [-10000, 10000].


 


Output

Output one float number for each test case, indicating the best possible score. The result should be rounded to two decimal places.


 


Sample Input

2
1 1 1 -1
-1 -1 -1 1
2
1 1 -1 -1
1 -1 -1 1


 


Sample Output

1.41
1.00




/**
hdu3622 2-SAT
题目大意：给定一组的点，一组有两个，每组必须的只能选择一个，不可不选，然后以选择的点画圆，问在所有圆的不能相交（可以相切）的情况下最大的可行半径是多少
解题思路：二分查找可行半径，每次利用2-sat建边，若满足则当前半径值可以，那么找出最大的即可。
*/
#include <stdio.h>
#include <algorithm>
#include <iostream>
#include <string.h>
#include <math.h>
#include <stack>
using namespace std;
const int maxn=210;
const double eps=1e-5;

int head[maxn],ip;
int dfn[maxn],low[maxn],sccno[maxn],cnt,scc,instack[maxn];
int n;
stack<int>stc;

void init()
{
    memset(head,-1,sizeof(head));
    ip=0;
}

struct note
{
    int v,next;
} edge[maxn*maxn*2];

void addedge(int u,int v)
{
    edge[ip].v=v,edge[ip].next=head[u],head[u]=ip++;
}

void add_cluse(int x,int xval,int y,int yval)
{
    x=x*2+xval;
    y=y*2+yval;
    addedge(x,y^1);
    addedge(y,x^1);
}

void dfs(int u)
{
    dfn[u]=low[u]=++scc;
    stc.push(u);
    instack[u]=1;
    for(int i=head[u]; i!=-1; i=edge[i].next)
    {
        int v=edge[i].v;
        if(!dfn[v])
        {
            dfs(v);
            low[u]=min(low[u],low[v]);
        }
        else if(instack[v])
        {
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(low[u]==dfn[u])
    {
        cnt++;
        int x;
        do
        {
            x=stc.top();
            stc.pop();
            sccno[x]=cnt;
            instack[x]=0;
        }
        while(x!=u);
    }
}

bool solve()
{
    scc=cnt=0;
    memset(sccno,0,sizeof(sccno));
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(instack,0,sizeof(instack));
    while(!stc.empty())stc.pop();
    for(int i=0; i<2*n; i++)
    {
        if(!dfn[i])
            dfs(i);
    }
    for(int i=0; i<2*n; i+=2)
    {
        if(sccno[i]==sccno[i^1])return false;
    }
    return true;
}

struct node
{
    double x,y;
} a[maxn][2];

double dis(node a,node b)
{
    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}

int main()
{
    while(~scanf("%d",&n))
    {
        for(int i=0; i<n; i++)
        {
            scanf("%lf%lf%lf%lf",&a[i][0].x,&a[i][0].y,&a[i][1].x,&a[i][1].y);
        }
        double l=0,r=40000.0;
        while(r-l>=eps)
        {
            double mid=(l+r)/2;
           // printf("%lf\n",mid);
            init();
            for(int i=0; i<n; i++)
            {
                for(int u=0; u<2; u++)
                {
                    for(int j=i+1; j<n; j++)
                    {
                        for(int v=0;v<2;v++)
                        {
                            if(dis(a[i][u],a[j][v])<mid*mid*4.0)//不满足
                            {
                              //  printf("%lf %lf\n",dis(a[i][u],a[j][v]),mid*mid);
                                add_cluse(i,u,j,v);
                              //  printf("%d,%d;%d,%d\n",i,u,j,v);
                            }
                        }
                    }
                }
            }
           // getchar();
            if(solve())l=mid;
            else r=mid;
        }
        printf("%.2lf\n",r);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

01 背包问题
0 1背包问题


01背包（ZeroOnePack）：有N件物品和一个容量为V的背包。（每种物品均只有一件）第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。
 

题目
有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。
基本思路
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。
用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}


  
初始化：  f0
For(i=1  to  n)
{
      for( j=1 to v )
      {
             f[i][j]=f[i-1][j];
             if(j>=c[i])
             {
                  f[i][j]=max{f[i-1][j] ,f[i-1][j-c[i]]+w[i]};
             } 
       }
}


第一种是第i件不放进去，这时所得价值为:f[i-1][v]

第二种是第i件放进去，这时所得价值为：f[i-1][v-c[i]]+w[i]

最后比较第一种与第二种所得价值的大小，哪种相对大，f[i][v]的值就是哪种。

用表格来演示：




背包容量


0


1


2


3


4


5


6


7


8


9


10


11


12


13


14


15




5物品


0


0


0


0


0


0


6


12


12


15


15


18


22


22


25


25




4物品


0


0


3


3


3


3


3


12


12


15


15


18


22


22


25


25




3物品


0


0


0


0


0


0


0


12


12


15


15


15


22


22


22


22




2物品


0


0


0


0


3


12


12


12


12


15


15


15


15


15


15


15




1物品


0


0


0


0


0


12


12


12


12


12


12


12


12


12


12


12






例子：5个物品，（重量，价值）分别为：（5，12），（4，3），（7，10），（2，3），（6，6）
背包的容量为15

 代码：#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
int main()
{
	int f[6][16];
	int cos[6]={0,5,4,7,2,6};
	int val[6]={0,12,3,10,3,6};
	memset(f,0,sizeof(f));
	for(int i=1;i<=5;i++)
	{
		for(int j=1;j<=15;j++)
		{
			f[i][j]=f[i-1][j];
			if(j>=cos[i])
			{
				f[i][j]=max(f[i-1][j],f[i-1][j-cos[i]]+val[i]);
			}
		}
	}
	for(int i=1;i<=5;i++)
	{
		for(int j=1;j<=15;j++)
		  printf("%d ",f[i][j]);
		  printf("\n");
	}
	printf("最大价值：%d\n",f[5][15]); 
} 
这里是用二位数组存储的，可以把空间优化，用一位数组存储！
代码：
 优化：将f数组转化为一维数组

#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
int main()
{
	int f[16];
	int cos[6]={0,5,4,7,2,6};
	int val[6]={0,12,3,10,3,6};
	memset(f,0,sizeof(f));
	for(int i=1;i<=5;i++)
	{
		for(int j=15;j>=1;j--)
		{
			if(j>=cos[i])
			{
				f[j]=max(f[j],f[j-cos[i]]+val[i]);
			}
		}
	}
	for(int i=1;i<=15;i++)
	{
		  printf("%d ",f[i]);
	}
	
} 



 


版权声明：本文为博主原创文章，未经博主允许不得转载。

addSubview和rootViewController区别
如果你把一个view添加到主视图中去有两种方式：




（1）直接将控制器的view添加到UIWindow中，并不理会它对应的控制器

[self.window  addsubview:MyView.view];


（2）设置uiwindow的根控制器，自动将rootviewcontroller的view添加到window中，负责管理rootviewcontroller的生命周期

[self.window.rootviewcontroller=MyView];

 

两个方法的区别：

以后的开发中，建议使用（2）.因为方法（1）存在一些问题，比如说控制器上面可能由按钮，需要监听按钮的点击事件，如果是1，那么按钮的事件应该由控制器来进行管理。但控制器是一个局部变量，控制器此时已经不存在了，但是控制器的view还在，此时有可能会报错。注意：方法执行完，这个控制器就已经不存在了。

问题1：当view发生一些事件的时候，通知控制器，但是控制器已经销毁了，所以可能出现未知的错误。

问题2：添加一个开关按钮，让屏幕360度旋转（两者的效果不一样）。当发生屏幕旋转事件的时候，UIapplication对象会将旋转事件传递给uiwindow,uiwindow又会将旋转事件传递给它的根控制器，由根控制器决定是否需要旋转

UIapplication->uiwindow->根控制器（第一种方式没有根控制器，所以不能跟着旋转）。

提示：不通过控制器的view也可以做开发，但是在实际开发中，不要这么做，不要直接把view添加到UIWindow上面去。因为，难以管理。

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 1305-Fermat vs. Pythagoras(毕达哥拉斯三元组的解)
题目地址：POJ 1305 
题意：给一个整数N，求N范围内的本原的毕达哥拉斯三元组的个数，以及N以内毕达哥拉斯三元组不涉及数的个数。 
思路： 
首先我们先来了解一下一些基本的定义 
毕达哥拉斯三元组： 
设不定方程:x^2+y^2=z^2若正整数三元组(x,y,z)满足上述方程，则称为毕达哥拉斯三元组。 
本原毕格拉斯三元组： 
在毕格拉斯三元组的基础上，若gcd(x,y,z)=1，则称为本原的毕达哥拉斯三元组。 
定理： 
正整数x,y,z构成一个本原的毕达哥拉斯三元组且y为偶数,当且仅当存在互素的正整数m,n(m>n),其中m,n的奇偶性不同,并且满足x=m^2-n^2,y=2*m*n, z=m^2+n^2 
所以根据定理，对于本题只要枚举一下m,n(m,n<=sqrt(n))，然后将三元组乘以i(保证i*z小于N)，就可以求出所有的毕达哥拉斯三元组。 
但是注意：因为在N范围内，所以z < N，即m^2 + n^2 < N。
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <bitset>
#pragma comment(linker, "/STACK:102400000,102400000")
using namespace std;
typedef __int64 LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
using namespace std;
const int Maxn=1e6+10;
int vis[Maxn];
int gcd(int a,int b)
{
    while(b!=0){
        int r=b;
        b=a%b;
        a=r;
    }
    return a;
}
int main()
{
    int N;
    while(~scanf("%d",&N)){
        int cnt1=0;
        int cnt2=0;
        memset(vis,0,sizeof(vis));
        int t=(int)sqrt(N*1.0);
        for(int n=1;n<=t;n++){
            for(int m=n+1;m<=t;m++){
                if(n*n+m*m>N) break;
                if((n&1)!=(m&1)){
                    if(gcd(n,m)==1){
                        int x=m*m-n*n;
                        int y=2*m*n;
                        int z=m*m+n*n;
                        cnt1++;
                        for(int i=1;;i++){
                            if(i*z>N) break;
                            vis[x*i]=1;
                            vis[y*i]=1;
                            vis[z*i]=1;
                        }
                    }
                }
            }
        }
        for(int i=1;i<=N;i++){
            if(!vis[i]) cnt2++;
        }
        printf("%d %d\n",cnt1,cnt2);
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

PHP中的final关键字
final顾名思义就是“最终的，最后的”。
final修饰方法可以得到“最后的方法”，即不能被子类重写的方法。
class NbaPlayer{
    final public function eat($food){
        echo "food is ".$food;
    }
}


final修饰类可以得到“最后的类”，即不能被继承的类。


final class NbaPlayer(){
}



例子：


<?php
//子类的方法名和父类的方法名相同时，会重写（覆盖）父类的方法
//对于不想被任何子类重写（修改）的方法，可以在class之前添加final关键字
//对于不想被子类重写（修改）的方法，可以在方法定义的前面添加final关键字
class BaseClass{
	public function test($temp="123"){
		echo "BaseClass::test called".$temp."\n";
	}
	final public function test1(){
		echo "BaseClass::test1 called\n";
	}
}
class ChildClass extends BaseClass{
	public function  test($temp="123"){
		echo "ChildClass::test called ";
	}
}
$obj = new ChildClass();
$obj->test("456");



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1020
Encoding
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 33303 Accepted Submission(s): 14811


Problem Description
Given a string containing only 'A' - 'Z', we could encode it using the following method:


1. Each sub-string containing k same characters should be encoded to "kX" where "X" is the only character in this sub-string.

2. If the length of the sub-string is 1, '1' should be ignored.



Input
The first line contains an integer N (1 <= N <= 100) which indicates the number of test cases. The next N lines contain N strings. Each string consists of only 'A' - 'Z' and the length is less than 10000.



Output
For each test case, output the encoded string in a line.



Sample Input

2
ABC
ABBCCC



Sample Output

ABC
A2B3C



Author
ZHANG Zheng


#include <stdio.h>
#include <string.h>
main ()
{
    int n;
    char str[10005];
    int i,j,len,t;
    scanf ("%d",&n);
    while (n--)
    {
        scanf ("%s",str);
        len=strlen(str);
        t=1;
        for (i=0;i<len;i++)
        {
            if (str[i]==str[i+1])
                t++;
            if (str[i]!=str[i+1])
            {
                if (t!=1)
                {
                    printf ("%d%c",t,str[i]);
                    t=1;
                }
                else
                {
                    printf ("%c",str[i]);
                    t=1;
                }
            }    
        }
        printf ("\n");
    }
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

c++实现动态顺序表
seqlist.h
#pragma once
#define  _SEQ_LIST_
#ifdef  _SEQ_LIST_
#include<iostream>
#include<assert.h>
#include<string>
using namespace std;

#define DEFAULT_CAPACITY  3
typedef int DataType;

typedef struct FindRet
{
    bool isFind;    // 是否找到的标示
    size_t index;   // 找到数据的下标
}Findret;

class SeqList
{
public:
    SeqList(DataType *arr = NULL, size_t size = 0, size_t capacity = DEFAULT_CAPACITY)

    {
        _arr = new DataType[DEFAULT_CAPACITY];
        _size = size;
        _capacity = capacity;
    }
    void Swap(SeqList &s)
    {
        /*DataType *tmp = s._arr;
        s._arr = _arr;
        _arr = tmp;*/
        swap(_arr, s._arr);  //swap是c++库函数
        swap(_size, s._size);
        swap(_capacity, s._capacity);
    }
    SeqList(const SeqList &s) :_arr(NULL)
    {
       SeqList tmp(s._arr);
        Swap(tmp);

    }
    SeqList& operator= (SeqList sList)
    {
        Swap(sList);
        return *this;
    }
    ~SeqList()
    {
        if (_arr)
        {
            delete[] _arr;
        }
    }
private:
    void _Cheekcapacity()
    {
        if (_size == _capacity) //判断链表是否已满
        {
            _capacity = _capacity * 2;
            DataType* tmp = new DataType[_capacity];
            memcpy(tmp, _arr, sizeof(DataType)* _size);
            delete[] _arr;
            _arr = tmp;
        }
    }
public:
    void PushBack(const DataType& x) //尾插
    {
        assert(this);
        _Cheekcapacity();
        _arr[_size] = x;
        _size++;
    }
    void PopBack() //尾删
    {
        assert(this);
        if (_size == 0)
        {
            cout << "SeqList is empty" << endl;
            return;
        }
        _arr[ --_size] = 0;
    }
    void PushFront(const DataType& x) //头插
    {
        assert(this);
        _Cheekcapacity();
        for (int i = _size; i > 0; i--)
        {
            _arr[i] = _arr[i - 1];
        }
        _arr[0] = x;
        _size++;
    }
    void PopFront() //头删
    {
        assert(this);
        if (_size == 0)
        {
            cout << "SeqList is empty" << endl;
            return;
        }
        for (size_t i = 0; i < _size - 1; i++)
        {
            _arr[i] = _arr[i + 1];
        }
        _size--;
    }
    void Print()
    {
        assert(this);
        if (_size == 0)
        {
            cout << "SeqList is empty" << endl;
            return;
        }
        for (size_t i = 0; i < _size; i++)
        {
            cout << _arr[i] << "->";
        }
        cout <<"NULL"<<endl;
    }
    void Insert(size_t index, const DataType& x)
    {
        assert(this);
        _Cheekcapacity();
        if (index < _size)
        {
            for (size_t i = _size; i > index; i--)
            {
                _arr[i] = _arr[i - 1];
            }
            _arr[index] = x;
            _size++;
        }

    }
    void Modified(size_t index, const DataType& x) //将index位置的元素修改为x
    {
        assert(this);
        if (index < _size)
        {
            _arr[index] = x;
        }
    }
    void Remove(size_t index)
    {
        assert(this);
        if (index < _size)
        {
            for (size_t i = index; i < _size - 1; i++)
            {
                _arr[i] = _arr[i + 1];
            }
            _size--;
        }
    }
    FindRet Find(const DataType& x)
    {
        Findret ret;
        assert(this);
        for (size_t i = 0; i < _size; i++)
        {
            if (_arr[i] == x)
            {
                ret.isFind = true;
                ret.index = i;
                cout << "find " << x << endl;
                return ret;
            }
        }
        ret.isFind = false;
        cout << "not find "<< x << endl;
        return ret;
    }
private:
    DataType *_arr;
    size_t _size;
    size_t _capacity;
};

#endif  //_SEQ_LIST
test.cpp
#include"seqlist.h"

void Test()
{
    SeqList s1;
    s1.PushBack(1);
    s1.PushBack(2);
    s1.PushBack(3);
    s1.PushBack(4);
    //s1.PopBack();
    //s1.PopBack();
    s1.Insert(3, 0);
    s1.Print();
    s1.Modified(0, 0);
    s1.Print();
    s1.Remove(3);
    s1.Find(4);
    s1.Find(1);
    s1.Print();
}
void Test2()
{
    SeqList s1;
    s1.PushFront(1);
    s1.PushFront(2);
    s1.PushFront(3);
    s1.PushFront(4);
    s1.PopFront();
    s1.PopFront();
    s1.Print();
}

int main()
{
    Test();
    getchar();
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题28-字符串的排列
题目：
/**
* 输入一个字符串，打印出该字符串中字符的所有排列。<br/>
* 例如输入字符串abc,则打印出由字符串abc所能排列出来的所有字符串abc,acb,bca,cab和cba。
* */



这里用递归比较好：
第一个是a，那么剩下的就问bc的排列有多少种
第一个是b，剩下的问ac
第一个是c，剩下的问ab
那么方法就有了：
当前这个数分别与他后面的数交换位置，然后求后面的有多少中排列。
代码：
package com.aii.algorithm;

public class Permutation {

	/**
	 * 输入一个字符串，打印出该字符串中字符的所有排列。<br/>
	 * 例如输入字符串abc,则打印出由字符串abc所能排列出来的所有字符串abc,acb,bca,cab和cba。
	 * */
	public void permutate(char[] str) {
		if (str == null) {
			return;
		}
		// 先判断空，然后再由permutate方法操作
		// 第二个参数是当前的字符的角标
		permutate(str, 0);
	}

	private void permutate(char[] str, int index) {
		// 此次递归结束标记，即到了str的最大长度，index==str.length
		if (index == str.length) {
			for (int i = 0; i < str.length; i++) {
				System.out.print(str[i]);
			}
			System.out.println();
			return;
		}

		// 从i=index到i=str.length-1为止
		// index和i交换位置，然后查找子串，递归
		for (int i = index; i < str.length; i++) {
			char tmp = str[index];
			str[index] = str[i];
			str[i] = tmp;
			permutate(str, index + 1);
		}
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 2899 Strange fuction(二分+数学)
题目来源：hdu 2899 Strange fuction

Strange fuction 
  Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others) 
  Total Submission(s): 4829    Accepted Submission(s): 3441

Problem Description 
Now, here is a fuction: 
  F(x) = 6 * x^7+8*x^6+7*x^3+5*x^2-y*x (0 <= x <=100) 
Can you find the minimum value when x is between 0 and 100.
Input 
The first line of the input contains an integer T(1<=T<=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 < Y <1e10)
Output 
Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.
Sample Input 
2 
100 
200
Sample Output 
-74.4291 
-178.8534
题目大意： 
        给出一个函数：F(x)=6 * x^7+8*x^6+7*x^3+5*x^2-y*x (0 <= x <=100);现在输入一个y值.(0 < Y <1e10)，求此函数的最小值。 
题目分析： 
       观察函数，我们可知，F(x)一阶导数为F’(x)=42 * x^6+48*x^5+21*x^2+10*x-y;而F’(x)中若不看y,则前面的式子为单增函数，当输入y值后，我们便可把y当做常数来处理，当y值大于前面式子的最大值，即F’(100)<0时，原函数F(x)单调递减，此时F(100)为最小值；而当y不大于前面的式子，即存在y使得F’(x)可以==0时，则我们可以知道，x取F’(x)==0的这个x值时，原函数F(x)取得最小值，在此处便需要使用二分来查找这个x值。 
 AC代码：
#include<stdio.h>
#include<math.h>
double F(double x)      //将原函数分解为F(x)-y*x，此处求的是分解后的F(x)值 
{
    return 6*pow(x,7.0)+8*pow(x,6.0)+7*pow(x,3.0)+5*pow(x,2.0);
}
double f(double x)      //分解后的F'(x)的值 
{
    return 42*pow(x,6.0)+48*pow(x,5.0)+21*pow(x,2.0)+10*pow(x,1.0);
}
int main()
{
    int n;
    double y;
    while(scanf("%d",&n)!=EOF)
    {
        while(n--)
        {
            scanf("%lf",&y);
            if(y>=F(100))           //此时原函数的导数不存在等于0的情况，即小于零 
                printf("%.4lf\n",F(100)-y*100);
            else
            {
                double mid,left=0,right=100;
                while(right-left>1e-8)  //使用二分进行查找使得分解后的F(x)的导数等于0的x 
                {
                    mid=(left+right)/2;
                    if(f(mid)<=y)
                        left=mid;
                    else
                        right=mid;
                }
                printf("%.4lf\n",F(mid)-y*mid);
            }
        }
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Round A APAC Test 2016 Problem C. gCampus 最短路


Problem C. gCampus



This contest is open for practice. You can try every problem as many times as you like, though we won't keep track of which problems you solve. Read the Quick-Start
 Guide to get started.




Small input
10 points




Solve C-small






Large input
15 points



Download
 C-large-practice.in




your output file:

source file(s):    not needed for the practice contest

  










Problem
Company G has a main campus with N offices (numbered from 0 to N - 1) and Mbidirectional roads (numbered from 0 to M - 1). The ith road connects a pair of offices (Ui, Vi),
 and it takes Ci minutes to travel on it (in either direction).
A path between two offices X and Y is a series of one or more roads that starts at X and ends at Y. The time taken to travel a path is the sum of the times needed to travel each of the roads that make up the path. (It's guaranteed that there is at least
 one path connecting any two offices.)
Company G specializes in efficient transport solutions, but the CEO has just realized that, embarrassingly enough, its own road network may be suboptimal! She wants to know which roads in the campus are inefficient. A road is inefficient if and
 only if it is not included in any shortest paths between any offices.
Given the graph of offices and roads, can you help the CEO find all of the inefficient roads?
Input
The first line of the input gives the number of test cases, T. T test cases follow. Each case begins with one line with two integers N and M, indicating the number of offices and roads.
 This is followed by M lines containing three integers each: Ui, Vi and Ci, indicating the ith road is between office Ui and office Vi,
 and it takes Ci minutes to travel on it.
Output
For each test case, output one line containing "Case #x:", where x is the test case number (starting from 1). Then output the road numbers of all of the inefficient roads, in increasing order, each on its own line. (Note that road 0 refers to the first road
 listed in a test case, road 1 refers to the second road, etc.)
Limits
0 < Ci ≤ 1000000.
Small dataset
1 ≤ T ≤ 10.
1 ≤ N = M ≤ 100.

Large dataset
1 ≤ T ≤ 3.
1 ≤ N ≤ 100.
1 ≤ M ≤ 10000.

Sample






Input 
 


Output 
 



2
3 3
0 1 10
1 2 3
2 0 3
3 3
0 1 10
1 2 3
2 1 3



Case #1:
0
Case #2:









题意，给出一个图，要求，输出非最短路上的所有边。

直接用disjtra算法求出所有源点的最短路，如果，某个点的最短距离加上这条边正好是别一个边的最短距离，则这条边就是在最短路上的边，用了n次disjtra复杂度为o(n * n * log(n))
#define typec ll
const typec inf = 1e18;
#define E 100005
#define V 105
typec cost[E],dist[V];
int e,pnt[E],nxt[E],head[V],prev[V],vis[V],num[V],index[E];
bool Use[E];
struct qnode {
    int v,en,k;typec c;
    qnode (int vv=0,int ene = 0,typec cc=0):v(vv),en(ene),c(cc){
    }
    bool operator <(const qnode & r)const {return c>r.c;}
};
priority_queue<qnode> que;
void dijkstra(int n,const int src){
    qnode mv;
    int i,j,k,pre;
    while(!que.empty()) que.pop();
    vis[src]=1;dist[src]=0;
    que.push(qnode(src,-1,0));
    for(pre=src,i=1;i<n;i++){
        for(j=head[pre];j!=-1;j=nxt[j]){
            k=pnt[j];
            if(vis[k]==0&&
               dist[pre]+cost[j]<dist[k]){
                    dist[k]=dist[pre]+cost[j];
                    que.push(qnode(pnt[j],j,dist[k]));
                    prev[k]=pre;
               }
        }
        while(!que.empty()&&vis[que.top().v]==1){
            que.pop();
        }
        if(que.empty())break;
        mv=que.top();que.pop();
        vis[pre=mv.v]=1;
    }
    for(int i = 1;i<=n;i++){
        pre = i;
        for(j=head[pre];j!=-1;j=nxt[j]){
            k=pnt[j];
            if(dist[pre] + cost[j] == dist[k]){
                Use[index[j]] = true;
            }
        }
    }
}
inline void addedge(int u,int v,typec c,int in){
    index[e] = in;pnt[e]=v;cost[e]=c;nxt[e]=head[u];head[u]=e++;
}


int T,n,m;
int main()
{
    freopen("C-large-practice.in", "r", stdin);
    freopen("C-large-practice.out", "w", stdout);

     while(S(T)!=EOF)
    {
        For(ta,1,T+1){
            S2(n,m);
            e=0;
            memset(head,-1,sizeof(head));
            fill(Use,false);
            for(int i=0;i<m;i++){
                int s,ee,c;
                scanf("%d%d%d",&s,&ee,&c);
                s++,ee++;
                addedge(s,ee,c,i);
                addedge(ee,s,c,i);
            }
            For(i,1,n+1){
                memset(vis,0,sizeof(vis));
                memset(prev,-1,sizeof(prev));
                for(int j=0;j<=n;j++)dist[j]=inf;
                dijkstra(n,i);
            }
            printf("Case #%d:\n",ta);
            FI(m){
                if(!Use[i]){
                    printf("%d\n",i);
                }
            }
        }

    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

【数据结构学习】-链表

链表是一种数据结构，当要保存和管理的数据元素的数目变化较大时，使用链表效率会很高。在链表中，每个元素都保存在一个称为节点的数据结构中。当新的元素加入列表时，创建新的节点来保存元素，链表中所有节点通过指针串联在一起。
对于一个链表，首先要掌握链表的基本操作，比如插入、删除、判断一个元素是否在链表中等等。以下是对链表进行基本操作的代码和解析。
#include <iostream>
using namespace std;
struct ListNode
{
	ListNode *next;
	int val;
	ListNode(int x): val(x),next(NULL) {}
};
void print(ListNode *head)		//输出链表
{
	ListNode *temp=head;
	while(temp!=NULL)
	{
		cout<<temp->val<<"\t";
		temp=temp->next;
	}
	cout<<endl;
}
int getsize(ListNode *head)		//得到链表的大小
{
	int size=0;
	ListNode *temp=head;
	while(temp!=NULL)
	{
		size++;
		temp=temp->next;
	}
	return size;
}
void add(int index,int element,ListNode *head)		//在索引处添加节点
{
	ListNode *node=new ListNode(element);
	ListNode *temp=head;
	int size=getsize(head);
	if(index>=size)
	{
		cout<<"index out of range"<<endl;
		return;
	}
	if(index==0)
	{
		node->next=head;
		return;
	}
	for(int i=1;i<index;i++)
	{
		temp=temp->next;
	}
	node->next=temp->next;
	temp->next=node;
}
void remove(int index,ListNode *head)  //删除节点
{
	int size=getsize(head);
	ListNode *temp=head;
	if(index>=size)
	{
		cout<<"index out of range"<<endl;
		return;
	}
	if(index==0)
	{
		head=head->next;
		return;
	}
	for(int i=1;i<index;i++)
	{
		temp=temp->next;
	}
	temp->next=temp->next->next;
}
bool contains(ListNode *head,int element)	//判断某个值是否在链表中
{
	ListNode *temp=head;
	while(temp!=NULL)
	{
		if(temp->val==element)
		{
			return true;
		}
		temp=temp->next;
	}
	return false;
}
int _tmain(int argc, _TCHAR* argv[])
{
	int a[5]={1,4,6,9,10};
	ListNode *head=new ListNode(1);
	ListNode *temp=head;
	for(int i=1;i<5;i++)
	{
		temp->next=new ListNode(a[i]);
		temp=temp->next;
	}
	cout<<"输出的原始链表为："<<endl;
	print(head);
	add(2,8,head);
	cout<<"输出插入元素后的链表为:"<<endl;
	print(head);
	cout<<"链表的大小为："<<endl<<getsize(head)<<endl;
	cout<<"链表中是否含有数值？"<<endl<<contains(head,9)<<endl;
	cout<<"链表中是否含有数值？"<<endl<<contains(head,7)<<endl;
	remove(4,head);
	cout<<"输出删除元素后的链表为："<<endl;
	print(head);
	return 0;
}输出结果为：
输出的原始链表为：
1 4 6 9 10
输出插入元素后的链表为:
1 4 8 6 9 10
链表的大小为：
6
链表中是否含有数值9？
1
链表中是否含有数值7？
0
输出删除元素后的链表为：
1 4 8 6 10
以上是链表的基本操作，链表还有一些其他比较常见的问题。比如，链表的反序、删除链表的倒数第N个节点、链表环的相关问题等。
1.链表反序
链表反序是比较常见的问题，很简单，直接看代码就好。
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL)
            return head;
        ListNode *curNode=head,*nextNode=head->next,*temp;
        while(nextNode!=NULL)
        {
            temp=nextNode->next;
            nextNode->next=curNode;
            curNode=nextNode;
            nextNode=temp;
        }
        head->next=NULL;
        head=curNode;
        return head;
    }
};
2.删除链表倒数第N个节点
这个有两种解法，第一种是直接把链表反序删除第N个节点即可，但是这样破坏了链表的原来的结构；第二种是声明两个指针，当第1个指针指向末尾时，让第二个节点指向倒数第N+1个节点。代码如下：
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {
        ListNode *tail,*curNode;
        tail=head;
        curNode=head;
        int length=0;
        while(curNode!=NULL)
        {
            length++;
            curNode=curNode->next;
        }
        if(length<n)
            return head;
        if(length==n)
        {
            head=head->next;
            return head;
        }
        for(int i=0;i<n+1;i++)
            tail=tail->next;
        curNode=head;
        while(tail!=NULL)
        {
            tail=tail->next;
            curNode=curNode->next;
        }
        curNode->next=curNode->next->next;
        return head;
    }
};3.链表环问题
思路：声明两个指针，一个快指针，一个慢指针，如果两个指针能够相交，则说明链表中存在环。代码如下：
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast,*slow;
        fast=head;
        slow=head;
        while(fast!=NULL&&fast->next!=NULL)
        {
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow)
                return true;
        }
        return false;
    }
};总结：链表是很重要的一部分内容，以上是常见的链表问题，其他的问题无外乎这些基本问题的变形。只要掌握了基本知识，临场多变通，就不会有问题。







版权声明：本文为博主原创文章，未经博主允许不得转载。

使用WCF 命名管道 创建的局域网聊天

WCF 是微软分布式系统开发中的一个重量级产品，也是.net中不得不学的一个通信框架，本文通过利用WCF实现一个局域网聊天，希望给大家做个抛砖引玉的作用。

下面是项目的主要结构

    /// <summary>
    /// 通信载体接口
    /// </summary>
    [ServiceContract(SessionMode = SessionMode.Allowed)]
    public interface IMessagesInterface
    {
        [OperationContract]
        string DoMessage(string text);
    }

 public class NamedPipeServer
    {
        private readonly ServiceHost serverHost;

        public string SelfName { get; set; }
        public List<string> ClientNames { get; set; }

        public NamedPipeServer(IMessagesInterface messageInterface, ClientNames selfName)
        {
            SelfName = selfName.ToString();
            ClientNames = new List<string>();
            RegisterClientName();
            serverHost = new ServiceHost(messageInterface);
            serverHost.AddServiceEndpoint((typeof(IMessagesInterface)), new NetNamedPipeBinding(), "net.pipe://localhost/Server/" + SelfName);
            serverHost.Open();
        }


        /// <summary>
        /// 调用远程 DoMessage，发送消息给远程
        /// </summary>
        /// <param name="clientName"></param>
        /// <param name="text">消息正文</param>
        /// <returns>发送结果</returns>
        public void SendMessage(string clientName, string text)
        {
            var msgInterface = GetMessagesInterface(clientName);
            if (msgInterface == null) return;
            try
            {
                msgInterface.DoMessage(text);
            }
            catch (Exception ex)
            {
            }
            finally
            {
                CloseChannel((ICommunicationObject)msgInterface);
            }
        }

        /// <summary>
        /// 打开通道 并 获取可供调用的远程接口
        /// </summary>
        /// <param name="clientKey"></param>
        /// <returns></returns>
        public IMessagesInterface GetMessagesInterface(string clientKey)
        {
            try
            {
                var factory = new ChannelFactory<IMessagesInterface>(new NetNamedPipeBinding(),
                    new EndpointAddress("net.pipe://localhost/Server/" + clientKey));
                return factory.CreateChannel();
            }
            catch (Exception)
            {
                return null;
            }
        }
        /// <summary>
        /// 关闭通道
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        private string CloseChannel(ICommunicationObject channel)
        {
            try
            {
                channel.Close();
            }
            catch (Exception ex)
            {
                return ex.Message;
            }
            finally
            {
                channel.Abort();
            }
            return null;
        }

        private void RegisterClientName()
        {
            foreach (var name in Enum.GetNames(typeof(ClientNames)))
            {
                ClientNames.Add(name);
            }
        }
    }

    public enum ClientNames
    {
        win1, win2, win3, win4
    }

core中封装了两个类，一个是通信载体接口，一个是服务的宿主，至于具体的服务实现，每个的实现都不一样。

通过枚举ClientNames 注册各自的名字，每个win 都持有所有的服务名，想给谁发信息，只用告知宿主，对方的名字，就能自己寻找到对方。

core封装了通信过程，每个人都不用去管通信，只用实现通信载体，就行了 。

代码有点抽象，不宜理解，但是结合代码，还是很好理解的。

源码：http://pan.baidu.com/s/1c0IztPQ

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：欢迎装载，原文链接http://blog.csdn.net/shanghongshen/article/

POJ 2524 Ubiquitous Religions 并查集

Ubiquitous Religions




Time Limit: 5000MS
 
Memory Limit: 65536K


Total Submissions: 27741
 
Accepted: 13588




Description

There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in. 

You know that there are n students in your university (0 < n <= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask
 m (0 <= m <= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound
 of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.
Input

The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The
 end of input is specified by a line in which n = m = 0.
Output

For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.
Sample Input
10 9
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
10 4
2 3
4 5
4 8
5 8
0 0

Sample Output
Case 1: 1
Case 2: 7

Hint

Huge input, scanf is recommended.
Source

Alberta Collegiate Programming Contest 2003.10.18

#include <cstdio>
#include <cstring>
#include <iostream>
#define maxn 50000+5
using namespace std;
int set[maxn],n,m,cnt;
inline int set_find(int t){
    if(set[t]<0)
        return t;
    else return set_find(set[t]);
}
void join(int x,int y){
    int a,b;
    a=set_find(x);
    b=set_find(y);
    if(a==b)
        return ;
    cnt--;
    set[a]=b;
}
int main(){
    int x,y;
    int count=1;
    while(scanf("%d%d",&n,&m)&&(n||m)){
        for(int i=1;i<=n;++i)set[i]=-1;
        cnt=n;
        while(m--){
            scanf("%d%d",&x,&y);
            join(x,y);
        }
        printf("Case %d: %d\n",count++,cnt);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

php中的parent、self、static关键字
1. parent关键字可以用于调用父类中被子类重写了的方法


2. self关键字可以用于访问类自身的成员方法，也可以用于访问自身的静态成员和类常量；不能用于访问类自身的属性；使用常量的时候不需要再属性面前加$符号


3. static关键字用于访问类自身定义的静态成员，防伪静态属性时需要在属性面前添加$符号


<?php

class BaseClass{
	public function test(){
		echo "BaseClass::test called\n";
	}
	public function test1(){
		echo "BaseClass::test1 called\n";
	}
}
class ChildClass extends BaseClass{
	const CONST_VALUE = "A constant value\n";
	private static $sValue = "static value\n";
	public function  test(){
		echo "ChildClass::test called\n";
		parent::test();
		//使用parent关键字可以访问父类中被子类重写的方法
		self::called();
		echo self::CONST_VALUE;
		echo self::$sValue;
		//使用self关键字可以访问自身的成员方法和常量成员
	}
	public function called(){
		echo "ChildClass::called() called\n";
	}
}
$obj = new ChildClass();
$obj->test();





版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 1634 Who's the boss?

Who's the boss?




Time Limit: 5000MS
 
Memory Limit: 30000K


Total Submissions: 2773
 
Accepted: 1142




Description

Several surveys indicate that the taller you are, the higher you can climb the corporate ladder. At TALL Enterprises Inc. this "de facto standard" has been properly formalized: your boss is always at least as tall as you are. Furthermore, you can safely assume
 that your boss earns a bit more than you do. In fact, you can be absolutely sure that your immediate boss is the person who earns the least among all the employees that earn more than you and are at least as tall as you are. Furthermore, if you are the immediate
 boss of someone, that person is your subordinate, and all his subordinates are your subordinates as well. If you are nobody's boss, then you have no subordinates. As simple as these rules are, many people working for TALL are unsure of to whom they should
 be turning in their weekly progress report and how many subordinates they have. Write a program that will help in determining for any employee who the immediate boss of that employee is and how many subordinates they have. Quality Assurance at TALL have devised
 a series of tests to ensure that your program is correct. These test are described below.
Input

On the first line of the input is a single positive integer n, telling the number of test scenarios to follow. Each scenario begins with a line containing two positive integers m and q, where m (at most 30000) is the number of employees and q (at most 200)
 is the number of queries. The following m lines each list an employee by three integers on the same line: employee ID number (six decimal digits, the first one of which is not zero), yearly salary in Euros and finally height in μm (1 μm = 10-6 meters
 - accuracy is important at TALL). The chairperson is the employee that earns more than anyone else and is also the tallest person in the company. Then there are q lines listing queries. Each query is a single legal employee ID. 
The salary is a positive integer which is at most 10 000 000. No two employees have the same ID,and no two employees have the same salary. The height of an employee is at least 1 000 000 μm and at most 2 500 000 μm.
Output

For each employee ID x in a query output a single line with two integers y k, separated by one space character, where y is the ID of x's boss, and k is the number of subordinates of x. If the query is the ID of the chairperson, then you should output 0 as the
 ID of his or her boss (since the chairperson has no immediate boss except, possibly, God).
Sample Input
2
3 3
123456 14323 1700000
123458 41412 1900000
123457 15221 1800000
123456
123458
123457
4 4
200002 12234 1832001
200003 15002 1745201
200004 18745 1883410
200001 24834 1921313
200004
200002
200003
200001
Sample Output
123457 0
0 2
123458 1
200001 2
200004 0
200004 0
0 3
Source

Northwestern Europe 2003

ACcode：

#include <map>
#include <queue>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <stdlib.h>
#include <iostream>
#include <algorithm>
#define maxn 30010
using namespace std;
int hash[1000000];
int stack[maxn],top=0;
struct woker{
    int id;
    int wage;
    int height;
    int boss;
    int nsub;
    void in(){
        scanf("%d%d%d",&id,&wage,&height);
        boss=0;
        nsub=1;
    }
    void on(){
        printf("id %d wage %d height %d boss %d nsub %d\n",id,wage,height,boss,nsub);
    }
}my[maxn];
bool cmp(woker a,woker b){
    return a.wage<b.wage;
}
int main(){
    int loop,n,m;
    scanf("%d",&loop);
    while(loop--){
        scanf("%d%d",&n,&m);
        for(int i=0;i<n;++i)my[i].in();
        sort(my,my+n,cmp);
        for(int i=0;i<n;++i){
            hash[my[i].id]=i;
        }
        top=0;
        for(int i=0;i<n;i++){
            while(top&&my[stack[top-1]].height<=my[i].height){
      				my[stack[top-1]].boss=my[i].id;
      				my[i].nsub+=my[stack[top-1]].nsub;
      				top--;
      			}
      			stack[top++]=i;
        }
        /**for(int i=0;i<n;++i){
            printf("%d",i);
            my[i].on();
        }**/
        int t,k;
        for(int i=0;i<m;++i){
            scanf("%d",&t);
            k=hash[t];
            printf("%d %d\n",my[k].boss,my[k].nsub-1);
        }
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题24-二叉搜索树的后序遍历序列
题目：
/*
 * 输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历的结果。<br/>
 * 如果是则返回true，否则返回false。<br/>
 * 假设输入的数组的任意两个数组都互不相同
 * */



既然是后序遍历，那么根元素肯定是在最后一个。
又应该为二叉搜索树，所以左边一半的肯定比根要小，右边一半的比根要大。
现在有了根，就可以把剩下的数组根据比根小与比根大的分割线分成两半。
然后再递归判断。


什么时候返回false：
当确定了某个分割点以后，（左边的全比根小，右边的第一个比根大）又在右边的数组中找到一个比根小的，说明该数组不满足二叉搜索树的后序遍历。


package com.aii.algorithm;

/**
 * 输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历的结果。<br/>
 * 如果是则返回true，否则返回false。<br/>
 * 假设输入的数组的任意两个数组都互不相同
 * */
public class VerifySquenceOfBST {

	public boolean check(int[] array, int start, int end) {
		if (end >= 0 && end - start <= 1) {
			return true;
		}
		int root = array[end];
		int newRootIndex = -1;

		// 1.找出那个分割线
		for (int i = start; i < end; i++) {
			// 遇到比root大的数，表示前一半已找到。
			// 则前一半的根原始的i-1
			if (array[i] > root) {
				newRootIndex = i;
				break;
			}
		}

		// 2.确定分割线以后再看左边和右边是否都满足，最后是用left&&right判断
		boolean left = true;
		boolean right = true;

		// newRootIndex=-1没找到，进这个if说明是找到了
		if (newRootIndex != -1) {

			// 现在要做的就是验证后半部分是否都满足所有的元素都大于root
			for (int i = newRootIndex; i < end - 1; i++) {
				// 如果找到一个，那就肯定是不满足的了，返回false
				if (array[i] < root) {
					return false;
				}
			}

			// 如果要找check(array,start,newRootIndex-1)，则必须保证end比start要大，
			// 即newRootIndex-1 - start > 0
			if (newRootIndex - 1 - start > 0) {
				left = check(array, start, newRootIndex - 1);
			}

			// 如果要找check(array,newRootIndex,end-1),则必须保证end-1比newRootIndex要大
			// 即end-1 - newRootIndex > 0
			if (end - 1 - newRootIndex > 0) {
				right = check(array, newRootIndex, end - 1);
			}

		} else {
			// 遇到没有找到的起概况，那就说明所有的数都比root小，那全在root的左节点下，
			// 所以left=check(array,start,end-1)
			left = check(array, start, end - 1);
		}
		return left && right;
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

【php】echo与var_dump
echo与var_dump的核心功能同样是没有区别的，皆为“输出变量的值”，但是echo偏向于产品，给客户看的，调试人员、编程人员更适合使用var_dump来输出变量，在调试的时候，告别难以使用的echo吧！
echo只能输出变量的值，var_dump能将变量的值与类型同时输出。
如果不做任何处理，在php中是无法直接输出一个数组的，需要用到一个for循环才可以，如果直接用echo输出一个数组，php会报错，但var_dump却是可以的，还输出得挺完美，无须通过任何的处理。
再有的就是类变量的输出，如果不作任何处理，echo同样是会报错的，var_dump则可以轻松输出。
用一个例子还说明这个问题，代码如下：
<?php
//对于普通变量的输出
$i=1;
echo $i;
echo "<br>";//华丽的分隔符，请忽略
var_dump($i);
echo "<br>";//华丽的分隔符，请忽略

//对于数组的输出
$arr=array(1,2,3);
echo $arr;//输出警告
echo "<br>";//华丽的分隔符，请忽略
var_dump($arr);
echo "<br>";//华丽的分隔符，请忽略

//对于类的输出
class Test{
	public $i="i";
	public $j="j";	
}
$test = new Test(); 
var_dump($test);
echo "<br>";//华丽的分隔符，请忽略
echo $test;//输出错误
echo "<br>";//华丽的分隔符，请忽略
?>输出结果如下：


可以看到var_dump对于变量、数组、类的输出，有着很好的表现，通过var_dump能够轻易地观察出变量、数组、类此时的值为多少。而echo则报错成狗，当然，在普通网页的输出，我们也不希望软件产品客户看到var_dump输出的信息，所以echo还是最基础的东西。

版权声明：本文为博主原创文章，未经博主允许不得转载。

正则表达式攻击实例 Regular Expressions Denial of Service


实施正则表达式评估程序及相关方法时存在漏洞，该漏洞会导致评估线程在处理嵌套和重复的正则表达式组的重复和交替重叠时挂起。这个缺陷可被攻击者用于执行 DOS (Denial of Service) 攻击。

仔细研究了一把，完全搞懂这种攻击是怎么回事了。直接上代码，看的很清楚
public class RegularExpressionsDOSExp
{
	 public static void main(String[] args)
	 {
	 String patterStr = "^(([a-z])+.)+[A-Z]([a-z])+$";
	 String paraStr = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
	
	 long startTime = System.currentTimeMillis();
	 final Pattern pattern = Pattern.compile(patterStr);
	 final Matcher matcher = pattern.matcher(paraStr);
	
	 matcher.find();
	
	 System.out.println(paraStr.length());
	 System.out.println("This takes " + (System.currentTimeMillis() -
	 startTime));
	 }
}
实测数据如下：

35个a，耗时950毫秒

40个a，耗时11242毫秒

貌似也没什么好的解决办法，只能通过入参和正则表达式的校验处理防御这种攻击。

另外想到一个方法就是起一个线程来跑正则，如果超时（比如2秒），就认为是受到攻击不是正常逻辑代码，然后终止线程。

版权声明：本文为博主原创文章，未经博主允许不得转载。

activemq与mysql持久化
1.去官网下载apache-activemq-5.11.1-bin.zip.解压。
2.找到conf下面的activemq.xml。



<persistenceAdapter>
            <jdbcPersistenceAdapter  dataDirectory="${activemq.base}/data" dataSource="#mysql-ds" useDatabaseLock="false"/> 
        </persistenceAdapter>替换
<persistenceAdapter>
            <kahaDB directory="${activemq.data}/kahadb"/>
        </persistenceAdapter>，在</broker>后添加如下代码：


<bean id="mysql-ds" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="com.mysql.jdbc.Driver"/> 
		<property name="url" value="jdbc:mysql://localhost:3308/activemq?relaxAutoCommit=true"/>
		<property name="username" value="root"/>
		<property name="password" value="419922"/> 
		<property name="poolPreparedStatements" value="true"/> 
	</bean> 

3.在本地数据库中创建名称为activemq的数据库。注意设置字符集为latin1 。
4.双击activemq.bat 启动activemq。然后数据库中就会生成三张表。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Wireless Network
Description
An earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The
 computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded
 as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B.


In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations.

Input
The first line contains two integers N and d (1 <= N <= 1001, 0 <= d <= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next
 N lines, each contains two integers xi, yi (0 <= xi, yi <= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following
 two formats:
1. "O p" (1 <= p <= N), which means repairing computer p.
2. "S p q" (1 <= p, q <= N), which means testing whether computer p and q can communicate.

The input will not exceed 300000 lines.

Output
For each Testing operation, print "SUCCESS" if the two computers can communicate, or "FAIL" if not.
Sample Input
4 1
0 1
0 2
0 3
0 4
O 1
O 2
O 4
S 1 4
O 3
S 1 4

Sample Output
FAIL
SUCCESS



题解：简单并查集。只需要把修好的和距离小于d的加入同一个集合就行了。


#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int pre[1005];
int X[1005];
int Y[1005]; 
int map[1003][1003];
bool good[1005];

int find(int x)
{
	return x == pre[x] ? x : find(pre[x]);
 } 

int cal(int x1,int y1,int x2,int y2)
{
	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
}

int main()
{
	int n,d;
	while(scanf("%d%d",&n,&d) != EOF)
	{
		for(int i = 1;i <= n;i++)
		{
			pre[i] = i;
		} 
		for(int i = 1;i <= n;i++)
		{
			scanf("%d%d",&X[i],&Y[i]);
			for(int j = 1;j < i;j++)
			{
				int t = cal(X[i],Y[i],X[j],Y[j]);
				map[i][j] = map[j][i] = t;
			}
		}
		
		memset(good,false,sizeof(good));
		char s[10];
		int u,v;
		d *= d;
		while(scanf("%s",s) != EOF)
		{
			if(s[0] == '#')
			{
				break;
			}
			if(s[0] == 'O')
			{
				scanf("%d",&u);
				good[u] = true;
				for(int i = 1;i <= n;i++)
				{
					if(map[u][i] <= d && good[i])
					{
						int x = find(i);
						int y = find(u);
						if(x != y)
						{
							pre[y] = x; 
						}
					}
				}
			}
			else
			{
				scanf("%d%d",&u,&v);
				int x = find(u);
				int y = find(v);
				if(x == y)
				{
					printf("SUCCESS\n");
				}
				else
				{
					printf("FAIL\n");
				}
			}
		}
	}
	
	
	return 0;
 } 


版权声明：本文为博主原创文章，未经博主允许不得转载。

STL面试常问
1：介绍一下STL，具体说明STL如何实现vector？
STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库中，包括容器、算法、迭代器组件。 
vector内部使用动态数组的方式实现的。如果动态数组的内存不够用，就要动态的重新分配，一般是当前大小的两倍，然后把原数组的内容拷贝过去。所以，在一般情况下，其访问速度同一般数组，只有在重新分配发生时，其性能才会下降。它的内部使用allocator类进行内存管理，程序员不需要自己操作内存。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1051 Wooden Sticks
题目大意：
        有一堆木棍要放到机器里面处理，第一根放进去的木棍需要1分钟的调整机器的时间，如果后续放进的木根的长度比它长且重量比它重，则不需要重新调整机器，否则要花1分钟时间来再次调整。给出这一堆木根的各自的长度和重量，求需要的最少的时间。


解题思路：
        考虑可以将木根排序，以长为第一要素，长度相同时参考重量，贪心算法，按升序排列。由于要标记木根是否已经被处理过，所以在存储木根信息的结构以中再加入一个标志位flag，初始化为0。每次从前往后找没处理过的木棍。值得注意的是，每次选定了一个木棍初始化了之后，再判断接下的k根木棍是不是能直接加工是比较的是前一个加工完的木棍，而不是本次选来初始化机器的木棍的长度和重量，具体见代码中注释了“important"的那句，也就是用cur记录每次比较对象的下标。


代码如下：
# include <iostream>
# include <algorithm>
using namespace std;

struct node
{
	int l;
	int w;
	int flag;
}stick[50003];

int cmp(struct node a,struct node b)
{  
	if(a.l!=b.l)
	return a.l<b.l;
	else
	return a.w<b.w;
}

int main()
{
	freopen("input.txt","r",stdin);
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		int i,j;
		memset(stick,0,sizeof(stick));
		for(i=0;i<n;i++)
		{
			scanf("%d %d",&stick[i].l,&stick[i].w);
		}
		sort(stick,stick+n,cmp);

		int count=0;
		int cur;
		for(i=0;i<n;i++)
		{
			if(stick[i].flag==0)
			{
				count++;
				cur=i;
			for(j=i+1;j<n;j++)
			{
				if(stick[j].flag==0  && stick[j].w>=stick[cur].w)
				{
					stick[j].flag=1;
					cur=j;//important
				}
			}
			}	
		}
		printf("%d\n",count);
	}
	return 0;
}

        

版权声明：本文为博主原创文章，未经博主允许不得转载。

python 流程控制
python 流程控制

if-else 语句

if语句举例：

>>> if 1<'a':
...     print "chen"
...
chen

逻辑值（bool）用来表示：对与错，真与假，空与非空等概念。
逻辑值包含了两个值： 
True：表示非空的量（比如string，tuple，list，set，dictionary等） 
False：表示0，None，空的量
作用：主要用于判断语句中，用来判断 
一个字符串是否是空得
一个运算结果是否为0
一个表达式是否可用

>>> a = "0"
>>> if a:
...     print "not null"
...
not null

>>> a = 0
>>> if a:
...     print "chen"
... else:
...     print "ok!"
...
ok!

else 语句可以有多个

#!/usr/bin/python

while 1:
    x = int (raw_input("please input :"))
    if x >= 90:
        print "x >= 90"
    elif x >= 80:
        print "90 > x >= 80"
    elif x >= 60:
        print "80 > x >= 60"
    else :
        print "< 60"
        break
逻辑运算符

if 后面的条件语句，可以用and，or，或者not
and表示两个条件同时成立
or有一个成立既可以
not条件值取反 

>>> True and False
False
>>> 1 and 1 and 0
0
>>> True or 0
True
>>> True or 0 or False
True
>>> True and 0 or False
False
for 循环
>>> a = (1,3,4,78,12)
>>> for i in a:
...     print i
...
1
3
4
78
12
>>> for i in "ads87":
...     print i
...
a
d
s
8
7
range(i,j,步进值)
注意： 
i 是起始值，包括在内 
j 是终止值，不包括在内 
（类似于切片）
>>> for i in range(1,4):
...     print i
...
1
2
3

步进值演示如下：

>>> for i in range(1,10,2):
...     print i
...
1
3
5
7
9
range 可以产生一个序列：
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
遍历字典
>>> a = {1:11,2:22,3:33,4:44}
>>> for i in a:
...     print i
...
1
2
3
4

可以看出来，这样遍历的只是字典的键值，那么就可以通过a[键值]的方式来访问字典。
其实另一种方法也可以。

>>> a.items()
[(1, 11), (2, 22), (3, 33), (4, 44)]
>>> for i in a.items():
...     print i
...
(1, 11)
(2, 22)
(3, 33)
(4, 44)
>>> for key,value in a.items():
...    print key
...    print value
...
1
11
2
22
3
33
4
44
循环控制

for 也可以和else 搭配~

>>> for i in range(10):
...     pass
... else:
...     print "end~"
...
end~

有什么卵用呢？
就是，当程序非正常执行的时候，就不会出现else中的内容。或者break跳出的时候也不会执行else中的内容

>>> import time
>>> for i in range(10):
...     print i
...     time.sleep(2)
... else:
...     print "ok"
...
0
1
2
^CTraceback (most recent call last):
  File "<stdin>", line 3, in <module>
KeyboardInterrupt
>>> for i in range(10):
...     if i > 4:
...         break
... else:
...     print "end"
...

break 跳出循环
continue 结束此次循环，进入下次循环
exit（）结束整个程序
pass 占位，相当于空语句


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU1009 FatMouse' Trade
题目大意：
        一直老鼠想吃咖啡豆，这些咖啡豆由一只猫来看守，它需要用它有的猫粮来换。
       读入两个整数m，n分别代表老鼠有的猫粮的总数，和放着咖啡豆的房间数。接下来n行，每行两个数j[i],f[i],分别代表这个房间中的总的咖啡豆的数量和需要的猫粮数，求出这时老鼠可获得的最大的猫粮数，知道接收到-1，-1结束处理。


解题思路：
        典型的贪心问题中的分数背包问题。由于可以取得房间中的咖啡豆的任意部分，所以转化为分数背包为题，求出每个房间的咖啡豆的单价，我是求出了单位重量的猫粮可以换取的咖啡豆，这样我觉得可以方便计算，然后将这个量按照这个量降序排列（优先选择单位重量可以换取的数量最大的咖啡豆）。


代码如下：
# include <iostream>
# include <algorithm>
using namespace std;

struct node
{
	int a,b;
	double price;
}List[1001];

bool cmp(node x,node y)
{
	return x.price>y.price;
}
int main()
{
	freopen("input.txt","r",stdin);
	int m,n;
	while(scanf("%d%d",&m,&n)!=EOF && m!=-1 && n!=-1)
	{
		memset(List,0,sizeof(List));
		int i,j;
		for(i=0;i<n;i++)
		{
			scanf("%d%d",&List[i].a,&List[i].b);
			List[i].price=(double)List[i].a/List[i].b;
		}
		sort(List,List+n,cmp);
		double maxS=0;
		for(i=0;i<n;i++)
		{
			if(m>=List[i].b)
			{
				maxS=maxS+List[i].a;
				m=m-List[i].b;
			}
			else
			{
				maxS=maxS+m*List[i].price;
				m=0;
				break;
			}
		}
		printf("%.3lf\n",maxS);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1808 Halloween treats 抽屉原理
虽然题目讲了那么多，最后只是让你找出可以整除c的集合。应该是spj程序有问题，你直接输出零都是对的。 
因为题目中c保证小于n，所以根据抽屉原理，一定存在一个连续的区间，满足题目要求。
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <math.h>
#include <stdlib.h>
#include <time.h>
using namespace std;

int a[100000+5],f[100000+5];
int main()
{
    int i,j,c,n,sum,t,st;
    while(~scanf("%d%d",&c,&n))
    {
        if(c==0&&n==0) break;
        for(i=1;i<=n;i++)
            scanf("%d",&a[i]);
        memset(f,0xff,sizeof(f));
        st=0;
        sum=0;
        for(i=1;i<=n;i++)
        {
            sum+=a[i];
            t=sum%c;
            sum=sum%c;
            if(t==0)
            {
                for(j=1;j<i;j++)
                    printf("%d ",j);
                printf("%d\n",j);
                break;
            }
            else if(f[t]!=-1)
            {
                for(j=f[t]+1;j<i;j++)
                    printf("%d ",j);
                printf("%d\n",j);
                break;
            }
            f[t]=i;
        }
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。http://xiang578.top/

C语言进阶：整型提升
几乎每个程序员都学过C，而且大多数在他们的工作中使用C。很显然C是TIOBE（2012年11月时排榜首）上最流程的编程语言之一。然而，有时，C的行为会让人意外和困惑。其中一个例子就是**整型提升**。请看下面这个例子：

#include <stdio.h>

int main(void)
{
    unsigned char a = 0xff;
    char b = 0xff;
    int c = a==b; // true, or false?
    printf("C: %d\n",c);
}
你可能认为输出是`1`.其实是`0`。噢！

C99标准
在K&R和C89的早期实现中，基于`short`和`char`的算术运算陷入两难的困境，因为可能会产生两种不同的结果。因此，在C99中很明确地定义了整型提升的规则（6.3.1.1）：


如果int能够表示原始类型中的所有数值，那么这个数值就被转成int型，否则，它被转成unsigned int型。这种规则被称为整型提升。所有其它类型都不会被整型提升改变。

让我们回忆一下整型的范围：


signed char: -127 -> 127
unsigned char: 0 -> 255
signed short: -32767 -> 32767
unsigned short: 0 -> 65535
signed int: -2147483647 -> 2147483647
可以看出有符号或者无符号的char、short都可以被signed int表示，所以当它们作算术运算时，都会被转成signed int。 
在前面的例子中， unsigned char a = 0xff 的值是255。但是， char b = 0xff 的值是-1。当它们都被转为int类型时，a 仍然是255，即 0x000000ff， 而b却变成0xffffffff ，代表整型中的-1。以下代码可以证明：

#include <stdio.h>

int main(void)
{
    unsigned char a = 0xff;
    char b = 0xff;
    printf("A: %08x, B: %08x\n", a, b);
    return 0;
}
输出结果是：

A: 000000ff, B: ffffffff
这就是为什么表示是`a==b`的结果是`0`。

从汇编层面理解
当我第一次听说整型提升时，我更加困惑：为什么会有这么奇怪的规则？想要知道为什么这样设计，你必须从汇编代码中挖掘原因。
从一个简单的例子开始：

int main(void)
{
    unsigned char a = 0xff;
    char b = 0xff;
    int c = a + b;
    return 0;
}
反汇编结果是：

movl    $0, -4(%rbp)        # The return value of main is 0
movb    $-1, -5(%rbp)       # unsigned char a = 0xff;
movb    $-1, -6(%rbp)       # char b = 0xff;
movzbl  -5(%rbp), %eax
movsbl  -6(%rbp), %ecx
addl    %eax, %ecx          # int c = a + b
movl    %ecx, -12(%rbp)     # store c onto the stack
movl    -4(%rbp), %eax
popq    %rbp
ret                         # return value 0 from eax
如果你的GAS语法不熟悉，可以查看X86 Assembly/GAS Syntax。GAS语法指令通常以“b”, “s”, “w”, “l”, “q” 和“t” 为后缀，以区分操作数在大小。


b = byte (8 bit)
s = short (16 bit integer) or single (32-bit floating point)
w = word (16 bit)
l = long (32 bit integer or 64-bit floating point)
q = quad (64 bit)
t = 10 bytes (80-bit floating point)
GAS语法中的mov是把参数从左边移到右边。例如： movl $0, -4(%rbp)的意思是把 0x00000000 移到地址 -4(%rbp)处。 
指令 movzbl 表示把一个byte变成long并将空位零填充 。movzbl -5(%rbp), %eax 把 0xff 移到寄存器 %eax 上，并把空位补0。寄存器 %eax 的值变成了 0x000000ff。 
指令 movsbl 表示把一个byte变成long并将空位符号填充。movsbl -6(%rbp), %ecx 把 0xff 移到寄存器 %eax ，然后把空位补成有符号的数值，这使得寄存器 %ecx 值变为 0xffffffff。最后， addl %eax, %ecx 执行加法操作， movl %ecx, -12(%rbp) 把结果存到栈上。 
现在，你可以把整型提升理解为把C语言类型直接映射到机器指令的一种机制了。所有算术操作的操作数被转成有符号或无符号int后，都会被当作一个小的int的计算。你可以这么想：尽管short和char只占一两个字节，当它们在进行算术运算时，都是当作int的。这种转成int规则被称为整型提升。

总结
通常情况下，在对int类型的数值作运算时，CPU的运算速度是最快的。在x86上，32位算术运算的速度比16位算术运算的速度快一倍。C语言是一个注重效率的语言，所以它会作整型提升，使得程序的运行速度尽可能地快。因此，你必须记住整型提升规则，以免发生一些整型溢出的问题。

作者：dryman (Felix Ren-Chyan Chern) 
时间：11/21/2012

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
Mac配置全局 Composer
当我配置composer时候看到一个教程，先去网上下载composer.phar, 然后拷贝到/usr/local/bin目录下，把composer.phar加到PATH里边，然后切到项目目录下，在项目目录下创建一个composer.json文件，指明依赖，比如，你的项目依赖 monolog：

{
    "require": {
        "monolog/monolog": "1.2.*"
    }
}然后运行


php composer.phar install很不幸，报错了，
Could not open input file: composer.phar怎么办呢，查资料，在网上找答案

第一步：首先从/usr/local/bin 删除composer.phar文件。如果不删的话会报错。
第二步：重新下载一下，看如下命令

cd /usr/local/bin
curl -sS https://getcomposer.org/installer | php

Composer successfully installed to: /usr/local/bin/composer.phar
Use it: php composer.phar

# 修改一下 composer.phar 文件的权限
sudo chmod a+x composer.phar第三步：切回项目目录，执行如下命令


composer.phar install

会下载很多文件，此时就会把依赖的包下载下来。之后会在项目目录下生成vendor目录，就大功告成了。








版权声明：本文为博主原创文章，未经博主允许不得转载。

Effective C++——导读(第0章)
第0章   导读 
术语 (Terminology) 
    下面是每一位程序员都应该了解的一份小小的C++词汇,其中的术语十分重要。 
    所谓声明式(declaration)是告诉编译器某个东西的名称和类型,但忽略细节,下面是声明式: 
extern int x;                           // 对象object声明式
std::size_t numDigits(int number);      // 函数function声明式
class Widget;                           // 类class声明式
template <typename T>                   // 模板template声明式
class GraphNode;                        // typename的使用条款     每个函数的声明揭示其签名式signature,也就是参数和返回类型。一个函数的签名等同于该函数的类型。numDigits函数的签名式std::size_t (int),也就是说"这个函数获得一个int并返回一个std::sizt_t".

    定义式(definition)的任务是提供编译器一些声明式所遗漏的细节.对对象而言,定义式是编译器为此对象所分配内存的地点.对function或function template 而言,定义式提供了代码本体.对 class 或 class template 而言,定义式列出它们的成员:

int x;                                  // 对象的定义式
std::size_t numDigits(int number) {     // 函数的定义式
    std::size_t digitsSoFar = 1;        // 此函数返回其参数的数字个数
    while ((number /= 10) != 0)
        ++digitsSoFar;
    return digitsSoFar;
}
class Widget {                          // class的定义
public:
    Widget();
    ~Widget();
    ...
};
template <typename T>                   // template的定义
class GraphNode {
public:
    GraphNode();
    ~GraphNode();
    ...
}; 
    初始化是"给予对象初始值"的过程.对用户自定义类型的对象而言,初始化由构造函数执行.所谓default构造函数是一个可以被调用而不带任何实参.这样的构造函数或者没有参数,或者就是每个参数都有缺省值:

class A {
public:
    A();                                // default构造函数
};
class B {
public:                                 // default构造函数
    explicit B(int x = 0, bool b = true);
};
class C {
public:
    explicit C(int x);                  // 不是default构造函数
};    上述的 class B和C的构造函数都被声明为 explicit,这可阻止它们被用来执行隐式类型转换(implicit type conversions),但它们仍可被用来进行显式类型转换(explicit type conversions):

void doSomething(B bObject);            // 函数接受一个类型为B的对象
B bObj1;                     
doSomething(bObj1);                     // ok
B bObj2(28);
doSomething(28);                        // error.int到B之间没有隐式转换
doSomething(B(28));                     // ok.使用B构造函数将int显式转换为一个B    被声明为 explicit 的构造函数通常比non-explicit更受欢迎,因为它们禁止编译器执行非预期的类型转换.

    copy构造函数被用来"以同型对象初始化自我对象",copy assignment操作符被用来"从另一个同型对象中拷贝其值到自我对象": 

class Widget {
public:
    Widget();                               // default构造函数
    Widget(const Widget &rhs);              // copy构造函数
    Widget &operator=(const Widget &rhs);   // copy assignment操作符
    ...
};
Widget w1;                                  // 调用default构造函数
Widget w2(w1);                              // 调用copy构造函数
w1 = w2;                                    // 调用copy assignment操作符    当看到赋值符号时请小心,因为"="语法也可用来调用copy构造函数: 
Widget w3 = w2;                             // 调用copy构造函数     幸运的是"copy构造"很容易和"copy赋值"有所区别.如果一个新对象被定义(例如以上语句中的w3),一定会有个构造函数被调用,不可能调用赋值操作.如果没有新对象被定义,就不会有构造函数被调用,那么赋值操作会被调用.

    copy构造函数是一个非常重要的函数,因为它定义一个对象如何passed by value.考虑以下代码: 
bool hasAcceptableQuality(Widget w);
...
Widget aWidget;
if (hasAcceptableQuality(aWidget))
    ...    参数w是以by value方式传递给hasAcceptableQuality,所以在上述调用中aWidget被复制到w体内.这个复制动作由Widget的copy构造函数完成.pass-by-value意味着"调用copy构造函数".以by value传递用户自定义类型通常是一个坏主意,pass-by-reference-to-const 往往是比较好的选择.

    STL(standard template library)致力于容器,迭代器,算法以及相关机能.许多相关机能以函数对象实现,那是"行为像函数"的对象.这样的对象来自于重载operator()的 class.

 
命名习惯 (Naming Conventions) 
    参数名称lhs和rhs分别代表left-hand side和right-hand side.下面的表达式: 
a *b     等价于以下的函数调用: 
operator *(a, b)     声明operator *如下: 
const Rational operator *(const Rational &lhs, const Rational &rhs);     对于成员函数,左侧实参由 this 指针表现出来,所以有时单独使用参数名称rhs. 
    将"指向一个T类型对象"的指针命名为pt,意思是"pointer to T".例如: 
Widget *pw;
class Airplane;
Airplane *pa;


版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 1159 Palindrome(DP LCS)
Description
A palindrome is a symmetrical string, that is, a string read identically from left to right as well as from right to left. You are to write a program which, given a string, determines the minimal number of characters to be inserted
 into the string in order to obtain a palindrome.

As an example, by inserting 2 characters, the string "Ab3bd" can be transformed into a palindrome ("dAb3bAd" or "Adb3bdA"). However, inserting fewer than 2 characters does not produce a palindrome.

Input
Your program is to read from standard input. The first line contains one integer: the length of the input string N, 3 <= N <= 5000. The second line contains one string with length N. The string is formed from uppercase letters
 from 'A' to 'Z', lowercase letters from 'a' to 'z' and digits from '0' to '9'. Uppercase and lowercase letters are to be considered distinct.

Output
Your program is to write to standard output. The first line contains one integer, which is the desired minimal number.
Sample Input
5
Ab3bd
Sample Output
2


题目大意：求插入最少的字符使得串为palindeome（回文串）。
遇到问题要剖析其原型，此题就是正序和逆序的LCS，结果来n-commenlength.


#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define LL long long
#define inf 0x3f3f3f3f
using namespace std;
short dp[5001][5001];
char a[5005],b[5005];
int main()
{
    int n,m,x,k,i,j;
    int cla;
    while(~scanf("%d",&n))
    {
        int s=0;
        dp[0][0]=0;<span id="transmark"></span>
        scanf("%s",a);
        for(i=n-1;i>=0;i--)
        b[s++]=a[i];
        b[s]='\0';
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                if(a[i-1]==b[j-1])
                {
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                else
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
        cout<<n-dp[n][n]<<endl;
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1026 Ignatius and the Princess I(bfs搜索+输出路径)
题目来源：hdu-1026 Ignatius and the Princess I 
Ignatius and the Princess I 
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others) 
Total Submission(s): 14677    Accepted Submission(s): 4653 
Special Judge
Problem Description 
The Princess has been abducted by the BEelzebub feng5166, our hero Ignatius has to rescue our pretty Princess. Now he gets into feng5166’s castle. The castle is a large labyrinth. To make the problem simply, we assume the labyrinth is a N*M two-dimensional array which left-top corner is (0,0) and right-bottom corner is (N-1,M-1). Ignatius enters at (0,0), and the door to feng5166’s room is at (N-1,M-1), that is our target. There are some monsters in the castle, if Ignatius meet them, he has to kill them. Here is some rules:
1.Ignatius can only move in four directions(up, down, left, right), one step per second. A step is defined as follow: if current position is (x,y), after a step, Ignatius can only stand on (x-1,y), (x+1,y), (x,y-1) or (x,y+1). 
2.The array is marked with some characters and numbers. We define them like this: 
. : The place where Ignatius can walk on. 
X : The place is a trap, Ignatius should not walk on it. 
n : Here is a monster with n HP(1<=n<=9), if Ignatius walk on it, it takes him n seconds to kill the monster.
Your task is to give out the path which costs minimum seconds for Ignatius to reach target position. You may assume that the start position and the target position will never be a trap, and there will never be a monster at the start position.
Input 
The input contains several test cases. Each test case starts with a line contains two numbers N and M(2<=N<=100,2<=M<=100) which indicate the size of the labyrinth. Then a N*M two-dimensional array follows, which describe the whole labyrinth. The input is terminated by the end of file. More details in the Sample Input.
Output 
For each test case, you should output “God please help our poor hero.” if Ignatius can’t reach the target position, or you should output “It takes n seconds to reach the target position, let me show you the way.”(n is the minimum seconds), and tell our hero the whole path. Output a line contains “FINISH” after each test case. If there are more than one path, any one is OK in this problem. More details in the Sample Output.
Sample Input 
5 6 
.XX.1. 
..X.2. 
2…X. 
…XX. 
XXXXX. 
5 6 
.XX.1. 
..X.2. 
2…X. 
…XX. 
XXXXX1 
5 6 
.XX… 
..XX1. 
2…X. 
…XX. 
XXXXX.
Sample Output 
It takes 13 seconds to reach the target position, let me show you the way. 
1s:(0,0)->(1,0) 
2s:(1,0)->(1,1) 
3s:(1,1)->(2,1) 
4s:(2,1)->(2,2) 
5s:(2,2)->(2,3) 
6s:(2,3)->(1,3) 
7s:(1,3)->(1,4) 
8s:FIGHT AT (1,4) 
9s:FIGHT AT (1,4) 
10s:(1,4)->(1,5) 
11s:(1,5)->(2,5) 
12s:(2,5)->(3,5) 
13s:(3,5)->(4,5) 
FINISH 
It takes 14 seconds to reach the target position, let me show you the way. 
1s:(0,0)->(1,0) 
2s:(1,0)->(1,1) 
3s:(1,1)->(2,1) 
4s:(2,1)->(2,2) 
5s:(2,2)->(2,3) 
6s:(2,3)->(1,3) 
7s:(1,3)->(1,4) 
8s:FIGHT AT (1,4) 
9s:FIGHT AT (1,4) 
10s:(1,4)->(1,5) 
11s:(1,5)->(2,5) 
12s:(2,5)->(3,5) 
13s:(3,5)->(4,5) 
14s:FIGHT AT (4,5) 
FINISH 
God please help our poor hero. 
FINISH
题目大意： 
       输入一个字符型的迷宫，要从左上角走到右下角，求所需的最短时间及所走路线，每一步只能走上、下、左、右，不能斜着走，图为’.’表示可以走，并且每步花费时间为1秒，当图为’数字‘时表示需要花费数字秒时间停留，故走过此处需花费时间为：map[][]-‘0’+1;若图为’X’，表示不可走。 
题目分析： 
       此题为迷宫搜索求最短路题，并且输出要包括路径，算是典型的搜索题吧。此题我使用的是bfs搜索，首先需建立一个结构体用来存放走到每个位置的坐标及花费的总时间，使用bfs当然就要用优先队列，在此队列中，把花费时间少的放在队首；另外需要建立一个结构体用来存放所走的最短路线；然后在找到最短路径时依次输出路径即可。 
AC代码：
#include<stdio.h>
#include<string.h>
#include<queue>
#define MAX 110
using namespace std;
char map[MAX][MAX];
int mark[MAX][MAX];
int dx[4]={1,-1,0,0};               //表示x下一步可走的方向 
int dy[4]={0,0,1,-1};               //表示y下一步可走的方向 
struct node{
    int x,y;
    int time;
    friend bool operator < (node a,node b)
    {
        return a.time > b.time;         //优先队列，输出时间短的 
    }
};
struct Edge{
    int px;
    int py;                             //用来存放前驱坐标 
};
node edge[MAX];
Edge pre[MAX][MAX];
int n,m;

void bfs(int sx,int sy)
{
    mark[sx][sy]=1;         //标记走过的坐标 
    node now,next;          //定义两个结构体，表示当前点与下一个点 
    pre[sx][sy].px=-1;      //标记终点 
    now.x=sx;
    now.y=sy;
    now.time=0;
    if(map[sx][sy]!='.')            
        now.time=map[sx][sy]-'0';
    priority_queue<node>q;  //定义优先队列 
    q.push(now);
    while(!q.empty())
    {
        now=q.top();
        q.pop();
        if(now.x==0&&now.y==0)      //若查找到起点，表明查找结束 
        {
            printf("It takes %d seconds to reach the target position, let me show you the way.\n",now.time);
            int key=1,total=now.time;
            sx=now.x,sy=now.y;
            while(pre[sx][sy].px!=-1)   //不断找前驱坐标，直至找到终点 
            {
                int tx=pre[sx][sy].px;
                int ty=pre[sx][sy].py;
                printf("%ds:(%d,%d)->(%d,%d)\n",key++,sx,sy,tx,ty);
                if(map[tx][ty]!='.')
                    for(int i=0;i<map[tx][ty]-'0';i++)
                        printf("%ds:FIGHT AT (%d,%d)\n",key++,tx,ty);
                sx=tx;
                sy=ty;
            }
            return ;
        }
        for(int i=0;i<4;i++)    //若还未查找完毕，将此点扩展出的所有满足题意的点入队列 
        {
            next.x=now.x+dx[i];
            next.y=now.y+dy[i];
            if(next.x<0||next.x>=n)
                continue;
            if(next.y<0||next.y>=m)
                continue;
            if(mark[next.x][next.y])
                continue;
            mark[next.x][next.y]=1;
            if(map[next.x][next.y]=='X')
                continue;
            if(map[next.x][next.y]=='.')
                next.time=now.time+1;
            else
                next.time=now.time+map[next.x][next.y]-'0'+1;
            pre[next.x][next.y].px=now.x;   //此处用来存放路径
            pre[next.x][next.y].py=now.y;
            q.push(next); 
        }
    }
    printf("God please help our poor hero.\n");
}
int main()
{
    while(scanf("%d%d",&n,&m)!=EOF)
    {   
        getchar();
        memset(mark,0,sizeof(mark));        //初始化标记数组 
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
                scanf("%c",&map[i][j]);     //存入图 
            getchar();
        }
        bfs(n-1,m-1);                       //从后向前查找，则输出的时候从前往后输出即是路径 
        printf("FINISH\n");
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【华为OJ平台练习题】Ascii码排序
//描述	
//Lily上课时使用字母数字图片教小朋友们学习英语单词，每次都需要把这些图片按照大小（ASCII码值从小到大）排列收好。请大家给Lily帮忙，通过C语言解决。
// 
//
//知识点	字符串
//运行时间限制	0M
//内存限制	0
//输入	
//Lily使用的图片包括"A"到"Z"、"a"到"z"、"0"到"9"。输入字母或数字个数不超过1024。
// 
//
//输出	
//Lily的所有图片按照从小到大的顺序输出
// 
//
//样例输入	Ihave1nose2hands10fingers
//样例输出	0112Iaadeeefghhinnnorsssv

#include <iostream>
using namespace std;
void Ascii_Sort(char* s)
{
	int lenS = strlen(s);
	for(int a = 0;a<lenS;a++)
	{
		for(int b = 0;b<lenS-a-1;b++)
		{
			if(s[b]>s[b+1])
			{
				char temp = s[b];
				s[b] = s[b+1];
				s[b+1] = temp;
				temp = NULL;
			}
		}
	}
		cout<<s<<endl;
}

int main()
{
	cout<<"输入一个字符串：";
	char s[30];
	cin.getline(s,30);
	Ascii_Sort(s);
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

使用JNDI的方式配置c3p0连接池


      JNDI的配置方式，可以在容器上配置数据源，让数据源的配置不再是依靠 spring的applicationContext.xml。通过这种方式，也可以配置dbcp等其他连接池。
      1 在tomcat的context.xml里的<context>标签添加<Resource>标签：
<Resource name="jdbc/TestDB" 
	        auth="Container" 
	       factory="org.apache.naming.factory.BeanFactory"
	       type="com.mchange.v2.c3p0.ComboPooledDataSource"
	       driverClass="oracle.jdbc.driver.OracleDriver"
               jdbcUrl="jdbc:oracle:thin:@localhost:1521:XE"
               user="orcl"
               password="newsnews"/>


不同数据源的 driverClass，jdbcUrl等 属性不同，依照连接池自身的属性配置，这里是使用的c3p0数据源，若使用其他数据源要修改属性；
   2 在项目的web.xml添加：
<resource-ref>
    <description>DB Connection</description>
    <res-ref-name>jdbc/TestDB</res-ref-name>
    <res-type>javax.sql.DataSource</res-type>
    <res-auth>Container</res-auth>
 </resource-ref>


res-ref-name引入context.xml里配置的Resource,res-type都设置为javax.sql.DataSource；
3 在spring的applicationContext.xml配置里添加：
	<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
		<property name="jndiName" value="java:/comp/env/jdbc/TestDB" />
	</bean>






﻿﻿
LeetCode（30） Substring with Concatenation of All Words
题目
You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.
For example, given: 
s:  “barfoothefoobarman” 
words:  [“foo”, “bar”]
You should return the indices: [0,9]. 
(order does not matter).
分析
解决该问题的关键是理解清楚要求。 
给定一个目标字符串s，一个单词集合words。 
要求使得words集合中所有元素连续出现在s中的首位置组成的集合（元素顺序不考虑）。
正如所给实例，目标字符串s:  “barfoothefoobarman” 
对比单词集合words:  [“foo”, “bar”] 
我们发现，在pos=0 ~ 5时“barfoo”恰好匹配，则0压入结果vector； 
在pos=9 ~ 14时“foobar”恰好匹配，则9压入结果vector；
在理清楚题意后，便可入手程序实现。
AC代码
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        if (words.empty())
            return vector<int>();

        vector<int> ret;
        //记录所给words中每个单词的出现次数
        map<string, int> word_count;


        //每个单词的长度相同
        int word_size = strlen(words[0].c_str());
        int word_nums = words.size();
        //所给匹配字符串的长度
        int s_len = strlen(s.c_str());

        for (int i = 0; i < word_nums; i++)
            ++word_count[words[i]];

        int i, j;
        map<string, int> temp_count;
        for (i = 0; i < s_len - word_nums*word_size + 1; ++i)
        {
            temp_count.clear();
            for (j = 0; j < word_nums; j++)
            {
                //检验当前单词是否属于words以及出现的次数是否一致
                string word = s.substr(i + j*word_size, word_size);
                if (word_count.find(word) != word_count.end())
                {
                    ++temp_count[word];
                    //如果出现的次数与words不一致，则返回错误
                    if (temp_count[word] > word_count[word])
                        break;
                }//if
                else{
                    break;
                }//else                 
            }//for
            //所有words内的单词,在i起始位置都出现，则将下标i存入结果的vector中
            if (j == word_nums)
            {
                ret.push_back(i);
            }//if
        }//for
        return ret;
    }
};
GitHub测试程序源码

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Lowest Bit
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 9707    Accepted Submission(s): 7128


Problem Description
Given an positive integer A (1 <= A <= 100), output the lowest bit of A.

For example, given A = 26, we can write A in binary form as 11010, so the lowest bit of A is 10, so the output should be 2.

Another example goes like this: given A = 88, we can write A in binary form as 1011000, so the lowest bit of A is 1000, so the output should be 8.

 

Input
Each line of input contains only an integer A (1 <= A <= 100). A line containing "0" indicates the end of input, and this line is not a part of the input data.

 

Output
For each A in the input, output a line containing only its lowest bit.

 

Sample Input

26
88
0

 

Sample Output

2
8
超级水题#include<stdio.h>
int main()
{
	int n,a[500];
	while(scanf("%d",&n),n)
	{
		int i,j;
		for( i=0;n>0;i++)
		{
			a[i]=n%2;
			n=n/2;
		}
		int sum=1;
		for(j=0;a[j]!=1;j++)
		sum*=2;
		printf("%d\n",sum);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

使用netbeans工具查看JVM源码（上）
首先我们来说一下JDK的问题，一般我们用的是oracle的JDK，这边我们要查看编译的是OpenJDK。先看一下两者之间的关系：



从上面可以看到，黑色部分是代码一致的，So,两者之间的源代码大部分是一样的。
1、下载OpenJDK的源码：
下载地址：
http://www.java.net/download/openjdk/jdk7u40/promoted/b43/openjdk-7u40-fcs-src-b43-26_aug_2013.zip
2、下载netbeans，我这边选择是centOS系统：（前面有说过，玩转Linux才是java开发者逼格的一种方式）
http://download.netbeans.org/netbeans/8.0.2/final/bundles/netbeans-8.0.2-cpp-linux.sh

这边一定要下载for C/C++版的，具体为什么呢？自己想吧~



3、导入JVM代码项目：


Next-->


Next-->


Next-->




构建命令修改为：
${MAKE} -f Makefile clean jvmg ALT_BOOTDIR=/usr/java/jdk1.7.0_79 ARCH_DATA_MODEL=64 LANG=C
其中ARCH_DATA_MODEL指定的是64位系统。
后面一直Next下去，点击完成即可




此时控制台会出现编译错误，这是因为一些参数什么都还没设置好。这样子项目就已经导入好了。
下一节再讲解编译构建。




版权声明：本文为博主原创文章，未经博主允许不得转载。

java初学者学习教程——01 java基本概念
java初学者专题教程：01
 java基本概念
学习java前，我们首先需要了解什么是java，java能够干什么，能够解决实际生活中具体什么问题
我们看如下图




java包含：JAVASE、JAVAEE、JAVAME

首先看下比较官方对着三类的解释
     * Java SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java
 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。
    * Java EE（Java Platform，Enterprise Edition）。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。
    * Java ME（Java Platform，Micro Edition）。这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。



通俗的说：
    SE主要用于桌面程序,控制台开发(JFC)。就是相当于我们使用windows系统时，桌面上使用的QQ软件一样
     EE企业级开发(JSP,EJB)，这个是服务端开发，主要是基于c/s开发web程序，比如一般的银行系统的网站都是使用java开发的
     ME嵌入式开发(手机,小家电)，现在智能手机基本在国内已经普及，安卓与苹果，学好ME嵌入式开发，那我们就可以去开发安卓上的软件应用等


原文地址：http://www.javalearn.net/article-25-1.html

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU  1050.Moving Tables【细节与方法选取】【8月26】
Moving Tables


Problem Description

The famous ACM (Advanced Computer Maker) Company has rented a floor of a building whose shape is in the following figure. 




The floor has 200 rooms each on the north side and south side along the corridor. Recently the Company made a plan to reform its system. The reform includes moving a lot of tables between rooms. Because the corridor is narrow and all the tables are big, only
 one table can pass through the corridor. Some plan is needed to make the moving efficient. The manager figured out the following plan: Moving a table from a room to another room can be done within 10 minutes. When moving a table from room i to room j, the
 part of the corridor between the front of room i and the front of room j is used. So, during each 10 minutes, several moving between two rooms not sharing the same part of the corridor will be done simultaneously. To make it clear the manager illustrated the
 possible cases and impossible cases of simultaneous moving. 




For each room, at most one table will be either moved in or moved out. Now, the manager seeks out a method to minimize the time to move all the tables. Your job is to write a program to solve the manager’s problem.


 


Input

The input consists of T test cases. The number of test cases ) (T is given in the first line of the input. Each test case begins with a line containing an integer N , 1<=N<=200 , that represents the number of tables to move. Each of the following N lines contains
 two positive integers s and t, representing that a table is to move from room number s to room number t (each room number appears at most once in the N lines). From the N+3-rd line, the remaining test cases are listed in the same manner as above.


 


Output

The output should contain the minimum time in minutes to complete the moving, one per line.


 


Sample Input

3 
4 
10 20 
30 40 
50 60 
70 80 
2 
1 3 
2 200 
3 
10 100 
20 80 
30 50 


 


Sample Output

10
20
30


 


这个题要注意1--3跟2--4公用一段走廊。第一想法是用区间合并的方法做，但是还可能是从1搬到2，这样区间合并的方法就不适用了，所以一直WA。然后看数据不大，直接开一数组f[205]存储编号为i的走廊用了几次。还需注意，输入的两端点大小不一定。代码如下：

#include<cstdio>
int main(){
    int T,n,a,b;
    scanf("%d",&T);
    while(T--){
        int f[205]={0},sum=-1;
        scanf("%d",&n);
        for(int i=0;i<n;i++){
            scanf("%d%d",&a,&b);
            int minx=a<b?(a+1)/2:(b+1)/2;
            int maxn=a<b?(b+1)/2:(a+1)/2;
            for(int i=minx;i<=maxn;i++){
                f[i]++;
                if(f[i]>sum)
                    sum=f[i];
            }
        }
        printf("%d\n",sum*10);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

在如下8*6的矩阵中，请计算从A移动到B一共有____种走法。要求每次只能向上或向右移动一格，并且不能经过P。
在如下8*6的矩阵中，请计算从A移动到B一共有__种走法。要求每次只能向上或向右移动一格，并且不能经过P。 

A:456 
B:492 
C:568 
D:626 
E:680 
F:702
解析: 
8*6的矩阵，从左下角A到右上角B，一共需要走12步，其中5步向上，7步向右，因此总的走法一共有C(12,5)=792种，但题目规定不能经过P，因此需要减去经过P点的走法。 
经过P的路径分为两部分，从A到P，从P到B。 
同理，从A到P的走法：C(6,2)=15； 
同理，从P到B的走法：C(6,3)=20； 
因此从A到B经过P点的走法有15*20=300种， 
所以从A到B不经过P点的走法有792-300=492种。
这题其实可以用程序算出来 
简单的动态规划 
dp[i][j] = dp[i][j-1] + dp[i-1][j];
代码如下:
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>

using namespace std;
int main()
{

  int dp[100][100] = {0};

  for(int i = 1; i <= 6; i++)
    for(int j = 1; j <= 8; j++){        
        dp[i][j] = dp[i-1][j] + dp[i][j-1];
    }

    int dp2[100][100] = {0};
    dp2[0][1] = 1;

    for(int i = 1; i <= 4; i++)
        for(int j = 1; j <= 4; j++)
            dp2[i][j] = dp2[i-1][j] + dp2[i][j-1];

    cout<<dp[6][8] - dp2[4][4] * dp[3][5]<<endl;

  return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

ZOJ 3885	The Exchange of Items 最小费用最大流




裸的最小费用最大流....



The Exchange of Items

Time Limit: 2 Seconds      Memory Limit: 65536 KB


Bob lives in an ancient village, where transactions are done by one item exchange with another. Bob is very clever and he knows what items will become more valuable later on. So, Bob
 has decided to do some business with villagers.
At first, Bob has N kinds of items indexed from 1 to N, and each item has Ai. There are M ways to exchanges items. For the ith
 way (Xi, Yi), Bob can exchange oneXith item to one Yith item, vice versa. Now Bob wants that his ith item has exactly Bi, and he wonders
 what the minimal times of transactions is.
Input
There are multiple test cases. 
For each test case: the first line contains two integers: N and M (1 <= N, M <= 100).
The next N lines contains two integers: Ai and Bi (1 <= Ai, Bi <= 10,000).
Following M lines contains two integers: Xi and Yi (1 <= Xi, Yi <= N).
There is one empty line between test cases.
Output
For each test case output the minimal times of transactions. If Bob could not reach his goal, output -1 instead.
Sample Input
2 1
1 2
2 1
1 2

4 2
1 3
2 1
3 2
2 3
1 2
3 4

Sample Output
1
-1


Author: FENG, Jingyi
Source: ZOJ Monthly, July 2017




/* ***********************************************
Author        :CKboss
Created Time  :2015年08月24日 星期一 13时12分25秒
File Name     :E.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=220;
const int INF=0x3f3f3f3f;

struct Edge
{
	int to,next,cap,flow,cost;
}edge[maxn*maxn];

int Adj[maxn],Size,N;

void init()
{
	memset(Adj,-1,sizeof(Adj)); Size=0;
}

void addedge(int u,int v,int cap,int cost)
{
	edge[Size].to=v;
	edge[Size].next=Adj[u];
	edge[Size].cost=cost;
	edge[Size].cap=cap;
	edge[Size].flow=0;
	Adj[u]=Size++;
}

void Add_Edge(int u,int v,int cap,int cost)
{
	addedge(u,v,cap,cost);
	addedge(v,u,0,-cost);
}

int dist[maxn],vis[maxn],pre[maxn];

bool spfa(int s,int t)
{
	queue<int> q;
	for(int i=0;i<N;i++)
	{
		dist[i]=INF; vis[i]=false; pre[i]=-1;
	}
	dist[s]=0; vis[s]=true; q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=false;
		for(int i=Adj[u];~i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(edge[i].cap>edge[i].flow&&
					dist[v]>dist[u]+edge[i].cost)
			{
				dist[v]=dist[u]+edge[i].cost;
				pre[v]=i;
				if(!vis[v])
				{
					vis[v]=true; q.push(v);
				}
			}
		}
	}
	if(pre[t]==-1) return false;
	return true;
}

int MinCostMaxFlow(int s,int t,int& cost)
{
	int flow=0;
	cost=0;
	while(spfa(s,t))
	{
		int Min=INF;
		for(int i=pre[t];~i;i=pre[edge[i^1].to])
		{
			if(Min>edge[i].cap-edge[i].flow)
			{
				Min=edge[i].cap-edge[i].flow;
			}
		}
		for(int i=pre[t];~i;i=pre[edge[i^1].to])
		{
			edge[i].flow+=Min;
			edge[i^1].flow-=Min;
			cost+=edge[i].cost*Min;
		}
		flow+=Min;
	}
	return flow;
}

int n,m;
int A[maxn],B[maxn];

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	while(scanf("%d%d",&n,&m)!=EOF)
	{
		int suma=0,sumb=0;
		for(int i=1;i<=n;i++)
		{
			scanf("%d%d",A+i,B+i);
			suma+=A[i]; sumb+=B[i];
		}
		init();
		for(int i=0;i<m;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			/// u--->v
			Add_Edge(u,v,INF,1);
			Add_Edge(v,u,INF,1);
		}

		if(suma!=sumb)
		{
			puts("-1"); continue;
		}

		int S=0,T=n+1;
		for(int i=1;i<=n;i++)
		{
			Add_Edge(S,i,A[i],0);
			Add_Edge(i,T,B[i],0);
		}

		N=n+2;
		int flow,cost;
		flow=MinCostMaxFlow(S,T,cost);

		//cout<<"flow "<<flow<<"cost "<<cost<<endl;
		if(flow==suma)
		{
			printf("%d\n",cost);
		}
		else
		{
			puts("-1"); continue;
		}
	}
    
    return 0;
}


版权声明：来自: 码代码的猿猿的AC之路 http://blog.csdn.net/ck_boss 

搭建PHP开发环境
前言：之前已经介绍了如何搭建PHP的运行环境，那么接下来要做的，搭建PHP开发环境就简单了，当然我之前在学习的阶段用的是eclipse，但是这一次，我们来使用phpStorm，不过这是一款商业软件，不过你应该不会担心要不要注册。
软件准备
phpStorm
说明：这个IDE我还用的不是很熟练，不过它集成了SVN，这个好的太多了！
安装
安装也是很傻瓜式的，一步到位就行了，不过这里有个参考的key。
hello
 


接着是一会的等待时间。。

注意：如果你是第一次打开storm，它会提示一个错误，好像是PHP的解释器没找到的错误，你只需要新建一个PHP5，就像指定一个Java的JDK一样，见下图的内容。


注意一定要选好！
运行
在浏览器地址栏输入对应的运行目录就OK了

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本站博客均为qing_gee原创文章，若您需要引用、转载，只需要注明来源及原文链接即可。

如何让IE支持自定义协议

浏览QQ空间的时候发现，只要在IE地址中输入象一下这种形式的地址，
tencent://Message/?Uin=251464630&websiteName=qzone.qq.com&Menu=yes
就会弹出给 251464630 发送信息的对话框，也就是说QQ对IE地址栏的东西做了监控。而且可以发现输入地址确定之后他就启动了timwp.exe这个程序。
在PPlive也有实现类似的功能，只要你电脑上安装了PPlive 这个程序，在IE地址栏中输入synacast://09jN1+TK3K3nodzJoaLOmqeS1KGhoKOZoqGclt
然后确定，就会弹出播放CCTV5的窗口。很有意思的一种功能，竟然这么多程序都用到了，我也就找了一下，找到了一下实现方法。

方法一： 也就是QQ和PPlive所采用的方法，在注册表里面添加两种类型的注册。
QQ的：
Windows Registry Editor Version 5.00
[HKEY_CLASSES_ROOT\TENCENT]
@="TencentProtocol"
"URL Protocol"="C:\\Program Files\\Tencent\\QQ\\Timwp.exe"
[HKEY_CLASSES_ROOT\TENCENT\DefaultIcon]
@="C:\\Program Files\\Tencent\\QQ\\Timwp.exe,1"
[HKEY_CLASSES_ROOT\TENCENT\shell]
[HKEY_CLASSES_ROOT\TENCENT\shell\open]
[HKEY_CLASSES_ROOT\TENCENT\shell\open\command]
@="\"C:\\Program Files\\Tencent\\QQ\\Timwp.exe\" \"%1\""

PPlive的：
Windows Registry Editor Version 5.00
[HKEY_CLASSES_ROOT\Synacast]
@="URL:synacast Protocol"
"Version"="1.5.38"
"URL Protocol"=""
[HKEY_CLASSES_ROOT\Synacast\DefaultIcon]
@="C:\\Program Files\\PPLive\\PPLive.exe"
[HKEY_CLASSES_ROOT\Synacast\Shell]
[HKEY_CLASSES_ROOT\Synacast\Shell\Open]
[HKEY_CLASSES_ROOT\Synacast\Shell\Open\Command]
@="C:\\Program Files\\PPLive\\PPLive.exe \"%1\""

通过多方查找终于发现是注册表这两项在起作用，原来只要在注册表里象添加文件扩展名一样，添加两个Synacast和TENCENT扩展名来，IE就会自动查找到这里来调用相应的程序。IE果然和windows系统内核整合起来了！原来注册表扩展名项还有这种作用，自己见识太少了，这种方法实现IE地址的自定义估计是最简单的了。

方法二：一开始不知道方法一的时候，在网上找了很多可以实现这种功能的代码，采用BHO（Browser Helper Object，浏览器辅助对象）或者IURLSearchHook接口 来做到。也就是通常所说的IE插件了，我这里统称为方法二。如果不知道什么叫做BHO和IURLSearchHook的就去搜索一下吧，最近流氓插件很火，所以这个技术也有多人提到，借助IURLSearchHook还可以实现中文实名上网等功能，不过那些臭名昭著的流氓软件可都不是这样子坐的他更多的精力是放到防止别人卸载那边去了。





版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU1203I Need A Offer
题目要求：


Problem Description

Speakless很早就想出国，现在他已经考完了所有需要的考试，准备了所有要准备的材料，于是，便需要去申请学校了。要申请国外的任何大学，你都要交纳一定的申请费用，这可是很惊人的。Speakless没有多少钱，总共只攒了n万美元。他将在m个学校中选择若干的（当然要在他的经济承受范围内）。每个学校都有不同的申请费用a（万美元），并且Speakless估计了他得到这个学校offer的可能性b。不同学校之间是否得到offer不会互相影响。“I NEED A OFFER”，他大叫一声。帮帮这个可怜的人吧，帮助他计算一下，他可以收到至少一份offer的最大概率。（如果Speakless选择了多个学校，得到任意一个学校的offer都可以）。


 


Input

输入有若干组数据，每组数据的第一行有两个正整数n,m(0<=n<=10000,0<=m<=10000) 
后面的m行，每行都有两个数据ai(整型),bi(实型)分别表示第i个学校的申请费用和可能拿到offer的概率。 
输入的最后有两个0。


 


Output

每组数据都对应一个输出，表示Speakless可能得到至少一份offer的最大概率。用百分数表示，精确到小数点后一位。


解题思路：
        看到题目想到了0-1背包问题，可以按照这种思路，求出在有限的钱数中找到概率和最大的组合，然后用1减去各个概率的乘积，也就是用1减去这几种情况都没有拿到offer的情况即为至少拿到一个offer。状态转移方程dp[i]=max[dp[i],dp[i-a]+b};
        这样做的话，还得需要记录路径。所以想到，可以将状态转移数组初始化为1，然后在循环过程中，直接记录没有拿到offer的概率的乘积。dp[i]=min{dp[i],dp[i-a]*(1-b)}
代码如下：
# include <iostream>
# include <algorithm>
using namespace std;


struct node
{
<span style="white-space:pre">	</span>int a;
<span style="white-space:pre">	</span>double b;
}school[10002];


double dp[10001];


int main()
{
<span style="white-space:pre">	</span>freopen("input.txt","r",stdin);
<span style="white-space:pre">	</span>int n,m;
<span style="white-space:pre">	</span>while(scanf("%d%d",&n,&m)!=EOF && (n!=0 || m!=0))
<span style="white-space:pre">	</span>{
<span style="white-space:pre">		</span>memset(dp,0,sizeof(dp));
<span style="white-space:pre">		</span>int i,j;
<span style="white-space:pre">		</span>for(i=0;i<m;i++)
<span style="white-space:pre">			</span>scanf("%d%lf",&school[i].a,&school[i].b);
<span style="white-space:pre">		</span>dp[n]=0;
<span style="white-space:pre">		</span>for(i=0;i<=n;i++)
<span style="white-space:pre">			</span>dp[i]=1;
<span style="white-space:pre">		</span>for(i=0;i<m;i++)
<span style="white-space:pre">		</span>{
<span style="white-space:pre">			</span>for(j=n;j>=school[i].a;j--)
<span style="white-space:pre">			</span>{
<span style="white-space:pre">				</span>if(dp[j]>dp[j-school[i].a]*(1-school[i].b))
<span style="white-space:pre">					</span>dp[j]=dp[j-school[i].a]*(1-school[i].b);
<span style="white-space:pre">			</span>}
<span style="white-space:pre">		</span>}
<span style="white-space:pre">		</span>printf("%.1lf%%\n",(1-dp[n])*100);
<span style="white-space:pre">	</span>}
<span style="white-space:pre">	</span>return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU2389 Rain on your Parade（二分图匹配 ，HK算法 ）
匈牙利算法果断超时，只有用HK模板测试一下

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<set>
#include<map>
#include<string>
#include<cstring>
#include<stack>
#include<queue>
#include<vector>
#include<cstdlib>
#define lson (rt<<1),L,M
#define rson (rt<<1|1),M+1,R
#define M ((L+R)>>1)
#define cl(a,b) memset(a,b,sizeof(a));
#define LL long long
#define P pair<int,int>
#define X first
#define Y second
#define pb push_back
#define fread(zcc)  freopen(zcc,"r",stdin)
#define fwrite(zcc) freopen(zcc,"w",stdout)
using namespace std;
/*这个算法比匈牙利算法的时间复杂度要小，大数据可以采用这个算法
二分图匹配（Hopcroft-Carp的算法）。
初始化：g[][]邻接矩阵
调用：res=MaxMatch();  Nx,Ny要初始化！！！
时间复杂大为 O(V^0.5 E)
适用于数据较大的二分匹配*/
const int MAXN=3005;
const int INF=1<<28;
int g[MAXN][MAXN],Mx[MAXN],My[MAXN],Nx,Ny;
int dx[MAXN],dy[MAXN],dis;
bool vst[MAXN];
struct people{
    int x,y,t;
}p[MAXN];
struct umbrella{
    int x,y;
}um[MAXN];

int inline abs(int x){return x<0?-x:x;}
int inline distance(people a,umbrella b){
    return abs(a.x-b.x)+abs(a.y-b.y);
}
bool searchP(){
    queue<int> Q;
    dis=INF;
    memset(dx,-1,sizeof(dx));
    memset(dy,-1,sizeof(dy));
    for(int i=0;i<Nx;i++)
        if(Mx[i]==-1){
            Q.push(i);
            dx[i]=0;
        }
    while(!Q.empty()){
        int u=Q.front();
        Q.pop();
        if(dx[u]>dis)break;
        for(int v=0;v<Ny;v++)
            if(g[u][v]&&dy[v]==-1){
                dy[v]=dx[u]+1;
                if(My[v]==-1)
                    dis=dy[v];
                else{
                    dx[My[v]]=dy[v]+1;
                    Q.push(My[v]);
                }
            }
    }
    return dis!=INF;
}

bool DFS(int u){
    for(int v=0;v<Ny;v++)
       if(!vst[v]&&g[u][v]&&dy[v]==dx[u]+1){
           vst[v]=1;
           if(My[v]!=-1&&dy[v]==dis) continue;
           if(My[v]==-1||DFS(My[v])){
               My[v]=u;
               Mx[u]=v;
               return 1;
           }
       }
    return 0;
}
int MaxMatch(){
    int res=0;
    memset(Mx,-1,sizeof(Mx));
    memset(My,-1,sizeof(My));
    while(searchP()){
        memset(vst,0,sizeof(vst));
        for(int i=0;i<Nx;i++)
            if(Mx[i]==-1&&DFS(i)) res++;
    }
    return res;
}
int main(){
    int T;
    scanf("%d",&T);
    int cas=1;
    while(T--){
        int t,n,m;
        scanf("%d%d",&t,&n);
        for(int i=0;i<n;i++){
            scanf("%d%d%d",&p[i].x,&p[i].y,&p[i].t);
        }
        scanf("%d",&m);
        for(int i=0;i<m;i++){
            scanf("%d%d",&um[i].x,&um[i].y);
        }
        cl(g,0);
        Nx=n;Ny=m;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)if(distance(p[i],um[j])/p[i].t<=t){
                g[i][j]=1;
            }
        }
        printf("Scenario #%d:\n%d\n\n",cas++,MaxMatch());

    }
    return 0;
}










版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU1669 Jamie's Contact Groups （二分+二分图的多重匹配+一对多的匹配）

多重匹配：一对多的二分图的多重匹配。二分图的多重匹配算法的实现类似于匈牙利算法，对于集合X中的元素xi，找到一个与其相连的元素yi后，检查匈牙利算法的两个条件是否成立，若yi未被匹配，则将
xi，yi匹配。否则，如果与yi匹配的元素已经达到上限，那么在所有与yi匹配的元素中选择一个元素，检查是否能找到一条增广路径，如果能，则让出位置，让xi与yi匹配。
match[i][j]表示X集合中的Xi点与y集合中的j个点相连接（一对多）

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<set>
#include<map>
#include<string>
#include<cstring>
#include<stack>
#include<queue>
#include<vector>
#include<cstdlib>
#define lson (rt<<1),L,M
#define rson (rt<<1|1),M+1,R
#define M ((L+R)>>1)
#define cl(a,b) memset(a,b,sizeof(a));
#define LL long long
#define P pair<int,int>
#define X first
#define Y second
#define pb push_back
#define fread(zcc)  freopen(zcc,"r",stdin)
#define fwrite(zcc) freopen(zcc,"w",stdout)
using namespace std;
const int maxn=1005;
const int inf=999999;

char s[100005];
vector<int> G[maxn];
int Nx,limit,cnt[maxn];//cnt数组是记录X集合Xi点 目前已经匹配Y集合里的点的个数
int matching[maxn][505];//这个表示X集合的Xi点与Y集合的cnt个点相连接
bool vis[maxn];
bool dfs(int u){//多重匹配和二分图的一般匹配差不多，还是两个条件
    int N=G[u].size();
    for(int i=0;i<N;i++){
        int v=G[u][i];
        if(vis[v])continue;
        vis[v]=true;
        if(cnt[v]<limit){
            matching[v][cnt[v]++]=u;//没有达到上限，匹配
            return true;
        }else {
            for(int i=0;i<cnt[v];i++){//达到上限，继续查看是否还能找到增广路
                if(dfs(matching[v][i])){
                    matching[v][i]=u;
                    return true;
                }
            }
        }
    }
    return false;
}
bool hungar(){
    cl(cnt,0);
    for(int i=0;i<Nx;i++){
        cl(vis,false);
        if(!dfs(i))return false;
    }
    return true;
}
int main(){
    int n,m;
    while(scanf("%d%d",&n,&m)&&(n||m)){
        getchar();
        for(int i=0;i<n;i++){
            gets(s);
            int len=strlen(s);
            for(int j=0;j<len;j++){
                if(s[j]>='0'&&s[j]<='9'){
                    int num=0;
                    while(s[j]>='0'&&s[j]<='9'){
                        num=num*10+s[j]-'0';
                        j++;
                    }
                    G[i].pb(num);
                }
            }
        }
        Nx=n;
        int l=0,r=n;
        while(l<r){///二分答案
           // printf("%d  %d \n",l,r);
            limit=(l+r)/2;
            if(hungar()){
                r=limit;
            }
            else {
                l=limit+1;
            }
        }
        printf("%d\n",r);
        for(int i=0;i<maxn;i++)G[i].clear();
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1286 找新朋友
找新朋友
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 9372    Accepted Submission(s): 4963



Problem Description
新年快到了，“猪头帮协会”准备搞一个聚会，已经知道现有会员N人，把会员从1到N编号，其中会长的号码是N号，凡是和会长是老朋友的，那么该会员的号码肯定和N有大于1的公约数，否则都是新朋友，现在会长想知道究竟有几个新朋友？请你编程序帮会长计算出来。
 

Input
第一行是测试数据的组数CN（Case number，1<CN<10000），接着有CN行正整数N（1<n<32768），表示会员人数。
 

Output
对于每一个N，输出一行新朋友的人数，这样共有CN行输出。

 

Sample Input

2
25608
24027

 

Sample Output

7680
16016
源代码
<span style="font-size:18px;"><span style="font-size:18px;">#include<cstdio>
#include<cstring>
char a[32770];
int t,n;
int cnt;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		memset(a,0,sizeof(a));
		cnt=0;
		scanf("%d",&n);
		for(int i=2;i<=n;i++)
		{
			if(n%i==0)
			{
				for(int j=i;j<=n;j+=i)
				a[j]=1;
			}
		}
		for(int i=1;i<=n;i++)
		{
			if(a[i]==0)
			cnt++;
		}
		printf("%d\n",cnt);
	}
	return 0;
}</span></span>

 


版权声明：本文为博主原创文章，未经博主允许不得转载。

[LeedCode OJ]#171 Excel Sheet Column Number
【 声明：版权所有，转载请标明出处，请勿用于商业用途。  联系信箱：libin493073668@sina.com】



题目链接：https://leetcode.com/problems/excel-sheet-column-number/


题意：
给定A~Z，分别代表1~26，AA-27，AB-28等等，现在给定一个由字母组成的字符串，要求将其转换为数字


思路：
运用进制的思想，转换成求进制的思路即可




class Solution
{
public:
    int titleToNumber(string s)
    {
        int ans = 0;
        int len = s.length(),i,j;
        for(i = 0; i<len; i++)
        {
            int cnt = len-1-i;
            int a = s[i]-'A'+1,q = 1;
            while(cnt--)
                q*=26;
            ans=ans+a*q;
        }
        return ans;
    }
};




版权声明：本文为博主原创文章，如果转载，请注明出处

浅析C#中的委托
委托是寻址方法的.NET版本。在C++中，函数指针只不过是一个指向内存位置的指针，它不是类型安全的。而.NET委托完全不同，委托是安全类型的类，它定义了返回类型和参数的类型。 
当把方法传递给其他方法时，需要使用委托。
C#中使用一个类时，分两个阶段。首先需要定义这个类，即告诉编译器这个类由什么组成的。然后，实例化一个对象（除非只使用静态方法）。
对于委托也是类似，也需要两个步骤。首先必须定义要使用的委托，然后必须创建该委托的一个或多个实例。
定义语法：
delegate void IntMethodInoker(int x);
delegate double TwoLongsOp(long first, long second);
delegate string GetString();
定义委托基本上是定义一个新类，所以可以在定义类的任何相同地方定义委托。即可以在另一个类的内部定义，可以在任何类的外部定义，可以在名称空间中把委托定义为顶层对象。
根据委托定义的可见性，和委托的作用域，可以在委托的定义上应用任意常见的访问修饰符：public、private、protected等 
例如：
public delegate string GetAString();
使用委托：
private delegate string GetAString();
static void Main()
{
    int x=40;
    GetAString firstStringMethod = new GetAString(x.ToString);
    Console.WriteLine("String is {0}",firstStringMethod () );
}
由上述代码可以看到，C#的委托在语法上总是接受一个参数的构造函数，这个参数就是委托引用的方法，但是这个方法必须匹配最初定义委托时的签名。
实际上，给委托实例提供圆括号与调用委托类的Invoke()方法完全相同。使用Invoke完成一个委托方法的封送，就类似于使用SendMessage方法来给界面线程发送消息，是一个同步方法。也就是说在Invoke封送的方法被执行完毕前，Invoke方法不会返回，从而调用者线程将被阻塞。
因为firstStringMethod 是一个委托类型的变量，所以C#编译器会用firstStringMethod.Invoke()代替firstStringMethod ()。
firstStringMethod();
firstStringMethod.Invoke();
为了减少输入量，只需要委托实例，就可以只传递地址的名称，即委托推断。
GetAString firstStringMethod = new GetAString(x.ToString);
GetAString firstStringMethod = x.ToString;
注意：输入行事不能是x.ToString()，也不能把它传给委托变量。x.ToString表示把方法的地址赋予委托变量。
多播委托： 
委托可以包含多个方法，这种委托称为多播委托。如果调用多播委托，就可以按顺序连续调用多个方法。但是，委托的签名必须返回void，否则只能得到委托调用的最后一个方法的结果。 
多播委托示例程：
delegate void Delegate_Multicast(int x, int y);
Class Class2
{
    static void Method1(int x, int y) 
    {
      Console.WriteLine("You r in Method 1");
    }
    static void Method2(int x, int y) 
    {
      Console.WriteLine("You r in Method 2");
    }
    public static void Main() 
    {
      Delegate_Multicast func = new Delegate_Multicast(Method1);
      func += new Delegate_Multicast(Method2);
      func(1,2);             // Method1 and Method2 are called
      func -= new Delegate_Multicast(Method1);
      func(2,3);             // Only Method2 is called
   }
}    
解析： 
上面的示例程序分别定义了名为method1 和 method2的两个接受整型参数、返回类型为void的方法。 
在Main函数里使用下面的声明创建委托对象： 
Delegate_Multicast func = new Delegate_Multicast(Method1); 
然后使用+= 来添加委托，使用-=来移除委托。
合并委托： 
委托对象的一个用途在于，可以使用 + 运算符将它们分配给一个要成为多路广播委托的委托实例。组合的委托可调用组成它的那两个委托。只有相同类型的委托才可以组合。 
- 运算符可用来从组合的委托移除组件委托。
delegate void Del(string s);

class TestClass
{
    static void Hello(string s)
    {
        System.Console.WriteLine("  Hello, {0}!", s);
    }

    static void Goodbye(string s)
    {
        System.Console.WriteLine("  Goodbye, {0}!", s);
    }

    static void Main()
    {
        Del a, b, c, d;

        // Create the delegate object a that references 
        // the method Hello:
        a = Hello;

        // Create the delegate object b that references 
        // the method Goodbye:
        b = Goodbye;

        // The two delegates, a and b, are composed to form c: 
        c = a + b;

        // Remove a from the composed delegate, leaving d, 
        // which calls only the method Goodbye:
        d = c - a;

        System.Console.WriteLine("Invoking delegate a:");
        a("A");
        System.Console.WriteLine("Invoking delegate b:");
        b("B");
        System.Console.WriteLine("Invoking delegate c:");
        c("C");
        System.Console.WriteLine("Invoking delegate d:");
        d("D");
    }
}

/*-------------------------
输出
Invoking delegate a:
  Hello, A!
Invoking delegate b:
  Goodbye, B!
Invoking delegate c:
  Hello, C!
  Goodbye, C!
Invoking delegate d:
  Goodbye, D!
  ----------------------*/
匿名方法： 
到目前为止，要想使用委托工作，方法必须已经存在。但是还有另一种使用委托的方法：即通过匿名方法。匿名方法是用作委托的参数的一段代码。 
用匿名方法定义委托的语法与前面的定义并没有区别。但在实例化的时候就有了区别了。 
如果使用匿名方法，则不必创建单独的方法，因此减少了实例化委托所需的编码系统开销。
例如，如果创建方法所需的系统开销是不必要的，在委托的位置指定代码块就非常有用。启动新线程即是一个很好的示例。无需为委托创建更多方法，线程类即可创建一个线程并且包含该线程执行的代码。
void StartThread()
{
    System.Threading.Thread t1 = new System.Threading.Thread
      (delegate()
            {
                System.Console.Write("Hello, ");
                System.Console.WriteLine("World!");
            });
    t1.Start();
}
委托类型派生自 .NET Framework 中的 Delegate 类。 委托类型是封装的，它们不能派生出其他类，也不能从 Delegate 派生出自定义类。 由于实例化的委托是一个对象，因此可以作为参数传递或分配给一个属性。 这允许方法作为参数接受委托并在稍后调用委托。 这被称为异步回调，是在长进程完成时通知调用方的常用方法。 当以这种方式使用委托时，使用委托的代码不需要知道要使用的实现方法。 功能类似于封装接口提供的功能。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ3734Blocks矩阵快速幂加dp思想
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

typedef vector<int> vec;
typedef vector<vec> mat;
const int M=10007;
typedef long long LL;
mat mul(mat &A,mat &B){
    mat C(A.size(),vec(B[0].size()));
    for(int i = 0;i < A.size();i++){
        for(int k = 0; k < B.size();k++){
            for(int j = 0;j < B[0].size();j++){
                C[i][j]+=A[i][k]*B[k][j];
                C[i][j] %= M;
            }
        }
    }
    return C;
}
mat fun(mat A,LL n){
    mat B(A.size(),vec(A.size()));
    for(int i = 0;i < A.size();i ++){
        B[i][i] = 1;
    }
    while(n > 0){
        if(n&1) B=mul(B,A);
        A = mul(A,A);
        n >>= 1;
    }
    return B;
}
int main(){
    int t;
    cin >> t;
    while(t--){
        int n;
        cin >> n;
        mat A(4,vec(4));
        A[0][0]=2;A[0][1]=1;A[0][2]=1;A[0][3]=0;
        A[1][0]=1;A[1][1]=2;A[1][2]=0;A[1][3]=1;
        A[2][0]=1;A[2][1]=0;A[2][2]=2;A[2][3]=1;
        A[3][0]=0;A[3][1]=1;A[3][2]=1;A[3][3]=2;
        A = fun(A,n);
        cout << A[0][0] << endl;
    }
    return 0;
}

dp[i][0] 代表i个红绿都是偶数 
dp[i][1] 代表i个红块是奇数绿块是偶数 
dp[i][2] 代表i个红块是偶数绿块是奇数 
dp[i][3] 代表i个红绿都是奇数 
由这个这个状态可以转出一个矩阵然后这个矩阵就快速幂

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Flying to the Mars

Problem Description



In the year 8888, the Earth is ruled by the PPF Empire . As the population growing , PPF needs to find more land for the newborns . Finally , PPF decides to attack Kscinow who ruling the Mars . Here the problem comes! How can the soldiers reach the Mars ? PPF
 convokes his soldiers and asks for their suggestions . “Rush … ” one soldier answers. “Shut up ! Do I have to remind you that there isn’t any road to the Mars from here!” PPF replies. “Fly !” another answers. PPF smiles :“Clever guy ! Although we haven’t got
 wings , I can buy some magic broomsticks from HARRY POTTER to help you .” Now , it’s time to learn to fly on a broomstick ! we assume that one soldier has one level number indicating his degree. The soldier who has a higher level could teach the lower , that
 is to say the former’s level > the latter’s . But the lower can’t teach the higher. One soldier can have only one teacher at most , certainly , having no teacher is also legal. Similarly one soldier can have only one student at most while having no student
 is also possible. Teacher can teach his student on the same broomstick .Certainly , all the soldier must have practiced on the broomstick before they fly to the Mars! Magic broomstick is expensive !So , can you help PPF to calculate the minimum number of the
 broomstick needed .
For example : 
There are 5 soldiers (A B C D E)with level numbers : 2 4 5 6 4;
One method :
C could teach B; B could teach A; So , A B C are eligible to study on the same broomstick.
D could teach E;So D E are eligible to study on the same broomstick;
Using this method , we need 2 broomsticks.
Another method:
D could teach A; So A D are eligible to study on the same broomstick.
C could teach B; So B C are eligible to study on the same broomstick.
E with no teacher or student are eligible to study on one broomstick.
Using the method ,we need 3 broomsticks.
……

After checking up all possible method, we found that 2 is the minimum number of broomsticks needed.


 

Input
Input file contains multiple test cases. 
In a test case,the first line contains a single positive number N indicating the number of soldiers.(0<=N<=3000)
Next N lines :There is only one nonnegative integer on each line , indicating the level number for each soldier.( less than 30 digits);

 

Output
For each case, output the minimum number of broomsticks on a single line.
 

Sample Input

4
10
20
30
04
5
2
3
4
3
4

 

Sample Output

1
2



题解：求递增序列的个数，就是求相同数字的数量最多的是多少，注意0的情况。可以用字典树，但是map拿来不用行吗。


#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm> 
#include <map>

using namespace std;

map<string,int> mp;

int main()
{
	int n;
	char s[100];
	int res = 0;
	while(scanf("%d",&n) != EOF)
	{
		getchar();
		res = 0;
		for(int i = 0;i < n;i++)
		{
			int cnt = 0;
			char ch = getchar();
			while(ch == '0')
			{
				ch = getchar();
			}
			if(ch == '\n')
			{
				res = max(++mp["0"],res);
				continue;
			}
			while(ch != '\n')
			{
				s[cnt++] = ch;
				ch = getchar();
			}
			s[cnt] = '\0';
			res = max(res,++mp[s]);
		}
		if(n == 0)
		{
			printf("0\n");
			continue;
		}
		printf("%d\n",res);
		mp.clear();
	}
	
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

一起talk C栗子吧（第四十二回：C语言实例--哈夫曼编码）


各位看官们，大家好，上一回中咱们说的是哈夫曼树的例子，这一回咱们说的例子是：哈夫曼编码。闲话
休提，言归正转。让我们一起talk C栗子吧！


看官们，咱们又看到哈夫曼了，不过大家不用担心，这里说的哈夫曼和上一回中咱们说的哈夫曼是同一个
人。哈哈！哈夫曼编码就是通过哈夫曼树来实现的，因此，我们先在上一回中先说了哈夫曼树，然后就在
这回中说哈夫曼编码。把哈夫曼树中左边孩子的权值修改为0,右边孩子的值修改为1。读取从根结点到某个
结点路径上的权值，就是该结点的哈夫曼编码。我们举例子来说明，例子中还使用上一回中的图，从哈夫
曼树变成哈夫曼编码如下图所示(左边是哈夫曼树，右边是哈夫曼编码）。


  
==>



从上图中，我们得出各个结点的哈夫曼编码，具体如下：


A的哈夫曼编码：11001B的哈夫曼编码：1101C的哈夫曼编码：101D的哈夫曼编码：00E的哈夫曼编码：100F的哈夫曼编码：01G的哈夫曼编码：11000H的哈夫曼编码：111


各位看官，关于哈夫曼编码的例子咱们就说到这里。欲知后面还有什么例子，且听下回分解。



版权声明：本文为博主原创文章，未经博主允许不得转载。

【算法学习笔记】-二分查找算法

二分搜索是一种常用的搜索方法，它要求数组中的元素必须是有序存放的。不失一般性，我们假定数组元素按升序存放。二分搜索方法首先将关键字与位于数组中央的元素进行比较，比较结果有三种情况：
1）如果关键字小于中央元素，我们只需要继续在数组的前半部分进行搜索。
2）如果关键字与中央元素相等，则搜索结束，找到匹配元素。
3）如果关键字大于中央元素，我们只需要继续在数组的后半部分进行搜索。
二分搜索的代码如下：

#include <iostream>
using namespace std;
int binarySearch(int a[],int number,int len)
{
	int left=0,right=len-1;
	int middle;
	while(left<=right)
	{
		middle=(left+right)/2;
		if(a[middle]<number)
		{
			left=middle+1;
		}
		else if(a[middle]>number)
		{
			right=middle-1;
		}
		else
		{
			return middle;
		}
	}
	return -1;
}
int _tmain(int argc, _TCHAR* argv[])
{
	int a[]={2,4,7,10,11,45,50,59,60,66,69,70,79};
	int result=binarySearch(a,45,13);
	if (result == -1)
	{
		cout<<"not find this number"<<endl;
	}
	else
	{
		cout<<"the index of number is "<<result<<endl;
	}
	return 0;
}输出结果为：
the index of number is 5


版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 3041--Asteroids【二分图 && 最小点数覆盖】


Asteroids




Time Limit: 1000MS
 
Memory Limit: 65536K


Total Submissions: 17861
 
Accepted: 9729





Description

Bessie wants to navigate her spaceship through a dangerous asteroid field in the shape of an N x N grid (1 <= N <= 500). The grid contains K asteroids (1 <= K <= 10,000), which are conveniently located at the lattice points of the grid. 

Fortunately, Bessie has a powerful weapon that can vaporize all the asteroids in any given row or column of the grid with a single shot.This weapon is quite expensive, so she wishes to use it sparingly.Given the location of all the asteroids in the field, find
 the minimum number of shots Bessie needs to fire to eliminate all of the asteroids.
Input

* Line 1: Two integers N and K, separated by a single space. 
* Lines 2..K+1: Each line contains two space-separated integers R and C (1 <= R, C <= N) denoting the row and column coordinates of an asteroid, respectively.
Output

* Line 1: The integer representing the minimum number of times Bessie must shoot.
Sample Input
3 4
1 1
1 3
2 2
3 2

Sample Output
2

Hint

INPUT DETAILS: 
The following diagram represents the data, where "X" is an asteroid and "." is empty space: 
X.X 
.X. 
.X. 

OUTPUT DETAILS: 
Bessie may fire across row 1 to destroy the asteroids at (1,1) and (1,3), and then she may fire down column 2 to destroy the asteroids at (2,2) and (3,2).

题意：
太空中有个N * N的网格，网格中分布了K个危险的小行星，有一种武器，只需要一枚子弹，就可以使某一行或者某一列上的所有小行星毁灭。问最少需要多少子弹，才能摧毁所有的小行星。


思路：
裸的最小点覆盖数题目。水水水。
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 550
using namespace std;
int map[maxn][maxn];
int used[maxn];
int link[maxn];
int n, m;

void init(){
    memset(map, 0, sizeof(map));
}

void getmap(){
    while(m--){
        int a, b;
        scanf("%d%d", &a, &b);
        map[a][b] = 1;
    }
}

bool dfs(int x){
    for(int i = 1; i <= n; ++i){
        if(map[x][i] && !used[i]){
            used[i] = 1;
            if(link[i] == -1 || dfs(link[i])){
                link[i] = x;
                return true;
            }
        }
    }
    return false;
}

int hungary(){
    int ans = 0;
    memset(link, -1, sizeof(link));
    for(int i = 1; i <= n; ++i){
        memset(used, 0, sizeof(used));
        if(dfs(i))
            ans++;
    }
    return ans;
}

int main (){
    while(scanf("%d%d", &n, &m) != EOF){
        init();
        getmap();
        int sum = hungary();
        printf("%d\n", sum);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

【STL容器学习】-关联容器与map的使用方法

STL提供了4个关联容器：set、multiset、map和multimap。这些容器提供了通过关键字快速存储和访问数据元素的能力。Set和map不允许有重复关键字，而multiset和multimap允许重复关键字。关联容器的几个共同函数如下：
find(key)：搜索容器中具有指定关键字的元素，返回指向此元素的迭代器。
lower_bound(key)：搜索容器中具有指定关键字的第一个元素，返回指向此元素的迭代器。
upper_bound(key)：搜索容器中具有指定关键字的最后一个元素，返回指向此元素的迭代器。
count(key)：返回容器中具有指定关键字的元素的数目。
Map是比较重要的STL容器，本文主要来介绍map的原理和一些常见的用法。
1.map实现的原理
Map内部自建一个一颗红黑树，一种严格意义上的平衡二叉树，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。

2.数据插入
1）用insert函数插入pair数据。
2）用insert函数插入value_type数据。
3）用数组方式插入数据。
以上三种方法，都可以实现插入操作，但是还是有区别的。用insert函数进行插入操作时，在数据的插入上涉及到集合的唯一性这个概念，即当map中有key值时，insert操作无法插入数据。但是如果是用数组方式就不同了，它可以覆盖以前关键字对应的值。可以用pair来获得是否插入成功，Pair<map<int, string>::iterator, bool> Insert_Pair，执行完insert操作后，通过判断Insert_Pair.second值的真假来判断是否插入成功。
代码举例及分析如下：

#include <iostream>
#include <map>
#include <string>
using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	map<int,string> map1;
	map1.insert(pair<int,string>(1,"John"));   //insert pair的方式插入
	map1.insert(pair<int,string>(1,"Jeff"));   //不会再执行插入操作
	map1.insert(map<int,string>::value_type(2,"King"));    //insert value_type的方式插入
	map1.insert(map<int,string>::value_type(2,"Jane"));    //不会再执行插入操作
	map1[3]="Peter";   //数组方式插入
	map1[3]="Smith";   //会覆盖掉上一个值
	map<int,string>::iterator p;   //迭代器遍历输出
	for(p=map1.begin();p!=map1.end();p++)
	{
		cout<<p->first<<"\t"<<p->second<<endl;
	}
	pair<map<int, string>::iterator, bool> insert_pair;   //用pair判断是否成功插入数据
	insert_pair=map1.insert(pair<int,string>(4,"Kevin"));
	if(insert_pair.second)    //判断是否插入成功
	{
		cout<<"Insert Kevin Successfully"<<endl;
	}
	else
	{
		cout<<"Insert Kevin failed"<<endl;
	}
	insert_pair=map1.insert(pair<int,string>(4,"Cathy"));
	if(insert_pair.second)
	{
		cout<<"Insert Cathy Successfully"<<endl;
	}
	else
	{
		cout<<"Insert Cathy failed"<<endl;
	}
	for(p=map1.begin();p!=map1.end();p++)
	{
		cout<<p->first<<"\t"<<p->second<<endl;
	}
	return 0;
}

执行结果为：
1 John
2 King
3 Smith
Insert Kevin Successfully
Insert Cathy failed
1 John
2 King
3 Smith
4 Kevin

3.数据遍历
1）应用前向迭代器
2）应用反向迭代器
3）用数组方式
代码及分析如下：


#include <iostream>
#include <map>
#include <string>
using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	map<int,string> map1;
	map1.insert(pair<int,string>(1,"John"));   
	map1.insert(pair<int,string>(2,"Jeff"));   
	map1.insert(pair<int,string>(3,"Smith"));
	map<int,string>::iterator it;   //前向迭代器遍历输出
	cout<<"应用前向迭代器输出:"<<endl;
	for(it=map1.begin();it!=map1.end();it++)
	{
		cout<<it->first<<"\t"<<it->second<<endl;
	}
	map<int,string>::reverse_iterator reverse_it; //反序迭代器
	cout<<"应用反向迭代器输出:"<<endl;
	for(reverse_it=map1.rbegin();reverse_it!=map1.rend();reverse_it++)
	{
		cout<<reverse_it->first<<"\t"<<reverse_it->second<<endl;
	}
	int size = map1.size();
	cout<<"应用数组方法输出:"<<endl;
	for(int index=1;index<=size;index++)
	{
		cout<<index<<"\t"<<map1[index]<<endl;
	}
	return 0;
}
执行结果为：
应用前向迭代器输出:
1 John
2 Jeff
3 Smith
应用反向迭代器输出:
3 Smith
2 Jeff
1 John
应用数组方法输出:
1 John
2 Jeff
3 Smith

4.数据查找
1）用count函数判断关键字是否出现，它的缺点是不能定位关键字的位置。
2）用find函数，它会返回一个迭代器，如果查找到数据，则返回数据所在位置的迭代器，如果没有查找到，则返回end迭代器。
代码及分析如下：


#include <iostream>
#include <map>
#include <string>
using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	map<int,string> map1;
	map1.insert(pair<int,string>(1,"John"));   
	map1.insert(pair<int,string>(2,"Jeff"));   
	map1.insert(pair<int,string>(3,"Smith"));
	map<int,string>::iterator it;   //前向迭代器遍历输出
	cout<<"应用前向迭代器输出:"<<endl;
	for(it=map1.begin();it!=map1.end();it++)
	{
		cout<<it->first<<"\t"<<it->second<<endl;
	}
	if (map1.count(1)!=0)	//用count函数来进行查找
	{
		cout<<"1 is in map"<<endl;
	}
	else
	{
		cout<<"1 is not in map"<<endl;
	}
	if(map1.find(4)!=map1.end())	//用find函数来进行查找
	{
		cout<<"4 is in map"<<endl;
	}
	else
	{
		cout<<"4 is not in map"<<endl;
	}
	return 0;
}
执行结果为：
应用前向迭代器输出:
1 John
2 Jeff
3 Smith
1 is in map
4 is not in map

5.map使用[ ]符号注意事项
使用[ ]对map进行插入或者查找操作非常便捷，但是如果map下标符运用不得当，就会造成意想不到的问题。对于map而言，并没有下标越界的概念，但是却有可能发生关键字在map中不存在的问题。如果访问的关键字在map中并不存在，则map会自动生成相应的关键字，并会给定一个默认的初始值。
代码和解析如下：


#include <iostream>
#include <map>
#include <string>
using namespace std;
int _tmain(int argc, _TCHAR* argv[])
{
	map<int,string> map1;
	map1.insert(pair<int,string>(1,"John"));   
	map1.insert(pair<int,string>(2,"Jeff"));   
	map1.insert(pair<int,string>(3,"Smith"));
	if (map1[4] == "Kevin")   //4不存在，map会自动添加，并初始化值为空，即“”
	{
		map1[4]="Cathy";
	}
	map<int,string>::iterator it;   //前向迭代器遍历输出
	cout<<"应用前向迭代器输出:"<<endl;
	for(it=map1.begin();it!=map1.end();it++)
	{
		cout<<it->first<<"\t"<<it->second<<endl;
	}
	return 0;
}
执行结果为：
应用前向迭代器输出:
1 John
2 Jeff
3 Smith
4
如输出所示，最后输出4的值为空。这是因为在进行查找操作时，map自动添加4为关键字，且它的值为空。所以，判断语句一直不成立，最后输出仍然为空。


版权声明：本文为博主原创文章，未经博主允许不得转载。

2015-8-26-java语法-优先队列
优先队列说白了就跟对一堆数排序一样，后面插进来的数要找个合适的位置插进去，java里面的优先队列用起来很简单，毕竟java本身就是民工语言，java里面一般是对两个对象的成员进行比较排序，比如下文中Person,每个Person对象都有age这个成员，可以根据age的大小来比较。由于java提供的是 Comparator<E>这个接口，还用到了模板，看一下源码，比较器第一个参数是刚添加的对象，第二个参数是队列已有的对象，如果比较函数  public int compare(Person o1, Person
 o2)返回值>=0就停止搜索，把该新添加的元素放在这个位置，如果<0,继续搜索直到找到队列的头。


package prority;


import java.util.Comparator;
import java.util.Iterator;
import java.util.PriorityQueue;


public class YY {
public static void main(String[] args) {
//一般把两个对象放进去，比较两个对象里的元素
Comparator<Person> OrderIsdn =  new Comparator<Person>(){  
            public int compare(Person o1, Person o2) { 
            //第一个参数是后面添加进来的元素，返回值>=0元素才不需要重新排序
                int age1 = o1.age;  
                int age2 = o2.age;  
                if(age1<age2)  
                {  
                    return -1;  
                } 
                else  
                {  
                    return 0;  
                }  
              
            }  
        }; 
        
        PriorityQueue<Person> priorityQueue =  new PriorityQueue<Person>(11,OrderIsdn);  
        
        
        
        Person t1 = new Person("t1",1);  
        Person t3 = new Person("t3",3);  
        Person t2 = new Person("t2",2);  
        Person t4 = new Person("t4",0);  
        priorityQueue.add(t1);  
       // priorityQueue.add(t1); //重复元素会添加 
        priorityQueue.add(t3);  
        priorityQueue.add(t2);  
        priorityQueue.add(t4); 
        Iterator<Person> iterator=priorityQueue.iterator();
        
        while(iterator.hasNext()){
        
        System.out.println(iterator.next().age);
        }
        
    
        
        
        
        
}


}
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 1163 	The Triangle
题目大意: 从三角形顶部数字走，每次只能走到这个数字的左下角或者右下角的数字，直到底部，计算走过的线路的数字之和，求这个和的最大值
解题思路: 这道题如果用枚举法（暴力思想），在数塔层数稍大的情况下（如31），则需要列举出的路径条数将是一个非常庞大的数目（2^30= 1024^3 > 10^9=10亿）。 
因此我们可以从下往上推，相邻的两个数中找较大的与上层相加，得出的结果相邻的两个数中再找较大的与上层相加，以此类推。
#include <cstdio>
#include <algorithm>
using namespace std;

int main() {
    int N;
    while (scanf("%d", &N) != EOF) {
        int DP[110][110];
        for (int i = 0; i < N; i++)
            for (int j = 0; j <= i; j++)
                scanf("%d", &DP[i][j]);
        for (int i = N-2; i >= 0; i--)
            for (int j = 0; j <= i; j++)
                DP[i][j] += max(DP[i+1][j], DP[i+1][j+1]);

        printf("%d\n", DP[0][0]);
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 1195 Mobile phones(二维树状数组，点修改，区间查询)
题目链接：POJ 1195 Mobile phones

 
【题目大意】







如图所示，开始的操作为 0  初始化 S * S大小的地图，值为0
操作 1， 输入 X Y A， 将地图中坐标为 （X,Y）的值修改为A
操作2， 输入 L B R T 查询 区间    (X,Y)   L<=X<=R , B<=Y<=T,  输出该矩形区间的和；
操作 3 结束程序


典型的二维树状数组
二维树状数组和一维树状数组原理是一样的。


我们先回顾一维树状数组 C【maxn】，
它的储存结构

C1 = A1
C2 = A1 + A2
C3 = A3
C4 = A1 + A2 + A3 + A4
C5 = A5
C6 = A5 + A6
    
   
C7 = A7
C8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8
……
C16 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10 + A11 + A12 + A13 + A14 + A15 + A16
...... 


而二维树状数组的第二维 与普通一维树状数组原理是一样的
设二维树状数组为 C[][]


例：举个例子来看看C[][]的组成。
     设原始二维数组为：
　 A[][]={{a11,a12,a13,a14,a15,a16,a17,a18,a19},
         {a21,a22,a23,a24,a25,a26,a27,a28,a29},
         {a31,a32,a33,a34,a35,a36,a37,a38,a39}，
         {a41,a42,a43,a44,a45,a46,a47,a48,a49}};
那么它对应的二维树状数组C[][]呢？ 


B[1]={a11,a11+a12,a13,a11+a12+a13+a14,a15,a15+a16,...}  这是第一行的一维树状数组
B[2]={a21,a21+a22,a23,a21+a22+a23+a24,a25,a25+a26,...} 这是第二行的一维树状数组
B[3]={a31,a31+a32,a33,a31+a32+a33+a34,a35,a35+a36,...} 这是第三行的一维树状数组
B[4]={a41,a41+a42,a43,a41+a42+a43+a44,a45,a45+a46,...} 这是第四行的一维树状数组


那么：
C[1][1]=a11,C[1][2]=a11+a12,C[1][3]=a13,C[1][4]=a11+a12+a13+a14,c[1][5]=a15,C[1][6]=a15+a16,...
   这是A[][] 第一行 的一维树状数组

C[2][1]=a11+a21,C[2][2]=a11+a12+a21+a22,C[2][3]=a13+a23,C[2][4]=a11+a12+a13+a14+a21+a22+a23+a24,C[2][5]=a15+a25,C[2][6]=a15+a16+a25+a26,...
   这是A[][]数组 第一行与第二行 相加后的树状数组

C[3][1]=a31,C[3][2]=a31+a32,C[3][3]=a33,C[3][4]=a31+a32+a33+a34,C[3][5]=a35,C[3][6]=a35+a36,...
   这是A[][] 第三行 的一维树状数组

C[4][1]=a11+a21+a31+a41,C[4][2]=a11+a12+a21+a22+a31+a32+a41+a42,C[4][3]=a13+a23+a33+a43,...
    这是A[][]数组 第一行+第二行+第三行+第四行 
后的树状数组 



注意加粗的部分，可以看出第二维之间储存值的关系和 第一维之间储存值得关系是一样的 ，
储存的项数都是 lowbit(i)。
所以修改和查询的函数，嵌套两个for循环就可以完成了

void modify(int a,int b,int val){
	for(int i=a;i<=n;i+=lowbit(i)){
		for(int j=b;j<=n;j+=lowbit(j))
			s[i][j]+=val;
	}
}
int sum(int x,int y){
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i)){
		for(int j=y;j>0;j-=lowbit(j))
			ans+=s[i][j];
	}
	return ans;
}


以上数据来源： 
树状数组讲的很好的文章



【源代码】

#include<iostream>
#include<string>
#include<cstring>
#include<cstdio>
using namespace std;
const int maxn = 1111;
int s[maxn][maxn];
int n;
int lowbit(int x){ //求x二进制表示的最后一个1所在位置，，当然返回的值是最后一个1及其后面0所组成的二进制数
	return x&(-x);
}
void modify(int a,int b,int val){
	for(int i=a;i<=n;i+=lowbit(i)){
		for(int j=b;j<=n;j+=lowbit(j))
			s[i][j]+=val;
	}
}
int sum(int x,int y){
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i)){
		for(int j=y;j>0;j-=lowbit(j))
			ans+=s[i][j];
	}
	return ans;
}
int getsum(int x1,int y1,int x2,int y2){
	return sum(x2,y2)-sum(x1-1,y2)-sum(x2,y1-1)+sum(x1-1,y1-1); //先求最大区间 ，减去上面多余的，左边多余的， 加上左上角减去两次的。
}
int main(){
	int op;
	while(scanf("%d%d",&op,&n)!=EOF){
		memset(s,0,sizeof(s));
		int order;
		int a,b,c,d;
		while(scanf("%d",&order)!=EOF && order != 3){
			if(order==1){
				scanf("%d%d%d",&a,&b,&c);
				modify(a+1,b+1,c);
			}
			else {
				scanf("%d%d%d%d",&a,&b,&c,&d);
				int ans = getsum(a+1,b+1,c+1,d+1);
				printf("%d\n",ans);
			}
		}
	}
	
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        静态链表 C++实现
用数组描述的链表，即称为静态链表。
在C语言中，静态链表的表现形式即为结构体数组，结构体变量包括数据域data和游标cur。

这种存储结构，仍需要预先分配一个较大的空间，但在作为线性表的插入和删除操作时不需移动元素，仅需修改指针，故仍具有链式存储结构的主要优点。

下图表示了静态链表的一中存储结构：
      图中用彩色途上的是两个头结点，不存放数据，分别用来记录第一个备用节点和第一个数据节点的下标。
下面给出静态链表的C++实现代码：

首先给出头文件：StaticList.h:

#include<iostream>
#include<assert.h>
using namespace std;

#define MAXSIZE 20        // 静态链表（数组）默认长度
#define ElemType int      // 值类型

class StaticList;

//节点类
typedef class StaticListNode   // 静态链表的节点类型（数组元素类型）
{
    friend class StaticList;
private:
    ElemType data;              // 值域
    int      cur;               // 游标 （指示当前节点的下一个元素下标）
}StaticListNode;


//  静态链表类</strong></span>
class StaticList
{
public:
    StaticList()
    {
        for(int i = 2; i<MAXSIZE-1; ++i)
            space[i].cur = i+1;
        space[i].cur = 0;        //整个链表结束
        space[0].cur = 2;
        space[1].cur = 0;        //数据节点头的游标为空，没有数据
    }
    
    ~StaticList()
    {}
    
// 尾部插入法
    void push_back(const ElemType &x)
    {
        int i = Malloc_SL();
        if(0 == i)              // 空间申请失败
        {
            cout<<"已满！"<<x<<"不能插入"<<endl;   
            return ;
        }
        space[i].data = x;
        space[i].cur = 0;
        
        int k = 1;
        while(0!=k && 0!=space[k].cur)  // 找到最后一个节点
            k = space[k].cur;
        
        space[k].cur = i;             // 把刚申请的下标为i的节点链到最后一个节点后面              
    }
    
// 头部插入法
    void push_front(const ElemType &x)
    {
        int i = Malloc_SL();
        if(0 == i)            // 同上，空间申请失败
        {
            cout<<"已满！"<<x<<"不能插入"<<endl;
            return ;
        }
        space[i].data = x;    // 把x放入刚申请的节点中
        
        space[i].cur = space[1].cur;   // 此时刚申请的节点i的游标指向第一个数据节点，称为第一个结点
        space[1].cur = i;              // 使头结点指向第一个数据节点
    }
    
// 尾部删除
    void pop_back()
    {
        int i = space[1].cur;
        int j = 0;
        for(; 0!=space[i].cur; j = i, i = space[i].cur)
        {}    // 找到最后一个节点以及倒数第二个节点
      
        space[j].cur = 0;     // 倒数第二个节点的游标赋空
        Free_SL(i);           // 最后一个节点被释放
    }
    
// 头部删除
    void pop_front()
    {
        int i = space[1].cur;    // i是第一个数据节点的下标
        space[1].cur = space[i].cur;  // 头结点指向第二个数据节点的下标
        Free_SL(i);              // i 节点被释放
    }
    
    void show_list()
    {
        for(int i = space[1].cur; i!=0; i = space[i].cur)
            cout<<space[i].data<<" ";
        cout<<"Over"<<endl;
    }
    
    /* 静态链表从小到大排序的前提下，插入x  */
    void insert_val(const ElemType &x)
    {
        int k = 1;
        while(0!=k && 0!=space[k].cur && space[space[k].cur].data<x)
            k = space[k].cur;        //在下标k之后插入
        
        if(0 == space[k].cur)    // 如果k指向最后一个节点，执行尾插
            push_back(x);
        else if(k == 1)          // 如果k指向第一个节点，执行头插
            push_front(x);
        else                     // 在中间任意位置插入x
        {    
            int i = Malloc_SL();
            assert(0 != i);
            space[i].data = x;
            space[i].cur = space[k].cur;   // i节点的游标指向k节点后面的一个节点
            space[k].cur = i;              // k节点的游标指向新开辟的i节点
        }
    }
    
    /* 返回key的前一个节点下标*/
    int find(const ElemType &key)       
    {
        int i = 1;
        while(0!=i && space[space[i].cur].data!=key)
            i = space[i].cur;
        if(0 == i)
        {
            cout<<"没找到 "<<key<<endl;
            return -1;
        }
        return i;
    }
    
    /* 删除给定的值key所在节点，若没找到则返回 */
    void delete_val(const ElemType &key)
    {
        int i = find(key);
        if(-1 == i)      // 说明静态链表中没有元素key
            return ;
        else if(1 == i)  // key 处于下标为2的节点(第一个数据节点)
            pop_front();
        else if(0 == space[i].cur)  // key处于最后一个节点
            pop_back();
        else             // key 处于中间任意位置
        {
            int k = space[i].cur;   // 记录要删除位置的下标
            space[i].cur = space[k].cur;  // 脱离出要删除节点
            Free_SL(k);  // 删除key所在节点
        }
    }
    
    /* sl1 和 sl2已存在，把它们糅合到另一个链表，使之按非递减排列 */
    void merge(StaticList &sl1, StaticList &sl2)
    {
        sl1.sort();   
        sl2.sort();
        if(0==sl1.length() || 0==sl2.length())
            return ;
        int p = sl1.space[1].cur;
        int q = sl2.space[1].cur;
        
        while(0!=p && 0!=q)
        {        
            // 哪个数据较小，就把该数据尾插到新链表中，并使游标指向下一个
            if(sl1.space[p].data < sl2.space[q].data)
            {            
                push_back(sl1.space[p].data);
                p = sl1.space[p].cur;
            }
            else
            {
                push_back(sl2.space[q].data);
                q = sl2.space[q].cur;
            }
        }
        while(0!=p)
        {        // 因为sl1已经有序，如果sl1还没有全部插入新链表，就把剩下的全部插入
            push_back(sl1.space[p].data);
            p = sl1.space[p].cur;
        }
        while(0!=q)
        {        // 因为sl2已经有序，如果sl2还没有全部插入新链表，就把剩下的全部插入
            push_back(sl2.space[q].data);
            q = sl2.space[q].cur;
        }
    }
    
    /* 如果静态链表无序，使其按非递减顺序排列 */
    void sort()
    {
        int s = space[1].cur;
        int p = space[s].cur;
        if(0 == p)
            return ;
        space[s].cur = 0;
        
        int k = 1;
        int k1 = 0;
        while(0 != p)
        {
            s = p;
            p = space[p].cur;
            
            k = 1;     // 找到一个位置k, 在k后插入s所指节点的数据
            while(0!=k && space[space[k].cur].data < space[s].data)
            {
                k1 = k;                  //如果k==0,用k1记录最后一个数据节点
                k = space[k].cur;        //在下标k之后插入
            }
            if(0 == k)    //尾插
            {
                space[k1].cur = s;
                space[s].cur = 0;
            }
            else          //头插和中间插
            {
                space[s].cur = space[k].cur;
                space[k].cur = s;
            }
        }
    }
    
    /* 逆置静态链表 */
    void reserve()
    {
        int s = space[1].cur;
        int p = space[s].cur;
        if( 0==p )
            return ;
        space[s].cur = 0;
        while(0 != p)
        {
            s = p;
            p = space[p].cur;
            
            space[s].cur = space[1].cur;   // 把s所指节点 头插进原有链表
            space[1].cur = s;              // s成为第一个数据节点
        }
    }
    
    /* 清空静态链表 */
    void clear()
    {
        for(int i = 2; i<MAXSIZE-1; ++i)
            space[i].cur = i+1;
        space[i].cur = 0;
        
        space[0].cur = 2;     // 下标2成为第一个备用节点
        space[1].cur = 0;     // 第一个数据节点为空
    }
    
    /* 返回表长 */
    int length()
    {
        if(0 == space[1].cur)
            return 0;
        int i = 1;
        int count = -1;
        do
        {
            ++count;
            i = space[i].cur;
        }while(0 != i);
        
        return count;
    }
    
    /* 返回下标为k的节点的下一个节点下标 在静态链表中用处不大*/
    int next(const int k)
    {
        if(0==k || 1==k)
            return -1;
        return space[k].cur;
    }
    /* 返回下标为k的节点的上一个节点下标 */
    int prio(const int k)
    {
        if(0==k || 1==k)
            return -1;
        int p = 1;
        while(0!=p && space[p].cur!=k)
            p = space[p].cur;
        return p;
    }
    
protected:
    /* 用来申请一个空间，返回该节点的下标 */
    int Malloc_SL()   
    {
        int i = space[0].cur;   // 0下标的游标指向第一个备用节点
        if(space[0].cur) space[0].cur = space[i].cur;  // 修改头结点保存的第一个备用节点下标  
        return i;
    }
    /* 释放下标为k的节点 */
    void Free_SL(int k)   
    {
        space[k].cur = space[0].cur;    // 该节点的游标指向第一个备用节点
        space[0].cur = k;               // 该节点称为第一个备用节点
    }
    
private:
    StaticListNode space[MAXSIZE];
};


下面是测试代码：
       Main.cpp
 #include"StaticList.h"

void main()
{
	StaticList SL;

	StaticList SL1;    //测试merge()
	StaticList SL2;
	
	SL1.push_back(1);
	SL1.push_back(9);
	SL1.push_back(0);
	SL1.push_back(6);
	SL1.push_back(999);

	SL2.push_back(5);
	SL2.push_back(8);
	SL2.push_back(100);

	ElemType Item = 0;
	int select = 1;
	while(select)
	{
		cout<<"********************************************"<<endl;
		cout<<"*[1] push_back           [2]  push_front   *"<<endl;
		cout<<"*[3] show_list           [4]  pop_back     *"<<endl;
		cout<<"*[5] pop_front           [6]  insert_val   *"<<endl;
		cout<<"*[7] length              [8]  find         *"<<endl;
		cout<<"*[9] merge               [10] delete_ val  *"<<endl;
		cout<<"*[11] sort               [12] reserve      *"<<endl;
		cout<<"*[13] next               [14] prio         *"<<endl;
		cout<<"*[15] clear              [16] destroy      *"<<endl;
		cout<<"*[0] quit_sys                              *"<<endl;
		cout<<"********************************************"<<endl;
		cout<<"请选择：》";
		cin>>select;
		switch(select)
		{
		case 1:
			cout<<"输入要尾插的数据:(-1结束)>";
			while(cin>>Item && -1 != Item)
				SL.push_back(Item);
			break;

		case 2:
			cout<<"输入要头插的数据:(-1结束)>";
			while(cin>>Item && -1 != Item)
				SL.push_front(Item);
			break;

		case 3:
			SL.show_list();
			break;
		case 4:
			SL.pop_back();
			break;

		case 5:
			SL.pop_front();
			break;

		case 6:
			cout<<"输入要插入的数据:>";
			cin>>Item;
			SL.insert_val(Item);
			break;

		case 7:
			cout<<"链表长度为："<<SL.length()<<endl;
			break;

		case 8:
			cout<<"输入要查找的数据:>";
			cin>>Item;
			SL.find(Item);
			break;
		
		case 9:
			SL.merge(SL1, SL2);
			break;

		case 10:
			cout<<"输入要删除的数据:>";
			cin>>Item;
			SL.delete_val(Item);
			break;

		case 11:
			SL.sort();
			break;

		case 12:
			SL.reserve();
			break;
		
		case 13:
			SL.next(0);
			break;

		case 14:
			SL.prio(0);
			break;

		case 15:
			SL.clear();
			break;
	
		case 16:
			SL.~StaticList();
			break;

		default:
			break;
		}
	}
}




下面是测试截图：





版权声明：本文为博主原创文章，未经博主允许不得转载。

uva 1351 区间dp
UVA 1351 - String Compression



问一个字符串经过压缩后最短可以到多短。压缩规则是如果有连续的重复子串(如:abcabcabcad)可以压缩成重复次数 + ( 重复子串) (前面例子的答案: 3(abc)ad
 )。压缩后的串长度要把数字和括号计算在内。

区间dp，dp存该区间能压缩的最小长度。
对于每个区间可以被分成两个子区间，或者该区间可以压缩。预处理出每个区间可以最多的由几个子串重复组成:c[i][j]。

dp[i][j] = min{dp[i][k] + dp[k][j], digits(s) + dp[i][l] + 2};
l = (j-i+1)/c[i][j];
s = c[i][j];

而对于c数组的预处理可以O(n^3)完成。枚举重复子串的长度和起始位置，然后从起始位置找，每找到一个串c[i][j]+1;具体见代码。





#include <bits/stdc++.h>

using namespace std;

const int INF = 999999999;

int len;
char s[205];
int _c[205][205];
int dp[205][205];

int _degits(int num) {
	int cnt = 0;
	while (num) {
		cnt++;
		num /= 10;
	}
	return cnt;
}

void _solve() {
	for(int i=0; i<len; i++) {
		for (int j=i; j<len; j++) {
			_c[i][j] = 1;
		}
	}

	for (int l=1; l<=len; l++) {
		for (int i=0; i<len; i++) {
			for (int j=i+l; j<len; j++) {
				if (s[j] != s[i + (j-i-l)%l]) break;
				if ((j-i-l) % l == l-1) {
					_c[i][j] = max(_c[i][j], _c[i][j-l] + 1);
				}
			}
		}
	}
}

int main () {
	int T;
	for (scanf ("%d", &T); T>0; T--) {
		scanf ("%s", s);
		len = strlen(s);

		_solve();


		for (int i=0; i<len; i++) {
			dp[i][i] = 1;
		}

		for (int j=1; j<len; j++) {
			for (int i=j-1; i>=0; i--) {
				dp[i][j] = INF;
				for (int k=i; k<j; k++) {
					dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]);
				}
				int l = (j-i+1)/_c[i][j];
				dp[i][j] = min(dp[i][j], dp[i][i+l-1] + 2 + _degits(_c[i][j]));
			}
		}

		printf ("%d\n", dp[0][len-1]);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

使用CUBLAS的一些小例子
1. 矩阵相乘再加 C = a*A*B + b*C
#include "cuda_runtime.h"
#include "cublas_v2.h"

#include <time.h>
#include <iostream>

using namespace std;

int const M = 6;
int const N = 10;

int main()
{
	cublasStatus_t status;

	//Host memory malloc
	float *h_A = (float*)malloc(N*M*sizeof(float));
	float *h_B = (float*)malloc(N*M*sizeof(float));
	float *h_C = (float*)malloc(M*M*sizeof(float));
	float *h_C_cpu = (float*)malloc(M*M*sizeof(float));
	memset(h_C_cpu,0,M*M*sizeof(float));

	//Initialize and print
	for (int i=0; i<M*N; i++)
	{
		h_A[i] = (float)(rand()%10+1);
		h_B[i] = (float)(rand()%10+1);
	}
	cout << "Matrix A is:" << endl;
	for (int i=0; i<M*N; i++)
	{
		cout << h_A[i] << " ";
		if ((i+1)%N == 0)
		{
			cout << endl;
		}
	}
	cout << endl;
	cout << "Matrix B is:" << endl;
	for (int i=0; i<M*N; i++)
	{
		cout << h_B[i] << " ";
		if ((i+1)%M == 0)
		{
			cout << endl;
		}
	}
	cout << endl;

	//CPU caculate
	for(int i = 0; i<M; i++)
	{
		for(int j=0; j<M; j++)
		{
			for(int k=0; k<N; k++)
			{
				h_C_cpu[i*M+j] = h_C_cpu[i*M+j]+h_A[i*N+k]*h_B[k*M+j]*1 + 0;
			}
		}
	}
	cout << "The result from CPU is:" << endl;
	for (int i=0; i<M*M; i++)
	{
		cout << h_C_cpu[i] << " ";
		if ((i+1)%M == 0)
		{
			cout << endl;
		}
	}
	cout << endl;
	//Create handle;
	cublasHandle_t handle;
	status = cublasCreate(&handle);
	if (status != CUBLAS_STATUS_SUCCESS)
	{
		if (status == CUBLAS_STATUS_NOT_INITIALIZED)
		{
			cout << "Fail to get an instance of blas object! Check whether you have free the handle!" << endl;
		}
		getchar();
		return EXIT_FAILURE;
	}

	//Device memory malloc and initialize
	float *d_A, *d_B, *d_C;
	cudaMalloc((void**)&d_A, N*M*sizeof(float));
	cudaMalloc((void**)&d_B, N*M*sizeof(float));
	cudaMalloc((void**)&d_C, M*M*sizeof(float));

	cublasSetVector(N*M, sizeof(float), h_A, 1, d_A, 1);
	cublasSetVector(N*M, sizeof(float), h_B, 1, d_B, 1);

	cudaThreadSynchronize();

	//Call gpu operation
	float a = 1;
	float b = 0;
	const float *ca = &a;
	const float *cb = &b;

	cublasSgemm(
		handle,
		CUBLAS_OP_T,
		CUBLAS_OP_T,
		M,
		M,
		N,
		ca,
		d_A,
		N,
		d_B,
		M,
		cb,
		d_C,
		M
		);
	cudaThreadSynchronize();
	cublasGetVector(M*M, sizeof(float), d_C, 1, h_C, 1);

	cout << "The result from GPU is:" << endl;
	for (int i=0; i<M; i++)
	{
		for(int j=0; j<M; j++)
		{
			cout << h_C[j*M + i] << " ";
		}
		cout << endl;
	}
	
	//Cleaning...
	free(h_A);
	free(h_B);
	free(h_C);
	cudaFree(d_A);
	cudaFree(d_B);
	cudaFree(d_C);

	cublasDestroy(handle);

	return 0;
}


2.更规范的一个例子，由SDK中的例子改编，与1类似，比较了CPU与GPU运算效率：


/*
 * Copyright 1993-2014 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO USER:
 *
 * This source code is subject to NVIDIA ownership rights under U.S. and
 * international Copyright laws.  Users and possessors of this source code
 * are hereby granted a nonexclusive, royalty-free license to use this code
 * in individual and commercial software.
 *
 * NVIDIA MAKES NO REPRESENTATION ABOUT THE SUITABILITY OF THIS SOURCE
 * CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR
 * IMPLIED WARRANTY OF ANY KIND.  NVIDIA DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOURCE CODE, INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL,
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION WITH THE USE
 * OR PERFORMANCE OF THIS SOURCE CODE.
 *
 * U.S. Government End Users.   This source code is a "commercial item" as
 * that term is defined at  48 C.F.R. 2.101 (OCT 1995), consisting  of
 * "commercial computer  software"  and "commercial computer software
 * documentation" as such terms are  used in 48 C.F.R. 12.212 (SEPT 1995)
 * and is provided to the U.S. Government only as a commercial end item.
 * Consistent with 48 C.F.R.12.212 and 48 C.F.R. 227.7202-1 through
 * 227.7202-4 (JUNE 1995), all U.S. Government End Users acquire the
 * source code with only those rights set forth herein.
 *
 * Any use of this source code in individual and commercial software must
 * include, in the user documentation and internal comments to the code,
 * the above Disclaimer and U.S. Government End Users Notice.
 */

/* This example demonstrates how to use the CUBLAS library
 * by scaling an array of floating-point values on the device
 * and comparing the result to the same operation performed
 * on the host.
 */

/* Includes, system */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include "time.h"
/* Includes, cuda */
#include <cuda_runtime.h>
#include <cublas_v2.h>
#include <helper_cuda.h>
using namespace std;
/* Matrix size */
#define N  (600)

/* Host implementation of a simple version of sgemm */
static void simple_sgemm(int n, float alpha, const float *A, const float *B,
                         float beta, float *C)
{
    int i;
    int j;
    int k;

    for (i = 0; i < n; ++i)
    {
        for (j = 0; j < n; ++j)
        {
            float prod = 0;

            for (k = 0; k < n; ++k)
            {
                prod += A[k * n + i] * B[j * n + k];
            }

            C[j * n + i] = alpha * prod + beta * C[j * n + i];
        }
    }
}

/* Main */
int main(int argc, char **argv)
{
    cublasStatus_t status;
    float *h_A;
    float *h_B;
    float *h_C;
    float *h_C_ref;
    float *d_A = 0;
    float *d_B = 0;
    float *d_C = 0;
    float alpha = 1.0f;
    float beta = 0.0f;
    int n2 = N * N;
    int i;
    float error_norm;
    float ref_norm;
    float diff;
    cublasHandle_t handle;


	clock_t cuStart,cuFinish;
	clock_t start,finish;

	
    int dev = findCudaDevice(argc, (const char **) argv);

    if (dev == -1)
    {
        return EXIT_FAILURE;
    }

    /* Initialize CUBLAS */
    printf("simpleCUBLAS test running..\n");

	

    status = cublasCreate(&handle);

    if (status != CUBLAS_STATUS_SUCCESS)
    {
        fprintf(stderr, "!!!! CUBLAS initialization error\n");
        return EXIT_FAILURE;
    }

    /* Allocate host memory for the matrices */
    h_A = (float *)malloc(n2 * sizeof(h_A[0]));

    if (h_A == 0)
    {
        fprintf(stderr, "!!!! host memory allocation error (A)\n");
        return EXIT_FAILURE;
    }

    h_B = (float *)malloc(n2 * sizeof(h_B[0]));

    if (h_B == 0)
    {
        fprintf(stderr, "!!!! host memory allocation error (B)\n");
        return EXIT_FAILURE;
    }

    h_C = (float *)malloc(n2 * sizeof(h_C[0]));

    if (h_C == 0)
    {
        fprintf(stderr, "!!!! host memory allocation error (C)\n");
        return EXIT_FAILURE;
    }

    /* Fill the matrices with test data */
    for (i = 0; i < n2; i++)
    {
        h_A[i] = rand() / (float)RAND_MAX;
        h_B[i] = rand() / (float)RAND_MAX;
        h_C[i] = rand() / (float)RAND_MAX;
    }
	cuStart = clock();
    /* Allocate device memory for the matrices */
    if (cudaMalloc((void **)&d_A, n2 * sizeof(d_A[0])) != cudaSuccess)
    {
        fprintf(stderr, "!!!! device memory allocation error (allocate A)\n");
        return EXIT_FAILURE;
    }

    if (cudaMalloc((void **)&d_B, n2 * sizeof(d_B[0])) != cudaSuccess)
    {
        fprintf(stderr, "!!!! device memory allocation error (allocate B)\n");
        return EXIT_FAILURE;
    }

    if (cudaMalloc((void **)&d_C, n2 * sizeof(d_C[0])) != cudaSuccess)
    {
        fprintf(stderr, "!!!! device memory allocation error (allocate C)\n");
        return EXIT_FAILURE;
    }

    /* Initialize the device matrices with the host matrices */
    status = cublasSetVector(n2, sizeof(h_A[0]), h_A, 1, d_A, 1);

    if (status != CUBLAS_STATUS_SUCCESS)
    {
        fprintf(stderr, "!!!! device access error (write A)\n");
        return EXIT_FAILURE;
    }

    status = cublasSetVector(n2, sizeof(h_B[0]), h_B, 1, d_B, 1);

    if (status != CUBLAS_STATUS_SUCCESS)
    {
        fprintf(stderr, "!!!! device access error (write B)\n");
        return EXIT_FAILURE;
    }

    status = cublasSetVector(n2, sizeof(h_C[0]), h_C, 1, d_C, 1);

    if (status != CUBLAS_STATUS_SUCCESS)
    {
        fprintf(stderr, "!!!! device access error (write C)\n");
        return EXIT_FAILURE;
    }
	
    /* Performs operation using cublas */
    status = cublasSgemm(handle, CUBLAS_OP_N, CUBLAS_OP_N, N, N, N, &alpha, d_A, N, d_B, N, &beta, d_C, N);

    if (status != CUBLAS_STATUS_SUCCESS)
    {
        fprintf(stderr, "!!!! kernel execution error.\n");
        return EXIT_FAILURE;
    }

    /* Allocate host memory for reading back the result from device memory */
    h_C_ref = (float *)malloc(n2 * sizeof(h_C[0]));

    if (h_C_ref == 0)
    {
        fprintf(stderr, "!!!! host memory allocation error (C)\n");
        return EXIT_FAILURE;
    }

    /* Read the result back */
    status = cublasGetVector(n2, sizeof(h_C[0]), d_C, 1, h_C_ref, 1);

    if (status != CUBLAS_STATUS_SUCCESS)
    {
        fprintf(stderr, "!!!! device access error (read C)\n");
        return EXIT_FAILURE;
    }


	cuFinish = clock();

	start = clock();
	/* Performs operation using plain C code */
	simple_sgemm(N, alpha, h_A, h_B, beta, h_C);
	finish = clock();

	cout<<"GPU TIME:"<<(double)(cuFinish - cuStart)/CLOCKS_PER_SEC<<endl;
	cout<<"CPU TIME:"<<(double)(finish - start)/CLOCKS_PER_SEC<<endl;


    /* Check result against reference */
    error_norm = 0;
    ref_norm = 0;

    for (i = 0; i < n2; ++i)
    {
        diff = h_C_ref[i] - h_C[i];
        error_norm += diff * diff;
        ref_norm += h_C_ref[i] * h_C_ref[i];
    }

    error_norm = (float)sqrt((double)error_norm);
    ref_norm = (float)sqrt((double)ref_norm);
	std::cout<<error_norm<<"\t"<<ref_norm<<std::endl;


    if (fabs(ref_norm) < 1e-7)
    {
        fprintf(stderr, "!!!! reference norm is 0\n");
        return EXIT_FAILURE;
    }

    /* Memory clean up */
    free(h_A);
    free(h_B);
    free(h_C);
    free(h_C_ref);

    if (cudaFree(d_A) != cudaSuccess)
    {
        fprintf(stderr, "!!!! memory free error (A)\n");
        return EXIT_FAILURE;
    }

    if (cudaFree(d_B) != cudaSuccess)
    {
        fprintf(stderr, "!!!! memory free error (B)\n");
        return EXIT_FAILURE;
    }

    if (cudaFree(d_C) != cudaSuccess)
    {
        fprintf(stderr, "!!!! memory free error (C)\n");
        return EXIT_FAILURE;
    }

    /* Shutdown */
    status = cublasDestroy(handle);

    if (status != CUBLAS_STATUS_SUCCESS)
    {
        fprintf(stderr, "!!!! shutdown error (A)\n");
        return EXIT_FAILURE;
    }

    if (error_norm / ref_norm < 1e-6f)
    {
        printf("simpleCUBLAS test passed.\n");
        exit(EXIT_SUCCESS);
    }
    else
    {
        printf("simpleCUBLAS test failed.\n");
        exit(EXIT_FAILURE);
    }
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu5402 Travelling Salesman Problem(棋盘染色+模拟)
题目：

Travelling Salesman Problem
Time Limit: 3000/1500 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 906    Accepted Submission(s): 331
Special Judge

Problem Description
Teacher Mai is in a maze with 
n
 rows and m
 columns. There is a non-negative number in each cell. Teacher Mai wants to walk from the top left corner(1,1)
 to the bottom right corner (n,m).
 He can choose one direction and walk to this adjacent cell. However, he can't go out of the maze, and he can't visit a cell more than once.

Teacher Mai wants to maximize the sum of numbers in his path. And you need to print this path.

 

Input
There are multiple test cases.

For each test case, the first line contains two numbers 
n,m(1≤n,m≤100,n∗m≥2).

In following n
 lines, each line contains m
 numbers. The j-th
 number in the i-th
 line means the number in the cell (i,j).
 Every number in the cell is not more than 104.

 

Output
For each test case, in the first line, you should print the maximum sum.

In the next line you should print a string consisting of "L","R","U" and "D", which represents the path you find. If you are in the cell(x,y),
 "L" means you walk to cell (x,y−1),
 "R" means you walk to cell (x,y+1),
 "U" means you walk to cell (x−1,y),
 "D" means you walk to cell (x+1,y).

 

Sample Input

3 3
2 3 3
3 3 3
3 3 2

 

Sample Output

25
RRDLLDRR

 

Author
xudyh
 

Source
2015 Multi-University Training Contest 9
 

Recommend
wange2014
 

题意：给你一个nxm的迷宫，每个格子有一个非负整数，每次可以从一个格子移动到相邻格子，每个格子只能访问一次，问你从（1，1）到（n,m）经过的数字能够得到的最大和是多少，并且求出移动路径。
思路：由于每个格子是非负整数，当我们经过所有格子时肯定得到的和是最大的，于是问题就变成了我们是否能遍历所有的格子。当n或m为奇数时，显然可以，我们只要一行一行的走或一列一列的走就可以了。当n和m都为偶数时，如果我们把横坐标+纵坐标的和为奇数的点染成黑色，把偶数的点染成白色，那么棋盘上黑白棋子是一样多的，并且起点和终点都为黑色，所以从起点到终点的任意路径必然是黑色棋子比白色棋子多一个，故我们不能遍历所有的格子，一定会剩下一个白格子，为了使和最大，我们剩下值最小的白格子就可以了。
接下来说一下构造路径的过程，如果要跳过的白格子在偶数行，那么我们先用RRRRD和LLLLLD移动到它的上上一行，然后按照DR和UR遍历它的这一行和上一行，遇到它的列时用R跳过即可，接下来的行就按照LLLLLD和RRRRRD模拟就可以了；如果要跳过的白格子在奇数行，我们先移动到它的这一行，然后用同样的方法遍历它的这一行和它的下一行即可。
有一个坑点就是要跳过的格子在最后一列时不用R，直接D就行，WA了一次后及时发现了wwwwwww


代码：
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include<climits>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <fstream>
#include <numeric>
#include <iomanip>
#include <bitset>
#include <list>
#include <stdexcept>
#include <functional>
#include <utility>
#include <ctime>
using namespace std;

#define PB push_back
#define MP make_pair

#define REP(i,x,n) for(int i=x;i<(n);++i)
#define FOR(i,l,h) for(int i=(l);i<=(h);++i)
#define FORD(i,h,l) for(int i=(h);i>=(l);--i)
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define RI(X) scanf("%d", &(X))
#define RII(X, Y) scanf("%d%d", &(X), &(Y))
#define RIII(X, Y, Z) scanf("%d%d%d", &(X), &(Y), &(Z))
#define DRI(X) int (X); scanf("%d", &X)
#define DRII(X, Y) int X, Y; scanf("%d%d", &X, &Y)
#define DRIII(X, Y, Z) int X, Y, Z; scanf("%d%d%d", &X, &Y, &Z)
#define OI(X) printf("%d",X);
#define RS(X) scanf("%s", (X))
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
#define Swap(a, b) (a ^= b, b ^= a, a ^= b)
#define Dpoint  strcut node{int x,y}
#define cmpd int cmp(const int &a,const int &b){return a>b;}

 /*#ifdef HOME
    freopen("in.txt","r",stdin);
    #endif*/
const int MOD = 1e9+7;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef long long LL;
typedef pair<int,int> PII;
//#define HOME

int Scan()
{
	int res = 0, ch, flag = 0;

	if((ch = getchar()) == '-')				//判断正负
		flag = 1;

	else if(ch >= '0' && ch <= '9')			//得到完整的数
		res = ch - '0';
	while((ch = getchar()) >= '0' && ch <= '9' )
		res = res * 10 + ch - '0';

	return flag ? -res : res;
}
/*----------------PLEASE-----DO-----NOT-----HACK-----ME--------------------*/



int a[105][105];
int main()
{
int n,m;
while(RII(n,m)!=EOF)
{
    int sum=0;
    int M=100000;
    int px=1;
    int py=1;
    REP(i,0,n)
    REP(j,0,m)
    {RI(a[i][j]);
    sum+=a[i][j];
    if((i+j)%2==1&&a[i][j]<M)
        {
            M=a[i][j];
            px=i;
            py=j;
        }
    }
    if(n%2==1)
    {
        printf("%d\n",sum);
        for(int i=0;i<n;i++)
        {
            if(i%2==0)
            {  for(int j=0;j<m-1;j++)
            printf("R");
            if(i!=n-1)
                printf("D");

            }
            else
            {
                for(int j=0;j<m-1;j++)
                    printf("L");
                printf("D");
            }
        }
    }
    else
        if(m%2==1)
    {
        printf("%d\n",sum);
        for(int i=0;i<m;i++)
        {
            if(i%2==0)
            {


                    for(int j=0;j<n-1;j++)
                        printf("D");
                    if(i!=m-1)
                        printf("R");


            }
            else
            {
               for(int j=0;j<n-1;j++)
                printf("U");
               printf("R");
            }
        }
    }
    else
    {
      printf("%d\n",sum-M);
      if(px%2==0)
         {

             for(int i=0;i<px;i++)
      {
          if(i%2==0)
            {  for(int j=0;j<m-1;j++)
            printf("R");
            if(i!=n-1)
                printf("D");

            }
            else
            {
                for(int j=0;j<m-1;j++)
                    printf("L");
                printf("D");
            }

      }
             for(int i=0;i<py;i++)
             {
                 if(i%2==0)
                 printf("DR");
                 else
                printf("UR");
             }
             if(py<m-1)
             printf("R");
             else
             {
                 if(px+1!=n-1)
                    printf("D");
             }
             for(int i=py+1;i<m;i++)
             {
                 if(i%2==0)
                    printf("UR");
                else
                {
                    printf("D");
                    if(i==m-1)
                        {   if(px+1!=n-1)
                            printf("D");}
                    else
                        printf("R");
                }
             }
             for(int i=px+2;i<n;i++)
             {
                 if(i%2==0)
                 {
                     for(int j=0;j<m-1;j++)
                        printf("L");
                     printf("D");

                 }
                 else
                 {
                     for(int j=0;j<m-1;j++)
                        printf("R");
                     if(i!=n-1)
                        printf("D");
                 }
             }

         }
         else
         {
                for(int i=0;i<px-1;i++)
             {
                 if(i%2==0)
            {  for(int j=0;j<m-1;j++)
            printf("R");
            if(i!=n-1)
                printf("D");

            }
            else
            {
                for(int j=0;j<m-1;j++)
                    printf("L");
                printf("D");
            }


             }

             for(int i=0;i<py;i++)
             {
                 if(i%2==0)
                 {
                     printf("DR");
                 }
                 else
                    printf("UR");
             }
             printf("R");
             for(int i=py+1;i<m;i++)
             {
                 if(i%2==0)
                 {
                     printf("UR");
                 }
                 else
                 {
                     printf("D");
                     if(i==m-1)
                     {
                         if(px!=n-1)
                         {
                             printf("D");
                         }
                     }
                     else
                     {
                         printf("R");
                     }
                 }
             }
             for(int i=px+1;i<n;i++)
             {
                 if(i%2==0)
                 {
                     for(int j=0;j<m-1;j++)
                        printf("L");
                     printf("D");
                 }
                 else
                 {
                     for(int j=0;j<m-1;j++)
                        printf("R");
                     if(i!=n-1)
                        printf("D");
                 }
             }
         }
    }
    printf("\n");

}


        return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

LA 4329（树状数组）
算法竞赛入门经典 p197

题目大意：
      一条大街上住着n个乒乓球爱好者，经常比赛切磋技术。每个人都有一个不同的技能值a[i]；每场比赛需要3个人：两名选手，一名裁判。他们有个奇怪的约定，裁判必须住在两名选手之间，而裁判的能力值也必须在两名选手之间。问一共能组织多少种比赛。
分析：
   假设a[1]到a[i-1]中小于a[i]的数有p[i]，a[i+1]到a[n]中小于a[i]的数有s[i]个;

这样当i为裁判时能够组织的比赛数目为：p[i]*(n-i-s[i]) + (i-1-p[i])*s[i];
则总比赛次数为：

ans = 0;
for i -> 1 to n   (i表示选取第i个人作为裁判)
    ans += p[i]*(n-i-s[i]) + (i-1-p[i])*s[i];
  首先确定p[i]的值，令x[j]表示到目前为止已经考虑过的所有a[i]中是否存在技能值为j的数；（x[j] = 0表示不存在，x[j] = 1表示存在）

memsest(x, 0, sizeof(x));(将x初始化为0);
for i -> 1 to cur    (cur为考虑的当前位置,即选取的裁判位置）
    x[a[i]] = 1;
则有 p[cur] = x[1]+x[2]+.....+x[a[cur]-1];

例：


  假设 n = 4      a[1] = 2, a[2] = 3, a[3] = 5, a[4] = 1;
  

  选取 cur= 3，a[cur] = 5;  （第三个人做裁判）

  p[3] = x[1]+x[2]+x[3]+x[4] = 0 + 1 + 1 + 0 = 2;（这里 x[1] = 0的原因是没有执行到第4个）
不断的记录求和，当然是没有问题的（时间开销很大)


for i -> 1 to n;
    x[a[i]] = 1;
    p[i] = 0;
    for j -> 1 to a[i]-1
        p[i] += x[j]

修改单个元素并求前缀和是树状数组的标准用法，可以大幅度缩减时间（时间复杂度从O(nr)降到O(nlogr) );

for i-> 1 to n
    add(a[i], 1); //(点修改)
    p[i] = sum(a[i]-1); //(前缀和);到这里结果基本上可以求出来了，那s[i]呢？类似的，方向从i -> 1 to n 改为 i -> n todown 1即可；
代码如下：


#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

const int maxn = 20000+10;
const int maxm = 100000+10;
int c[maxm], a[maxn], p[maxn], s[maxn], n;

inline int lowbit(int x){
    return x&-x;
}

void add(int x, int d){
    while(x <= maxm){    // 一定注意这里是maxm, 原因可以思考一下;
        c[x] += d; x += lowbit(x);
    }
}

int sum(int x){
    int ret = 0;
    while(x > 0){
        ret += c[x]; x -= lowbit(x);
    }
    return ret;
}

int main()
{
    int T;
    scanf("%d", &T);
    while(T--){
        scanf("%d", &n);
        for(int i = 1; i <= n; ++i)
            scanf("%d", &a[i]);
        memset(c, 0, sizeof(c));
        for(int i = 1; i <= n; ++i){
            add(a[i], 1);
            p[i] = sum(a[i]-1);
        }
        memset(c, 0, sizeof(c));
        for(int i = n; i > 0; --i){
            add(a[i], 1);
            s[i] = sum(a[i]-1);
        }
        long long ans = 0;
        for(int i = 1; i <= n; ++i){
            ans += p[i]*(n-i-s[i]) + (i-1-p[i])*s[i];
        }
        printf("%lld\n", ans);
    }
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

EularProject 44：和与差均是五角数中差最小值
Pentagon numbers 
Problem 44 
Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, …
It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?
Answer: 
5482660 
Completed on Tue, 25 Aug 2015, 04:45 
Go to the thread for problem 44 in the forum.
#include<iostream>
#include<math.h>
# define maxStep 10000
using namespace std;

long func(long n)
{
    return n*(3 * n - 1) / 2;
}

bool IsPentagonal(long x)
{
    long temp = ceil(sqrt(2.0*x / 3));
    return (2 * x == 3 * temp*temp - temp) ? true : false;
}

bool Stop(long start, long step)
{
    long high = func(start);
    long little = func(start - step);
    long sum = little + high;
    if (IsPentagonal(sum) == false)
        return false;
    long diff = high - little;
    if (IsPentagonal(diff)==false)
        return false;
    return diff;
}

void main()
{
    long base = func(1);
    long lst[maxStep], start[maxStep], step[maxStep];
    for (int i = 0; i < maxStep; i++)
    {
        lst[i] = func(i + 2) - base;
        start[i] = i + 2;
        step[i] = i + 1;
    }
    while (true)
    {
        long result = Stop(start[0], step[0]);
        if (result)
        {
            cout << start[0] <<"  "<< step[0] << endl;
            cout << func(start[0])-func(start[0]-step[0]) << endl;
            system("pause");
        }
        start[0]++;
        long s1 = start[0];
        long s2 = step[0];
        lst[0] = func(s1) - func(s1 - s2);
        {
            long k = 1;
            long lst_temp = lst[0];
            long start_temp = start[0];
            long step_temp = step[0];
            while (lst_temp > lst[k])
            {
                lst[k-1] = lst[k];
                start[k-1] = start[k];
                step[k-1] = step[k];
                k++;
                if (k == maxStep)
                {
                    cout << "程序退出，因为需要增加maxStep" << endl;
                    return;
                }
            }
            lst[k - 1] = lst_temp;
            start[k - 1] = start_temp;
            step[k - 1] = step_temp;
        }
    }
    system("pause");
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

从编译器角度分析C语言中数组名和指针的区别

数组名和指针是两个往往很容易让人们混淆的概念，

很多人以为数组名就是一个指针，

也有很多人知道数组名不同于指针但是仅知道数组名的值不能像指针一样改变




例如你可以写出下面这样的代码：

int *p;

p++;

却不能写这样的代码：

int a[];

a++;




那么数组名跟指针之间到底有什么区别呢？

第一，在声明上，只有作为函数参数的数组名编译器总是转化成指针，

其他情况下，数组名就是数组名，指针就是指针，二者不能混淆，

你不能在一个文件中定义一个数组，而在另一个文件中把它声明成一个指针。

char a[];    //定义一个数组a

extern char* a;    //在另一个文件中将a声明成一个指针




在编译器中，符号表用来存放C语言中有关标识符的属性信息，这些信息集中反应了标识符的特征属性。

等到词法分析到代码声称的各个阶段的时候，编译器需要根据源代码提出的要求，从表中获取不同标识符的不同属性。

值得注意的是，数组标识符的属性和指针是完全不同的。

因此，在一个文件中定义一个数组的时候，编译器会把它记录在符号表中，而在编译器分析另一个文件中的声明时，通过符号的语义检查发现不一致。

也许这样的声明可以编译通过(在gcc下通过了)，但是把一个数组名当成一个指针来使用，别指望它能运行起来。




第二，指针是一个变量，而数组名不是。

数组名是数组的首地址，它本身就是一个地址，对应到汇编语言级别就是一个常量，一个固定的数（地址）。

因此数组名不能进行++,--等运算。

在大多数编译器中，对数组的引用a[i]总是被编译器改写成*(a+i)的格式。

也就是说，编译器每遇到a[i]，都会把它当作*(a+i)来处理。

我们都知道，*addr表示内存中（addr）的位置存储的值，

比如*0x8048000就表示地址为0x8048000的内存中所存储的值。

所以a[i]就表示a的值加上i所得到的数作为一个内存地址里面所存储的值。 




那么a的值是什么呢 ？？？

编译器在做词法分析和语法分析的时候，遇到一个数组的定义，就会把数组的有关信息汇集在一个叫做“内情向量”或“信息向量”的表格中，其中的信息包括数组的类型，维数，各维的上、下边界，以及数组的首地址，然后将这个“内情向量”相关信息存储在符号表中。

数组定义后位置就是固定的，因此其首地址可以在编译阶段得到。




当编译器到达代码生成的各阶段时，每次遇到数组名这个标识符，编译器都会从符号表中取出这个数组的首地址，然后用这个地址来替代数组名，例如，假设数组a起始地址是0x8048000，则a[1]就会被编译器转化成*(0x8048000+1)，

因此在生成的汇编代码中，数组名已经完全被转化成一个常量，一个固定的数(地址)。

但是

对于指针p，它是一个变量，其值存储在地址&p中，这个值在编译时是不能得到的。

因为是变量，所以指针可以作为表达式中的左值操作，

如++或--，而被认为是常量的数组名却不可以，正如你可以骑走一辆自行车，但是不能骑走一棵树。




另外，C语言把 数组下标 改写成 指针偏移量 的  根本原因  是

指针偏移量是底层硬件所使用的基本模型。




第三，对数组的引用，如a[i]，或*(a+1)，需要访存一次；而对指针的引用，如*(p+1)，需要访存两次。




a被认为是常数，所以取*(a+1)的值只需将a所表示的常数加1，然后从得到的地址里访存取一次即可。

对于指针，需要先从&p这个地址里把p的值取出来，然后加1，再从得到的地址里访存取一次，一共需要两次访存。




第四，假设a是一个数组名，而p是一个指针，当你使用 a 和 &a 时，得到值是一样的，都是数组的起始地址。

而使用 p 和 ＆p 时，得到的值是不一样的， p 表示指针 p 所指向的地址，而 &p 表示 p 这个变量的地址。

再假设   p = a;

则 p 就表示数组a的起始地址，而&p是存储数组a的起始地址的那个地址。

这是因为编译器把a当成数组首地址，而&a当作数组第一个元素的地址，因此得到的值是一样的。

另外，sizeof(a)得到的是a所表示的数组的大小，而sizeof(p)得到的是指针的大小。

版权声明：本文为博主原创文章，未经博主允许不得转载。

poj1562&&hdoj1241Oil Deposits

Oil Deposits




Time Limit: 1000MS
 
Memory Limit: 10000K


Total Submissions: 14613
 
Accepted: 7963




Description

The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each
 plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous
 pockets. Your job is to determine how many different oil deposits are contained in a grid.
Input

The input contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 <= m <= 100 and 1 <= n <= 100. Following this
 are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either `*', representing the absence of oil, or `@', representing an oil pocket. 


Output

are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.
Sample Input
1 1
*
3 5
*@*@*
**@**
*@*@*
1 8
@@****@*
5 5 
****@
*@@*@
*@**@
@@@*@
@@**@
0 0
Sample Output
0
1
2
2

Source
Mid-Central USA 1997
j简单深搜，因为只需要判断是否连成一块，因此不需要回溯过程，还是很简单的，一个油田，九宫格之内的属于同一块，
附ac代码：
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
char c[110][110];
int i,j,k,l,m,n;
void dfs(int x,int y)
{
	if(x<1||x>m||y<0||y==n)
	return ;
	if(c[x][y]=='*')
	return ;
	if(c[x][y]=='@')
	c[x][y]='*';
	dfs(x,y+1);
	dfs(x,y-1);
	dfs(x+1,y);
	dfs(x-1,y);
	dfs(x+1,y+1);
	dfs(x+1,y-1);
	dfs(x-1,y+1);
	dfs(x-1,y-1);
}
int main()
{
	while(scanf("%d%d",&m,&n)&&(m||n))
	{
		for(i=1;i<=m;i++)
		scanf("%s",c[i]);
		int cnt=0;
		for(i=1;i<=m;i++)
		for(j=0;j<=n;j++)
		{
			if(c[i][j]=='@')
			cnt++;
			dfs(i,j);
		}
		printf("%d\n",cnt);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Java知识总结----日志系统在项目中的应用（五）
       现在的工作过程中，日志在项目中的角色越来越重要，环境出问题了，遇到bug了，我们都要从日志查起。所以在项目中记录日志就显得很重要。今天就跟大家简单聊聊如何在项目中引入日志。
       现在市面上比较流行的日志框架有log4j，logback等，大家可能还听说过sjf4j，当然了还有apache的commons-logging，jdk的java.util.log。那么slf4j是什么呢？slf4j，Simple Logging Facade for Java，简单日志门面，只是一个接口，没有具体的实现。它不是具体的日志解决方案，它只服务于各种各样的日志系统。我们可以把各种各样的日志实现接入slf4j，在项目中只使用slf4j就可以了。今天我们就来看看如何把log4j接入slf4j中。
      首先我们需要slf4j和log4j的依赖包：log4j的核心包，slf4j的接口包，以及slf4j对log4j的实现包。

<dependency>
	<groupId>log4j</groupId>
	<artifactId>log4j</artifactId>
	<version>1.2.17</version>
</dependency>
		
<dependency>
	<groupId>org.slf4j</groupId>
	<artifactId>slf4j-api</artifactId>
	<version>1.7.12</version>
</dependency>
<dependency>
	<groupId>org.slf4j</groupId>
	<artifactId>slf4j-log4j12</artifactId>
	<version>1.7.12</version>
</dependency>
然后，我们需要再项目中创建log4j的配置文件，默认在src下，文件名为log4j.properties。配置文件示例内容如下：


 ### set log levels ###
log4j.rootLogger = info,stdout,file

### 输出到控制台 ###
log4j.appender.stdout = org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target = System.out
log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern =  %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n

### 输出到文件 ###
log4j.appender.file = org.apache.log4j.DailyRollingFileAppender
log4j.appender.file.File = logs/log.log
log4j.appender.file.Append = true
log4j.appender.file.Threshold = DEBUG ## 
log4j.appender.file.layout = org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
log4j.rootLogger：指定了项目的全局配置，第一个参数表示当前工程默认的日志级别，后面的参数表示日志的输出形式。

ConsoleAppender：表示输出到控制台，DailyRollingFileAppender：表示每天生成一个日志文件。
ConversionPattern：表示日志的输出格式，其内容代表的具体含义，大家可以参考log4j的其他资料，这里就不一一讲解了。
在项目中的使用也非常简单，只要在类中定义如下的变量即可：

private static Logger logger = LoggerFactory.getLogger(UserController.class);
注意：Logger和LoggerFactory都是org.slf4j包下的。

在使用的时候直接调用logger.info(),logger.debug().logger.error()即可使用了。


如果我们想把jdk的java.util.log和Apache的commons-logging怎么接入slf4j呢？只需要引入一下依赖：

<dependency>
	<groupId>org.slf4j</groupId>
	<artifactId>jcl-over-slf4j</artifactId>
	<version>1.7.12</version>
</dependency>
<dependency>
	<groupId>org.slf4j</groupId>
	<artifactId>jul-to-slf4j</artifactId>
	<version>1.7.12</version>
</dependency>jcl-over-slf4j：把commmons-logging接入slf4j，jul-to-slf4j：把java.util.log接入slf4j。



下面呢，我们再说说logback。Logback是由log4j创始人设计的又一个开源日志组件。相比较log4j，logback不仅继承了log4j的有点，对log4j也进行了非常大的改进。那么如何在项目中使用logback呢？
首先引入相关的依赖：

<!-- log配置 -->
<dependency>
	<groupId>org.slf4j</groupId>
	<artifactId>slf4j-api</artifactId>
	<version>1.7.12</version>
</dependency>

<dependency>
	<groupId>ch.qos.logback</groupId>
	<artifactId>logback-core</artifactId>
	<version>1.1.1</version>
</dependency>
<dependency>
	<groupId>ch.qos.logback</groupId>
	<artifactId>logback-classic</artifactId>
	<version>1.1.1</version>
</dependency>
        <dependency>  
	<groupId>org.logback-extensions</groupId>  
	<artifactId>logback-ext-spring</artifactId>  
        <version>0.1.1</version>  
</dependency>
 <!-- logback兼容java.util.log -->
<dependency>
	<groupId>org.slf4j</groupId>
	<artifactId>jul-to-slf4j</artifactId>
	<version>1.7.6</version>
</dependency>
<!-- for common-logging -->
<dependency>
	<groupId>org.slf4j</groupId>
	<artifactId>jcl-over-slf4j</artifactId>
	<version>1.7.6</version>
</dependency>
<!-- logback兼容log4j -->
<dependency>
        <groupId>org.slf4j</groupId>
	<artifactId>log4j-over-slf4j</artifactId>
	<version>1.7.6</version>
</dependency>在上边的要特别注意的是，我们要把log4j也接入slf4j，并且在项目中不能再引入log4j的jar包和slf4j-log4j-*的jar包，这个在打包的时候，要特别注意。

然后在src下创建logback的配置文件logback.xml：

<?xml version="1.0" encoding="UTF-8"?>
<configuration>
        <property name="log.home" value="/data/application/logs" />
        <!-- 默认输出文件 -->
	<appender name="DEFAULT-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender">
		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
			<fileNamePattern>${log.home}/default/common-default.log.%d{yyyyMMdd}</fileNamePattern>
			<maxHistory>30</maxHistory>
		</rollingPolicy>
		<encoder charset="UTF-8">
			<pattern>%d [%t] %-5p %c{2} [%X{traceRootId}/%X{userId}/%X{userEmail}/%X{userPhone}] - [%m]%n</pattern>
		</encoder>
	</appender>
	<!-- 默认错误文件 -->
	<appender name="ERROR-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender">
		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
			<fileNamePattern>${log.home}/error/common-error.log.%d{yyyyMMdd}</fileNamePattern>
		</rollingPolicy>
		<encoder charset="UTF-8">
			<pattern>%d [%t] %-5p %c{2} [%X{traceRootId}/%X{userId}/%X{userEmail}/%X{userPhone}] - [%m]%n</pattern>
		</encoder>
		<filter class="ch.qos.logback.classic.filter.ThresholdFilter">
    		<level>ERROR</level>
    	</filter>
	</appender>
	<!-- 性能日志文件 -->
	<appender name="PERF-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender">
		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
			<fileNamePattern>${log.home}/perf/common-perf.log.%d{yyyyMMdd}</fileNamePattern>
			<maxHistory>30</maxHistory>
		</rollingPolicy>
		<encoder charset="UTF-8">
			<pattern>%d [%t] %-5p %c{2} [%X{traceRootId}/%X{userId}/%X{userEmail}/%X{userPhone}] - [%m]%n</pattern>
		</encoder>
	</appender>
	<!-- 默认dao日志文件 -->
	<appender name="DAO-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender">
		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
			<fileNamePattern>${log.home}/dao/common-dao.log.%d{yyyyMMdd}</fileNamePattern>
			<minIndex>1</minIndex>    
	      	<maxIndex>5</maxIndex>
		</rollingPolicy>
		<encoder charset="UTF-8">
			<pattern>%d [%t] %-5p %c{2} [%X{traceRootId}/%X{userId}/%X{userEmail}/%X{userPhone}] - [%m]%n</pattern>
		</encoder>
	</appender>
	<!-- 默认dlock日志文件 -->
	<appender name="DLOCK-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender">
		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
			<fileNamePattern>${log.home}/dlock/common-dlock.log.%d{yyyyMMdd}</fileNamePattern>
			<minIndex>1</minIndex>    
	      	<maxIndex>5</maxIndex>
		</rollingPolicy>
		<encoder charset="UTF-8">
			<pattern>%d [%t] %-5p %c{2} [%X{traceRootId}/%X{userId}/%X{userEmail}/%X{userPhone}] - [%m]%n</pattern>
		</encoder>
	</appender>
	<!-- service日志文件 -->
	<appender name="SERVICE-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender">
		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
			<fileNamePattern>${log.home}/service/common-service.log.%d{yyyyMMdd}</fileNamePattern>
			<maxHistory>30</maxHistory>
		</rollingPolicy>
		<encoder charset="UTF-8">
			<pattern>%d [%t] %-5p %c{2} [%X{traceRootId}/%X{userId}/%X{userEmail}/%X{userPhone}] - [%m]%n</pattern>
		</encoder>
	</appender>
	<!-- 业务日志文件 -->
	<appender name="BUSINESS-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender">
		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
			<fileNamePattern>${log.home}/business/common-business.log.%d{yyyyMMdd}</fileNamePattern>
			<maxHistory>30</maxHistory>
		</rollingPolicy>
		<encoder charset="UTF-8">
			<pattern>%d [%t] %-5p %c{2} [%X{traceRootId}/%X{userId}/%X{userEmail}/%X{userPhone}] - [%m]%n</pattern>
		</encoder>
	</appender>
	<!-- 报警日志 -->
	<appender name="ALARM-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender">
      <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"> 
    		<fileNamePattern>${log.home}/alarm/common-alarm.log.%d{yyyyMMdd}</fileNamePattern> 
    		<maxHistory>30</maxHistory>  
  	</rollingPolicy>                                                                                    
	<encoder charset="UTF-8">
		<pattern>%d [%t] %-5p %c{2} [%X{traceRootId}/%X{userId}/%X{userEmail}/%X{userPhone}] - [%m]%n</pattern>
	</encoder>                                                                                                                                                                                                                                                                                    
	</appender> 
	<appender name="TRACE-APPENDER" class="ch.qos.logback.core.rolling.RollingFileAppender"> 
	     <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"> 
	   		<fileNamePattern>${log.home}/trace/tracing.log.%d{yyyy-MM-dd-HH}.gz</fileNamePattern> 
	   		<maxHistory>72</maxHistory>  
	 	</rollingPolicy> 	                                                                                         
	<encoder charset="UTF-8">
		<pattern>%d - [%m]%n</pattern>
	</encoder>                                                                                                                                                                                                                                                                                    
	</appender>
	<logger name="java.sql" additivity="false">
		<level value="INFO"/>
		<appender-ref ref="DAO-APPENDER"/>
		<appender-ref ref="ERROR-APPENDER"/>
	</logger>
	
	<logger name="businessLogger" additivity="false">
		<level value="${log.root.level}"/>
		<appender-ref ref="BUSINESS-APPENDER"/>
		<appender-ref ref="ERROR-APPENDER"/>
	</logger>
	<logger name="serviceLogger" additivity="false">
		<level value="${log.root.level}"/>
		<appender-ref ref="SERVICE-APPENDER"/>
	</logger>
	<!-- 屏蔽logger -->
	<logger name="org.springframework" level="WARN" />
	<logger name="org.apache" level="WARN" />
	<logger name="org.mybatis.spring" level="WARN" />
	<!-- 屏蔽jdk日志 -->
	<logger name="java" level="WARN" />
	<logger name="com.mchange" additivity="false">
		<level value="WARN"/>
		<appender-ref ref="DAO-APPENDER"/>
	</logger>	
	<!-- 屏蔽logger 结束-->
	<root level="${log.root.level}">
		<appender-ref ref="DEFAULT-APPENDER"></appender-ref>
		<appender-ref ref="ALARM-APPENDER"/>
		<appender-ref ref="ERROR-APPENDER"></appender-ref>
	</root>
</configuration> 
logback的配置文件大体上分为3个部分，第一个部分是appender标签，里边配置了不同的appender日志存放的位置，日志格式等信息。第二部分是logger标签，只要指定不同的日志使用不同的appender，用于区分，如businessLogger，表示logger的名字为businessLogger的，日志输出到DEFAULT_APPENDER和ERRPR_APPENDER中。第三部分是root标签，表示项目的全局配置，包括日志级别和默认的日志输出。

最后要在web.xml中进行配置：

  	<context-param>
		<param-name>logbackConfigLocation</param-name>
		<param-value>classpath:logback.xml</param-value>
	</context-param>
	<listener>
		<listener-class>ch.qos.logback.ext.spring.web.LogbackConfigListener</listener-class>
	</listener>

在使用方式上，和log4j是一样的，使用org.slf4j的两个类即可。

private static Logger logger = LoggerFactory.getLogger(UserController.class);


版权声明：本文为博主原创文章，未经博主允许不得转载。

Lua学习笔记--table
Lua只有一种数据结构，叫table。但是他灰常强大，足以满足我们一般的要求，而且可以根据table做出其他的效果。
一.简介
table类型实际上是一种关联数组，是一种具有特殊索引方式的数组，不仅可以通过整数来索引，还可以通过字符串等其他类型（除了nil）来索引。table没有固定大小，可以动态添加元素。
table可以被理解为一个对象，程序使用一个引用来使用table，这个引用是基于引用计数的。如果一个table没有被引用，那么Lua的垃圾回收机制会清除table并回收其内存。
创建table是通过构造式来创建的。
先来看看传统的C语言的方式的数组用法：
--创建一个table，并将其引用使用a保存
a = {}
--向table中添加三条数据
a[1] = "hehe"
a[2] = "haha"
a[3] = "heihei"

--输出
for i = 1,3 do
	print(a[i])
end结果：
hehe
haha
heihei
请按任意键继续. . .


but Lua的数组的索引可以是其他类型的，类似dictionary的功能。下面是使用字符串作为索引：
--创建一个table，并将其引用使用a保存
a = {}
--table中的索引不仅限于number，使用其他类型的数据也可以作为索引 
a["hehe"] = "heihei"
local i = "hh"
a[i] = "haha"

local t = "hehe"
print(a[t])
print(a["hh"])
结果：
heihei
haha
请按任意键继续. . .



一个非常容易出错的地方：
一种简便的写法：a.name <=>a["name"] 千万不要与a[name]搞混

--创建一个table，并将其引用使用a保存
a = {}
a["name"] = "puppet"
print(a.name)
结果：
puppet


下面的例子更好的看出这个的区别：
a = {}
x = "y"
a[x] = 10
--表示a[x]未定义，为nil
print(a.x)
--表示a["y"]，为10
print(a.y)结果：
nil
10
请按任意键继续. . .


table是匿名的，持有table引用的变量与table自身木有关系。可以有多个变量引用同一个table。当不需要table时，就将这个引用的变量置为nil，当一个table所有的引用都为nil时，那么table就被垃圾回收机制收了。


 a = {}
 a[1] = "haha"
 --b与a引用了同一个table
 b = a
 print(b[1])
 --通过b对table操作等同于通过a对table操作
 b[1] = "heihei"
 print(a[1])

 a = nil
 --b还引用着table
 b = nil
 --现在table被收了
结果：
haha
heihei
请按任意键继续. . .





二.table构造式
构造式是用来初始化table的表达式，是Lua特有的也是灰常有用的一种表达式。
最简单的table构造式就是一个空的table：
a = {}我们也可以将table构造式用于数组的初始化，比如：
--table构造式
day = {"Sunday", "Monday", "Tuesday", "Wendesday", "Thursday", "Friday", "Saturday"}
--注意，Lua中数组的开始为1，这一点与C等不同
print(day[1])
print(day[4])结果：
Sunday
Wendesday
请按任意键继续. . .


这里要注意的一点：Lua中数组的起始为1，不是0！！！

对于那种非普通数组的table初始化，lua提供了一种比较简单的方式：
a = {x = "hehe", y = "haha"}

print(a.x)
print(a.y)结果：
hehe
haha
请按任意键继续. . .

上面的构造式相当于下面的一大串：
a = {}
a.x = "hehe"
a.y = "heihei"

--最麻烦的写法如下：
--a["x"] = "hehe"
--a["y"] = "heihei"

print(a.x)
print(a.y)


这样一看，构造式为我们省去了很多麻烦。另外，还是一定要注意，构造式里面的x表示的并不是x的值，而是字段"x"！！！即a["x"] = "hehe"




三.table的table
table什么都能装，而且同一个table中可以装不同类型的东东：
a = {x = 1, y = "hehe"}
print(a.x)
print(a.y)结果：
1
hehe
请按任意键继续. . .


当然，这不是最牛的，最牛的是table的table：
a = {x = "hehe", y = "heihei"}
b = {i = "haha"}
--将key z value b添加到table a中
a.z = b

--使用:a.z表示b，b.i索引到了“haha”
print(a.z.i)结果：
haha
请按任意键继续. . .




当不需要一个字段时，可以将其赋值为nil：
a = {x = "hehe", y = "heihei"}
--当不需要一个字段时，将其赋值为nil
a.x = nil

四.table的遍历
对于数据结构，遍历是最重要的操作了。
1.数组型遍历
对于数组型的table，遍历比较简单。
a = {"Monday", "Tuesday", "Wednesday"}
--#a是取数组或者线性表最后一个索引值
for i = 1, #a do
	print(a[i])
end结果：
Monday
Tuesday
Wednesday
请按任意键继续. . .


注意：这里说的数组型table，指的是使用number作为索引的那种C类型的数组。如果索引为其他类型，不能用这种方式来遍历。




2.迭代器遍历
对于那种不是传统数组，而是key-value对的table，就需要使用迭代器进行遍历了。


--一个使用字段索引的table
a = {x = "hehe", y = "haha", z = "heihei"}
--使用迭代器进行迭代，每次i被赋予一个新的key，而k则会被赋值成key所对应的value
for i, k in pairs(a) do
	print(i, k)
end结果：
y       haha
x       hehe
z       heihei
请按任意键继续. . .


注意，迭代器有几种，在不同的时候需要用不同的迭代器：
用于迭代文件的：io.lines
用于迭代table的：pairs
用于迭代数组元素的：ipairs
用于迭代字符串的单词的：string.gmatch




比如下面用的ipairs迭代传统数组：
a = {"Monday", "Tuesday", "Wednesday"}
--用于迭代传统数组的ipairs迭代器
for i, k in ipairs(a) do
	print(k)
end 结果：
Monday
Tuesday
Wednesday
请按任意键继续. . .





































版权声明：本文为博主原创文章，未经博主允许不得转载。

快速矩阵幂+DFS构造矩阵+大数 ACdream1214 Nice Patterns Strike Back
传送门：点击打开链接
题意：告诉你矩阵大小是n*m，要求矩阵中不能有2*2的白色子矩阵或者黑色子矩阵，最后种类数模P
思路：如果不是大数，这道题还是非常有意思的。。对于专门卡C++的题目也是醉了...因为n太大了，而m最大也只有5，很明显是大数上的快速矩阵幂。
问题是如何构造出矩阵出来，之前做过骨牌的题目，就是利用DFS来构造的，感觉这道题在思路上是一样的，同样也是利用DFS先构造出矩阵
然后直接大数+快速矩阵幂撸一发就行了
#include<map>
#include<set>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<string>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<functional>
#define FIN freopen("input.txt","r",stdin)
using namespace std;

const int matMX = 50;
const int DLEN = 4;
const int MAXN = 9999;

class BN {
public:
    int a[500];
    int len;

    BN(const int b = 0) {
        int c, d = b;
        len = 0;
        memset(a, 0, sizeof(a));
        while(d > MAXN) {
            c = d - (d / (MAXN + 1)) * (MAXN + 1);
            d = d / (MAXN + 1);
            a[len++] = c;
        }
        a[len++] = d;
    }
    BN(const char *s) {
        int t, k, index, L, i;
        memset(a, 0, sizeof(a));
        L = strlen(s);
        len = L / DLEN;
        if(L % DLEN) len++;
        index = 0;
        for(i = L - 1; i >= 0; i -= DLEN) {
            t = 0;
            k = i - DLEN + 1;
            if(k < 0) k = 0;
            for(int j = k; j <= i; j++) {
                t = t * 10 + s[j] - '0';
            }
            a[index++] = t;
        }
    }
    BN operator/(const int &b)const {
        BN ret;
        int i, down = 0;
        for(int i = len - 1; i >= 0; i--) {
            ret.a[i] = (a[i] + down * (MAXN + 1)) / b;
            down = a[i] + down * (MAXN + 1) - ret.a[i] * b;
        }
        ret.len = len;
        while(ret.a[ret.len - 1] == 0 && ret.len > 1) ret.len--;
        return ret;
    }
    bool operator>(const BN &T)const {
        int ln;
        if(len > T.len) return true;
        else if(len == T.len) {
            ln = len - 1;
            while(a[ln] == T.a[ln] && ln >= 0) ln--;
            if(ln >= 0 && a[ln] > T.a[ln]) return true;
            else return false;
        } else return false;
    }
    BN operator-(const BN &T)const {
        int i, j, big;
        bool flag;
        BN t1, t2;
        if(*this > T) {
            t1 = *this;
            t2 = T;
            flag = 0;
        } else {
            t1 = T;
            t2 = *this;
            flag = 1;
        }
        big = t1.len;
        for(i = 0; i < big; i++) {
            if(t1.a[i] < t2.a[i]) {
                j = i + 1;
                while(t1.a[j] == 0) j++;
                t1.a[j--]--;
                while(j > i) t1.a[j--] += MAXN;
                t1.a[i] += MAXN + 1 - t2.a[i];
            } else t1.a[i] -= t2.a[i];
        }
        t1.len = big;
        while(t1.a[t1.len - 1] == 0 && t1.len > 1) {
            t1.len--;
            big--;
        }
        if(flag) t1.a[big - 1] = 0 - t1.a[big - 1];
        return t1;
    }
    int operator%(const int &b)const {
        int i, d = 0;
        for(int i = len - 1; i >= 0; i--) {
            d = ((d * (MAXN + 1)) % b + a[i]) % b;
        }
        return d;
    }
};


LL mod;
struct Mat {
    int m, n;
    LL S[matMX][matMX];
    Mat(int a, int b) {
        m = a; n = b;
        memset(S, 0, sizeof(S));
    }
    Mat(int a, int b, LL w[][matMX]) {
        m = a; n = b;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                S[i][j] = w[i][j];
            }
        }
    }
};

Mat mat_mul(Mat A, Mat B) {
    Mat C(A.m, B.n);
    for(int i = 0; i < A.m; i++) {
        for(int j = 0; j < B.n; j++) {
            for(int k = 0; k < A.n; k++) {
                C.S[i][j] = (C.S[i][j] + A.S[i][k] * B.S[k][j]) % mod;
            }
        }
    }
    return C;
}

Mat Blank(int m, int n) {
    Mat ret(m, n);
    for(int i = 0; i < m; i++) {
        ret.S[i][i] = 1;
    }
    return ret;
}

Mat mat_pow(Mat A, BN b) {
    Mat ret = Blank(A.m, A.n);
    while(b > 0) {
        if(b % 2) ret = mat_mul(ret, A);
        A = mat_mul(A, A);
        b = b / 2;
    }
    return ret;
}

int m;
LL TB[matMX][matMX];
void DFS(int x, int y, int p) {
    if(p == m) {
        TB[x][y] = 1;
        return;
    }
    DFS(x << 1 | 1, y << 1, p + 1);
    DFS(x << 1, y << 1 | 1, p + 1);
    if(!p || (!((x & 1) && (y & 1)))) DFS(x << 1 | 1, y << 1 | 1, p + 1);
    if(!p || (!(!(x & 1) && !(y & 1)))) DFS(x << 1, y << 1, p + 1);
}

int main() {
    //FIN;
    char word[500];
    while(~scanf("%s%d%lld", word, &m, &mod)) {
        memset(TB, 0, sizeof(TB));
        DFS(0, 0, 0);

        BN n = BN(word);
        Mat s(1 << m, 1 << m, TB), fuck(1 << m, 1);
        for(int i = 0; i < (1 << m); i++) {
            fuck.S[i][0] = 1;
        }
        Mat res = mat_mul(mat_pow(s, n - 1), fuck);

        LL ans = 0;
        for(int i = 0; i < (1 << m); i++) {
            ans = (ans + res.S[i][0]) % mod;
        }
        printf("%lld\n", ans);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

类加载器
类加载器搜索类的路径

1、App加载器搜索类的路径：classpath下的jar包或类（即自定义类）的类加载器； //注：APP类加载器也是默认的类加载器，如果没有自定义的类加载器的话。

2、Ext加载器搜索类的路径：jdk安装目录下/lib/ext下的jar包或类。

3、启动加载器：jdk安装目录/lib下的几个jdk提供的jar包（例如，rt.jar等）；
换句话说，即使有其他的jar包放到jdk安装目录/lib目录下，但是名字不是jdk提供的几个jar包的名字之一的话，也不会被加载。






一图胜千言























版权声明：本文为博主原创文章，未经博主允许不得转载。

ACdream 1213 Matrix Multiplication(矩阵乘法)
题目链接:http://acdream.info/problem?pid=1213
涉及的数学知识较多，包括矩阵的转置，矩阵的乘法，关联矩阵.....
刚开始是直接按照各个概念做的，结果MLE了，MLE代码如下
#include<cstdio>
#include<iostream>
#include<sstream>
#include<cstdlib>
#include<cstring>
#include<string>
#include<climits>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
#include<set>
#include<map>
using namespace std;
int n,m;
int a[10005][5],v[10005][10005],v1[10005][10005];
int main()
{
    int i,j;
    while(~scanf("%d%d",&n,&m))
    {
        memset(v,0,sizeof(v));
        memset(v1,0,sizeof(v1));
        for(i=0;i<m;i++)
            for(j=0;j<2;j++)
            scanf("%d",&a[i][j]);
        for(i=0;i<m;i++)
            v[a[i][0]-1][a[i][1]-1]=v[a[i][1]-1][a[i][0]-1]=1;
        for(i=0;i<n;i++)
            for(j=0;j<m;j++)
                v1[j][i]=v[i][j];
        int sum=0,b=0,k=m;
        while(k--)
        {
             for(i=0;i<n;i++)
            {
                int c=0;
                for(j=0;j<m;j++)
                {
                    sum+=v[b][c++]*v1[j][i];
                }
            }
            b++;
        }
        printf("%d\n",sum);
    }
    return 0;
}
网上看了别人的题解后获得思路，下面是AC代码
#include<cstdio>
#include<iostream>
#include<sstream>
#include<cstdlib>
#include<cstring>
#include<string>
#include<climits>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
#include<set>
#include<map>
using namespace std;
int n,m;
int a[100005];
int main()
{
    int i,j;
    while(~scanf("%d%d",&n,&m))
    {
        int u,v;
        memset(a,0,sizeof(v));
        for(i=1; i<=m; i++)
        {
            scanf("%d%d",&u,&v);
            a[u]++;
            a[v]++;
        }
        long long sum=0;
        for(i=1; i<=n; i++)
            sum+=a[i]*a[i];
        printf("%lld\n",sum);
    }
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

进程之间的8种通信方式
方法/步骤




无名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。



高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。



有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。



消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。



信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。



信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。



共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。



套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。




版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ 1028 Ignatius and the Princess III(DP)
Problem Description
"Well, it seems the first problem is too easy. I will let you know how foolish you are later." feng5166 says.

"The second problem is, given an positive integer N, we define an equation like this:
  N=a[1]+a[2]+a[3]+...+a[m];
  a[i]>0,1<=m<=N;
My question is how many different equations you can find for a given N.
For example, assume N is 4, we can find:
  4 = 4;
  4 = 3 + 1;
  4 = 2 + 2;
  4 = 2 + 1 + 1;
  4 = 1 + 1 + 1 + 1;
so the result is 5 when N is 4. Note that "4 = 3 + 1" and "4 = 1 + 3" is the same in this problem. Now, you do it!"

 

Input
The input contains several test cases. Each test case contains a positive integer N(1<=N<=120) which is mentioned above. The input is terminated by the end of file.

 

Output
For each test case, you have to output a line contains an integer P which indicate the different equations you have found.

 

Sample Input

4
10
20

 

Sample Output

5
42
627



和上篇类似。
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define LL __int64
#define inf 0x3f3f3f3f
using namespace std;
LL x,y;
LL dp[100010];
int main()
{
    LL n,m,k,i,j,l,c;
    while(~scanf("%lld",&n))
    {
        memset(dp,0,sizeof(dp));
        dp[0]=1;
        for(i=1; i<=n; i++)
        {
            for(j=i; j<=n; j++)
                dp[j]+=dp[j-i];
        }
        printf("%lld\n",dp[n]);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

c++继承总结
继承 
1）继承是面向对象程序设计实现软件重用的重要方法。程序员可以在已有基类的基础上定义新的派生类。 
2） 单继承的派生类只有一个基类。多继承的派生类有多个基类。 
3） 派生类对基类成员的访问由继承方式和成员性质决定。 
4） 创建派生类对象时，先调用基类构造函数初始化派生类中的基类成员。调用析构函数的次序和调用构造函数的次序相反。 
5）C++提供虚继承机制，防止类继承关系中成员访问的二义性。 
6）   多继承提供了软件重用的强大功能，也增加了程序的复杂性。
派生类类成员访问级别 
1、需要被外界访问的成员直接设置为public 
2、只能在当前类中访问的成员设置为private 
3、只能在当前类和子类中访问的成员设置为protected，protected成员的访问权限介于public和private之间。
//类的继承方式对子类对外访问属性影响

#include <cstdlib>
#include <iostream>

using namespace std;

class A
{
private:
    int a;
protected:
    int b;
public:
    int c;

    A()
    {
        a = 0;
        b = 0;
        c = 0;
    }

    void set(int a, int b, int c)
    {
        this->a = a;
        this->b = b;
        this->c = c;
    }
};

class B : public A
{
public:
    void print()
    {
        //cout<<"a = "<<a; //err
        cout<<"b = "<<b;
        cout<<"c = "<<endl;
    }
};

class C : protected A
{
public:
    void print()
    {
        //cout<<"a = "<<a; //err
        cout<<"b = "<<b;
        cout<<"c = "<<endl;
    }
};

class D : private A
{
public:
    void print()
    {
        //cout<<"a = "<<a; //err
        cout<<"b = "<<b<<endl; 
        cout<<"c = "<<c<<endl; 
    }
};

int main_01(int argc, char *argv[])
{
    A aa;
    B bb;
    C cc;
    D dd;

    aa.c = 100; //ok
    bb.c = 100; //ok
    //cc.c = 100; //err 类的外部是什么含义
    //dd.c = 100; //err

    aa.set(1, 2, 3);
    bb.set(10, 20, 30);
    //cc.set(40, 50, 60); //ee
    //dd.set(70, 80, 90); //ee

    bb.print();
    cc.print();
    dd.print();

    system("pause");
    return 0;
}

类型兼容性原则 
子类对象可以当作父类对象使用 
子类对象可以直接赋值给父类对象 
子类对象可以直接初始化父类对象 
父类指针可以直接指向子类对象 
父类引用可以直接引用子类对象
#include <cstdlib>
#include <iostream>

using namespace std;

//子类就是特殊的父类
class Parent03
{
protected:
    const char* name;
public:
    Parent03()
    {
        name = "Parent03";
    }

    void print()
    {
        cout<<"Name: "<<name<<endl;
    }
};

class Child03 : public Parent03
{
protected:
    int i;
public:
    Child03(int i)
    {
        this->name = "Child2";
        this->i = i;
    }
};

int main()
{
    Child03 child03(1000);
    //分别定义父类对象 父类指针 父类引用 child
    Parent03 parent = child03;
    Parent03* pp = &child03;
    Parent03& rp = child03;

    parent.print();
    pp->print();
    rp.print();
    system("pause");
    return 0;
}

继承中构造和析构 
在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化 
    在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理
#include <cstdlib>
#include <iostream>
using namespace std;

class Parent04
{
public:
    Parent04(const char* s)
    {
        cout<<"Parent04()"<<" "<<s<<endl;
    }

    ~Parent04()
    {
        cout<<"~Parent04()"<<endl;
    }
};

class Child04 : public Parent04
{
public:
    Child04() : Parent04("Parameter from Child!")
    {
        cout<<"Child04()"<<endl;
    }

    ~Child04()
    {
        cout<<"~Child04()"<<endl;
    }
};

void run04()
{
    Child04 child;
}

int main_04(int argc, char *argv[])
{
    run04();

    system("pause");
    return 0;
}

1、子类对象在创建时会首先调用父类的构造函数 
2、父类构造函数执行结束后，执行子类的构造函数 
3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用 
4、析构函数调用的先后顺序与构造函数相反
继承中的同名成员变量 
1、当子类成员变量与父类成员变量同名时 
2、子类依然从父类继承同名成员 
3、在子类中通过作用域分辨符::进行同名成员区分（在派生类中使用基类的同名成员，显式地使用类名限定符）  
4、同名成员存储在内存中的不同位置

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU - 1272 小希的迷宫（简单并查集）

小希的迷宫




Time Limit: 1000MS
 
Memory Limit: 32768KB
 
64bit IO Format: %I64d & %I64u




Submit Status


Description

上次Gardon的迷宫城堡小希玩了很久（见Problem B），现在她也想设计一个迷宫让Gardon来走。但是她设计迷宫的思路不一样，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。 


 




Input

输入包含多组数据，每组数据是一个以0 0结尾的整数对列表，表示了一条通道连接的两个房间的编号。房间的编号至少为1，且不超过100000。每两组数据之间有一个空行。 
整个文件以两个-1结尾。 

 




Output

对于输入的每一组数据，输出仅包括一行。如果该迷宫符合小希的思路，那么输出"Yes"，否则输出"No"。 

 




Sample Input


6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0

-1 -1 

 




Sample Output


Yes
Yes
No 

 


简单的并查集，符合的无向图要求是连通的并且没有环。点的编号好像没有什么规律吧。

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std;

const int MAXN = 100000 + 100;
int parent[MAXN];
bool vis[MAXN];

int find_set(int t)
{
	if (parent[t] == -1)
		return t;
	else
		return parent[t] = find_set(parent[t]);
}

bool union_set(int a, int b)
{
	int t1 = find_set(a);
	int t2 = find_set(b);
	if (t1 != t2)
	{
		parent[t2] = t1;
		return true;
	}
	return false;
}

int main()
{
	int a, b;
	while (scanf("%d%d", &a, &b) != EOF && a != -1)
	{
		if (a == 0 && b == 0)
		{
			printf("Yes\n");
			continue;
		}
		memset(vis, false, sizeof(vis));
		memset(parent, -1, sizeof(parent));
		union_set(a, b);
		vis[a] = vis[b] = true;
		bool ret = true;
		bool ok = true;
		while (scanf("%d%d", &a, &b) && a)
		{
			ret = union_set(a, b);
			vis[a] = vis[b] = true;
			if (!ret) ok = false;
		}
		int sum = 0;
		for (int i = 0; i < MAXN; i++)
		{
			if (vis[i] && parent[i] == -1)
				sum++;
		}
		if (sum != 1) ok = false;
		printf("%s\n", ok ? "Yes" : "No");
	}

}



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU2795 Billboard 线段树
开始的代码，暴力求解。。。。。果断超时

#include <iostream>
#include <cstdio>
#include <string.h>
using namespace std;

const int maxn = 200005;

int main()
{
    int  h, w, k, b;
    int  a[maxn] ;
    bool flag;
    while(scanf("%d%d%d", &h, &w, &k) != EOF){
        memset(a, 0, sizeof(a));
        for(int j = 0; j < k; j++){
            scanf("%d", &b);
            flag = false;
            for(int i = 1; i <= h; i++){
                if(a[i] + b <= w) {
                    a[i] += b;
                    flag = true;
                    printf("%d\n", i);
                    break;
                }
            }
            if(!flag) printf("-1\n");
        }
    }
    return 0;
}


线段树求解  

#include<iostream>
#include<cstdio>
using namespace std;
const int  N = 200005;
int h,w,n;
struct  Tree
{
    int l,r;
    int num;
}tree[N<<2];
int minn(int h,int n)
{
    if(h>n)
        return n;
    else
        return h;
}
int maxx(int a,int b)
{
    if(a>b)
        return a;
    else
        return b;
}
void creat(int i,int l,int r)
{
    int mid=(l+r)>>1;
    tree[i].l=l;
    tree[i].r=r;
    tree[i].num=w;
    if(l==r)
        return;
    creat(i<<1,l,mid);
    creat(i<<1|1,mid+1,r);
}
int query(int i,int len)
{
    if(tree[i].l==tree[i].r)
    {
        tree[i].num-=len;
        return tree[i].l;
    }
    else
    {
        int sum1=0,sum2=0;
        if(len<=tree[i<<1].num)
            sum1=query(i<<1, len);
        else
            if(len<=tree[i<<1|1].num)
                sum2=query(i<<1|1,len);
        tree[i].num=maxx(tree[i<<1].num,tree[i<<1|1].num);   //回溯
        return sum1+sum2;
    }
}
int main()
{
    while(scanf("%d%d%d",&h,&w,&n) != EOF)
    {
        int len;
        creat(1,1,minn(h,n));
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&len);
            if(tree[1].num>=len)
                printf("%d\n",query(1,len));
            else
                printf("-1\n");
        }
    }
    return 0;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

[搜索]hdu5355
题意： 
      将n分成一样大小的m份.  
 分析： 
      很经典的一道题。如果n==2m 那么2m*(2m+1)肯定能成功。然后就按照这个点，分别一直减去2m,如果n<=40的话就可以爆搜了。先找规律处理一部分，然后暴力一部分。这题很经典的说。

#include<iostream>   
#include<stdio.h>  
#include<math.h>  
#include <map>
#include<cstring>
#include<vector>
#include<deque>
#include<queue>
#include<stack>
#include<algorithm> 
#include<stdlib.h>  
#define read freopen("q.txt","r",stdin) 
#define LL long long 
using namespace std;  
const int maxn = 100005;
int vis[maxn],s[100];
vector<int> res[100];
int m;
bool dfs(int n,int sum)
{
    if(n<=0)return true;

    for(int i=1;i<=m;i++)
    {
        if(s[i]+n>sum)continue;
        s[i]+=n;
        vis[n]=i;
        if(dfs(n-1,sum))return true;
        vis[n]=0;
        s[i]-=n;
    }
    return false;
}
int main()
{
    //read;
    int cas;
    scanf("%d",&cas);
    while(cas--)
    {
        int n,i,j;
        scanf("%d%d",&n,&m);
        memset(vis,0,sizeof(vis));
        memset(s,0,sizeof(s));
        for(i=1;i<=m;i++)res[i].clear();
        LL tmp=(LL)n*(n+1)/2;
        if(tmp%m || n<2*m-1)
        {
            puts("NO");
            continue;
        }
        while(n>40)
        {
            for(i=1;i<=m;i++)res[i].push_back(n--);
            for(i=m;i>=1;i--)res[i].push_back(n--);
        }
        dfs(n,n*(n+1)/(2*m));
        for(i=1;i<=n;i++)res[vis[i]].push_back(i);
        puts("YES");
        for(i=1;i<=m;i++)
        {
            int len=res[i].size();
            printf("%d ",len);
            for(j=0;j<len;j++)printf(" %d",res[i][j]);
            printf("\n");
        }
    }   

}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 题目3415 Common Substrings（后缀数组+栈，求可以匹配到的长度大于k的公共子串个数）
Common Substrings




Time Limit: 5000MS
 
Memory Limit: 65536K


Total Submissions: 8471
 
Accepted: 2798




Description


A substring of a string T is defined as:
T(i, k)=TiTi+1...Ti+k-1, 1≤i≤i+k-1≤|T|.
Given two strings A, B and one integer K, we define
S, a set of triples (i, j, k):
S = {(i, j, k) | k≥K,
A(i, k)=B(j, k)}.
You are to give the value of |S| for specific A, B and
K.


Input


The input file contains several blocks of data. For each block, the first line contains one integer
K, followed by two lines containing strings A and B, respectively. The input file is ended by
K=0.
1 ≤ |A|, |B| ≤ 105
1 ≤ K ≤ min{|A|, |B|}
Characters of A and B are all Latin letters.


Output

For each case, output an integer |S|.

Sample Input
2
aababaa
abaabaa
1
xx
xx
0

Sample Output
22
5

Source
POJ Monthly--2007.10.06, wintokk

题目大意：
就是可以匹配到的长度大于k的公共子串个数，即S = {(i, j, k) | 
k≥K, A(i, k)=B(j, 
k)}.个数
例如第二组，长度为1时，第一个串取第一个x，第二个串可以去第一个或第二个，种类为2，第一个串取第二个一样，种类又是2，对于长度为2时，第一个串全取，第二个串全取，一种，总共有五种
思路：按题目的意思可以转换为求所有的i ,j,两个串后缀的最长公共前缀长度lcp（s1[i],s2[j]）-k+1>0的和，暴力绝对超时，所以运用一个单调栈来求所有串和这个串的最长前缀

剩下的思路讲解来自http://m.blog.csdn.net/blog/u012866104/38725689

这道题需要对height数组分组后，用单调栈优化。对于LCP=L>K的前缀，对答案的贡献是L-K+1.即长度为K,K+1.....L的公共字串。对于每一组，栈里维护height值递增，这样保证了每个height的贡献量为height[i]-K+1,因为有定理LCP（i,j）=min（height[i+1],...height[j]）如果在height[i]之后插入一个height[k]<height[i],那么height[i]就等于废了，他的价值仅为height[k]了，对于之后的j，LCP（i,j）起码要<=height[k],像这种递减的值插入栈前，需要将栈里>=插入值的变成插入值，然后将插入值的宽度增加。因为这当中为了降低复杂度，用了一个sum来维护当前栈里的后缀与将要入栈的后缀的公共字串的个数。因此实际上的{将栈里>=插入值的变成插入值}的操作，体现在sum上，是对sum减去一段height之差*宽度。
补充：因为rank=i的后缀能与其rank前后的后缀都可能产生公共子串，但此算法只维护其前面的，因此排在A串后缀后面的B串后缀，应该用扫描B串后缀来维护，因为B在A后，以B为参考系，A就在前，这就是为什么要分别扫A和B串的原因。
补充完这段，接着开始：比如我们正在扫A串，那么当B串入栈时，sum均会加上L-K+1，而之后当有height值小的要入栈，此时可以是A串的后缀，他虽然不增加sum的值，但它也起到了阻断作用，它是之前栈里height值>=它的值变废了，因为后面的后缀与栈里算LCP值时，起码要<=这个值，由于栈里原先的元素都加了L-K+1，假设现在入栈的height值为T（T<L），那么它对答案的贡献是T-K+1，它使原先栈里大于等于它废成T，贡献量变为T-K+1，相当于减少了L-K+1-（T-K+1）=L-K（高度差），因为之前入栈时已加在sum上，此时就要从sum中减去了，当然不能忘了乘宽度，因为这些height都会合并，他代表的是一系列height相同的元素，是有数目的。

开始用比较习惯的写法，提交过了发现跑了900多，感觉有些慢，换了以前的写法又写了一遍稍微快一点点
ac代码1
Problem: 3415		User: kxh1995
Memory: 5064K		Time: 938MS
Language: C++		Result: Accepted
#include<stdio.h>       
#include<string.h>       
#include<algorithm>       
#include<iostream>        
using namespace std;      
char str[200010];    
int sa[200100],Rank[200100],rank2[200100],height[200010],c[200100],*x,*y;
int k,stack[200100][2];  
int n;  
void cmp(int n,int sz)  
{  
    int i;  
    memset(c,0,sizeof(c));  
    for(i=0;i<n;i++)  
        c[x[y[i]]]++;  
    for(i=1;i<sz;i++)  
        c[i]+=c[i-1];  
    for(i=n-1;i>=0;i--)  
        sa[--c[x[y[i]]]]=y[i];  
}  
void build_sa(char *s,int n,int sz)  
{  
    x=Rank,y=rank2;  
    int i,j;  
    for(i=0;i<n;i++)  
        x[i]=s[i],y[i]=i;  
    cmp(n,sz);  
    int len;  
    for(len=1;len<n;len<<=1)  
    {  
        int yid=0;  
        for(i=n-len;i<n;i++)  
        {  
            y[yid++]=i;  
        }  
        for(i=0;i<n;i++)  
            if(sa[i]>=len)  
                y[yid++]=sa[i]-len;  
            cmp(n,sz);  
        swap(x,y);  
        x[sa[0]]=yid=0;  
        for(i=1;i<n;i++)  
        {  
            if(y[sa[i-1]]==y[sa[i]]&&sa[i-1]+len<n&&sa[i]+len<n&&y[sa[i-1]+len]==y[sa[i]+len])  
                x[sa[i]]=yid;  
            else  
                x[sa[i]]=++yid;  
        }  
        sz=yid+1;  
        if(sz>=n)  
            break;  
    }  
    for(i=0;i<n;i++)  
        Rank[i]=x[i];  
}  
void getHeight(char *s,int n)  
{  
    int k=0;  
    for(int i=0;i<n;i++)  
    {  
        if(Rank[i]==0)  
            continue;  
        k=max(0,k-1);  
        int j=sa[Rank[i]-1];  
        while(s[i+k]==s[j+k])  
            k++;  
        height[Rank[i]]=k;  
    }  
} 
int main()
{
	while(scanf("%d",&k)!=EOF,k)
	{
		int i;
		scanf("%s",str);
		int len=strlen(str);
		str[len]=127;
		scanf("%s",str+len+1);
		int n=strlen(str);
		build_sa(str,n+1,128);
		getHeight(str,n);
		__int64 tot,top;
		tot=top=0;
		__int64 sum=0;
		for(i=1;i<=n;i++)
		{
			if(height[i]<k)
				top=tot=0;
			else
			{
				int cnt=0;
				if(sa[i-1]<len)
				{
					cnt++;
					tot+=height[i]-k+1;
				}
				while(top>0&&height[i]<=stack[top-1][0])
				{
					top--;
					tot-=stack[top][1]*(stack[top][0]-height[i]);
					cnt+=stack[top][1];
				}
				stack[top][0]=height[i];
				stack[top++][1]=cnt;
				if(sa[i]>len)
					sum+=tot;
			}
		}
		tot=top=0;
		for(i=1;i<=n;i++)
		{
			if(height[i]<k)
				top=tot=0;
			else
			{
				int cnt=0;
				if(sa[i-1]>len)
				{
					cnt++;
					tot+=height[i]-k+1;
				}
				while(top>0&&height[i]<=stack[top-1][0])
				{
					top--;
					tot-=stack[top][1]*(stack[top][0]-height[i]);
					cnt+=stack[top][1];
				}
				stack[top][0]=height[i];
				stack[top++][1]=cnt;
				if(sa[i]<len)
					sum+=tot;
			}
		}
		printf("%I64d\n",sum);
	}
}
ac代码2
Problem: 3415		User: kxh1995
Memory: 5856K		Time: 797MS
Language: C++		Result: Accepted
#include<stdio.h>       
#include<string.h>       
#include<algorithm>       
#include<iostream>      
#define min(a,b) (a>b?b:a)   
#define max(a,b) (a>b?a:b)    
using namespace std;      
char str[200010];    
int sa[200100],t1[200200],t2[200200],c[200200];  
int rank[200200],height[200200]; 
int k,stack[200100][2];  
int n;  
void build_sa(char s[],int n,int m)  
{  
    int i,j,p,*x=t1,*y=t2;  
    for(i=0;i<m;i++)  
        c[i]=0;  
    for(i=0;i<n;i++)  
        c[x[i]=s[i]]++;  
    for(i=1;i<m;i++)  
        c[i]+=c[i-1];  
    for(i=n-1;i>=0;i--)  
        sa[--c[x[i]]]=i;  
    for(j=1;j<=n;j<<=1)  
    {  
        p=0;  
        for(i=n-j;i<n;i++)  
            y[p++]=i;  
        for(i=0;i<n;i++)  
            if(sa[i]>=j)  
                y[p++]=sa[i]-j;  
        for(i=0;i<m;i++)  
            c[i]=0;  
        for(i=0;i<n;i++)  
            c[x[y[i]]]++;  
        for(i=1;i<m;i++)  
            c[i]+=c[i-1];  
        for(i=n-1;i>=0;i--)  
            sa[--c[x[y[i]]]]=y[i];  
        swap(x,y);  
        p=1;  
        x[sa[0]]=0;  
        for(i=1;i<n;i++)  
            x[sa[i]]=y[sa[i-1]]==y[sa[i]]&&y[sa[i-1]+j]==y[sa[i]+j]?p-1:p++;  
        if(p>=n)  
            break;  
        m=p;  
    }  
}  
void getHeight(char *s,int n)  
{  
    int i,j,k=0;  
    for(i=0;i<=n;i++)  
        rank[sa[i]]=i;  
    for(i=0;i<n;i++)  
    {  
        if(k)  
            k--;  
        j=sa[rank[i]-1];  
        while(s[i+k]==s[j+k])  
            k++;  
        height[rank[i]]=k;  
    }  
}
int main()
{
	while(scanf("%d",&k)!=EOF,k)
	{
		int i;
		scanf("%s",str);
		int len=strlen(str);
		str[len]=127;
		scanf("%s",str+len+1);
		int n=strlen(str);
		build_sa(str,n+1,128);
		getHeight(str,n);
		__int64 tot,top;
		tot=top=0;
		__int64 sum=0;
		for(i=1;i<=n;i++)
		{
			if(height[i]<k)
				top=tot=0;
			else
			{
				int cnt=0;
				if(sa[i-1]<len)
				{
					cnt++;
					tot+=height[i]-k+1;
				}
				while(top>0&&height[i]<=stack[top-1][0])
				{
					top--;
					tot-=stack[top][1]*(stack[top][0]-height[i]);
					cnt+=stack[top][1];
				}
				stack[top][0]=height[i];
				stack[top++][1]=cnt;
				if(sa[i]>len)
					sum+=tot;
			}
		}
		tot=top=0;
		for(i=1;i<=n;i++)
		{
			if(height[i]<k)
				top=tot=0;
			else
			{
				int cnt=0;
				if(sa[i-1]>len)
				{
					cnt++;
					tot+=height[i]-k+1;
				}
				while(top>0&&height[i]<=stack[top-1][0])
				{
					top--;
					tot-=stack[top][1]*(stack[top][0]-height[i]);
					cnt+=stack[top][1];
				}
				stack[top][0]=height[i];
				stack[top++][1]=cnt;
				if(sa[i]<len)
					sum+=tot;
			}
		}
		printf("%I64d\n",sum);
	}
}







版权声明：本文为博主原创文章，未经博主允许不得转载。

Java基础笔记-反射及应用
反射： 
动态获取字节码文件对象(Person.class)，并对其成员进行运行。 
动态获取字节码文件对象的方式： 
      1：任何一个对象都是由字节码文件对象创建的，所以任何一个对象都可以得到自己的字节码文件对象 
        那么这个功能应该定义在Object中，所以使用 getClass() 
        需要先new对象
  2:每种数据类型都有一个 静态的class 属性,通过该属性可以得到字节码文件对象
    不需要new对象，但是需要Person类存在

  3:Class类提供了一个静态的forName(String str)方法 
    只需要提供字符串形式的包名+类名

1.
Person person1 = new Person();//先加载Person.class到方法区
Class<? extends Person> claz1 = person1.getClass();//得到了Person.class
Person person2 = new Person();
Class<? extends Person> claz2 = person2.getClass();//得到了 Person.class
System.out.println(claz1==claz2);//true 
---->字节码文件只加载一次到方法区,所以两次得到的是同一个

2.
Class<Person> claz1 = Person.class;
3.
Class<?> claz1 = Class.forName("com.reflect.Person");
动态获取字节码文件对象，并创建对象: 
1)调用无参构造方法创建对象
//当无参的构造方法不存在时，会发生InstantiationException
    //当构造方法的权限过低时，会发生IllegalAccessException
    public static void createObj1() throws ClassNotFoundException, InstantiationException, IllegalAccessException
    {
        //Person person = new Person();
        //获取字节码文件对象---Person.class
        Class<?> claz = Class.forName("com.reflect.Person");            
        //使用Class提供的newInstance()方法创建Person类型的对象
        Object obj = claz.newInstance();//使用无参的构造方法创建对象
        Person person = (Person)obj;
        System.out.println(person);
}
2)使用有参数的构造方法创建对象
public static void createObj2() throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException
    {   //Person person = new Person("小红",20);
        //获取字节码文件对象---Person.class
        Class<?> claz = Class.forName("com.reflect.Person");        
        //得到构造方法所属的Constructor类型的对象
        Constructor<?> constructor = claz.getConstructor(String.class,int.class);       
        //使用构造方法创建对象--使用Constructor提供的创建对象的功能
        Person person =(Person)constructor.newInstance("小红",20);
        System.out.println(person);
}
3)动态创建对象并给属性赋值
Class<?> claz = Class.forName("com.reflect.Person");         
//得到属性name所属的 Field类型的对象
//Field field = claz.getField("name");//只能获取权限是public 的属性
//System.out.println(field);//NoSuchFieldException
Field field = claz.getDeclaredField("name");
//因为name是非静态属性，所以必须通过对象访问，所以先创建对象
Object obj = claz.newInstance();
//设置name属性为可访问的
field.setAccessible(true);// 该方法是从父类中继承的
//使用Field类提供的赋值功能，给属性赋值
field.set(obj, "小红");
System.out.println(obj);
4)调用静态方法
public static void method3() throws ClassNotFoundException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException
    {
        //获取字节码文件对象---Person.class
         Class<?> claz = Class.forName("com.reflect.Person");

         ///获取被调用的方法所属的 Method类型的对象
         Method method = claz.getMethod("function", null);
         //执行方法
         method.invoke(null, null);
}
5)通过对象调用无参方法
public static void method1() throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException
    {
        // Person person = new Person();person.show();
        //获取字节码文件对象---Person.class
         Class<?> claz = Class.forName("com.reflect.Person");
         //获取被调用的方法所属的 Method类型的对象
         Method method = claz.getMethod("show", null);
         //show()属于非静态方式，需要对象去调用
         Object obj = claz.newInstance();
         //执行方法
         method.invoke(obj, null);
}
6)通过对象调用有参方法
//调用带参的方法
public static void method2() throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException
{
        //获取字节码文件对象---Person.class
         Class<?> claz = Class.forName("com.reflect.Person");        
       //获取被调用的方法所属的 Method类型的对象
         Method method = claz.getMethod("fun", String.class);        
         //fun()属于非静态方式，需要对象去调用
         Object obj = claz.newInstance();
         //执行方法
         method.invoke(obj, "hello");
}
反射应用： 
这里有一台笔记本,刚开始只有外设鼠标。后来增加键盘、摄像头等等。 
笔记本有running方法和use方法.外设都有open和close方法
public class NoteBook { 
    public void runing(){
        System.out.println("电脑运行");
    }   
    public void useKeyBoard(KeyBoard kb){
        if(kb!=null){
            kb.open();
            kb.close();
        }
    }
}
调用：
NoteBook noteBook = new NoteBook();
noteBook.runing();
KeyBoard keyBoard = new KeyBoard ();
noteBook.use(keyBoard );
如果添加外设鼠标呢? 
NoteBook又得添加一个useMouse(Mouse mouse){..}方法，如果再添加外设的话，还得添加相应的方法。 
当然，这里很容易解决，定义一个借口Usb.
interface Usb { 
    public void open();
    public void close();
}
然后让外设去实现这个接口， 
在NoteBook里面只用定义一个
useUsb(Usb usb){
    usb.open();
    usb.close();
}
在主程里调用：
Usb keyBoard = new KeyBoard ();
noteBook.useUsb(keyBoard );
Usb mouse = new Mouse();
noteBook.useUsb(mouse);
如果还要添加外设，只用添加相应的类并实现Usb接口即可，那么问题来了，主程序里面又得new新的对象，调用相同的语句。
解决方法就可以用反射了：
1.把所有的外设添加到一个配置文件中 
usb1=com.reflect.test.KeyBoard 
usb2=com.reflect.test.Mouse 
2.主程序里调用
Properties properties = new Properties();
FileInputStream fileInputStream = new FileInputStream("config\\config.properties");
properties.load(fileInputStream);            
for(int i=1;i<=properties.size();i++)
{
       String value properties.getProperty("usb"+i);
       Class<?> claz = Class.forName(value);
       Object obj = claz.newInstance();
       Usb usb = (Usb)obj;
       noteBook.useUsb(usb);
}
–>添加外设只用在配置文件中添加，主程序调用不用修改

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

12549 - Sentry Robots （二分图匹配）
该题和HDU 5093 如出一辙 传送门  。即求解二分图最大匹配数 = 最小点集覆盖 。 该题要求用尽量少的机器人看守所有重要的点，并且障碍物会阻隔机器人的看守范围  。
我们不妨将行列分开，按照行和列的最大看守范围编号，这样得到的就是最大匹配数 。 由于要求看守所有重要的点，所以这样可以有效去重，进行了最大匹配之后还可以保证一定看守了所有的点 。 建好图之后套Dinic模板就行了 。
该题有点逆着来的意思 ，请读者仔细品味 。
细节参见代码：
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int INF = 1000000000;
const int maxn = 20000 + 100;
int T,cnt,n,m,u,pp,a,b,v,w,t,id1[100][100],id2[100][100];
char s[maxn][maxn];
struct Edge {
  int from, to, cap, flow;
};
bool operator < (const Edge& a, const Edge& b) {
  return a.from < b.from || (a.from == b.from && a.to < b.to);
}
struct Dinic {
  int n, m, s, t;
  vector<Edge> old;
  vector<Edge> edges;    // 边数的两倍
  vector<int> G[maxn];   // 邻接表，G[i][j]表示结点i的第j条边在e数组中的序号
  bool vis[maxn];        // BFS使用
  int d[maxn];           // 从起点到i的距离
  int cur[maxn];         // 当前弧指针
void init(int n) {
    for(int i = 0; i < n; i++) G[i].clear();
    edges.clear();
}
void AddEdge(int from, int to, int cap) {
    edges.push_back((Edge){from, to, cap, 0});
    edges.push_back((Edge){to, from, 0, 0});
    m = edges.size();
    G[from].push_back(m-2);
    G[to].push_back(m-1);
}
bool BFS() {
    memset(vis, 0, sizeof(vis));
    queue<int> Q;
    Q.push(s);
    vis[s] = 1;
    d[s] = 0;
    while(!Q.empty()) {
      int x = Q.front(); Q.pop();
      for(int i = 0; i < G[x].size(); i++) {
        Edge& e = edges[G[x][i]];
        if(!vis[e.to] && e.cap > e.flow) {
          vis[e.to] = 1;
          d[e.to] = d[x] + 1;
          Q.push(e.to);
        }
      }
    }
    return vis[t];
}
int DFS(int x, int a) {
    if(x == t || a == 0) return a;
    int flow = 0, f;
    for(int& i = cur[x]; i < G[x].size(); i++) {
      Edge& e = edges[G[x][i]];
      if(d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap-e.flow))) > 0) {
        e.flow += f;
        edges[G[x][i]^1].flow -= f;
        flow += f;
        a -= f;
        if(a == 0) break;
      }
    }
    return flow;
}
int Maxflow(int s, int t) {
    this->s = s; this->t = t;
    int flow = 0;
    while(BFS()) {
      memset(cur, 0, sizeof(cur));
      flow += DFS(s, INF);
    }
    return flow;
  }
}g;
char ss[maxn][maxn];
map<int,int> p;
int main() {
    scanf("%d",&T);
    while(T--) {
        scanf("%d%d%d",&n,&m,&pp);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++) s[i][j] = '.';
        g.init(n*m*2+n);
        for(int i=1;i<=pp;i++) {
            scanf("%d%d",&a,&b);
            s[a][b] = '*';
        }
        scanf("%d",&w);
        for(int i=1;i<=w;i++) {
            scanf("%d%d",&a,&b);
            s[a][b] = '#';
        }
        int cnt = 1;
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++) {
                if(s[i][j] == '#') cnt++;//按照行编号
                if(s[i][j] == '*') id1[i][j] = cnt;
            }
            cnt++;
        }
        for(int j=1;j<=m;j++) {
            for(int i=1;i<=n;i++) {
                if(s[i][j] == '#') cnt++;//按列编号
                if(s[i][j] == '*') id2[i][j] = cnt;
            }
            cnt++;
        }
        p.clear();
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++) {
                if(s[i][j] == '*') {
                    g.AddEdge(id1[i][j],id2[i][j],1);//连边
                    if(!p.count(id1[i][j])) { //每个编号只能与源点连一次
                        p[id1[i][j]] = 1;
                        g.AddEdge(0,id1[i][j],1);
                    }
                    if(!p.count(id2[i][j])) {//同上
                        p[id2[i][j]] = 1;
                        g.AddEdge(id2[i][j],cnt+1,1);
                    }
                }
            }
        }
        int ans = g.Maxflow(0,cnt+1);
        printf("%d\n",ans);
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

参观城市（dfs,改编spfa）




问题 F: 参观城市
时间限制: 1 Sec  内存限制: 128 MB
提交: 34  解决: 19
[提交][状态][讨论版]

题目描述


有N个城市，这N个城市间只有N-1条路把这个N个城市连接起来。现在，小明在第S号城市，他有张该国地图，他想知道如果自己要去参观第T号城市，必须经过的前一个城市是几号城市（假设你不走重复的路）。


输入


第一行输入一个整数M表示测试数据共有M(1<=M<=5)组
每组测试数据的第一行输入一个正整数N(1<=N<=100000)和一个正整数S(1<=S<=100000)，N表示城市的总个数，S表示参观者所在城市的编号
随后的N-1行，每行有两个正整数a,b(1<=a,b<=N)，表示第a号城市和第b号城市之间有一条路连通。


输出


每组测试数据输N个正整数，其中，第i个数表示从S走到i号城市，必须要经过的上一个城市的编号。（其中i=S时，请输出-1）


样例输入

110 101 21 91 83 78 68 109 510 310 4

样例输出

8 1 10 10 9 8 3 10 1 -1



     竞赛的时候就差一点写出来！

我是想用邻接表做，我用了两种方法，一种是spfa的模板改编的，另一种是dfs




上代码！




dfs版本:





#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int per[110000],vis[110000],t,head[110000];
struct node 
{
	int u,v,next;
}s[110000];
void addedge(int x,int y)
{
	s[t].u=x;
	s[t].v=y;
	s[t].next=head[x];
	head[x]=t++;
}
void dfs(int x)
{
	for(int k=head[x];k!=-1;k=s[k].next)
	{
		int v=s[k].v;
		if(!vis[v])
		{
			per[v]=x;
			vis[v]=1;
			dfs(v);
		}
	}
}
int main()
{
	int N,a,b,i,m,n;
		scanf("%d",&N);
		while(N--)
		{
			memset(head,-1,sizeof(head));
			memset(vis,0,sizeof(vis));
			scanf("%d%d",&m,&n);
			t=0;
			for(i=0;i<n-1;i++)
			{
				scanf("%d%d",&a,&b);
				addedge(a,b);
				addedge(b,a);
			}
			vis[m]=1;
			per[m]=-1;
			dfs(m);
			for(i=1;i<m;i++)
			printf("%d ",per[i]);
			printf("%d\n",per[m]);
		}
return 0;
}


spfa改编版本：





#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<queue>
#define INF 0x3f3f3f3f
using namespace std;
int per[101000],vis[101000];
int head[101000];
int m,n;
struct node 
{
	int from,to,next;
}s[101000];
void spfa()
{
	int cn,i;
	memset(vis,0,sizeof(vis));
	queue<int> qq;
	vis[n]=1;
	cn=n;
	per[n]=-1;
	qq.push(n);
	while(!qq.empty())
	{
		int u=qq.front();
		qq.pop();
		cn=u;
		for(int k=head[u];k!=-1;k=s[k].next)
		{
			int v=s[k].to;
				if(!vis[v])
				{
					qq.push(v);
					per[v]=cn;
					vis[v]=1;
				}
		}
	}
	for(i=1;i<m;i++)
	printf("%d ",per[i]);
	printf("%d\n",per[m]);
}
int main()
{
	int i,j,k,l,t,x,y,a,b,N;
	scanf("%d",&N);
	while(N--)
	{
		scanf("%d%d",&m,&n);
		 t=0;
		 memset(head,-1,sizeof(head));
		for(i=0;i<m-1;i++)
		{
			scanf("%d%d",&a,&b);
			s[t].from=a;
			s[t].to=b;
			s[t].next=head[a];
			head[a]=t++;
			s[t].from=b;
			s[t].to=a;
			s[t].next=head[b];
			head[b]=t++;
		}
		spfa();
	}
	return 0;
}


两种方法的区别是，dfs是一搜到底，然后回溯！

而spfs版本是把和当前相连的搜索完，在进行下一个！
都很巧妙，然而vector我还不会用，下次一定补上！



版权声明：本文为博主原创文章，未经博主允许不得转载。

C. Lengthening Sticks（Codeforces Round #317   容斥定理）

C. Lengthening Sticks


time limit per test
1 second


memory limit per test
256 megabytes


input
standard input


output
standard output



You are given three sticks with positive integer lengths of a, b, and c centimeters.
 You can increase length of some of them by some positive integer number of centimeters (different sticks can be increased by a different length), but in total by at most l centimeters.
 In particular, it is allowed not to increase the length of any stick.

Determine the number of ways to increase the lengths of some sticks so that you can form from them a non-degenerate (that is, having a positive area) triangle. Two ways are considered different, if the length of some stick is increased by different number of
 centimeters in them.



Input

The single line contains 4 integers a, b, c, l (1 ≤ a, b, c ≤ 3·105, 0 ≤ l ≤ 3·105).



Output

Print a single integer — the number of ways to increase the sizes of the sticks by the total of at most l centimeters, so that you
 can make a non-degenerate triangle from it.



Sample test(s)



input
1 1 1 2




output
4




input
1 2 3 1




output
2




input
10 2 1 7




output
0






Note

In the first sample test you can either not increase any stick or increase any two sticks by 1 centimeter.

In the second sample test you can increase either the first or the second stick by one centimeter. Note that the triangle made from the initial sticks is degenerate and thus, doesn't meet the conditions.







   题意：给出a,b,c,L，要求a+x,b+y,c+z构成三角形，x+y+z<=L，问有多少中分法(x,y,z可为0)。 

本来想写思路了，奈何岩兄写的太好了，我就不好意思写了，索性就用他的吧。




岩兄博客地址：点击打开链接

  

思路：用容斥来搞，结果ans=全部组合的情况-不符合三角形定理的情况。 

1.求全部组合的情况： 
当L=0时，res=1； 
当L=1时，res=3；所以当L=1时形成的情况为1+3=4 
当L=2时，res=6；所以当L=2时形成的情况为4+6=10 
当L=3时，res=10; 所以当L=3时形成的情况为10+10=20 
…….. 
所以由上面可以推出当L=n时，全部的组合情况是C(2,2) + C(3,2) + ......C(l,2)。 
2.不符合三角形定理的情况： 
如果要形成一个三角形，那么必须任意两边之和大于第三边。那么不符合的就是任意一边大于等于其余两边的和。所以分别把a,b,c当成第三边，然后再考虑将剩下的l拆分三份分配给a,b,c依旧不满足的情况即可。 
我们先把a当成第三边，然后给a增加一个La,现在i=a+La，Max=a+b+c+L。现在我们考虑b+c的范围，因为是不满足的情况，所以b+c的变化范围<=i，又因为总长度maxn的限制，b+c<=maxn-i,所以b+c的最大变化范围只能在min(i,maxn-i)。令x=min(i,maxn-i)-b-c表示总共变化量的大小，即Lb+Lc<=x，等价于tmp+Lb+Lc的方案数。


#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<vector>
#include<queue>
#include<stack>
#include<map>

using namespace std;

long long int minn(long long int xx,long long int yy){
    if(xx<yy){
        return xx;
    }
    return yy;
}

long long int IEP(long long int a,long long int b,long long int c,long long int l){
    long long int s = 0;
    long long int maxn = a + b + c + l;
    for(long long int i=a;i<=a+l;i++){
        if(b+c<=i){
            long long int xx = min(i,maxn-i)-b-c;
            s += (xx+1)*(xx+2)/2;
        }
    }
    return s;
}

int main(){
    __int64 a,b,c,l;
    __int64 ans = 0;
    while(scanf("%lld%lld%lld%lld",&a,&b,&c,&l)!=EOF){
        ans = 0;
        for(__int64 i=0;i<=l;i++){
            ans += (i+1)*(i+2)/2;
        }
        ans -= IEP(a,b,c,l);
        ans -= IEP(b,a,c,l);
        ans -= IEP(c,a,b,l);
        printf("%lld\n",ans);
    }
    return 0;
}







版权声明：本文为博主原创文章，如有特殊需要请与博主联系  QQ ： 793977586。

一个非常正确且强大的编程学习方法


一旦你发现一个学习工具，它采用自上而下的方法，那么什么是最好的学习方法？我对这有一个具有争议性的观点：我认为尽可能快地记住基础知识对初学者而言是绝对有必要的。当成为更高级的学习者，记忆很快成为一个被丢弃了的方式。你可能听到过别人轻视地说（“不要死记，要内部消化”，“我在消化记住的东西”，“我讨厌测试，我不得不回想起记忆中的东西”）。
另一方面，当你还是小学的时候，你被迫花时间来背乘法口诀表。为什么要背呢？因为你的基础乘法口诀表可以是构建更复杂的乘除法的基础。这和你记忆编程语言的语法并没有什么不同：如果你写 if 或 for 循环越自然，那么你写出更复杂的语句块也更容易。
我也承认记忆并不总是学习所有东西的最好方法，但是我相信对于编程初学者而言，是实践编程所绝对必须的。为什么呢？因为它可以减少阻力，如果有什么东西会带给初学者挫折，那就是阻力。
考虑到这一点，这里有一些具体的建议给那些正在学习或准备学习 Web 应用开发的初学者。实际上，说得更远点更抽象点，这就是一个如何开始学习软件开发的一个好计划。很显然，这不是一个适合所有人的计划，但是我认为它一定适合大部分初学者。

学习一门弱类型的编程语言，不要先学习那种具有强制类型的、面向对象的编程语言。严格而言，如果有人对你提到 class (类）或继承，那么你就应该去选择其它的途径了。虽然我认同类和继承相关技术是软件开发中必不可少的，但是我强烈认为它们不应该是初学者的选择。鉴于此，我认为 JavaScript 是初学者而言最理想的编程语言，因为：(a) JS 解释器在绝大部分浏览器上都可用，(b)它的面向对象特性并不是强制型的，(c)在工业界被广泛使用（是的，即使是 web 之外的客户端，即使是现在担任设备工程师的我也做嵌入 JavaScript 的工作。）说得更具体点，我建议你学习用 JavaScript 如何学习去下面的事，特别是以这个顺序：学习如何打印出一些东西，学习如何声明和定义变量，学习基本算术运算操作（包括余数操作），学习循环（特别是 for 循环），学习把抽象重复的代码写成函数，学习字符串和用循环操作字符串，学习数组和数组的循环方法（特别是 foreach 循环），学习创建和操作对象数据集。记住上面的这些并每天写一个程序来实践，直到这些都轻而易举地想起来。学习 Git 的基本操作，学习通过命令行使用 Git。这意味着要先学习四个 Unix/Linux 命令（ls,pwd,mkdir,cd)。当学习了这几个命令，也就学会了以“树型”或层次结构的呈现方式查询文件系统。一旦你掌握了上面的几个 Unix/Linux 命令，并会从命令行进入文件系统，你就应该学几个基础的 Git 命令。主要是 git init, git status, git add and git commit。一旦你掌握了 Git 的基本操作，在学习下面的技术时将其集成到你的工作流中。学习 HTML 基础，能够凭记忆创建简单的 HTML 页面。学习 DOM 和如何理解 HTML 作为指定的分层树结构。花点时间来思考它如何关系到你在前面步骤中学到的分层文件系统。学习 CSS 选择器，了解它如何让你选定 DOM 的某些部分。了解 DOM 元素之间的关系。了解一个 DOM 元素作为另一个 DOM 元素的父元素或子元素的含义。理解这与后代和祖先之间的关系有什么不同。记住选择器可以让你通过这些关系来选定某些元素。学习 jQuery，并主要专注于 DOM 的操作能力。学会用 jQuery 对 DOM 插入或删除元素，实践可视化如何影响用 DOM 定义的树型结构。实践 jQuery 中的事件处理和 DOM 操作（比如，实践操作 DOM 当用户点击某个东西，或在指定的时间间隔）。多练习 JavaScript 对象，并把它们当作可变的聚合器。学习如何用 JavaScript 来表示更复杂的数据而不是基本数据类型。学会应用并操作这些数据结构。理解并定义 JSON、理解它如何与 JavaScript 对象相关联。学会使用 jQuery 的 getJSON 函数从文件中获取数据到 JavaScript 对象中。使用类似的技术，用一个简单的 JSONP API 去练习用 AJAX 拉取数据。练习向 DOM 插入和删除这个数据。
在这个阶段，做一个简单的幻灯片来循环播放 Flickr 图片，这将是一个令人难以置信的项目，将真正考验你的能力，使用之前学过的基础技术来实现它。
如果你做了这一步，那么你已经掌握了大量必备的编程和计算机科学基本概念。具体来说，你掌握了计算机程序的最重要元素（如果 if-else 语句，循环，变量，对象，函数，数组等），你已经学会了链式或树型的数据结构。这时，无疑你已经准备好转移到更高级的主题。


谢谢关注websites博客！
本文最初发表在codecloud.net，文章内容属作者个人观点，不代表本站立场。

版权声明：本文为博主原创文章，未经博主允许不得转载。

单链表的反转（数据结构 面试题）

编写一个算法来颠倒一个链表，该链表的第一个结点由first指向。不要复制列表元素；而是重置链接和指针，使得first指向原来的最后一个结点，并且结点之间的所有链接都反向。
思路：因为题目中明确说明不能复制元素，所以通过复制来重置另外一个链表的想法被终止。我们想到，如果要改变连接的指向，又能够要使链表继续遍历，那么最少需要先遍历到几个结点呢？答案是3个。如图：（第二张是将要结束时的情况）



3个结点之后就可以对第一个连接进行反转，直到cur->next-==NULL结束，然后对最后一个特殊处理即可，详见代码。
#include <iostream>
#include <ctime>
#include <string>
#include <string.h>
#include <algorithm>
using namespace std;
template <typename T>
class clist
{
public:
	struct node
	{
		T value;
		node* next;
		node(T v=NULL) :value(v){}
	};
	node *front;
	node *tail;
	int size;
	clist(node *f = NULL, node*t = NULL, int s = NULL) :front(f), tail(t), size(s){}
	~clist()
	{
		if (!size)
		{
			node* temp = front;
			node* pre = NULL;
			while (temp != tail)
			{
				pre = temp;
				temp = temp->next;
				delete pre;
			}
			delete temp;
			size = 0;
		}
	}
	void build_list_rand(int len)
	{	//创建一条任意长度的为len的链表
		srand((unsigned)time(NULL));
		front = new node();
		front->value = rand()%100+1;
		node* temp = front;
		size++;
		while (size<len)
		{
			temp->next = new node;
			temp->value = rand()%100+1;
			temp = temp->next;
			size++;
		}
		tail = temp;
		tail->value = rand()%100+1;
		tail->next = NULL;
	}
	void swap(node* &a, node* &b)
	{	//交换两个指针
		node* temp = a;
		a = b;
		b = temp;
	}
	void clist<T>::reserve()
	{	//反转函数
		node* head=NULL, *mid=NULL, *follow=NULL, *temp=NULL;
		if (size <= 1)
			return;
		else if (size == 2)
		{
			swap(front, tail);
			front->next = tail;
			tail->next = NULL;
		}
		else
		{
			swap(front, tail);
			head = tail;
			mid = tail->next;
			follow = mid->next;
			while (follow != NULL)
			{
				mid->next = head;
				head = mid;
				mid = follow;
				follow = follow->next;
			}
			mid->next = head;
			tail->next = NULL;
		}
	}
	void display()
	{	//打印整个链表和长度
		node* temp = front;
		while (temp != tail)
		{
			cout << temp->value << ' ';
			temp = temp->next;
		}
		cout << temp->value << endl;
		cout << "the size is " << size << endl;
	}
};
int main()
{
	clist<int> a;
	int b;
	cout << "请输入您要反转的链表的长度：" << endl;
	cin >> b;
	a.build_list_rand(b);
	a.display();
	a.reserve();
	a.display();
	return 0;
}运行结果：



版权声明：本文为博主原创文章，未经博主允许不得转载。

《Java实战开发经典》第五章5.2
package five; 
//第五章练习2，测试一个Employee类，属性包括编号、姓名 
//基本薪水、薪水增长额以及计算薪水增长额及计算增长后的工资 
//总额的操作方法 
public class Two { 
public static void main(String[] args) { 
    System.out.println(“===薪水调整前===”); 
    Employee employee=new Employee(); 
    employee.calculateSalaryIncrease(10000); 
    employee.calculateSalaryAll(); 
    employee.tell(); 
    System.out.println(“===薪水调整后===”); 
    employee.calculateSalaryIncrease(15000); 
    employee.setbasicSalary(15000); 
    employee.calculateSalaryAll(); 
    employee.tell(); 
} 
} 
class Employee{ 
     private int number=32109409; 
     private String name=”xpq”; 
     private int basicSalary=10000; 
     private int salaryIncrease; 
     private int xinshuizengzhange; 
     private int gongzizonge; 
     /*public int getbasicSalary(){ 
         return basicSalary; 
     }*/ 
     public void setbasicSalary(int temp){ 
         basicSalary=temp; 
     } 
     public Employee(){
 }
 public void tell(){
     System.out.println("编号:"+number+",名字:"+name+",基本薪水:"+basicSalary+",薪水增长额:"+xinshuizengzhange
             +",工资总额:"+gongzizonge);
 }
 public int  calculateSalaryIncrease(int temp){//计算薪水增长额
     return xinshuizengzhange=temp-basicSalary;
 }
 public int calculateSalaryAll(){//计算增长后工资总额
     return gongzizonge=basicSalary*12;
 }

}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【日常学习】【数学/哈希】康托展开
康托展开是什么呢？
（以下内容引自CSDN用户zhongkeli 原文地址：http://blog.csdn.net/zhongkeli/article/details/6966805
其实这位作者也是引用的博客园用户的文章，但是原文已经找不到了，因此放上转载作者作为来源，尊重原作者版权。）
康托展开的公式是 X=an*(n-1)!+an-1*(n-2)!+...+ai*(i-1)!+...+a2*1!+a1*0! 其中，ai为当前未出现的元素中是排在第几个（从0开始）。
　　这个公式可能看着让人头大，最好举个例子来说明一下。例如，有一个数组 s = ["A", "B", "C", "D"]，它的一个排列 s1 = ["D", "B", "A", "C"]，现在要把 s1 映射成 X。n 指的是数组的长度，也就是4，所以
X(s1) = a4*3! + a3*2! + a2*1! + a1*0!

关键问题是 a4、a3、a2 和 a1 等于啥？

a4 = "D" 这个元素在子数组 ["D", "B", "A", "C"] 中是第几大的元素。"A"是第0大的元素，"B"是第1大的元素，"C" 是第2大的元素，"D"是第3大的元素，所以 a4 = 3。
a3 = "B" 这个元素在子数组 ["B", "A", "C"] 中是第几大的元素。"A"是第0大的元素，"B"是第1大的元素，"C" 是第2大的元素，所以 a3 = 1。
a2 = "A" 这个元素在子数组 ["A", "C"] 中是第几大的元素。"A"是第0大的元素，"C"是第1大的元素，所以 a2 = 0。
a1 = "C" 这个元素在子数组 ["C"] 中是第几大的元素。"C" 是第0大的元素，所以 a1 = 0。（因为子数组只有1个元素，所以a1总是为0）
所以，X(s1) = 3*3! + 1*2! + 0*1! + 0*0! = 20

对于每一种排列，康托展开后，编号分别为：
A B C | 0
A C B | 1
B A C | 2
B C A | 3
C A B | 4
C B A | 5



说到这里，大家差不多久都明白了吧。康托展开，是用一一对应的方式将一些元素的排列映射为一组从1开始的连续数字。因此，如果在哈希表中用到它，不必取模，计算过程也没有复杂多少，但大大减少了哈希数组的空间复杂度，使得哈希数组空间利用率达到100%。哈希数组大小是n！（n为元素个数）。
那么，我们引用CSDN用户Re_cover的康托展开的代码（源地址：http://blog.csdn.net/re_cover/article/details/9823169）：
int factor[] = {1,1,2,6,24,120,720,5040,40320,362880};//阶乘   

int cantor(char x[]) //康托展开   
{  
    int sum = 0, s;  
    for(int i = 0; i < 9; i++)  
    {  
        s = 0;  
        for(int j = i + 1; j < 9; j++)  
            if(x[j] < x[i])  
                s++;  
        sum += s * factor[9 - i - 1];  
    }  
    return sum;  
}  

通过康托逆展开生成全排列


如果已知 s = ["A", "B", "C", "D"]，X(s1) = 20，能否推出 s1 = ["D", "B", "A", "C"] 呢？
因为已知 X(s1) = a4*3! + a3*2! + a2*1! + a1*0! = 20，所以问题变成由 20 能否唯一地映射出一组 a4、a3、a2、a1？如果不考虑 ai 的取值范围，有
3*3! + 1*2! + 0*1! + 0*0! = 20
2*3! + 4*2! + 0*1! + 0*0! = 20
1*3! + 7*2! + 0*1! + 0*0! = 20
0*3! + 10*2! + 0*1! + 0*0! = 20
0*3! + 0*2! + 20*1! + 0*0! = 20
等等。但是满足 0 <= ai <= n-1 的只有第一组。可以使用辗转相除的方法得到 ai，如下图所示：




知道了a4、a3、a2、a1的值，就可以知道s1[0] 是子数组["A", "B", "C", "D"]中第3大的元素 "D"，s1[1] 是子数组 ["A", "B", "C"] 中第1大的元素"B"，s1[2] 是子数组 ["A", "C"] 中第0大的元素"A"，s[3] 是子数组 ["C"] 中第0大的元素"C"，所以s1 = ["D", "B", "A", "C"]。
这样我们就能写出一个函数，它可以返回  s 的第 m 个排列。

这里同样引用Re_cover的代码：
void trans(int x) //康托展开逆运算   
{  
    int visit[10] = {0};  
    int t;  
    for(int i = 0; i < 9; i++)  
    {  
        t = x / factor[9 - i - 1];  
        x %= factor[9 - i - 1];  
        for(int j = 0; j <= t; j++)  
            if(visit[j] == 1)  
                t++;  
        visit[t] = 1;  
        st[i] = t;  
    }  
}  

至此，康托展开的学习就告一段落了。最后想介绍一下康托，虽然估计大家也都认识他吧，格奥尔格·康托，集合论的发明者，一生执着追求的异类。我们的数学老师只发过一篇补充阅读材料，介绍的就是康托。他是幸运的，他求学时，正值柏林大学形成欧洲数学中心的时代，他的导师是大数学家库莫尔，外尔斯特拉斯和克罗内克。他又是不幸的，他的集合论如罗巴切夫斯基的鞍面几何那样不为世人所接受，但罗巴切夫斯基至少还有在内心里默默支持他的高斯，而康托的学说即使他的恩师克罗内克都是最激进的反对者。孤独而执着地坚持着自己的学说的康托最终罹患严重的精神分裂，在痛苦和绝望中死去。直到他死后很多年，人们才重新发现集合论的重要性。如今集合论已成为中学数学最为基础的第一课。让我们缅怀这位抗争一生的数学家。
顺带也缅怀一下同样孤独一生的罗巴切夫斯基，他曾巡回欧洲演讲，然而无人能回应他殷切的期待。正如高斯日记里所说：“当时在场的各位，我或许是其中唯一听懂罗巴切夫斯基先生在说什么的人。”然而高斯的软弱和怯懦让他没有勇气公开支持这一在他内心已然成熟却被视为异端的理论，这让罗氏进一步陷入冰窖，仿佛这一成果成了他一生的污点。最让我感动的是，尽管孤独落寞，他至死都坚信这一成果的正确性，坚信这是一种独立于欧式几何的几何系统。
相比之下，黎曼的境遇就要好上很多。在人们的思想进一步解放后，年轻的波恩哈德·黎曼（时年28岁）拿着一篇赫然写着平行线可以相交的论文来到歌厅根大学，当即被聘为讲师。（北师大的老教授在这里吐槽说由此可见当时德国大学数学是什么样的水平= =好喜欢萌哒哒老爷爷）这篇论文奠定了黎曼几何的基础。黎曼几何是球面几何，与罗氏几何的鞍面不同，但产生的影响愈发广大。它深刻地影响了拓扑学，在爱因斯坦以它为基础发明广义相对论后更是被世人奉若珍宝。而罗巴切夫斯基也终于得以正名。


好了，科学史就说到这里吧。仰望满天的星空，缅怀逝去的先辈，让我们努力为人类科学进步做出更大的努力。
——千里之行，始于足下。

版权声明：转载请注明出处 [ametake版权所有]http://blog.csdn.net/ametake欢迎来看 

悼念512汶川大地震遇难同胞——珍惜现在，感恩生活
Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 19552    Accepted Submission(s): 8274


Problem Description
急！灾区的食物依然短缺！
为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。
请问：你用有限的资金最多能采购多少公斤粮食呢？

后记：
人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。
月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——
感谢父母，他们给予我们生命，抚养我们成人；
感谢老师，他们授给我们知识，教我们做人
感谢朋友，他们让我们感受到世界的温暖；
感谢对手，他们令我们不断进取、努力。 
同样，我们也要感谢痛苦与艰辛带给我们的财富～




 

Input
输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1<=n<=100, 1<=m<=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1<=p<=20,1<=h<=200,1<=c<=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。
 

Output
对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。
 

Sample Input

1
8 2
2 100 4
4 100 2

 

Sample Output

400

#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
struct stu {
	int val;
	int wight;
}boy[10010];
int nexty[10010];
int main()
{
	int n;
	int a,b;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d%d",&a,&b);
		int e,f,g;
		memset(boy,0,sizeof(boy));	
		memset(nexty,0,sizeof(nexty));
		int k=0;
		for(int i=0;i<b;i++)
		   {
		   	scanf("%d%d%d",&e,&f,&g);
			   	for(int j=0;j<g;j++)//刚开始没有考虑到要这么转化
			   	{
			   		boy[k].wight=f;
			   		boy[k++].val=e;//刚开始写错了错写成g了
				}
		   }
		for(int i=0;i<k;i++)
		{
			for(int j=a;j>=boy[i].val;j--)//刚开始没有考虑等号
			{
			    nexty[j]=max(nexty[j],nexty[j-boy[i].val]+boy[i].wight);
			    
			}
		}
     	printf("%d\n",nexty[a]);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

C语言提高之指针初步
1、指针也是一种数据类型
        指针是一种数据类型，是指它指向的内存空间的数据类型；
        *号表示 操作 指针所指向的内存空间中的值；
        *p相当于通过地址(p变量的值)找到一块内存；然后操作内存；
        *p放在等号的左边赋值（给内存赋值）；
        *p放在等号的右边取值（从内存获取值）；
        不断的给指针变量赋值，就是不断的改变指针变量（和所指向内存空间没有任何关系）；
        指针做函数参数 形参有多级指针的时候, 站在编译器的角度 ,只需要分配4个字节的内存(32bit平台)，当我们使用内存的时候,我们才关心 指针所指向的内存 是一维的还是二维的。
2、指针指向某个变量，就是把某个变量地址赋给指针；
      指针变量  和  它指向的内存块变量  是两个不同的概念；释放了指针所指的内存空间，但是如果指针变量没有重置成NULL，则会出现“野指针”的情况。
                 避免方法：（1）定义指针的时候，初始化成NULL；（2）释放指针所指向的内存空间以后，紧接着把指针重置成NULL。
3、一级指针的典型用法：数组 int buf[10]、字符串 
1).C语言的字符串 以零结尾的字符串
2).在C语言中没有字符串类型， 通过 字符数组 来模拟字符串 
3).字符串的内存分配，堆上、栈上、全局区 (很重要)
4).注意：buf是一个指针，是一个只读的常量，也就是说buf是一个常量指针，不能别修改指向（也就是地址）。——这是必须的，也是显而易见的，为了保护数组的首地址，析构内存的时候，保证buf所指向的内存空间安全释放

p = buf; //buf 数组首元素的地址

	for (i=0; i<strlen(buf); i++)
	{
		p = p +i;//此处不能换成buf，这也是数组首地址和指针的区别
		printf("%c ", *p);
	}5).字符串作函数参数//不要轻易改变形参的值, 要引入一个辅助的指针变量. 把形参给接过来
int copy_str26_good(char *from , char *to)
{
	//*(0) = 'a';
	char *tmpfrom = from;
	char *tmpto = to;
	if ( from == NULL || to == NULL)
	{
		return -1;
	}

	while ( *tmpto++ = *tmpfrom++ ) ; //tmpfrom在不断变化！    //空语句

	printf("from:%s \n", from);  //打印成功！from未变化！
		
}
int main()
{
	int ret = 0;
	char *from = "abcd";
	char buf2[100]; 

	copy_str26_good(from, buf2);
	printf("copy_str25_err end\n");
	return 0;
}
       应用场景：char *p = "abcdbcd123123cdacbdabcdabcdabcdaabcd"; ，求字符串p中 abcd出现的次数，1).请自定义函数接口,完成上述需求 ，2).自定义的业务函数 和 main函数分开。
int count(char *source, char *sub)
{
	int count = 0;
	char *tmp_source = source;//不轻易改变形参的值
	char *tmp_sub = sub;
	for (; *tmp_source != '\0'; tmp_source++)//循环检测原字符串
	{
		char *temp = tmp_source;//记录原字符串匹配位置，以便复位
		while (*tmp_source != '\0')//开始一趟匹配
		{
			if (*tmp_source != *tmp_sub)
			{
				break;
			}
			tmp_source++;
			tmp_sub++;
			if (*tmp_sub == '\0')
				count++;
		}
		tmp_sub = sub;//复位
		tmp_source = temp;//复位
	}

	return count;
}

void main()
{
	char *p = "abcd111122abcd3333322abcd3333322qqq";
	char buf[] = "abcd";
	int sub_count = count(p, sub_str);
	printf("sub_str(abcd) count: %d\n", sub_count);
}

void get_count(char *source, char *sub, int *count)
{
	if (source == NULL || sub == NULL || count == NULL)//增强程序的健壮性
	{
		printf("func getCount() err (source==NULL || sub==NULL || count==NULL) \n");
		return -1;
	}
	char *tmp_sub = sub;
	for (; *source != '\0'; source++)//循环检测原字符串
	{
		char *temp = source;//记录原字符串匹配位置，以便复位
		while (*source != '\0')//开始一趟匹配
		{
			if (*source != *tmp_sub)
			{
				break;
			}
			source++;   
			tmp_sub++;
			if (*tmp_sub == '\0')
				(*count)++;//注意：不是*count++！++的优先级高于*。否则将会是地址移动！这里应该是对*count
		}
		tmp_sub = sub;//复位
		source = temp;//复位      
		//这里有的程序优化为：当查找成功时，复位到+strlen(sub)。我觉得不合适！试想一下在“aaaa”中查找“aa”!
	}
	printf("sub_str(abcd) count: %d\n", *count);
}

void main()
{
	char *p = "abcd111122abcd3333322abcd3333322qqq";
	char buf[] = "abcd";
	int num = 0;
	get_count(p, buf, &num);
}
4、二级指针：指向指针变量的指针，存放地址值的地址。一级指针所关联的是其值（一个地址）名下空间里的数据，这个数据可以是任意类型并做任意用途，但二级指针所关联的数据只有一个类型一个用途，就是地址。一级指针的值虽然是地址，但这个地址做为一个值也需要空间来存放，是空间就具有地址 ，这就是存放地址这一值的空间所具有的地址，二级指针就是为了获取这个地址。


     例如：如果A、B、C都是变量，即C是普通变量，B是一级指针变量，其中存放着C的地址，A是二级指针变量，其中存放着B的地址，则这3个变量分别在内存中占据各自的存储单元，它们之间的相互关系下图所示，相互之间的前后位置关系并不重要．此时，B是一级指针变量，B的值(即C的地址)是一级指针数据；A是二级指针变量，A的值(即B的地址)是二级指针数据．



       关于为什么要使用二级指针？参见：http://blog.csdn.net/hmsiwtv/article/details/7413168     \      http://blog.csdn.net/anna39/article/details/6769177    \      http://blog.csdn.net/mhjcumt/article/details/7351032
对上述参见资料的一些分析：
谨记：指针存放的是某变量的地址，但是同时指针变量又有存放自己的地址。
程序是想修改p的地址，所以要把p的地址作为实参扔给形参，所以形参应该是二级指针。
如果形参是一级指针，则在被调用函数中对该指针（形参）的地址修改一万次，对主调函数的实参指针都没有任何作用！
对于多级指针，只需从右向左一级一级分析即可。*号就像一把钥匙，通过后边的地址去操作存放在地址中的内容。
间接赋值：（形参指针级别需要高）
a.用 1级 指针作形参，去间接修改了 0级 指针（实参）的值；
b.用 2级 指针作形参，去间接修改了 1级 指针（实参）的值；
c.用 3级 指针作形参，去间接修改了 2级 指针（实参）的值；
d.用 n级 指针作形参，去间接修改了 n-1级 指针（实参）的值；

对于参见资料2，用函数返回值来传递动态内存，不要用return语句返回指向“栈内存”的指针，要返回一个“常量”指针或者一个“堆内存指针”。（详见上篇内存四区专题）
对于参见资料1，当使用一级指针的被调函数中不断修改pa的指向，在此时形参结合所发生的事：array得到了数组名为str， search得到了a的值， pa得到了p的值（而非p自身的地址）！但实参p并未得到形参pa传回的值（某元素的地址）。可见尽管使用了指针，也并没实现传址，当实参形参都是指针时，它们也仅仅是传值——传了“别人的”地址，没有传回来。正如我们以前所知的，想要在被调函数中修改主调函数中的某值，可以使用（一级）指针做函数参数。
       但是在参见资料1中，我们的需求是在被调函数中修改主调函数中的某值的地址值，所以要使用二级指针——指向指针的指针。这样，我们在传递变量时find2(str, a, &p); 而非find1(str, a, p);，传递的是p的地址，而不是传递指针变量p所保存的地址（这不是p的地址）。 
void getMem(char **p2)
{
	*p2 = 400; //间接赋值  p2是p1的地址
}

void getMem2(char *p2)
{
        //char *p2;放在形参位置和放在函数这儿一样，
	p2 = 800; // 所以在此修改p2对主调函数中的p1没有任何影响
}

void main()
{
	char *p1 = NULL;

	char **p2 = NULL;

	p1 = 0x11;
	p2 = 0x22;

	//直接修改p1的值

	p1 = 0x111;

	//间接修改p1的值
	p2 = &p1; 

	*p2 = 100; //间接赋值  p2是p1的地址

	printf("p1:%d \n", p1);

	//{
	//	*p2 = 200; //间接赋值  p2是p1的地址
	//	printf("p1:%d \n", p1);
	//}

	getMem(&p1);//传递的是p1的地址

	getMem2(p1);//传递的是p1保存的地址

	printf("p1:%d \n", p1);

	system("pause");
	return ;
}应用场景：int  getMem3(char **myp1, int *mylen1,  char **myp2, int *mylen2)
{
	int	ret = 0;
	char	*tmp1, *tmp2;

	tmp1 = (char *)malloc(100);//原来p1指向NULL，现在要让p1指向新分配的堆内存
	strcpy(tmp1, "1132233");
	//间接赋值 
	*mylen1 = strlen(tmp1);  //1级指针的间接赋值
	*myp1 = tmp1; //2级指针的间接赋值

	tmp2 = (char *)malloc(200);//原来p2指向NULL，现在要让p2指向新分配的堆内存
	strcpy(tmp2, "aaaaavbdddddddd");
        //间接赋值
	*mylen2 = strlen(tmp2);  //1级指针的间接赋值
	*myp2 = tmp2; //2级指针的间接赋值


	return ret;
}

int  main()
{
	int	ret = 0;
	char	*p1 = NULL;
	int	len1 = 0;
	char	*p2 = NULL;
	int	len2 = 0; 

	ret = getMem3(&p1, &len1, &p2, &len2);//测试是否调用成功
	if (ret != 0)
	{
		printf("func getMem3() err:%d \n", ret);//如果不成功返回错误码
		return ret;
	}
	printf("p1:%s \n", p1);
	printf("p2:%s \n", p2);
	
	if (p1 != NULL)//释放内存
	{
		free(p1);
		p1 = NULL;
	}
	if (p2 != NULL)
	{
		free(p2);
		p2 = NULL;
	}

	system("pause");
	return ret;
}函数调用时，形参传给实参，用实参取地址，传给形参，在被调用函数里面用*p，来改变实参，把运算结果传出来。——C语言 的精华。

间接赋值成立的三个条件：
条件1  //定义1个变量（实参） //定义1个变量（形参）
条件2  //建立关联：把实参取地址传给形参，实参可能是普遍变量，也有可能是指针变量。
条件3  //*形参去间接地的修改了实参的值。

//1 2 3 这3个条件 写在有一个函数
//12 写在一块，3 单独写在另外一个函数里面  ==>函数调用
//1      23写在一块 ==> C++会有




版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1808 Halloween treats 抽屉原理
虽然题目讲了那么多，最后只是让你找出可以整除c的集合。应该是spj程序有问题，你直接输出零都是对的。 
因为题目中c保证小于n，所以根据抽屉原理，一定存在一个连续的区间，满足题目要求。
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <math.h>
#include <stdlib.h>
#include <time.h>
using namespace std;

int a[100000+5],f[100000+5];
int main()
{
    int i,j,c,n,sum,t,st;
    while(~scanf("%d%d",&c,&n))
    {
        if(c==0&&n==0) break;
        for(i=1;i<=n;i++)
            scanf("%d",&a[i]);
        memset(f,0xff,sizeof(f));
        st=0;
        sum=0;
        for(i=1;i<=n;i++)
        {
            sum+=a[i];
            t=sum%c;
            sum=sum%c;
            if(t==0)
            {
                for(j=1;j<i;j++)
                    printf("%d ",j);
                printf("%d\n",j);
                break;
            }
            else if(f[t]!=-1)
            {
                for(j=f[t]+1;j<i;j++)
                    printf("%d ",j);
                printf("%d\n",j);
                break;
            }
            f[t]=i;
        }
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。http://xiang578.top/

LeetCode（29）Divide Two Integers
题目
Divide two integers without using multiplication, division and mod operator.
If it is overflow, return MAX_INT.
分析
题目要求不用 * / %三种运算符的条件下，求得两个int类型整数的商。
方法一：
很明显的，我们可以用求和累计的方法，求得商，但是该方法测试会出现TLE；参考博客提出解决办法：每次将被除数增加1倍，同时将count也增加一倍，如果超过了被除数，那么用被除数减去当前和再继续本操作，但是我测试结果依然是TLE。所以这道题的目的在于考察逻辑运算。
方法二：
该方法来源于参考博客但是该实现忽略了结果溢出的问题，需要加上结果是否溢出判断。
TLE（方法一）代码
//方法一，翻倍累和  结果是：Time Limit Exceeded
class Solution {
public:
    int divide(int dividend, int divisor) {

        //如果被除数或者除数有一者为0 或者绝对值除数大于被除数则返回0
        if (dividend == 0 || divisor == 0 || abs(divisor) > abs(dividend))
            return 0;

        int sign = ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0)) ? 1 : -1;

        long long Dividend = abs(dividend), Divisor = abs(divisor);

        long long sum = 0;
        int count = 0, ret = 0;

        while (Divisor <= Dividend)
        {
            count = 1;
            sum = Divisor;
            while ((sum + sum) < Dividend)
            {
                sum += sum;
                count += count;
            }
            Dividend -= sum;
            ret += count;
        }

        if (sign == -1)
            return 0 - ret;
        else
            return ret;
    }
};
AC代码
//方法二：位运算
class Solution {
public:
    int divide(int dividend, int divisor) {

        //如果被除数或者除数有一者为0 或者绝对值除数大于被除数则返回0
        if (dividend == 0 || divisor == 0)
            return 0;


        // without using * / mod
        // using add
        auto sign = [=](long long x) {
            return x < 0 ? -1 : 1;
        };

        int d1 = sign(dividend);
        int d2 = sign(divisor);

        long long n1 = abs(static_cast<long long>(dividend));
        long long n2 = abs(static_cast<long long>(divisor));

        long long ans = 0;

        while (n1 >= n2) {
            long long base = n2;
            for (int i = 0; n1 >= base; ++i) {
                n1 -= base;
                base <<= 1;
                ans += 1LL << i;
            }
        }
        //如果转换为int类型，结果溢出,返回INT_MAX ，int类型表示范围[-2147483648 , 2147483648)
        if (ans > INT_MAX && d1 == d2)
            return INT_MAX;

        int res = static_cast<int>(ans);
        if (d1 != d2) 
            return -res;
        else 
            return res;
    }
};
GitHub测试程序源码

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu(3555)——Bomb（不要49）
这道题和不要62那道题有些类似，这道题是不要出现连续的49。
思路大致一样，只是在对f数组进行初始化的时候，我们需要求的是数中不含有49的个数，然后最后利用n+1-cal(n+1)来求出正确答案，这里与我想的有些不同。
还要注意一点，要全部转化为__int64，要不然的话会WA。
#include<stdio.h>
#include<string.h>
#include<set>
#include<map>
#include<stack>
#include<queue>
#include<math.h>
#include<iostream>
#include<algorithm>
using namespace std;
#define maxn 103
typedef __int64 ll;
ll f[maxn][maxn];
ll dig[maxn];
void init(){
	f[0][0]=1;
	for(int i=1;i<=20;i++){
		for(int j=0;j<=9;j++){
			for(int k=0;k<=9;k++){
				if(j==4&&k==9) continue;
				f[i][j]=f[i][j]+f[i-1][k];
			}
		}
	}
}
ll cal(ll x){
	ll tmp=x,t=0;
	while(tmp){
		dig[++t]=tmp%10;
		tmp=tmp/10;
	}
	dig[t+1]=0;
	ll ans=0;
	for(int i=t;i>=1;i--){
		for(int j=0;j<dig[i];j++){
			if(!(dig[i+1]==4&&j==9)) ans+=f[i][j];
		}
		if(dig[i+1]==4&&dig[i]==9) break;
	}
	return ans;
}
int main(){
	ll T,n;
	init();
	while(~scanf("%I64d",&T)){
		while(T--){
			scanf("%I64d",&n);
			ll res=cal(n+1);
			printf("%I64d\n",n+1-res);	
		}
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

几种常见的排序算法
一、几种常见的排序算法性能比较



排序算法
最好时间
平均时间
最坏时间
辅助内存
稳定性
备注



简单选择排序
O(n^2)
O(n^2)
O(n^2)
O(1)
不稳定
n小时较好


直接插入排序
O(n)
O(n^2)
O(n^2)
O(1)
稳定
大部分已有序的较好


冒泡排序
O(n)
O(n^2)
O(n^2)
O(1)
稳定
n小时较好


希尔排序
O(n)
O(nlogn)
O(n^s), s∈(1,2)
O(1)
不稳定
s是所选分组


快速排序
O(nlogn)
O(nlogn)
O(n^2)
O(logn)
不稳定
n大时较好


堆排序
O(nlogn)
O(nlogn)
O(nlogn)
O(1)
不稳定
n大时较好


归并排序
O(nlogn)
O(nlogn)
O(nlogn)
O(n)
稳定
n大时较好


注：稳定——所有相等的数经过排序之后，仍能保持它们在排序之前的相对位置关系。
二、常见算法的实现（java）
1、选择排序（Selection Sort）
　　选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。
public class selectSort {

    public static void selectSort(int[] a){
        int i,j;
        for (i=0;i<a.length;i++){
            for (j=i+1;j<a.length;j++){
                if (a[j]<a[i]){
                    int temp=a[i];
                    a[i]=a[j];
                    a[j]=temp;
                }
            }
        }
    }

    public static void main(String args[]){
        int[] a={5,4,9,8,7,6,0,1,3,-5};
        selectSort(a);
        for(int i=0;i<a.length;i++){
            System.out.print(a[i]+" ");
        }
        System.out.println();
    }
}
２、插入排序（Insertion Sort）
　　插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i]又是排好序的序列。要达到这个目的，我们可以用顺序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤ L[i]，则L[1..i]已排好序，第i遍处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一个位置j(1≤j≤i-1)，使得L[j] ≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过程，共需要(a),(b),(c)三次插入。
public class insertSort {

    public static void insertSort(int[] a){
        if (a!=null){
            for (int i=1;i<a.length;i++){
                int temp=a[i],j=i;
                if (a[j-1]>temp){
                    while(j>=1&&a[j-1]>temp){
                        a[j]=a[j-1];
                        j--;
                    }
                }
                a[j]=temp;
            }
        }
    }

    public static void main(String args[]){
        int[] a={5,4,9,8,7,6,0,1,3,2};
        insertSort(a);
        for(int i=0;i<a.length;i++){
            System.out.print(a[i]+" ");
        }
        System.out.println();
    }
}

３、冒泡排序（Bubble Sort）
　　冒泡排序方法是最简单的排序方法。这种方法的基本思想是，将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。显然，处理一遍之后，“最轻”的元素就浮到了最高位置；处理二遍之后，“次轻”的元素就浮到了次高位置。在作第二遍处理时，由于最高位置上的元素已是“最轻”元素，所以不必检查。一般地，第i遍处理时，不必检查第i高位置以上的元素，因为经过前面i-1遍的处理，它们已正确地排好序。
public class bubbleSort {

    public static void bubbleSort(int[] a){
        for (int i=0;i<a.length;i++){
            for (int j=0;j<a.length-1;j++){
                if (a[j]>a[j+1]){
                    int temp=a[j];
                    a[j]=a[j+1];
                    a[j+1]=temp;
                }
            }
        }
    }
    public static void main(String args[]) {
        int[] a = {5, 4, 9, 8, 7, 6, 0, 1, 3, 2};
        bubbleSort(a);
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
        System.out.println();
    }
}

４、希尔排序（Shell Sort）
　　在直接插入排序算法中，每次插入一个数，使有序序列只增加1个节点，并且对插入下一个数没有提供任何帮助。如果比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。
public class shellSort {

    public static void shellSort(int[] array){
        int len=array.length;
        for(int h=len/2;h>0;h=h/2){//步长为h
            for (int i=h;i<len;i++){
                int temp=array[i];
                int j;
                for (j=i-h;j>=0;j-=h){//相隔h个常量，跳跃式移动，使得排序效率提高
                    if (temp==array[j]){
                        array[j+h]=array[h];
                    }else break;
                }
                array[j+h]=temp;
            }
        }
    }
    public static void main(String args[]){
        int[] a={5,4,9,8,7,6,0,1,3,2};
        shellSort(a);
        for(int i=0;i<a.length;i++){
            System.out.print(a[i]+" ");
        }
        System.out.println();
    }
}
５、快速排序（Ｑuick Sort）
　　快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的数，直到基准点的左右只有一个元素为止。
public class quickSort {

    public static void quickSort(int[] array,int low,int high) {
        if(low < high){
            int privotLoc = partition(array,  low,  high);  //将表一分为二
            quickSort(array,low,privotLoc -1);          //递归对低子表递归排序
            quickSort(array,privotLoc + 1,high);        //递归对高子表递归排序
        }
    }

    public static int partition(int a[], int low, int high) {
        int privotKey = a[low];                             //基准元素
        while(low < high){                                   //从表的两端交替地向中间扫描
            while(low < high  && a[high] >= privotKey)
                --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
            swap(a,low,high);
            while(low < high  && a[low] <= privotKey )
                ++low;
            swap(a,low,high);
        }
        return low;
    }

    public static void swap(int[] a, int i,int j) {
        int tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    public static void main(String args[]){
        int[] a={5,4,9,8,7,6,0,1,3,2};
        quickSort(a,0,a.length-1);
        for(int i=0;i<a.length;i++){
            System.out.print(a[i]+" ");
        }
        System.out.println();
    }
}

６、堆排序（Ｈeap Sort）
　　堆排序是一种树形选择排序，在排序过程中，将A[n]看成是完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。
/**
 * 堆排序
 *
 *      首先使用建立最大堆的算法建立好最大堆，
 *      然后将堆顶元素（最大值）与最后一个值交换，
 *      同时使得堆的长度减小1 ，调用保持最大堆性质的算法调整，
 *      使得堆顶元素成为最大值，此时最后一个元素已被排除在外
 */
public class heapSort {
    private static int heapSize;//元素个数

    private static void maxHeapify( int[] array , int index ){
        int left = 2*index;//左孩子
        int right = 2*index+1;//右孩子
        int largest;
        if( left < heapSize && array[ index ] < array[ left ]){
            largest = left;
        }else{
            largest = index;
        }
        if( right < heapSize && array[ right ] > array[ largest ]){
            largest = right;
        }
        if( largest == index ){
            return ;
        } else {
            int temp = array[ index ];
            array[ index ] = array[ largest ];
            array[ largest ] = temp;
            maxHeapify( array, largest );
        }
    }

    /**
     * 建立最大堆。在数据中，array.length/2+1一直到最后的元素都是叶子元素，
     * 因此从其前一个元素开始，一直到第一个元素，重复调用maxHeapify函数，使其保持最大堆的性质
     * @param array
     */
    private static void buildMaxHeap(int[] array){
        // 找出最小元素,并将其置于array[0]
        int min = array[0];
        for(int i = 1 ; i < array.length ; i++ ){
            if( min > array[i] ){
                min = array[i];
                array[i] = array[0];
                array[0] = min;
            }
        }
        for( int i = array.length / 2 ; i >= 1; i-- ){
            maxHeapify( array , i );
        }
    }

    /**
     * 堆排序:
     */
    public static void heapSort( int[] array ){
        buildMaxHeap( array );
        for(int i = array.length - 1 ; i >= 2 ; i--){
            int temp = array[1];
            array[1] = array[i];
            array[i] = temp;
            heapSize--;
            maxHeapify( array , 1 );
        }
    }

    public static void main(String args[]){
        int[] a={5,4,9,8,7,6,0,1,3,2};
        heapSize = a.length;
        heapSort(a);
        for(int i=0;i<a.length;i++){
            System.out.print(a[i] + " ");
        }
        System.out.println();
    }
}
７、归并排序（Ｍerge Sort）
　　设有两个有序（升序）序列存储在同一数组中相邻的位置上，不妨设为A[l..m]，A[m+1..h]，将它们归并为一个有序数列，并存储在A[l..h]。
public class mergeSort {

    public static void MergeSort(int[] array,int p,int r){
        if (p<r){
            int q=(p+r)/2;
            MergeSort(array,p,q);
            MergeSort(array,q+1,r);
            Merge(array,p,q,r);
        }
    }
    public static void Merge(int[] array,int p,int q,int r){
        int n1=q-p+1;
        int n2=r-q;
        int[] L=new int[n1];
        int[] R=new int[n2];
        for (int i=0;i<n1;i++){
            L[i]=array[p+i];
        }
        for (int i=0;i<n2;i++){
            R[i]=array[q+1+i];
        }
        int i,j,k=p;
        for (i=0,j=0;i<n1&&j<n2;k++){
            if (L[i]<R[j]){
                array[k]=L[i];
                i++;
            }else{
                array[k]=R[j];
                j++;
            }
        }
        if (i<n1){
            for (j=i;j<n1;j++,k++)
                array[k]=L[j];
        }
        if (j<n2){
            for (i=j;i<n2;i++,k++)
                array[k]=R[i];
        }
    }

    public static void main(String args[]) {
        int[] a = {5, 4, 9, 8, 7, 6, 0, 1, 3, 2};
        MergeSort(a,0,a.length-1);
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
        System.out.println();
    }
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

我的第一个java定时器
在开发中，我们经常需要一些周期性的操作，例如每隔几分钟就进行某一项操作。这时候我们就要去设置个定时，
接下来就去开发我的第一个java定时器吧，Java计时器实用程序允许您执行线程或任务在一个预先确定的将来的时间,并根据一组这些任务可以重复频率。
 设计和实现一个计时器,会用到model-control-view(MVC)设计模式。
开始:
首先来构w建一个最简单的java web 项目吧。这里我用的是最myeclipse，好处自然不必多说，谁用谁知道，当然如果
你要用其他IDE也可以。
在myeclipse中创建一个新的web应用程序很简单，点击File-new-WebProject，输入我们的项目名就可以了。
这个时候会系统会生成很多东西，我们找到WebRoot 下面的index.jsp页面，输入
Hello World!
启动我 们的tomcat,好了这个时候我们的第一个web项目就构建完成了;


现在我们已经有了自己的第一个 java web 程序了，可以尝试去写一个java web 计时器了;


表示层(View)

我们通常把web应用程序的表示层称为视图展现层，。 它将包括一个屏幕显示计时器在任何时候的状态,以及一组按钮控制计时器的激活(启动计时器)和失活(停止计时器)。
 您还可以定义定时器的间隔秒重复一个导演的任务。 最后,一个刷新屏幕按钮将更新事件通知显示在屏幕上。


模型层
模型层主要有两个类，MyTimer和Display(其目的是报告的状态计时器,它可以显示).
先看一看他们的结构体系:



Display类有三个方法和构造函数。 在构造函数中Display(),display属性初始化为一个空字符串。 
该方法getDisplay()返回属性的内容display。
 最后,该方法insert(value)接受一个字符串作为参数,
创建了一个换行符,并将其添加到display；



 public void insert(String value) {
        Calendar now = Calendar.getInstance();
        String stamp = now.get(Calendar.HOUR_OF_DAY)+":"+now.get(Calendar.MINUTE)+
                ":"+now.get(Calendar.SECOND)+" - ";      
        display+=stamp+value+"\n<br>";
    }

类MyTimer直接与JSP页面交互。MyTimer可以执行各种操作,包括启动一个计时器(timerStarted()),停止计时器(timerStopped()),并在屏幕上显示事件通知(getDisplay())。
 它包含两个属性:对象display和timer。
当对象myTimer被创建时,构造函数传递一个参数叫什么seconds,它的类型为Integer(该参数定义了定时器的时期,这是转换为毫秒。Timer是一个具体的类,属于Java实用程序包和允许一个线程操作任务,可以在需要时启动在未来某个时间和停止。
 它的scheduleAtFixedRate()方法是用来计划任务重复固定利率执行。 这需要三个参数:任务执行(MyTask),延迟计时器开始前(设置为0),和时间转换为毫秒。 创建并启动一个计时器,就创建一个新的对象myTimer

 public MyTimer(Integer seconds) {
        timer = new Timer();
        long msec = 1000;
        display = new Display();
        
        timer.scheduleAtFixedRate(new MyTask(), 0*msec, 
                seconds.intValue()*msec);
        
        display.insert("Timer is started.");
    }
计时器的任务时间表是定义为MyTask类,此类继承自TimeTask,并扩展了TimerTask——另一个类的Java实用程序包。MyT

ask作为MyTimer的一个私人内部类,允许操作对象display。
 因此,MyTask作用是为了在一个时间段显示的去调用执行
display对象的insert方法.


public class MyTimer {
    private Timer timer;
    private Display display;    
    private String snapshot;
    public MyTimer(Integer timeSecond) {
    }
    private class MyTask extends TimerTask {
        @Override
        public void run() {
            // task to do
            display.insert("New event.");
        }
timerStopped()方法停止计时器,它的实现非常简单。 它调用timer对象的cancel()方法,然后创建一个事件通知,显示在屏幕上的web应用程序。


 public void timerStopped() {
        timer.cancel();
        display.insert("Timer has stopped.");
    }
最后一个方法getSnapshot()将作为一个字符串返回的结果的方法getDisplay()从对象display中提取getDisplay();。
 该方法用于更新web应用程序的屏幕。


 public String getSnapshot() {
        snapshot=display.getDisplay();
        return snapshot;
    }
创建接口引入JSTL


<%@page contentType="text/html" pageEncoding="UTF-8" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>由于，我们的秒数是1-9，所以可以利用JSTL,循环出来一个简易的下拉式列表框，供我们选择


<%
Integer seconds[] = {new Integer(1),new Integer(2),new Integer(3),
                    new Integer(4),new Integer(5),new Integer(6),
                    new Integer(7),new Integer(8),new Integer(9)};
request.setAttribute("seconds", seconds);

Integer second=(Integer) session.getAttribute("second");
if(second==null) {
    session.setAttribute("second", seconds[0]);
}
%></pre><strong></strong><div><strong></strong></div><div><strong>完善视图层</strong></div><div><strong></strong><pre name="code" class="html"><html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>JSP Page</title>
        <style type="text/css">
            #foo { overflow-y: hidden; }
            .bar { float: left; margin:5px 5px 5px 5px; }
            .screen {border:solid 4px;width:500px;height:300px;
                     background-color:beige; padding: 5px 5px 5px 5px;
                     overflow:scroll}
	</style>
    </head>
    <body>
        <h1>Hello World!</h1>
        <div id="foo">
            <div class="bar">
                <form method="post" action="start.action">
                  	  间隔 (秒)
                    <select name="second">
                        <c:forEach items="${seconds}" var="row">
                            <c:if test="${row != second}">
                                <option>${row}</option>
                            </c:if>
                            <c:if test="${row == second}">
                                <option selected="">${row}</option>
                            </c:if>
                        </c:forEach>
                    </select>
                    <input type="submit" value="开始  计时">
                </form>
            </div>
            <div class="bar">
                <form method="post" action="stop.action">
                    <input type="submit" value="停止  计时">
                </form>
            </div>
            <div class="bar">
                <form method="post" action="control/doRefresh.jsp">
                    <input type="submit" value="刷新">
                </form>
            </div>
        </div>
        <c:if test="${mytimer == null}">
            <div class="screen" style="border-color:red">
                ${display}
            </div>
        </c:if>
        <c:if test="${mytimer != null}">
            <div class="screen" style="border-color:green">
                ${display}
            </div>
        </c:if>
    </body>
</html>

配置 <servlet>
    <servlet-name>StratServlet</servlet-name>
    <servlet-class>servlet.StartServlet</servlet-class>
  </servlet>
　<servlet-mapping>
    <servlet-name>StratServlet</servlet-name>
    <url-pattern>/start.action</url-pattern>
  </servlet-mapping>
	
	 <servlet>
    <servlet-name>StopServlet</servlet-name>
    <servlet-class>servlet.StopServlet</servlet-class>
  </servlet>
　<servlet-mapping>
    <servlet-name>StopServlet</servlet-name>
    <url-pattern>/stop.action</url-pattern>
  </servlet-mapping>


控制层

这里控制层，我用了两种不同的方法，一种是使用在JSP页面引入JSTL,进行判断，跳转。还有一种是使用Servlet,进行控制跳转。其实一个JSP也就是一个简易的Servlet,在JSP页面进行流程控制有一个好处，就是不用到Web.xml里面去配置，比较简单，方便。这里我两种方式都采用了。
@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp)
			throws ServletException, IOException {
		try {
			//得到间隔秒数
			Integer second = new Integer(req.getParameter("second"));
			//得到对象
			MyTimer mytimer = (MyTimer) req.getSession()
					.getAttribute("mytimer");
			//判断对象是否存在，如果存在，就表明重复点击了开始按钮，这里先结束一下，当前的线程，再开始新的;
			if (mytimer != null) {
				// stop timer
				mytimer.timerStopped();
			}
			//新对象,新方法，新线程
			mytimer = new MyTimer(second);
			req.getSession().setAttribute("mytimer", mytimer);
			req.getSession().setAttribute("display", mytimer.getSnapshot());
			req.getSession().setAttribute("second", second);
			resp.sendRedirect("\\index.jsp");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
如果我们去JSP页面去控制的话，那么首先先去创建一个文件夹，我这里取名叫control,接着在里面写方法.
<%@page contentType="text/html" pageEncoding="UTF-8" import="data.*" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<%
Integer second= new Integer(request.getParameter("second"));

MyTimer mytimer = (MyTimer) session.getAttribute("mytimer");
if(mytimer!=null) {
    // stop timer
    mytimer.timerStopped();
}
mytimer = new MyTimer(second);
session.setAttribute("mytimer", mytimer);
session.setAttribute("display", mytimer.getSnapshot());
session.setAttribute("second", second);
%>

<c:redirect url="/index.jsp"/>好了到这里一个简易的Java计时器就完成了，接下来看一看运行效果吧;




源代码已上传，想看看的可以去下载http://download.csdn.net/detail/liaodehong/9052595



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu  2824 The Euler function
The Euler function
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4523    Accepted Submission(s): 1882



Problem Description
The Euler function phi is an important kind of function in number theory, (n) represents the amount of the numbers which are smaller than n and coprime to n, and this function has a lot of beautiful characteristics.
 Here comes a very easy question: suppose you are given a, b, try to calculate (a)+ (a+1)+....+ (b)
 

Input
There are several test cases. Each line has two integers a, b (2<a<b<3000000).
 

Output
Output the result of (a)+ (a+1)+....+ (b)
 

Sample Input

3 100

 

Sample Output

3042

 源代码
<span style="font-size:18px;">#include<cstdio>
#define MAX 3000010
int a,b;
long long p[MAX];//long long型才能过MAX太大 

void euler()
{
	for(int i=2;i<=MAX;i++)
	{
		if(!p[i])
		{
			for(int j=i;j<=MAX;j+=i)
			{
				if(!p[j])
				p[j]=j;
				p[j]=p[j]/i*(i-1);
			}
		}
		p[i]+=p[i-1];
	}
}

int main()
{	
	euler();
	while(~scanf("%d%d",&a,&b))
	{
		printf("%lld\n",p[b]-p[a-1]);
	}
	return 0;
}</span>



版权声明：本文为博主原创文章，未经博主允许不得转载。

C# 中动态调用C++动态链接
之前的文章中讲述过从DLL中导出变量，其中包括了静态加载和动态加载。
C#调用C++动态链接库同样分为静态加载和动态加载。
fellen的博客“WPF中使用MFC动态链接库（dll）函数”中讲述的是如何C#静态加载DLL，即需要将C++代码编译生成的Dll放在C#程序的Bin目录下，并在引入函数的位置加入[DllImport(“xxx.dll”)] 。
由于Dll路径的限制，使用的不是很方便，C#中我们经常通过配置动态的调用托管Dll，例如常用的一些设计模式：Abstract Factory， Provider， Strategy模式等等，那么是不是也可以这样动态调用C++动态链接呢？只要您还记得在C++中，通过LoadLibrary, GetProcess, FreeLibrary这几个函数是可以动态调用动态链接的（它们包含在kernel32.dll中），那么问题迎刃而解了。
首先看一下LoadLibrary, GetProcAddress, FreeLibrary这三个函数：
HMODULE  WINAPI   LoadLibrary ( LPCTSTR  lpFileName); 
说明: 
载入指定的动态链接库，并将它映射到当前进程使用的地址空间。一旦载入，即可访问库内保存的资源 
返回值 
lpLibFileName String，指定要载入的动态链接库的名称。采用与CreateProcess函数的lpCommandLine参数指定的同样的搜索顺序 
一旦不需要，用FreeLibrary函数释放DLL
FARPROC  GetProcAddress (HMODULE hModule,  LPCSTR lpProcName); 
说明: 
GetProcAddress函数检索指定的动态链接库(DLL)中的输出库函数地址。 
hModule 
[in] 包含此函数的DLL模块的句柄。LoadLibrary、AfxLoadLibrary 或者GetModuleHandle函数可以返回此句柄。 
lpProcName 
[in] 包含函数名的以NULL结尾的字符串，或者指定函数的序数值。如果此参数是一个序数值，它必须在一个字的底字节，高字节必须为0。 
返回值： 
如果函数调用成功，返回值是DLL中的输出函数地址。 
如果函数调用失败，返回值是NULL。得到进一步的错误信息，调用函数GetLastError。 
GetProcAddress函数被用来检索在DLL中的输出函数地址。 
lpProcName指针指向的函数名，拼写和大小写必须和DLL源代码中的模块定义文件(.DEF)中输出段(EXPORTS)中指定的相同。Win32 API函数的输出名可能不同于你在代码中调用的这些函数名，这个不同被宏隐含在相关的SDK头文件中。如果想得到更多信息，请参考Win32函数原型(Win32 Function Prototypes)。 
lpProcName参数能够识别DLL中的函数，通过指定一个与函数相联系的序数值(在.DEF中的EXPORTS段)。GetProcAddress函数验证那个指定的序数值是否在输出的序数1和最高序数值之间(在.DEF中)。函数用这个序数值作为索引从函数表中读函数地址，假如.DEF 文件不连续地定义函数的序数值，如从1到N(N是输出的函数序数值)，错误将会发生，GetProcAddress将会返回一个错误的、非空的地址，虽然指定的序数没有对应的函数。 
为了防止函数不存在，函数应该通过名字指定而不是序数值。
BOOL WINAPI  FreeLibrary  ( In HMODULE hModule); 
说明： 
释放指定的动态链接库，它们早先是用LoadLibrary API函数装载的。
使用分两步走，首先是引入以上三个函数，并进行封装。新建一个类名为CSharpMethod.cs.需要注意的是必须引入命名空间using System.Runtime.InteropServices。
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace InteropDemo
{
    public static class CSharpMethod
    {
        [DllImport("kernel32.dll", EntryPoint = "LoadLibrary")]
        public static extern int LoadLibrary(
            [MarshalAs(UnmanagedType.LPStr)] string lpLibFileName);

        [DllImport("kernel32.dll", EntryPoint = "GetProcAddress")]
        public static extern IntPtr GetProcAddress(int hModule,
            [MarshalAs(UnmanagedType.LPStr)] string lpProcName);

        [DllImport("kernel32.dll", EntryPoint = "FreeLibrary")]
        public static extern bool FreeLibrary(int hModule);
    }
}
接下来第二步就是具体的使用了： 
使用NativeMethod类动态读取C++Dll，获得函数指针，并且将指针封装成C#中的委托。原因很简单，C#中已经不能使用指针了，如下 
int hModule = CSharpMethod.LoadLibrary(@“c:”CppDemo.dll”); 
IntPtr intPtr = CSharpMethod.GetProcAddress(hModule, “Add”);
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace InteropDemo
{
    class Program
    {
        static void Main(string[] args)
        {
            //1. 动态加载C++ Dll
            int hModule = CSharpMethod.LoadLibrary(@"c:\CppDemo.dll");
            if (hModule == 0) return;

            //2. 读取函数指针
            IntPtr intPtr = CSharpMethod.GetProcAddress(hModule, "Add");

            //3. 将函数指针封装成委托
            Add addFunction = (Add)Marshal.GetDelegateForFunctionPointer(intPtr, typeof(Add));

            //4. 测试
            Console.WriteLine(addFunction(1, 2));
            Console.Read();
        }
        delegate int Add(int a, int b);
    }
}
上诉代码中使用了Marshal.GetDelegateForFunctionPointer 方法 ，下面做简单介绍。 
功能：将非托管函数指针转换为委托。 
命名空间：   System.Runtime.InteropServices 
程序集：   mscorlib（在 mscorlib.dll 中）  
语法：public static Delegate GetDelegateForFunctionPointer( IntPtr ptr, Type t) 
参数：ptr为要转换的非托管函数指针；t为要返回的委托的类型。 
返回值：类型为System.Delegate 委托实例，可强制转换为适当的委托类型。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 2841-Visible Trees(容斥)
题目地址：HDU 2841 
题意：给出一个m*n的矩阵，从（1,1）开始，一个人站在（0,0）位置，问人可以看到矩阵里的几棵树，要求两棵树和人在同一直线上的时候只能看到一棵。 
思路：对于一个点（x,y）只要x与y存在最大公约数g,则可以知道在(x/g,y/g)有一棵树挡起了点(x,y)，所以(x,y)是看不到的，因此我们要判断一个点是否能看到，就看它的(x,y)是否存在最大公约数不为1的数，若不存在则可以看到，相反则看不到。而满足最大公约数为1的数就是x 和y 互质，所以我们只要找到矩阵内互质的数之和即可,我们可以固定m,然后从[1,m]找与nn(,nn>=1&&nn<=n)互质的数的和。
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <bitset>
using namespace std;
typedef __int64 LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
using namespace std;
const int Maxn=1e5+10;
LL prime[Maxn];
LL sprime[Maxn];
bitset<Maxn>pri;
LL k,cnt;
void is_prime()
{
    pri.set();
    for(LL i=2; i<Maxn; i++) {
        if(pri[i]) {
            prime[k++]=i;
            for(LL j=i+i; j<Maxn; j+=i)
                pri[j]=0;
        }
    }
}
void Divide(LL n)
{
    cnt=0;
    LL t=(LL)sqrt(1.0*n);
    for(LL i=0; prime[i]<=t; i++) {
        if(n%prime[i]==0) {
            sprime[cnt++]=prime[i];
            while(n%prime[i]==0)
                n/=prime[i];
        }
    }
    if(n>1)
        sprime[cnt++]=n;
}

LL Ex(LL n)
{
    LL ans=0;
    LL tmp,flag;
    LL i,j;
    for(i=1;i<(LL)(1<<cnt);i++)
    {
        tmp=1;
        flag=0;
        for(j=0;j<cnt;j++)
            if(i&((LL)(1<<j))){
                flag++;
                tmp*=sprime[j];
            }
        if(flag&1)
            ans+=n/tmp;
        else
            ans-=n/tmp;
    }
    return ans;
}
int main()
{
    int T;
    LL m,n;
    LL res;
    is_prime();
    scanf("%d",&T);
        while(T--) {
          scanf("%lld %lld",&m,&n);
          res=0;
          for(LL i=1;i<=n;i++){
          Divide(i);
          res+=(m-Ex(m));
          }
          printf("%lld\n",res);
        }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Ancient Printer


Problem Description
The contest is beginning! While preparing the contest, iSea wanted to print the teams' names separately on a single paper.
Unfortunately, what iSea could find was only an ancient printer: so ancient that you can't believe it, it only had three kinds of operations:

● 'a'-'z': twenty-six letters you can type
● 'Del': delete the last letter if it exists
● 'Print': print the word you have typed in the printer

The printer was empty in the beginning, iSea must use the three operations to print all the teams' name, not necessarily in the order in the input. Each time, he can type letters at the end of printer, or delete the last letter, or print the current word. After
 printing, the letters are stilling in the printer, you may delete some letters to print the next one, but you needn't delete the last word's letters.
iSea wanted to minimize the total number of operations, help him, please.
 

Input
There are several test cases in the input.

Each test case begin with one integer N (1 ≤ N ≤ 10000), indicating the number of team names.
Then N strings follow, each string only contains lowercases, not empty, and its length is no more than 50.

The input terminates by end of file marker.

 

Output
For each test case, output one integer, indicating minimum number of operations.
 

Sample Input

2
freeradiant
freeopen

 

Sample Output
21


题解：要想得到最少就要操作最少，所以对于有公共前缀的字符串，前缀只打印一次。首先我们把所有字符串用字典树保存。此时这棵树的每一个节点都要打印，除了根（不包含字母），现在所有节点都要打印和删除，但是最后一个字符串不删除，该字符串肯定是最长的了。所以公式=res=2 * （n (节点数)- 1） + m（打印次数） - maxlen(最长字符串)。
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

struct Node
{
	Node* next[26];
	Node()
	{
		for(int i = 0;i < 26;i++)
		{
			next[i] = NULL;
		}
	}
};

int res = 0;
Node* root;

int max(int a,int b)
{
	return a > b ? a : b;
}

void insert(char* s)
{
	Node* p = root;
	int len = strlen(s);
	for(int i = 0; i < len;i++)
	{
		int x = s[i] - 'a';
		if(p->next[x] == NULL)
		{
			Node* q = new Node();
			p->next[x] = q;
			res++;
		}
		p = p->next[x];
	}
}

void del(Node*& root)
{
	for(int i = 0; i < 26;i++)
	{
		if(root->next[i] != NULL)
		{
			del(root->next[i]);
		}
	}
	
	delete root;
}

int main()
{
	int n;
	while(scanf("%d",&n) != EOF)
	{
		root = new Node();
		char s[100];
		res = 0;
		int maxlen = 0;
		for(int i = 0;i < n;i++)
		{
			scanf("%s",s);
			maxlen = max(maxlen,strlen(s));
			insert(s);
		}
		res = 2 * res + n - maxlen;
		printf("%d\n",res);
		
		del(root);
	}
	
	return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 2819 Swap (行列匹配+输出解)
题意：能否使对角线上全是1 ，这个简单直接按行列匹配，难在路径的输出，我们知道X,Y左右匹配完了之后，不一定是1–1,2–2,3–3……这样的匹配。可能是1–3，2–1，3–2，我们要把他们交换成前一种的匹配形式，也就是路径的答案，再有矩阵的一些关于秩的性质，行变换和列变换是等价的。

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<set>
#include<map>
#include<string>
#include<cstring>
#include<stack>
#include<queue>
#include<vector>
#include<cstdlib>
#define lson (rt<<1),L,M
#define rson (rt<<1|1),M+1,R
#define M ((L+R)>>1)
#define cl(a,b) memset(a,b,sizeof(a));
#define LL long long
#define P pair<int,int>
#define X first
#define Y second
#define pb push_back
#define fread(zcc)  freopen(zcc,"r",stdin)
#define fwrite(zcc) freopen(zcc,"w",stdout)
using namespace std;
const int maxn=105;
const int inf=999999;

vector<int> G[maxn];
int matching[maxn];
bool vis[maxn];
int Nx;
int dfs(int u){
    int N=G[u].size();
    for(int i=0;i<N;i++){
        int v=G[u][i];
        if(vis[v])continue;
        vis[v]=true;
        if(matching[v]==-1||dfs(matching[v])){
            matching[v]=u;
            return 1;
        }
    }
    return 0;
}
int hungar(){
    int ans=0;
    cl(matching,-1);
    for(int i=0;i<Nx;i++){
        cl(vis,false);
        ans+=dfs(i);
    }
    return ans;
}
int Left[maxn],Right[maxn];
int main(){

    int n;
    while(~scanf("%d",&n)){
        for(int i=0;i<maxn;i++)G[i].clear();
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                int x;
                scanf("%d",&x);
                if(x)G[i].pb(j);
            }
        }
        Nx=n;
        int ans=hungar();
        if(ans<n){
            puts("-1");
            continue;
        }

        int num=0;
        for(int i=0;i<n;i++){//查找路径
            int j;
            for(j=i;j<n;j++)if(matching[j]==i)break;
            if(i!=j){
                Left[num]=i;Right[num++]=j;
                swap(matching[i],matching[j]);
            }
        }
        printf("%d\n",num);
        for(int i=0;i<num;i++){
            printf("C %d %d\n",Left[i]+1,Right[i]+1);
        }
    }
    return 0;
}






            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[C++11 并发编程] 10 - 对极少修改的数据进行保护
假设有一个用于进行域名解析的DNS缓存数据，在大多数情况下，DNS数据很少会改变。当用户访问新的网站时，新的DNS信息才会被自动添加到这个转换表之中。虽然对这个数据的修改很少发生，但是在多个线程读取数据时，有线程要修改数据，仍然会导致读取线程读到错误的数据。我们需要使用某种方式来对读写操作进行保护。
使用前面几节用到的std::mutex可以达到保护数据完整性的效果，但是效率太低。因为大多数线程都是读取数据而不是修改数据，使用mutex，就会导致读取数据操作被认为的串行化，而降低多线程程序的执行效率。“读-写锁”则比较适合用在这里，读操作可以同时进行，而在进行写操作时，其它的读操作会被挂起。
C++标准库不支持这样的读写锁，这里用Boost库中的boost::shared_mutex来作为例子。与使用std::mutex的方法类似，我们可以使用std::lock_guard<boost::shared_mutex>和std::unique_lock<boost::shared_mutex>来进行枷锁操作，以保证操作时互斥的。对于只是读取而不修改数据的线程，则使用boost::shared_lock<boost::shared_mutex>来对数据进行共享访问。
#include <map>
#include <string>
#include <mutex>
#include <boost/thread/shared_mutex.hpp>

class dns_entry
{};

class dns_cache
{
    std::map<std::string,dns_entry> entries;
    boost::shared_mutex entry_mutex;
public:
    dns_entry find_entry(std::string const& domain)
    {
		// 只读操作，使用boost::shared_lock<>来保护数据
		// 多个线程可以同时调用find_entry()
        boost::shared_lock<boost::shared_mutex> lk(entry_mutex);
        std::map<std::string,dns_entry>::const_iterator const it=
            entries.find(domain);
        return (it==entries.end())?dns_entry():it->second;
    }
    void update_or_add_entry(std::string const& domain,
                             dns_entry const& dns_details)
    {
		// 更新操作，使用std::lock_guard<>来进行互斥保护
		// 只有一个线程可以进行更新操作，读取操作也会被block
        std::lock_guard<boost::shared_mutex> lk(entry_mutex);
        entries[domain]=dns_details;
    }
};

int main()
{}

关于递归的加锁问题，如果在同一个线程的上下文对std::mutex进行多次加锁操作，其结果是不确定的。如果真的需要对一个mutex进行多次加锁操作，可以使用C++标准库提供的std::recursive_mutex。在同一个线程上下文中，可以对这种mutex进行多次加锁操作，加锁操作执行了多少次，解锁操作就需要做多少次，否则其它线程无法获取这个锁。使用std::lock_guard<std::recursive_mutex>和std::unique_lock<std:;recursive_mutex>可以帮助你解决这个问题。
实际上，我们并不建议使用递归锁。如果你发现你的代码中需要这种锁，最好先看看这样设计是否正确。因为mutex使用来进行进程间互斥的，同一个线程不需要对已经获得的锁再次进行加锁操作。

版权声明：本文为博主原创文章，未经博主允许不得转载。

yii2 表单使用方法
Activeform
文本框:textInput();
密码框:passwordInput();
单选框:radio(),radioList();
复选框:checkbox(),checkboxList();
下拉框:dropDownList();
隐藏域：hiddenInput();
文本域：textarea(['rows'=>3]);
文件上传:fileInput();
提交按钮:submitButton();
重置按钮:resetButtun();





<?php
$form = ActiveForm::begin([
    'action' => ['test/getpost'],
    'method'=>'post',
    ]); ?>
 
<? echo $form->field($model, 'username')->textInput(['maxlength' => 20]) ?>
<? echo $form->field($model, 'password')->passwordInput(['maxlength' => 20]) ?>
<? echo $form->field($model, 'sex')->radioList(['1'=>'男','0'=>'女']) ?>
<? echo $form->field($model, 'edu')->dropDownList(['1'=>'大学','2'=>'高中','3'=>'初中'],
                                              ['prompt'=>'请选择','style'=>'width:120px']) ?>
<? echo $form->field($model, 'file')->fileInput() ?>
<? echo $form->field($model, 'hobby')->checkboxList(['0'=>'篮球','1'=>'足球','2'=>'羽毛球','3'=>'乒乓球']) ?>
<? echo $form->field($model, 'info')->textarea(['rows'=>3]) ?>
 
<? echo $form->field($model, 'userid')->hiddenInput(['value'=>3]) ?>
 
<? echo Html::submitButton('提交', ['class'=>'btn btn-primary','name' =>'submit-button']) ?>   
<? echo Html::resetButton('重置', ['class'=>'btn btn-primary','name' =>'submit-button']) ?>
<?php ActiveForm::end(); ?>



版权声明：本文为博主原创文章，未经博主允许不得转载。

python 设置linux环境变量
在linux上设置临时环境变量：
export PGPASSWORD = 'postgres'
若用python实现，错误的方法：
os.system("export PGPASSWORD='postgres'")
正确的方法：
os.environ['PGPASSWORD'] = 'postgres'

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

poj1979  DFS

Description
There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can't move on red tiles, he can
 move only on black tiles. 

Write a program to count the number of black tiles which he can reach by repeating the moves described above.


Input
The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.


There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.


'.' - a black tile 
'#' - a red tile 
'@' - a man on a black tile(appears exactly once in a data set) 
The end of the input is indicated by a line consisting of two zeros. 

Output
For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).

Sample Input
6 9
....#.
.....#
......
......
......
......
......
#@...#
.#..#.
11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........
11 6
..#..#..#..
..#..#..#..
..#..#..###
..#..#..#@.
..#..#..#..
..#..#..#..
7 7
..#.#..
..#.#..
###.###
...@...
###.###
..#.#..
..#.#..
0 0
Sample Output
45
59
6
13

Source
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<map>
#include<algorithm>
#include<set>
#define INF 0x3f3f3f3f

using namespace std;

int n,m;
char a[300][300];
int vis[300][300];
int lx,ly;
int dx[]= {-1,1,0,0};
int dy[]= {0,0,-1,1};
int num=0;
int dp[300][300];
int panduan(int x,int y)
{
    if(x>=0&&x<n&&y>=0&&y<m)
        return 1;
    return 0;
}
int DFS(int x,int y)
{
    if(!panduan(x,y)||a[x][y]=='#')
        return 0;
    if(vis[x][y]==0)
    {
        vis[x][y]=1;
        for(int i=0; i<4; i++)
        {
            int fx=dx[i]+x;
            int fy=dy[i]+y;
            if(panduan(fx,fy)&&vis[fx][fy]==0&&a[fx][fy]=='.')
            {
                DFS(fx,fy);
                num++;
            }
        }
        //vis[x][y]=0;  //走过的点就不用再走了
    }
    return 1;
}
int main()
{
    while(~scanf("%d%d",&m,&n))
    {
        if(!m&&!n)
            break;
        int flag=1;
        memset(vis,0,sizeof(vis));
        for(int i=0; i<n; i++)
        {
            scanf("%s",a[i]);
            if(flag)
            {
                for(int j=0; j<m; j++)
                {
                    if(a[i][j]=='@')
                    {
                        flag=0;<span id="transmark"></span>  lx=i;ly=j;
                        break;
                    }
                }
            }
        }
        num=0;
        DFS(lx,ly);
        printf("%d\n",num+1);
    }
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

浅析C#中的Func<>委托
Func<TResult>委托
封装一个不具有参数但是却返回TResult参数指定的类型值的方法。
语法：
public delegate TResult Func<out TResult>()











Func<T, TResult>委托





封装一个具有一个参数并返回 TResult 参数指定的类型值的方法。 




语法






public delegate TResult Func<in
 T, out TResult>(



      T arg

)




Func<T1, T2, TResult>委托
封装一个具有两个参数并返回 TResult 参数指定的类型值的方法。  语法
public delegate TResult Func<in T1, in T2,out TResult>(      T1 arg1,
      T2 arg2)





若要引用不具有参数但却返回 void 的方法（或者在 Visual Basic 中，被声明为 Sub 而不是被声明为 Function 的方法），请改用 Action 委托。




版权声明：本文为博主原创文章，未经博主允许不得转载。

从零开始学Java之五种内部类将线程隐藏类中

1.使用普通内部类继承Thread类
<code class="hljs java has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-class" style="box-sizing: border-box;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">ThreadTestOne</span> {</span>

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> countDown = <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">5</span>;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Inner inner;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-class" style="box-sizing: border-box;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">Inner</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">extends</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">Thread</span>{</span>

        Inner(String name){
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">super</span>(name);
            start();
        }

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>(){
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">while</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">true</span>){
                System.out.println(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>);
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span>(--countDown == <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>)
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span>;
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>{
                    sleep(<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">10</span>);
                }<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span>(InterruptedException e){
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throw</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> RuntimeException(e);
                }
            }
        }

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> String <span class="hljs-title" style="box-sizing: border-box;">toString</span>(){
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"#"</span>+getName()+<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">":"</span>+countDown;
        }
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">ThreadTestOne</span>(String name){
        inner = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Inner(name);
    }

}</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li><li style="box-sizing: border-box; padding: 0px 5px;">23</li><li style="box-sizing: border-box; padding: 0px 5px;">24</li><li style="box-sizing: border-box; padding: 0px 5px;">25</li><li style="box-sizing: border-box; padding: 0px 5px;">26</li><li style="box-sizing: border-box; padding: 0px 5px;">27</li><li style="box-sizing: border-box; padding: 0px 5px;">28</li><li style="box-sizing: border-box; padding: 0px 5px;">29</li><li style="box-sizing: border-box; padding: 0px 5px;">30</li><li style="box-sizing: border-box; padding: 0px 5px;">31</li><li style="box-sizing: border-box; padding: 0px 5px;">32</li><li style="box-sizing: border-box; padding: 0px 5px;">33</li><li style="box-sizing: border-box; padding: 0px 5px;">34</li></ul>

2.使用匿名内部类构造Thread类，重写run（）方法
<code class="hljs cs has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> ThreadTestTwo {

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> countDown = <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">5</span>;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Thread t;

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">ThreadTestTwo</span>(String name){
        t = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Thread(name){
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>(){
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">while</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">true</span>){
                    System.<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">out</span>.println(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>);
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span>(--countDown == <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>)
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span>;
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>{
                        sleep(<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">10</span>);
                    }<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span>(InterruptedException e){
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throw</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> RuntimeException(e);
                    }
                }
            }

            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> String <span class="hljs-title" style="box-sizing: border-box;">toString</span>(){
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"#"</span>+getName()+<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">":"</span>+countDown;
            }
        };
        t.start();
    }
}
</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li><li style="box-sizing: border-box; padding: 0px 5px;">23</li><li style="box-sizing: border-box; padding: 0px 5px;">24</li><li style="box-sizing: border-box; padding: 0px 5px;">25</li><li style="box-sizing: border-box; padding: 0px 5px;">26</li><li style="box-sizing: border-box; padding: 0px 5px;">27</li><li style="box-sizing: border-box; padding: 0px 5px;">28</li></ul>

3.使用普通内部类实现Runnable类
<code class="hljs java has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-class" style="box-sizing: border-box;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">RunnableTestOne</span> {</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> countDown = <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">5</span>;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Inner inner;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-class" style="box-sizing: border-box;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">Inner</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">implements</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">Runnable</span>{</span>
        Thread t;
        Inner(String name){
            t = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Thread(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>,name);
            t.start();
        }

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>(){
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">while</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">true</span>){
                System.out.println(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>);
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span>(--countDown == <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>)
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span>;
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>{
                    Thread.sleep(<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">10</span>);
                }<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span>(InterruptedException e){
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throw</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> RuntimeException(e);
                }
            }
        }

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> String <span class="hljs-title" style="box-sizing: border-box;">toString</span>(){
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"#"</span>+Thread.currentThread().getName()+<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">":"</span>+countDown;
        }
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">RunnableTestOne</span>(String name){
        inner = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Inner(name);
    }
}
</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li><li style="box-sizing: border-box; padding: 0px 5px;">23</li><li style="box-sizing: border-box; padding: 0px 5px;">24</li><li style="box-sizing: border-box; padding: 0px 5px;">25</li><li style="box-sizing: border-box; padding: 0px 5px;">26</li><li style="box-sizing: border-box; padding: 0px 5px;">27</li><li style="box-sizing: border-box; padding: 0px 5px;">28</li><li style="box-sizing: border-box; padding: 0px 5px;">29</li><li style="box-sizing: border-box; padding: 0px 5px;">30</li><li style="box-sizing: border-box; padding: 0px 5px;">31</li><li style="box-sizing: border-box; padding: 0px 5px;">32</li><li style="box-sizing: border-box; padding: 0px 5px;">33</li></ul>

4.使用匿名内部类构造Thread类，参数1构造一个Runnable对象，参数2指明线程名称
<code class="hljs cs has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> RunnableTestTwo {

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> countDown = <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">5</span>;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Thread t;

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">RunnableTestTwo</span>(String name){
        t = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Thread(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Runnable(){

            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>(){
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">while</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">true</span>){
                    System.<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">out</span>.println(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>);
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span>(--countDown == <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>)
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span>;
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>{
                        Thread.sleep(<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">10</span>);
                    }<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span>(InterruptedException e){
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throw</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> RuntimeException(e);
                    }
                }
            }

            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> String <span class="hljs-title" style="box-sizing: border-box;">toString</span>(){
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"#"</span>+Thread.currentThread().getName()+<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">":"</span>+countDown;
            }
        },name);
        t.start();
    }
}
</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li><li style="box-sizing: border-box; padding: 0px 5px;">23</li><li style="box-sizing: border-box; padding: 0px 5px;">24</li><li style="box-sizing: border-box; padding: 0px 5px;">25</li><li style="box-sizing: border-box; padding: 0px 5px;">26</li><li style="box-sizing: border-box; padding: 0px 5px;">27</li><li style="box-sizing: border-box; padding: 0px 5px;">28</li><li style="box-sizing: border-box; padding: 0px 5px;">29</li></ul>

5.使用局部内部类，即在方法内部构造Thread类，重写run（）方法
<code class="hljs cs has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> ThreadMethod {

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> countDown = <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">5</span>;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Thread t;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> String name;

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">ThreadMethod</span>(String name){
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.name = name;
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">runThread</span>(){
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span>(t == <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>){
            t = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Thread(name){

                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>(){

                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">while</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">true</span>){
                        System.<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">out</span>.println(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>);
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span>(--countDown == <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>)
                            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span>;
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>{
                            sleep(<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">10</span>);
                        }<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span>(InterruptedException e){
                            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throw</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> RuntimeException(e);
                        }
                    }
                }

                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> String <span class="hljs-title" style="box-sizing: border-box;">toString</span>(){
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"#"</span>+getName()+<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">":"</span>+countDown;
                }
            };
            t.start();
        }
    }
}</code>

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 4268 Alice and Bob（贪心+STL）
该题一开始我用multiset写了一发，写的比较裸，TLE了 。 后来队友想到了一个比较好的方法 ：将两个结构体排序之后，从大到小枚举Alice的h，对于每个h，将Bob中满足h小于当前h的牌的w加进multiset，然后用二分函数查找一下大于等于当前w的第一个数，当前迭代器的上一个指针就是小于当前w的最大w，找到就删除。那么也就是我们用了这样的贪心策略：对于Alice的每一张牌，要覆盖一张Bob的尽可能h和w接近它的牌  。  为什么这样的贪心策略是正确的呢 ？ 假如不这样，那么当前牌会覆盖一张w更小的牌，假如之后的牌中有w比当前牌小，那么这样是不划算的，
 如果有牌的w比当前牌大，那么显然也不可能更优 。 
细节参见代码：
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<list>
#include<cmath>
#include<set>
#include<queue>
using namespace std;
typedef long long ll;
const long long maxn = 100000+5;
int T,n,m;
struct node{
    int h,w;
    bool operator < (const node& rhs) const {
        return h < rhs.h || (h == rhs.h && w < rhs.w);
    }
}a[maxn],b[maxn];
multiset<int> g;
int main() {
    scanf("%d",&T);
    while(T--){
        g.clear();
        scanf("%d",&n);
        for(int i=0;i<n;i++) scanf("%d%d",&a[i].h,&a[i].w);
        for(int i=0;i<n;i++) scanf("%d%d",&b[i].h,&b[i].w);
        sort(a,a+n);
        sort(b,b+n);
        int cur = 0,cnt=0;
        for(int i=0;i<n;i++){
            while(cur<n&&b[cur].h<=a[i].h) g.insert(b[cur++].w);
            if(g.size()==0) continue;
            multiset<int> ::iterator it = g.lower_bound(a[i].w);
            if(it!=g.begin()) it--;
            if(*it<=a[i].w) g.erase(it),cnt++;
        }
        printf("%d\n",cnt);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

剑指offer面试题27-二叉搜索树转双向链表
题目：
/**
* 输入一颗二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br/>
* 要求不能创建任何新的节点，只能调整树中节点指针的指向。<br/>
* 
* */



然后基本要实现的功能就是这样子的：




怎么实现呢？
看着像递归，就拿根节点来看：
我要做两件事情：
1.拿到左边树的最大的，让root.left=max，max.right=root
2.拿到右边树的最小的，让root.right=min,min.left=root


所以就需要2个函数，min和max，分别处理最大和最小：
看代码：
package com.aii.algorithm;

public class ConvertBinaryTreeToLinkedList {

	/**
	 * 输入一颗二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br/>
	 * 要求不能创建任何新的节点，只能调整树中节点指针的指向。<br/>
	 * 
	 * */
	public BinaryTreeNode convert(BinaryTreeNode root) {
		// 肯定是中序遍历

		if (root == null) {
			return null;
		}
		// 获取左节点的最大值，并且
		// 1.把最大值赋值给root的left
		// 2.把root赋值给最大值的right
		getMax(root, root.left);

		// 获取右节点的最小值，并且
		// 1.把最小值赋值给root的right
		// 2.把root赋值给最小值的left
		getMin(root, root.right);

		// 最后得到链表的头结点，返回
		BinaryTreeNode tmp = root;
		while (tmp.left != null) {
			tmp = tmp.left;
		}

		return tmp;
	}

	/**
	 * 处理左节点
	 * */
	private void getMax(BinaryTreeNode root, BinaryTreeNode left) {
		if (left == null) {
			return;
		}
		// 也做同样的处理
		getMax(left, left.left);
		getMin(left, left.right);

		// 找到最大的那个值
		BinaryTreeNode tmp = left;
		while (tmp.right != null) {
			tmp = tmp.right;
		}
		// 然后分配2个指针
		tmp.right = root;
		root.left = tmp;
	}

	/**
	 * 处理右节点
	 * */
	private void getMin(BinaryTreeNode root, BinaryTreeNode right) {
		if (right == null) {
			return;
		}

		getMax(right, right.left);
		getMin(right, right.right);

		// 找到最小的那个值，然后设置指针
		BinaryTreeNode tmp = right;
		while (tmp.left != null) {
			tmp = tmp.left;
		}
		tmp.left = root;
		root.right = tmp;
	}

}


测试用例：
package com.aii.algorithm;

import org.junit.Before;
import org.junit.Test;

public class ConvertBinaryTreeToLinkedListTest {

	private BinaryTreeNode root = new BinaryTreeNode(10);

	@Before
	public void init() {
		BinaryTreeNode n2 = new BinaryTreeNode(6);
		BinaryTreeNode n3 = new BinaryTreeNode(14);
		BinaryTreeNode n4 = new BinaryTreeNode(4);
		BinaryTreeNode n5 = new BinaryTreeNode(8);
		BinaryTreeNode n6 = new BinaryTreeNode(12);
		BinaryTreeNode n7 = new BinaryTreeNode(16);

		root.left = n2;
		root.right = n3;

		n2.left = n4;
		n2.right = n5;

		n3.left = n6;
		n4.right = n7;
	}

	@Test
	public void test() {
		BinaryTreeNode bt = new ConvertBinaryTreeToLinkedList().convert(root);
		print(bt);
	}

	private void print(BinaryTreeNode bt) {
		if (bt == null) {
			System.out.println(bt);
			return;
		}
		BinaryTreeNode tmp = bt;
		while (tmp.right != null) {
			System.out.print(tmp.value + "-->");
			tmp = tmp.right;
		}
		System.out.println(tmp.value);

		//
		while (tmp.left != null) {
			System.out.print(tmp.value + "-->");
			tmp = tmp.left;
		}
		System.out.println(tmp.value);
	}

}
打印结果：
4-->16-->6-->8-->10-->12-->14
14-->12-->10-->8-->6-->16-->4



版权声明：本文为博主原创文章，未经博主允许不得转载。

BFS求解迷宫问题

定义一个二维数组： 
int maze[5][5] = {
0, 1, 0, 0, 0,
0, 1, 0, 1, 0,
0, 0, 0, 0, 0,
0, 1, 1, 1, 0,
0, 0, 0, 1, 0,
};
它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序打印出从左上角到右下角的最短路线的长度。
Input
第一行输入为测试用例的数目T。
接着是T个5× 5的二维数组，每个表示一个迷宫。
Output
左上角到右下角的最短路径的长度；如果不能通路，输出-1。格式如样例所示。
 
Sample Input
2
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
 
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 1
0 0 0 1 0
 
Sample Output
8
-1







#include<iostream>
#include<queue>
#include<stack>
using namespace std;

int maze[5][5];
int dir[4][2] = { -1, 0, 1, 0, 0, 1, 0, -1 };
int visited[5][5];
struct point
{
	int x;
	int y;
};
queue<point>q;
point pre[5][5];
int dist[5][5];
int lateset_dir[5][5];
stack<point>out_path;
stack<int>out_dir;
bool FindShortestPath(point begin,point end)
{
	q.push(begin);
	while (!q.empty())
	{
		point curr = q.front();
		q.pop();
		visited[begin.x][begin.y] = 1;
		for (int i = 0; i < 4; i++)
		{
			if (curr.x + dir[i][0] == 4 && curr.y + dir[i][1] == 4)
			{
				pre[4][4] = curr;
				dist[4][4] = dist[curr.x][curr.y] + 1;
				lateset_dir[4][4] = i;
				return true;
			}
			int nx = curr.x + dir[i][0];
			int ny = curr.y + dir[i][1];
			if (nx >= 0 && nx <= 4 && ny >= 0 && ny <= 4 && visited[nx][ny] == 0 && maze[nx][ny] == 0)
			{
				visited[nx][ny] = 1;
				point next;
				next.x = nx;
				next.y = ny;
				q.push(next);
				pre[nx][ny] = curr;
				dist[nx][ny] = dist[curr.x][curr.y] + 1;
				lateset_dir[nx][ny] = i;
			}
		}
	}
	return false;
}

void print_path(point p)
{
	point tmp = pre[p.x][p.y];
	if (tmp.x != p.x || tmp.y != p.y)//结束条件
	{
		out_path.push(p);
		out_dir.push(lateset_dir[p.x][p.y]);
		print_path(tmp);
	}
}

void getPath(point p)
{
	point tmp = pre[p.x][p.y];
	while (1)
	{
		if (tmp.x == p.x && tmp.y == p.y)
		{
			break;
		}
		out_path.push(p);
		out_dir.push(lateset_dir[p.x][p.y]);
		p = tmp;
		tmp = pre[tmp.x][tmp.y];
	}
}
int main()
{
	freopen("sample_input.txt", "r", stdin);
	int test_case;
	cin >> test_case;
	for (int t = 0; t < test_case; t++)
	{
		for (int i = 0; i < 5; i++)
		{
			for (int j = 0; j < 5; j++)
			{
				cin >> maze[i][j];
			}
		}
		memset(visited, 0, sizeof(visited));
		//清空队列为了第二次输入的maze
		while (!q.empty())
		{
			q.pop();
		}
		point begin, end;
		begin.x = 0; begin.y = 0;
		end.x = 4; end.y = 4;
		bool flag = FindShortestPath(begin, end);
		if (flag)
		{
			cout << "Yes" << endl;
			//print_path(end);
			getPath(end);
			while (!out_path.empty())
			{
				point tmp = out_path.top();
				out_path.pop();
				cout << tmp.x << " " << tmp.y << " " << endl;
			}
			while (!out_dir.empty())
			{
				int tmp = out_dir.top();
				out_dir.pop();
				if (tmp == 0)
					cout << "Up " << endl;
				else if (tmp == 1)
					cout << "Down " << endl;
				else if (tmp == 2)
					cout << "Right " << endl;
				else 
					cout << "Left " << endl;
			}
		}	
		else
		{
			cout << "No" << endl;
		}
	}
	
	
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

php读取图片流输出到页面图片
读取图片流代码
<?php



@ header("Content-Type:image/png");
$imagespath = $_GET['imagespath'];
$vms_ini_path=dirname(dirname(dirname(dirname(__FILE__)))).'\vms.ini';//vms.ini文件绝对路径
$ini_array = parse_ini_file($vms_ini_path);
$imagespath = $ini_array['CAPTURE_PATHNAME'].$imagespath;

echo file_get_contents($imagespath);

function isExist($path){
	if (!is_dir($path)){
		return false;
	}else{
		return true;
	}
}


//声明需要创建的图层的图片格式
//@ header("Content-Type:image/png");

//echo file_get_contents("C:\VMS_CAPTURE\hulu.png");



?>




显示图片
<img alt="JS相册特效" src="<?php echo "photop_api.php?imagespath=".$imagesarray[$i]?>" onload="scaleImage(this,99,75)" alt=""/>



版权声明：本文为博主原创文章，未经博主允许不得转载。

mfc cef

在mfc单文档程序中加入cef：
1.在BOOL CtestCEFApp::InitInstance()中初始化cef
HINSTANCE hInst = GetModuleHandle(NULL);
CefMainArgs main_args(hInst);


m_cefApp = new ClientApp();


//cef默认启动四个进程，分别是浏览器主进程，渲染进程，GPU进程，插件进程，如果不是主进程则直接退出
//AfxMessageBox(L"CefExecuteProcess");
int exit_code = CefExecuteProcess(main_args, m_cefApp.get(), NULL);
if (exit_code >= 0)
return exit_code;


//设置cef参数
CString szCEFCache;
CString szPath;
INT nLen = GetTempPath( 0, NULL ) + 1;
GetTempPath( nLen, szPath.GetBuffer( nLen ));
szCEFCache.Format( _T("%scache\0\0"), szPath );


CefSettings settings;
//settings.no_sandbox = TRUE;
//settings.multi_threaded_message_loop = FALSE;
CefString(&settings.cache_path) = szCEFCache;


//CefSettingsTraits::init( &cSettings);
//cSettings.multi_threaded_message_loop = false;


m_bCEFInitialized = CefInitialize(main_args, settings,m_cefApp.get(), NULL);


//初始化自定义协议
scheme_test::InitTest();
2.创建浏览器窗口
BOOL ClientApp::CreateBrowser(HWND hWnd, CRect rect, LPCTSTR pszURL)
{
CefBrowserSettings settings;
CefWindowInfo info;


info.SetAsChild( hWnd, rect );
std::string url = "test://test/html1.html";


return CefBrowserHost::CreateBrowser( info, m_cefHandler.get(), url, settings, NULL );
}
3.资源文件加载
namespace scheme_test {


// Implementation of the factory for for creating schema handlers.
class ClientSchemeHandlerFactory : public CefSchemeHandlerFactory {
public:
// Return a new scheme handler instance to handle the request.
virtual CefRefPtr<CefResourceHandler> Create(CefRefPtr<CefBrowser> browser,
CefRefPtr<CefFrame> frame,
const CefString& scheme_name,
CefRefPtr<CefRequest> request)
OVERRIDE {
return NULL;
}


IMPLEMENT_REFCOUNTING(ClientSchemeHandlerFactory);
};


//此方法在ClientApp的虚函数中被调用
void RegisterCustomSchemes(CefRefPtr<CefSchemeRegistrar> registrar,
std::vector<CefString>& cookiable_schemes) {
registrar->AddCustomScheme("test", true, false, false);//注册一个新的协议test
}


//初始化时调用
void InitTest() {
CefRegisterSchemeHandlerFactory("test", "test", new ClientSchemeHandlerFactory());//注册一个新的域名，并且新建一个可以处理此域名请求的类
}


}  // namespace scheme_test
4.两个关键的类
class CWebClient
: public CefClient
, public CefLifeSpanHandler
, public CefRequestHandler
{


public:
CMyWebBrowser m_wndBrowser;
public:
CWebClient(void){}
virtual ~CWebClient(void){}


virtual CefRefPtr<CefLifeSpanHandler> GetLifeSpanHandler() { return this; }
virtual CefRefPtr<CefRequestHandler> GetRequestHandler() { return this; }


//virtual bool DoClose( CefRefPtr<CefBrowser> browser );
//virtual void OnBeforeClose( CefRefPtr<CefBrowser> browser );
virtual void OnAfterCreated( CefRefPtr<CefBrowser> browser );


//此处处理接收到的message
virtual bool OnProcessMessageReceived( CefRefPtr<CefBrowser> browser, CefProcessId source_process, CefRefPtr<CefProcessMessage> message );
//此处加载本地html资源
virtual CefRefPtr<CefResourceHandler> GetResourceHandler( CefRefPtr<CefBrowser> browser, CefRefPtr<CefFrame> frame, CefRefPtr<CefRequest> request );


private:
bool ParseTestUrl(const std::string& url, std::string* file_name, std::string* mime_type);


public:


IMPLEMENT_REFCOUNTING(CWebClient);
IMPLEMENT_LOCKING(CWebClient);
};
class ClientApp: public CefApp
,public CefBrowserProcessHandler
,public CefRenderProcessHandler
{
public:
ClientApp(void);
ClientApp(HWND hWnd);
~ClientApp(void);


virtual CefRefPtr<CefBrowserProcessHandler> GetBrowserProcessHandler() OVERRIDE { return this; }
virtual CefRefPtr<CefRenderProcessHandler> GetRenderProcessHandler()OVERRIDE { return this; }
//此处处理js和c++调用
virtual void OnContextCreated( CefRefPtr<CefBrowser> browser, CefRefPtr<CefFrame> frame, CefRefPtr<CefV8Context> context );


virtual void OnContextInitialized() OVERRIDE;


//此处要<span style="font-family: Arial, Helvetica, sans-serif;">注册一个新的协议test</span>
virtual void OnRegisterCustomSchemes( CefRefPtr<CefSchemeRegistrar> registrar );


BOOL CreateBrowser(HWND hWnd, CRect rect, LPCTSTR pszURL);


public:
CefRefPtr<CWebClient> m_cefHandler;


private:
IMPLEMENT_REFCOUNTING(ClientApp);


};
5.c++和js相互调用
第一种：
class CefV8ExtensionHandler : public CefV8Handler
{
public:
CefV8ExtensionHandler(){}
~CefV8ExtensionHandler(){}


virtual bool Execute( const CefString& name, CefRefPtr<CefV8Value> object, const CefV8ValueList& arguments, CefRefPtr<CefV8Value>& retval, CefString& exception );


IMPLEMENT_REFCOUNTING(CefV8ExtensionHandler);
};
void ClientApp::OnContextCreated( CefRefPtr<CefBrowser> browser, CefRefPtr<CefFrame> frame, CefRefPtr<CefV8Context> context )
{
CefRefPtr<CefV8Value> obj = context->GetGlobal();


CefRefPtr<CefV8Handler> handler = new CefV8ExtensionHandler();


obj->SetValue("test", CefV8Value::CreateFunction("test", handler), V8_PROPERTY_ATTRIBUTE_READONLY);


}
bool CefV8ExtensionHandler::Execute( const CefString& name, CefRefPtr<CefV8Value> object, const CefV8ValueList& arguments, CefRefPtr<CefV8Value>& retval, CefString& exception )
{
if (name == "test")
{
std::string arg1 = arguments[0]->GetStringValue();


//MessageBoxA(NULL, arg1.c_str(), NULL, NULL);


retval = CefV8Value::CreateString(arg1);


CefRefPtr<CefBrowser> browser = CefV8Context::GetCurrentContext()->GetBrowser();
ASSERT(browser.get());


CefRefPtr<CefProcessMessage> message = CefProcessMessage::Create("test");


browser->SendProcessMessage(PID_BROWSER, message);


return true;
}


return false;
}
第二种：
std::string app_code =
"var app;"
"if (!app)"
"  app = {};"
"(function() {"
"  app.sendMessage = function(name, arguments) {"
"    native function sendMessage();"
"    return sendMessage(name, arguments);"
"  };"
"  app.setMessageCallback = function(name, callback) {"
"    native function setMessageCallback();"
"    return setMessageCallback(name, callback);"
"  };"
"  app.removeMessageCallback = function(name) {"
"    native function removeMessageCallback();"
"    return removeMessageCallback(name);"
"  };"
"})();";
CefRegisterExtension("v8/app", app_code,
new ClientAppExtensionHandler(this));
6.自定义标题栏需要子类化浏览器窗口方能接收到消息
class CMyWebBrowser : public CWnd
{
DECLARE_DYNCREATE(CMyWebBrowser)


public:
CMyWebBrowser(void);
virtual ~CMyWebBrowser(void);


protected:
DECLARE_MESSAGE_MAP()


public:
afx_msg LRESULT OnNcHitTest(CPoint point);
};
LRESULT CMyWebBrowser::OnNcHitTest(CPoint point)
{
CRect rc;
GetClientRect(&rc);
rc.top = rc.top;
rc.left = rc.left;
rc.right = rc.right;
rc.bottom = 20;
ClientToScreen(&rc);


CPoint screenpoint(point);
ScreenToClient(&screenpoint);


if (rc.PtInRect(point))
{
AfxGetApp()->GetMainWnd()->PostMessage(WM_NCLBUTTONDOWN, HTCAPTION, MAKELPARAM(screenpoint.x, screenpoint.y));


return 0;
}
else
return CWnd::OnNcHitTest(point);
}
void CWebClient::OnAfterCreated( CefRefPtr<CefBrowser> browser )
{
HWND hWnd = browser->GetHost()->GetWindowHandle();
HWND hChildWnd = ::GetNextWindow(hWnd, GW_CHILD );
m_wndBrowser.SubclassWindow(hChildWnd);


CefLifeSpanHandler::OnAfterCreated(browser);
}
7.消息循环
int CtestCEFApp::ExitInstance()
{
if( m_bCEFInitialized )
{
m_bCEFInitialized = false;


m_cefApp = NULL;


CefShutdown();
}


return CWinAppEx::ExitInstance();
}


BOOL CtestCEFApp::PumpMessage()
{
if( m_bCEFInitialized )
CefDoMessageLoopWork();


return CWinAppEx::PumpMessage();
}<span style="font-family:Arial, Helvetica, sans-serif;"><span style="white-space: normal;">
</span></span>

版权声明：本文为博主原创文章，未经博主允许不得转载。

scu oj 4443 Range Query （scoure :2015年四川省acm省赛）
     
Range Query

frog has a permutation p(1),p(2),…,p(n) of {1,2,…,n}.
 She also has m1+m2 records (ai,bi,ci) of
 the permutation.

For 1≤i≤m1, (ai,bi,ci) means min{p(ai),p(ai+1),…,p(bi)}=ci;For m1<i≤m1+m2, (ai,bi,ci) means max{p(ai),p(ai+1),…,p(bi)}=ci.
Find a permutation which is consistent with above records, or report the records are self-contradictory. If there are more than one valid permutations, find the lexicographically least one.
Permutation p(1),p(2),…,p(n) is
 lexicographically smaller than q(1),q(2),…,q(n) if
 and only if there exists 1≤i≤n which p(i)<q(i) and
 for all 1≤j<i, p(j)=q(j).
Input
The input consists of multiple tests. For each test:
The first line contains 3 integers n,m1,m2 (1≤n≤50,0≤m1+m2≤50).
 Each of the following (m1+m2) lines
 contains 3 integers ai,bi,ci (1≤ai≤bi≤n,1≤ci≤n).
Output
For each test, write n integers p(1),p(2),…,p(n) which
 denote the lexicographically least permutation, or ``-1'' if records are self-contradictory.
Sample Input
    5 1 1
    1 5 1
    1 5 5
    3 1 1
    1 2 2
    1 2 2
Sample Output
    1 2 3 4 5
    -1


解法：完备匹配的最小字典序。  先出最大匹配，然后枚举从小到每个点枚举最优状态，删边然后继续寻找增广路。
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int mmax  = 60;

int max_num[mmax],min_num[mmax];
int L[mmax],R[mmax];
bool G[mmax][mmax];
int n,m1,m2;
void init()
{
    memset(G,0,sizeof G);
    for(int i=1;i<=n;i++)
    {
        L[i]=min_num[i]=1;
        R[i]=max_num[i]=n;
    }
}
int link[mmax];
bool vis[mmax];
int Match[mmax];
bool match(int x)
{
    for(int i=1;i<=n;i++)
    {
        if(G[x][i] && !vis[i])
        {
            vis[i]=1;
            if(link[i]==-1 || match(link[i]))
            {
                link[i]=x;
                Match[x]=i;
                return 1;
            }
        }
    }
    return 0;
}
int hungury()
{
    int cnt=0;
    memset(link,-1,sizeof link);
    for(int i=1;i<=n;i++)
    {
        memset(vis,0,sizeof vis);
        if(match(i))
            cnt++;
    }
    return cnt;
}
int main()
{
    int a,b,c;
    while(~scanf("%d %d %d",&n,&m1,&m2))
    {
        init();
        for(int i=1;i<=m1;i++)
        {
            scanf("%d %d %d",&a,&b,&c);
            for(int j=a;j<=b;j++)
                min_num[j]=max(min_num[j],c);
            L[c]=max(L[c],a);
            R[c]=min(R[c],b);
        }
        for(int i=1;i<=m2;i++)
        {
            scanf("%d %d %d",&a,&b,&c);
            for(int j=a;j<=b;j++)
                max_num[j]=min(max_num[j],c);
            L[c]=max(L[c],a);
            R[c]=min(R[c],b);
        }

        for(int i=1;i<=n;i++)
        {
            for(int j=min_num[i];j<=max_num[i];j++)
            {
                if(L[j]<=i && i<=R[j])
                    G[i][j]=1;
            }
        }
        int num = hungury();
        if(num==n)
        {

//            for(int i=1;i<=n;i++)
//                printf("%d%c",Match[i],i==n?'\n':' ');

            for(int i=1;i<=n;i++)
            {
                int tmp=Match[i];
                G[i][tmp]=0;
                link[tmp]=-1;
                bool fg=0;
                memset(vis,0,sizeof vis);
                for(int j=1;j<tmp;j++)
                {
                    if(!vis[j] && G[i][j])
                    {
                        vis[j]=1;
                        if(link[j]==-1 || match(link[j]))
                        {
                            link[j]=i;
                            Match[i]=j;
                            fg=1;
                            break;
                        }
                    }
                }
                if(!fg)
                {
                    G[i][tmp]=1;
                    link[tmp]=i;
                }
                tmp=Match[i];
                for(int j=1;j<=n;j++)
                    G[j][tmp]=0;
            }


            for(int i=1;i<=n;i++)
                printf("%d%c",Match[i],i==n?'\n':' ');
        }
        else
            puts("-1");
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU   4267   A Simple Problem with Integers(树状数组)

A Simple Problem with Integers
Time Limit: 5000/1500 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4475    Accepted Submission(s): 1378



Problem Description

Let A1, A2, ... , AN be N elements. You need to deal with two kinds of operations. One type of operation is to add a given number to a few numbers in a given interval. The other is to query the value of some element.

 


Input

There are a lot of test cases. 
The first line contains an integer N. (1 <= N <= 50000)
The second line contains N numbers which are the initial values of A1, A2, ... , AN. (-10,000,000 <= the initial value of Ai <= 10,000,000)
The third line contains an integer Q. (1 <= Q <= 50000)
Each of the following Q lines represents an operation.
"1 a b k c" means adding c to each of Ai which satisfies a <= i <= b and (i - a) % k == 0. (1 <= a <= b <= N, 1 <= k <= 10, -1,000 <= c <= 1,000)
"2 a" means querying the value of Aa. (1 <= a <= N)


 


Output

For each test case, output several lines to answer all query operations.

 


Sample Input

4 
1 1 1 1
14
2 1
2 2
2 3
2 4
1 2 3 1 2
2 1 
2 2
2 3
2 4
1 1 4 2 1
2 1
2 2
2 3
2 4


 


Sample Output

1
1
1
1
1
3
3
1
2
3
4
1


 


Source

2012 ACM/ICPC Asia Regional Changchun Online









    题意：给出一个数目为n的序列，然后有m步操作，有两种操作方式
1.输入四个数据a,b,k,c将区间[a,b]中的数i满足(i-a)%k  == 0加上c.
2.输入一个数y,输出序列中第y个数的值。


  思路：因为k的值很小，那么对k取余的值也会很小，所以可以建立一个树状数组c[x][k][x%k]代表x对k取余的值，然后每次更新树状数组的时候只需要更新updata(a,.....) 与updata(b+1,.....);




点击打开链接








#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

#define N 50010

using namespace std;

int a[N];
int c[N][12][12];
int n,m;

int lowbit(int x) {
    return x&(-x);
}

void updata(int x,int k,int mod,int num) {
    while(x<=n) {
        c[x][k][mod] += num;
        x += lowbit(x);
    }
}

int getsum(int x,int y) {
    int s = 0;
    while(x>0) {
        for(int i=1; i<=10; i++) {
            s += c[x][i][y%i];
        }
        x -= lowbit(x);
    }
    return s;
}
int main() {
    while(scanf("%d",&n)!=EOF) {
        memset(c,0,sizeof(c));
        for(int i=1; i<=n; i++) {
            scanf("%d",&a[i]);
        }
        int x,y,k,num;
        scanf("%d",&m);
        while(m--) {
            scanf("%d",&x);
            if(x == 1) {
                scanf("%d%d%d%d",&x,&y,&k,&num);
                updata(x,k,x%k,num);
                updata(y+1,k,x%k,-num);
            } else {
                scanf("%d",&y);
                int sum = getsum(y,y);
                printf("%d\n",sum+a[y]);
            }
        }

    }
    return 0;
}




版权声明：本文为博主原创文章，如有特殊需要请与博主联系  QQ ： 793977586。

辛星解读laravel源代码第一篇即Database的实现流程
     经过一天左右的努力，终于把laravel的源代码整合到了yaf框架上面，下面说一下laravel的db层的一些处理吧，我使用的是laravel5.1.4，下面是database所在的位置：laravel5.1.4/vendor/laravel/framework/src/Illuminate/Database ，这个路径就是它的文件地址目录。
     我们来到Database文件夹后，会看到一些目录，这里简单介绍下它们的作用：
      Connectors----用于连接  、    Console-----用于命令行  、    Eloquent-----用于ORM 
      Migrantions----用于迁移、      Query-------用于查询、       Schema--------用于操作数据库结构
     该目录下还有一些其他的文件，都是一些比较通用的文件和接口性质的东西，当然也有一些和MySQL以及Postgresql息息相关的东西，这里就不一一介绍啦。
      然后我们进入Query目录，发现它有两个目录和三个文件，其中Builder.php是具体的命令，比如我们常用的transaction、get、lists都是在这个文件中定义的，而Expression.php则是具体的表达式，而JoinClause.php则是和连接相关的操作，主要处理连接里面具体的每个小环节的操作。一般来说，这里面最大的就是Builder.php，它有52KB，它是负责接收用户传递过来的数据的，我们的命令也就写在这个接口里面。
        而Grammars文件夹则是根据用户的输入来进行编译，也就是它里面的函数多是以compile开头，而且多数是compileInsert这种形式，因为在它的源代码中我们经常会发现它的构造中是compile加上action的ucfirst操作之后的字符串拼接得到。而在Grammars里面又会有Grammar.php和MySqlGrammar.php等和具体的数据库相关的文件。
      而在Connection.php中引用它们的时候，它是不知道我们使用了哪个数据库的，因此laravel给我们提供的解决办法是，我不管你使用的是哪个具体的Grammar，我只知道，你给我用的时候，必须是QueryGrammar。由于我们的业务中都是使用的MySQL，因此我们可以写一个QueryGrammar来继承自MySQLGrammar，当然，不这样做也是可以的。
       其中绝大多数都是在Builder和Grammar中跳转，还有少数是需要Processor的，一般都是这样，很多具体的细节就不废话了。下面把Builder.php的代码贴上来把：
  <?php

namespace Illuminate\Database\Query;

use Closure;
use BadMethodCallException;
use Illuminate\Support\Arr;
use Illuminate\Support\Str;
use InvalidArgumentException;
use Illuminate\Support\Collection;
use Illuminate\Pagination\Paginator;
use Illuminate\Contracts\Support\Arrayable;
use Illuminate\Database\ConnectionInterface;
use Illuminate\Database\Query\Grammars\Grammar;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Database\Query\Processors\Processor;

class Builder
{
    /**
     * The database connection instance.
     *
     * @var \Illuminate\Database\Connection
     */
    protected $connection;

    /**
     * The database query grammar instance.
     *
     * @var \Illuminate\Database\Query\Grammars\Grammar
     */
    protected $grammar;

    /**
     * The database query post processor instance.
     *
     * @var \Illuminate\Database\Query\Processors\Processor
     */
    protected $processor;

    /**
     * The current query value bindings.
     *
     * @var array
     */
    protected $bindings = [
        'select' => [],
        'join'   => [],
        'where'  => [],
        'having' => [],
        'order'  => [],
    ];

    /**
     * An aggregate function and column to be run.
     *
     * @var array
     */
    public $aggregate;

    /**
     * The columns that should be returned.
     *
     * @var array
     */
    public $columns;

    /**
     * Indicates if the query returns distinct results.
     *
     * @var bool
     */
    public $distinct = false;

    /**
     * The table which the query is targeting.
     *
     * @var string
     */
    public $from;

    /**
     * The table joins for the query.
     *
     * @var array
     */
    public $joins;

    /**
     * The where constraints for the query.
     *
     * @var array
     */
    public $wheres;

    /**
     * The groupings for the query.
     *
     * @var array
     */
    public $groups;

    /**
     * The having constraints for the query.
     *
     * @var array
     */
    public $havings;

    /**
     * The orderings for the query.
     *
     * @var array
     */
    public $orders;

    /**
     * The maximum number of records to return.
     *
     * @var int
     */
    public $limit;

    /**
     * The number of records to skip.
     *
     * @var int
     */
    public $offset;

    /**
     * The query union statements.
     *
     * @var array
     */
    public $unions;

    /**
     * The maximum number of union records to return.
     *
     * @var int
     */
    public $unionLimit;

    /**
     * The number of union records to skip.
     *
     * @var int
     */
    public $unionOffset;

    /**
     * The orderings for the union query.
     *
     * @var array
     */
    public $unionOrders;

    /**
     * Indicates whether row locking is being used.
     *
     * @var string|bool
     */
    public $lock;

    /**
     * The field backups currently in use.
     *
     * @var array
     */
    protected $backups = [];

    /**
     * All of the available clause operators.
     *
     * @var array
     */
    protected $operators = [
        '=', '<', '>', '<=', '>=', '<>', '!=',
        'like', 'like binary', 'not like', 'between', 'ilike',
        '&', '|', '^', '<<', '>>',
        'rlike', 'regexp', 'not regexp',
        '~', '~*', '!~', '!~*', 'similar to',
                'not similar to',
    ];

    /**
     * Whether use write pdo for select.
     *
     * @var bool
     */
    protected $useWritePdo = false;

    /**
     * Create a new query builder instance.
     *
     * @param  \Illuminate\Database\ConnectionInterface  $connection
     * @param  \Illuminate\Database\Query\Grammars\Grammar  $grammar
     * @param  \Illuminate\Database\Query\Processors\Processor  $processor
     * @return void
     */
    public function __construct(ConnectionInterface $connection,
                                Grammar $grammar,
                                Processor $processor)
    {
        $this->grammar = $grammar;
        $this->processor = $processor;
        $this->connection = $connection;
    }

    /**
     * Set the columns to be selected.
     *
     * @param  array  $columns
     * @return $this
     */
    public function select($columns = ['*'])
    {
        $this->columns = is_array($columns) ? $columns : func_get_args();

        return $this;
    }

    /**
     * Add a new "raw" select expression to the query.
     *
     * @param  string  $expression
     * @param  array   $bindings
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function selectRaw($expression, array $bindings = [])
    {
        $this->addSelect(new Expression($expression));

        if ($bindings) {
            $this->addBinding($bindings, 'select');
        }

        return $this;
    }

    /**
     * Add a subselect expression to the query.
     *
     * @param  \Closure|\Illuminate\Database\Query\Builder|string $query
     * @param  string  $as
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function selectSub($query, $as)
    {
        if ($query instanceof Closure) {
            $callback = $query;

            $callback($query = $this->newQuery());
        }

        if ($query instanceof self) {
            $bindings = $query->getBindings();

            $query = $query->toSql();
        } elseif (is_string($query)) {
            $bindings = [];
        } else {
            throw new InvalidArgumentException;
        }

        return $this->selectRaw('('.$query.') as '.$this->grammar->wrap($as), $bindings);
    }

    /**
     * Add a new select column to the query.
     *
     * @param  mixed  $column
     * @return $this
     */
    public function addSelect($column)
    {
        $column = is_array($column) ? $column : func_get_args();

        $this->columns = array_merge((array) $this->columns, $column);

        return $this;
    }

    /**
     * Force the query to only return distinct results.
     *
     * @return $this
     */
    public function distinct()
    {
        $this->distinct = true;

        return $this;
    }

    /**
     * Set the table which the query is targeting.
     *
     * @param  string  $table
     * @return $this
     */
    public function from($table)
    {
        $this->from = $table;

        return $this;
    }

    /**
     * Add a join clause to the query.
     *
     * @param  string  $table
     * @param  string  $one
     * @param  string  $operator
     * @param  string  $two
     * @param  string  $type
     * @param  bool    $where
     * @return $this
     */
    public function join($table, $one, $operator = null, $two = null, $type = 'inner', $where = false)
    {
        // If the first "column" of the join is really a Closure instance the developer
        // is trying to build a join with a complex "on" clause containing more than
        // one condition, so we'll add the join and call a Closure with the query.
        if ($one instanceof Closure) {
            $this->joins[] = new JoinClause($type, $table);

            call_user_func($one, end($this->joins));
        }

        // If the column is simply a string, we can assume the join simply has a basic
        // "on" clause with a single condition. So we will just build the join with
        // this simple join clauses attached to it. There is not a join callback.
        else {
            $join = new JoinClause($type, $table);

            $this->joins[] = $join->on(
                $one, $operator, $two, 'and', $where
            );
        }

        return $this;
    }

    /**
     * Add a "join where" clause to the query.
     *
     * @param  string  $table
     * @param  string  $one
     * @param  string  $operator
     * @param  string  $two
     * @param  string  $type
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function joinWhere($table, $one, $operator, $two, $type = 'inner')
    {
        return $this->join($table, $one, $operator, $two, $type, true);
    }

    /**
     * Add a left join to the query.
     *
     * @param  string  $table
     * @param  string  $first
     * @param  string  $operator
     * @param  string  $second
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function leftJoin($table, $first, $operator = null, $second = null)
    {
        return $this->join($table, $first, $operator, $second, 'left');
    }

    /**
     * Add a "join where" clause to the query.
     *
     * @param  string  $table
     * @param  string  $one
     * @param  string  $operator
     * @param  string  $two
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function leftJoinWhere($table, $one, $operator, $two)
    {
        return $this->joinWhere($table, $one, $operator, $two, 'left');
    }

    /**
     * Add a right join to the query.
     *
     * @param  string  $table
     * @param  string  $first
     * @param  string  $operator
     * @param  string  $second
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function rightJoin($table, $first, $operator = null, $second = null)
    {
        return $this->join($table, $first, $operator, $second, 'right');
    }

    /**
     * Add a "right join where" clause to the query.
     *
     * @param  string  $table
     * @param  string  $one
     * @param  string  $operator
     * @param  string  $two
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function rightJoinWhere($table, $one, $operator, $two)
    {
        return $this->joinWhere($table, $one, $operator, $two, 'right');
    }

    /**
     * Add a basic where clause to the query.
     *
     * @param  string|array|\Closure  $column
     * @param  string  $operator
     * @param  mixed   $value
     * @param  string  $boolean
     * @return $this
     *
     * @throws \InvalidArgumentException
     */
    public function where($column, $operator = null, $value = null, $boolean = 'and')
    {
        // If the column is an array, we will assume it is an array of key-value pairs
        // and can add them each as a where clause. We will maintain the boolean we
        // received when the method was called and pass it into the nested where.
        if (is_array($column)) {
            return $this->whereNested(function ($query) use ($column) {
                foreach ($column as $key => $value) {
                    $query->where($key, '=', $value);
                }
            }, $boolean);
        }

        // Here we will make some assumptions about the operator. If only 2 values are
        // passed to the method, we will assume that the operator is an equals sign
        // and keep going. Otherwise, we'll require the operator to be passed in.
        if (func_num_args() == 2) {
            list($value, $operator) = [$operator, '='];
        } elseif ($this->invalidOperatorAndValue($operator, $value)) {
            throw new InvalidArgumentException('Illegal operator and value combination.');
        }

        // If the columns is actually a Closure instance, we will assume the developer
        // wants to begin a nested where statement which is wrapped in parenthesis.
        // We'll add that Closure to the query then return back out immediately.
        if ($column instanceof Closure) {
            return $this->whereNested($column, $boolean);
        }

        // If the given operator is not found in the list of valid operators we will
        // assume that the developer is just short-cutting the '=' operators and
        // we will set the operators to '=' and set the values appropriately.
        if (!in_array(strtolower($operator), $this->operators, true)) {
            list($value, $operator) = [$operator, '='];
        }

        // If the value is a Closure, it means the developer is performing an entire
        // sub-select within the query and we will need to compile the sub-select
        // within the where clause to get the appropriate query record results.
        if ($value instanceof Closure) {
            return $this->whereSub($column, $operator, $value, $boolean);
        }

        // If the value is "null", we will just assume the developer wants to add a
        // where null clause to the query. So, we will allow a short-cut here to
        // that method for convenience so the developer doesn't have to check.
        if (is_null($value)) {
            return $this->whereNull($column, $boolean, $operator != '=');
        }

        // Now that we are working with just a simple query we can put the elements
        // in our array and add the query binding to our array of bindings that
        // will be bound to each SQL statements when it is finally executed.
        $type = 'Basic';

        $this->wheres[] = compact('type', 'column', 'operator', 'value', 'boolean');

        if (!$value instanceof Expression) {
            $this->addBinding($value, 'where');
        }

        return $this;
    }

    /**
     * Add an "or where" clause to the query.
     *
     * @param  string  $column
     * @param  string  $operator
     * @param  mixed   $value
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhere($column, $operator = null, $value = null)
    {
        return $this->where($column, $operator, $value, 'or');
    }

    /**
     * Determine if the given operator and value combination is legal.
     *
     * @param  string  $operator
     * @param  mixed  $value
     * @return bool
     */
    protected function invalidOperatorAndValue($operator, $value)
    {
        $isOperator = in_array($operator, $this->operators);

        return $isOperator && $operator != '=' && is_null($value);
    }

    /**
     * Add a raw where clause to the query.
     *
     * @param  string  $sql
     * @param  array   $bindings
     * @param  string  $boolean
     * @return $this
     */
    public function whereRaw($sql, array $bindings = [], $boolean = 'and')
    {
        $type = 'raw';

        $this->wheres[] = compact('type', 'sql', 'boolean');

        $this->addBinding($bindings, 'where');

        return $this;
    }

    /**
     * Add a raw or where clause to the query.
     *
     * @param  string  $sql
     * @param  array   $bindings
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereRaw($sql, array $bindings = [])
    {
        return $this->whereRaw($sql, $bindings, 'or');
    }

    /**
     * Add a where between statement to the query.
     *
     * @param  string  $column
     * @param  array   $values
     * @param  string  $boolean
     * @param  bool  $not
     * @return $this
     */
    public function whereBetween($column, array $values, $boolean = 'and', $not = false)
    {
        $type = 'between';

        $this->wheres[] = compact('column', 'type', 'boolean', 'not');

        $this->addBinding($values, 'where');

        return $this;
    }

    /**
     * Add an or where between statement to the query.
     *
     * @param  string  $column
     * @param  array   $values
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereBetween($column, array $values)
    {
        return $this->whereBetween($column, $values, 'or');
    }

    /**
     * Add a where not between statement to the query.
     *
     * @param  string  $column
     * @param  array   $values
     * @param  string  $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereNotBetween($column, array $values, $boolean = 'and')
    {
        return $this->whereBetween($column, $values, $boolean, true);
    }

    /**
     * Add an or where not between statement to the query.
     *
     * @param  string  $column
     * @param  array   $values
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereNotBetween($column, array $values)
    {
        return $this->whereNotBetween($column, $values, 'or');
    }

    /**
     * Add a nested where statement to the query.
     *
     * @param  \Closure $callback
     * @param  string   $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereNested(Closure $callback, $boolean = 'and')
    {
        // To handle nested queries we'll actually create a brand new query instance
        // and pass it off to the Closure that we have. The Closure can simply do
        // do whatever it wants to a query then we will store it for compiling.
        $query = $this->newQuery();

        $query->from($this->from);

        call_user_func($callback, $query);

        return $this->addNestedWhereQuery($query, $boolean);
    }

    /**
     * Add another query builder as a nested where to the query builder.
     *
     * @param  \Illuminate\Database\Query\Builder|static $query
     * @param  string  $boolean
     * @return $this
     */
    public function addNestedWhereQuery($query, $boolean = 'and')
    {
        if (count($query->wheres)) {
            $type = 'Nested';

            $this->wheres[] = compact('type', 'query', 'boolean');

            $this->mergeBindings($query);
        }

        return $this;
    }

    /**
     * Add a full sub-select to the query.
     *
     * @param  string   $column
     * @param  string   $operator
     * @param  \Closure $callback
     * @param  string   $boolean
     * @return $this
     */
    protected function whereSub($column, $operator, Closure $callback, $boolean)
    {
        $type = 'Sub';

        $query = $this->newQuery();

        // Once we have the query instance we can simply execute it so it can add all
        // of the sub-select's conditions to itself, and then we can cache it off
        // in the array of where clauses for the "main" parent query instance.
        call_user_func($callback, $query);

        $this->wheres[] = compact('type', 'column', 'operator', 'query', 'boolean');

        $this->mergeBindings($query);

        return $this;
    }

    /**
     * Add an exists clause to the query.
     *
     * @param  \Closure $callback
     * @param  string   $boolean
     * @param  bool     $not
     * @return $this
     */
    public function whereExists(Closure $callback, $boolean = 'and', $not = false)
    {
        $type = $not ? 'NotExists' : 'Exists';

        $query = $this->newQuery();

        // Similar to the sub-select clause, we will create a new query instance so
        // the developer may cleanly specify the entire exists query and we will
        // compile the whole thing in the grammar and insert it into the SQL.
        call_user_func($callback, $query);

        $this->wheres[] = compact('type', 'operator', 'query', 'boolean');

        $this->mergeBindings($query);

        return $this;
    }

    /**
     * Add an or exists clause to the query.
     *
     * @param  \Closure $callback
     * @param  bool     $not
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereExists(Closure $callback, $not = false)
    {
        return $this->whereExists($callback, 'or', $not);
    }

    /**
     * Add a where not exists clause to the query.
     *
     * @param  \Closure $callback
     * @param  string   $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereNotExists(Closure $callback, $boolean = 'and')
    {
        return $this->whereExists($callback, $boolean, true);
    }

    /**
     * Add a where not exists clause to the query.
     *
     * @param  \Closure  $callback
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereNotExists(Closure $callback)
    {
        return $this->orWhereExists($callback, true);
    }

    /**
     * Add a "where in" clause to the query.
     *
     * @param  string  $column
     * @param  mixed   $values
     * @param  string  $boolean
     * @param  bool    $not
     * @return $this
     */
    public function whereIn($column, $values, $boolean = 'and', $not = false)
    {
        $type = $not ? 'NotIn' : 'In';

        // If the value of the where in clause is actually a Closure, we will assume that
        // the developer is using a full sub-select for this "in" statement, and will
        // execute those Closures, then we can re-construct the entire sub-selects.
        if ($values instanceof Closure) {
            return $this->whereInSub($column, $values, $boolean, $not);
        }

        if ($values instanceof Arrayable) {
            $values = $values->toArray();
        }

        $this->wheres[] = compact('type', 'column', 'values', 'boolean');

        $this->addBinding($values, 'where');

        return $this;
    }

    /**
     * Add an "or where in" clause to the query.
     *
     * @param  string  $column
     * @param  mixed   $values
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereIn($column, $values)
    {
        return $this->whereIn($column, $values, 'or');
    }

    /**
     * Add a "where not in" clause to the query.
     *
     * @param  string  $column
     * @param  mixed   $values
     * @param  string  $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereNotIn($column, $values, $boolean = 'and')
    {
        return $this->whereIn($column, $values, $boolean, true);
    }

    /**
     * Add an "or where not in" clause to the query.
     *
     * @param  string  $column
     * @param  mixed   $values
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereNotIn($column, $values)
    {
        return $this->whereNotIn($column, $values, 'or');
    }

    /**
     * Add a where in with a sub-select to the query.
     *
     * @param  string   $column
     * @param  \Closure $callback
     * @param  string   $boolean
     * @param  bool     $not
     * @return $this
     */
    protected function whereInSub($column, Closure $callback, $boolean, $not)
    {
        $type = $not ? 'NotInSub' : 'InSub';

        // To create the exists sub-select, we will actually create a query and call the
        // provided callback with the query so the developer may set any of the query
        // conditions they want for the in clause, then we'll put it in this array.
        call_user_func($callback, $query = $this->newQuery());

        $this->wheres[] = compact('type', 'column', 'query', 'boolean');

        $this->mergeBindings($query);

        return $this;
    }

    /**
     * Add a "where null" clause to the query.
     *
     * @param  string  $column
     * @param  string  $boolean
     * @param  bool    $not
     * @return $this
     */
    public function whereNull($column, $boolean = 'and', $not = false)
    {
        $type = $not ? 'NotNull' : 'Null';

        $this->wheres[] = compact('type', 'column', 'boolean');

        return $this;
    }

    /**
     * Add an "or where null" clause to the query.
     *
     * @param  string  $column
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereNull($column)
    {
        return $this->whereNull($column, 'or');
    }

    /**
     * Add a "where not null" clause to the query.
     *
     * @param  string  $column
     * @param  string  $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereNotNull($column, $boolean = 'and')
    {
        return $this->whereNull($column, $boolean, true);
    }

    /**
     * Add an "or where not null" clause to the query.
     *
     * @param  string  $column
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orWhereNotNull($column)
    {
        return $this->whereNotNull($column, 'or');
    }

    /**
     * Add a "where date" statement to the query.
     *
     * @param  string  $column
     * @param  string   $operator
     * @param  int   $value
     * @param  string   $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereDate($column, $operator, $value, $boolean = 'and')
    {
        return $this->addDateBasedWhere('Date', $column, $operator, $value, $boolean);
    }

    /**
     * Add a "where day" statement to the query.
     *
     * @param  string  $column
     * @param  string   $operator
     * @param  int   $value
     * @param  string   $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereDay($column, $operator, $value, $boolean = 'and')
    {
        return $this->addDateBasedWhere('Day', $column, $operator, $value, $boolean);
    }

    /**
     * Add a "where month" statement to the query.
     *
     * @param  string  $column
     * @param  string   $operator
     * @param  int   $value
     * @param  string   $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereMonth($column, $operator, $value, $boolean = 'and')
    {
        return $this->addDateBasedWhere('Month', $column, $operator, $value, $boolean);
    }

    /**
     * Add a "where year" statement to the query.
     *
     * @param  string  $column
     * @param  string   $operator
     * @param  int   $value
     * @param  string   $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function whereYear($column, $operator, $value, $boolean = 'and')
    {
        return $this->addDateBasedWhere('Year', $column, $operator, $value, $boolean);
    }

    /**
     * Add a date based (year, month, day) statement to the query.
     *
     * @param  string  $type
     * @param  string  $column
     * @param  string  $operator
     * @param  int  $value
     * @param  string  $boolean
     * @return $this
     */
    protected function addDateBasedWhere($type, $column, $operator, $value, $boolean = 'and')
    {
        $this->wheres[] = compact('column', 'type', 'boolean', 'operator', 'value');

        $this->addBinding($value, 'where');

        return $this;
    }

    /**
     * Handles dynamic "where" clauses to the query.
     *
     * @param  string  $method
     * @param  string  $parameters
     * @return $this
     */
    public function dynamicWhere($method, $parameters)
    {
        $finder = substr($method, 5);

        $segments = preg_split('/(And|Or)(?=[A-Z])/', $finder, -1, PREG_SPLIT_DELIM_CAPTURE);

        // The connector variable will determine which connector will be used for the
        // query condition. We will change it as we come across new boolean values
        // in the dynamic method strings, which could contain a number of these.
        $connector = 'and';

        $index = 0;

        foreach ($segments as $segment) {
            // If the segment is not a boolean connector, we can assume it is a column's name
            // and we will add it to the query as a new constraint as a where clause, then
            // we can keep iterating through the dynamic method string's segments again.
            if ($segment != 'And' && $segment != 'Or') {
                $this->addDynamic($segment, $connector, $parameters, $index);

                $index++;
            }

            // Otherwise, we will store the connector so we know how the next where clause we
            // find in the query should be connected to the previous ones, meaning we will
            // have the proper boolean connector to connect the next where clause found.
            else {
                $connector = $segment;
            }
        }

        return $this;
    }

    /**
     * Add a single dynamic where clause statement to the query.
     *
     * @param  string  $segment
     * @param  string  $connector
     * @param  array   $parameters
     * @param  int     $index
     * @return void
     */
    protected function addDynamic($segment, $connector, $parameters, $index)
    {
        // Once we have parsed out the columns and formatted the boolean operators we
        // are ready to add it to this query as a where clause just like any other
        // clause on the query. Then we'll increment the parameter index values.
        $bool = strtolower($connector);

        $this->where(Str::snake($segment), '=', $parameters[$index], $bool);
    }

    /**
     * Add a "group by" clause to the query.
     *
     * @param  array|string  $column,...
     * @return $this
     */
    public function groupBy()
    {
        foreach (func_get_args() as $arg) {
            $this->groups = array_merge((array) $this->groups, is_array($arg) ? $arg : [$arg]);
        }

        return $this;
    }

    /**
     * Add a "having" clause to the query.
     *
     * @param  string  $column
     * @param  string  $operator
     * @param  string  $value
     * @param  string  $boolean
     * @return $this
     */
    public function having($column, $operator = null, $value = null, $boolean = 'and')
    {
        $type = 'basic';

        $this->havings[] = compact('type', 'column', 'operator', 'value', 'boolean');

        if (!$value instanceof Expression) {
            $this->addBinding($value, 'having');
        }

        return $this;
    }

    /**
     * Add a "or having" clause to the query.
     *
     * @param  string  $column
     * @param  string  $operator
     * @param  string  $value
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orHaving($column, $operator = null, $value = null)
    {
        return $this->having($column, $operator, $value, 'or');
    }

    /**
     * Add a raw having clause to the query.
     *
     * @param  string  $sql
     * @param  array   $bindings
     * @param  string  $boolean
     * @return $this
     */
    public function havingRaw($sql, array $bindings = [], $boolean = 'and')
    {
        $type = 'raw';

        $this->havings[] = compact('type', 'sql', 'boolean');

        $this->addBinding($bindings, 'having');

        return $this;
    }

    /**
     * Add a raw or having clause to the query.
     *
     * @param  string  $sql
     * @param  array   $bindings
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function orHavingRaw($sql, array $bindings = [])
    {
        return $this->havingRaw($sql, $bindings, 'or');
    }

    /**
     * Add an "order by" clause to the query.
     *
     * @param  string  $column
     * @param  string  $direction
     * @return $this
     */
    public function orderBy($column, $direction = 'asc')
    {
        $property = $this->unions ? 'unionOrders' : 'orders';
        $direction = strtolower($direction) == 'asc' ? 'asc' : 'desc';

        $this->{$property}[] = compact('column', 'direction');

        return $this;
    }

    /**
     * Add an "order by" clause for a timestamp to the query.
     *
     * @param  string  $column
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function latest($column = 'created_at')
    {
        return $this->orderBy($column, 'desc');
    }

    /**
     * Add an "order by" clause for a timestamp to the query.
     *
     * @param  string  $column
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function oldest($column = 'created_at')
    {
        return $this->orderBy($column, 'asc');
    }

    /**
     * Add a raw "order by" clause to the query.
     *
     * @param  string  $sql
     * @param  array  $bindings
     * @return $this
     */
    public function orderByRaw($sql, $bindings = [])
    {
        $property = $this->unions ? 'unionOrders' : 'orders';

        $type = 'raw';

        $this->{$property}[] = compact('type', 'sql');

        $this->addBinding($bindings, 'order');

        return $this;
    }

    /**
     * Set the "offset" value of the query.
     *
     * @param  int  $value
     * @return $this
     */
    public function offset($value)
    {
        $property = $this->unions ? 'unionOffset' : 'offset';

        $this->$property = max(0, $value);

        return $this;
    }

    /**
     * Alias to set the "offset" value of the query.
     *
     * @param  int  $value
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function skip($value)
    {
        return $this->offset($value);
    }

    /**
     * Set the "limit" value of the query.
     *
     * @param  int  $value
     * @return $this
     */
    public function limit($value)
    {
        $property = $this->unions ? 'unionLimit' : 'limit';

        if ($value > 0) {
            $this->$property = $value;
        }

        return $this;
    }

    /**
     * Alias to set the "limit" value of the query.
     *
     * @param  int  $value
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function take($value)
    {
        return $this->limit($value);
    }

    /**
     * Set the limit and offset for a given page.
     *
     * @param  int  $page
     * @param  int  $perPage
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function forPage($page, $perPage = 15)
    {
        return $this->skip(($page - 1) * $perPage)->take($perPage);
    }

    /**
     * Add a union statement to the query.
     *
     * @param  \Illuminate\Database\Query\Builder|\Closure  $query
     * @param  bool  $all
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function union($query, $all = false)
    {
        if ($query instanceof Closure) {
            call_user_func($query, $query = $this->newQuery());
        }

        $this->unions[] = compact('query', 'all');

        return $this->mergeBindings($query);
    }

    /**
     * Add a union all statement to the query.
     *
     * @param  \Illuminate\Database\Query\Builder|\Closure  $query
     * @return \Illuminate\Database\Query\Builder|static
     */
    public function unionAll($query)
    {
        return $this->union($query, true);
    }

    /**
     * Lock the selected rows in the table.
     *
     * @param  bool  $value
     * @return $this
     */
    public function lock($value = true)
    {
        $this->lock = $value;

        return $this;
    }

    /**
     * Lock the selected rows in the table for updating.
     *
     * @return \Illuminate\Database\Query\Builder
     */
    public function lockForUpdate()
    {
        return $this->lock(true);
    }

    /**
     * Share lock the selected rows in the table.
     *
     * @return \Illuminate\Database\Query\Builder
     */
    public function sharedLock()
    {
        return $this->lock(false);
    }

    /**
     * Get the SQL representation of the query.
     *
     * @return string
     */
    public function toSql()
    {
        return $this->grammar->compileSelect($this);
    }

    /**
     * Execute a query for a single record by ID.
     *
     * @param  int    $id
     * @param  array  $columns
     * @return mixed|static
     */
    public function find($id, $columns = ['*'])
    {
        return $this->where('id', '=', $id)->first($columns);
    }

    /**
     * Get a single column's value from the first result of a query.
     *
     * @param  string  $column
     * @return mixed
     */
    public function value($column)
    {
        $result = (array) $this->first([$column]);

        return count($result) > 0 ? reset($result) : null;
    }

    /**
     * Get a single column's value from the first result of a query.
     *
     * This is an alias for the "value" method.
     *
     * @param  string  $column
     * @return mixed
     *
     * @deprecated since version 5.1.
     */
    public function pluck($column)
    {
        return $this->value($column);
    }

    /**
     * Execute the query and get the first result.
     *
     * @param  array   $columns
     * @return mixed|static
     */
    public function first($columns = ['*'])
    {
        $results = $this->take(1)->get($columns);

        return count($results) > 0 ? reset($results) : null;
    }

    /**
     * Execute the query as a "select" statement.
     *
     * @param  array  $columns
     * @return array|static[]
     */
    public function get($columns = ['*'])
    {
        return $this->getFresh($columns);
    }

    /**
     * Execute the query as a fresh "select" statement.
     *
     * @param  array  $columns
     * @return array|static[]
     */
    public function getFresh($columns = ['*'])
    {
        if (is_null($this->columns)) {
            $this->columns = $columns;
        }

        return $this->processor->processSelect($this, $this->runSelect());
    }

    /**
     * Run the query as a "select" statement against the connection.
     *
     * @return array
     */
    protected function runSelect()
    {
        return $this->connection->select($this->toSql(), $this->getBindings(), !$this->useWritePdo);
    }

    /**
     * Paginate the given query into a simple paginator.
     *
     * @param  int  $perPage
     * @param  array  $columns
     * @param  string  $pageName
     * @return \Illuminate\Contracts\Pagination\LengthAwarePaginator
     */
    public function paginate($perPage = 15, $columns = ['*'], $pageName = 'page')
    {
        $page = Paginator::resolveCurrentPage($pageName);

        $total = $this->getCountForPagination($columns);

        $results = $this->forPage($page, $perPage)->get($columns);

        return new LengthAwarePaginator($results, $total, $perPage, $page, [
            'path' => Paginator::resolveCurrentPath(),
            'pageName' => $pageName,
        ]);
    }

    /**
     * Get a paginator only supporting simple next and previous links.
     *
     * This is more efficient on larger data-sets, etc.
     *
     * @param  int  $perPage
     * @param  array  $columns
     * @param  string  $pageName
     * @return \Illuminate\Contracts\Pagination\Paginator
     */
    public function simplePaginate($perPage = 15, $columns = ['*'], $pageName = 'page')
    {
        $page = Paginator::resolveCurrentPage($pageName);

        $this->skip(($page - 1) * $perPage)->take($perPage + 1);

        return new Paginator($this->get($columns), $perPage, $page, [
            'path' => Paginator::resolveCurrentPath(),
            'pageName' => $pageName,
        ]);
    }

    /**
     * Get the count of the total records for the paginator.
     *
     * @param  array  $columns
     * @return int
     */
    public function getCountForPagination($columns = ['*'])
    {
        $this->backupFieldsForCount();

        $this->aggregate = ['function' => 'count', 'columns' => $columns];

        $results = $this->get();

        $this->aggregate = null;

        $this->restoreFieldsForCount();

        if (isset($this->groups)) {
            return count($results);
        }

        return isset($results[0]) ? (int) array_change_key_case((array) $results[0])['aggregate'] : 0;
    }

    /**
     * Backup some fields for the pagination count.
     *
     * @return void
     */
    protected function backupFieldsForCount()
    {
        foreach (['orders', 'limit', 'offset', 'columns'] as $field) {
            $this->backups[$field] = $this->{$field};

            $this->{$field} = null;
        }
    }

    /**
     * Restore some fields after the pagination count.
     *
     * @return void
     */
    protected function restoreFieldsForCount()
    {
        foreach (['orders', 'limit', 'offset', 'columns'] as $field) {
            $this->{$field} = $this->backups[$field];
        }

        $this->backups = [];
    }

    /**
     * Chunk the results of the query.
     *
     * @param  int  $count
     * @param  callable  $callback
     * @return void
     */
    public function chunk($count, callable $callback)
    {
        $results = $this->forPage($page = 1, $count)->get();

        while (count($results) > 0) {
            // On each chunk result set, we will pass them to the callback and then let the
            // developer take care of everything within the callback, which allows us to
            // keep the memory low for spinning through large result sets for working.
            if (call_user_func($callback, $results) === false) {
                break;
            }

            $page++;

            $results = $this->forPage($page, $count)->get();
        }
    }

    /**
     * Get an array with the values of a given column.
     *
     * @param  string  $column
     * @param  string  $key
     * @return array
     */
    public function lists($column, $key = null)
    {
        $columns = $this->getListSelect($column, $key);

        $results = new Collection($this->get($columns));

        return $results->pluck($columns[0], Arr::get($columns, 1))->all();
    }

    /**
     * Get the columns that should be used in a list array.
     *
     * @param  string  $column
     * @param  string  $key
     * @return array
     */
    protected function getListSelect($column, $key)
    {
        $select = is_null($key) ? [$column] : [$column, $key];

        // If the selected column contains a "dot", we will remove it so that the list
        // operation can run normally. Specifying the table is not needed, since we
        // really want the names of the columns as it is in this resulting array.
        return array_map(function ($column) {
            $dot = strpos($column, '.');

            return $dot === false ? $column : substr($column, $dot + 1);
        }, $select);
    }

    /**
     * Concatenate values of a given column as a string.
     *
     * @param  string  $column
     * @param  string  $glue
     * @return string
     */
    public function implode($column, $glue = null)
    {
        if (is_null($glue)) {
            return implode($this->lists($column));
        }

        return implode($glue, $this->lists($column));
    }

    /**
     * Determine if any rows exist for the current query.
     *
     * @return bool
     */
    public function exists()
    {
        $limit = $this->limit;

        $result = $this->limit(1)->count() > 0;

        $this->limit($limit);

        return $result;
    }

    /**
     * Retrieve the "count" result of the query.
     *
     * @param  string  $columns
     * @return int
     */
    public function count($columns = '*')
    {
        if (!is_array($columns)) {
            $columns = [$columns];
        }

        return (int) $this->aggregate(__FUNCTION__, $columns);
    }

    /**
     * Retrieve the minimum value of a given column.
     *
     * @param  string  $column
     * @return float|int
     */
    public function min($column)
    {
        return $this->aggregate(__FUNCTION__, [$column]);
    }

    /**
     * Retrieve the maximum value of a given column.
     *
     * @param  string  $column
     * @return float|int
     */
    public function max($column)
    {
        return $this->aggregate(__FUNCTION__, [$column]);
    }

    /**
     * Retrieve the sum of the values of a given column.
     *
     * @param  string  $column
     * @return float|int
     */
    public function sum($column)
    {
        $result = $this->aggregate(__FUNCTION__, [$column]);

        return $result ?: 0;
    }

    /**
     * Retrieve the average of the values of a given column.
     *
     * @param  string  $column
     * @return float|int
     */
    public function avg($column)
    {
        return $this->aggregate(__FUNCTION__, [$column]);
    }

    /**
     * Execute an aggregate function on the database.
     *
     * @param  string  $function
     * @param  array   $columns
     * @return float|int
     */
    public function aggregate($function, $columns = ['*'])
    {
        $this->aggregate = compact('function', 'columns');

        $previousColumns = $this->columns;

        $results = $this->get($columns);

        // Once we have executed the query, we will reset the aggregate property so
        // that more select queries can be executed against the database without
        // the aggregate value getting in the way when the grammar builds it.
        $this->aggregate = null;

        $this->columns = $previousColumns;

        if (isset($results[0])) {
            $result = array_change_key_case((array) $results[0]);

            return $result['aggregate'];
        }
    }

    /**
     * Insert a new record into the database.
     *
     * @param  array  $values
     * @return bool
     */
    public function insert(array $values)
    {
        if (empty($values)) {
            return true;
        }

        // Since every insert gets treated like a batch insert, we will make sure the
        // bindings are structured in a way that is convenient for building these
        // inserts statements by verifying the elements are actually an array.
        if (!is_array(reset($values))) {
            $values = [$values];
        }

        // Since every insert gets treated like a batch insert, we will make sure the
        // bindings are structured in a way that is convenient for building these
        // inserts statements by verifying the elements are actually an array.
        else {
            foreach ($values as $key => $value) {
                ksort($value);
                $values[$key] = $value;
            }
        }

        // We'll treat every insert like a batch insert so we can easily insert each
        // of the records into the database consistently. This will make it much
        // easier on the grammars to just handle one type of record insertion.
        $bindings = [];

        foreach ($values as $record) {
            foreach ($record as $value) {
                $bindings[] = $value;
            }
        }

        $sql = $this->grammar->compileInsert($this, $values);

        // Once we have compiled the insert statement's SQL we can execute it on the
        // connection and return a result as a boolean success indicator as that
        // is the same type of result returned by the raw connection instance.
        $bindings = $this->cleanBindings($bindings);

        return $this->connection->insert($sql, $bindings);
    }

    /**
     * Insert a new record and get the value of the primary key.
     *
     * @param  array   $values
     * @param  string  $sequence
     * @return int
     */
    public function insertGetId(array $values, $sequence = null)
    {
        $sql = $this->grammar->compileInsertGetId($this, $values, $sequence);

        $values = $this->cleanBindings($values);

        return $this->processor->processInsertGetId($this, $sql, $values, $sequence);
    }

    /**
     * Update a record in the database.
     *
     * @param  array  $values
     * @return int
     */
    public function update(array $values)
    {
        $bindings = array_values(array_merge($values, $this->getBindings()));

        $sql = $this->grammar->compileUpdate($this, $values);

        return $this->connection->update($sql, $this->cleanBindings($bindings));
    }

    /**
     * Increment a column's value by a given amount.
     *
     * @param  string  $column
     * @param  int     $amount
     * @param  array   $extra
     * @return int
     */
    public function increment($column, $amount = 1, array $extra = [])
    {
        $wrapped = $this->grammar->wrap($column);

        $columns = array_merge([$column => $this->raw("$wrapped + $amount")], $extra);

        return $this->update($columns);
    }

    /**
     * Decrement a column's value by a given amount.
     *
     * @param  string  $column
     * @param  int     $amount
     * @param  array   $extra
     * @return int
     */
    public function decrement($column, $amount = 1, array $extra = [])
    {
        $wrapped = $this->grammar->wrap($column);

        $columns = array_merge([$column => $this->raw("$wrapped - $amount")], $extra);

        return $this->update($columns);
    }

    /**
     * Delete a record from the database.
     *
     * @param  mixed  $id
     * @return int
     */
    public function delete($id = null)
    {
        // If an ID is passed to the method, we will set the where clause to check
        // the ID to allow developers to simply and quickly remove a single row
        // from their database without manually specifying the where clauses.
        if (!is_null($id)) {
            $this->where('id', '=', $id);
        }

        $sql = $this->grammar->compileDelete($this);

        return $this->connection->delete($sql, $this->getBindings());
    }

    /**
     * Run a truncate statement on the table.
     *
     * @return void
     */
    public function truncate()
    {
        foreach ($this->grammar->compileTruncate($this) as $sql => $bindings) {
            $this->connection->statement($sql, $bindings);
        }
    }

    /**
     * Get a new instance of the query builder.
     *
     * @return \Illuminate\Database\Query\Builder
     */
    public function newQuery()
    {
        return new static($this->connection, $this->grammar, $this->processor);
    }

    /**
     * Merge an array of where clauses and bindings.
     *
     * @param  array  $wheres
     * @param  array  $bindings
     * @return void
     */
    public function mergeWheres($wheres, $bindings)
    {
        $this->wheres = array_merge((array) $this->wheres, (array) $wheres);

        $this->bindings['where'] = array_values(array_merge($this->bindings['where'], (array) $bindings));
    }

    /**
     * Remove all of the expressions from a list of bindings.
     *
     * @param  array  $bindings
     * @return array
     */
    protected function cleanBindings(array $bindings)
    {
        return array_values(array_filter($bindings, function ($binding) {
            return !$binding instanceof Expression;
        }));
    }

    /**
     * Create a raw database expression.
     *
     * @param  mixed  $value
     * @return \Illuminate\Database\Query\Expression
     */
    public function raw($value)
    {
        return $this->connection->raw($value);
    }

    /**
     * Get the current query value bindings in a flattened array.
     *
     * @return array
     */
    public function getBindings()
    {
        return Arr::flatten($this->bindings);
    }

    /**
     * Get the raw array of bindings.
     *
     * @return array
     */
    public function getRawBindings()
    {
        return $this->bindings;
    }

    /**
     * Set the bindings on the query builder.
     *
     * @param  array   $bindings
     * @param  string  $type
     * @return $this
     *
     * @throws \InvalidArgumentException
     */
    public function setBindings(array $bindings, $type = 'where')
    {
        if (!array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }

        $this->bindings[$type] = $bindings;

        return $this;
    }

    /**
     * Add a binding to the query.
     *
     * @param  mixed   $value
     * @param  string  $type
     * @return $this
     *
     * @throws \InvalidArgumentException
     */
    public function addBinding($value, $type = 'where')
    {
        if (!array_key_exists($type, $this->bindings)) {
            throw new InvalidArgumentException("Invalid binding type: {$type}.");
        }

        if (is_array($value)) {
            $this->bindings[$type] = array_values(array_merge($this->bindings[$type], $value));
        } else {
            $this->bindings[$type][] = $value;
        }

        return $this;
    }

    /**
     * Merge an array of bindings into our bindings.
     *
     * @param  \Illuminate\Database\Query\Builder  $query
     * @return $this
     */
    public function mergeBindings(Builder $query)
    {
        $this->bindings = array_merge_recursive($this->bindings, $query->bindings);

        return $this;
    }

    /**
     * Get the database connection instance.
     *
     * @return \Illuminate\Database\ConnectionInterface
     */
    public function getConnection()
    {
        return $this->connection;
    }

    /**
     * Get the database query processor instance.
     *
     * @return \Illuminate\Database\Query\Processors\Processor
     */
    public function getProcessor()
    {
        return $this->processor;
    }

    /**
     * Get the query grammar instance.
     *
     * @return \Illuminate\Database\Query\Grammars\Grammar
     */
    public function getGrammar()
    {
        return $this->grammar;
    }

    /**
     * Use the write pdo for query.
     *
     * @return $this
     */
    public function useWritePdo()
    {
        $this->useWritePdo = true;

        return $this;
    }

    /**
     * Handle dynamic method calls into the method.
     *
     * @param  string  $method
     * @param  array   $parameters
     * @return mixed
     *
     * @throws \BadMethodCallException
     */
    public function __call($method, $parameters)
    {
        if (Str::startsWith($method, 'where')) {
            return $this->dynamicWhere($method, $parameters);
        }

        $className = get_class($this);

        throw new BadMethodCallException("Call to undefined method {$className}::{$method}()");
    }
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ - 1157 LITTLE SHOP OF FLOWERS
题目大意: F束花插入V个瓶子里面，花要按编号插，不同花插入不同的花瓶有不同的美观程度，要求最大的美观程度。
解题思路: 状态函数为f[i][j]表示第i束花插入前j个瓶子里面。则状态转移函数为f[i][j]=max(f[i-1][j-1]+a[i][j],f[i][j-1])
因为有两种插法，一：第i束花插入第j个瓶子里面，则为f[i][j]=f[i-1][j-1]+a[i][j].二：第i束花不插入第j个瓶子里面，则f[i][j]=f[i][j-1]。两者当中取极大者
#include <cstdio>
#include <algorithm>
using namespace std;

int main() {
    int F, V;
    while (scanf("%d%d", &F, &V) != EOF) {
        int A, cur = 0, pre = 1, DP[2][110] = {-0x3f3f3f3f};
        for (int i = 1; i <= F; i++) {
            for (int j = 1; j <= V; j++) {
                scanf("%d", &A);
                if (j >= i && j <= V - F + i)
                    DP[cur][j] = max(DP[cur][j-1], DP[pre][j-1] + A);
                else 
                    DP[cur][j] = -0x3f3f3f3f;
            }
            swap(cur, pre);
        }
        printf("%d\n", DP[pre][V]);
    }
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5289 Assignment （二分+区间最值）
【题目链接】click here~~
【题目大意】：
给出一个数列，问其中存在多少连续子序列，子序列的最大值-最小值<k

【思路】：枚举数列左端点，然后二分枚举右端点，用ST算法求区间最值。（或用单调队列的思路）
代码：

#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
typedef long long LL;
#define Max(a,b) a>b?a:b
#define Min(a,b) a>b?b:a
#define mem(a,b) memset(a,b,sizeof(a))
int arr[N];
int n,k,m,tmp;
int dp_max[N][20],dp_min[N][20];
void rmq_init(){
    for(int i=1; i<=n; ++i) dp_max[i][0]=dp_min[i][0]=arr[i];
    double limit=log(n)/log(2.0);  // 换底公式
    for(int j=1; j<=(int)limit; ++j){
        for(int i=1; i+(1<<j)-1<=n; ++i){
            dp_max[i][j]=Max(dp_max[i][j-1],dp_max[i+(1<<(j-1))][j-1]);
            dp_min[i][j]=Min(dp_min[i][j-1],dp_min[i+(1<<(j-1))][j-1]);
        }
    }
}

int rmq_max(int L,int R){   // 查询[L,R]之间的最大值
    int k=floor(log2((double)(R-L+1)));
    return Max(dp_max[L][k], dp_max[R - (1<<k) + 1][k]);
}

int rmq_min(int L, int R){   // 查询[L,R]之间的最小值
    int k=floor(log2((double)(R-L+1)));
    return Min(dp_min[L][k], dp_min[R - (1<<k) + 1][k]);
}

int solve(int L,int R){
    int k=floor(log2((double)(R-L+1)));
    int maxx=Max(dp_max[L][k],dp_max[R - (1<<k) + 1][k]);
    int minn=Min(dp_min[L][k],dp_min[R - (1<<k) + 1][k]);
    return maxx-minn;
}

inline LL read(){
    int c=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){c=c*10+ch-'0';ch=getchar();}
    return c*f;
}

int main(){
    int t;t=read();
    while(t--){
        n=read();k=read();
        for(int i=1; i<=n; ++i){
            arr[i]=read();
        }
        rmq_init();
        LL ans=0;
        for(int i=1; i<=n; ++i){//枚举左端点，二分右端点,ST求最值
            int ll=i,rr=n;
            while(ll<=rr){
                int mid=(ll+rr)>>1;
                if(solve(i,mid)>=k) rr=mid-1;
                else ll=mid+1;
            }
            if(solve(i,rr)<k)ans+=(rr-i+1);
            else ans+=(ll-i+1);
        }
        printf("%I64d\n",ans);
    } return 0;
}
单调队列：
【思路】：
O(n)复杂度
用两个单调队列维护最大值，最小值，相当于双指针，初始，第一个第二个指针指向第一个数据，第一个指针按顺序不断向队尾添加数据，当最大值最小值的差大于等于k后，意味着新添加的这个不能作用于当前第二个指针的位置，也就能计算出，以第二个指针位置开始的连续子序列的个数，最后统计就可以了。

代码：
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
typedef long long LL;
#define Max(a,b) a>b?a:b
#define Min(a,b) a>b?b:a
#define mem(a,b) memset(a,b,sizeof(a))
int arr[N];
int i,j,n,k,m,tmp;
deque <int >deq_max,deq_min;// maxvalue minvalue
inline LL read(){
    int c=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){c=c*10+ch-'0';ch=getchar();}
    return c*f;
}
int main(){
    int t;t=read();
    while(t--){
        n=read();k=read();
        for(int i=0; i<n; ++i){
            arr[i]=read();
        }
        LL ans=0;
        while(!deq_max.empty()) deq_max.pop_back();
        while(!deq_min.empty()) deq_min.pop_back();
        for(i=0,j=0; i<n; ++i){
            while(!deq_max.empty()&&deq_max.back()<arr[i]) deq_max.pop_back();deq_max.push_back(arr[i]);
            while(!deq_min.empty()&&deq_min.back()>arr[i]) deq_min.pop_back();deq_min.push_back(arr[i]);
            while(!deq_max.empty()&&!deq_min.empty()&&deq_max.front()-deq_min.front()>=k){
                ans+=(i-j);
                if(deq_max.front()==arr[j]) deq_max.pop_front();
                if(deq_min.front()==arr[j]) deq_min.pop_front();
                j++;
            }
        }
        while(j<n){
            ans+=(i-j);
            j++;
        }
        printf("%I64d\n",ans);
    } return 0;
}








版权声明：本文为博主原创文章，未经博主允许不得转载。

python 函数

关于函数 
 

同样的代码，一般不写两遍

函数的定义
def：函数名（参数列表）：#可以没有参数 
 函数体 
 
- 当函数设置默认参数的时候，是自右向左的，即默认值都得在右边。可以指定设定某个默认值。 
- 这样不对： 
 
这样指定默认值才对，当指定值的时候，可以不用考虑顺序。 

全局变量

函数返回值

多类型传值
 
- 以上可以看出，函数可以接受多种类型的值
当传递两个函数值的时候 
虽然t中有两个值，但是这样直接传t会报错。 

这种情况可以用以下方式解决： 
 
但是当 t 中有3个或以上的值的时候，就会报错 
- 当一个字典中的key值和函数的形参是对应的话，可以这么传递参数：
>>> dic = {'age':30,'name':"chen"}
>>> def f(name,age):
...     print "name: %s \n age: %s "% (name,age)
...
>>> f(**dic)
name: chen
 age: 30
记住，字典中的key值一定要和形参相对应
函数参数的冗余
 
如果此时，在f 的实参传入一个f（x=10,y = 20），则会报错，因为没有y这个形参 
需要这样做： 

注意，下面的情况要避免： 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

2012 成都网络赛





Control


Time Limit: 1000ms

Memory Limit: 32768KB
64-bit integer IO format: %I64d     
 Java class name: Main


Submit Status PID:
 26307

　　You, the head of Department of Security, recently received a top-secret information that a group of terrorists is planning to transport some WMD 1 from
 one city (the source) to another one (the destination). You know their date, source and destination, and they are using the highway network.
　　The highway network consists of bidirectional highways, connecting two distinct city. A vehicle can only enter/exit the highway network at cities only.
　　You may locate some SA (special agents) in some selected cities, so that when the terrorists enter a city under observation (that is, SA is in this city), they would be caught immediately.
　　It is possible to locate SA in all cities, but since controlling a city with SA may cost your department a certain amount of money, which might vary from city to city, and your budget might not be able to bear the full cost of controlling all cities, you
 must identify a set of cities, that:
　　* all traffic of the terrorists must pass at least one city of the set.
　　* sum of cost of controlling all cities in the set is minimal.
　　You may assume that it is always possible to get from source of the terrorists to their destination.
------------------------------------------------------------
1 Weapon of Mass Destruction



Input
　　There are several test cases.
　　The first line of a single test case contains two integer N and M ( 2 <= N <= 200; 1 <= M <= 20000), the number of cities and the number of highways. Cities are numbered from 1 to N.
　　The second line contains two integer S,D ( 1 <= S,D <= N), the number of the source and the number of the destination.
　　The following N lines contains costs. Of these lines the ith one contains exactly one integer, the cost of locating SA in the ith city to put it under observation. You may assume that the cost is positive and not exceeding 107.
　　The followingM lines tells you about highway network. Each of these lines contains two integers A and B, indicating a bidirectional highway between A and B.
　　Please process until EOF (End Of File).



Output
　　For each test case you should output exactly one line, containing one integer, the sum of cost of your selected set.
　　See samples for detailed information.



Sample Input
5 6
5 3
5
2
3
4
12
1 5
5 4
2 3
2 4
4 3
2 1

Sample Output
3


网络流： 点有权值费用，拆点建边。
#include <cstdio>
#include <queue>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef int MyType;
const int INF = 0x3F3F3F3F;
const int MAXN = 510;
const int MAXE = 100000 + 10;

struct Edge { int to, next; MyType cap; };
Edge es[MAXE];
int head[MAXN], cur[MAXN], level[MAXN], que[MAXN];
int n, m, src, des, cnt;

void add( int u, int v, MyType c ) {
    es[cnt].to = v; es[cnt].cap = c; es[cnt].next = head[u]; head[u] = cnt++;
    es[cnt].to = u; es[cnt].cap = 0; es[cnt].next = head[v]; head[v] = cnt++;
    return ;
}

bool bfs() {
    int mf, me;
    memset( level, 0, sizeof( level ) );
    mf = me = 0;
    que[me++] = src;
    level[src] = 1;
    while( mf < me ) {
        int u = que[mf++];
        for( int i = head[u]; ~i; i = es[i].next ) {
            int v = es[i].to;
            if( level[v] == 0 && es[i].cap > 0 ) {
                level[v] = level[u] + 1;
                que[me++] = v;
            }
        }
    }
    return ( level[des] != 0 );
}

int dfs( int u, int f ) {
    if( u == des || f == 0 ) return f;
    int flow = 0;
    for( int &i = cur[u]; ~i; i = es[i].next ) {
        Edge &e = es[i];
        if( e.cap > 0 && level[e.to] == level[u] + 1 ) {
            int d = dfs( e.to, min( f, e.cap ) );
            if( d > 0 ) {
                e.cap -= d;
                es[i ^ 1].cap += d;
                flow += d;
                f -= d;
                if( f == 0 ) break;
            } else level[e.to] = -1;
        }
    }
    return flow;
}

MyType dinic() {
    MyType ret = 0;
    while( bfs() ) {
        for( int i = 0; i <= 500; ++i ) {
            cur[i] = head[i];
        }
        ret += dfs( src, INF );
    }
    return ret;
}

int main()
{
    int a, b;
    while(~scanf("%d%d%d%d", &n, &m, &src, &des))
    {
        memset(head, -1, sizeof head);
        cnt = 0;
        int tt;
        des += 200;
        for( int i = 1; i <= n; ++i ) {
            scanf( "%d", &tt );
            add( i, i + 200, tt );
        }
        for( int i = 1; i <= m; ++i ) {
            scanf( "%d%d", &a, &b );
            add( a + 200, b, INF );
            add( b + 200, a, INF );
        }
        int ans = dinic();
        printf( "%d\n", ans );
    }
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

ZOJ 3883	Scan Code 模拟


模拟,考虑shift 和 caps 的各种组合



Scan Code

Time Limit: 2 Seconds      Memory Limit: 65536 KB


Edward is writing an editor. After he wrote the function to get input from his special keyboard, he found that what he got is scan code, instead of ASCII code. He is very busy, so he
 gives you the easy task, translate the scan code to a string.
The scan code is very simple, when you press a key, the keyboard will send a make code of this key to computer (if you press the key for a long time, keyboard will send the make code
 to computer many times), and when you release a key, the keyboard will send a brake code of this key to computer. When computer received a make code, a character or function for the key will do on the editor (Caps Lock is off at the beginning) excepted the
 Caps Lock key (do the function when press the key).
Input
Input will consist of multiple test cases.
Each case has one line, the scan code received from keyboard in Hex (scan code table is at Hint section), the length is less than or equal to 1000000.
Input's validation is guaranteed.
Output
For each case, output the string on the editor and put a newline at the end.
Sample input
16F0161216F016F012
16F0161612F016F012

Sample output
1!
11

http://en.wikipedia.org/wiki/Scancode
Here is the scan code table:


Author: LU, Yi
Source: ZOJ Monthly, July 2015
Submit    Status



#include<cstdio>
#include<cstring>
#include<iostream>
#include<map>
#include<string>

using namespace std;

const int maxn=2001000;

char up[54][20]=
{
"~","!","@","#","$","%","^","&","*","(",")","_","+","Backspace",
"Tab","Q","W","E","R","T","Y","U","I","O","P","{","}","|",
"Caps","A","S","D","F","G","H","J","K","L",":","\"","Enter",
"LShift","Z","X","C","V","B","N","M","<",">","?","RShift","Space"
};

char down[54][20]=
{
"`","1","2","3","4","5","6","7","8","9","0","-","=","Backspace",
"Tab","q","w","e","r","t","y","u","i","o","p","[","]","\\",
"Caps","a","s","d","f","g","h","j","k","l",";","'","Enter",
"LShift","z","x","c","v","b","n","m",",",".","/","RShift","Space"
};

string Value[54]=
{
"0E","16","1E","26","23","2E","36","3D","3E","46","22","4E","55","66","0D","15","1D","24",
"2C","2D","35","3C","43","44","4D","54","5B","5D","58","1C","1B","25","2B","33","34","3B",
"42","4B","4C","52","5A","12","1A","45","29","2A","32","31","3A","41","49","4A","59","21"
};

map<string,int> msi;

void init()
{
    for(int i=0;i<54;i++) msi[Value[i]]=i;
}

int st,ed;
int shL,shR;
int cap;
char input[maxn];
char output[maxn];

int main()
{
    init();

/*
    string in;
    while(cin>>in)
    {
        int id=msi[in];
        cout<<id<<": "<<up[id]<<endl;
    }
*/

    while(scanf("%s",input)!=EOF)
    {
        int len=strlen(input);

        st=0,ed=0; shL=0; shR=0; cap=0;

        int cpp=0;

        string cmd;
        for(int i=0;i<len;i+=2)
        {
            cmd="";
            cmd+=input[i];
            cmd+=input[i+1];

            if(cmd[0]=='F'&&cmd[1]=='0')
            {
                i+=2;
                cmd="";
                cmd+=input[i];
                cmd+=input[i+1];

                int id=msi[cmd];
                string info=up[id];


                if(info=="LShift"||info=="RShift")
                {
                    //cout<<"info: "<<info<<endl;
                    if(info=="LShift") shL=0;
                    else if(info=="RShift") shR=0;
                }
                else if(info=="Caps")
                {
                    cpp=0;
                }
            }
            else
            {
                int id=msi[cmd];
                string info=up[id];

                //cout<<"info: "<<info<<endl;

                if(info=="Backspace")
                {
                    if(ed>st) ed--;
                }
                else if(info=="Enter")
                {
                    output[ed++]='\n';
                }
                else if(info=="Space")
                {
                    output[ed++]=' ';
                }
                else if(info=="Tab")
                {
                    output[ed++]='\t';
                }
                else if(info=="LShift"||info=="RShift")
                {
                    if(info=="LShift") shL++;
                    if(info=="RShift") shR++;
                }
                else if(info=="Caps")
                {

                    if(cpp==0) cap=cap^1;
                    cpp=1;
                }
                else
                {
                    if(down[id][0]<='z'&&down[id][0]>='a')
                    {
                        int sh=(shL!=0)||(shR!=0);
                        if((sh&&cap)||(sh==0&&cap==0))
                        {
                           output[ed++]=down[id][0];
                        }
                        else
                        {
                            output[ed++]=up[id][0];
                        }
                    }
                    else
                    {
                        int sh=(shL!=0)||(shR!=0);
                        if(sh==0)
                        {
                           output[ed++]=down[id][0];
                        }
                        else
                        {
                            output[ed++]=up[id][0];
                        }
                    }
                }
            }
        }
        output[ed]=0;
        cout<<output<<endl;
    }
    return 0;
}




版权声明：来自: 码代码的猿猿的AC之路 http://blog.csdn.net/ck_boss 

全排列
主要学习下递归的思路，没有考虑重复数的问题



#include<iostream>
using namespace std;
int A[5] = {1,2,3,4,5};
int B[5];
void permutation(int n,int curr)
{
	if (curr == n)
	{
		for (int i = 0; i < n; i++)
			cout << B[i] << " ";
		cout << endl;
		return;
	}
	else
	{
		for (int j = 0; j < n; j++)
		{
			bool flag = true;
			//设置B[curr]为A[j]
			B[curr] = A[j];
			//B[curr]不在集合中时，继续下一次递归
			for (int i = 0; i < curr; i++)
			{
				if (B[curr] == B[i])
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				permutation(n, curr + 1);
			}
		}
	}
}
int main()
{
	permutation(5,0);
	return 0;
}
考虑重复的数


#include<iostream>
#include<algorithm>
using namespace std;
int A[8];//目标集合
int B[8];//候选集合
void permutation(int n,int curr)
{
	if (curr == n)
	{
		for (int i = 0; i < n-1; i++)
			cout << B[i] << " ";
		cout << B[n-1];
		cout << endl;
		return;
	}
	else
	{
		for (int j = 0; j < n; j++)
		{
			if (!j || A[j] != A[j - 1])
			{
				B[curr] = A[j];
				int c1 = 0;//目标集合中包含B[curr]的次数
				int c2 = 0;//候选集合中包含B[curr]的次数
				for (int i = 0; i < curr; i++)
				{
					if (B[i] == A[j])
					{
						c1++;
					}
				}
				for (int i = 0; i < n; i++)
				{
					if (A[i] == A[j])
					{
						c2++;
					}
				}
				if (c1 < c2)
				{
					permutation(n, curr + 1);
				}
			}
			
		}
	}
}
int comp(const void*a, const void*b)
{
	return *(int*)a - *(int*)b;
}
int main()
{
	int N;
	cin >> N;
	for (int i = 0; i < N; i++)
		cin >> A[i];
	qsort(A, N, sizeof(int),comp);
	permutation(N,0);
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

打印一个0到1之间的数的二进制表示

 public static String printBinary(double num)
  {
 if(num>=1||num<=0)
 return "ERROR";
 StringBuilder binary=new StringBuilder();
 binary.append(".");
 while(num>0)
 {
 /*
  *设定长队上限，32个字符
  */
 if(binary.length()>=32)
 return "ERROR";
 double r=num*2;
 if(r>=1)
 {
 binary.append(1);
 num=r-1;
 }
 else
 {
 binary.append(0);
 num=r;
 }
 }
 return binary.toString();
 
  }

上面的做法是将数字乘以2，然后与1进行比较，此外我们还可以将这个数与0.5比较，然后与0.25比较，依此类推。
如下：
public static String printBinary2(double num)
 {
if(num>=1||num<=0)
return "ERROR";
StringBuilder binary=new StringBuilder();
double frac=0.5;
binary.append(".");
while(num>0)
{
/*设定长度上限，32个字符
*/
if(binary.length()>32)
return "ERROR";
if(num>=frac)
{
binary.append(1);
num-=frac;
}
else
{
binary.append(0);
}
frac/=2;
}
return binary.toString();
 }



版权声明：本文为博主原创文章，未经博主允许不得转载。

codeforces 309A Morning run 概率
http://codeforces.com/problemset/problem/309/A 
题意： 
给定n 个人，给定长度为 l 的环形跑道，同时开始跑 t 时间，求相撞次数的期望，注意相撞之后，两个人还是按照原来的方向跑下去。 
分析： 
如果两个人是同向的话肯定是不可能相撞的 
1）如果时间无限的话，那么任意两个人相撞的时间的就是x/2x/2、x/2+l/2x/2 + l/2、x/2+lx/2 + l…. 并且可以知道两个人相撞的概率就是0.5*0.5->0.25。 
2）对于如果t=l/2t = l/2 的时候，在这个时间周期里，任意两个人会相撞一次，而这两个人的方向只需要相对就可以了。概率是0.5。 
思路： 
将 t=k∗l/2+p/2t = k*l/2 + p/2  -> 2t=k∗l+p2t = k*l + p，k表示有几个时间周期为l/2l/2，p就是剩下的。对于k的话，运用上面的分析，每次任意两个人都会撞到1次。总次数为k∗n∗(n−1)/2k*n*(n-1)/2，概率都为0.5。 
剩下p秒，运用分析中的第一种，对于某两个人，如果 p/2<x/2p/2 < x/2 则撞不到，如果 x/2<=p/2x/2 <= p/2  -> p>=xp >= x  撞到一次，如果 p/2>=x/2+l/2p/2 >= x/2 + l/2 撞到两次 但是这里会发现p/2<l/2p/2 < l/2是一定的，所以按照这样分解剩下的p秒不可能撞到两次。 
因为我们将时间分解成了l/2l/2为周期的，这样可以去掉剩下的时间碰撞两次的情况。 
现在考虑如何快速的判断剩下p秒中任意两个人能否多撞1次。 
将原本的数组扩展，在后面i+n的位置接着存下a[i]+l的值。这样就将两个不同的方向也归一了，举个例子比如 l = 7 两个人 0 , 3, 这其实是有两个距离的一个是3，一个是4，但是运用这样的方法就可以 判断a[0] 与 a[1]的关系解决了一个方向，判断a[1] 与 a[2] 就解决了另一个方向的问题。 
尾指针枚举每一个人i -> 0~n，头指针0~2*n （或者0~i+n，不过对于每次i 一定不会超过 i+n ，因为p < l）往前移动 直到不能多撞一次，将次数加上可以多撞一次的个数。
#include <cstdio>
#include <algorithm>
#define M 10000009
int a[M];
int main()
{
    int n,l,t;
    while(scanf("%d %d %d",&n,&l,&t) == 3)
    {
        for(int i = 0;i < n;i++)
        {
            scanf("%d",&a[i]);
            a[i+n] = a[i] + l;
        }
        int k = 2*t/l;
        int p = 2*t%l;
        double ans = (double)k*n*(n-1);
        for(int i = 0,j = 0;i < n;i++)
        {
            while(j < 2*n && a[j] - a[i] <= p)
                j++;
            ans += j-i-1;
        }
        printf("%.10f\n",ans/4);
    }
}

之前是写的是分解成t=k∗l+pt = k*l + p的，应该也是可以的，就是以前写的有思维漏洞，但是水过了数据，将以前的修改了下。。 
将原本的数组扩展，在后面i+n的位置接着存下a[i]+l,i+2n 位置存下a[i]+2l的值。就可以将问题都归一到能否多撞一次中，并且将两个不同的方向也归一了，据上面的例子比如 l = 7 两个人 0 , 3, 这其实是有两个距离的一个是3，一个是4，但是运用这样的方法就可以 判断a[0] 与 a[1],与a[3] 的关系，这样就覆盖了一次和两次的情况，判断a[1] 与 a[2]，与a[4]就解决了另一个方向一次和两次的问题。。。弱菜求指正，严重觉得这样搞可能还有问题。还是分解成2t=k∗l+p2t = k*l + p 将问题更简单的处理
#include <cstdio>
#include <algorithm>
#define M 10000009
int a[M];
int main()
{
    int n,l,t;
    while(scanf("%d %d %d",&n,&l,&t) == 3)
    {
        for(int i = 0;i < n;i++)
        {
            scanf("%d",&a[i]);
            a[i+n] = a[i] + l;
            a[i+2*n] = a[i+n] + l;
        }
        int k = t/l;
        int p = t%l;
        double ans = (double)2*k*n*(n-1);
        for(int i = 0,j = 0;i < n;i++)
        {
            while(j < 3*n && a[j] - a[i] <= 2*p)
                j++;
            if(j > i+n) //i+n 与 i 实际为同一个点
            ans += j-i-1-1;
            else
            ans += j-i-1;
        }
        printf("%.10f\n",ans/4);
    }
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

OpenCV入门笔记（七） 文字区域的提取
前面我们已经学了一些OpenCV中基本的图片处理的知识，可以拿来做一些小应用。比如怎样从一张图片中，把文字圈出来。这一步骤对OCR（Optical Character Recognition）非常有用，因为一般的OCR引擎只是拿来识别文字，并没有对图片做预处理，因此精度可能会收到图片质量影响。
当然，我们这里只是粗略的查找文字区域，并没有进一步地处理图片。而且对背景复杂，或者文字旋转角度过于倾斜的情况也无法自适应，因此只能给大家做参考。若要实用到项目中，还有很多工作要做。

效果图
比如我们有下面的一篇文章的截图，想把其中的文字区域全部找出来。


当然这里的截图只有文字和白花花的背景，效果会非常好。绿色的的矩形框的是我们根据检测到的文字区域，手动画出来的。


原理
那么我们是怎么做到检测到区域的呢？
首先，我们会注意到，文字区域和其他的图片背景很不一样。我们用膨胀处理图片，让文字变成一块块大区域，然后识别整块的轮廓，用矩形去框住这个轮廓。
这个程序分三个子函数，detect（检测），preprocess（图片预处理），findTextRegion（查找和筛选文字区域）。即main函数调用detect函数去实际完成文字区域检测。detect函数又分成preprocess和findTextRegion两个步骤来做。
见下面的序列图，可能会清晰点。
Created with Raphaël 2.1.0mainmaindetectdetectpreprocesspreprocessfindTextRegionfindTextRegion检测文本区域返回检测到的文本矩形Sobel，二值化，膨胀和腐蚀Morphology方法预处理图片返回预处理后的图片轮廓检测，去掉面积小的，过长的查找和筛选文字区域返回区域box的坐标

1. Detect
先来看main函数和Detect函数
def detect(img):
    # 1.  转化成灰度图
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # 2. 形态学变换的预处理，得到可以查找矩形的图片
    dilation = preprocess(gray)

    # 3. 查找和筛选文字区域
    region = findTextRegion(dilation)

    # 4. 用绿线画出这些找到的轮廓
    for box in region:
        cv2.drawContours(img, [box], 0, (0, 255, 0), 2)

    cv2.namedWindow("img", cv2.WINDOW_NORMAL)
    cv2.imshow("img", img)

    # 带轮廓的图片
    cv2.imwrite("contours.png", img)

    cv2.waitKey(0)
    cv2.destroyAllWindows()


if __name__ == '__main__':
    # 读取文件
    imagePath = sys.argv[1]
    img = cv2.imread(imagePath)
    detect(img)

2. Preprocess
利用数学形态学（Morphology）进行预处理。
这个过程很重要，是文字区域检测效果好坏的核心代码，尤其是一下几个参数：

膨胀的核函数大小，这里用了 30 x 9，可以调节
腐蚀的核函数大小，这里用了 24 x 6，可以调节

def preprocess(gray):
    # 1. Sobel算子，x方向求梯度
    sobel = cv2.Sobel(gray, cv2.CV_8U, 1, 0, ksize = 3)
    # 2. 二值化
    ret, binary = cv2.threshold(sobel, 0, 255, cv2.THRESH_OTSU+cv2.THRESH_BINARY)

    # 3. 膨胀和腐蚀操作的核函数
    element1 = cv2.getStructuringElement(cv2.MORPH_RECT, (30, 9))
    element2 = cv2.getStructuringElement(cv2.MORPH_RECT, (24, 6))

    # 4. 膨胀一次，让轮廓突出
    dilation = cv2.dilate(binary, element2, iterations = 1)

    # 5. 腐蚀一次，去掉细节，如表格线等。注意这里去掉的是竖直的线
    erosion = cv2.erode(dilation, element1, iterations = 1)

    # 6. 再次膨胀，让轮廓明显一些
    dilation2 = cv2.dilate(erosion, element2, iterations = 3)

    # 7. 存储中间图片 
    cv2.imwrite("binary.png", binary)
    cv2.imwrite("dilation.png", dilation)
    cv2.imwrite("erosion.png", erosion)
    cv2.imwrite("dilation2.png", dilation2)

    return dilation2


3. findTextRegion
def findTextRegion(img):
    region = []

    # 1. 查找轮廓
    contours, hierarchy = cv2.findContours(img, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # 2. 筛选那些面积小的
    for i in range(len(contours)):
        cnt = contours[i]
        # 计算该轮廓的面积
        area = cv2.contourArea(cnt) 

        # 面积小的都筛选掉
        if(area < 1000):
            continue

        # 轮廓近似，作用很小
        epsilon = 0.001 * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, epsilon, True)

        # 找到最小的矩形，该矩形可能有方向
        rect = cv2.minAreaRect(cnt)
        print "rect is: "
        print rect

        # box是四个点的坐标
        box = cv2.cv.BoxPoints(rect)
        box = np.int0(box)

        # 计算高和宽
        height = abs(box[0][1] - box[2][1])
        width = abs(box[0][0] - box[2][0])

        # 筛选那些太细的矩形，留下扁的
        if(height > width * 1.2):
            continue

        region.append(box)

    return region


完整代码
加上头文件，把几个函数合并以后，贴在这里。注意开头要写明用utf8编码，不然中文注释可能不会被系统识别。而且Python没有花括号来控制流程，所以对看不见的Tab缩进很敏感，写代码的时候要规范。
直接在终端里敲下面的命令，既可以运行

python textDetection.py ./pic/1.png

代码：textDetection.py
# coding:utf8

import sys

import cv2
import numpy as np

def preprocess(gray):
    # 1. Sobel算子，x方向求梯度
    sobel = cv2.Sobel(gray, cv2.CV_8U, 1, 0, ksize = 3)
    # 2. 二值化
    ret, binary = cv2.threshold(sobel, 0, 255, cv2.THRESH_OTSU+cv2.THRESH_BINARY)

    # 3. 膨胀和腐蚀操作的核函数
    element1 = cv2.getStructuringElement(cv2.MORPH_RECT, (30, 9))
    element2 = cv2.getStructuringElement(cv2.MORPH_RECT, (24, 6))

    # 4. 膨胀一次，让轮廓突出
    dilation = cv2.dilate(binary, element2, iterations = 1)

    # 5. 腐蚀一次，去掉细节，如表格线等。注意这里去掉的是竖直的线
    erosion = cv2.erode(dilation, element1, iterations = 1)

    # 6. 再次膨胀，让轮廓明显一些
    dilation2 = cv2.dilate(erosion, element2, iterations = 3)

    # 7. 存储中间图片 
    cv2.imwrite("binary.png", binary)
    cv2.imwrite("dilation.png", dilation)
    cv2.imwrite("erosion.png", erosion)
    cv2.imwrite("dilation2.png", dilation2)

    return dilation2


def findTextRegion(img):
    region = []

    # 1. 查找轮廓
    contours, hierarchy = cv2.findContours(img, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # 2. 筛选那些面积小的
    for i in range(len(contours)):
        cnt = contours[i]
        # 计算该轮廓的面积
        area = cv2.contourArea(cnt) 

        # 面积小的都筛选掉
        if(area < 1000):
            continue

        # 轮廓近似，作用很小
        epsilon = 0.001 * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, epsilon, True)

        # 找到最小的矩形，该矩形可能有方向
        rect = cv2.minAreaRect(cnt)
        print "rect is: "
        print rect

        # box是四个点的坐标
        box = cv2.cv.BoxPoints(rect)
        box = np.int0(box)

        # 计算高和宽
        height = abs(box[0][1] - box[2][1])
        width = abs(box[0][0] - box[2][0])

        # 筛选那些太细的矩形，留下扁的
        if(height > width * 1.2):
            continue

        region.append(box)

    return region


def detect(img):
    # 1.  转化成灰度图
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # 2. 形态学变换的预处理，得到可以查找矩形的图片
    dilation = preprocess(gray)

    # 3. 查找和筛选文字区域
    region = findTextRegion(dilation)

    # 4. 用绿线画出这些找到的轮廓
    for box in region:
        cv2.drawContours(img, [box], 0, (0, 255, 0), 2)

    cv2.namedWindow("img", cv2.WINDOW_NORMAL)
    cv2.imshow("img", img)

    # 带轮廓的图片
    cv2.imwrite("contours.png", img)

    cv2.waitKey(0)
    cv2.destroyAllWindows()


if __name__ == '__main__':
    # 读取文件
    imagePath = sys.argv[1]
    img = cv2.imread(imagePath)
    detect(img)



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 2824 The Euler function
The Euler function
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4548    Accepted Submission(s): 1895


Problem Description
The Euler function phi is an important kind of function in number theory, (n) represents the amount of the numbers which are smaller than n and coprime to n, and this function has a lot of beautiful characteristics. Here comes a very
 easy question: suppose you are given a, b, try to calculate (a)+ (a+1)+....+ (b)
 

Input
There are several test cases. Each line has two integers a, b (2<a<b<3000000).
 

Output
Output the result of (a)+ (a+1)+....+ (b)
 

Sample Input

3 100

 

Sample Output

3042

 

代码：
 
#include<stdio.h>
#define MAX 3000010
long long euler[MAX];
int init()
{
	int i,j;
	for(i=2;i<MAX;i++)
	{
		if(!euler[i])
		{
			for(j=i;j<MAX;j+=i)
			{
				if(!euler[j])
				euler[j]=j;
				euler[j]=euler[j]/i*(i-1);
			}
		}
		euler[i]+=euler[i-1];
	}
}
int main()
{
	int a,b;
	init();
	while(scanf("%d%d",&a,&b)!=EOF)
	{
		printf("%lld\n",euler[b]-euler[a-1]);
	}
	return 0;
}

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

ZOJ3876 May Day Holiday
             题目大意：求输入年份的那一年的五一劳动节，在Marjar University 的学生能够休息多少天。。。
         题目并不难，只需要我们知道一个小常识：闰年的一年有366天，而判定闰年的前提是能被4整除但不能被100整除、或者能被400整除即为
闰年。那么这样一来实现起来就容易了，以某一年的五一是星期几为基准，我们判定它与输入年份之间相隔多少天，如果时间是往后退那么这
一年五一开始的一天一定等于基准年的星期加上相隔天数再mod（7）就能知道了。反之如果是往前推，那么就用基准年五一开始的星期减去相
隔天数mod（7）便可得出结果。
         实现很快，我还是WA了7次。。。
        光考虑题目说的情况去了，一直以为自己的做题方法有问题。其实再看看题会发现除了题目说的三种情况。星期二也是可以休息6天的。

May Day Holiday

Time Limit: 2 Seconds      Memory Limit: 65536 KB


As a university advocating self-learning and work-rest balance, Marjar University has so many days of rest, including holidays and weekends. Each weekend, which consists of Saturday and
 Sunday, is a rest time in the Marjar University.
The May Day, also known as International Workers' Day or International Labour Day, falls on May 1st. In Marjar University, the May Day holiday is a five-day vacation from May 1st to May
 5th. Due to Saturday or Sunday may be adjacent to the May Day holiday, the continuous vacation may be as long as nine days in reality. For example, the May Day in 2015 is Friday so the continuous vacation is only 5 days (May 1st to May 5th). And the May Day
 in 2016 is Sunday so the continuous vacation is 6 days (April 30th to May 5th). In 2017, the May Day is Monday so the vacation is 9 days (April 29th to May 7th). How excited!
Edward, the headmaster of Marjar University, is very curious how long is the continuous vacation containing May Day in different years. Can you help him?
Input
There are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case, there is an integer y (1928
 <= y <= 9999) in one line, indicating the year of Edward's query.
Output
For each case, print the number of days of the continuous vacation in that year.
Sample Input
3
2015
2016
2017

Output
5
6
9



#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
int yy(int n){
	if((n%4==0&&n%100!=0)||n%400==0)
	  return 1;
	else return 0;
}
void d(int n)
{
	if(n==1) printf("9\n");
	else if(n==0||n==2) printf("6\n");
	else  printf("5\n");
}
int main(){
	int T,year,nowyear,day,sum;
	year=2015,day=5;
	cin>>T;
	while(T--){
		sum=0;
		cin>>nowyear;
		if(nowyear==year) 
			d(day);
		else if(nowyear>year){
			for(int i=year+1;i<=nowyear;i++)
			  {
			  	  if(yy(i)) sum+=366;
			  	  else sum+=365;
			  }
			    	int t=(sum+day)%7;
			    //	cout<<t<<endl;

			d(t);
	
		}
		else if(nowyear<year){
			for(int i=year;i>nowyear;i--)
			  {
			  	  if(yy(i)) sum+=366;
			  	  else sum+=365;
			  }
	         // cout<<sum<<"dd"<<endl;
			  	int t=(sum)%7;
			  	t=day-t;
			  	if(t<0)
			  	t+=7;
	//cout<<t<<endl;
			d(t);
		}
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

背包问题2《模版》
01背包模版：
memset(f,0,sizeof(f));
		for(i=1;i<=n;i++)
		    for(j=v;j>=volume[i];j--)
		    {
		    	f[j]=max(f[j],f[j-volume[i]]+value[i]);
		    }
		printf("%ld\n",f[v]);

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

奖学金

时间限制: 1 Sec  内存限制:
128 MB
提交: 43  解决: 27
[提交][状态][讨论版]
题目描述

某校发放奖学金共5种，获取条件各不同：

1.AK奖学金，每人8000，期末平均成绩>80，且在本学期发表论文大于等于1篇； 
2.AC奖学金，每人4000，期末平均成绩>85，且班级评议成绩>80； 
3.成绩优秀奖，每人2000，期末平均成绩>90； 
4.西部奖学金，每人1000，期末平均成绩>85的西部省份学生； 
5.班级贡献奖，每人850，班级评议成绩>80的学生干部。 
只要符合条件就可以得奖，一人可兼得多项奖学金。例：某生，期末平均成绩87，班级评议成绩82，且是学生干部，则可同时获得AC奖学金和班级贡献奖，奖金总数4850。现给出若干学生的姓名、期末平均成绩、班级评议成绩、是否学生干部、是否西部省份学生、发表论文数。计算哪个同学获得的奖金总数最高？有多个最高值则输出第一个出现的。

输入

第一行是一个整数n（1 <= n <= 10），表示学生的总数。接下来的n行,每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过20的字符串（不含空格）；期末平均成绩和班级评议成绩都是0到100之间的整数（包括0和100）；是否是学生干部和是否是西部省份学生分别用一个字符表示，Y表示是，N表示不是；发表的论文数是0到10的整数（包括0和10）。每两个相邻数据项之间用一个空格分隔。

输出

输出包括三行，第一行是获得最多奖金的学生的姓名，第二行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。第三行是这n个学生获得的奖学金的总数。

样例输入

4
YaoLin 87 82 Y N 0
ChenRuiyi 88 78 N Y 1
LiXin 92 88 N N 0
ZhangQin 83 87 Y N 1


样例输出

ChenRuiyi
9000
28700





#include<stdio.h> 
#include<string.h> 
int main() 
{ 
    char a[100],name[100],ok1,ok2; 
    int n,x,y,num; 
    while(scanf("%d",&n)!=EOF) 
    { 
        int sum,total=0,max=0; 
        for(int i=0;i<n;i++) 
        { 
            sum=0; 
            scanf("%s%d%d %c %c %d",a,&x,&y,&ok1,&ok2,&num); 
            if(x<=80&&y<=80) 
                continue; 
            if(x>80&&num>0) 
            sum+=8000; 
            if(x>85&&y>80) 
            { 
                sum+=4000; 
              
            } 
            if(y>80&&ok1=='Y') 
                sum+=850; 
            if(x>85&&ok2=='Y') 
                sum+=1000; 
            if(x>90) 
                sum+=2000; 
            total+=sum; 
            if(sum>max) 
            { 
                max=sum; 
                strcpy(name,a); 
            } 
        } 
        printf("%s\n%d\n%d",name,max,total); 
    } 
    return 0; 
} 
/************************************************************** 
    Problem: 1589 
    Language: C++ 
    Result: 正确 
    Time:4 ms 
    Memory:816 kb 
****************************************************************/



版权声明：本文为博主原创文章，未经博主允许不得转载。

【JavaSE】day03_Date、SimpleDateFormat、Calendar、Collection
【JavaSE】day03_Date、SimpleDateFormat、Calendar、Collection


1.Date及其常用API
1)JAVA 中的时间
Java中的时间使用标准类库的Date类表示，是用距离一个固定时间点的毫秒数（可正可负，long类型）表达一个特定的时间点。
固定的时间点叫纪元（epoch），是UTC时间1970年 1月 1日 00:00:00。
UTC（Universal Time Coordinated世界调整时间）与GMT（Greenwich Mean Time格林威治时间）一样，是一种具有实际目的的科学标准时间。


2)Date类简介
java.util.Date 类封装日期及时间信息。
Date类的大多数用于进行时间分量计算的方法已经被Calendar取代。


3)setTime与getTime方法
void setTime(long time):
该方法用于为一个Date对象设置其需要表示的时间，该参数为一个long值，其含义是需要表示的这个时间点距离1970年1月1日 00:00:00之间的毫秒差。
long getTime()
该方法用于获取一个Date对象所表示的时间点，该返回值为一个long值，表示该时间点距离1970年1月1日 00:00:00之间的毫秒差。


4) Date 重写 toString方法

Date重写了toString()方法，用一个字符串来描述当前Date对象所表示的时间。
格式如下:
    Mon Feb 17 15:36:55 CST 2014
代码演示：
package day03;

import java.util.Date;

/**
 * java.util.Date
 * 其每一个实例用于表示一个时间点
 * 内部维护一个long值，该值是从UTC时间的1970/01/01 00：00：00
 * 至当前Date表示的时间点之间的毫秒差
 *
 */
public class DateDemo01 {
	public static void main(String[] args) {
		/*
		 * 默认创建出来的Date实例表示当前系统时间
		 */
		Date date = new Date();
		/*
		 * Date类重写类toString，只是对于非英语国家来说不是很友好
		 */
		System.out.println(date); //Mon Aug 24 21:37:16 CST 2015
		
		/*
		 * 获取Date内部维护的long值
		 */
		long longTime = date.getTime();
		System.out.println(longTime); //1440423436050
		
		//表示明天当前时间
		longTime += 1000*60*60*24;
		/*
		 * 支持传入long值的构造方法
		 * 创建的Date就表示该long值所表示的时间
		 */
		Date tomrrowDate = new Date(longTime);
		System.out.println(tomrrowDate); //Tue Aug 25 21:37:16 CST 2015
		/*
		 * 也可以在现有的Date对象上调用setTime方法
		 * 将long值传入，使其表示这个时间
		 */
		date.setTime(longTime);
		System.out.println(date); //Tue Aug 25 21:37:16 CST 2015
		
	}

}


2.SimpleDateFormat
1）SimpleDateFormat简介

SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -> 文本）、解析（文本 -> 日期）和规范化。
简单的说，SimpleDateFormat就是根据一个特定的日期格式在字符串与Date之间相互转换。


2）日期模式匹配字符串

日期模式的匹配字符串如下表：


例如: yyyy年MM月dd日--HH:mm:ss 可以匹配 2014年01月06日--13:22:41


3）将Date格式化为String

将Date格式化为String，我们需要使用SimpleDateFormat提供的方法:
    String format(Date d)
代码演示：
package day03;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * java.text.SimpleDateFormat
 * 该类的作用是使用给定的字符串格式在Date与String之间进行转换。
 * 对于该类，需要掌握：
 * 1：会写日期格式字符串
 * 2：记住两个转换方法（String->Date,Date->String）
 *
 */
public class SimpleDateFormatDemo01 {
	public static void main(String[] args) {
		Date now = new Date();
		System.out.println(now);
		/*
		 * 2015-08-24 09:50:12
		 * yyyy-MM-dd HH:mm:ss
		 */
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss E");
		/*
		 * String format(Date date)
		 * 按照创建SimpleDateFormat时指定的日期格式，
		 * 将当前给定的date对象表示的时间转换为字符串。
		 */
		String str = sdf.format(now);
		System.out.println(str);
	}

}


4）将String解析为Date

将String格式化为Date，我们需要使用SimpleDateFormat提供的方法:
    Date parse(String s)


代码演示：
package day03;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 将字符串按照该日期格式解析为Date
 *
 */
public class SimpleDateFormatDemo02 {
	public static void main(String[] args) {
		String str = "2008-08-08 20:08:08";
		System.out.println(str);
		
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		try {
			/*
			 * Date parse(String str)
			 * 将给定的字符串解析为Date对象并返回。
			 */
			Date date = sdf.parse(str);
			System.out.println(date);
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}

}

3.Calendar类
1）Calendar 简介

java.util.Calendar 类用于封装日历信息，其主要作用在于其方法可以对时间分量进行运算。
Calendar是抽象类，其具体子类针对不同国家的日历系统，其中应用最广泛的是GregorianCalendar（格里高里历，即通用的阳历），对应世界上绝大多数国家/地区使用的标准日历系统。


2）getInstance()方法

Calendar是抽象类，其提供了一个工厂方法:Calendar getInstance()。该方法可以根据当前系统所在地区获取一个适当的Calendar的子类实现。
在实际开发中，也推荐使用该方法来实例化Calendar的对象。


3）setTime与getTime方法

Calendar的void setTime(Date date),允许我们为Calendar设置Date对象所表示的时间。
Calendar的 Date getTime(),允许我们获取一个使用Date对象描述的Calendar所表示的时间。
代码演示：
package day03;

import java.util.Calendar;
import java.util.Date;

/**
 * java.util.Calendar
 * ---public abstract class Calendar
 * 日历类，用作操作时间。
 * 常用的是格里高利历法（阳历）
 * 默认创建出来的Calendar实现类的实例表示当前系统时间
 *
 */
public class CalendarDemo01 {
	public static void main(String[] args) {
		/*
		 * Calendar的getInstance可以根据当前系统所在地区
		 * 创建合适的实现类，通常是格里高利历法。
		 */
		Calendar calendar = Calendar.getInstance();
		
		/*
		 * 不能直观看到具体表示的时间。
		 */
		System.out.println(calendar);
		
		/*
		 * Calendar -> Date
		 * 
		 * Date getTime()
		 * Calendar提供的getTime方法可以将其表示的时间以Date形式返回。
		 */
		Date date = calendar.getTime();
		System.out.println(date);
		
		/*
		 * Date -> Calendar
		 * 
		 * void setTime(Date date)
		 * Calendar提供了一个setTime()方法，可以使当前
		 * Calendar表示给定的date所表示的时间。
		 */
		Date now = new Date();
		calendar.setTime(now);
		System.out.println(calendar);
		
		
		
	}

}

4）设置日期及时间分量

Calendar提供了一种通用的设置时间的方式:
    void set(int field,int value)
该方法可以通过对不同的时间分量分别设置不同的值。Calendar对不同的时间分量提供了相应的常量，我们在使用set方法设置时，第一个参数就应当使用对应的常量作为时间分量。
代码演示：
package day03;

import java.util.Calendar;

/**
 * Calendar提供类一个set方法，允许我们对当前Calendar
 * 的各个时间分量进行单独设定。
 *
 */
public class CalendarSet {
	public static void main(String[] args) {
		Calendar calendar = Calendar.getInstance();
		System.out.println(calendar.getTime());
		
		/*
		 * 设置各个时间分量，
		 * 使其表示：2008/08/08 20：08：08
		 * 需要注意。设置了某个时间分量的值可能会影响其他时间分量的值。
		 * 例如：设置了年、月、日可能会将星期改变。
		 */
		
		//设置年份
		calendar.set(Calendar.YEAR,2008);
		
		//设置月份
		//月份从0开始，有常量对应。0表示1月。。。
		calendar.set(Calendar.MONTH,7);
		
		//设置日
		//Calendar.DATE==Calendar.DAY_OF_MONTH
		calendar.set(Calendar.DAY_OF_MONTH,8);
			
		//设置小时
		//Calendar.HOUR_OF_DAY ：24小时制
		//Calendar.HOUR        ：12小时制
		calendar.set(Calendar.HOUR_OF_DAY,20);
		
		//设置分钟
		calendar.set(Calendar.MINUTE,8);
		
		//设置秒
		calendar.set(Calendar.SECOND,8);
		
		System.out.println(calendar.getTime());
		
	}

}

5） 获取时间分量对应的值

Calendar提供了一种通用的获取时间分量的方式:
    int get(int field)
该方法可以通过对不同的时间分量获取相应的值。Calendar对不同的时间分量提供了相应的常量，我们在使用get方法获取时，参数就应当使用对应的常量作为时间分量。


6）getActualMaximum方法

   int getActualMaximum(int field)方法用于获取给定时间分量所允许的最大值。
代码演示：
package day03;

import java.util.Calendar;

/**
 * Calendar提供了一个get方法，可以获取给定的时间分量所对应的值。
 *
 */
public class CalendarGet {
	public static void main(String[] args) {
		Calendar calendar = Calendar.getInstance();
		
		//获取年
		int year = calendar.get(Calendar.YEAR);
		//获取月,从0开始
		int month = calendar.get(Calendar.MONTH)+1;
		//获取日
		int day = calendar.get(Calendar.DATE);		
		System.out.println(year+"-"+month+"-"+day);
		
		//获取星期，每周第一天从星期日开始（1表示周日）
		int week = calendar.get(Calendar.DAY_OF_WEEK);
		System.out.println(week==1?7:week-1);
		
		/*
		 * int getActualMaximum(int field)
		 * Calendar提供了一个方法，可以获取给定的时间分量
		 * 在当前Calendar表示的日期中所允许的最大值。
		 * 查看当月的月底--Calendar.DAY_OF_MONTH
		 */
		int days = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);
		System.out.println("这个月："+days+"天");
		
		/*
		 * 今年多少天？--Calendar.DAY_OF_YEAR
		 */
		days = calendar.getActualMaximum(Calendar.DAY_OF_YEAR);
		System.out.println("今年共："+days+"天");
		
		
	}

}

7） add方法

Calendar还允许我们使用统一的方式来对某个时间分量的值进行计算。我们需要使用方法 
    void add(int field,int amount)
该方法可以为某个时间分量的值加上给定的值，若想减去给定的值，那么传入的值需要是负数即可。并且计算后会自动进行相应的进位，例如若当前为月底，那么加一天后，为下个月的月初，而月就会进位。
package day03;

import java.util.Calendar;

/**
 * Calendar提供了一个add方法，用于计算时间。
 * void add(int field,int value)
 * 对于给定的时间分量加上给定的值，若value为负数，
 * 则减去指定的值。
 *
 */
public class CalendarAdd {
	public static void main(String[] args) {
		Calendar calendar = Calendar.getInstance();
		//calendar.add(Calendar.YEAR,1);
		System.out.println(calendar.getTime());
		
		/*
		 * 查看3年零2个月又25天是那天？
		 */
		calendar.add(Calendar.YEAR,3);
		calendar.add(Calendar.MONTH,2);
		calendar.add(Calendar.DAY_OF_YEAR,25); //可能会跨年，故用DAY_OF_YEAR
		//calendar.add(Calendar.DATE,25);
		System.out.println(calendar.getTime());
		
		//减去4年
		calendar.add(Calendar.YEAR,-4);
		System.out.println(calendar.getTime());
		
	}

}

4.Collection
java提供了一种可以存数一组数据的数据结构，其提供了丰富的方法，在实际开发中往往比数组使用的广泛。这种数据结构成为集合:Collection。
Collection是一个接口，其定义了集合的相关功能方法。
1） List和Set

Collection派生出了两个子接口，一个是List另一个则是Set。
List:称为可重复集，顾名思义，该集合中是允许存放重复元素的，那么何为重复元素？重复元素指的并非是同一个元素，而是指equals方法比较为true的元素。
Set:称为不可重复集，所以，该集合中是不能将相同的元素存入集合两次，同List，这里相同指的也是两个元素的equals比较结果为true。


2） add()、size()、clear()、isEmpty()方法

Collection定义了一个add方法用于向集合中添加新元素。 该方法定义为:
boolean add(E e)
该方法会将给定的元素添加进集合，若添加成功则返回true,否则返回false。
size方法用于获取当前集合中的元素总数。该方法定义为:int size()
clear方法用于清空集合。该方法定义为:void clear()
isEmpty方法用于判断当前集合中是否不 包含元素。该方法定义为:boolean isEmpty()
代码演示：
package day03;

import java.util.ArrayList;
import java.util.Collection;

/**
 * java.util.Collection
 * 集合，用于存放一组元素。
 * 提供类若干功能，比数组使用方便。
 *
 */
public class CollectionDemo01 {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		
		/*
		 * boolean add(E e)
		 * 将当前集合中添加给定的元素
		 * 若成功添加则返回true
		 */
		c.add("one");
		c.add("two");
		c.add("three");
		c.add("four");
		
		/*
		 * int size()
		 * 获取当前集合中的元素个数
		 */
		System.out.println("size:"+c.size()); //size:4
		
		/*
		 * boolean isEmpty()
		 * 判断当前集合是否不包含任何元素
		 * 当集合中没有元素时返回true
		 */
		boolean b = c.isEmpty();
		System.out.println(b); //false
		
		/*
		 * void clear()
		 * 清空集合元素
		 */
		c.clear();
		System.out.println("size:"+c.size()); //size:0
		System.out.println(c.isEmpty()); //true
		
	}

}

3）contains方法

boolean contains(Object o)
该方法会用于判断给定的元素是否被包含在集合中。若包含则返回true,否则返回false。
这里需要注意的是，集合在判断元素是否被包含在集合中是使用元素的equals的比较结果。
(o==null ? e==null : o.equals(e)) 其中e是集合中的元素。
代码演示：
package day03;

import java.util.ArrayList;
import java.util.Collection;


/**
 * 判断集合是否含有给定的元素
 *
 */
public class CollectionDemo02 {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		c.add(new Aoo("zhangsan",21));
		c.add(new Aoo("lisi",22));
		c.add(new Aoo("wangwu",23));
		
		/*
		 * 集合的toString格式
		 * [元素1.toString(),元素2.toString()...]
		 */
		System.out.println(c); //[zhangsan,21, lisi,22, wangwu,23]
		
		Aoo a = new Aoo("zhangsan",28);
		
		/*
		 * boolean contains(E e)
		 * 判断当前集合是否包含给定元素，包含则返回true
		 * 判断依据是看给定的元素与集合中现有的元素是否
		 * 存在equals比较为true的，有则认为包含！
		 */
		boolean contains = c.contains(a);
		System.out.println("contains:"+contains); //contains:true
		
		
		
	}

}



4）集合持有对象的引用

集合中存储的都是引用类型的元素，那么引用类型变量实际上存储的是对象的“地址”，所以实际上集合只存储了元素对象在堆中的地址。而并不是将对象本身存入了集合中。
代码演示：
package day03;

import java.util.ArrayList;
import java.util.Collection;

public class CollectionDemo03 {
	public static void main(String[] args) {
		Collection c = new ArrayList();
		Aoo o = new Aoo("zhangsan",23);
		c.add(o);
		System.out.println(c); //[zhangsan,23]
		
		o.setName("lisi");
		System.out.println(c); //[lisi,23]
		
	}

}



版权声明：本文为博主原创文章，未经博主允许不得转载。

C++ Vector 简单实现 会用也要会写
我们知道，内存块的大小是不能改变的，因此数组的大小不能改变。但是STL的vector让我们摆脱了这种困扰，它可以帮我们动态的管理数组的大小。
诚然，STL的vector底层还是通过动态数组来实现的，当数组大小不够时，就申请一块更大的内存，同时将原来的元素的值拷贝过去，再删掉原来那块小内存，当然这一操作的带价是非常高的，包括了一次申请内存和释放内存，以及元素的初始化。（更多的一些注意问题可以查看之前的博文http://blog.csdn.net/u011408355/article/details/47060277）
本文给出了Vector类模板的实现，相比于STL的vector模板当然差的远了，但是大致原理差不多了，大家读读下面的代码应该可以让你对STL的vector的理解加深。


template<typename T>
class Vector{
public://构造函数，复制构造函数以及析构函数
Vector(int size=0):theSize(size),theCapacity(0+SPACE_CAPACITY){
objects=new T[theCapacity];
}
Vector(const Vector& rhs):objects(NULL){
operator=(rhs);
}
~Vector(){
delete[] objects;
}

// 重载=号操作符
const Vector& operator=(const Vector& rhs){
theCapacity=rhs.theCapacity;
theSize=rhs.theSize;
objects=new objects[this->theCapacity];
for(int i=0;i<this->theSize;i++)
objects[i]=rhs.objects[i];
return *this;
}

//调整size
void resize(int newSize){
if(newSize>theCapacity)
reserve(newSize*2+1);
theSize=newSize;
}//调整预留的空间，也就是实际上申请的内存的大小
void reserve(int newCapacity){
if(newCapacity<theSize)
return;
T* oldObject=objects;
objects=new T[newCapacity];
theCapacity=newCapacity;
for(int i=0;i<theSize;i++)
objects[i]=oldObject[i];
delete objects;
}

//重载[]操作符
T& operator[](int index){
return *(objects+index);
}
const T& operator[](int index)const{
return *(objects+index);
} //几个get函数，均为const成员，保证const对象也能调用
bool isEmpty() const{
return getSize()==0;
}
int capacity() const{
return theCapacity;
}
int size() const{
return theSize;
}//push和pop操作
void push_back(T t){
if(theSize==theCapacity)
reserve(theCapacity*2+1);
objects[theSize++]=t;
}
void pop_back(){
theSize--;
}
T& back(){
return objects[theSize-1];
}
const T& back()const{
return objects[theSize-1];
}

// 迭代器
typedef T* iterater;
typedef const T* const_iterater;

//begin end 等操作
iterater begin(){
return objects;
}
const_iterater begin() const{
return objects;
}
iterater end(){
return (objects+theSize);
}
const_iterater end() const{
return (objects+theSize);
}
enum { SPACE_CAPACITY=16};
private:
T* objects;
int theSize;
int theCapacity;
};

这里稍微提一下 const成员函数，也称常成员函数，或者只读成员函数，const对象只能访问常成员函数，通过const指针调用也只能访问常成员函数，但是有个特例，构造函数和析构函数是唯一不是const成员函数却可以被const对象调用的成员函数。


若有错误，欢迎指正。

版权声明：本文为博主原创文章，未经博主允许不得转载。

双向链表
#include<iostream>
#include<assert.h>
using namespace std;

typedef int DataType;
class LinkNode
{
    friend class List;
public:
    LinkNode(const DataType& x)
    :_data(x)
    ,_prev(NULL)
    ,_next(NULL)
    {}
private:
    DataType _data;
    LinkNode* _prev;
    LinkNode* _next;
};

class List
{
public:
    List() :_Head(NULL), _Tail(NULL)
    {}
    List(const List& l)
    {}
    ~List()
    {}
    List& operator=(const List &l)
    {}
public:
    void Print()
    {
        LinkNode* begin = _Head;
        while (begin)
        {
            cout << begin->_data << "<->";
            begin = begin->_next;
        }
        cout << "NULL" << endl;
    }
    void PushBack(const DataType& x) //尾插
    {
        //1.没有节点
        //2.多个节点
        if (_Head == NULL)
        {
            _Head = new LinkNode(x);
            _Tail = _Head;
        }
        else
        {
            LinkNode* tmp = new LinkNode(x);
            _Tail->_next = tmp;
            tmp->_prev = _Tail;
            _Tail = tmp;
        }
    }

    void PopBack()
    {
        if (_Head == NULL)
        {
            return;
        }
        if (_Head == _Tail)
        {
            delete _Head;
            _Head = NULL;
            _Tail = NULL;
        }
        else
        {
            LinkNode* del = _Tail;
            _Tail = _Tail->_prev;
            delete del;
            _Tail->_next = NULL;
        }
    }

    void PushFront(const DataType& x)
    {
        //1.没有节点
        //2.多个节点
        if (_Head == NULL)
        {
            _Head = new LinkNode(x);
            _Tail = _Head;
        }
        else
        {
            LinkNode* tmp = new LinkNode(x);
            tmp->_next = _Head;
            _Head->_prev = tmp;
            _Head = tmp;
        }
    }

    void PopFront()
    {
        if (_Head == NULL)
        {
            return;
        }
        if (_Head == _Tail)
        {
            delete _Head;
            _Head = NULL;
            _Tail = NULL;
        }
        else
        {
            LinkNode* del = _Head;
            _Head = _Head->_next;
            delete del;
            _Head->_prev = NULL;
        }
    }

    LinkNode* Find(const DataType& x)
    {
        LinkNode* begin = _Head;
        while (begin)
        {
            if (begin->_data == x)
            {
                cout << "find " << x << endl;
                return begin;
            }
            begin = begin->_next;
        }
        cout << "not find " << x << endl;
        return NULL;
    }
    void Insert(LinkNode* pos, const DataType& x) //在pos的后面插入x
    {
        assert(pos);

        LinkNode* begin = _Head;
        while (begin)
        {
            LinkNode* tmp = new LinkNode(x);
            if (begin == pos)
            {
                if (pos == _Tail)
                {
                    pos->_next = tmp;
                    tmp->_prev = pos;
                    _Tail = tmp;
                }
                else
                {
                    tmp->_prev = pos;
                    tmp->_next = pos->_next;
                    pos->_next = tmp;
                    tmp->_next->_prev = tmp;
                }
            }
            begin = begin->_next;
        }
    }

    void Erase(LinkNode* del)
    {
        assert(del);
        if (_Head == NULL)
        {
            return;
        }
        LinkNode* begin = _Head;
        while (begin)
        {
            if (begin == del)
            {
                if (_Head == _Tail)  //只有一个节点
                {
                    delete del;
                    _Head = NULL;
                    _Tail = NULL;
                    return;
                }
                if (del == _Head)  //删头节点
                {
                    _Head = _Head->_next;
                    delete del;
                    _Head->_prev = NULL;
                    return;
                }
                if (del == _Tail)  //删尾节点
                {
                    _Tail = _Tail->_prev;
                    delete del;
                    _Tail->_next = NULL;
                    return;
                }
                else  //删中间节点
                {
                    del->_prev->_next = del->_next;
                    del->_next->_prev = del->_prev;
                    delete del;
                    return;
                }
            }
            begin = begin->_next;
        }
    }
private:
    LinkNode* _Head;
    LinkNode* _Tail;
};

void Test()
{
    List l1;
    l1.PushBack(1);
    l1.PushBack(2);
    l1.PushBack(3);
    l1.Print();
    l1.PopBack();
    l1.PopBack();
    l1.PopBack();
    /*l1.PopBack();*/
    l1.Print();
}

void Test2()
{
    List l1;
    l1.PushFront(1);
    l1.PushFront(2);
    l1.PushFront(3);
    l1.Print();
    LinkNode* node = l1.Find(4);
    l1.Erase(node);
    /*l1.Insert(node, 4);*/
    l1.Print();
    //l1.PopFront();
    //l1.PopFront();
    //l1.PopFront();
    //l1.PopFront();
    //l1.Print();
}

int main()
{
    Test2();
    getchar();
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

猴子选大王


问题描述：
一群猴子按编号围成一圈，然后从第一只开始数，数到第m只，把他踢出圈，然后再从他后面开始数，数到第m只，再把他踢出圈，如此下去，直到剩下最后一个猴子为止。


算法实现：
<?PHP
	function MonkeyKing($n,$m){
		$monkey = range(1,$n);//生成1-n的数组
		$i = 0;
		while(count($monkey)>1){
			$i++;
			$head = array_shift($monkey);//获得第一个数
			if($i % $m != 0){
				//如果不是m的倍数，则将i放到数组末尾，也即是去掉m。
				$monkey = array_push($monkey,$head);
			}
		}
		return $monkey[0];
	}
	




版权声明：本文为博主原创文章，未经博主允许不得转载。

【MongoDB】-Java实现对mongodb的And、Or、In操作
1）And（同时满足多个条件时用And）
public void testAnd(){      
    DBObject queryCondition = new BasicDBObject();    
    //agender='female' AND age > 27    
    queryCondition.put("agender", "female");    
    queryCondition.put("age", new BasicDBObject("$gt", 27));    
    DBCursor dbCursor = coll.find(queryCondition);       
}    
2）Or（两个条件满足其中一个）
public void testOrSingleField(){    
    DBObject queryCondition = new BasicDBObject();          
    //age<15 OR age>27     
    BasicDBList values = new BasicDBList();    
    values.add(new BasicDBObject("age", new BasicDBObject("$gt", 27)));    
    values.add(new BasicDBObject("age", new BasicDBObject("$lt", 15)));    
    queryCondition.put("$or", values);    

    DBCursor dbCursor = coll.find(queryCondition);       
}    
3）In（需要某个字段的值在某个范围时）
public void testIn(){    
    DBObject queryCondition = new BasicDBObject();          
    //age in [13, 47]    
    BasicDBList values = new BasicDBList();    
    values.add(13);    
    values.add(47);    
    queryCondition.put("age", new BasicDBObject("$in", values));    

    DBCursor dbCursor = coll.find(queryCondition);       
}    

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        hdoj 2602 Bone Collector【0-1背包】【dp思想】


Bone Collector
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 40247    Accepted Submission(s): 16722



Problem Description

Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …
The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the
 maximum of the total value the bone collector can get ?




 


Input

The first line contain a integer T , the number of cases.
Followed by T cases , each case three lines , the first line contain two integer N , V, (N <= 1000 , V <= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third
 line contain N integers representing the volume of each bone.

 


Output

One integer per line representing the maximum of the total value (this number will be less than 231).

 


Sample Input

1
5 10
1 2 3 4 5
5 4 3 2 1


 


Sample Output

14


 


题意：给一定数量的骨头的价格和体积，装进背包，求所能装下的骨头的最大价值
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
struct node{
	int value,vol;
}; 
node p[1010];
int bag[1100];
int main()
{
	int i,j,k,t,n,v;
	scanf("%d",&t);//总情况数 
	while(t--)
	{
		memset(bag, 0, sizeof(bag));//全初始化为 0 
		scanf("%d%d",&n,&v);//n数量,v体积 
		for(i = 1; i <= n; i++)
			scanf("%d",&p[i].value);//输入每个骨头的价值 
		for(i = 1; i <= n; i++)
			scanf("%d",&p[i].vol);//输入每个骨头所占体积 
		for(i = 1; i <= n ;i++)//数量变化 
		{
			for( j = v; j >= p[i].vol;j--)// 体积控制,背包如果可以装下骨头就继续 
			{	//动态规划过程 
				bag[j] = max(bag[j], bag[j-p[i].vol]+p[i].value);//当前与下一个取价值最大的 
			}
		}
		printf("%d\n",bag[v]);//输出装的最多价值 
	}
	return 0;
}











版权声明：原创文章，若要转载，请与博主联系，谢谢

spring 引入外部配置文件
beans-properties.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:p="http://www.springframework.org/schema/p"
   xmlns:context="http://www.springframework.org/schema/context"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context/spring-context-4.0.xsd">
     
     <!-- 配置数据源 -->
<!-- <bean id="dataS" class="com.mchange.v2.c3p0.ComboPooledDataSource">
<property name="user" value="root"></property>
<property name="password" value="123456"></property>
<property name="driverClass" value="com.mysql.jdbc.Driver"></property>
<property name="jdbcUrl" value="jdbc:mysql:///test"></property>
</bean> -->

<!-- 导入外部的资源文件 -->
    <context:property-placeholder location="classpath:db.properties"/>


<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="user" value="${jdbc.user}"></property>
        <property name="password" value="${jdbc.password}"></property>
        <property name="driverClass" value="${jdbc.driverClass}"></property>
        <property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property>
    </bean>

</beans>
外部文件为:db.properties
jdbc.user=root
jdbc.password=1230
jdbc.driverClass=com.mysql.jdbc.Driver
jdbc.jdbcUrl=jdbc:mysql:///test


测试类：
package com.spring.properties;

import java.sql.SQLException;

import javax.sql.DataSource;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class main {
    public static void main(String[] args) throws Exception {

    ApplicationContext ctx = new ClassPathXmlApplicationContext("beans-properties.xml");
   DataSource source = (DataSource) ctx.getBean("dataS");
   System.out.println(source.getConnection());
}
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

跟我一起写Makefile:MakeFile介绍
make命令执行时，需要一个 makefile 文件，以告诉make命令如何去编译和链接程序。
首先，我们用一个示例来说明makefile的书写规则。以便给大家一个感性认识。这个示例来源于gnu的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：
1）如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。
2）如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。
3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。
只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。


makefile的规则
在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。
target ... : prerequisites ...
        command
        ...
        ...
target可以是一个object file(目标文件)，也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。
prerequisites就是，要生成那个target所需要的文件或是目标。

command也就是make需要执行的命令。（任意的shell命令）


这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在 command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是makefile的规则。也就是makefile中最核心的内容。


说到底，makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是makefile的主线和核心，但要写好一个makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢道来。内容还多着呢。：）


一个示例
正如前面所说的，如果一个工程有3个头文件，和8个c文件，我们为了完成前面所述的那三个规则，我们的makefile应该是下面这个样子的。
edit : main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o       /*注释:如果后面这些.o文件比edit可执行文件新,那么才会去执行下面这句命令*/
        cc -o edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o


main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o


反斜杠（\）是换行符的意思。这样比较便于makefile的易读。我们可以把这个内容保存在名字为“makefile”或“Makefile” 的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下 “make clean”就可以了。


在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。


在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。


这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像c语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令（不仅用于clean，其他lable同样适用），就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。


make是如何工作的
在默认的方式下，也就是我们只输入make命令。那么，
1. make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2. 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
3. 如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。
4. 如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）

5. 当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生成make的终极任务，也就是执行文件edit了。


这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。
通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显式要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。
于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以 edit也会被重新链接了（详见edit目标文件后定义的命令）。
而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。



makefile中使用变量
在上面的例子中，先让我们看看edit的规则：
edit : main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。
比如，我们声明任意一变量名，叫objects, OBJECTS, objs, OBJS, obj, 或OBJ，只要能够表示obj文件即可。我们在makefile起始处按如下定义此变量：
objects = main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o

于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile变为如下：
objects = main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o


edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)

如果有新的 .o 文件加入，我们只需简单地修改变量objects即可。
更多关于变量的话题，我会在后续详细介绍。



让make自动推导
GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。
只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么 whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile 再也不用写得这么复杂。我们的新makefile又出炉了。
objects = main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o
 cc = gcc


edit : $(objects)
        cc -o edit $(objects)


main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h


.PHONY : clean
clean :
        rm edit $(objects)

这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。
关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。



另类风格的makefile
既然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。
objects = main.o kbd.o command.o display.o \
                insert.o search.o files.o utils.o


edit : $(objects)
        cc -o edit $(objects)


$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h


.PHONY : clean
clean :
        rm edit $(objects)

这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。



清空目标文件的规则
每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：
clean:
        rm edit $(objects)
#更为稳健的做法是：
.PHONY : clean
clean :
        -rm edit $(objects)

前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。
上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。



Makefile里有什么？
Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。
1. 显式规则。显式规则说明了，如何生成一个或多个目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。
2. 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写Makefile，这是由make所支持的。
3. 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
4. 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。
5. 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜杠进行转义，如：“\#”。
最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。



Makefile的文件名
默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。
当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“--file”参数，如：make -f Make.Linux或make --file Make.AIX。



引用其它的Makefile
在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：
include <filename>;
filename可以是当前操作系统Shell的文件模式（可以包含路径和通配符）
在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和<filename>;可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了 e.mk和f.mk，那么，下面的语句：
include foo.make *.mk $(bar)
等价于：
include foo.make a.mk b.mk c.mk e.mk f.mk

make命令开始时，会找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：
1. 如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。
2. 如果目录<prefix>;/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。
如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取， make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：
-include <filename>;

其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。



环境变量 MAKEFILES
如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变量中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。
但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。



make的工作方式
GNU的make工作时的执行步骤如下：（想来其它的make也是类似）
1. 读入所有的Makefile。
2. 读入被include的其它Makefile。
3. 初始化文件中的变量。
4. 推导隐晦规则，并分析所有规则。
5. 为所有的目标文件创建依赖关系链。
6. 根据依赖关系，决定哪些目标要重新生成。
7. 执行生成命令。
1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。

当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。


from Ubuntu wiki

版权声明：本文为博主原创文章，未经博主允许不得转载。

监督算法大比拼之BP、SVM、adaboost非线性多分类实验
写在之前：
前些文章曾经细数过从决策树、贝叶斯算法等一些简单的算法到神经网络(BP)、支持向量机（SVM）、adaboost等一些较为复杂的机器学习算法（对其中感兴趣的朋友可以往前的博客看看），各种算法各有优缺点，基本上都能处理线性与非线性样本集，然通观这些算法来看，个人感觉对于数据（无论线性还是非线性）的分类上来说，里面比较好的当数BP、SVM、adaboost元算法这三种了，由于前面在介绍相应算法原理以及实验的时候所用的样本以及分类情况都是二分类的，对于多分类的情况未曾涉及过，而实际情况往往是分类多分类数据的样本较多，本节旨在对BP、SVM、adaboost这三种个人感觉较好的算法进行一个对比，同时实验一个简单的非线性多分类样本。
一：理解与分析
既然是多分类样本，首先对样本需要理解，所谓多分类就是样本集中不止2类样本，至少3类才称得上是多分类。比如下面一个二维非线性的多类样本集（这也是后面我们实验的样本集）： 
 
每种颜色代表一类，可以看到共有5类，同时也可以看到是一个非线性的吧，这里可以就把五类分别设置为1~5类类标签。
好了，曾经在单个算法介绍的时候，里面的实验都是二分类的（也就是只有上述5类样本中的两类），二分类的方式很简单，不是你就是我的这种模式，那么从二分类到多分类该怎么转换呢？假如一个样本不是我，那也可能不是你呀，可能是他它她对吧，这个时候该如何呢？
现在一般的方式都是将多分类问题转化为二分类问题，因为前面许多算法在原理推导上都是假设样本是二分类的，像SVM，整个推导过程以至结论都是相对二分类的，根本没有考虑多分类，依次你想将SVM直接应用于多分类是不可能的，除非你在从原理上去考虑多分类的情况，然后得到一个一般的公式，最后在用程序实现这样才可以。
那么多分类问题怎么转化为二分类问题？很简单，一个简单的思想就是分主次，采取投票机制。转化的方式有两种，因为分类问题最终需要训练产生一个分类器，产生这个分类器靠的是训练样本，前面的二分类问题实际上就是产生了一个分类器，而多分类问题根据训练集产生的可不止是一个分类器，而是多个分类器。
那第一种方式就是将训练样本集中的某一类当成一类，其他的所有类当成另外一类，像上面的5类，我把最中间的一类当成是第一类，并重新赋予类标签为1，而把四周的四类都认为是第二类，并重新赋予类标签维-1，好了现在的问题是不是就是二分类问题了？是的。那二分类好办，用之前的任何一个算法处理即可。好了，这是把最中间的当成一类的情况下建立的一个分类器。同理，我们是不是也可以把四周任何一类自成一类，而把其他的统称为一类呀？当然可以，这样依次类推，我们共建立了几个分类器？像上面5类就建立了5个分类器吧，好了到了这我们该怎么划分测试集的样本属于哪一类了？注意测试集是假设不知道类标签的，那么来了一个测试样本，我把它依次输入到上述建立的5个分类器中，看看最终它属于哪一类的多，那它就属于哪一类了吧。比如假设一个测试样本本来是属于中间的（假设为第5类吧），那么先输入第五类自成一类的情况，这个时候发现它属于第五类，记录一下5，然后再输入左上角（假设为1类）自成一类的情况，那么发现这个样本时不属于1类的，而是属于2,3,4,5这几类合并在一起的一类中，那么它属于2,3,4,5中的谁呢？都有可能吧，那么我都记一下，此时记一下2,3,4,5。好了再到有上角，此时又可以记一下这个样本输入1,3,4,5.依次类推，最后把这5个分类器都走一遍，就记了好多1~5的标签吧，然后去统计他们的数量，比如这里统计1类，发现出现了3次，2,3,4都出现了3次，就5出现了5次，那么我们就有理由认为这个样本属于第五类，那么现在想想是不是就把多类问题解决了呢？而这个过程参考这位大神博客中的一张图表示就如下： 
 
可以看到，其实黑实线本类是我们想要的理想分类面，而按照这种方式建立的分类面是带阴影部分的那个分类面，那阴影部分里面表示什么呢？我们想想，假设一个样本落在了阴影里面，比如我画的那个紫色的点，按照上面计算，发现它属于三角形一类的2次，属于正方形一类的2次，属于圆形一类的1次，那这个时候你怎么办？没招，只能在最大的两次中挑一个，运气好的认为属于三角形，挑对了，运气不好的挑了个正方形，分错了。所以阴影部分是属于模棱两可的情况，这个时候只能挑其中一个了。
这是第一种方式，那还有第二种分类方式，思想类似，也是转化为二分类问题，不过实现上不同。前面我们是挑一类自成一类，剩下的所有自成一类，而这里，也是从中挑一类自成一类，然剩下的并不是自成一类，而是在挑一类自成一类，也就是说从训练样本中挑其中的两类来产生一个分类器。像上述的5类，我先把1,2,类的训练样本挑出来，训练一个属于1,2,类的分类器，然后把1,3,挑出来训练一个分类器，再1,4再1,5再2,3,等等（注意2,1与1,2一样的，所以省去了），那这样5类样本需要建立多少个分类器呢？n*(n-1)/2吧，这里就是5*4/2=10个分类器，可以看到比上面的5个分类器多了5个。而且n越大，多的就越多。好了建立完分类器，剩下的问题同样采取投票机制，来一个样本，带到1,2建立的发现属于1，属于1类的累加器加一下，带到1,3建立的发现也属于1，在加一下，等等等等。最后看看5个类的累加器哪个最大就属于哪一类。那么一个问题来了，会不会出现像上面那种情况，有两个或者更多个累加器的值是一样的呢？答案是有的，但是这种情况下，出现一样的概率可比上述情况的概率小多了（比较是10个分类器来的结果，怎么也得比你5个的要好吧），同样一个示意图如下： 
 
可以看到重叠部分就是中间那么一小块，相比上面那种方式小了不少吧。 
那么细比较这两种方式，其实各有优缺点。第一种方式由于建立的分类器少（n越大越明显吧，两者相差(n*(n-1)/2 - n）个分类器）。也就是在运算的时候速度更快，而第二种方式虽然速度慢，但是精度高呀，而且现在计算机的速度也够快了，可以弥补第二种方式的缺点，所以个人更倾向于第二种方式了。 
好了说完了理论部分，实践起来吧，实践是检验真理的唯一方法。
二：BP模式识别工具箱处理多分类实验
首先采用神经网络算法来实验，同时为了速度与准确率，我们实验matlab的神经网络工具箱，关于该工具箱怎么用，请参考：
机器学习之实战matlab神经网络工具箱
为了实现较好的效果，这里我们直接使用matlab在BP下建立起来的模式识别工具箱（nprtool）。该工具箱的使用可以通过GUI界面直接操作，也可以命令操作，需要说明一点的就是数据的输入形式，尤其是对于类标签的设置，在该工具箱下，类标签已经不再是用数字1~5直接表示，而是用一个向量，比如类别1可以表示为[1,0,0,0,0],类别3可以表示为[0,0,1,0,0]这种表示方式。同时如果样本输入每一行表示一个样本，那么类别就得像上面那一，每一行表示一个样本类别。如果每一列为一个样本，那么对应的标签也是每一列一个样本，下面实验每一列表示一个样本的样本集：
%%  
% * matlab模式识别工具箱的分类设计
% * 多类非线性分类
% 
%% 
clc
clear
close all
%% Load data
% * 数据预处理
data = load('data_test.mat');
data = data.data;
%选择训练样本个数
num_train = 200;%共500个样本
%构造随机选择序列
choose = randperm(length(data));
train_data = data(choose(1:num_train),:);
label_temp = train_data(:,end);
label_train = zeros(length(train_data),5);
%把输出分类标签改为工具箱要求的格式
for i = 1:length(train_data)
    label_train(i,label_temp(i)) = 1; 
end
train_data = train_data(:,1:end-1)';
label_train = label_train';
%
test_data = data(choose(num_train+1:end),:);
label_temp = test_data(:,end);
label_test = zeros(length(test_data),5);
%把输出分类标签改为工具箱要求的格式
for i = 1:length(test_data)
    label_test(i,label_temp(i)) = 1; 
end
test_data = test_data(:,1:end-1)';
label_test = label_test';
%%
% Create a Pattern Recognition Network
hiddenLayerSize = 10;
net = patternnet(hiddenLayerSize);
% 将训练集再按比例内分为训练集、验证集、测试集
net.divideParam.trainRatio = 70/100;
net.divideParam.valRatio = 15/100;
net.divideParam.testRatio = 15/100;
% Train the Network
[net,tr] = train(net,train_data,label_train);
% Test the Network
predict = net(test_data);
[~,predict] = max(predict);
%% show the result --testings
figure;
gscatter(test_data(1,:),test_data(2,:),predict);
[~,label_test] = max(label_test);
accuracy = length(find(predict==label_test))/length(test_data);
title(['predict the testing data and the accuracy is :',num2str(accuracy)]);
可以看到，其实程序开头许多对数据进行了训练样本与测试样本的选择，同时对类标签进行了变化。之间部分是建立模式识别的神经网络网路系统，最后应用这个网络对测试集进行测试，得到一个结果如下： 
 
这是中间出来的网路结构： 
 
可以看到，这是200个训练样本300个测试样本下的结果，该工具箱产生的准确率是相当高的。 
其实对于该工具箱也可以通过GUI界面直接操作，不用编写那么多代码，但是你的输入数据格式什么的都得提前转换对才行。直接命令输入nprtool就可以打开该工具箱的GUI，详细的可以自行研究。
三：svm之libsvm处理多分类实验
下面我们来通过svm方法进行上述数据的分类。由于上面的BP部分直接采用工具箱函数，并没有涉及到前面我们说的两种由二分类到多分类的方法，对于svm我们将把两种方式都演示一遍。这里我会用到libsvm工具箱，关于该工具箱怎么使用请看：
解密SVM系列（五）：matlab下libsvm的简单使用
第一种：
%%  
% * libsvm工具箱实验
% * 多类非线性分类
% 
%% 
clc
clear
close all
%% Load data
% * 数据预处理--分两类情况
data = load('data_test.mat');
data = data.data;
%选择训练样本个数
num_train = 200;
%构造随机选择序列
choose = randperm(length(data));
train_data = data(choose(1:num_train),:);
gscatter(train_data(:,1),train_data(:,2),train_data(:,3));
label_train = train_data(:,end);
test_data = data(choose(num_train+1:end),:);
label_test = test_data(:,end);
%% svm的构建与训练
for i = 1:5 %5类
    %重新归类
    label_temp = label_train;
    index1 = find(label_train == i);
    index2 = find(label_train ~= i);
    label_temp(index1) = 1;
    label_temp(index2) = -1;
    % 训练模型
    model{i} = svmtrain(label_temp,train_data(:,1:end-1),'-t 2');
end
% 用模型来预测测试集的分类
predict = zeros(length(test_data),1);
for i = 1:length(test_data)
    data_test = test_data(i,:);
    addnum = zeros(1,5);
    for j = 1:5
        temp = svmpredict(1,data_test(:,1:end-1),model{j});
        if temp > 0
            addnum(j) = addnum(j) + 1;
        else
            addnum = addnum + 1;
            addnum(j) = addnum(j) - 1;
        end
    end
    [~,predict(i)] = max(addnum);
end
%% show the result--testing
figure;
gscatter(test_data(:,1),test_data(:,2),predict);
accuracy = length(find(predict==label_test))/length(test_data);
title(['predict the training data and the accuracy is :',num2str(accuracy)]);
结果如下： 
 
 下面进行第二种方式：
%%  
% * libsvm工具箱实验
% * 多类非线性分类
% 
%% 
clc
clear
close all
%% Load data
% * 数据预处理
data = load('data_test.mat');
data = data.data;
%选择训练样本个数
num_train = 200;
%构造随机选择序列
choose = randperm(length(data));
train_data = data(choose(1:num_train),:);
gscatter(train_data(:,1),train_data(:,2),train_data(:,3));
label_train = train_data(:,end);
test_data = data(choose(num_train+1:end),:);
label_test = test_data(:,end);
%% svm的构建与训练
num = 0;
for i = 1:5-1 %5类
    for j = i+1:5 
        num = num + 1;
        %重新归类
        index1 = find(label_train == i);
        index2 = find(label_train == j);
        label_temp = zeros((length(index1)+length(index2)),1);
        %svm需要将分类标签设置为1与-1
        label_temp(1:length(index1)) = 1;
        label_temp(length(index1)+1:length(index1)+length(index2)) = -1;
        train_temp = [train_data(index1,:);train_data(index2,:)];
        % 训练模型
        model{num} = svmtrain(label_temp,train_temp(:,1:end-1),'-t 2');      
    end
end
% 用模型来预测测试集的分类
predict = zeros(length(test_data),1);
for i = 1:length(test_data)
    data_test = test_data(i,:);
    num = 0;
    addnum = zeros(1,5);
    for j = 1:5-1
        for k = j+1:5
            num = num + 1;
            temp = svmpredict(1,data_test(:,1:end-1),model{num});
            if temp > 0
                addnum(j) = addnum(j) + 1;
            else
                addnum(k) = addnum(k) + 1;
            end
        end
    end
    [~,predict(i)] = max(addnum);
end
%% show the result--testing
figure;
gscatter(test_data(:,1),test_data(:,2),predict);
accuracy = length(find(predict==label_test))/length(test_data);
title(['predict the testing data and the accuracy is :',num2str(accuracy)]);
结果如下： 
 
可以看到的是这两种方式下的结果都挺好，准确率都高，由于训练样本随机选择，每一次的结果不会一样。至于哪一种好，我觉得，当样本大的时候，在速度满足要求的情况下，并且数据可能重叠的时候，第二种是好些的。
四：adaboost元算法处理多分类实验
关于adaboost元算法的详细原理与实现过程请看上节：
机器学习之白话与实战adaboost元算法
考虑到adaboost元算法并没有去找相应的软件工具箱，所以这里就用自己编写的函数来实现吧，在上述博客中涉及到了下面会使用到的两个子函数buildSimpleStump和adaBoostTrainDs，限于篇幅，这里不再贴出来，要使用的朋友可以自行把那里的拷贝过来。
那么在基于上述的两个子函数下，我们在编写两个函数，一个是adaboost的训练函数，一个是adaboost的预测函数，函数如下： 
训练函数：
function model = adaboost_train(label,data,iter)
[model.dim,model.direction,model.thresh,model.alpha] = ...
    adaBoostTrainDs(data,label,iter);
model.iter = iter;
预测函数：
function predict = adaboost_predict(data,model)
h = zeros(model.iter,1);
for j = 1:model.iter
    if model.direction(j) == -1
        if data(model.dim(j)) <= model.thresh(j)
            h(j) = -1;
        else
            h(j) = 1;
        end
    elseif model.direction(j) == 1
        if data(model.dim(j)) <= model.thresh(j)
            h(j) = 1;
        else
            h(j) = -1;
        end
    end
end
predict = sign(model.alpha'*h);
有了这两个函数我们就可以进行实验了，这里我们只一第二种方式的多分类为例，函数同上面的svm类似，只不过把那里的训练模型函数与预测函数改到我们这里的这种，主函数如下：
%%  
% * adaboost
% * 多类非线性分类
% 
%% 
clc
clear
close all
%% Load data
% * 数据预处理
data = load('data_test.mat');
data = data.data;
%选择训练样本个数
num_train = 200;
%构造随机选择序列
choose = randperm(length(data));
train_data = data(choose(1:num_train),:);
gscatter(train_data(:,1),train_data(:,2),train_data(:,3));
label_train = train_data(:,end);
test_data = data(choose(num_train+1:end),:);
label_test = test_data(:,end);
%% adaboost的构建与训练
num = 0;
iter = 30;%规定弱分类器的个数
for i = 1:5-1 %5类
    for j = i+1:5 
        num = num + 1;
        %重新归类
        index1 = find(label_train == i);
        index2 = find(label_train == j);
        label_temp = zeros((length(index1)+length(index2)),1);
        %svm需要将分类标签设置为1与-1
        label_temp(1:length(index1)) = 1;
        label_temp(length(index1)+1:length(index1)+length(index2)) = -1;
        train_temp = [train_data(index1,:);train_data(index2,:)];
        % 训练模型
        model{num} = adaboost_train(label_temp,train_temp,iter);
    end
end
% 用模型来预测测试集的分类
predict = zeros(length(test_data),1);
for i = 1:length(test_data)
    data_test = test_data(i,:);
    num = 0;
    addnum = zeros(1,5);
    for j = 1:5-1
        for k = j+1:5
            num = num + 1;
            temp = adaboost_predict(data_test,model{num});
            if temp > 0
                addnum(j) = addnum(j) + 1;
            else
                addnum(k) = addnum(k) + 1;
            end
        end
    end
    [~,predict(i)] = max(addnum);
end
%% show the result--testing
figure;
gscatter(test_data(:,1),test_data(:,2),predict);
accuracy = length(find(predict==label_test))/length(test_data);
title(['predict the testing data and the accuracy is :',num2str(accuracy)]);
这还是在200个训练样本下300个测试样本的一个结果如下： 
 
可以看到在iter=30个弱分类器下的结果已经是高的惊人了。
至此上述三种方法介绍完毕，上述三种方法对于监督式的多分类问题来说确实都相当好了。只要根据你的样本来调节适当参数，感觉总是可以得到较好的结果的。叙述了这么多，喜欢的朋友顶一下吧~_~!同时也欢迎相互交流。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

关于虚函数
typedef void (*fun)();
class A
{
public:
	A()
	{
		cout << "class A default constructor called" << endl;
		a = 0;
	}
	A(int param)
	{
		cout << "class A constructor called" << endl;
		a = param;
	}
	~A()
	{

	}
	virtual void FunctionA()
	{
		cout << "classA FunctionA()" << endl;
	}
	virtual void FunctionB()
	{
		cout << "classA FunctionB()" << endl;
	}
	int a;
	static int staticA;
private:

};
int  A::staticA = 2;int main()
{
   A aObj;
   fun  funcA =  (fun) *((int*)*(int*)(&aObj));
   funcA();
   fun  funcB =  (fun) *( (int*)*(int*)(&aObj) + 1);
   funcB();
   while(1);
   return 0;
}

1.(int*)(*aObj)得到了虚函数表指针的地址&vptr
2.(int*)*(int*)(*aObj)得到虚函数表指针vptr 指针的类型是（int*）,这时需要转化下
3.vptr是指向vptr table，其实就是指向一个数组，数组元素是函数指针。 
    (int*)*(int*)(*aObj) 指向数组第一个元素  所以*（(int*)*(int*)(*aObj))就是FunctionA的地址  
    (int*)*(int*)(*aObj) + 1 指向数组第二个元素，所以*（(int*)*(int*)(*aObj) + 1) 就是FunctionB的地址
4.funcA(); funcB(); 这样就是调用相应的虚函数

 


版权声明：本文为博主原创文章，未经博主允许不得转载。

CI中奇葩而有趣的坑
以下代码是正确的：
<input type="checkbox" name="permission[]" value="valuexxx"/>
$permissions = $this->input->post ( 'permission' );
以下代码中的permissions 只能获取选中的个数：
<input type="checkbox" name="permission" value="valuexxx"/>
$permissions = $this->input->post ( 'permission' );

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：欢迎转载，转载请注明原地址，谢谢！

Effective C++——条款3(第1章)
条款03:尽量使用 const
Use const whenever possible
    const 允许指定一个语义约束(也就是指定一个"不该被改动"的对象),而编译器会强制实施这项约束.它允许告诉编译器和其他程序员其值应该保持不变.只要这(某值保持不变)是事实,因为说出来可以获得编译器的帮助,确保这条约束不被违反.
    可以用 const 在 class 外部修饰global或namespace作用域中的常量,或修饰文件,函数,或区块作用域(block scope)中被声明为 static 的对象.可以用它修饰 class 内部的 static 和non-static 成员变量.面对指针,可以指出指针自身,指针所指物,或者两者都是 const:
char greeting[] = "hello";
char *p = greeting;                        // non-const pointer,non-const data
const char *p = greeting;                // non-const pointer,const data
char * const p = greeting;                // const pointer, non-const data
const char * const p = greeting;        // const pointer, const data    从右向左看,p是一个 const 指针,指向 const char 类型的数据.(第四个)
    从右向左看,p是一个指针,指向 const char 类型的数据.(第二个)
    STL迭代器以指针为基础塑模出来,所以迭代器的作用就像 T * 指针.声明迭代器为 const 就像声明指针为 const 一样(即声明一个 T *const 指针),表示这个迭代器不得指向不同的对象,但它指向的对象的值是可以改变的.如果希望迭代器所指的对象不可被改动(即 const T *指针),需要的是 const_iterator:
std::vector<int> vec;
...
const std::vector<int>::iterator iter = vec.begin();        // iter的作用像个T *const
*iter = 10;                                                    // ok. 改变iter所指对象
++iter;                                                        // error. iter是const
std::vector<int>::const_iterator cIter = vec.begin();        // cIter的作用像个const T *
*cIter = 10;                                                // error. *cIter是const
++cIter;                                                    // ok. 改变cIter    const 最具威力的用法是面对函数对象时的应用.在一个函数声明式内,const 可以和函数返回值,各参数,函数本身产生关联.
    令函数返回一个常量值,往往可以降低因客户错误而造成的意外,而又不至于放弃安全性和高效性.例如,考虑有理数的operator*的声明式:
class Rational { ... };
const Rational operator *(const Rational &lhs, const Rational &rhs);    为什么返回一个 const 对象?原因是如果不这样客户就能实现这样的暴行:
Rational a, b, c;
(a * b) = c;    许多程序员会无意间这样做,只因为单纯的打字错误:
if (a * b = c)                // 实际上是==    如果a和b是内置类型,这样代码当然不合法.而一个"良好的用户自定义类型"的特征就是它们避免无端地与内置类型不兼容.将operator *的返回值声明为 const ,可以预防那个"没有意义的赋值动作".

const 成员函数
    将 const 实施于成员函数的目的,是为了确认该成员函数可作用于 const 对象上.这一类函数之所以重要,基于两个理由:
    第一,它们使 const 接口比较容易被理解.这是因为,得知哪个函数可以改动对象内容,哪个函数不能,很重要.
    第二,它们使"操作const对象"成为可能.这对编写高效代码是个关键.因为如条款20所述,改善C++程序效率的一个根本办法是以pass by reference to const 方式传递对象,而此技术可行的前提是,有 const 成员函数可用来处理取得的 const 对象.
    如果两个成员函数只是常量性(constness)不同,可以被重载.这是很重要的C++特性.考虑以下 class,用来表现一大块文字:
class TextBlock {
public:
    const char & operator[](std::size_t position) const {
        return text[position];
    }
    char & operator[](std::size_t position) {
        return text[position];
    }
private:
    std::string text;
};    TextBlock的operator[]可以这样使用:
TextBlock tb("hello");
std::cout << tb[0];
const TextBlock ctb("world");
std::cout << ctb[0];    真实程序中 const 对象大多用于pass by pointer-to-const 或 pass by reference-to-const 的传递结果.上述的ctb例子太造作,下面这个比较真实:
void print(const TextBlock &ctb) {
    std::cout << ctb[0];
}    只要重载operator[]并对不同版本给予不同的返回类型,就可以令 const 和non-const TextBlock获得不同的处理:
tb[0] = 'x';            // ok
ctb[0] = 'x';            // error    上述错误是因为operator[]的返回类型导致的,企图对一个"由const的operator[]返回"的 const char &施行赋值动作.
    也要注意,non-const operator[]的返回类型是个reference to char,不是char.如果operator[]只是返回一个char,下面这样的句子就无法通过编译:tb[0] = 'x';
    那是因为,如果函数的返回类型是个内置类型,那么改动函数返回值从来就不合法.纵然合法,C++以by value返回对象这一事实意味着改动的其实是tb.text[0]的一个副本,不是tb.text[0]自身.
    成员函数如果是 const 意味着什么?这里有两个流行概念:bitwise constnest(physical constness)和logical constness.
    bitwise const 阵营的人相信,成员函数只有在不更改对象的任何成员变量(static 除外)时才可以说是const.也就是说它不更改对象内的任何一个bit.这种论点的优点是很容易侦测为违反点:编译器只需寻找成员变量的赋值动作即可.bitwise constness正是C++对常量性的定义,因此 const 成员函数不可以更改对象内任何non-static 成员变量.
    但是,一个更改了"指针所指物"的成员函数虽然不能算是 const,但如果只有指针(而非其所指物)隶属于对象,那么称此函数为bitwise const 不会引发编译器异议.例如:
class CTextBlock {
public:
    char& operator[](std::size_t position) const {
        return pText[position];
    }
private:
    char *pText;
};    这个 class 不适当地将其operator[]声明为 const 成员函数,而该函数却返回一个reference指向对象内部值.operator[]实现代码并不更改pText.于是编译器很开心地为operator[]产生目标码.它是bitwise const,所有编译器都这么认定.但是看看它允许发生什么事情:
const CTextBlock cctb("hello");
char *pc = &cctb[0];
*pc = 'J';    创建一个常量对象并设以某值,而且只对它调用 const 成员函数.但是终究改变了它的值.
    这种情况导出所谓的logical constness.他们认为:一个 const 成员函数可以修改它所处理的对象内的某些bits,但只有在客户端侦测不出的情况下才得如此.例如CTextBlock class 有可能高速缓存(cache)文本区块的长度以便应付询问:
class CTextBlock {
public:
    std::size_t length() const;
private:
    char *pText;
    std::size_t textLength;
    bool lengthIsValid;
};
std::size_t CTextBlock::length() const {
    if (!lengthIsValid) {
        textLength = std::strlen(pText);    // error!
        lengthIsValid = true;                // error!
    }                                        // const成员函数内不能给成员变量赋值
    return textLength;
}    textLength和lengthIsValid的修改对 const CTextBlock对象而言是可接受的,但是编译器不同意.
    解决的办法很简单:利用C++的一个与 const 相关的摆动场:mutable(可变的).mutable 释放掉non-static 成员变量的bitwise constness约束:
class CTextBlock {
public:
    std::size_t length() const;
private:
    char *pText;
    mutable std::size_t textLength;        // 这些成员变量可能会被更改
    mutable bool lengthIsValid;            // 即使在const成员函数内
};
std::size_t CTextBlock::length() const {
    if (!lengthIsValid) {
        textLength = std::strlen(pText);    // ok
        lengthIsValid = true;                // ok
    }
    return textLength;
}
    注意:
    将某些东西声明为 const 可帮助编译器侦测出错误用法.const 可被施加于任何作用域内的对象,函数参数,函数返回值,成员函数本体.
    编译器强制实施bitwise constness,但编写程序时应该使用"概念上的常量性"(coceptual constness).
    当 const 和 non-const 成员函数有着实质等价的实现时,令non-const版本调用 const 版本可避免代码重复.


版权声明：本文为博主原创文章，未经博主允许不得转载。

LeetCode: MissingNumber
题目链接：https://leetcode.com/problems/missing-number/
题目：

Given an array containing n distinct numbers taken from 0,
 1, 2, ..., n, find the one that is missing from the array.

For example,
Given nums = [0, 1, 3] return 2.

Note:
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?

题意：在给定包含n个数的数组中找出丢失的那个

分析：很简单，排下序，遍历一下即可

代码：

public class Solution {
    public int missingNumber(int[] nums) {
        int k = 0;
	    int len = nums.length;
	        
	    Arrays.sort(nums);
	        
	    for(int i=0; i<nums.length; i++) {
	        if(nums[i] != k)
	            return k;
	        k++;
	    }
	        
        if(k == len) {
            return k;   
        }
		return 0;
    }
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

全排列方法求解八皇后问题


#include<iostream>
using namespace std;
int C[8];
int res = 0;//多少组解
void EightQueen(int n,int curr)
{
	if (curr == n)
	{
		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < n; j++)
			{
				if (C[i] == j)
					cout << "Q ";
				else
					cout << "* ";
			}
			cout << endl;
		}
		return;
	}
	else
	{
		for (int i = 0; i < n; i++)
		{
			C[curr] = i;//第curr行放在第i列上
			bool flag = true;
			for (int j = 0; j < curr; j++)
			{
				if (C[curr] == C[j] || curr - C[curr] == j - C[j] || curr + C[curr] == j + C[j])
				{
					flag = false;
					break;
				}
			}

			if (flag)
			{
				EightQueen(n, curr + 1);
			}
		}
	}
}
int main()
{
	EightQueen(8,0);
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

最小生成树+Hdu4786
hdu4786 
最小生成树的变形题，求一遍最小，求一遍最大，在从此区间是否含有斐波那契数，别忘了并查集，因为可能不连通。
后来想其实不难，场上出不来的原还是对最小生成数不熟练，基础薄弱。！
#include<bits/stdc++.h>
using namespace std;
int par[100100];
int rank_[101000];
struct edge {
    int u,v,cost;
};
int n,m;
int init(int n){
    for(int i=0;i<=n;i++) {
        par[i]=i;
        rank_[i]=0;
    }
}
bool comp(const edge& e1,const edge& e2){
    return e1.cost > e2.cost;
}
bool comp2(const edge& e1,const edge& e2){
    return e1.cost < e2.cost;
}
edge es[100100];
int find_(int x){
    if(par[x]==x) return x;
    else return par[x]=find_(par[x]);
}
void unite(int x,int y){
    x=find_(x);
    y=find_(y);
    if(x==y) return ;
    if(rank_[x]<rank_[y]){
        par[x]=y;

    }else {
        par[y]=x;
        if(rank_[x]==rank_[y]) rank_[x]++;
    }
}
bool same(int x,int y){
    return find_(x)==find_(y);
}
int kruskal(){
    sort(es,es+m,comp);
    init(n);
    int res=0;
    for(int i=0;i<m;i++){
        edge e=es[i];
        if(!same(e.u,e.v)){
            unite(e.u,e.v);
            res+=e.cost;
        }
    }
    return res;
}
int kruskal2(){
    sort(es,es+m,comp2);
    init(n);
    int res=0;
    for(int i=0;i<m;i++){
        edge e=es[i];
        if(!same(e.u,e.v)){
            unite(e.u,e.v);
            res+=e.cost;
        }
    }
    return res;
}
const int maxn = 1e5 + 100;
int main()
{
    int F[maxn];
    int tmp[maxn];
    memset(tmp,0,sizeof(tmp));
    memset(F,0,sizeof(F));
    tmp[0] = 1; tmp[1] = 2;
    F[1] = 1;
    F[2] = 1;
    for(int i = 2; tmp[i-2] + tmp[i-1] < maxn; ++i)
    {
        tmp[i] = tmp[i-2] + tmp[i-1];
        F[tmp[i]] = 1;
    }




    int t,kase=0;
    scanf("%d",&t);
    while(t--){


        scanf("%d%d",&n,&m);
        int flag=0;
        init(n);
        for(int i=0;i<m;i++){
             scanf("%d%d%d",&es[i].u,&es[i].v,&es[i].cost);
             unite(es[i].u,es[i].v);
        }
        int cnt=0;
        for(int i=1;i<=n;i++) if(par[i]==i) ++cnt;
        int o=0;
        printf("Case #%d: ",++kase);
        if(cnt==1) {



             int q = kruskal2();
         int p = kruskal();

    for(int i=q;i<=p;i++)
        if(F[i]) {
            o=1; break;
        }

        }




        if(o) printf("Yes");  else printf("No");

        printf("\n");

    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

Objective-C 【动态类型检测&响应方法】

———————————————————————————————————————————
动态类型检测

代码：

#import <Foundation/Foundation.h>

@interface Animal : NSObject
-(void)run;
-(void)abc;
@end

@implementation Animal
-(void)run
{
    NSLog(@"Animal run!");
}
-(void)abc
{
    NSLog(@"abc!");
}
@end

@interface Dog : Animal
-(void)run;
-(void)eat;
-(void)bark;
@end

@implementation Dog
-(void)run
{
    NSLog(@"Dog run!");
}
-(void)eat
{
    NSLog(@"Dog eat!");
}
-(void)bark
{
    NSLog(@"Dog bark!");
}
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        //动态类型检测：
        //*******************************************************
        
//        1)判断某个对象是否是该类的实例对象，或者是其子类的实例对象（对象和类）
//        isKindOfClass使用格式：   [对象 isKindOfClass:类对象];
       
        Animal *ani=[Animal new];
        
        //BOOL isIstance=[ani isKindOfClass:[ani class]];
        BOOL isInstance=[ani isKindOfClass:[Animal class]];
        //上面两种写法都行，因为可以用 类类型的实例对象/类名 去调用类对象
        
        NSLog(@"isInstance = %d",isInstance);//输出是1（ani本来就是Animal的实例对象，自然为1）
        
        
        Dog *dog=[Dog new];
        BOOL isInstance1=[dog isKindOfClass:[Animal class]];
        NSLog(@"isIstance1 = %d",isInstance1);//输出是1（Dog是Animal的子类，dog是Dog的实例对象，自然为1）
        
        
        Person *p=[Person new];
        BOOL isInstance2=[p isKindOfClass:[Animal class]];
        NSLog(@"isInstance2 = %d",isInstance2);//输出是0（Person是无关的类，不是Animal的子类，p是Person的实例对象，所以为0）
        
        //*******************************************************
        
//        2）判断某个对象是否是该类的实例对象（单指这个类，不包括其子类）
        
//        isMemberOfClass使用格式：   [对象 isMemberOfClass:类对象];
       
        BOOL isInstance3=[ani isMemberOfClass:[Animal class]];
        NSLog(@"isInstance3 = %d",isInstance3);//输出是1（ani是Animal的实例对象，自然为1）

        BOOL isInstance4=[dog isMemberOfClass:[Animal class]];
        NSLog(@"isInstance4 = %d",isInstance4);//输出是0（dog是Dog的实例对象，Dog是Animal的子类，所以为0）
        
        //*******************************************************
        
//        3）判断某个类是不是另一个类的子类
        
//        isSubclassOfClass使用格式：    [类名/类对象 isSubclassOfClass:类对象];

        BOOL isInstance5=[Dog isSubclassOfClass:[Animal class]];
        NSLog(@"isInstance5 = %d",isInstance5);//输出为1（Dog是Animal的子类）

        BOOL isInstance6=[Animal isSubclassOfClass:[Dog class]];
        NSLog(@"isInstance6 = %d",isInstance6);//输出为0（Animal是Dog的父类）

        BOOL isInstance7=[[Dog class] isSubclassOfClass:[Animal class]];
        NSLog(@"isInstance7 = %d",isInstance7);//输出为1（这里注意前面可以写作类对象的形式）

//        BOOL isInstance8=[[Dog class] isSubclassOfClass:Animal];//这句话编译不会通过，因为后面Animal不是类对象的格式
        
        //*******************************************************
        
//        4)判断对象能否响应指定的方法
        
//        respondsToSelector使用格式：   [对象 respondsToSelector:方法的SEL];
//        BOOL isRespond1=ani respondsToSelector:<#(SEL)#>//这里显然参数传进来的应该是一个SEL的类型
//        我们一起来回顾一下SEL是什么。首先SEL表示方法的存储位置，我们一般先将方法包装为SEL类型，然后根据sel数据找到方法的地址，然后根据方法地址调用相应的方法。所以接下来我们应该这样处理：
        
        SEL s1=@selector(eat);//先将数据封装成SEL类型，获得方法的地址
        BOOL isRespond1=[dog respondsToSelector:s1];//eat是Dog里面的方法，dog是Dog的实例对象，所以可以访问
        NSLog(@"isRespond1 = %d",isRespond1);//输出为1
        
        SEL s2=@selector(bark);
        BOOL isRespond2=[ani respondsToSelector:s2];//ani是Animal的实例对象，但是bark是Dog的特有方法，所以说无法访问
        NSLog(@"isRespond = %d",isRespond2);//输出为0
        
//        所以说我们一般用实例对象调用方法之前，可以先作一个判断，如下：
//        if(isRespond1)
//        {
//            [dog eat];
//        }
//        else
//        {
//            NSLog(@"无法调用");
//        }
//        这样可以把错误扼杀在编译时，而不是到了运行的时候错误才发现。
        
        //*******************************************************
        
//        5）判断类能否调用(相应)指定的方法
        BOOL isRespond3=[Dog instancesRespondToSelector:s1];//s1是eat的SEL封装，eat是Dog的方法，所以可以调用
        NSLog(@"isRespond3 = %d",isRespond3);//输出为1
        
        BOOL isRespond4=[Animal instancesRespondToSelector:s1];//显然Animal不能调用其子类特有的方法
        NSLog(@"isRespond4 = %d",isRespond4);//输出为0
        
        SEL s3=@selector(abc);//abc方法是Animal中的
        BOOL isRespond5=[Dog instancesRespondToSelector:s3];//子类继承父类的abc方法，自然子类可以调用（★这里我要说明一点，如果你在父类中只写了abc方法的声明，而没有写实现的话，这里结果就是0，表示无法调用★）
        NSLog(@"isRespond5 = %d",isRespond5);//输出为1
        
        //*******************************************************
        
    }
    return 0;
}


———————————————————————————————————————————
响应方法（属于动态类型检测部分）

//响应方法（调用方法）
//1.响应无参方法
//2.响应有一个参数的方法
//3.响应有两个参数的方法（因为OC只提供了最多两个参数的响应方法）



#import <Foundation/Foundation.h>

@interface Animal : NSObject
-(void)run;
@end

@implementation Animal
-(void)run
{
    NSLog(@"Animal run!");
}
@end

@interface Dog : Animal
-(void)eat:(NSString *)foodName;
-(void)eat:(NSString *)foodName andDogName:(NSString *)dogName;
@end

@implementation Dog
-(void)eat:(NSString *)foodName
{
    NSLog(@"Dog eat %@",foodName);
}
-(void)eat:(NSString *)foodName andDogName:(NSString *)dogName
{
    NSLog(@"%@ eat %@",dogName,foodName);
}
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
//        以后调用方法，大都以这种形式调用
//        调用方法的时候，我们应该具备这样的思路，养成书写习惯：
//        ①首先调用方法得有 实例对象，所以要先创建实例对象
//        ②其次调用方法前要判断是否能调用，所以要有判断语句（对象是否能调用方法）
//        ③因为判定对象能调用方法的时候这个方法是以SEL的格式去调用的，所以先要将此方法转化成SEL的形式
//        ④然后判断结束后，返回值是1就调用，返回值是0就输出无法调用
//        ⑤最后调用 无参/有参 方法（本节所讲内容）
        //*******************************************************
        Animal *ani =[[Animal alloc]init];//①
        SEL s1=@selector(run);//③
        BOOL isRespond=[ani respondsToSelector:s1];//②
        if (isRespond) {//④
            [ani performSelector:s1];//⑤      实例对象调用无参方法
        }
        else
        {
            NSLog(@"无法调用!");
        }
        //*******************************************************
        Dog *dog=[[Dog alloc]init];
        SEL s2=@selector(eat:);//这里获取含多个参数的方法地址的时候，只写方法名即可
        BOOL isRespond2=[dog respondsToSelector:s2];
        if (isRespond2) {
            [dog performSelector:s2 withObject:@"coffee"];//实例对象调用含有一个参数的方法
        }
        else
        {
            NSLog(@"无法调用!");
        }
        //*******************************************************
        Dog *dog2=[[Dog alloc]init];
        SEL s3=@selector(eat:andDogName:);//只写方法名
        BOOL isRespond3=[dog respondsToSelector:s3];
        if (isRespond3) {
            [dog performSelector:s3 withObject:@"hotdog" withObject:@"bigmax"];//实例对象调用含两个参数的方法
        }
        else
        {
            NSLog(@"无法调用!");
        }
        //*******************************************************
    }
    return 0;
}


———————————————————————————————————————————







版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU - 1232 畅通工程（简单并查集）

畅通工程




Time Limit: 2000MS
 
Memory Limit: 32768KB
 
64bit IO Format: %I64d & %I64u




Submit Status


Description

某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ 

 




Input

测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( < 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。 
注意:两个城市之间可以有多条道路相通,也就是说 
3 3 
1 2 
1 2 
2 1 
这种输入也是合法的 
当N为0时，输入结束，该用例不被处理。 

 




Output

对每个测试用例，在1行里输出最少还需要建设的道路数目。 

 




Sample Input


4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0 

 




Sample Output


1
0
2
998 






#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int MAXN = 1010;
int parent[MAXN];
int n, m;

void make_set()
{
	for (int i = 0; i <= n; i++)
		parent[i] = -1;
}

int find_set(int t)
{
	if (parent[t] == -1)
		return t;
	else
		return parent[t]=find_set(parent[t]);
}

void union_set(int a, int b)
{
	int t1 = find_set(a);
	int t2 = find_set(b);
	if (t1 != t2)
		parent[t2] = t1;
}

int main()
{
	int a, b;
	while (scanf("%d", &n) != EOF&&n)
	{
		scanf("%d", &m);
		make_set();
		for (int i = 0; i < m; i++)
		{
			scanf("%d%d", &a, &b);
			union_set(a, b);
		}
		int sum = 0;
		for (int i = 1; i <= n;i++)
		if (parent[i] == -1)
			sum++;
		printf("%d\n", sum-1);
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

at91sam9g25处理器uboot移植 个人笔记一


1 生成补丁 与 打补丁


  生成补丁 diff -upNr old/ new/ > patch-x.y.z
  diff -upNr u-boot-2014.07/ u-boot-2014.07_moveto9g25/ > moveto9g25-2015.08.25-ok.patch
  打补丁   cd old
           patch -p1 < ../patch-x.y.z
----------------------------------------------------------------------------------------------
2 修改boards.cfg 与 Makefile
  Status, Arch, CPU:SPLCPU, SoC, Vendor, Board name,    Target,        Options, Maintainers
  Active  arm   arm926ejs  at91  atmel   at91sam9g25jzq at91sam9g25jzq_nandflash
         at91sam9g25jzq:AT91SAM9G25,SYS_USE_NANDFLASH    Zhaigch <zhaigcherer@qq.com>


  修改Makefile,指定CROSS_COMPILE = arm-linux-
  拷贝board/atmel/at91sam9x5ek 为 at91sam9g25jzq对应配置文件里的Board name
  拷贝include/configs/at91sam9x5ek.h 为 at91sam9g25jzq.h
  生成配置头文件 make <Target>_config
  make at91sam9g20ek_nandflash_config
  make at91sam9g25jzq_nandflash_config
  make
  make u-boot.dis //生成反汇编文件
----------------------------------------------------------------------------------------------  
3 搜索字符串命令
  grep -nR "xx" ./
  使用4.3.2交叉编译器编译时出错 armv5te指令集不兼容,使用arm-none-gnueabi-4.7.3编译顺利通过。
  
  修改 configs/at91sam9g25jzq.h 里的宏定义为“CONFIG_SYS_TEXT_BASE
0x22000000”
  使程序编译后的运行地址为22000000开始,将nand中拷贝出的程序放到该地址后，直接跳转执行。
  发现源码做的太好了，直接就跑起来了！
---------------------------------------------------------------------------------------------- 
4 启动分析一
  arch/arm/lib/vectors.S    //中断向量表,跳转到 reset,即：
  arch/arm/cpu/arm926ejs/start.S //这里如果没有分两级引导的话,这里需要进行一些必要的初始化操作
    //如关闭内部看门狗,初始化系统时钟,初始化ddr2内存,从nand中拷贝程序到内存中等操作。
    //由于我们是二级启动uboot,以上这些已经被1级引导程序完成,因此 通过宏CONFIG_SKIP_LOWLEVEL_INIT
    //直接跳过这些过程直接调用 _main
  arch/arm/lib/crt0.S  // _main在该文件中定义
    //初始化sp为 CONFIG_SYS_INIT_SP_ADDR = 0x20000000 + 4096 - GENERATED_GBL_DATA_SIZE
    //sub sp, sp, #GD_SIZE   ,接着在sp上方又分配出 GD_SIZE大小的内存
    //mov r9, sp,此时r9保存的就是GD_SIZE大小的内存的起始地址,也可以认为是某个全局变量结构体的指针
    //调用 board_init_f,根据配置头文件中的宏 CONFIG_SYS_GENERIC_BOARD,common/board_f.c被编译
    #define DECLARE_GLOBAL_DATA_PTR register volatile gd_t *gd asm ("r9")
  common/board_f.c  //如果没有该宏,arm/lib/board.c会被编译,该文件以后会被踢出源码,尽量不要链接它
    bl board_init_f //板初始化,完成什么操作呢？
---------------------------------------------------------------------------------------------- 
5 启动分析二
  board_init_f
    gd = &data; // gd全局数据指针指向在堆栈里定义的结构体,这里不使用上一步在堆栈外分配的内存
                // 为什么?以后再分析
    initcall_run_list(init_sequence_f) //调用init_sequence_f数组中的全部函数
setup_mon_len,     //填充 gd->mon_len 程序长度
setup_fdt,         //填充 gd->fdt_blob = 0
trace_early_init,  //空
arch_cpu_init,     //调用at91_clock_init,填充gd->arch 时钟相关数据
mark_bootstage,    //"board_init_f"字符串放入record[]数组记录表中
timer_init,        //初始化pit,填充gd->arch.timer_rate_hz gd->arch.tbu = gd->arch.tbl = 0
env_init,          //根据配置文件中宏 CONFIG_ENV_IS_IN_NAND, env_nand.c被编译连接
                  //env_init被调用,填充gd->env_addr环境变量存放地址
                  //填充gd->env_valid环境变量有效标识
init_baud_rate,
  //填充gd->baudrate
serial_init, 
/* serial communications setup */
console_init_f,    //填充gd->have_console = 1,初始化print缓冲,从此可以使用printf打印功能
display_options,   //console中打印 uboot版本信息与编译日期
display_text_info,
/* show debugging info if required */
print_cpuinfo,     //打印处理器型号,主时钟,系统时钟,外设时钟
announce_dram_init,//puts("DRAM:  ");
dram_init,         //填充gd->ram_size = 0x4000000
setup_dest_addr,   //填充gd->relocaddr = gd->ram_top = 0x24000000
reserve_round_4k,  //4k对齐gd->relocaddr &= ~(4096 - 1);
reserve_trace,     //null
reserve_uboot,     //gd->relocaddr -= gd->mon_len;留出uboot的代码空间 
                      //gd->relocaddr &= ~(4096 - 1);4K对齐 
                      //gd->start_addr_sp = gd->relocaddr;堆栈空间
setup_machine,     //gd->bd->bi_arch_number = CONFIG_MACH_TYPE 设置板号
reserve_global_data,//gd->start_addr_sp -= sizeof(gd_t);堆栈下移,分配空间gd_t
                  //gd->new_gd = gd->start_addr_sp 指向新分配的内存地址
reserve_fdt,       //gd->start_addr_sp -= gd->fdt_size; 为fdt分配内存空间
                  //gd->new_fdt = gd->start_addr_sp 指向新分配的fdt内存空间
reserve_stacks,    //2字节对齐,为IRQ中断分配内存
setup_dram_config, //null
show_dram_config,  //打印出dram的大小
display_new_sp,    //调试时打印 gd->start_addr_sp
reloc_fdt,         //重定位fdt,进行数据拷贝
setup_reloc,       //gd->reloc_off = gd->relocaddr - 0x22000000;
                  //memcpy(gd->new_gd, (char *)gd, sizeof(gd_t)); 将gd内的数据拷贝到新的地址
  
---------------------------------------------------------------------------------------------- 
6 启动分析三
  在调用board_init_f()完成板卡与全局结构体变量 gd 的初始化后将其拷贝到在代码段下重新分配的全局结构
  体中。接下来进行sp的重新设置，将r9指向重新分配的全局变量gd，然后进行代码的重定位。
    ldr sp, [r9, #GD_START_ADDR_SP]
/* sp = gd->start_addr_sp */
    bic sp, sp, #7
/* 8-byte alignment for ABI compliance */
    ldr r9, [r9, #GD_BD]
/* r9 = gd->bd */
    sub r9, r9, #GD_SIZE
    
  修改代码返回值,使其值为重定位后的地址
    adr lr, here
    ldr r0, [r9, #GD_RELOC_OFF]
/* r0 = gd->reloc_off */
    add lr, lr, r0
    ldr r0, [r9, #GD_RELOCADDR]
/* r0 = gd->relocaddr */
  拷贝代码到重定位的地址空间去
    b relocate_code 
  arch/arm/lib/relocate.S
  将链接脚本中代码段从 __image_copy_start 到 __image_copy_end之间的 代码段、数据段和命令行段
  拷贝到重定位的地址 gd->relocaddr 处
  拷贝完成后,还需要将从 __rel_dyn_start到 __rel_dyn_end之间的 .rel.dyn段(代码重定位时使用,默认应该
  是由编译器产生的相关寻址相关的数据)
  完成代码的重定义后，返回到重定位后的代码中
  bl c_runtime_cpu_setup //arch/arm/cpu/arm926ejs/start.S 无其它需要初始化的操作,直接返回
  接下来初始化bss段
  接下来调用board_init_r函数
    mov r0, r9 //将重定位后新的gd指针作为参数0传入函数
    ldr r1, [r9, #GD_RELOCADDR] //重定位后代码段的起始地址作为参数1传入函数
    ldr pc, =board_init_r //绝对地址跳转,由于代码重定位后,同时根据重定位后相对于之前程序的偏移值
    对程序的运行地址进行了修正,从而保证重定位后,通过绝对地址跳转时的正确运行。
---------------------------------------------------------------------------------------------- 
7 启动分析四
  board_init_r
    initcall_run_list(init_sequence_r) //循环调用结构体 init_sequence_r 中的全部函数
  initr_caches //打开处理器的数据和指令cache,需要自己添加
  board_init //与具体的板卡相关的外设的初始化,以及gd->bd相关的元素进行初始设置,需要移植修改
  initr_serial //再次初始化串口
  initr_malloc //初始化分配的堆空间内存,
  bootstage_relocate //启动阶段重定位,干嘛的 未知
  power_init_board //空,如果需要自定义相关操作
  initr_flash // nor flash的初始化,如果板上没有Nor flash需要配置宏 CONFIG_SYS_NO_FLASH
  initr_nand //nand flash的初始化,需要配置宏 CONFIG_CMD_NAND
  initr_env //初始化环境变量
    set_default_env() //如果从flash中没有读到环境变量则使用默认的的环境变量default_environment
      "bootargs=" CONFIG_BOOTARGS "\0"
      "bootcmd=" CONFIG_BOOTCOMMAND "\0"
      "nfsboot=" CONFIG_NFSBOOTCOMMAND
"\0"
      "bootdelay=" __stringify(CONFIG_BOOTDELAY)
"\0"
      "baudrate=" __stringify(CONFIG_BAUDRATE)
"\0"
      "ethaddr=" __stringify(CONFIG_ETHADDR)
"\0"
      "ipaddr=" __stringify(CONFIG_IPADDR)
"\0"
      "serverip=" __stringify(CONFIG_SERVERIP)
"\0"
      "gatewayip=" __stringify(CONFIG_GATEWAYIP)
"\0"
      "netmask=" __stringify(CONFIG_NETMASK)
"\0"
    
  initr_secondary_cpu //空,__weak标记的虚弱函数,如果编译的程序里有相同函数名的函数则用它代替自己
  stdio_init //标准输入输出初始化
  initr_jumptable //初始化跳转表,干嘛的 未知
  console_init_r //控制命令行相关的初始化操作,不需要移植,不用关心它。
  interrupt_init //中断初始化,不关心中断,能引导linux内核就行了,
  initr_ethaddr  //初始化网卡地址,需要配置宏 CONFIG_CMD_NET
  initr_net      //初始化网卡,需要配置宏 CONFIG_CMD_NET
  run_main_loop  //主循环,死循环中运行main_loop,去解析用户输入的命令行,或系统自动运行的命令
    main_loop
---------------------------------------------------------------------------------------------- 
8 启动分析五
  由于在9g25处理器的引导过程中,在uboot之前有一个初始的引导程序，该程序完成了 中断向量表的初始化
  fiq irq的中断场景记录和sp的设置,ddr内存初始化,系统时钟工作在399Mhz,外设时钟工作在133Mhz,调试
  串口bps为115200,然后将nand的0x40000开始的0x80000(512k)长的数据拷贝到ddr内存0x23000000处,然后
  通过ldr pc,=0x23000000 绝对地址跳转到23000000地址运行拷贝到些处的uboot程序.
  
  由于在uboot中会执行一些关于协处理的操作(MMU、Icache、Dcache)指令MRC(读协处理器),MCR(写协处理器),
  这两条指令必须在特权模式下执行,因此在跳转到uboot前先让处理器工作在svc管理模式,否则在执行到这
  样的命令时会触发 未定义 指令的中断。
  打补丁测试
  tar xjf u-boot-2014.07.tar.bz2 
  cd u-boot-2014.07/
  patch -p1 < ../moveto9g25-2015.08.25-ok.patch 
  make at91sam9g25jzq_nandflash_config
  make
  make u-boot.dis
  
  nfs 22000000 192.168.0.1:/home/terminal/workspace/nfs/image/uImage_1
  
  












版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模式之一简单工厂模式
根据用户需求实例化不同对象。



//simple factory model

#include<iostream>

using namespace std;

//用一个单独的类来做这个创造实例的过程，即工厂
class Operation{
public:
	Operation()
	{
		number1=0;
		number2=0;
		result=0;
	}

	Operation(int one,int two):number1(one),number2(two)
	{
		result=0;
	}

	void setOne(int one)
	{
		number1=one;
	}

	void setTwo(int two)
	{
		number2=two;
	}
	
	int getOne()
	{
		return number1;
	}

	int getTwo()
	{
		return number2;
	}

	virtual int getResult()
	{//虚接口，需要子类自己实现
		return result;
	}

protected:
	int number1;
	int number2;
	int result;
};

//四个具体操作的子类，主要用于实现虚函数接口
class AddOperation:public Operation{
public:
	virtual int getResult()
	{
		result=number1+number2;
		return result;
	}
};

class SubOperation:public Operation{
public:
	virtual int getResult()
	{
		result=number1-number2;
		return result;
	}
};

class MulOperation:public Operation{
public:
	virtual int getResult()
	{
		result=number1*number2;
		return result;
	}
};

class DivOperation:public Operation{
public:
	virtual int getResult()
	{
		result=number1/number2;
		return result;
	}
};

//工厂，一个接口类
class SimpleFactory{
public:
	static Operation* createOper(char operChar)
	{
		static Operation* oper;
		
		switch(operChar)
		{
			case '+':
				oper=new AddOperation();
				break;
			case '-':
				oper=new SubOperation();
				break;
			case '*':
				oper=new MulOperation();
				break;
			case '/':
				oper=new DivOperation();
				break;
			default:
				break;
		}
		return oper;	
	}
};

int main()
{
	char operChar;
	int number1,number2;
	cout<<"please input number1:";
	cin>>number1;
	cout<<endl;

	cout<<"please input number2:";
	cin>>number2;
	cout<<endl;

	cout<<"please input a operation:";
	cin>>operChar;
	cout<<endl;

	Operation* oper;//具体操作在创建时确定

	opedgr=SimpleFactory::createOper(operChar);//根据输入实例化对象
	//当需要新增其他操作时，只需要添加操作类及修改工厂，与客户端无关，客户端看不到改变
	oper->setOne(number1);
	oper->setTwo(number2);

	cout<<"The Result is:";
	cout<<oper->getResult()<<endl;

	return 0;
}



投篮，当投篮率为多少时，选择玩法1或者玩法2


版权声明：本文为博主原创文章，未经博主允许不得转载。

Python 并行分布式框架：Celery 超详细介绍
先来一张图，这是在网上最多的一张Celery的图了，确实描述的非常好

Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。
消息中间件
Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis, MongoDB (experimental), Amazon SQS (experimental),CouchDB (experimental), SQLAlchemy (experimental),Django ORM (experimental), IronMQ
任务执行单元
Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。
任务结果存储
Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, Redis，memcached, MongoDB，SQLAlchemy, Django ORM，Apache Cassandra, IronCache
OK 废话就说到这， 来点使用的。
首先你也看到了， 你要有一个消息中间件，此处我们选择rabbitmq，为什么不用redis或者sqs呢，首先这两个我都用过了，想接触以下rabbitmq，所以果断选择这个。
Now 安装rabbitmq！ 
官网介绍有安装方法， 我贴以下网址吧，自己看看，很简单很简单。 我是Mac系统 http://www.rabbitmq.com/install-standalone-mac.html 如果是其他系统自己对应下。 可以把sbin的路径配置到path里面（我比较懒 没加，所以去到解压目录，囧）
启动管理插件：sbin/rabbitmq-plugins enable rabbitmq_management 
启动rabbitmq：sbin/rabbitmq-server -detached
ok， now，rabbitmq已经启动，可以打开页面来看看 
地址：http://localhost:15672/#/ 
用户名密码都是guest 
现在可以进来了把，可以看到具体页面。 
关于rabbitmq的配置，网上很多 自己去搜以下就ok了。
好了 消息中间件有了，现在该来代码了，我是在celeby官网看的，如果觉得我代码有问题，可以自己去官网看，嘿嘿。
安装celeby。 
建议使用 virtualenv，具体怎么用 参考 
http://www.nowamagic.net/academy/detail/1330228 
http://liuzhijun.iteye.com/blog/1872241
首先，定义一个task。
from celery import Celery

app = Celery('tasks', backend='amqp://guest@localhost//', broker='amqp://guest@localhost//')

@app.task
def add(x, y):
    return x + y
保存为tasks.py 
—>broker 就是中间件了，自己看着改吧, backend就是 后端来发送状态消息，保持追踪任务的状态，存储或发送这些状态
Now 可以启动了 
命令: celery -A tasks worker –loglevel=info 
想要查看完整的命令行参数列表 
命令：celery worker –help 或者 
          celery help
现在 另开一个terminal，启用虚拟环境， ipython 启动python console
In [9]: from tasks import add

In [10]: result = add.delay(6, 7)
现在你可以在用之前命令启动的终端中看到输出，而且可以验证结果。 
调用任务会返回一个 AsyncResult 实例，可用于检查任务的状态，等待任务完成或获取返回值， 而且现在我们也设置了一个用于保存结果和状态等信息的backend， 现在你可以成功的拿到结果， 如果你print result， 你会看到一串字符串， 类似与uuid。 
如下方式：
In [11]: result.ready()
Out[11]: True

In [12]: result.get(timeout=1)
Out[12]: 13

In [13]: result.get(propagate=False)
Out[13]: 13
ok 现在看到结果了吧。 
注： propagate的作用 倘若任务抛出了一个异常， get() 会重新抛出异常， 但你可以指定 propagate 参数来覆盖这一行为。
以上就是一些代码了。
下面是 celery的配置，配置的话 你不想看这个 可以去官网看，比我的详细的多。
app.conf.update(
    CELERY_TASK_SERIALIZER='json',
    CELERY_ACCEPT_CONTENT=['json'],  # Ignore other content
    CELERY_RESULT_SERIALIZER='json',
    CELERY_TIMEZONE='Europe/Oslo',
    CELERY_ENABLE_UTC=True,
)
但是对于大型项目来说 这样配置就显得很low，这个时候可以用模块。你可以调用 config_from_object() 来让 Celery 实例加载配置模块。 
app.config_from_object(‘celeryconfig’)
celeryconfig.py
BROKER_URL = 'amqp://'
CELERY_RESULT_BACKEND = 'amqp://'

CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_ACCEPT_CONTENT=['json']
CELERY_TIMEZONE = 'Europe/Oslo'
CELERY_ENABLE_UTC = True
可以使用 python -m celeryconfig 来验证配置是否正确。
好了 这是这篇博客的全部，稍后还有有的，谢谢。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【C++】复数类的实现
#include<iostream>
using namespace std;
class Complex
{
private:
 double _real;
 double _image;
public:
 Complex(double real = 2.2,double image=1.1)//构造函数
 {
  cout<<"构造函数被调用"<<endl;
  _real = real;
  _image = image;
 }
 Complex(const Complex& d)//拷贝构造函数
 {
  cout<<"拷贝构造函数被调用"<<endl;
  this->_real = d._real ;
  this->_image = d._image ;
 }
 ~Complex()
 {
  cout<<"析构函数被调用"<<endl;
 }
 void Display()
 {
  cout<<"Real:"<<_real;
  cout<<"   Image:"<<_image<<endl;
 }
public:
 Complex& operator=(const Complex& d)
 {
  if(this != &d)
  {
   cout<<"赋值运算符被重载"<<endl;
   this->_real = d._real ;
   this->_image = d._image ;
  }
  return *this;
 }
 Complex& operator++()
 {
  cout<<"前置++被重载"<<endl;
  this->_real++;
  return *this;
 }
    Complex operator++(int)
 {
  cout<<"后置++被重载"<<endl;
  Complex *tmp = this;
  this->_real++;
  return *tmp;
 }
 Complex& operator--()
 {
  cout<<"前置--被重载"<<endl;
  this->_real --;
  return *this;
 }
 Complex operator--(int)
 {
  cout<<"后置--被重载"<<endl;
  Complex *tmp = this;
  this->_real --;
  return *tmp;
 }
 Complex operator+(const Complex& d)
 {
  cout<<"+被重载"<<endl;
  Complex tmp ;
  tmp._real = this->_real + d._real ;
  tmp._image = this->_image + d._image ;
  return tmp;
 }
 Complex operator-(const Complex& d)
 {
  cout<<"-被重载"<<endl;
  Complex tmp;
  tmp._real = this->_real - d._real ;
  tmp._image = this->_image - d._image;
  return tmp;
 }
 Complex& operator-=(const Complex& d)
 {
  cout<<"-=被重载"<<endl;
  this->_real -= d._real ;
  this->_image -= d._image ;
  return *this;
 }
 Complex& operator+=(const Complex& d)
 {
  cout<<"+=被重载"<<endl;
  this->_real +=  d._real ;
  this->_image +=  d._image ;
  return *this;
 }
 Complex operator*(const Complex& d)
 {
  Complex tmp;
  tmp._real = this->_real * d._real - this->_image * d._image;
  tmp._image = this->_image * d._real + this->_real * d._image;
  return tmp;
 }
 Complex operator/(const Complex& d)
 {
  Complex tmp;
  tmp._real = (this->_real * d._real + this->_image * d._image)/
   (d._real * d._real +d._image * d._image);
  tmp._image = (this->_image * d._real - this->_real * d._image)/
   (d._real * d._real +d._image * d._image);
  return tmp;
 }

};
 
int main()
{
 Complex d1;
 d1.Display();
 //Complex d2(d1);
 Complex d2 = d1;
 d2.Display();
 Complex d3(4.4,5.5);
 d3.Display() ;
 d3 = d2;
 d3.Display();
    ++d3;
 d3.Display ();
 d3++;
 d3.Display ();
 --d3;
 d3.Display ();
 d3--;
 d3.Display ();
 //system(pause);
 d3 = d3+d1;
 d3.Display ();
 d3 = d3-d1;
 d3.Display ();
 d3-=d1;
    d3.Display ();
 getchar();
 return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Java知识总结----Spring拦截器（六）
        在看到拦截器的时候，大家一定会想到另外一个词，就是过滤器。两者到底有什么区别呢？过滤器，从字面的意思理解就是过滤用的，当很多请求过来的时候，我们对其进行过滤，满足一定条件的时候，才放行。在Java中，过滤器是使用Filter实现的，实现原理都是基于回调函数的。最常见的过滤器的应用就是字符编码的过滤、用户信息验证的过滤等。拦截器呢，就是用来拦截的，可以在方法的执行时，添加一些其他的信息，拦截器是使用Interceptor实现的，实现原理是基于Java的反射机制的。最常见的拦截器的应用有：添加访问日志、性能监控等。今天我们就来看看怎么用Spring的拦截器为方法添加访问日志。
       首先，我们创建一个拦截器类，由于我们需要拦截的是方法，所以，就继承MethodInterceptor类。

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 监控日志拦截器
 * @author lizhiyang
 *
 */
public class MonitorLogInterceptor implements MethodInterceptor {
	
	private Logger logger = LoggerFactory.getLogger(MonitorLogInterceptor.class);

	public Object invoke(MethodInvocation methodinvocation) throws Throwable {
		Method method = methodinvocation.getMethod();
		//方法执行前输出
		logger.info("methodIn:methodName="+method.getName());
		try {
			//执行方法
			return methodinvocation.proceed();
		} finally {
			//方法执行后输出
			logger.info("methodOut:methodName="+method.getName());
		}
	}

}

在方法的执行前和执行后都加上日志输出。

接着，有的时候，我们可能需要自定义多个拦截器，这个时候，我们需要有一个拦截器链，把这些拦截器都串起来。

import java.util.ArrayList;
import java.util.List;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

/**
 * 拦截器链
 * @author lizhiyang
 *
 */
public class InterceptorChain implements MethodInterceptor {

	private List<MethodInterceptor> chains;
	
	public Object invoke(MethodInvocation methodinvocation) throws Throwable {
		InterceptorChainSupport support = new InterceptorChainSupport(methodinvocation, new ArrayList<MethodInterceptor>(chains));
		return support.proceed();
	}

	public List<MethodInterceptor> getChains() {
		return chains;
	}
	
	public void setChains(List<MethodInterceptor> chains) {
		this.chains = chains;
	}
}
里面我们用到了一个类：InterceptorChainSupport，他的实现如下：

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Method;
import java.util.List;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class InterceptorChainSupport implements MethodInvocation {
	
	private MethodInvocation proxy;
	private List<MethodInterceptor> chains;
	
	public InterceptorChainSupport(MethodInvocation proxy,List<MethodInterceptor> chains) {
		this.proxy = proxy;
		this.chains = chains;
	}

	public MethodInvocation getProxy() {
		return proxy;
	}

	public void setProxy(MethodInvocation proxy) {
		this.proxy = proxy;
	}

	public List<MethodInterceptor> getChains() {
		return chains;
	}

	public void setChains(List<MethodInterceptor> chains) {
		this.chains = chains;
	}

	public Object[] getArguments() {
		return proxy.getArguments();
	}

	public AccessibleObject getStaticPart() {
		return proxy.getStaticPart();
	}

	public Object getThis() {
		return proxy.getThis();
	}

	public Object proceed() throws Throwable {
		//如果拦截器链不空，则继续执行拦截器
		if(chains != null && chains.size() > 0) {
			//递归调用，一直调用到拦截器链的最后一个
			return (chains.remove(0)).invoke(this);
		} else {
			return proxy.proceed();
		}
	}

	public Method getMethod() {
		return proxy.getMethod();
	}
}
InterceptorChainSupport是真正来处理拦截器链的，遍历执行所有的拦截器。在InterceptorChain中构造InterceptorChainSupport的时候要特别注意，一定要new一个新的List来存放chains，否则，会造成调用链只能执行一次的情况。
此处的执行过程是这样的：当调用相应的方法时，调用InterceptorChain.invoke()----->InterceptorChainSupport.proceed()---->***Interceptor.invoke()------>InterceptorChainSupport().proceed()------......---->真正的方法处理---->方法之后的拦截处理。


最后，我们在spring的配置文件中，来配置拦截器。


<!-- 配置日志监控拦截器 -->
	<bean id="monitorLogInterceptor" class="com.demo.interceptor.MonitorLogInterceptor" />
	
	<!-- 配置拦截器链，保存所有的拦截器 -->
	<bean id="interceptorChain" class="com.demo.interceptor.InterceptorChain">
		<property name="chains">
			<list>
				<ref bean="monitorLogInterceptor"/>
			</list>
		</property>
	</bean>
	
	<!-- 配置拦截器和需要拦截的bean -->
	<bean id="serviceProxyCreator" class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
		<property name="interceptorNames">
			<list>
				<value>interceptorChain</value>
			</list>
		</property>
		<property name="beanNames">
			<value>*Service</value>
		</property>
	</bean>
这样配置之后，在spring容器加载的时候，spring就知道了执行*Service类中的方法时候，需要应用interceptorChain中的拦截器。

这个时候呢，就有了一个问题，如果我不想给这个类的每个方法都进行拦截，只拦截一部分呢？这个时候我们可以借助注解来实现。为需要拦截的方法上加上注解。
首先我们创建一个注解类，MonitorLog。

/**
 * 	1.RetentionPolicy.SOURCE ——只在源代码级别保留,编译时就会被忽略
	2.RetentionPolicy.CLASS ——编译时被保留,在class文件中存在,但JVM将会忽略
	3.RetentionPolicy.RUNTIME —— 被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.
 *
 */
@Retention(RetentionPolicy.RUNTIME)
/**
 * 该注解应用于方法
 */
@Target(ElementType.METHOD)
/**
 * 指明被注解的类会自动继承，如果我们把注解放在接口的方法上，那么实现该接口的类也会被继承该注解
 */
@Inherited
/**
 * Documented 注解表明这个注解应该被 javadoc工具记录.
 */
@Documented
public @interface MonitorLog {

}
然后我们在需要拦截的方法上天剑@MonitorLog注解。


public interface UserService {
	@MonitorLog
	public boolean insertUser(UserModel user);
	public UserModel getUser(int userId);
	public String test();
	public void user(String name);
}
我们现在还需要修改MonitorLogInterceptor类，只有添加@MonitorLog的方法才进行拦截，其他的不拦截。


public class MonitorLogInterceptor implements MethodInterceptor {
	
	private Logger logger = LoggerFactory.getLogger(MonitorLogInterceptor.class);

	public Object invoke(MethodInvocation methodinvocation) throws Throwable {
		Method method = methodinvocation.getMethod();
		//获取方法的MonitorLog注解
		MonitorLog log = method.getAnnotation(MonitorLog.class);
		boolean bLog = false;
		//该方法存在MonitorLog注解，则输出日志
		if(log != null) {
			bLog = true;
			//方法执行前输出
			logger.info("methodIn:methodName="+method.getName());
		}
		try {
			//执行方法
			return methodinvocation.proceed();
		} finally {
			if(bLog) {
				//方法执行后输出
				logger.info("methodOut:methodName="+method.getName());
			}
		}
	}

}
以上，就是spring拦截器的一个简单的应用。当然了，我们也可以使用spring的aop标签，来进行具体的配置。


版权声明：本文为博主原创文章，未经博主允许不得转载。

ACM学习-图双连通子图

// ACM学习-割点和桥.cpp : 定义控制台应用程序的入口点。
//


#include "stdafx.h"
#include<iostream>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;


const int v = 13;
int edge[v][v] = {
{ 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0 },
{ 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1 },
{ 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{ 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0 },
{ 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0 },
{ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 },
{ 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 },
{ 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1 },
{ 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0 }
};
bool vis[v] = { false };
char t[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
'I', 'J', 'K', 'L', 'M' };
//queue<int> q;
//判断i点到j点是否有两条路径
bool is_can_shuang_lian_tong(int i, int j){


for (int i = 0; i<v; i++){
vis[i] = false;
}
queue<int> q;
q.push(i);
vis[i] = true;
int count = 0;
while (q.size() > 0){
int k = q.front();
q.pop();
if (edge[k][j]){
count++;
vis[j] = true;
if (count == 2)
return true;
}
for (int i = 0; i < v; i++){
if (edge[k][i] && !vis[i])
{
vis[i] = true;
q.push(i);
}
}
}
return false;
}
void print(int i)
{
cout << t[i] << ends;
}
void bian_zi_tu(){//广度优先遍历


queue<int> q;
vector<int> vnum;
int yy[v][v];//这个变量可以去除，没用
memcpy(yy, edge, v*v * sizeof(int));
for (int i = 0; i<v; i++){
vis[i] = false;
}
for (int i = 0; i<v; i++){
if (!vis[i])
{
vis[i] = true;
vnum.clear();
q.push(i);
vnum.push_back(i);
while (q.size() > 0){
int k = q.front();
q.pop();
for (int i = 0; i < v; i++){
if (yy[k][i]&&!vis[i])
{
//yy[k][i] = 0;
//yy[i][k] = 0;
vis[i] = true;
q.push(i);
vnum.push_back(i);
}
}
}//while
for_each(vnum.begin(),vnum.end(),print);
cout << endl;
}
}



}
//得到一个图中是否有双连通子图
void get_shuang_lian_tong(){
bool isContinue = true;
while (isContinue){
int count = 0;
int index = 0;
isContinue = false;//由于删除了节点关系，可能要再删一次
for (int i = 0; i < v; i++){//如果某个节点只有一个节点跟它相连，则删除它与连着的那个节点的关系
count = 0;
for (int j = 0; j < v; j++){
if (edge[i][j]){
++count;
index = j;
}
}
if (count ==1)
{
isContinue = true;
edge[i][index] = 0;
edge[index][i] = 0;
}

}


}
for (int i = 0; i < v; i++){
for (int j = 0; j < v; j++){
if (edge[i][j]){
if (!is_can_shuang_lian_tong( i,j))//判断i与j是否有两条路径
{//如果没有删除他们的关系
edge[i][j] = 0;
edge[j][i] = 0;
}
}
}
}





}


int _tmain(int argc, _TCHAR* argv[])
{

get_shuang_lian_tong();
/*for (int i = 0; i < v; i++){
for (int j = 0; j < v; j++){
if (edge[i][j])
{
cout << t[i] << "和" << t[j] << "连着" << endl;
}
}
}*/
bian_zi_tu();
return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 5127 Dogs' Candies【CDQ分治+动态凸包】
HDU 5127 Dogs’ Candies【CDQ分治+动态凸包】
题意：
一个狗国家的狗国王有一个装糖的盒子，每颗糖有两个属性p,q，分别代表甜度和咸度，每只狗对于甜度和咸度的偏爱度不一样，所以每条狗有两个参数x, y，每颗糖对于特定的狗的美味度等于p*x+q*y。现在有50000个操作，分为三种：

将新的糖(p,q)放入盒子中
将盒子中存在的糖(p,q)吃掉
给出一条狗的参数(x,y)，询问当前存在的糖的最大美味度。

解法：
这个题是2014年广州现场赛的A题，模拟赛做的时候虽然推出了公式，但是并没有发现最优解为凸包的性质，于是一直到比赛结束都没有做出这个题，但是当时最诡异的是，有一个排名比较靠后的队伍在16分钟就将此题一血拿走，整场比赛解出此题的不过10支左右队伍。当比赛结束的时候，看了一下别人的代码，发现我能在hust上面看到的代码居然都是暴力水过去的！…我觉得好醉啊…，继续在网上买了搜索此题题解，发现都是直接 n2n^2暴力来一遍的…，仔细想了一下，n2n^2暴力的话，复杂度在最坏的情况下为25000∗2500025000*25000，大概6∗1086*10^8左右，这种复杂度我是无论如何都不敢敲的…，但是如果数据是随机生成的话，询问，插入，删除操作只占50000∗1/350000*1/3，那么这个复杂度以当时的30s的时限来说，还是可以跑出结果的…于是这么一个现场10支队伍过的难题，就被这样水过去了。
此题虽然能够暴力水过去，但是无疑思考更一般的通解是很有必要的。 
后来听说翁教他们当时是分块暴力重建凸包过去的，我就去请教了一下翁教，终于由之前的公式发现了最优解在凸包上的这一重大性质。 
此题正解应该是cdq分治+维护动态凸包，或者分块暴力重建凸包。而我的做法是CDQ维护凸包。具体是这样的：
首先得先分析出最优解一定在凸包上这一性质：
考虑这样的两颗糖果A(p1,q1),B(p2,q2)A(p_1,q_1), B(p_2,q_2)，假设A比B优，那么存在这样的表达式：p1∗x+q1∗y≥p2∗x+q2∗yp_1*x+q_1*y \geq p_2*x+q_2*y,变形一下式子之后得到这样的表达式：p2−p1q2−q1≤−yx(x>0且q2>q1)\dfrac{p_2-p_1}{q_2-q_1}\leq\dfrac{-y}{x}(x>0 且q_2>q_1)，也就是说，只要A，B满足上述式子就一定存在A比B更优。我们可以将q看成横坐标，p看成纵坐标，将每一颗糖看成一个点。假设K=−yxK=\dfrac{-y}{x}，考虑这样的三个点A(q1,p1),B(q2,p2),C(q3,p3)A(q_1,p_1), B(q_2,p_2), C(q_3,p_3)。                   设AB的斜率为k1k_1, BC的斜率为k2k_2, 则A比B优需要满足k1<Kk_1<K，B比C更优需要满足k2<Kk_2<K，那么B比A,C都优的话，就需要满足k2<K<k1k_2<K<k_1，也就是说需要满足k2<k1k_2<k_1，这种情况只有在三个点构成的图为上凸壳的时候才满足，如果图形是下凸壳的话，中间的B点一定不可能比AC都优。 
于是这里可以知道的是对于特定的KK来说，最优解一定在可选点构成的上凸包上面，由于之前限定了(x>0且q2>q1)(x>0 且q_2>q_1)当这个条件改变的时候，最优解也可能在下凸包上。于是我们只需要维护一个动态的凸包，对于每一个询问，在相应的上凸壳或下凸壳上二分斜率就能找到最优解。
至于这里如何维护凸包的话，如果做过维护动态凸包的类似题的话，此时肯定就迎刃而解。
我的方法是用CDQ分治做这个凸包。 
对于一个区间[l,r]，我首先将存在于[l, mid]中的点集取出来做出一个凸包，对于[l, mid]之间的‘-1’操作，如果删除的是[l, mid]之间的点，那么就正常的删点；如果删的点是l左边的点，那么这个删除操作就忽略。然后利用构建好的这个凸包去更新[mid+1, r]中的所有询问操作。
看似好像没问题，但是实际上这是错的… 
因为在区间[mid+1, r]中可能存在删除操作，删掉了之前构建好的凸包上面的点，导致更新后面的询问出现错误，那么我们还需要做的就是在删除点之后，继续维护这个凸包。对于[mid+1, r]中的加点操作，我们是可以忽略的，因为后面更新右区间的时候也会更新的。 
删除点的维护操作是这样的，首先现在凸包上面找到这个点，如果没找到说明不会改变凸包，但是也要将这个点标记为已删除的点。如果这个点在凸包上面，那么找到这个点的在凸包上的前驱和后继，将该点删除，然后在最开始构筑凸包的那个数组中，重新构造前驱到后继之间的凸包，最后在加上后面的凸包即可。 
做完这一步的话，就可以正常的更新所有询问咯~ 
复杂度O(n∗log2n∗log2n)O(n*log_2n*log_2n)。这个算法在hdu上面目前暂居时间排名第一^_^(赶紧截图留念…不然要被超啦..对了，第二的关云长是我前半小时在hust上面交的~~)
代码：

#include <iostream>
#include <cstdio>
#include <stack>
#include <cstring>
#include <queue>
#include <algorithm>
#include <cmath>
#include <map>
//#include <unordered_map>
#define N 50010
using namespace std;
typedef long long LL;
typedef pair<int,int> PII;
const LL INF=0x3f3f3f3f3f3f3f3fLL;
void Open()
{
    #ifndef ONLINE_JUDGE
        freopen("D:/in.txt","r",stdin);
        //freopen("D:/my.txt","w",stdout);
    #endif // ONLINE_JUDGE
}
struct Point
{
    int x, y;
    int ty, opid;
    bool operator<(const Point& o)const{
        return x < o.x || (x == o.x && y < o.y);
    }
}can[N], p1[N], p2[N], pt[N], tmp[N];
int n;
int m1, m2;
map<PII, int> mp;
LL ans[N];
bool vis[N];
int cnt;

LL Cross(Point A, Point B){return (LL)A.x * B.y - (LL)A.y * B.x;}
Point operator-(Point A, Point B) {return (Point){A.x - B.x, A.y - B.y};}
void getConvex(int n)
{
    m1 = m2 = 0;
    sort(pt, pt+n);
    for(int i = 0; i < n; i++)
    {
        while(m1 > 1 && Cross(pt[i] - p1[m1-2], p1[m1-1] - p1[m1-2]) <= 0) m1--;
        p1[m1++] = pt[i];
    }
    for(int i = n-1; i >= 0; i--)
    {
        while(m2 > 1 && Cross(pt[i] - p2[m2-2], p2[m2-1] - p2[m2-2]) <= 0) m2--;
        p2[m2++] = pt[i];
    }
}

void updateConvex(Point deltP)
{
    int idx = -1;
    for(int i = 0; i < m1; i++)
    {
        if(p1[i].x == deltP.x && p1[i].y == deltP.y){idx = i;break;}
    }
    if(idx != -1)
    {
        int l = idx - 1, r = idx + 1;
        int tail = 0;
        for(int i = r+1; i < m1; i++)
            tmp[tail++] = p1[i];
        int lpt, rpt;
        if(l == -1) lpt = -1;
        if(r == m1) rpt = cnt - 1;
        for(int i = 0; i < cnt; i++){
            if(l != -1 && pt[i].x == p1[l].x && pt[i].y == p1[l].y && vis[pt[i].opid]) lpt = i;
            if(r != m1 && pt[i].x == p1[r].x && pt[i].y == p1[r].y && vis[pt[i].opid]) rpt = i;
        }
        ///
        m1 = l+1;
        for(int i = lpt + 1; i <= rpt; i++)
        {
            if(vis[pt[i].opid] == 0) continue;
            while(m1 > 1 && Cross(pt[i] - p1[m1-2], p1[m1-1] - p1[m1-2]) <= 0) m1--;
            p1[m1++] = pt[i];
        }
        for(int i = 0; i < tail; i++)
            p1[m1++] = tmp[i];
    }

    idx = -1;
    for(int i = 0; i < m2; i++)
    {
        if(p2[i].x == deltP.x && p2[i].y == deltP.y) {idx = i;break;}
    }
    if(idx != -1)
    {
        int l = idx - 1, r = idx + 1;
        int tail = 0;
        for(int i = r+1; i < m2; i++)
            tmp[tail++] = p2[i];
        int lpt, rpt;
        if(l == -1) lpt = cnt;
        if(r == m2) rpt = 0;
        for(int i = 0; i < cnt; i++){
            if(l != -1 && pt[i].x == p2[l].x && pt[i].y == p2[l].y && vis[pt[i].opid]) lpt = i;
            if(r != m2 && pt[i].x == p2[r].x && pt[i].y == p2[r].y && vis[pt[i].opid]) rpt = i;
        }
        ///
        m2 = l+1;
        for(int i = lpt - 1; i >= rpt; i--)
        {
            if(vis[pt[i].opid] == 0) continue;
            while(m2 > 1 && Cross(pt[i] - p2[m2-2], p2[m2-1] - p2[m2-2]) <= 0) m2--;
            p2[m2++] = pt[i];
        }
        for(int i = 0; i < tail; i++)
            p2[m2++] = tmp[i];
    }
}

void updateans(int x, int y, int idx)
{
    Point o =(Point){x, -y};
    if(m1 <= 2){
        for(int i = 0; i < m1; i++)
            ans[idx] = max(ans[idx], (LL)p1[i].x * y + (LL)p1[i].y * x);
    }else{
        int lb = -1, ub = m1-1;
        while(lb + 1 < ub)
        {
            int mid = lb + ub >> 1;
            if(Cross(p1[mid+1] - p1[mid], o) <= 0) lb = mid;
            else ub = mid;
        }
        lb = max(0, lb);
        ans[idx] = max(ans[idx], (LL)p1[lb].x * y + (LL)p1[lb].y * x);
        if(ub < m1) ans[idx] = max(ans[idx], (LL)p1[ub].x * y + (LL)p1[ub].y * x);
    }
    if(m2 <= 2) {
        for(int i = 0; i < m2; i++)
            ans[idx] = max(ans[idx], (LL)p2[i].x * y + (LL)p2[i].y * x);
    }else{
        int lb = -1, ub = m2 - 1;
        while(lb + 1 < ub){
            int mid = lb + ub >> 1;
            if(Cross(p2[mid+1] - p2[mid], o) <= 0) lb = mid;
            else ub = mid;
        }
        lb = max(0, lb);
        ans[idx] = max(ans[idx],(LL)p2[lb].x * y + (LL)p2[lb].y * x);
        if(ub < m2) ans[idx] = max(ans[idx], (LL)p2[ub].x * y + (LL)p2[ub].y * x);
    }
}
void divide(int l, int r)
{
    if(l >= r) return ;
    int mid = l + r >> 1;

    for(int i = l; i <= mid; i++) vis[i] = 0;
    for(int i = l; i <= mid; i++)
    {
        if(can[i].ty == 1) vis[i] = 1;
        if(can[i].ty == -1 && can[i].opid >= l && can[i].opid <= mid) vis[can[i].opid] = 0;
    }
    cnt = 0;
    for(int i = l; i <= mid; i++)
        if(vis[i]) pt[cnt++] = can[i];

    getConvex(cnt);

    for(int i = mid+1; i <= r; i++){
        if(can[i].ty == 0) updateans(can[i].x, can[i].y, i);
        if(can[i].ty == -1 && can[i].opid >= l && can[i].opid <= mid && vis[can[i].opid]){
            vis[can[i].opid] = 0;
            updateConvex(can[can[i].opid]);
        }
    }

    divide(l, mid);
    divide(mid+1, r);
}
int main()
{
    Open();
    while(~scanf("%d", &n) && n)
    {
        mp.clear();
        for(int i = 0; i < n; i++)
        {
            int ty, x, y;
            scanf("%d%d%d", &ty, &x, &y);
            can[i] = (Point){y, x, ty, i};
            if(ty == 0) swap(can[i].x, can[i].y), ans[i] = -INF;
            if(ty == 1) mp[PII(y, x)] = i;
            if(ty == -1) can[i].opid = mp[PII(y, x)];
        }
        divide(0, n-1);
        for(int i = 0; i < n; i++)
        {
            if(can[i].ty == 0)
                printf("%I64d\n", ans[i]);
        }
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

C++成员初始化列表
class A
{
public:
	A()
	{
		cout << "class A default constructor called" << endl;
		a = 0;
	}

	A(int param)
	{
		cout << "class A constructor called" << endl;
		a = param;
	}

	~A()
	{

	}
	virtual void FunctionA()
	{
		cout << "classA" << endl;
	}
	int a;
private:

};

class B:public A
{
public:
	B()
	{
	}

	B(int m):b(m),a(m)
	{
		cout <<"class B constructor called" << endl;
	}

	~B()
	{

	}
	virtual void FunctionA()
	{
		cout << "classA" << endl;
	}
	void FunctionB()
	{
		cout << b << endl;
	}
private:
	int b;

};


int main()
{
  A* pA = new B(10);
  while(1);
  return 0;
}
 
这里编译器会有一个警告，意思是说a不是B的成员或者基类。 a是不能放在派生类B的初始化列表里进行初始化。
所以在派生类的初始化列表里面，只会进行以下的初始化操作：
派生类的初始化列表：基类的初始化， 派生类本身数据成员的初始化。



版权声明：本文为博主原创文章，未经博主允许不得转载。

【树链剖分】【JLOI 2014】【bzoj 3631】松鼠的新家
3631: [JLOI2014]松鼠的新家
Time Limit: 10 Sec  Memory Limit: 128 MB
Submit: 877  Solved: 421

Description
松鼠的新家是一棵树，前几天刚刚装修了新家，新家有n个房间，并且有n-1根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在“树”上。松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去a1，再去a2，……，最后到an，去参观新家。 
可是这样会导致维尼重复走很多房间，懒惰的维尼不听地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。维尼是个馋家伙，立马就答应了。 
现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。因为松鼠参观指南上的最后一个房间an是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。
Input
第一行一个整数n，表示房间个数 
第二行n个整数，依次描述a1-an 
接下来n-1行，每行两个整数x，y，表示标号x和y的两个房间之间有树枝相连。
Output
一共n行，第i行输出标号为i的房间至少需要放多少个糖果，才能让维尼有糖果吃。
Sample Input
5
1 4 5 3 2
1 2
2 4
2 3
4 5

Sample Output
1
2
1
2
1

HINT
2<= n <=300000

题解：
树链剖分基础题（我会说我写了两个多小时才A吗） 
相当于是给出一堆修改，线段树上区间+1，记得要去重就好了，最后是单点查询。
Code：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 300100
#define root 1,1,tot
#define lch rt<<1,l,mid
#define rch rt<<1|1,mid+1,r

struct Edge{
    int v,next;
}edge[N<<1];
struct Tree{
    int s,lazy;
}tree[N<<2];
int n,num=0,tot=0,a[N],head[N];
int de[N],fa[N],sz[N],son[N],w[N],top[N];

int in(){
    int x=0; char ch=getchar();
    while (ch<'0' || ch>'9') ch=getchar();
    while (ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return x;
}
void add(int u,int v){
    edge[++num].v=v; edge[num].next=head[u]; head[u]=num;
}

void dfs1(int x){
    sz[x]=1;
    for (int i=head[x]; i; i=edge[i].next){
        int v=edge[i].v;
        if (v==fa[x]) continue;
        de[v]=de[x]+1; fa[v]=x;
        dfs1(v); sz[x]+=sz[v];
        if (sz[son[x]]<sz[v]) son[x]=v;
    }
}
void dfs2(int x,int st){
    w[x]=++tot; top[x]=st;
    if (!son[x]) return;
    dfs2(son[x],st);
    for (int i=head[x]; i; i=edge[i].next){
        int v=edge[i].v;
        if (v==fa[x] || v==son[x]) continue;
        dfs2(v,v);
    }
}

void push_up(int rt){
    tree[rt].s=tree[rt<<1].s+tree[rt<<1|1].s;
}
void push_down(int rt,int len){
    tree[rt<<1].s+=(len-(len>>1))*tree[rt].lazy;
    tree[rt<<1|1].s+=(len>>1)*tree[rt].lazy;
    tree[rt<<1].lazy+=tree[rt].lazy;
    tree[rt<<1|1].lazy+=tree[rt].lazy;
    tree[rt].lazy=0;
}
void change(int rt,int l,int r,int ll,int rr,int k){
    if (ll<=l && r<=rr){
        tree[rt].s+=(r-l+1)*k;
        tree[rt].lazy+=k;
        return;
    }
    if (tree[rt].lazy!=0) push_down(rt,r-l+1);
    int mid=(l+r)>>1;
    if (ll<=mid) change(lch,ll,rr,k);
    if (rr>mid) change(rch,ll,rr,k);
    push_up(rt);
}
int query(int rt,int l,int r,int x){
    if (l==r) return tree[rt].s;
    if (tree[rt].lazy!=0) push_down(rt,r-l+1);
    int mid=(l+r)>>1;
    if (x<=mid) return query(lch,x);
    return query(rch,x);
}

void work(int x,int y){
    int yy=y;
    if (de[top[x]]<de[top[y]]) swap(x,y);
    while (top[x]!=top[y]){
        if (de[top[x]]<de[top[y]]) swap(x,y);
        change(root,w[top[x]],w[x],1);
        x=fa[top[x]];
    }
    if (de[x]<de[y]) swap(x,y);
    change(root,w[y],w[x],1);
    change(root,w[yy],w[yy],-1);
}

int main(){
    n=in();
    for (int i=1; i<=n; i++) a[i]=in();
    for (int i=1; i<n; i++){
        int u=in(),v=in();
        add(u,v),add(v,u);
    }

    dfs1(1),dfs2(1,1);
    for (int i=1; i<n; i++)
        work(a[i],a[i+1]);
    for (int i=1; i<=n; i++)
        printf("%d\n",query(root,w[i]));
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1281
链接：点击打开链接
题意：N*M的棋盘，接下来的K行描述了所有格子的信息:每行两个数X和Y,表示了这个格子在棋盘中的位置.问重点格子的个数和不同行不同列的棋子个数(如果拿掉一个格子的棋子之后不同行不同列的个数改变则这个格子叫重点格子)
代码：#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
int n,m,k;
int s[105][105],match[105],vis[105],xx[105],yy[105];
int dfs(int x){
    int i,j;
    for(i=1;i<=m;i++){
        if(!vis[i]&&s[x][i]){
        vis[i]=1;
        if(!match[i]||dfs(match[i])){
        match[i]=x;
        return 1;
        }
        }
    }
    return 0;
}
int hungarian(){
    int i,sum;
    sum=0;
    for(i=1;i<=n;i++){
        memset(vis,0,sizeof(vis));
        if(dfs(i))
        sum++;
    }
    return sum;
}                                //匈牙利算法
int main(){
    int i,j,cur,ans,sum,temp;
    cur=1;
    while(scanf("%d%d%d",&n,&m,&k)!=EOF){
        memset(s,0,sizeof(s));
        memset(match,0,sizeof(match));
        for(i=1;i<=k;i++){
        scanf("%d%d",&xx[i],&yy[i]);
        s[xx[i]][yy[i]]=1;
        }
        ans=hungarian();         //不同行不同列的个数
        sum=0;
        for(i=1;i<=k;i++){
            s[xx[i]][yy[i]]=0;  //遍历所有可放棋子的格子
            memset(match,0,sizeof(match));
            temp=hungarian();   //不要忘记初始化match数组
            if(temp!=ans)
            sum++;
            s[xx[i]][yy[i]]=1;
        }
        printf("Board %d have %d important blanks for %d chessmen.\n",cur++,sum,ans);
    }
    return 0;
}

﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

GDI+屏幕截图(二)
上一篇讲了如何写一个很low的截屏工具，这次进行稍微美化，对未选择区域的图片加上透明度，效果如下图。


 
主要用到的的代码如下：
        /// 设置图片的透明度  
        /// </summary>  
        /// <param name="image">原图</param>  
        /// <param name="alpha">透明度0-255</param>  
        /// <returns></returns>  
        private Bitmap SetPictureAlpha(Image image, int alpha)
        {
            //颜色矩阵  
            float[][] matrixItems =  
           {  
               new float[]{1,0,0,0,0},  
               new float[]{0,1,0,0,0},  
               new float[]{0,0,1,0,0},  
               new float[]{0,0,0,alpha/255f,0},  
               new float[]{0,0,0,0,1}  
           };
            ColorMatrix colorMatrix = new ColorMatrix(matrixItems);
            ImageAttributes imageAtt = new ImageAttributes();
            imageAtt.SetColorMatrix(colorMatrix, ColorMatrixFlag.Default, ColorAdjustType.Bitmap);


            Bitmap bmp = new Bitmap(image.Width, image.Height);
            Graphics g = Graphics.FromImage(bmp);
            g.DrawImage(image, new Rectangle(0, 0, image.Width, image.Height),
                    0, 0, image.Width, image.Height, GraphicsUnit.Pixel, imageAtt);
            g.Dispose();
            return bmp;
        }


看不懂的可以参考
http://blog.csdn.net/q317379184/article/details/47978783
 
  定义Image alphaImg;
       alphaImg = SetPictureAlpha(alphaImg, 100);//透明度Img
在pictureBox1_Paint中加入        //在有透明度的区域绘制无透明度区域
               g.DrawImage(Img, rect, rect, GraphicsUnit.Pixel);
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu2019 数列有序


数列有序!
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 59159    Accepted Submission(s): 25525



Problem Description

有n(n<=100)个整数，已经按照从小到大顺序排列好，现在另外给一个整数x，请将该数插入到序列中，并使新的序列仍然有序。

 


Input

输入数据包含多个测试实例，每组数据由两行组成，第一行是n和m，第二行是已经有序的n个数的数列。n和m同时为0标示输入数据的结束，本行不做处理。

 


Output

对于每个测试实例，输出插入新的元素后的数列。

 


Sample Input

3 3
1 2 4
0 0


 


Sample Output

1 2 3 4


 


Author

lcy

 


Source

C语言程序设计练习（三）

 


Recommend

lcy   |   We have carefully selected several similar problems for you:  2021 2029 2035 2028 2034 

 




去年寒假做的。。。那时候都不知道什么事算法
#include <stdio.h>
#include <stdlib.h>
int comp(const void *a,const void *b)
{
	return *(int*)a-*(int*)b;
}
int main()
{
	int a[100],i,t,m,n;
	while(scanf("%d%d",&n,&m)!=EOF&&n!=0&&m!=0)
	{
	for(i=0;i<n;i++)
       scanf("%d",&a[i]);
	a[n]=m;
	qsort(a,n+1,sizeof(int),comp);
	for(i=0;i<n;i++)
	   printf("%d ",a[i]);
    printf("%d\n",a[n]);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Atitit.执行cli cmd的原理与调试
Atitit.执行cli cmd的原理与调试
 
1. /c  与/k
1
2. /k  参数，有利于调试
1
3. -------code
2
4. 打开程序后与openner脱离关系
3
5. 返回参数 StandardOutput  StandardError
3
6. Bat参数的隐藏命令：：使用@后头符
3
6.1. 1.1. 实际执行模式
3
6.2. 1.2. 空格的问题
3
6.3. 1.3. 中文路径的问题，程序文件读取编码设置
3
6.4. 1.4. 回显乱码
4
7. 双引号转译问题
4
8. 参数
4
 
1. /c  与/k
。如果使用 cmd/c 就可以省掉 EXIT 了
2. /k  参数，有利于调试
使用process explorer可以看到实际的调用参数
 

作者:: 老哇的爪子 Attilax 艾龙，  EMAIL:1466519819@qq.com

转载请注明来源： http://blog.csdn.net/attilax
 
 
 
Atitit.执行cmd的原理与调试
"cmd.exe"  /k  "D:\workspace3 空格\amaz_spider\WpfApplication1/phprun.bat"  "D:\workspace22 空格\amaz_spider\WpfApplication1/com.attilax/api.php"  "tagP823=1&textfield=2015-9-1&textfield2=09%253A10&prod_name=iphone%2bcase&select=%25E6%258E%2592%25E5%2590%258Dxy&select3=%25E6%258E%2592%25E5%2590%258Dxy&select4=%25E5%25A5%25BD%25E8%25AF%2584&select5=%25E5%25A5%25BD%25E8%25AF%2584&select6=%25E8%25B7%259F%25E5%258D%2596%25E4%25B8%25AA%25E6%2595%25B0&select9=%25E8%25B7%259F%25E5%258D%2596%25E4%25B8%25AA%25E6%2595%25B0&select7=%25E5%25A5%25BD%25E8%25AF%2584%25E6%2595%25B0%25E7%259B%25AE&select8=%25E5%25A5%25BD%25E8%25AF%2584%25E6%2595%25B0%25E7%259B%25AE&select2=%25E5%25BA%2597%25E9%2593%25BA%25E8%25AF%2584%25E4%25BB%25B7%25E6%2595%25B0&select10=%25E5%25BA%2597%25E9%2593%25BA%25E8%25AF%2584%25E4%25BB%25B7%25E6%2595%25B0&method=search_context&$callback=search_context_finish&$parser=php"
 
3. -------code
    public class Cmd
    {
        private Process proc = null;
        /// <summary>
        /// 构造方法
        /// </summary>
        public Cmd()
        {
            proc = new Process();
        }
        /// <summary>
        /// 执行CMD语句
        /// </summary>
        /// <param name="cmd">要执行的CMD命令</param>
        public string RunCmd(string cmd)
        {
            proc.StartInfo.CreateNoWindow = true;
            proc.StartInfo.FileName = cmd;
                //"cmd.exe";
            proc.StartInfo.UseShellExecute = false;
           proc.StartInfo.RedirectStandardError = true;
           proc.StartInfo.RedirectStandardInput = true;
           proc.StartInfo.RedirectStandardOutput = true;
      //      proc.StartInfo.Arguments = " /k  " + cmd;//“/C”表示执行完命令后马上退出   
           
            proc.Start();
            proc.WaitForExit();//这里无限等待进程结束  
     //     proc.StandardInput.WriteLine(cmd);
       //     proc.StandardInput.WriteLine("exit");
            string outStr = proc.StandardOutput.ReadToEnd();
            string errstr = proc.StandardError.ReadToEnd();
            Console.WriteLine(errstr);
            proc.Close();
            return outStr;
        }
 
4. 打开程序后与openner脱离关系
应该使用cmd /c ？？？
 
5. 返回参数 StandardOutput  StandardError
 
    string outStr = proc.StandardOutput.ReadToEnd();
            string errstr = proc.StandardError.ReadToEnd();
 
6. Bat参数的隐藏命令：：使用@后头符

6.1.     1.1. 实际执行模式

Processmonitor 检查。得到。。

PID: 115372, Command line: cmd.exe /c "D:\workspace 绌烘牸\AtiBrow\exp_receipt.bat"

6.2. 1.2. 空格的问题

双引号解决

6.3. 1.3. 中文路径的问题，程序文件读取编码设置

Php.ini中的default_charset = "utf-8"  只是设置post，get的编码，不能设置php文件的读取编码。。最好是注释掉此参数，让他根据文件本身的编码自动判断，否则输出的php结果都 header('Content-Type:text/html;charset=utf8

 

作者:: 老哇的爪子 Attilax 艾龙，  EMAIL:1466519819@qq.com

转载请注明来源： http://blog.csdn.net/attilax

 

 

原因在于php文件本身是用系统字符集来编码的，中文的windows XP都是用GB2312，每一个文件头部都有字段指示该文件是用何种方式编码的

 

用javac编译java源文件时，编译器默认用系统编码读源文件里的内容。如果源文件不是用系统编码来保存的，可以用命令javac -encoding指定具体的编码

 

淋巴，只能不个php文件的编码设置成gbk。。才ok。。

 

6.4. 1.4. 回显乱码

 

 header('Content-Type:text/html;charset=gbk');  

 
7. 双引号转译问题
好像是三个双引号   
8. 参数
执行 CMD 时，参数加引号常见问题 - 的米-漠石's Blog - 博客频道 - CSDN.NET.html
C#执行DOS命令（CMD命令） - 杨友山 - 博客频道 - CSDN.NET
paip.asp vbs通过CLI命令行调用PHP代码 - attilax的专栏 - 博客频道 - CSDN.NET
paip.执行shell cmd 命令uapi java php python总结 - attilax的专栏 - 博客频道 - CSDN.NET
paip.python 执行shell 带空格命令行attilax总结- python教程 中国黑帽网.html
Atitit.执行cmd 命令行 php - attilax的专栏 - 博客频道 - CSDN.NET.html
 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

Codeforces Round #317 [AimFund Thanks-Round] (Div. 1) A. Lengthening Sticks 分类

A. Lengthening Sticks


time limit per test
1 second


memory limit per test
256 megabytes


input
standard input


output
standard output



You are given three sticks with positive integer lengths of a, b, and c centimeters.
 You can increase length of some of them by some positive integer number of centimeters (different sticks can be increased by a different length), but in total by at most l centimeters.
 In particular, it is allowed not to increase the length of any stick.

Determine the number of ways to increase the lengths of some sticks so that you can form from them a non-degenerate (that is, having a positive area) triangle. Two ways are considered different, if the length of some stick is increased by different number of
 centimeters in them.



Input

The single line contains 4 integers a, b, c, l (1 ≤ a, b, c ≤ 3·105, 0 ≤ l ≤ 3·105).



Output

Print a single integer — the number of ways to increase the sizes of the sticks by the total of at most l centimeters, so that you can
 make a non-degenerate triangle from it.



Sample test(s)



input
1 1 1 2




output
4




input
1 2 3 1




output
2




input
10 2 1 7




output
0






Note

In the first sample test you can either not increase any stick or increase any two sticks by 1 centimeter.

In the second sample test you can increase either the first or the second stick by one centimeter. Note that the triangle made from the initial sticks is degenerate and thus, doesn't meet the conditions.

题意，给出四个数a,b,c,l，a b c 可以增加任意长的数但a b c增加的总和小于l,要求a b c能构成三角形的个数。

反向思考，要求能构成三角形的个数，我们可以找不能构成三角形的个数。

a b c 任意加长，总的方案数为 这个式子 x + y + z + left = l;的解的个数，x y z left 分别对用a b c增长的长度，和剩下的长度。

这个不定方程的方案数用隔板法，很容易得知是c(l + 3,3);

然后，可以枚举，不能构成三角形的个数，不能构成三角形的条件就是，如果a是最大边，那么b + c <= a，那一定不能构成三角形，所以可以枚举最大边，那可以得到公式，

b + y + c + z < = a + x (a+ x最大边)

y + z <= l - x(总和最大不能过l)

也就是得到方程y + z <= min(l - x,a + x - b -c)不定方程的解的个数。很明显，也就是c(all,2) all = min(l - x,a + x - b -c)

总的复杂度为o(n )注意要用long long ,会爆int.

#define N 205
#define M 100005
#define maxn 205
#define MOD 1000000000000000007
int n,a,b,c,l;
ll Cal(ll x){
    if(x < 0) return 0;
    return (x + 2)* (x + 1) / 2;
}
int main()
{
    //freopen("in.txt", "r", stdin);
    //freopen("out.txt", "w", stdout);
     while(S2(a,b)!=EOF)
    {
        S2(c,l);
        ll ans = (ll)(l + 3) * (ll)(l + 2) * (ll)(l + 1) / 6;
        FI(l+1){
            ans -= Cal(min(a + i - b - c,l - i));
            ans -= Cal(min(b + i - a - c,l - i));
            ans -= Cal(min(c + i - a - b,l - i));
        }
        cout<<ans<<endl;
    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu1078 FatMouse and Cheese（记忆化搜索）
题目链接：
http://acm.hdu.edu.cn/showproblem.php?pid=1078

题目大意：


题目中的k表示横向或者竖直最多可以前进的距离，不能够拐弯。老鼠的出发点是(1,1)。

对于老鼠从当前点能够到达的点，筛选出从这些点到达当前点所能获得的cheese的最大值。
思路：记忆化搜索。如果对于当前的点，没有被搜索过（dp[i][j]=0），那么就对其进行搜索，搜索过程中记录下最优的解。如果已经被搜索过了，就可以直接利用已经记录的值来进行判断 了，不需要再去搜索。
如果搜索完以后结果还是0，表明他不能再有新的路可以走了，结果就是他本身了。
#include<stdio.h>
#include<string.h>
#define LL __int64
#define max(a,b) a>b?a:b
int n,k;
LL a[105][105],dp[105][105];
int dir[][2]={0,1,0,-1,1,0,-1,0};
void dfs(int x,int y)
{

    for(int i=0;i<4;i++)
    {
        for(int j=1;j<=k;j++)    
        {
        int xx=x+dir[i][0]*j;
        int yy=y+dir[i][1]*j;
            if(xx<=0||yy<=0||xx>n||yy>n)continue;
            if(a[xx][yy]>a[x][y]){
                if(dp[xx][yy]==0){     //如果没有被搜索过
                    dfs(xx,yy);
                    dp[x][y]=max(dp[xx][yy]+a[x][y],dp[x][y]);
                }
                else dp[x][y]=max(dp[xx][yy]+a[x][y],dp[x][y]);
            }
    }
}
if(dp[x][y]==0)dp[x][y]=a[x][y];    //表明已经没有路可以走了。
return ;
}
int main()
{
    int i,j;
    while(scanf("%d%d",&n,&k)!=EOF)
    {
        if(n==-1&&k==-1)break;
        for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        scanf("%I64d",&a[i][j]);
        memset(dp,0,sizeof(dp));
      dfs(1,1);
        printf("%I64d\n",dp[1][1]);
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Find Cycle

Find Cycle

A graph is a type of data structure that consists of nodes and edges that connect the nodes. An edge has a start node and end node, and we will only consider directed edges.
The figure below is an example of a graph with 8 nodes (labeled '1' through '8') and 9 edges. A path in a graph is a sequence of nodes that are connected by edges.
'6->3->2->1' is an example of path in the graph below.

﻿

A "Cycle" is a special case of path; it has at least 2 nodes, and the start node and the end node of the path are the same.
For example, '1->5->2->1','7->8->7','5->2->1->5', and '8->7->8' are examples of cycle you can find in the graph above.

﻿

Given a graph, write a program that finds a cycle of the given graph.
If there's a cycle, write node numbers in ascending order, and write '0'. If there is more than one cycle, choose and print out one cycle.﻿         

[Constraints]
N, the number of nodes satisfies 5<=N<=100, and M, the number of edges satisfies 1<=M<=1000.

﻿

[Input]
Several test cases can be included in the inputs. T, the number of cases is given in the first row of the inputs. 
After that, the test cases as many as T (T <= 10) are given. The first line of each test case has N, the number of nodes, and M, the number of edges. The second line has M pairs of start node and end node. The nodes
 are labeled form '1' to 'N'.
No edge has the same start and end node. All integers in the input are separated by a space.﻿

We call the number of edges that come out of a node "degree".
For test cases #1-#3, the degree of all nodes is 1; for test cases #4-#6, the degree is 2 or less; for test cases #7-#10, there's no limit in degree.
Here, "degree of the node is 1" means that all nodes simply have only one edge coming out of the node.
(In the left graph above, from node 2, you can go to either node 1 or node 4 so the degree is not 1. In the right graph, on the contrary, the degree is 1.)﻿

[Output]
Print answers for each of 10 test cases in 10 lines. Start each line with '#x' where x is the test case number, leave a space and print your answer.
When a cycle exists, enumerate numbers of the nodes in the cycle in ascending order. For example, the cycle '1->5->2->1' is written as '1 2 5'.
If there is no cycle, just write '0'.

[Sample Input/Output]
Input (Input consists of several lines, but the example below shows input for only 4 test cases represented through 9 lines to help you understand the format.)
4 -->T: the number of test cases
5 5 -->case 1
4 3 2 4 3 5 3 2 1 4
5 5 -->case 2
4 3 2 4 3 5 2 3 1 4
6 5 -->case 3
1 5 6 4 3 1 5 3 4 6
8 9 -->case 4
5 2 3 2 6 3 8 7 2 1 6 4 2 4 1 5 7 8﻿

Output (Output is made up of 10 lines, but the example below shows output for only 4 test cases to help you understand the format.)
Case #1 
2 3 4
Case #2 
0
Case #3 
1 3 5
Case #4 
7 8 

Note, for "Case 4" we can also output "1 2 5".

题目的意思比较简单，大意是从给出的线路中找出一个回环，然后将回环结果由小到大输出即可。

解题思路：首先构造一个N*N的矩阵，并初始化为全0，通过输入将有线路的矩阵标记为1，然后用深度递归的方法找到回环；在寻找的过程中需要维护两张表，Table表按顺序保存已经遍历过的非0节点，Hash表保存Table表中非0节点出现的顺序，也就是遍历的顺序。

 




Table[i]


1


2


3


4


5


6


7


8




Value


1


3


4


2


6


0


0


0





 




Hash[i]


1


2


3


4


5


6


7


8




Value


1


4


2


3


6


0


0


0





 

/*

You should use the statndard input/output

 

in order to receive a score properly.

 

Do not use file input and output

 

Please be very careful.

*/

 

#include <stdio.h>

 

#define MAX_M  1001

#define MAX_N  101

 

int Array[MAX_N][MAX_N];// 构造一个N*N的矩阵,用来保存输入的边数

int N,M;

int Answer;

int num = 0 ;

 

int Table[MAX_N];

int Hash[MAX_N];

int top ;//遍历过的非0点个数

int start ;//标志位

int temp;

 

//递归算法

int Cacluate(int node)

{

         int i;

         //int ret; 

         if (start !=-1)

                   return 0;

                  

         if (Hash[node] != 0)

         {

                   //Table : 100 200 800 0 2 5 7 9 6 4 5

                   //Hash  : 1 0 1 0 7

                   //loop;

                   start = Hash[node];

                   //top--;

                   return 0;

         }

         //retr

         top++;

         Table[top] = node;  

         Hash[node] = top;   

        

        

         //if(Hash[node] == 1)

         //      return node;

        

         //Hash[node] = 1;

        

         for(i=1;i<=N;i++)

         {

                   if(Array[node][i] != 0  && node !=i)

                   {

                            Cacluate(i);

                            /*ret = Cacluate(i);

                            if(ret != 0)

                            {

                                     return ret;

                            }*/

                            if (start !=-1)

                                     return 0;

                   }

         }

        

         Hash[node] = 0;

         top--;

         return 0;

}

 

int main(void)

{

         int T, test_case;

         /*

            The freopen function below opens input.txt file in read only mode, and afterward,

            the program will read from input.txt file instead of standard(keyboard) input.

            To test your program, you may save input data in input.txt file,

            and use freopen function to read from the file when using scanf function.

            You may remove the comment symbols(//) in the below statement and use it.

            But before submission, you must remove the freopen function or rewrite comment symbols(//).

          */

         freopen("input.txt", "r", stdin);

 

         /*

            If you remove the statement below, your program's output may not be rocorded

            when your program is terminated after the time limit.

            For safety, please use setbuf(stdout, NULL); statement.

          */

         setbuf(stdout, NULL);

 

         scanf("%d", &T);

         for(test_case = 0; test_case < T; test_case++)

         {

 

                   int i,j;

                   int t1,t2;

                   int loop = 0 ;

                   top = 0;

        start = -1;

                  

                   scanf("%d",&N);

                   scanf("%d",&M);

 

                   //初始化Array数组，全部初始化为0

                   for(i=1;i<=N;i++)

                   {

                            for(j=1;j<=N;j++)

                            {

                                     Array[i][j] = 0 ;

                            }

                   }

                   //保存输入的边数，将有线路的边置为1

                   for(i=0;i<M;i++)

                   {                          

                            scanf("%d %d" , &t1,&t2);

//保存t1->t2的边之前先判断是否有t2->t1的边，如果有，直接按照大小顺序输出t1、t2，

                            if (Array[t2][t1]!=0)

                            {

                                     if(t1<=t2)

                                         printf("Case #%d\n%d %d\n",test_case+1,t1,t2);

                                     else

                                               printf("Case #%d\n%d %d\n",test_case+1,t2,t1);

                                     loop = 1;

                            }

                            Array[t1][t2] = 1 ;     //将有线路的边置为1  

                                    

                   }

                   if (loop!=0)

        {

            continue;//结束本次case循环，之后的代码不执行，进入下一个case。

        }

                  

                   for(i=0;i<=N;i++)//初始化两张表

                   {

                            Table[i] = 0;

            Hash[i] = 0;

                   }

                   //start = -1;              

                   for(i=1;i<=N;i++)

                   {

                            for(j=1;j<=N;j++)

                            {

                                     if (Array[i][j] != 0)//如果不为0则循环遍历数据表

                                     {

                                               Cacluate(i);                                           

                                               if (start !=-1)

                                                        break;//跳出第一重for循环

                                     }

                                    

                            }

                            if (start !=-1)

                                     break;// 跳出第二重for循环，即结束遍历

                   }

 

          printf("Case #%d\n", test_case+1);

 

//将得到的结果进行排序

     if(start !=-1){

                   for(i=start;i<=top;i++)

                   {

                         for( j = start;j < top +start- i;j++)

                                     {

                                               if(Table[j] > Table[j+1])

                                               {

                                                        temp = Table[j] ;

                                                        Table[j] = Table[j+1] ;

                                                        Table[j+1] = temp ;

                                               }

                                     }

                   }

                  

//输出结果

                   for(i=start;i<top;i++)

                   {

                            printf("%d ",Table[i]);

                   }

                   printf("%d",Table[top]);

          }

 

          else  if(start ==-1)

        printf("%d",Table[0]);

 

         printf("\n");

                           

                  

                  

                   /////////////////////////////////////////////////////////////////////////////////////////////

                   /*

                      Implement your algorithm here.

                      The answer to the case will be stored in variable Answer.

                    */

                   /////////////////////////////////////////////////////////////////////////////////////////////

                   //Answer = 0;

 

                   // Print the answer to standard output(screen).

                  

                   //

                   //printf("%d\n", Answer);

         }

         return 0;//Your program should return 0 on normal termination.

}

版权声明：本文为博主原创文章，未经博主允许不得转载。

简单的图片验证
在编写爬虫爬去一个航空公司官网的时候，发现航班信息都是图片，比如航班号，舱位信息，价格，时间等。相对而言，图片相对比较简单，没有干扰线条，文字也是端端正正的。所以，可以处理.
package com.weixuan;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.*;

/**
 * Create by fengtang
 * 2015/8/25 0025
 * ImageToString
 */
public class ImageToString {

    /**
     * 配置文件，图片识别特征库
     */
    public static Properties prop = new Properties();
    private static final int GRAYCVALUE = 128;

    static {
        try {
            String fileName = "E:\\IDEA\\ImageToString\\src\\main\\resource\\config\\FeatureLibrary.properties";
            File myFile = new File(fileName);
            InputStreamReader isr;
            isr = new InputStreamReader(new FileInputStream(myFile), "UTF-8");
            prop.load(isr);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * @param imag 原始图片文件
     * @return 图片对应的字符串
     * @throws Exception
     * @brief 获取图片对应的字符串
     */
    public static String getString(BufferedImage imag) throws Exception {
        /**
         *  1.获取有效图形
         */
        imag = getPicValidByValue(imag, GRAYCVALUE);

        /**
         *  2.切割图片
         */
        BufferedImage[] imagList = getSplitPics(imag);
        String[] code = new String[imagList.length];
        String[] picCode = new String[imagList.length];
        String validateCode = "";
        for (int i = 0; i < imagList.length; i++) {
            /**
             * 3.获取切割后的有效图形
             */
            imagList[i] = getPicValidByValue(imagList[i], GRAYCVALUE);
            /**
             * 4.获取图片的点阵描述字符串
             */
            picCode[i] = getSingleBmpCode(imagList[i], GRAYCVALUE);
            /**
             * 5.匹配结果
             */
            code[i] = match(picCode[i]);
            if (code[i] == null) {
                throw new RuntimeException("匹配出错");
            }
            /**
             * 6.拼装最后结果
             */
            validateCode = validateCode + code[i];
        }
        validateCode = validateCode.replace("semicolon", ":");
        return validateCode;
    }

    /**
     * @param singlepic 灰度图
     * @param grayValue 背前景灰色界限
     * @return 灰度图片的点阵描述字串(1表示灰点，0表示背景)
     * @brief 返回灰度图片的点阵描述字串.
     */
    private static String getSingleBmpCode(BufferedImage singlepic, int grayValue) {
        if (singlepic == null) {
            return null;
        }
        int[] pixel;
        StringBuilder code = new StringBuilder();
        for (int y = 0; y < singlepic.getHeight(); y++) {
            for (int x = 0; x < singlepic.getWidth(); x++) {
                pixel = getPixel(singlepic, x, y);
                if (pixel[0] < grayValue) {
                    code.append("1");
                } else {
                    code.append("0");
                }
            }
        }
        return code.toString();
    }

    /**
     * @param imag     图片文件
     * @param grayVale 灰度背景分界值
     * @return 有效图片文件
     * @brief 获取有效图形
     */
    private static BufferedImage getPicValidByValue(BufferedImage imag, int grayVale) {
        int posX1 = imag.getWidth();
        int posY1 = imag.getHeight();
        int posX2 = 0;
        int posY2 = 0;
        /**
         * 找有效区
         */
        for (int i = 0; i < imag.getHeight(); i++) {
            for (int j = 0; j < imag.getWidth(); j++) {
                int pixelValue = getPixel(imag, j, i)[0];
                /**
                 *     根据灰度值
                 */
                if (pixelValue < GRAYCVALUE) {
                    if (posX1 > j) {
                        posX1 = j;
                    }
                    if (posY1 > i) {
                        posY1 = i;
                    }
                    if (posX2 < j) {
                        posX2 = j;
                    }
                    if (posY2 < i) {
                        posY2 = i;
                    }
                }
            }
        }
        return imag.getSubimage(posX1, posY1, posX2 - posX1 + 1, posY2 - posY1 + 1);
    }

    /**
     * @param imag 源图像。
     * @param j    图像上指定像素位置的 x 坐标。
     * @param i    图像上指定像素位置的 y 坐标。
     * @return 返回包含 rgb 颜色分量值的数组。元素 index 由小到大分别对应 r，g，b。
     * @brief 取得图像上指定位置像素的 rgb 颜色分量.
     */
    private static int[] getPixel(BufferedImage imag, int j, int i) {
        int[] rgb = new int[3];
        int pixel = imag.getRGB(j, i);
        rgb[0] = (pixel & 0xff0000) >> 16;
        rgb[1] = (pixel & 0xff00) >> 8;
        rgb[2] = pixel & 0xff;
        return rgb;
    }

    /**
     * @param picCode piCode
     * @return String
     * @brief 匹配.
     */
    private static String match(String picCode) {
        String c = null;
        Iterator it = prop.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            char[] validateC = entry.getValue().toString().toCharArray();
            char[] picCodeC = picCode.toCharArray();
            boolean rightFlag = true;
            if (validateC.length == picCodeC.length) {
                for (int i = 0; i < picCodeC.length; i++) {
                    if (picCodeC[i] != validateC[i]) {
                        rightFlag = false;
                        break;
                    }
                }
            } else {
                rightFlag = false;
            }
            if (rightFlag) {
                c = entry.getKey().toString();
                break;
            }
        }
        return c;
    }

    /**
     * @param img img
     * @return BufferedImage
     * @brief 图片切割.
     */
    private static BufferedImage[] getSplitPics(BufferedImage img) {
        int posx1 = img.getWidth();
        int posy1 = img.getHeight();
        List<Integer> point = new ArrayList<Integer>();
        for (int i = 0; i < img.getWidth(); i++) {
            boolean flag = true;
            for (int j = 0; j < img.getHeight(); j++) {
                if (getPixel(img, i, j)[0] < GRAYCVALUE) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                if (point.size() != 0) {
                    int temp1 = point.get(point.size() - 1);
                    if (i == temp1) {
                        point.set(point.size() - 1, i + 1);
                    } else {
                        point.add(i + 1);
                    }
                } else {
                    point.add(i + 1);
                }

            }
        }
        BufferedImage[] listImage = new BufferedImage[point.size() + 1];
        for (int i = 0; i < point.size() + 1; i++) {
            if (i == 0) {
                listImage[i] = img.getSubimage(0, 0, point.get(i), posy1);
            } else if (i < point.size()) {
                listImage[i] = img.getSubimage(point.get(i - 1), 0, point.get(i) - point.get(i - 1), posy1);
            } else {
                listImage[i] = img.getSubimage(point.get(i - 1), 0, posx1 - point.get(i - 1), posy1);
            }

        }
        return listImage;
    }
}

FeatureLibrary.properties
#################图片识别特征库###################
semicolon=111100001111
A=000100000010000010100001010000101000011100010001001000101110111
B=111110010001010001011110010011010001010001010001111110
C=001111010001100000100000100000100000100000010001001110
D=111100010010010001010001010001010001010001010010111100
E=111111010001010000010010011110010010010000010001111111
F=111111010001010000010010011110010010010000010000111000
G=001110010010100000100000100000100111100010010010001100
H=111011101000100100010010001001111100100010010001001000101110111
I=111110010000100001000010000100001000010011111
J=011111000100000100000100000100000100000100000100100100111000
K=111011010010010100011000011100010100010010010010111011
L=111000010000010000010000010000010000010000010001111111
M=111011101101100110110011011001010100101010010101001010101101011
N=111011101100100110010010101001010100101010010011001001101110010
O=001100010010100001100001100001100001100001010010001100
P=111110010001010001010001011110010000010000010000111000
Q=001100010010100001100001100001100001101101010010001110000011
R=111110001000100100010011110001010000100100010010001000101110011
S=011111000110000010000011000001000011000111110
T=111111010100100001000010000100001000010001110
U=111011101000100100010010001001000100100010010001001000100011100
V=111011101000100100010001010000101000010100001010000010000001000
W=110101101010100101010010101001010100110110001010000101000010100
X=110111010010010100001100001000001100010010010010111011
Y=111011101000100010100001010000010000001000000100000010000011100
Z=111111001000010001000010000100010000100111111
0=011101000110001100011000110001100011000101110
1=010110010010010010010010111
2=011101000110001000010001000100010001000011111
3=011101000100001001100000100001000011001101110
4=000010000110001010010010010010100010011110000010000111
5=111111000010000111101000100001100011000101110
6=001110100110000101101100110001100011000101110
7=111111001000010000100010000100001000010000100
8=011101000110001010100111010001100011000101110
9=011101000110001100011001101101000011001011100
舱=001000010000011110011000010010100100011011000010010010000001111110111100010010100100011010100100010110101100010010100010100010100010100110011110
￥=111000111010000010001000100000101000000010000011111110000010000000010000000010000000111000

测试
package com.weixuan;

import org.junit.Test;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

/**
 * Create by fengtang
 * 2015/8/25 0025
 * ImageToString
 */
public class TestProcessImage {

    public static final String fileName = "C:\\Users\\fengtang\\Desktop\\img\\flightNo.png";
    @Test
    public void processImageTest() {
        try {
            BufferedImage imag = ImageIO.read(new File(fileName));;
            System.out.println(ImageToString.getString(imag));
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

测试的航班号和价格





            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：欢迎交流

Hdoj 5410 CRB and His Birthday【背包变形】
题意

现在有 m 块钱以及 n 种物品，然后每种物品价格 val，买 x 个送糖果 x * w1 + w2，问怎么买是的送的糖果最多？


分析

一看就是很明显的背包，问题在于这个w2，我们知道普通的背包放进去的物体得到的价值只和放进去的数量成正比。这里不是正比，假如放了为正比+w2，所以这里还与放与不放有关系。
千万不要陷入放于不放中，其实我们可以对w2这里做一次0-1背包，价值为w1+w2.然后对剩下的进行多重背包或完全背包。
因为没有限制数量，所以可以直接完全背包，这样很快，当然可以对剩下的做多重也对，但是切记直接做多重，然后二进制优化中第一个0-1，这样是错的，自己模拟下这组数据 
  100 2 
  10 2 1 
  10 1 2


代码
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>

using namespace std;

const int N = 2010;
const int M = 1010;

int capacity[M],w1[M],w2[M];
int dp[N];
void Zero_one(int cost,int w,int m)
{
    for(int i=m;i>=cost;--i)
        dp[i] = max(dp[i],dp[i-cost]+w);
}
int main()
{
//    freopen("Input.txt","r",stdin);
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int m,n;
        scanf("%d%d",&m,&n);
        for(int i=0;i<n;i++)
            scanf("%d%d%d",&capacity[i],&w1[i],&w2[i]);
        memset(dp,0,sizeof(dp));
        for(int i=0;i<n;i++)
        {
            Zero_one(capacity[i], w1[i]+w2[i], m);
            int k=1;
            int num = m/capacity[i]-1;
            while(k<num)
            {
                Zero_one(k*capacity[i], k*w1[i], m);
                num-=k; //
                k*=2;
            }
            Zero_one(num*capacity[i], num*w1[i], m);
        }
        printf("%d\n",dp[m]);
    }

    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

dev view 列名称居中


1.这句话是view行中值居中
this.gridView1.Appearance.Row.TextOptions.HAlignment = DevExpress.Utils.HorzAlignment.Center;
 2.这句话是view列标题居中
 this.gridView1.Appearance.HeaderPanel.TextOptions.HAlignment = DevExpress.Utils.HorzAlignment.Center;



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU   2841  Visible Trees（容斥定理）

Visible Trees
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 1951    Accepted Submission(s): 792



Problem Description

There are many trees forming a m * n grid, the grid starts from (1,1). Farmer Sherlock is standing at (0,0) point. He wonders how many trees he can see.

If two trees and Sherlock are in one line, Farmer Sherlock can only see the tree nearest to him.

 


Input

The first line contains one integer t, represents the number of test cases. Then there are multiple test cases. For each test case there is one line containing two integers m and n(1 ≤ m, n ≤ 100000)

 


Output

For each test case output one line represents the number of trees Farmer Sherlock can see.

 


Sample Input

2
1 1
2 3


 


Sample Output

1
5


 


Source

2009 Multi-University Training
 Contest 3 - Host by WHU

 






         题意：有一个n*m的矩阵，左下角坐标为(1,1)，右上角坐标为(n,m);你现在的位置的坐标是(0,0),输出现在你能看到几个点.
         思路：你将矩阵仔细研究一下会发现如果两个点A(x1,y1),B(x2,y2)如果x2,y2有一个公约数k，使得x2/k == x1 && y2/k == y1 这样的话就两个点就会形成一个线段y=kx，正好(0,0)在这条线段中，故在这条线段上的矩阵上的点就只能看到一个。所以我们就得出结论如果坐标(x,y)中x,y互质，那么就能过被看到，如果我们将矩阵的一边固定住，假设是n，那么题意就转化成求1--m与区间[1,n]求互质的个数的题了，这样的话就是一个很简单的容斥定理的问题了，具体看代码吧。






点击打开链接





#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<vector>
#include<queue>
#include<stack>
#include<map>

#define N 1100

using namespace std;

int n,m,k;
int prime[N],num[N];
int t;

__int64 IEP(int pn){   /// [n,m]区间求与k互质的个数
    int pt = 0;
    __int64 s = 0;
    num[pt++] = -1;
    for(int i=0;i<t;i++){
        int l = pt;
        for(int j=0;j<l;j++){
            num[pt++] = num[j]*prime[i]*(-1);
        }
    }
    for(int i=1;i<pt;i++){
        s += pn/num[i];
    }
    return s;
}

int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&m);
        __int64 sum = 0;
        for(int i=1;i<=n;i++){
            memset(prime,0,sizeof(prime));
            memset(num,0,sizeof(num));
            int pk = sqrt(i);
            int nn = i;
            t = 0;
            for(int j=2;j<=pk;j++){
                if(nn%j == 0){
                    prime[t++] = j;
                    while(nn%j == 0){
                        nn = nn / j;
                    }
                }
            }
            if(nn!=1){
                prime[t++] = nn;
            }
            sum += m - IEP(m);
        }
        printf("%I64d\n",sum);
    }
    return 0;
}



版权声明：本文为博主原创文章，如有特殊需要请与博主联系  QQ ： 793977586。

程序在的内存中的分配（常量，局部变量，全局变量，程序代码）

一. 在c中分为这几个存储区
1.栈 - 由编译器自动分配释放
2.堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收
3.全局区（静态区），全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放
4.另外还有一个专门放常量的地方。- 程序结束释放
                                                                                                                                              
在函数体中定义的变量通常是在栈上，用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区（静态区）,在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。另外，函数中的"adgfdf"这样的字符串存放在常量区。比如：


//main.cpp
int a = 0;      // 全局初始化区
char *p1;      // 全局未初始化区
void main()
{
    int b;            // 栈区
    char s[] = "abc"; // 栈区
    char *p2; // 栈区
    char *p3 = "123456"; // p3在栈区;   "123456\0" 在常量区， 
 
    static int c =0;      // 全局（静态）初始化区
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 
    strcpy(p1, "123456");    // "123456\0" 放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
} 

二.在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区
1.栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。
2.堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
3.自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
4.全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
5.常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）



三、堆和栈的理论知识 
申请方式 
stack: 由系统自动分配。   例如，声明在函数中一个局部变量   int   b;   系统自动在栈中为b开辟空间 
heap: 需要程序员自己申请，并指明大小，在c中malloc函数 
如p1  =   (char   *)malloc(10); 
在C++中用new运算符 
如p2  =   (char   *)malloc(10);

但是注意p1、p2本身是在栈中的。
KMP 讲解 和 KMP的 strstr 实现
网上关于KMP的讲解已经够多了，但我感觉很多的文章对于一些关键点的解释还不够清晰，如果你还不知道KMP算法，那建议你先百度了解一番KMP，如果了解完后感觉大脑还是塞塞的，思路不够清晰的话再来看看我这篇文章。这里就不再对KMP从头到尾讲述了。毫无疑问，KMP的关键点就是求next数组，我只针对如下两点做解释以及给与数学证明。
针对字符串str求它的next数组：
1 next[i]的意义：
next[i]的意义是当下标为i的元素不匹配时，它的前缀和后缀能够匹配的最长长度，计算前缀和后缀的时候是不把当前字符考虑进去的，因为我是当前字符失配时跳转到下一个位置（也就是说这个字符之前的字符都匹配了），以及计算前缀时不能把最后一个字符包括，计算后缀时当然也不能把第一个字符考虑进来，比如“AAABC”，当计算第四个字符B的时候，它的前缀和后缀匹配的最长长度是2，因为第一个和最后一个字符不能互相包括嘛。 所谓的前缀 和 后缀 都是从左到右计算的，也就是下标从小到大的，比如字符串“ABABB”，计算最后一个字符B的next值时，后缀为AB。
好了，理解了next[i]的意义后，我们说说next[0]和next[1]的值，这两个的值是确定的，next[0]=-1,next[1]=0。我来解释为什么这么设置它们的值。我们在在计算第J个字符的next值时，让i=J-1，如果str[ next[i]  ] 与 str[ J-1 ]不匹配时，我们会进行跳转，也就是让i=next[i]（待会会解释为什么这么跳转），但是我们需要一个终止条件，也就是前缀长度为1时也不匹配的时候，这时应该终止，而当第0个元素与str[J-1]不匹配时，此时恰好i=next[0]，i=-1了，此时我们知道前后缀能匹配的最长长度为0，因此我们把next[0]设置为-1，当然设置为-2，-3都可以，因为它只是一个终止条件，好让我们判断i=该值时，匹配长度为0，可以计算下一个字符的next值了。
为什么next[1]=0呢，因为，next[1]之前只有一个字符，那个字符既是它的前缀也是后缀，而next数组的定义中已经说明了，计算的时候不能互相包括，所以next[1]直接设置为0，真正的next数组从2开始计算起。这里我给出当str [next[i]]==str[ J-1 ]时，next[ j ]=next[i]+1的数学证明：
采用反证法： 
假设第J个字符存在更大的next值，设这个值为K，那么K>next[i]+1,则 K-1>next[ i ] ,（此处i=j-1） 根据next数组的求法我们知道，也就是存在某个值P和L，使得 str[0~P]=str[L~i]，也就是存在str[0~P-1]=str[L~ i-1]，这个值恰好是next[i]的值，等于K-1，而根据前置条件K-1>next[i],两者矛盾，故当str [next[i]]==str[
 J-1 ]时，next[ j ]=next[i]+1。（原谅我写这么多文字而不带一张图，请耐下心来）


2 next[i]的跳转：
上面已经说了，让i=J-1，如果str[ next[i] ] 与 str[ J-1 ]不匹配时，我们会进行跳转，也就是让i=next[i]，然后继续比较直到求得next[J]的值。（没错，在求next[J]的值时，每次都是与str[J]比较） 这么跳转的原因还得从next数组每个值的意义说起，就是前后缀匹配的最长长度。
next [ i ]的意义是存在两个值P,K使得str[ 0~P ]和str[ K ~ i-1 ]匹配（那么也就是next[i]=P+1）。
令i=J-1，假设我们的str[ next[i] ] 与 str[ J-1 ] 不匹配，
即 str[P+1]!=str[J-1],根据next数组的定义，我们现在要找两个新的值M，N来组成前缀和后缀，使得str[ 0 ~ M ]=str[ N ~ i-1 ]匹配再比较str [ M+1 ]与str [ i ]是否相等以此来求next[J]的值，我们知道新求得的匹配长度必然是小于next[i]的（待会会证明），也就是说M<P,N>k,
  因为str [ 0~P ]与str [ k ~ i-1 ]相等，因此str [ N ~ i-1 ]是str [ 0 ~ P ]的一个子串，那么我们现在其实就是在求str[ P+1 ]也就是str[ next[i] ] 的next值。所以才让i=next[i].
现在我证明，新求得的匹配长度必然是小于next[i]的（注意这里我证明的是什么，不清楚的看上面那段话中，我说的待会会证明）。
反证法：
假设新求得的长度为L，且L>=next[i]。那么存在str [ 0~L-1 ]=str [ J-L+1 ~  i-1 ]，而我们next [ i ]的值的定义就是第i个字符前的最长前后缀匹配长度，如果还存在新的长度L满足这种关系的话，那么不满足我们的next数组的定义，两者矛盾，因此命题得证。


本来很想画图，但苦于没有没有合适的画图工具，导致我只能纯文字的叙述，希望能够帮到对KMP尚还不清晰的朋友，另外，我的一贯原则是talk is cheap show me the code 所以 这里还是提供一个小例子，通过kmp来实现strstr函数


#include <iostream>
using namespace std;
//求next数组
void getNext(char* str,int* arr,int n){
	arr[0]=-1;
	if(n<=1)
		return;
	arr[1]=0;
	int j=2,i;
	while(j<n){
		i=j-1;
		while(1){
			if(arr[i]==-1||str[j-1]==str[arr[i]]){
				arr[j]=arr[i]+1;
				j++;
				break;
			}else
				i=arr[i];
		}
	}
}
//统计字符串长度
int strlen(char* str){
	int len=0;
	while(*str++!='\0')
		len++;
	return len;
}
//返回在源串中第一个与子串匹配的字符的起始地址，若没有匹配则返回NULL
char* strstr(char* src,char* match){
	int len1=strlen(src);
	int len2=strlen(match);
	if(len1==0||len2==0||len1<len2)
		return NULL;
	int* next=new int[len2];
	getNext(match,next,len2);
	int j=0,i=0;
	while(i<len1&&j<len2){
		if(j==-1||src[i]==match[j])
		{
			i++;
			j++;
		}
		else
			j=next[j];
	}
	delete[] next;
	if (j==len2)
		return (src+i-j);
	return NULL;
}

int main(int arg1,char** arg2){
	char str1[]="today is sunny and all is right";
	char str2[]=" al";
	char* res=strstr(str1,str2);
	if(res!=NULL)
		cout<<res<<endl;
	else
		cout<<"res is null"<<endl;
	getchar();
}



我们知道strstr是返回源串中第一个与模式串匹配的地址。
假设我现在更改需求，需要返回所有与模式串匹配的下标呢（源串中的每个字符只能用一次，也就是说各个子串在源串中的位置不重叠）
look is cheap show me the code。
可以把下标都存在vector中，将其作为返回值，有兴趣的朋友可以写一写。




若有错误，或是建议，欢迎留言。













版权声明：本文为博主原创文章，未经博主允许不得转载。

python菜鸟日记8

1. python中的多进程编程概念：由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Process类来代表一个进程对象。


2. python中的多线程编程具体做法：当我们引入该multiprocessing模块后，对需要进行调用的函数创建进程：b= Process(target=函数名, args=(实参,))，因为process是一个类，所以b就是一个target函数的进程对象，我们也可以在里面添加name属性进行定义这个进程的名字，但python一般都是自动给这个进程一个名字，b.start()通过调用start（）函数进行启动进程来执行函数，p.join()通过调用join（）函数来说明当需要调用执行的函数调用完毕以后紧接着执行后面的语句代码，这个函数的左右就好像一个承接作用。


3. python中的进程池：如果需要对一个函数进行传入多个不同的实参，可以通过进程池来创建多个子进程。具体做法：from multiprocessing import Pool先引入进程池，b= Pool(n)创建进程池对象，里面的n表示可以同时进行n个进程，一定要记住多进程调用时，进程之间是交替执行的，b.apply_async(函数名, args=(实参,))创建进程，多次调用apply_async（）创建多个子进程，p.close()多进程执行完毕后通过调用close（）来结束进程并表示不能继续添加新的Process了，p.join()承接作用。


4. Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据，以Queue为例，我们可以写两个函数，一个是read函数，一个是write函数，引入Queue以后，我们b=Queue()来创建一个b队列对象，然后在read函数中用a=b.get（true）来取出队列b中的值，在write函数中通过b.put（value）将value写入队列b中，这样以后，我们再创建俩个进程，然后start（）调用执行，这俩个进程之间就可以用Queue来进行通信了。


5. 在Unix/Linux下，可以使用fork()调用实现多进程。要实现跨平台的多进程，可以使用multiprocessing模块。进程间通信是通过Queue、Pipes等实现的。


6. python中的多线程编程：Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块


7. python中的多进程编程做法：与多进程编程类似，b= threading.Thread(target=函数名, name=线程别名)，t.start()启动线程执行函数，t.join()承接作用


8. 多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。（这里的变量指的是模块中的全局变量）


9. 多线程中的lock，b= threading.Lock()来创建锁对象b,对于与全局变量有关的函数中定义锁机制lock.acquire()，也就是多线程在执行这个函数时都要先得到这个锁，然后才能进行下面的语句代码，否则进入排队队列进行等待，执行完函数后lock.release()来进行释放锁，给等待队列中的线程继续执行，这样就避免了线程在交替执行时全局变量的不稳定性。


10. 多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。


11. 在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。前面我们已经直到用lock进行多线程中的全局变量进行加锁，但是，python有提供了另一种方法，可以对全局变量不加锁，单个线程里的"全局变量",就是线程里的所有函数都可访问,但其它线程无法访问的变量...它叫做Threadlocal。


12.Threadloca的使用方法:我们通过b= threading.local()来创建b全局变量，而b又是一个ThreadLocal对象，在各个函数中可以定义b.a，b.c,b.e这些线程中的局部变量，是b的属性，就好像b是线程的全局变量，后面的b.a,b.e是线程的全局子变量，我们可以把他们全部看成是某个线程的全局变量，这样在多线程交替执行的时候，每个线程都能用自己的全局变量，就避免了源程序中的全局变量共享的问题。


13. 首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。


14. 多进程优缺点：多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）
                                 多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题


15. 多线程优缺点：多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。在Windows下，多线程的效率比多进程要高。


16. 无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？因为多线程多进程是交替执行的，所以会有切换过程，这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。


17. 计算密集型任务：计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。


18. IO密集型任务：涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差


19. if __name__ == '__main__':的作用是：判断该模块是否是直接执行还是在被调用到另外一个模块中进行执行，
如果我们是直接执行某个.py文件的时候，该文件中那么”__name__ == '__main__'“是True,但是我们如果从另外一个.py文件通过import导入该文件的时候，这时__name__的值就是我们这个py文件的名字而不是__main__。这个功能还有一个用处：调试代码的时候，在”if __name__ == '__main__'“中加入一些我们的调试代码，我们可以让外部模块
调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

http操作，模拟第三方接口回调通知


可以用来检验返回给第三方的回应SUCCESS是否正确，包括编码，是否有空格



模拟第三方接口发送回调notify

import java.io.IOException;
	import java.io.InputStream;
	import java.io.OutputStream;
	import java.net.HttpURLConnection;
	import java.net.URL;
	
	private static byte[] readContent(final InputStream in, int length) throws IOException {
		byte dataBytes[] = new byte[length];		
		int bytesRead = 0;
		int n = 0;
		int leftbytes = length;
		while (leftbytes > 0
				&& (n = in.read(dataBytes, bytesRead, leftbytes)) != -1) {
			leftbytes = length - bytesRead;
			bytesRead = bytesRead + n;
		}
		return dataBytes;
	}

	public static void main(String args[]){
		try {
			
			URL url = new URL("https://www.1hedai.com/page/style4/yeepayCallBack/SpaceNotify.jsp");
			HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();
			urlcon.setReadTimeout(5000);
			urlcon.setDoOutput(true);
			urlcon.setDoInput(true);
			urlcon.setRequestMethod("POST");
			urlcon.setRequestProperty("Content-Type", "text/xml;charset=UTF-8");
			OutputStream out = urlcon.getOutputStream();
			
			out.write("测试返回的SUCCESS".getBytes("UTF-8"));
			out.flush();
			out.close();
			
			int length = urlcon.getContentLength();
			InputStream in = urlcon.getInputStream();
			byte[] b = readContent(in, length);
			String result =  new String(b, "UTF-8");
			System.out.println("收到的回调:" + result + "0");
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}



服务器接收到notify，并发送回应SUCCESS


//接口回调
	//打印参数
	System.out.println("+++++++++++++++ space Notify ++++++++++++++++++");
	
	//声明JSP对象
	try{
		// 验签
		//boolean flag = SignUtil.verifySign(sourceMessage, signMsg);
		//out.print("SUCCESS");
		response.setHeader("Content-type", "text/html;charset=UTF-8");
		response.setCharacterEncoding("UTF-8");
		//response.getWriter().write("SUCCESS");
	
		OutputStream outStream = response.getOutputStream();
		outStream.write("SUCCESS".getBytes("UTF-8"));
		//outStream.flush();
		outStream.close(); 
	}catch(Exception e){
		 e.printStackTrace();
	}



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU   1695   GCD（容斥定理）

GCD
Time Limit: 6000/3000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 7529    Accepted Submission(s): 2773



Problem Description

Given 5 integers: a, b, c, d, k, you're to find x in a...b, y in c...d that GCD(x, y) = k. GCD(x, y) means the greatest common divisor of x and y. Since the number of choices may be very large, you're only required to output the total number of different number
 pairs.
Please notice that, (x=5, y=7) and (x=7, y=5) are considered to be the same.

Yoiu can assume that a = c = 1 in all test cases.


 


Input

The input consists of several test cases. The first line of the input is the number of the cases. There are no more than 3,000 cases.
Each case contains five integers: a, b, c, d, k, 0 < a <= b <= 100,000, 0 < c <= d <= 100,000, 0 <= k <= 100,000, as described above.


 


Output

For each test case, print the number of choices. Use the format in the example.


 


Sample Input

2
1 3 1 5 1
1 11014 1 14409 9


 


Sample Output

Case 1: 9
Case 2: 736427

HintFor the first sample input, all the 9 pairs of numbers are (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 5), (3, 4), (3, 5). 


 


Source

2008 “Sunline Cup” National Invitational Contest












    题意：输入五个整数a,b,c,d,k，要求从区间[a,b]取出一个x，从区间[c,d]取出一个y，使得GCD(x,y) == k求出有多少种情况，不过注意的是GCD(5,7)与GCD(7,5)是一种。


    思路：将x,y同时除以k，就转变成求x,y互质，就能用容斥定理做了。




点击打开链接





#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<vector>
#include<queue>
#include<stack>
#include<map>

#define N 101000

using namespace std;

vector<int>q[N];
int num[N];
int a,b,c,d,k;

void init(){
    for(int i=0;i<=N;i++){
        q[i].clear();
    }
    for(int i=1;i<=100000;i++){
        int p = i;
        int pi = sqrt(p);
        for(int j=2;j<=pi;j++){
            if(p%j == 0){
                q[i].push_back(j);
                while(p%j == 0){
                    p = p/j;
                }
            }
        }
        if(p!=1){
            q[i].push_back(p);
        }
    }
}

__int64 IEP(int ii,int pn){
    int pt = 0;
    __int64 s = 0;
    num[pt++] = -1;
    for(int i=0;i<q[ii].size();i++){
        int l = pt;
        for(int j=0;j<l;j++){
            num[pt++] = num[j]*q[ii][i]*(-1);
        }
    }
    for(int i=1;i<pt;i++){
        s += pn/num[i];
    }
    return s;
}

int main(){
    int T;
    init();
    int kk = 0;
    scanf("%d",&T);
    while(T--){
        scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);
        if(b>d){
            int e = b;
            b = d;
            d = e;
        }
        if(k == 0){
            printf("Case %d: 0\n",++kk);
            continue;
        }
        b = b/k;
        c = b+1;
        d = d/k;
        __int64 sum = 0;
        for(int i=1;i<=b;i++){
            sum += b - IEP(i,b);
        }
        sum = (sum+1)/2;
        for(int i=1;i<=b;i++){
            sum += d - c + 1 - IEP(i,d) + IEP(i,c-1);
        }
        printf("Case %d: %I64d\n",++kk,sum);
    }
    return 0;
}



 

版权声明：本文为博主原创文章，如有特殊需要请与博主联系  QQ ： 793977586。

POJ 2479 Maximum sum && 2593 Max Sequence （dp）买一送一

Max Sequence




Time Limit: 3000MS
 
Memory Limit: 65536K


Total Submissions: 16511
 
Accepted: 6921




Description

Give you N integers a1, a2 ... aN (|ai| <=1000, 1 <= i <= N). 


You should output S. 

Input

The input will consist of several test cases. For each test case, one integer N (2 <= N <= 100000) is given in the first line. Second line contains N integers. The input is terminated by a single line with N = 0.
Output

For each test of the input, print a line containing S.
Sample Input
5
-5 9 -5 11 20
0

Sample Output
40
Source

POJ Monthly--2005.08.28,Li Haoyuan

ACcode：

#include <cmath>
#include <cstdio>
#include <iostream>
#define maxn  100000+5
using namespace std;
int a[maxn],dp[maxn],pd[maxn],sum;
int main(){
    int loop,n;
    while(scanf("%d",&n)&&n){
        scanf("%d",&a[1]);
        dp[0]=pd[n+1]=-maxn;
        dp[1]=a[1];
        for(int i=2;i<=n;++i){
            scanf("%d",&a[i]);
            dp[i]=max(dp[i-1]+a[i],a[i]);
        }
        pd[n]=a[n];
        for(int i=n-1;i>0;--i){
            pd[i]=max(pd[i+1]+a[i],a[i]);
        }
        for(int i=1,j=n-1;i<=n;++i,--j){
            dp[i]=max(dp[i],dp[i-1]);
            pd[i]=max(pd[i],pd[i+1]);
           // printf("dp[%d]==%d  pd[%d]==%d\n",i,dp[i],i,pd[i]);
        }
        sum=dp[1]+pd[2];
        for(int i=2;i<=n;++i)
            sum=max(sum,dp[i]+pd[i+1]);
        printf("%d\n",sum);
    }
    return 0;
}


Maximum sum




Time Limit: 1000MS
 
Memory Limit: 65536K


Total Submissions: 36441
 
Accepted: 11309




Description

Given a set of n integers: A={a1, a2,..., an}, we define a function d(A) as below:

Your task is to calculate d(A).
Input

The input consists of T(<=30) test cases. The number of test cases (T) is given in the first line of the input. 
Each test case contains two lines. The first line is an integer n(2<=n<=50000). The second line contains n integers: a1, a2, ..., an. (|ai| <= 10000).There is an empty line after each case.
Output

Print exactly one line for each test case. The line should contain the integer d(A).
Sample Input
1

10
1 -1 2 2 3 -3 4 -4 5 -5
Sample Output
13
Hint

In the sample, we choose {2,2,3,-3,4} and {5}, then we can get the answer. 

Huge input,scanf is recommended.
Source

POJ Contest,Author:Mathematica@ZSU
ACcode：

#include <cmath>
#include <cstdio>
#include <iostream>
#define maxn 50000+5
using namespace std;
int a[maxn],dp[maxn],pd[maxn],sum;
int main(){
    int loop,n;
    scanf("%d",&loop);
    while(loop--){
        scanf("%d",&n);
        scanf("%d",&a[1]);
        dp[0]=pd[n+1]=-maxn;
        dp[1]=a[1];
        for(int i=2;i<=n;++i){
            scanf("%d",&a[i]);
            dp[i]=max(dp[i-1]+a[i],a[i]);
        }
        pd[n]=a[n];
        for(int i=n-1;i>0;--i){
            pd[i]=max(pd[i+1]+a[i],a[i]);
        }
        for(int i=1,j=n-1;i<=n;++i,--j){
            dp[i]=max(dp[i],dp[i-1]);
            pd[i]=max(pd[i],pd[i+1]);
           // printf("dp[%d]==%d  pd[%d]==%d\n",i,dp[i],i,pd[i]);
        }
        sum=dp[1]+pd[2];
        for(int i=2;i<=n;++i)
            sum=max(sum,dp[i]+pd[i+1]);
        printf("%d\n",sum);
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

spring事务处理详解
1：Java包含两种异常：checked异常和unchecked异常。
checked和unchecked异常之间的区别是： 
Checked异常必须被显式地捕获try-catch-finally,而unchecked异常则可以不必捕获或抛出。 
Checked异常继承java.lang.Exception类。Unchecked异常继承自java.lang.RuntimeException类。
2：Mysql 存储引擎中InnoDB与Myisam的主要区别
事务处理方面：innodb 支持事务功能，myisam 不支持。 
Myisam 的执行速度更快，性能更好。
engine = innodb 和 engine = myisam 
可使用下述语句之一检查表的表类型： 
SHOW TABLE STATUS LIKE ‘tbl_name’; 
SHOW CREATE TABLE tbl_name;
使用下述语句，可检查mysqld服务器支持的存储引擎：  
SHOW ENGINES;
3：spring事务处理
throw new RuntimeException(“xxxxxxxxxxxx”); 默认事务回滚 
throw new Exception(“xxxxxxxxxxxx”); 默认事务不回滚 
Spring的AOP即声明式事务管理默认是针对unchecked exception回滚。也就是默认对RuntimeException()异常或是其子类进行事务回滚； 
checked异常,throw new Exception默认不会回滚
若想让checked异常或者自定义异常回滚 
(1)配置文件方式
<tx:advice id="txAdvice">
    <tx:attributes>
       <tx:method name="update*" no-rollback-for="IOException"/>
       <tx:method name="*"/>
    </tx:attributes>
 </tx:advice>

<tx:advice id="txAdvice" transaction-manager="transactionManager">
 　　<tx:attributes>
 　　　　<tx:method name="*" rollback-for="com.cn.untils.exception.MyException"/>
 　　</tx:attributes>
 </tx:advice>

(2)注解方式
@Transactional(rollbackFor = Exception.class)
 @Transactional(rollbackFor = MyException.class)
不起作用： 
@Transactional
public void addAdmin(Admin admin) throws Exception {
    try {
        this.adminDao.add(admin);
        admin.setUsername("123456789012345");
        this.adminDao.update(admin);
    } catch (Exception e) {
        e.printStackTrace();
        throw new Exception("测试!");
    }

}

起作用
@Transactional(rollbackFor = Exception.class)
public void addAdmin(Admin admin) throws Exception {
    try {
        this.adminDao.add(admin);
        admin.setUsername("123456789012345");
        this.adminDao.update(admin);
    } catch (Exception e) {
        e.printStackTrace();
        throw new Exception("测试!");
    }

}
起作用
@Transactional
public void addAdmin(Admin admin) {
    try {
        this.adminDao.add(admin);
        admin.setUsername("123456789012345");
        this.adminDao.update(admin);
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException("测试!");
    }

}
完整写法：
@Transactional(rollbackFor = RuntimeException.class)
public void addAdmin(Admin admin) {
    try {
        this.adminDao.add(admin);
        admin.setUsername("123456789012345");
        this.adminDao.update(admin);
    } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException("测试!");
    }
——————————————————————————————————————— 
  我开通了微信订阅号“i小窝”，关注即可第一时间看到我的原创文章以及我推荐的精彩文章： 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[笔记][Java7并发编程实战手册]4.3 创建固定的线程执行器newFixedThreadPool线程池
[笔记][Java7并发编程实战手册]系列目录

简介

newFixedThreadPool(int nThreads, ThreadFactory threadFactory)  
    创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。

newCachedThreadPool()创建的线程池的特性是：自动回收不使用的线程（终止并从缓存中移除那些已有 60 秒钟未被使用的线程），（在无可用线程的情况下）自动的为新来的task创建新线程。 
正是因为这种特性，在小任务量，任务时间执行短的场景下能提高性能。然后如果在大量任务，且任务执行之间较长的场景中，系统将会超负荷。性能极低。
newFixedThreadPool(int nThreads)　就是来解决以上问题的。它创建一个固定大小的线程池，如果task任务数量大于nThreads数量，那么这些任务将在队列中排队，直到有可用线程再执行。
讲了2章了,可能有得人还不知道为什么要强转成ThreadPoolExecutor，可以看下面的源码，和下面的类图就明白了
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }


newSingleThreadExecutor： 
　　只创建一个线程的线程池。多余的task将以无界队列来运行。也就是阻塞到有可用线程才能运行。

示例
创建固定大小的线程池
场景描述：下面示例讲的是：创建一个固定大小的线程执行器线程池，然后循环创建几个task任务执行。观察线程数量和名称。
/**
 * Created by zhuqiang on 2015/8/25 0025.
 */
public class Client {
    public static void main(String[] args) {
        ThreadPoolExecutor es = (ThreadPoolExecutor) Executors.newFixedThreadPool(3);
//        es.shutdown();   // 如果先关闭再执行任务，则会拒绝执行任务，抛出RejectedExecutionException异常
        for (int i = 0; i < 10 ; i++) {
            es.execute(new Task(es,"task-"+i));
        }
        es.shutdown();

    }
}
class Task implements  Runnable{
    private  ThreadPoolExecutor es;
    private  String name;

    public Task(ThreadPoolExecutor es, String name) {
        this.es = es;
        this.name = name;
    }

    @Override
    public void run() {
        try {
            long timeout = (long) (Math.random() * 10);
            TimeUnit.SECONDS.sleep(timeout);
            System.out.println(Thread.currentThread().getName() + "...执行完成..task=" + name +"    耗时：" + timeout);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
某一次的运行结果：
pool-1-thread-2...执行完成..task=task-1    耗时：0
pool-1-thread-1...执行完成..task=task-0    耗时：3
pool-1-thread-3...执行完成..task=task-2    耗时：4
pool-1-thread-2...执行完成..task=task-3    耗时：5
pool-1-thread-1...执行完成..task=task-4    耗时：5
pool-1-thread-3...执行完成..task=task-5    耗时：7
pool-1-thread-3...执行完成..task=task-8    耗时：0
pool-1-thread-2...执行完成..task=task-6    耗时：8
pool-1-thread-1...执行完成..task=task-7    耗时：7
pool-1-thread-3...执行完成..task=task-9    耗时：8
结果说明：可以看到，创建了3个数量的线程池，在执行中，也只会使用这三个线程数量，而其他的则会阻塞等待执行。

创建固定大小的线程池的时候使用ThreadFactory
ThreadFactory的作用：构造一个新 Thread。实现也可能初始化属性、名称、守护程序状态、ThreadGroup 等等。 
在写demo的时候，我认为最麻烦的就是，设置循环中创建的线程的join方法。 在没有使用线程池的时候，在循环中调用这个方法都麻烦，要么抛出异常，要么就只有再循环一次来单独设置。 就这个场景而言，使用ThreadFactory来就很简单了。 ——————–  好把，我以为在工厂中，自己调用join方法能行。但是测试过了。视乎没有效果。  那就只能看下用法。场景用途我暂时也不知道了
示例如下：
/**
 * Created by zhuqiang on 2015/8/25 0025.
 */
public class Client {
    public static void main(String[] args) {
//        ThreadPoolExecutor es = (ThreadPoolExecutor) Executors.newFixedThreadPool(3);  //1 该注释代码。和下面为使用工厂的对比。
        ThreadPoolExecutor es = (ThreadPoolExecutor) Executors.newFixedThreadPool(3, new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r);
                thread.setName("xxxx" + thread.getId());  //对新创建的线程做一些操作
                return thread;
            }
        });
        for (int i = 0; i < 10 ; i++) {
            es.execute(new Task(es,"task-"+i));
        }
        es.shutdown();
    }
}
class Task implements  Runnable{
    private  ThreadPoolExecutor es;
    private  String name;

    public Task(ThreadPoolExecutor es, String name) {
        this.es = es;
        this.name = name;
    }

    @Override
    public void run() {
        try {
            long timeout = (long) (Math.random() * 10);
            TimeUnit.SECONDS.sleep(timeout);
            System.out.println(Thread.currentThread().getName() + "...执行完成..task=" + name +"    耗时：" + timeout);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


某一次的执行结果：
xxxx12...执行完成..task=task-0    耗时：3
xxxx12...执行完成..task=task-3    耗时：2
xxxx14...执行完成..task=task-2    耗时：6
xxxx13...执行完成..task=task-1    耗时：7
xxxx13...执行完成..task=task-6    耗时：0
xxxx12...执行完成..task=task-4    耗时：4
xxxx13...执行完成..task=task-7    耗时：6
xxxx14...执行完成..task=task-5    耗时：7
xxxx12...执行完成..task=task-8    耗时：5
xxxx13...执行完成..task=task-9    耗时：8

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 1869 六度分离
六度分离

Time Limit: 5000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)

Total Submission(s): 6509    Accepted Submission(s): 2627


Problem Description
1967年，美国著名的社会学家斯坦利·米尔格兰姆提出了一个名为“小世界现象(small world phenomenon)”的著名假说，大意是说，任何2个素不相识的人中间最多只隔着6个人，即只用6个人就可以将他们联系在一起，因此他的理论也被称为“六度分离”理论(six degrees of separation)。虽然米尔格兰姆的理论屡屡应验，一直也有很多社会学家对其兴趣浓厚，但是在30多年的时间里，它从来就没有得到过严谨的证明，只是一种带有传奇色彩的假说而已。


Lele对这个理论相当有兴趣，于是，他在HDU里对N个人展开了调查。他已经得到了他们之间的相识关系，现在就请你帮他验证一下“六度分离”是否成立吧。
 

Input
本题目包含多组测试，请处理到文件结束。
对于每组测试，第一行包含两个整数N,M(0<N<100,0<M<200),分别代表HDU里的人数（这些人分别编成0~N-1号)，以及他们之间的关系。
接下来有M行，每行两个整数A,B(0<=A,B<N)表示HDU里编号为A和编号B的人互相认识。
除了这M组关系，其他任意两人之间均不相识。

 

Output
对于每组测试，如果数据符合“六度分离”理论就在一行里输出"Yes"，否则输出"No"。
 

Sample Input

8 7
0 1
1 2
2 3
3 4
4 5
5 6
6 7
8 8
0 1
1 2
2 3
3 4
4 5
5 6
6 7
7 0

 

Sample Output

Yes
Yes#include<stdio.h>
#define INF 0xfffffff
#include<string.h>
#define N 120 
int country,road;
int v[N],map[N][N],cost[N];
void dij(int sta)
{
    int mincost,next;
    int i,j;
    memset(v,0,sizeof(v));
    for(i=0;i<country;i++)
    cost[i]=map[sta][i];
    v[sta]=1;
    for(i=1;i<country;i++)
     {
         mincost=INF;
         for(j=0;j<country;j++)
          {
              if(!v[j]&&cost[j]<mincost)
              {
                  mincost=cost[j];
                  next=j;
              }
          }
          v[next]=1;
          for(j=0;j<country;j++)
           {
               if(!v[j]&&cost[j]>cost[next]+map[next][j])
               cost[j]=cost[next]+map[next][j];
           }
     }
}
int max()//寻找最大的距离（两人之间的） 
{
    int y=-1;
    int u;
    int i,j;
    for(j=0;j<country;j++)
    {
      dij(j);
    for(i=j+1;i<country;i++)
     {
         if(cost[i]>y)
         y=cost[i];
     }
    }
     return y;
}
 int main()
{
    while(scanf("%d%d",&country,&road)!=EOF)
    {
        int i,j;
        for(i=0;i<country;i++)//初始化 
        {
            map[i][i]=0;
            for(j=0;j<country;j++)
             {
                 if(i!=j)
                 {
                     map[i][j]=INF;
                 }
             }
        }
        int a,b;
        while(road--)
        {    
            scanf("%d%d",&a,&b);
            map[b][a]=map[a][b]=1;//任何两人之间的距离都是1 
        }
        int s=max();
        if(s>7)//是否满足条件 
        printf("No\n");
        else
        printf("Yes\n");
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Python一日一练06----怒刷点击量pyqt5版

功能
输入博主用户名，增加博主点击量


软件截图


部分源码
# coding=utf-8
__author__ = 'a359680405'

from PyQt5 import QtWidgets
from PyQt5.QtCore import QThread
from PyQt5.QtCore import pyqtSignal
from visitspage.UI.MainForm import Ui_MainForm
from visitspage.UI.newForm import Ui_newForm
import  re,time
import urllib.request

from bs4 import BeautifulSoup

class WorkThread(QThread):
    _strName="a359680405"
    _brushNum=50
    trigger=pyqtSignal(str)                         #传参

    def __init__(self,strName,brushNum):
        super(WorkThread,self).__init__()
        self._strName=strName
        self._brushNum=brushNum

    def run(self):
        p=re.compile('/'+self._strName+'/article/details/........')
        #自己的博客主页
        url = "http://blog.csdn.net/"+self._strName
        #使用build_opener()是为了让python程序模仿浏览器进行访问
        opener = urllib.request.build_opener()
        opener.addheaders = [('User-agent', 'Mozilla/5.0')]
        try:
            html = opener.open(url).read().decode('utf-8')
        except urllib.error.HTTPError:
                      #print('urllib.error.HTTPError')
                      self.trigger.emit('无此用户 ')
                      time.sleep(1)#出现错误，停几秒先

        allfinds = p.findall(html)
        #print(allfinds)
        self.trigger.emit(str(allfinds))

        urlBase = "http://blog.csdn.net"#需要将网址合并的部分
        #页面中的网址有重复的，需要使用set进行去重复
        mypages = list(set(allfinds))
        for i in range(len(mypages)):
            mypages[i] = urlBase+mypages[i]

        #print('要刷的网页有：')
        self.trigger.emit('要刷的网页有：')
        for index , page in enumerate(mypages) :
            # print(str(index), page)
            self.trigger.emit(str(index)+ page)

        #所有的页面都刷
        #print('下面开始刷了哦：')
        self.trigger.emit('下面开始刷了哦：')
        for index , page in enumerate(mypages) :
            for j in range(self._brushNum):
                 try :
                      pageContent = opener.open(page).read().decode('utf-8')
                      #使用BeautifulSoup解析每篇博客的标题
                      soup = BeautifulSoup(pageContent)
                      blogTitle = str(soup.title.string)
                      blogTitle = blogTitle[0:blogTitle.find('-')]
                      #print(str(j) , blogTitle)
                      self.trigger.emit(str(j)+" "+ blogTitle)

                 except urllib.error.HTTPError as e:
                      #print('urllib.error.HTTPError')
                      self.trigger.emit('urllib.error.HTTPError ')
                      time.sleep(1)#出现错误，停几秒先

                 except urllib.error.URLError:
                      #print('urllib.error.URLError')
                      self.trigger.emit('urllib.error.URLError')
                      time.sleep(1)#出现错误，停几秒先

                 time.sleep(0.1)#正常停顿，以免服务器拒绝访问




class VpForm(QtWidgets.QMainWindow,Ui_MainForm):
    def __init__(self):
        super(VpForm,self).__init__()
        self.setupUi(self)
        self._worker=[]
        self._form=[]

        self.submitBt.clicked.connect(self.shua)

    #索引增加
    def shua(self):
            thread=WorkThread(self.nameLe.text(),int(self.numLe.text()))
            form=NewForm()
            thread.trigger.connect(form.display)
            form.show()
            thread.start()

            self._worker.append(thread)
            self._form.append(form)




class NewForm(QtWidgets.QWidget,Ui_newForm):
    def __init__(self):
        super(NewForm,self).__init__()
        self.setupUi(self)
    def display(self,m):
        self.displayTb.append(m)

if __name__=="__main__":
    import sys
    app=QtWidgets.QApplication(sys.argv)
    myshow=VpForm()
    myshow.show()
    sys.exit(app.exec_())




完整源码地址http://download.csdn.net/detail/a359680405/9046865   （资源已经被删  -   -）


版权声明：本文为博主原创文章，未经博主允许不得转载。

sqlite3实现中文路径sql文件导入另类解决方法
1.需求
程序要实现产品离线数据下载，故采用java端直接拼接sql文件，客户端下载sql文件，合并到本地数据库。性能还行局域网十几秒7兆多，但是存在一个sqlite或sql文件保存在中文路径下无法合并的问题
2.解决
主要原因是因为sqlite打开数据库时使用utf8打开，qt普遍采用unicode编码。网上方法较多，这里采用另外一种方法解决，采用相对路径避开中文路径的问题
3.代码片段
1.创建数据库
    QString strdbpath(QDir::currentPath() + "/db");
    QDir dir("");
    dir.mkpath(strdbpath);
    strdbpath += "/mysqlite.db";
    QSqlDatabase dbset = QSqlDatabase::addDatabase("QSQLITE", "file");
    dbset.setDatabaseName(strdbpath);
    if (!dbset.open()) {
        LOG_ALL_ERROR(QStringLiteral("failed open mysqlite.db"));
        return bret;
    }
2.合并sql文件到本地数据库
std::string strstdcmd("sqlite3.exe ./db/mysqlite.db \".read ./db/mysqlite.sql\"");
    QProcess process;
    process.start(strstdcmd.c_str());
    process.waitForFinished();
    String strsqlpath(QDir::currentPath() + "/db/mysqlite.sql");
    QFile::remove(strsqlpath);
3.下载sql文件部分略用libcurl很容易也很快下载文件
4.备注
1.代码在win7+vs2010+qt5.40+libcurl 7.36.0下编译通过
2.编译或直接下载sqlite3.exe在生成目录和源码目录分别存放一份
3.常识currentPath在编译时是指源码目录，直接运行exe指exe所在目录

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

栈的压入、弹出序列

栈的压入、弹出序列
题目描述：

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。

输入：
每个测试案例包括3行：
第一行为1个整数n(1<=n<=100000)，表示序列的长度。
第二行包含n个整数，表示栈的压入顺序。
第三行包含n个整数，表示栈的弹出顺序。

输出：
对应每个测试案例，如果第二个序列是第一个序列的弹出序列输出Yes，否则输出No。


样例输入：
5
1 2 3 4 5
4 5 3 2 1
5
1 2 3 4 5
4 3 5 1 2

样例输出：
Yes
No



解题分析：
如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果下一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有的数字都压入了栈了仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。


代码如下：
#include <iostream>
#include <stack>
using namespace std;
bool isPopSequence(int* pushSeq,int *popSeq,int length){
	if(pushSeq==NULL || popSeq==NULL || length<1)
		return false;
	int ipop=0,jpush=0;
	stack<int> istack;
	while(ipop<length){
		if(istack.empty() || istack.top()!=popSeq[ipop]){ //栈顶元素不等于当前栈顶元素，则遍历压入序列
			while(jpush<length && pushSeq[jpush]!=popSeq[ipop]){
				istack.push(pushSeq[jpush]);
				++jpush;
			}
			if(jpush==length)
				return false;
			else {
				/*istack.push(pushSeq[jpush]);
				++jpush;
				istack.pop();*/ //是等价的
				++jpush;
			}
		}else
			istack.pop();//栈顶元素等于当前弹出序列元素，则直接弹出
		++ipop;//下一个弹出元素
	}//while循环正常结束，则代表是弹出序列
	return true;
}

void TestProgram22(){
	int length=0;
	while(cin>>length){
		int *popSeq=new int[length];
		int *pushSeq=new int[length];
		for(int i=0;i<length;i++)
			cin>>pushSeq[i];
		for(int i=0;i<length;i++)
			cin>>popSeq[i];
		if(isPopSequence(pushSeq,popSeq,length))
			cout<<"Yes"<<endl;
		else
			cout<<"No"<<endl;
	}
}

int main(){
	TestProgram22();
	return 0;
}


所有可能的出栈序列问题及卡塔兰数的应用
参考链接：http://www.cnblogs.com/fxplove/articles/2500898.html






版权声明：本文为博主原创文章，未经博主允许不得转载。

【bzoj2286】【sdoi2011】【消耗战】【虚树+dp】
Description

在一场战争中，战场由n个岛屿和n-1个桥梁组成，保证每两个岛屿间有且仅有一条路径可达。现在，我军已经侦查到敌军的总部在编号为1的岛屿，而且他们已经没有足够多的能源维系战斗，我军胜利在望。已知在其他k个岛屿上有丰富能源，为了防止敌军获取能源，我军的任务是炸毁一些桥梁，使得敌军不能到达任何能源丰富的岛屿。由于不同桥梁的材质和结构不同，所以炸毁不同的桥梁有不同的代价，我军希望在满足目标的同时使得总代价最小。
侦查部门还发现，敌军有一台神秘机器。即使我军切断所有能源之后，他们也可以用那台机器。机器产生的效果不仅仅会修复所有我军炸毁的桥梁，而且会重新随机资源分布（但可以保证的是，资源不会分布到1号岛屿上）。不过侦查部门还发现了这台机器只能够使用m次，所以我们只需要把每次任务完成即可。

Input

第一行一个整数n，代表岛屿数量。
接下来n-1行，每行三个整数u,v,w，代表u号岛屿和v号岛屿由一条代价为c的桥梁直接相连，保证1<=u,v<=n且1<=c<=100000。
第n+1行，一个整数m，代表敌方机器能使用的次数。
接下来m行，每行一个整数ki，代表第i次后，有ki个岛屿资源丰富，接下来k个整数h1,h2,…hk，表示资源丰富岛屿的编号。


Output

输出有m行，分别代表每次任务的最小代价。

Sample Input
10

1 5 13

1 9 6

2 1 19

2 4 8

2 3 91

5 6 8

7 5 4

7 8 31

10 7 9

3

2 10 6

4 5 7 8 3

3 9 4 6


Sample Output

12

32

22

【数据规模和约定】

对于10%的数据，2<=n<=10,1<=m<=5,1<=ki<=n-1

对于20%的数据，2<=n<=100,1<=m<=100,1<=ki<=min(10,n-1)

对于40%的数据，2<=n<=1000,m>=1,sigma(ki)<=500000,1<=ki<=min(15,n-1)

对于100%的数据，2<=n<=250000,m>=1,sigma(ki)<=500000,1<=ki<=n-1

题解：显然每次dp整棵树会超时。因为k总共只有500000.所以保存一下每个点到根的路径上最小的边权，每次构建一棵虚树。在虚树上dp一下即可。
简要提一下构建虚树的方法：首先把点按dfs序从小到大排序。先去掉一些点使的剩下的点中没有点为其他点的lca。然后维护一个单调栈。栈里存的始终是一条链。。每次用还未加入的点和该点与栈顶元素的lca更新一下即可。。
代码：#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#define N 250010
using namespace std;
int point[N],u,v,w,point2[N],next[2*N],next2[2*N],deep[N],n,m,k,h[N],st[N],cnt,cnt2,top,t;
int f[N][22],ma[N],temp,ff;
long long r[N],d[N];
struct use{int st,en,w;}e[N*2];
struct use2{int st,en;}b[N*2];
bool cmp(int a,int b) {return ma[a]<ma[b];}
void add(int x,int y,int v){next[++cnt]=point[x];point[x]=cnt;e[cnt].st=x;e[cnt].en=y;e[cnt].w=v;}
void add2(int x,int y)
{
  if (x==y) return;
  next2[++cnt2]=point2[x];point2[x]=cnt2;
  b[cnt2].st=x;b[cnt2].en=y;
}
void dfs(int x,int fa)
{
   ma[x]=++ma[0];
   for (int i=1;i<=20;i++) if ((1<<i)>deep[x]) break;else f[x][i]=f[f[x][i-1]][i-1];
   for (int i=point[x];i;i=next[i])
    if (e[i].en!=fa)
       {
       	 deep[e[i].en]=deep[x]+1;
         f[e[i].en][0]=x;r[e[i].en]=min(r[x],(long long)e[i].w);
         dfs(e[i].en,x);
	   }
}
int lca(int x,int y)
{
    if(deep[x]<deep[y])swap(x,y);
    int t=deep[x]-deep[y];
    for(int i=0;(1<<i)<=t;i++) if(t&(1<<i))x=f[x][i];
    for(int i=20;i>=0;i--)if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    if(x==y)return x;
    return f[x][0];
}
void dp(int x)
{
	d[x]=r[x];
	long long temp(0);
	for (int i=point2[x];i;i=next2[i])
	 {
	 	dp(b[i].en);
	 	temp+=d[b[i].en];
	 }
	 point2[x]=0;
	if (temp==0) d[x]=r[x];
	else d[x]=min(d[x],temp);
}
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n-1;i++) {scanf("%d%d%d",&u,&v,&w);add(u,v,w);add(v,u,w);}
	r[1]=(long long)9999999999999;dfs(1,0);
	scanf("%d",&m);
	for (int p=1;p<=m;p++)
	{
	  cnt2=0;
	  scanf("%d",&k);
	  for (int i=1;i<=k;i++)scanf("%d",&h[i]);
	  sort(h+1,h+k+1,cmp);
      int t=0;h[++t]=h[1];
      for(int i=2;i<=k;i++) if(lca(h[t],h[i])!=h[t])h[++t]=h[i];
      st[++top]=1;
      for(int i=1;i<=t;i++)
       {
        int temp=h[i],ff=lca(temp,st[top]);
        while(1)
        {
            if(deep[ff]>=deep[st[top-1]])
            {
                add2(ff,st[top--]);
                if(st[top]!=ff)st[++top]=ff;break;
            }
            add2(st[top-1],st[top]);top--;
        }
        if(st[top]!=temp)st[++top]=temp;
       }
      while(--top)add2(st[top],st[top+1]);
      dp(1);
      printf("%lld\n",d[1]);
	}  
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Codevs3162抄书问题题解
题目

题目来源


http://codevs.cn/problem/3162/


题目描述 Description 
现在要把M本有顺序的书分给K个人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本数给同一个人抄写。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。
输入描述 Input Description 
第一行两个整数M、K；（K<=M<=100） 
第二行M个整数，第i个整数表示第i本书的页数。
输出描述 Output Description 
共K行，每行两个正整数，第i行表示第i个人抄写的书的起始编号和终止编号。K行的起始编号应该从小到大排列，如果有多解，则尽可能让前面的人少抄写。
样例输入 Sample Input 
9 3 
1 2 3 4 5 6 7 8 9
样例输出 Sample Output 
1 5 
6 7 
8 9

题解

自己对划分型DP一点感觉都没有，一开始把阶段和状态弄反了。。。竟然还能过6个点。。。
把书的页数a[i]预处理出来一个前缀和数组w[i]；
以人数为阶段，书数为状态，i个人j本书的状态是由i-1个人p本书的状态转移过来： 
f[i][j]=minj−1p=1{max{f[i−1][p],w[i]−w[p]}}f[i][j]=\min_{p=1}^{j-1}\{\max\{f[i-1][p],w[i]-w[p]\}\}； 
初始化f[1][i]=w[i]。
输出方案时，要求前面的人抄的页数少，那就让后面的人抄的页数多，边递归边贪心，只要让当前的人抄的页数不大于f[k][m]即可。

Code
#include <cstdio>
#include <algorithm>
#include <cstring>
#define N 105
using namespace std;
int m, k, f[N][N], w[N], a[N];
void getans(int x, int y)
{
    if(y == 0) return;
    if(y == 1)
    {
        printf("1 %d\n", x);
        return;
    }
    int t = x;
    for(int i = a[x]; i + a[t - 1] <= f[k][m]; --t) i += a[t - 1];
    getans(t - 1, y - 1);
    printf("%d %d\n", t, x);
}
int main()
{
    memset(f, 0x3f, sizeof(f));
    scanf("%d%d", &m, &k);
    for(int i = 1; i <= m; ++i)
    {
        scanf("%d", &a[i]);
        f[1][i] = w[i] = a[i] + w[i - 1];
    }
    for(int i = 2; i <= k; ++i) for(int j = 1; j <= m; ++j)
    {
        for(int p = 1; p < j; ++p)
        {
            if(f[i][j] > max(f[i - 1][p], w[j] - w[p]))
            {
                f[i][j] = max(f[i - 1][p], w[j] - w[p]);
            }
        }
    }
    getans(m, k);
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

坐标移动
import java.util.Scanner;


public class CoordinateMove {
	/**
	  * @坐标移动  
	  * 开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串
	  * 里面读取一些坐标，并将最终输入结果输出到输出文件里面。  * 
	  */
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String str = sc.nextLine();
		String []sArr = str.split(";");
		int x=0;
		int y=0;
		for (int i = 0; i < sArr.length; i++) {
			if(sArr[i].matches("[AWSD]{1}[0-9]+")){
				char c = sArr[i].charAt(0);
				String val = sArr[i].substring(1, sArr[i].length());
				int value = Integer.parseInt(val);
				switch (c) {
				case 'A':
					x-=value;
					break;
				case 'W':
					y+=value;
					break;
				case 'S':
					y-=value;
					break;
				case 'D':
					x+=value;
					break;

				default:
					break;
				}
			}
		}
		System.out.println(x+","+y);
	}

}


版权声明：本文为博主原创文章，未经博主允许不得转载。

poj 2002 Squares （hash 拉链 点集）
这是我们理工内部培训册上的一个例题。题目就是给出一组点，问这些点能组成多少个正方形。直接方法便是枚举任意两点，然后根据数学推出另外两点，然后判断这两点是否在点的集合内。立方阶复杂度。 但是可以利用hash来存储各点，hash的目的本来就是实现快速查找，并节省空间。这样的话我们在查找的时候就O1了。求另外两点很好求，但是注意有重复统计。
我这里给出两种形式的hash解决方案：



Squares




Time Limit: 3500MS
 
Memory Limit: 65536K


Total Submissions: 17694
 
Accepted: 6753




Description
A square is a 4-sided polygon whose sides have equal length and adjacent sides form 90-degree angles. It is also a polygon such that rotating about its centre by 90 degrees gives the same polygon. It is not the only polygon with
 the latter property, however, as a regular octagon also has this property. 

So we all know what a square looks like, but can we find all possible squares that can be formed from a set of stars in a night sky? To make the problem easier, we will assume that the night sky is a 2-dimensional plane, and each star is specified by its x
 and y coordinates. 

Input
The input consists of a number of test cases. Each test case starts with the integer n (1 <= n <= 1000) indicating the number of points to follow. Each of the next n lines specify the x and y coordinates (two integers) of each
 point. You may assume that the points are distinct and the magnitudes of the coordinates are less than 20000. The input is terminated when n = 0.
Output
For each test case, print on a line the number of squares one can form from the given stars.
Sample Input
4
1 0
0 1
1 1
0 0
9
0 0
1 0
2 0
0 2
1 2
2 2
0 1
1 1
2 1
4
-2 5
3 7
0 0
5 2
0

Sample Output
1
6
1

Source
Rocky Mountain 2004

AC：
/*=============================================================================
#
#      Author: liangshu - cbam 
#
#      QQ : 756029571 
#
#      School : 哈尔滨理工大学 
#
#      Last modified: 2015-08-26 18:28
#
#     Filename: E.cpp
#
#     Description: 
#        The people who are crazy enough to think they can change the world, are the ones who do ! 
=============================================================================*/
#
#include<iostream>    
#include<sstream>    
#include<algorithm>    
#include<cstdio>    
#include<string.h>    
#include<cctype>    
#include<string>    
#include<cmath>    
#include<vector>    
#include<stack>    
#include<queue>    
#include<map>    
#include<set>    
using namespace std;
const int M = 1007;
int a, b;
struct Point{
    int x, y;
    Point *next;
}p[1023];
Point *pnd[1034];

struct Node{
    int x, y;
    bool friend operator < (Node a, Node b){
        if(a.x != b.x)
            return a.x < b.x;
        return a.y < b.y;
    }
}cnt[1023];
bool hash_search(int x,int a, int b){
   Point *pt = pnd[x];
 //  c//out<<"x = "<<x<<"a = "<<a<<" b = "<<b<<endl;
   while(pt){
       if(pt -> x == a && pt -> y == b){
           return true;break;
       }
       pt = pt -> next;
   }
   return false;
}

int main(){
    int n,n_p = 0;
    while (scanf("%d", &n) != EOF && n){
        n_p = 0;
        memset(pnd, 0, sizeof(pnd));
        for(int i = 0; i < n ; i++){
            scanf("%d%d",&a, &b);
            cnt[i].x = a;cnt[i].y = b;
            int key = abs(a + b) % M;
            if(!hash_search(key, a, b)){
                p[n_p].x = a;
                p[n_p].y = b;//cout<<"a = "<<a<<" b = "<<b<<endl;
                p[n_p].next = pnd[key];
                pnd[key] = &p[n_p];
                n_p++;
            }
        }
        /*for(int i = 0; i < n; i++){
            Point *it = pnd[i];
            while(it){
                cout<<it -> x<<" "<<it -> y<<" ";
                it = it -> next;
            }
            cout<<endl;
        }*/
        sort(cnt, cnt + n);
        int ans = 0;
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                int dx = cnt[j].x - cnt[i].x;
                int dy = cnt[j].y - cnt[i].y;
                int x = cnt[i].x - dy;
                int y = cnt[i].y + dx;
                if(hash_search(abs(x + y) % M, x, y)){
                    int x = cnt[j].x - dy;
                    int y = cnt[j].y + dx;
                    if(hash_search(abs(x + y) % M, x, y))
                    ans ++;
                }
            }
        }
        printf("%d\n",ans / 2);

    }
    return 0;
}

AC2：
/*=============================================================================
#
#      Author: liangshu - cbam 
#
#      QQ : 756029571 
#
#      School : 哈尔滨理工大学 
#
#      Last modified: 2015-08-26 18:31
#
#     Filename: B.cpp
#
#     Description: 
#        The people who are crazy enough to think they can change the world, are the ones who do ! 
=============================================================================*/
#


#include<iostream>
#include<sstream>
#include<algorithm>
#include<cstdio>
#include<string.h>
#include<cctype>
#include<string>
#include<cmath>
#include<vector>
#include<stack>
#include<queue>
#include<map>
#include<set>
using namespace std;
const int M = 1031;
struct Point{
    int x, y;
};
Point p[1023];
int n, hash[M + 8], next[1023];

bool cmp(const Point & a, const Point & b){
    if(a.x != b.x)
        return a.x < b.x;
    return a.y < b.y;
}
int hashcode(const Point&tp){
    return abs(tp.x + tp.y ) % M;
}

bool hash_search(const Point &tp){
    int key = hashcode(tp);
    int i = hash[key];
    while(i != -1){
        if(tp.x == p[i].x && tp.y == p[i].y){
            return true ;
        }

            i = next[i];
    }
    
        return false ;
}

void insert_hash(int i){
    int key = hashcode(p[i]);
    next[i] = hash[key];
    hash[key] = i;
}

int main(){
    Point p3, p4;
    int dx, dy, ans;
    while(scanf("%d",&n) != EOF && n){
        memset(hash, -1, sizeof(hash));
        memset(next, -1, sizeof(next));
        for(int i = 0; i < n; i++){
            scanf("%d %d",&p[i].x, &p[i].y);
        }
        ans = 0;
        sort(p, p + n, cmp);
        for(int i = 0; i < n; i++)
            insert_hash(i);
            ans = 0;
            for(int i = 0; i < n; i++){
                for(int j = i + 1; j < n;  j++){
                    int dx = p[j].x - p[i].x;
                    int dy = p[j].y - p[i].y;
                    p3.x = p[i].x + dy;
                    p3.y = p[i].y - dx;
                    if(hash_search(p3))
                    {
                        p4.x = p[j].x + dy;
                        p4.y = p[j].y - dx;
                        if(hash_search(p4))
                            ans ++;
                    }
                }   
            }
        printf("%d\n", ans/2);
    }
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

SPOJ题目687  Repeats（后缀数组+RMQ求重复次数最多的子串的重复次数）
REPEATS - Repeats


no tags 



A string s is called an (k,l)-repeat if s is obtained by concatenating k>=1 times some seed string t with length l>=1. For example, the string
s = abaabaabaaba
is a (4,3)-repeat with t = aba as its seed string. That is, the seed string t is 3 characters long, and the whole string s is obtained by repeating t 4 times.
Write a program for the following task: Your program is given a long string u consisting of characters ‘a’ and/or ‘b’ as input. Your program must find some (k,l)-repeat that occurs as substring within u with k as large as possible.
 For example, the input string
u = babbabaabaabaabab
contains the underlined (4,3)-repeat s starting at position 5. Since u contains no other contiguous substring with more than 4 repeats, your program must output the maximum k.

Input
In the first line of the input contains H- the number of test cases (H <= 20). H test cases follow. First line of each test cases is n - length of the input string (n <= 50000), The next n lines contain the input string, one character
 (either ‘a’ or ‘b’) per line, in order.

Output
For each test cases, you should write exactly one interger k in a line - the repeat count that is maximized.

Example
Input:
1
17
b
a
b
b
a
b
a
a
b
a
a
b
a
a
b
a
b

Output:
4

since a (4, 3)-repeat is found starting at the 5th character of the input string.
ac代码

#include<stdio.h>         
#include<string.h>         
#include<algorithm>         
#include<iostream>        
#define min(a,b) (a>b?b:a)     
#define max(a,b) (a>b?a:b)      
using namespace std;        
char str[53030];      
int sa[53030],Rank[53030],rank2[53030],height[53030],c[53030],*x,*y,s[53030];    
int n;    
void cmp(int n,int sz)    
{    
    int i;    
    memset(c,0,sizeof(c));    
    for(i=0;i<n;i++)    
        c[x[y[i]]]++;    
    for(i=1;i<sz;i++)    
        c[i]+=c[i-1];    
    for(i=n-1;i>=0;i--)    
        sa[--c[x[y[i]]]]=y[i];    
}    
void build_sa(char *s,int n,int sz)    
{    
    x=Rank,y=rank2;    
    int i,j;    
    for(i=0;i<n;i++)    
        x[i]=s[i],y[i]=i;    
    cmp(n,sz);    
    int len;    
    for(len=1;len<n;len<<=1)    
    {    
        int yid=0;    
        for(i=n-len;i<n;i++)    
        {    
            y[yid++]=i;    
        }    
        for(i=0;i<n;i++)    
            if(sa[i]>=len)    
                y[yid++]=sa[i]-len;    
            cmp(n,sz);    
        swap(x,y);    
        x[sa[0]]=yid=0;    
        for(i=1;i<n;i++)    
        {    
            if(y[sa[i-1]]==y[sa[i]]&&sa[i-1]+len<n&&sa[i]+len<n&&y[sa[i-1]+len]==y[sa[i]+len])    
                x[sa[i]]=yid;    
            else    
                x[sa[i]]=++yid;    
        }    
        sz=yid+1;    
        if(sz>=n)    
            break;    
    }    
    for(i=0;i<n;i++)    
        Rank[i]=x[i];    
}    
void getHeight(char *s,int n)    
{    
    int k=0;    
    for(int i=0;i<n;i++)    
    {    
        if(Rank[i]==0)    
            continue;    
        k=max(0,k-1);    
        int j=sa[Rank[i]-1];    
        while(s[i+k]==s[j+k])    
            k++;    
        height[Rank[i]]=k;    
    }    
}  
int minv[53010][20],lg[53030];    
void init_lg()  
{  
    int i;  
    lg[1]=0;  
    for(i=2;i<52020;i++)  
    {  
        lg[i]=lg[i>>1]+1;  
    }  
}  
void init_RMQ(int n)  
{  
    int i,j,k;  
    for(i=1;i<=n;i++)  
    {  
        minv[i][0]=height[i];  
    }  
    for(j=1;j<=lg[n];j++)    
    {    
        for(k=0;k+(1<<j)-1<=n;k++)    
        {    
            minv[k][j]=min(minv[k][j-1],minv[k+(1<<(j-1))][j-1]);     
        }    
    }  
}  
int lcp(int l,int r)  
{  
    l=Rank[l];  
    r=Rank[r];  
    if(l>r)  
        swap(l,r);  
    l++;  
    int k=lg[r-l+1];  
    return min(minv[l][k],minv[r-(1<<k)+1][k]);    
} 
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		int i,j,k;
		for(i=0;i<n;i++)
		{
			scanf("%s",str+i);
		}
		build_sa(str,n+1,128);
		getHeight(str,n);
		init_lg();
		init_RMQ(n);
		int maxn=0;
		for(i=1;i<n;i++)
		{
			for(j=0;j+i<n;j+=i)
			{
				int k=lcp(j,j+i);
				int now=k/i;
				int tj=j-(i-k%i);
				if(tj>=0)
				{
					if(lcp(tj,tj+i)>=i-k%i)
						now++;
				}
				if(now>maxn)
					maxn=now;
			}
		}
		printf("%d\n",maxn+1);
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

赋值位置切换
我常常用到赋值位置切换，比如我在从数据库查询数据的时候，我需要从DataRow赋值给类，但是当我显示数据的时候，我就要用到类赋值给DataRow。我很讨厌做重复的工作，总是错误百出，那我要怎么样改进呢？这也是我写这篇小文章的原因。源代码很简单，除了分享程序之外，我还要分享源程序。
（1）界面设置，增加两个richtextbox和一个按钮，如下图所示：


（2）在按钮上，实现代码

string preText = this.richTextBox1.Text;
            string[] preTextA = preText.Split(new char[] { '\n' });
            string line = string.Empty;
            foreach (string str in preTextA)
            {
                string[] strA = str.Split(new char[] { '=' });

                line = strA[1].Replace(";","") + " = " + strA[0].Trim() + ";\n";

                this.richTextBox2.AppendText(line);
            }

（3）运行结果




（4）资源下载
http://download.csdn.net/detail/panliuwen/9043315



版权声明：本文为博主原创文章，未经博主允许不得转载。

C# SQLserver数据库图片存取
   #region 数据库图片存取
        /// <summary>
        /// <strong><span style="color:#ff0000;">导入图片到数据库</span></strong>
        /// </summary>
        /// <param name="filePath"></param>
        public void Import(string filePath)
        {
            string fileName = filePath.Substring(filePath.LastIndexOf(@"\")+1, filePath.LastIndexOf(".")-filePath.LastIndexOf(@"\")-1); 
            FileStream fileStream = new FileStream(filePath, FileMode.Open);
            byte[] imageBytes = new byte[fileStream.Length];
            BinaryReader binaryReader = new BinaryReader(fileStream);
            imageBytes = binaryReader.ReadBytes(Convert.ToInt32(fileStream.Length));

            SqlConnection sqlConnection = new SqlConnection(@"data source=PANLEE-PC\MSSQLSERVER_2;initial catalog=DBImage;integrated security=true");
            sqlConnection.Open();
            SqlCommand sqlCommand=new SqlCommand();
            sqlCommand.Connection = sqlConnection;
            try
            {
                string sqlCreate = @"Create Table Portraits(
                                   学号 varchar(50),
                                   照片 image,
                                   )";
                sqlCommand.CommandText = sqlCreate;
                sqlCommand.ExecuteNonQuery();
            }
            catch { }

            sqlCommand.CommandText= "insert into Portraits (学号, 照片) values(@ID,@Image)";
            sqlCommand.Parameters.Add("Image", SqlDbType.Image);
            sqlCommand.Parameters.Add("ID", SqlDbType.VarChar);
            sqlCommand.Parameters["ID"].Value = fileName;
            sqlCommand.Parameters["Image"].Value = imageBytes;
            sqlCommand.ExecuteNonQuery();
            sqlConnection.Close();
        }
      
        /// <summary>
        //<strong>/<span style="color:#ff0000;">导出图片</span></strong>
        /// </summary>
        /// <param name="SID"></param>
        /// <returns>bitmap</returns>
        public Bitmap Export(string SID)
        {
            byte[] imagebytes = null;
            SqlConnection sqlConnection = new SqlConnection(@"data source=PANLEE-PC\MSSQLSERVER_2;initial catalog=DBImage;integrated security=true");
            sqlConnection.Open();
            SqlCommand sqlCommand = new SqlCommand("select 照片 from Portraits where 学号=@ID", sqlConnection);
            sqlCommand.Parameters.Add("ID", SqlDbType.VarChar);
            sqlCommand.Parameters["ID"].Value = SID;
            SqlDataReader sqlDataReader = sqlCommand.ExecuteReader();
            while (sqlDataReader.Read())
            {
                imagebytes = (byte[])sqlDataReader.GetValue(0);
            }
            sqlDataReader.Close();
            sqlCommand.Clone();
            sqlConnection.Close();
            MemoryStream ms = new MemoryStream(imagebytes);
            Bitmap bitmap = new Bitmap(ms);
            return bitmap;
        }
        #endregion

版权声明：本文为博主原创文章，未经博主允许不得转载。

设计模型之二策略模式




//strategy model
//策略模式是一种定义一系列算法的方法
#include<iostream>

using namespace std;

//一个抽象的策略类
class Strategy{
public:
	virtual void algorithmInterface()=0;
};

//三种不同策略
class StrategyA:public Strategy{
	void algorithmInterface()
	{
		cout<<"A strategy"<<endl;
	}
};

class StrategyB:public Strategy{
	void algorithmInterface()
	{
		cout<<"B strategy"<<endl;
	}
};

class StrategyC:public Strategy{
	void algorithmInterface()
	{
		cout<<"C strategy"<<endl;
	}
};

//维护一个具体策略，具体策略由用户指定
class StrategyContext{
public:
	StrategyContext(char X)
	{//根据用户需要创建策略类
		switch(X)
		{//这里其实就是一个简单工厂模式，实例化一个具体对象
			case 'A':
				stra=new StrategyA();
				break;
			case 'B':
				stra=new StrategyB();
				break;
			case 'C':
				stra=new StrategyC();
				break;
			default:
				break;
		}
	}
	
	void getResult()
	{//根据选择的策略得出结果
		stra->algorithmInterface();
	}

private:
	Strategy* stra;
	//基类指针，用于指向一个具体的子对象
	//这里曾出现过一个编译问题：如果子类是私有继承或保护继承自基类，则基类指针不能指向子类对象，具体原因不明
};

int main()
{
	//客户端只需要知道一个StrategyContext类就可以，而不需要知道其他策略类
	StrategyContext straContxt('B');
	straContxt.getResult();
	return 0;
}

hdoj 2647 Reward

Reward

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)

Total Submission(s): 5940    Accepted Submission(s): 1827



Problem Description

Dandelion's uncle is a boss of a factory. As the spring festival is coming , he wants to distribute rewards to his workers. Now he has a trouble about how to distribute the rewards.
The workers will compare their rewards ,and some one may have demands of the distributing of rewards ,just like a's reward should more than b's.Dandelion's unclue wants to fulfill all the demands, of course ,he wants to use the least money.Every work's reward
 will be at least 888 , because it's a lucky number.

 


Input

One line with two integers n and m ,stands for the number of works and the number of demands .(n<=10000,m<=20000)
then m lines ,each line contains two integers a and b ,stands for a's reward should be more than b's.

 


Output

For every case ,print the least money dandelion 's uncle needs to distribute .If it's impossible to fulfill all the works' demands ,print -1.

 


Sample Input

2 1
1 2
2 2
1 2
2 1


 


Sample Output

1777
-1本题题意：老板给员工发奖励，员工有不同的要求，例如 1 2 ；说明1 要求奖励比2高；如果 出现 环的情况，则输出-1；没有环则输出老板最少需要多少钱发奖励！所以  1 2情况，则令1的奖励为888，2的奖励为889；代码如下：<pre name="code" class="cpp">#include<stdio.h>
#include<queue>
#include<algorithm>
#include<iostream>
using namespace std;
#include<string.h>
#define  N 11000
#define  INF  0xffff
struct line
{
    int u,v,w;
    int next;
}edge[21000];
int top=0,indegree[N];
int t,n,m,head[N];
void add(int u,int v)
{
    edge[top].v =v;
    edge[top].next =head[u];
    head[u]=top++;
    indegree[v]++;
}
void topo()
{
    int i,j,val=0,x=888,s,v[N],k=0;
     queue<int>Q;
    s=INF;
    for(i=1;i<=n;i++)
     {
         v[i]=888;// 初始化所有人奖励都为888 
         if(indegree[i]==0)//入度为零入队 
         {
             s=i;
            Q.push(i);
         }
     }
     if(s==INF)//当刚开始的没有入度为零的点，输出-1，return  
     {
     printf("-1\n");
     return ;
     }   
     while(!Q.empty() )
     {
         top=Q.front () ;
         Q.pop();
         indegree[top]=-1;
         s=INF;
         val+=v[top];//奖励加起来 
          k++; //标记 入队人数 
         for(i=head[top];i!=-1 ;i=edge[i].next )
         { 
             indegree[edge[i].v ]--;
             if(indegree[edge[i].v ]==0)
             {
                 s=edge[i].v ;
                 Q.push(edge[i].v ); 
             
            }
            v[edge[i].v]=v[top]+1;//与top相连的点奖励加一 
         }
     }
     if(k<n)//判断是否全部入队，即是否有环 
     printf("-1\n");
     else
     {
         printf("%d\n",val);
     }
}
int main()
{
    int i;
        
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        memset(head,-1,sizeof(head));
        memset(indegree,0,sizeof(indegree));
        top=0;
        int a,b;
        while(m--)//反向建边 
        {
            scanf("%d%d",&a,&b);
            add(b,a);
        }
        topo();
    }
}














版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu2602 01背包Bone Collector
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 40316    Accepted Submission(s): 16748


Problem Description
Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …
The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the
 maximum of the total value the bone collector can get ?




 

Input
The first line contain a integer T , the number of cases.
Followed by T cases , each case three lines , the first line contain two integer N , V, (N <= 1000 , V <= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third
 line contain N integers representing the volume of each bone.
 

Output
One integer per line representing the maximum of the total value (this number will be less than 231).
 

Sample Input

1
5 10
1 2 3 4 5
5 4 3 2 1

 

Sample Output

14本人还没有学c++

#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
struct stu {
	int val;
	int cos;
}boy[10010];
//stu ;
//int bag[10010];
int nexty[10010];//如果把所有nexty都改为next提交时出现编译错误，应该是因为next数组在c++里面已经有定义（本人还没有学c++）。
int main()
{
	int n;
	int a,b;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d%d",&a,&b);
		memset(boy,0,sizeof(boy));
	//	memset(bag,0,sizeof(bag));
		memset(nexty,0,sizeof(nexty));
		for(int i=0;i<a;i++)
		   scanf("%d",&boy[i].val);
		for(int j=0;j<a;j++)
		   scanf("%d",&boy[j].cos);
		for(int i=0;i<a;i++)
		{
			for(int j=b;j>=boy[i].cos;j--)
		//	bag[j]=max(bag[j],bag[j-boy[i].cos]+boy[i].val);
			nexty[j]=max(nexty[j],nexty[j-boy[i].cos]+boy[i].val);
		}
		//printf("%d\n",bag[b]);
		printf("%d\n",nexty[b]);
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA 11021 Tribles (概率dp)
题目链接：https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1962



题目大意：一开始有k个什么鬼，每个只能活一天，死前有pi的概率生出i个后代，0 <= i < n，现在问m代后死光的概率


题目分析：首先对于每个这个东西的繁衍都是独立的，所以我们先考虑1只在m代后死光的概率，设dp[i]为在第i代死光的概率则有
dp[i] = p[0] + p[1] * dp[i - 1] + p[2] * dp[i - 1] ^ 2 + ... + p[n - 1] * dp[i - 1] ^ (n - 1)，意思是前一天不生的话直接死光，否则生了i只，这i只在i－1天时必须死光，一只死光的概率是dp[i - 1]，x只死光的概率就是p[x] * dp[i - 1] ^ x，因为独立所以最后答案就是dp[m] ^ k
#include <cstdio>
#include <cstring>
#include <cmath>
int const MAX = 1005;
double p[MAX], dp[MAX];

int main()
{
    int T;
    scanf("%d", &T);
    for(int ca = 1; ca <= T; ca++)
    {
        int n, k, m;
        memset(dp, 0, sizeof(dp));
        scanf("%d %d %d", &n, &k, &m);
        for(int i = 0; i < n; i++)
            scanf("%lf", &p[i]);
        for(int i = 1; i <= m; i++)
            for(int j = 0; j < n; j++)
                dp[i] += p[j] * pow(dp[i - 1], j);
        printf("Case #%d: %.7f\n", ca, pow(dp[m], k));
    }
}








版权声明：本文为博主原创文章，未经博主允许不得转载。

大数+找规律 ACdream1210 Chinese Girls' Amusement
传送门：点击打开链接
题意：对于n个点围成的圈。从一个点出发，顺时针数K个位置，一直进行这个操作直到回到最初的那个点时，恰好把所有的点都访问了一遍，问最大的K(K<=n/2)
思路：很容易就想到了一种方法，找到K<=n/2，且gcd(K,n)=1，有人是用java从n/2向1去枚举的，感觉好暴力，所以当时不敢这样写
后来发现其实是有规律的，从n=3一直算下去，会得到一个这样的序列1 1 2 1 3 3 4 3 5 5 6 5 7 7 8 7 9 9 10 9.....
很明显以4个为一组，一下子就能找到规律。。
然后按照这个规律直接算出答案就行了
#include<map>
#include<set>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<string>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<functional>
#define FIN freopen("input.txt","r",stdin)
#define FOUT freopen("output.txt","w+",stdout)

using namespace std;
typedef long long LL;
typedef pair<int, int> PII;

const int MX = 2500;
const int MAXN = 9999;
const int DLEN = 4;

class Big {
public:
    int a[MX], len;
    Big(const int b = 0) {
        int c, d = b;
        len = 0;
        memset(a, 0, sizeof(a));
        while(d > MAXN) {
            c = d - (d / (MAXN + 1)) * (MAXN + 1);
            d = d / (MAXN + 1);
            a[len++] = c;
        }
        a[len++] = d;
    }
    Big(const char *s) {
        int t, k, index, L, i;
        memset(a, 0, sizeof(a));
        L = strlen(s);
        len = L / DLEN;
        if(L % DLEN) len++;
        index = 0;
        for(i = L - 1; i >= 0; i -= DLEN) {
            t = 0;
            k = i - DLEN + 1;
            if(k < 0) k = 0;
            for(int j = k; j <= i; j++) {
                t = t * 10 + s[j] - '0';
            }
            a[index++] = t;
        }
    }
    Big operator/(const int &b)const {
        Big ret;
        int i, down = 0;
        for(int i = len - 1; i >= 0; i--) {
            ret.a[i] = (a[i] + down * (MAXN + 1)) / b;
            down = a[i] + down * (MAXN + 1) - ret.a[i] * b;
        }
        ret.len = len;
        while(ret.a[ret.len - 1] == 0 && ret.len > 1) ret.len--;
        return ret;
    }
    bool operator>(const Big &T)const {
        int ln;
        if(len > T.len) return true;
        else if(len == T.len) {
            ln = len - 1;
            while(a[ln] == T.a[ln] && ln >= 0) ln--;
            if(ln >= 0 && a[ln] > T.a[ln]) return true;
            else return false;
        } else return false;
    }
    Big operator+(const Big &T)const {
        Big t(*this);
        int i, big;
        big = T.len > len ? T.len : len;
        for(i = 0; i < big; i++) {
            t.a[i] += T.a[i];
            if(t.a[i] > MAXN) {
                t.a[i + 1]++;
                t.a[i] -= MAXN + 1;
            }
        }
        if(t.a[big] != 0) t.len = big + 1;
        else t.len = big;
        return t;
    }
    Big operator-(const Big &T)const {
        int i, j, big;
        bool flag;
        Big t1, t2;
        if(*this > T) {
            t1 = *this;
            t2 = T;
            flag = 0;
        } else {
            t1 = T;
            t2 = *this;
            flag = 1;
        }
        big = t1.len;
        for(i = 0; i < big; i++) {
            if(t1.a[i] < t2.a[i]) {
                j = i + 1;
                while(t1.a[j] == 0) j++;
                t1.a[j--]--;
                while(j > i) t1.a[j--] += MAXN;
                t1.a[i] += MAXN + 1 - t2.a[i];
            } else t1.a[i] -= t2.a[i];
        }
        t1.len = big;
        while(t1.a[t1.len - 1] == 0 && t1.len > 1) {
            t1.len--;
            big--;
        }
        if(flag) t1.a[big - 1] = 0 - t1.a[big - 1];
        return t1;
    }
    int operator%(const int &b)const {
        int i, d = 0;
        for(int i = len - 1; i >= 0; i--) {
            d = ((d * (MAXN + 1)) % b + a[i]) % b;
        }
        return d;
    }
    Big operator*(const Big &T) const {
        Big ret;
        int i, j, up, temp, temp1;
        for(i = 0; i < len; i++) {
            up = 0;
            for(j = 0; j < T.len; j++) {
                temp = a[i] * T.a[j] + ret.a[i + j] + up;
                if(temp > MAXN) {
                    temp1 = temp - temp / (MAXN + 1) * (MAXN + 1);
                    up = temp / (MAXN + 1);
                    ret.a[i + j] = temp1;
                } else {
                    up = 0;
                    ret.a[i + j] = temp;
                }
            }
            if(up != 0) {
                ret.a[i + j] = up;
            }
        }
        ret.len = i + j;
        while(ret.a[ret.len - 1] == 0 && ret.len > 1) ret.len--;
        return ret;
    }
    void print() {
        printf("%d", a[len - 1]);
        for(int i = len - 2; i >= 0; i--) printf("%04d", a[i]);
    }
};

int main() {
    char word[MX];
    while(~scanf("%s", word)) {
        Big n(word);
        Big a = (n - 3) / 4 + 1;
        Big b = a * 2 - 1;
        Big c = n - a * 4 + 2;
        if(c.a[0] == 3) (b + 1).print();
        else b.print();
        printf("\n");
    }
    return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ 2142-The Balance(扩展欧几里德)
题目地址：POJ 2142 
题意：有两种类型的砝码质量分别为a和b，要求称出质量为d的物品，要求a的数量x和b的数量y的和x+y最小，若有多个x+y的值，取ax+by最小的。 
思路：我们应该求ax+by=d。这里我们应用扩展欧几里德求出ax+by=gcd(a,b)，那么ax/gcd(a,b)+by/gcd(a,b)=1,然后求出来特解，令x=x*n，把x转化为最小正值，即x=(x%b+b)%b，求出此时的y=(d-ax)/b，若求出的y是负值，把y变成正的，因为砝码的位置涉及左右之分。同理求出y为最小正值是x的解，然后比较两组的值就好了。。
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <bitset>
#pragma comment(linker, "/STACK:102400000,102400000")
using namespace std;
typedef __int64 LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
using namespace std;
int gcd(int a,int b)
{
    while(b!=0){
        int r=b;
        b=a%b;
        a=r;
    }
    return a;
}
void exgcd(int a,int b,int &x,int &y)
{
    if(b==0){
        x=1,y=0;
        return ;
    }
    exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-(a/b)*y;
}
int main()
{
    int a,b,d;
    int x,y;
    int xx,yy;
    int tx,ty;
    while(~scanf("%d %d %d",&a,&b,&d)){
        if(!a&&!b&&!d) break;
        int G=gcd(a,b);
        a/=G;
        b/=G;
        d/=G;
        exgcd(a,b,x,y);
        xx=x*d;
        xx=(xx%b+b)%b;
        yy=(d-a*xx)/b;
        if(yy<0) yy=-yy;
        ty=y*d;
        ty=(ty%a+a)%a;
        tx=(d-b*ty)/a;
        if(tx<0) tx=-tx;
        if(tx+ty>xx+yy){
            tx=xx;
            ty=yy;
        }
        printf("%d %d\n",tx,ty);
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

JAVA问题总结之7--Pow、sin、sqrt、abs等常用数学函数调用
JAVA问题总结之7--Pow、sin、sqrt、abs等常用数学函数调用


常用的使用方法：
Math.sin(0)		//返回0.0，这是double类型的值
Math.cos(0)		//返回1.0 
Math.tan(0.5)		//返回0.5463024898437905 
Math.round(6.6)		//返回7 
Math.round(6.3)		//返回6 
Math.ceil(9.2)		//返回10 .0
Math.ceil(-9.8)		//返回-9 .0
Math.floor(9.2)		//返回9 .0
Math.floor(-9.8)		//返回-10 .0
Math.sqrt(144)		//返回12.0 
Math.pow(5,2)		//返回25.0 
Math.exp(2)		//返回7.38905609893065 
Math.log(7.38905609893065)	//返回2.0 
Math.max(560, 289)	//返回560 
Math.min(560, 289)		//返回289 
Math.random()		//返回0.0到1.0之间双精度的一个随机数值

实践代码：
package p1;
public class test6 {
   public static void main(String[] args){
    System.out.println(Math.pow(10,155));
    System.out.println(Math.sin(1));
    System.out.println(Math.sin(Math.PI/4));
    System.out.println(Math.abs(-90));
    System.out.println(Math.sqrt(144));
    for (int i=1;i<=20;i++){
    	 System.out.println(i+":"+Math.random());    	
    }
   }
}

结果：
1.0E155
0.8414709848078965
0.7071067811865475
90
12.0
1:0.05260267431982091
2:0.6339033998766357
3:0.49012139821926204
4:0.6766536495850571
5:0.45268037837432784
6:0.3684743794849339
7:0.08980638896408366
8:0.7523227712481388
9:0.23355417326001215
10:0.41579450277636454
11:0.9330214794750951
12:0.10476091028343881
13:0.5372910349869016
14:0.4883949657729365
15:0.5738547396220067
16:0.9779399544828125
17:0.6946646075636851
18:0.3644623715046946
19:0.5593707918301456
20:0.15426893317772905

其他使用类推。

版权声明：本文为博主原创文章，未经博主允许不得转载。

ACMer
是时候静下心来总结总结了。
为什么总是菜的，就不能牛逼一点吗？！
还是刷的少，刷到1K在说话！

版权声明：本文为博主原创文章，未经博主允许不得转载。

【并查集】hdu 1856 More is better
【并查集】hdu 1856 More is better
n个元素的集合应用问题——并查集。
题目大意
n个元素，告诉它们的两两连接关系，求单个连通分支所含元素个数的最大值
 


说一下思路
经典的并查集求的是所含连通分支的个数，这道题求的是并查集森林最大点集数（元素数），思路是维护一个cnt[ ]数组，初始化元素所在集合为自身cnt[ ] = 1;当要合并时,父节点累加孩子节点，cnt[ y ] += cnt [ x ]，最后输出最大值。
★这题没有离散化就过了，so big the memory is !~


参考代码
#include<bits/stdc++.h>
using namespace std;

const int _max = 1e7 + 10;
int n,a,b,pre[_max],cnt[_max],m;

void init(){
 for(int i = 1;i <= _max;++ i){
    pre[i] = i;//每个元素所在的森林初始化自身
    cnt[i] = 1;//自身点数为1
 }
}

int find(int x){//查，元素x的根节点
  return pre[x] == x?x:pre[x] = find(pre[x]);
}

void join(int a,int b){
  int x = find(a),y = find(b);
  if(x != y) {//根节点不属于同一片森林
    pre[x] = y;
    cnt[y] += cnt[x];//y作父亲节点！！！
  }
}

int main(){
  #ifndef ONLINE_JUDGE
  freopen("input.txt","r",stdin);
  #endif // ONLINE_JUDGE
  while(scanf("%d",&n) == 1){
    if(n == 0) {puts("1");continue;}//特判n == 0的情况
    init();
    m = 0;
    for(int i = 0;i < n; ++ i){
        scanf("%d%d",&a,&b);
        join(a,b);
        if(a > b) m = max(m,a);//找到最大的那个节点
        else m = max(m,b);
    }
    printf("%d\n",*max_element(cnt+1,cnt+1+m));
  }
  return 0;
}


加粗    Ctrl + B 
斜体    Ctrl + I 
引用    Ctrl + Q
插入链接    Ctrl + L
插入代码    Ctrl + K
插入图片    Ctrl + G
提升标题    Ctrl + H
有序列表    Ctrl + O
无序列表    Ctrl + U
横线    Ctrl + R
撤销    Ctrl + Z
重做    Ctrl + Y


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 1083Courses(最大匹配)

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<set>
#include<map>
#include<string>
#include<cstring>
#include<stack>
#include<queue>
#include<vector>
#include<cstdlib>
#define lson (rt<<1),L,M
#define rson (rt<<1|1),M+1,R
#define M ((L+R)>>1)
#define cl(a,b) memset(a,b,sizeof(a));
#define LL long long
#define P pair<int,int>
#define X first
#define Y second
#define pb push_back
#define fread(zcc)  freopen(zcc,"r",stdin)
#define fwrite(zcc) freopen(zcc,"w",stdout)
using namespace std;
const int maxn=505;
const int inf=999999;


vector<int> G[maxn];
int matching[maxn];
bool vis[maxn];
int Nx;
bool dfs(int u){
    int N=G[u].size();
    for(int i=0;i<N;i++){
        int v=G[u][i];
        if(vis[v])continue;
        vis[v]=true;
        if(matching[v]==-1||dfs(matching[v])){
            matching[v]=u;
            return true;
        }
    }
    return false;
}
int hungar(){
    int ans=0;
    cl(matching,-1);
    for(int i=0;i<Nx;i++){
        cl(vis,false);
        if(dfs(i))ans++;
    }
    return ans;
}

int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        int n,m;
        scanf("%d%d",&n,&m);
        for(int i=0;i<maxn;i++)G[i].clear();
        for(int i=0;i<n;i++){
            int t;scanf("%d",&t);
            while(t--){
                int v;scanf("%d",&v);
                v--;
                G[i].pb(v);
            }
        }
        Nx=n;
        int ans=hungar();
        //printf("ans = %d\n",ans);
        if(n==ans){
            puts("YES");
        }
        else {
            puts("NO");
        }
    }
    return 0;
}





            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ 1101([POI2007]Zap-满足x<=a&&y<=b&&gcd(x,y)=d的数对个数)


1101: [POI2007]Zap
Time Limit: 10 Sec  Memory Limit: 162 MB
Submit: 1646  Solved: 577
[Submit][Status][Discuss]
Description

FGD正在破解一段密码，他需要回答很多类似的问题：对于给定的整数a,b和d，有多少正整数对x,y，满足x<=a，y<=b，并且gcd(x,y)=d。作为FGD的同学，FGD希望得到你的帮助。

Input

第一行包含一个正整数n，表示一共有n组询问。（1<=n<= 50000）接下来n行，每行表示一个询问，每行三个正整数，分别为a,b,d。（1<=d<=a,b<=50000）

Output

对于每组询问，输出到输出文件zap.out一个正整数，表示满足条件的整数对数。

Sample Input

2
4 5 2
6 4 3
Sample Output

3
2
HINT


对于第一组询问，满足条件的整数对有(2,2)，（2,4），（4，2）。对于第二组询问，满足条件的整数对有（6,3），（3,3）。


Source







本题为mobius反演：
PS:计算过程不能用long long 不然TLE
公式推导
这部分让我们看看PoPoQQQ的PPT《莫比乌斯反演》
































#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<functional>
#include<iostream>
#include<cmath>
using namespace std;
#define For(i,n) for(int i=1;i<=n;i++)
#define Fork(i,k,n) for(int i=k;i<=n;i++)
#define MEM(a) memset(a,0,sizeof(a));
#define MAXN (50000+10) 
typedef long long ll;
int p[MAXN]={0},tot;
bool b[MAXN]={0};
int mu[MAXN]={0},sum[MAXN]={0};

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'&&ch>'9') { if (ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
	return x*f;
}

void make_prime(int n)
{
	tot=0; mu[1]=1;
	Fork(i,2,n)
	{
		if (!b[i]) p[++tot]=i,mu[i]=-1;
		For(j,tot)
		{
			if (i*p[j]>n) break;
			b[i*p[j]]=1;
			if (i%p[j]==0) { mu[i*p[j]]=0; break; }
			mu[i*p[j]]=-mu[i];  
		}
	}
	sum[0]=0;
	For(i,n) sum[i]=sum[i-1]+mu[i];
}
int n,m,d;
int calc() {
	int ans=0;
	
	for(int i=1,last=1;i<=n;i=last+1) {
		last=min(n/(n/i),m/(m/i));
		ans+=(sum[last]-sum[i-1])*(n/i)*(m/i);
		
	}
	printf("%d\n",ans);
	return ans;
}

int main()
{
//	freopen("bzoj1101.in","r",stdin);
	MEM(p) MEM(b) MEM(mu) MEM(sum)
	
	int N = 50000;
	make_prime(N); 
	
	
	int T;T=read();
	while(T--)
	{
		n=read(); m=read(); d=read();  if (n>m) swap(n,m);
		n/=d,m/=d;
		calc();
	}
	
	return 0;
}









版权声明：本文为博主原创文章，未经博主允许不得转载。

nyoj33 蛇形填数



蛇形填数
时间限制：3000 ms  |  内存限制：65535 KB
难度：3





描述在n*n方陈里填入1,2,...,n*n,要求填成蛇形。例如n=4时方陈为：
10 11 12 1
9 16 13 2
8 15 14 3
7 6 5 4


输入直接输入方陈的维数，即n的值。(n<=100)
输出输出结果是蛇形方陈。
样例输入
3

样例输出
7 8 1
6 9 2
5 4 3

来源

算法经典


#include <stdio.h>
#include <string.h>
int main()
{
	int n,i,j,stamp[101][101],num=1;
	memset(stamp,0,sizeof(stamp));
	scanf("%d",&n);
	for(i=0;i<=(n-1)/2;i++)
	{
		for(j=i;j<n;j++)
			if(!stamp[j][n-1-i])
			stamp[j][n-1-i]=num++;
		for(j=n-2-i;j>=0;j--)
			if(!stamp[n-1-i][j])
			stamp[n-1-i][j]=num++;
		for(j=n-2-i;j>=0;j--)
			if(!stamp[j][i])
			stamp[j][i]=num++;
		for(j=i+1;j<n;j++)
			if(!stamp[i][j])
			stamp[i][j]=num++;
	}
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
			printf("%d ",stamp[i][j]);
		printf("\n");
	}
	return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

【原创分享】DT精灵虚拟光驱，APP,NT,LE三大转码完全硬盘版(带免安装+卸载补丁）



 
【硬盘版】精灵虚拟光驱DAEMON
 Tools Lite v4.48.0.0347（带免安装补丁）

下载地址：http://www.bego.cc/file/114953182



以下就是APP,NT和LE完全硬盘版下载

提示一：APP，NT0.87不用安装，只要双击免安装补丁，自动生成所在文件夹的右键启动菜单。
提示二：NT.0.92+0.93和LE不用每次安装卸载都必须重启资源管理器，只要双击免安装补丁，直接就能生成启动菜单。

示图：

备份  备份2
上图LE是简易版安装，和APP,NT相同，只要右键游戏exe主程序直接日本语运行就好。方便简单。
LE完全版不用重启资源管理器直接安装右键菜单。和原来安装相同，有图标，需要去选择2级菜单启动。

1.APP右键启动菜单
2.NT.0.87启动菜单
3.NT 0.92启动菜单
4.LE简易版启动菜单

APP,NT和LE都能同时安装
注：LE简易版还是完全版免安装补丁只支持安装一个版本，安装其他版本请先卸载后再免安装。



【Locale Emulator \Run in Japanese】转码运行。
【硬盘版】AppPatch（带免安装+卸载补丁）
下载地址：http://www.bego.cc/file/114623384

【硬盘版】NTLEA v0.87（带免安装+卸载补丁）
下载地址：http://www.bego.cc/file/114623225
【硬盘版】NTLEA v0.92（带免安装+卸载补丁）
下载地址：http://www.bego.cc/file/114623228
【硬盘版】NTLEA v0.931（带免安装+卸载补丁）
下载地址：http://www.bego.cc/file/114623234

【硬盘版】Locale Emulator v1.0.9.1（带简易版&完全版 免安装补丁+卸载补丁）
下载地址：http://www.bego.cc/file/114680537
【硬盘版】Locale Emulator v1.3.0.0（带简易版&完全版 免安装补丁+卸载补丁）
下载地址：http://www.bego.cc/file/114680540
本人Win7一直在用的版本，比较稳定。不容易出错。
【硬盘版】Locale Emulator v2.0.1.0（带简易版&完全版 免安装补丁+卸载补丁）
下载地址：http://www.bego.cc/file/114680543
当前最新LE版本


至于安装版和其它转码工具图解1都有下载，请自行【Ctrl+F】搜索图解1【转码工具名】
然后下载：http://tieba.baidu.com/p/3702015596


点点博客地址  点点博客备份地址

3.个人论坛地址 4.乐乎地址 
 5.网易博客6.CSDN博客地址 7.QQ空间日志地址8.绯月论坛地址 9.动物饭团扑论坛

10.技术宅论坛

11. WP博客[翻墙可完整查看]  WP博客[无需翻墙] 12.blogger博客[需翻墙]  blogger博客[无需翻墙]


版权声明：本文为博主原创文章，未经博主允许不得转载。

c++运算符重载
C++不允许把下标运算符函数作为外部函数来定义,它只能是非静态的成员函数。
注意操作符重载作为友元函数和成员函数的区别


// person.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

class MyShape {
protected:
	int R_, G_, B_;

	string colorToString() {
		stringstream ss;
		ss << R_ << " " << G_ << " " << B_;
		return ss.str();
	}
public:
	void setColor(int R, int G, int B) {
		R_ = R; G_ = G, B_ = B;
	}
	int getR() {
		return R_;
	}
	int getG() {
		return G_;
	}
	int getB() {
		return B_;
	}
	virtual void Draw() = 0;
	MyShape() {
		R_ = 255; G_ = 255, B_ = 255;
	}
};

class MyCircle : public MyShape{
private:
	int x_, y_, radius_, _size;
	MyCircle*mMyCircle;
public:
	MyCircle(int x, int y, int radius) {
		x_ = x;
		y_ = y;
		radius_ = radius;
		mMyCircle = NULL;
	}
	MyCircle(int size) {
		_size = size;
		mMyCircle = new MyCircle[size];
	}
	MyCircle() {
		x_ = y_ = 200;
		radius_ = 100;
		mMyCircle = NULL;
	}

	MyCircle(MyCircle& aCircle) {
		x_ = aCircle.x_;
		y_ = aCircle.y_;
		radius_ = aCircle.radius_;
		R_ = aCircle.getR();
		G_ = aCircle.getG();
		B_ = aCircle.getB();
		mMyCircle = NULL;
	}
	~MyCircle()
	{
		if (mMyCircle != NULL)
		delete[]mMyCircle;
	}
	void setCenter(int x, int y) {
		x_ = x;
		y_ = y;
	}

	void setRadius(int radius) {
		radius_ = radius;
	}
	int getRadius() {
		return radius_;
	}

	void Draw() {
	}

	//----在此处添加关系运算符  >、<、>=、<=、==、!=  的重载原型声明
	friend bool operator>(const MyCircle &c1, const MyCircle &c2)//声明为友元函数
	{
		return c1.radius_ > c2.radius_;
	}



	bool operator<(const MyCircle &c1)
	{
		return this->radius_ < c1.radius_;
	}
	bool operator>=(const MyCircle &c1)
	{
		return this->radius_ >= c1.radius_;
	}
	bool operator<=(const MyCircle &c1)
	{
		return this->radius_ <= c1.radius_;
	}
	bool operator==(const MyCircle &c1)
	{
		return this->radius_ == c1.radius_;
	}
	bool operator!=(const MyCircle &c1)
	{
		return this->radius_ != c1.radius_;
	}

	MyCircle operator++()
	{
		radius_++;
		return *this;
	}
	MyCircle operator++(int dummy)
	{
		MyCircle temp(*this);
		radius_++;
		return temp;
	}
	MyCircle& operator[](const int &index)//不允许声明为友元函数
	{
		return mMyCircle[index];
	}

};

//----在此处添加关系运算符的重载定义



int _tmain(int argc, _TCHAR* argv[])
{
	int r1, r2, r3 = 0;
	cin >> r1 >> r2 >> r3;
	MyCircle c1, c2, c3;
	c1.setRadius(r1);
	c2.setRadius(r2);
	c3.setRadius(r3);
	if (c1 > c2)
		cout << 1 << endl;
	if (c2 < c1)
		cout << 5 << endl;

	MyCircle aa(4);
	for (int i = 0; i < 4; i++)
	{
		aa[i] = MyCircle(1, 2, i + 1);
		cout << aa[i].getRadius();
	}
	system("pause");
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

PHPExcel导出mysql数据库数据
使用PHPExcel导出文件


首先看看上面的文章，写入方法一样，只是中间多了数据库的操作，后面还有excel浏览器输出。
数据库代码（数据库配置文件自行完成）
<?php
/*db.php*/
	require dirname(__FILE__)."/dbconfig.php";

	class db{
		public $conn = null;

		public function __construct($config){
			$this->conn=mysql_connect($config['host'],$config['username'],$config['password']) or die(mysql_error());
			mysql_select_db($config['database'],$this->conn) or die(mysql_error());
			mysql_query("set names ".$config['charset']) or die(mysql_error());
		}

		public function getResult($sql){
			$resource = mysql_query($sql,$this->conn) or die(mysql_error());
			$res = array();
			while(($row=mysql_fetch_assoc($resource))!=false){
				$res[] = $row;
			}
			return $res;
		}

		public function getUserinfo(){
			$sql = "。。。";
			$res = self::getResult($sql);
			return $res;
		}
	}


数据库导出代码：
<?php
	$dir = dirname(__FILE__);
	require $dir."/db.php";
	require $dir."/PHPExcel.php";

	$db = new db($phpexcel);
	$objPHPExcel = new PHPExcel();

	for($i=0; $i<3; $i++){
		if($i>0){
			$objPHPExcel->createSheet();
		}
		$objPHPExcel->setActiveSheetIndex($i);
		$objSheet = $objPHPExcel->getActiveSheet();
		$data = $db->getUserinfo();

		$objSheet->setCellValue("A1","编号")->setCellValue("B1","登陆名")
				->setCellValue("C1","昵称")->setCellValue("D1","电子邮箱")
				->setCellValue("E1","学校")->setCellValue("F1","最后登陆时间");

		$j = 2;
		foreach ($data as $key => $value) {
			# code...
			$objSheet->setCellValue("A".$j,$value['id'])->setCellValue("B".$j,$value['user_login'])
					->setCellValue("C".$j,$value['user_nicename'])->setCellValue("D".$j,$value['user_email'])
					->setCellValue("E".$j,$value['sch_name'])->setCellValue("F".$j,$value['last_login_time']);
			$j++;
		}
	}

	$objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel,"Excel5");
	// $objWriter->save($dir.'/export.xls'); //生成excel文件
	browser_export("Excel5","browser_excel03.xls"); //浏览器输出
	$objWriter->save("php://output");

	function browser_export($type, $filename){
		if($type == "Excel5"){
			header('Content-Type: application/vnd.ms-excel'); //excel2003
		}else{
			header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); //excel2007
		}
		header('Content-Disposition: attachment;filename="'.$filename.'"');
		header('Cache-Control: max-age=0');
	}
	

	

运行截图：




版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ - 2524 Ubiquitous Religions（简单并查集）

Ubiquitous Religions




Time Limit: 5000MS
 
Memory Limit: 65536KB
 
64bit IO Format: %I64d & %I64u




Submit Status


Description

当今世界有很多不同的宗教,很难通晓他们。你有兴趣找出在你的大学里有多少种不同的宗教信仰。
你知道在你的大学里有n个学生(0 < n <= 50000) 。你无法询问每个学生的宗教信仰。此外,许多学生不想说出他们的信仰。避免这些问题的一个方法是问m(0 <= m <= n(n - 1)/ 2)对学生, 问他们是否信仰相同的宗教( 例如他们可能知道他们两个是否去了相同的教堂) 。在这个数据中,你可能不知道每个人信仰的宗教，但你可以知道校园里最多可能有多少个不同的宗教。假定每个学生最多信仰一个宗教。




Input

有多组数据。对于每组数据：
第一行：两个整数n和m。
以下m行：每行包含两个整数i和j，表示学生i和j信仰相同的宗教。学生编号从1到n。
输入的最后一行中,n = m = 0。




Output

对于每组测试数据，输出一行，输出数据序号( 从1开始) 和大学里不同宗教的最大数量。（参见样例）



Sample Input

10 9
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
10 4
2 3
4 5
4 8
5 8
0 0





Sample Output

Case 1: 1
Case 2: 7





Hint

输入巨大,推荐使用scanf。



简单并查集，求无向图连通分量。



#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

const int MAXN = 50000 + 50;
int parent[MAXN];

int n, m;

void make_set()
{
	for (int i = 0; i <= n; i++)
		parent[i] = -1;
}

int find_set(int t)
{
	if (parent[t] == -1)
		return t;
	else
		return parent[t] = find_set(parent[t]);
}

void union_set(int a, int b)
{
	int t1 = find_set(a);
	int t2 = find_set(b);
	if (t1 != t2)
		parent[t2] = t1;
}

int main()
{
	int casen;
	casen = 1;
	while (scanf("%d%d", &n, &m) != EOF&&n)
	{
		int a, b;
		make_set();
		for (int i = 0; i < m; i++)
		{
			scanf("%d%d", &a, &b);
			union_set(a, b);
		}
		int sum = 0;
		for (int i = 1; i <= n; i++)
		{
			if (parent[i] == -1)
				sum++;
		}
		printf("Case %d: ", casen);
		casen++;
		printf("%d\n", sum);
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

A - B

时间限制: 1 Sec  内存限制:
128 MB
提交: 80  解决: 31
[提交][状态][讨论版]
题目描述

做惯了A+B的我们，要不要来点新鲜的？那么来个A-B吧？

输入

第一行输入一个N，代表有N组测试数据，
接下来N行，每行输入两个整数A和B，注意是：整数、整数、整数，重要的话一定要说三遍！
（题目保证A和B均在int型内！）

输出

输入N行，每行输入A-B的值！

样例输入

3
2 1
1 2
3 0

样例输出

1
-1
3



刚开始没有考虑到是long long型；


#include<stdio.h> 
int main() 
{ 
    int  n,m; 
    scanf("%d",&n); 
    while(n--) 
    { 
        long long a,b; 
        scanf("%lld%lld",&a,&b); 
        printf("%lld\n",a-b); 
    } 
    return 0; 
} 
/************************************************************** 
    Problem: 1708 
    Language: C 
    Result: 正确 
    Time:0 ms 
    Memory:768 kb 
****************************************************************/




版权声明：本文为博主原创文章，未经博主允许不得转载。

《Java实战开发经典》第五章5.6
package five; 
//第五章练习6 
public class Six { 
public static void main(String[] args) { 
    String str1=”Java技术学习班20070326”; 
    System.out.println(str1.substring(9)); 
    String str2=”MLDN JAVA”; 
    System.out.println(str2.replaceAll(“JAVA”, “J2EE”)); 
    System.out.println(str1.charAt(7)); 
    System.out.println(str1.replaceAll(“0”, “”)); 
    String str3=”    Java技术学习班 20070326 MLDN   老师      “; 
    System.out.println(str3);                           //原样输出 
    System.out.println(str3.trim());                    //使用trim()方法，去除且只能去除字符串两端的空格 
    System.out.println(str3.replaceAll(” “, “”));       //使用replaceAll()方法，使用空替换空格，去除整个字符串中的空格 
    String str4=”100273199210014080”; 
    System.out.println(str4.substring(6, 14)); 
} 
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

巧妙使用static 为数据打包并发送
只要做过项目的朋友对关键字static应该都有一些了解，但未见了解很全面的。在C语言中，关键字static有以下明显的作用：1.static变量分配到静态内存中，这一点和全局非静态变量相同。
2.在函数体，static变量只要不进行修改操作，在被调用过程中其值将保持不变。
3.在模块内，全局static变量可以被模块内所有函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量，具有私有特点。
4.在模块内，一个static函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用，也具有私有特点。
   如果我们能够很好地利用static的这些特性，书写高内聚低耦合，更具模块化的代码就不会显得象句口号；如果不能很好地理解和使用它，一切都只是空谈。下面来举个例子来说明static在实际应用可能会遇到问题。
　　如果要求实现下面的接口：为每个大小约1600字节的音视频裸数据(audio/video)添加包头(packet header)，然后将打过包头的整个数据包发送到网络。打过包头的数据包格式如下:
                     <------packet----->
                     ｜ header ｜ data ｜
 
　　我想有人可能会这么做：
 
#define MAX_PACKET_SIZE 1600
 
typedef struct _header
{
  bool type;　　/*数据包类型*/
  bool length;　/*数据包类型*/
　...
}header;
 
bool send(bool type,uint8*data,uint32 length)
{
  uint8 packet[MAX_PACKET_SIZE+sizeof(header)]={0};/*定义数组*/
  header* pheader=(header*)packet;
 
  if(NULL==data || length<1)
  {
    return FALSE;
  }
 
　/*设置包头*/
  pheader->type=type;
  pheader->length=length;
 
  pheader++;
  memcpy((uint8*)pheader,data,length);/*拷贝数据到包头之后*/
  netSend(packet);/*将包发送到网络*/
  return TRUE;
}
　　
　　对于上面的代码，有人可能会有这样的疑虑,发送数据包到网络是一个非常频繁的操作，所以在send函数中，频繁地为packet分配栈内存是一种低效的做法。他可能会将上的代码修改为：
bool send(bool type,uint8*data,uint32 length)
{
  uint8* packet=NULL;
  header* pheader=NULL;
 
  if(NULL==data || length<1)
  {
    return FALSE;
  }
 
  packet= (uint8*)malloc(length+sizeof(header));
 
  if(NULL==packet)
  {
    return FALSE;
  }
 
  pheader=(header*)packet;
  pheader->type=type;
  pheader->length=length;
  pheader++;
 
  memcpy((uint8*)pheader,data,length);
 
  net_send(packet);/*将包发送到网络*/
 
  free(packet);
  packet=NULL;
 
  return TRUE;
}
 
使用动态内存好象可以解决上面的问题，但它没有考虑到频繁地使用malloc-free会产生大量的内存碎片。在嵌入式系统环境中，一般内存大小有限，所以这种做法最终会导致分配失败。对于处理大流量数据问题，一种比较常用的高效方法就是在函数内部使用静态数组(全局静态数组在这个应用中不建议使用，因为全局变量会增加函数间的耦合度)。嘿嘿，听到这样的建议，估计有人会马上这么改：
bool send(bool type,uint8*data,uint32 length)
{
  static uint8 packet[MAX_PACKET_SIZE+sizeof(header)]={0};
  header* pheader=(header*)packet;
 
  if(NULL==data || length<1)
  {
    return FALSE;
  }
 
  pheader->type=type;
  pheader->length=length;
  pheader++;
 
  memcpy((uint8*)pheader,data,length);
  net_send(packet);/*将包发送到网络*/
  memset(packet,0,sizeof(packet));/*清除本次内存操作*/
 
  return TRUE;
}
 
　　朋友且慢，小心地雷！
 
　　你是否忘了考虑代码可重入(reentrance)问题呢？这里使用packet静态数组的确不用频繁地分配动态或栈内存，但同时引入了代码不可重入的问题。因为函数内的static变量分配在静态内存区，供所有对象共用。在多任务系统中，如果有一个以上的任务同时访问该内存，很可能会出现问题。所以我们必须要用其它手段来消除这个不可重入问题。使用信号量semaphore是一个很好解决不可重入问题的方法。在上面代码中加入信号量:
bool send(bool type,uint8*data,uint32 length)
{
  static uint8 packet[MAX_PACKET_SIZE+sizeof(header)]={0};
  header* pheader=(header*)packet;
 
  if(NULL==data || length<1)
  {
    return FALSE;
  }
 
  semTake(semaphore,WAIT_FOREVER);/*等待信号量*/
 
  pheader->type=type;
  pheader->length=length;
  pheader++;
 
  memcpy((uint8*)pheader,data,length);
  net_send(packet);/*将包发送到网络*/
  memset(packet,0,sizeof(packet));/*清除本次内存操作*/
 
  semGive(semaphore);/*释放信号量*/
 
  return TRUE;
}
 
好，现在终于解决这个问题了。在我们的视频会议系统中，曾经就在将数据发送到网络上
踩过这个地雷，修改这个bug也化了很大功夫
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

简单的client/server模型
所谓client/server简单来说就是客户端服务器模型，简称C/S模型，一个简单的CS模型所用到的只是一些简单的网络方面的知识，下面我以一个面向连接的CS实例来解释面向连接的主要过程： 
首先我们想看一张图，来了解一下服务器端和客户端的链接过程： 
 
首先是服务器端，服务器首先要创建套接字，然后将其绑定到本地端口，之后将其转换为链接套接字，之后就时阻塞等待客户端的连接了。
在这里解释一下端口和IP地址之间的关系：我们都知道IP地址就如同家庭的地址和门牌号，能够找到某人的家，这里就如同找到某台主机是一样的，但是家里的人不止一个，就如同一台主机同时运行的应用程序有好多一样，要将消息准发到特定的应用程序就需要用到端口号，端口号就是该应用程序消息的接口。一般情况下，某个应用程序的端口是特定的，例如：浏览器的端口是80一样。 
那么套接字又是干什么的呢？套接字中保存有客户端课服务器端的IP地址和连接套接字，有了连接套接字就能将信息发出了。
客户端同时也需要建立一个连接套接字，在客户端将IP地址和端口等信息初始化完成之后，就需要将客户端与服务器连接，此时服务器处于阻塞状态等待客户端的连接，当客户端连接成功之后，就会产生一个连接套接字，消息通过连接套接字发送和接收。
上图读取数据和发送数据就是通过send函数和recv函数来实现的。
在服务器和客户端之间一般是发送一些特定的数据包，例如整个结构体数据，我们可以利用memcpy函数将结构体保存在一个字符串数组当中，然后等到在客户端接收之后，再将其还原为一个结构体。
下面是实例的代码： 
客户端：
#include<stdio.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<unistd.h>
#include<string.h>
#include<errno.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include "my_recv.h"

#define INVALID_USERINFO    'n'     //用户信息无效
#define VALID_USERINFO      'y'     //用户信息有效

int get_userinfo(char *buf, int len)                //获取用户输入存入buf，长度len，以'\n'结束
{
    int i;
    int c;

    if(buf == NULL)
    {
        return -1;
    }

    i = 0;
    while(((c = getchar()) != '\n') && (c != EOF) && (i < len - 2))
    {
        buf[i++] = c;
    }
    buf[i++] = '\n';
    buf[i++] = '\0';

    return 0;
}


void input_userinfo(int conn_fd, const char *string)                //输入用户名，然后通过fd发送出去
{
    char input_buf[32];
    char recv_buf[BUFSIZE];
    int  flag_userinfo;

    do
    {                                                             //输入用户信息知道正确为止 
        printf("%s:", string);
        if(get_userinfo(input_buf, 32) < 0)
        {
            printf("error return from get_userinfo\n");
            exit(1);
        }

        if(send(conn_fd, input_buf,strlen(input_buf), 0) < 0)
        {
            my_err("send", __LINE__);
        }

        if(my_recv(conn_fd, recv_buf, sizeof(recv_buf)) < 0)
        {
            printf("data is too long\n");
            exit(1);
        }

        if(recv_buf[0] == VALID_USERINFO)
        {
            flag_userinfo = VALID_USERINFO; 
        }
        else
        {
            printf("%s error, input again,", string);
            flag_userinfo = INVALID_USERINFO;
        }
    }while(flag_userinfo == INVALID_USERINFO);
}

int main(int argc, char ** argv)
{
    int                  i;
    int                  ret;
    int                  conn_fd;
    int                  serv_port;
    struct sockaddr_in   serv_addr;
    char                 recv_buf[BUFSIZE];

    if(argc != 5)                                   //检查参数个数
    {
        printf("usage : [-p] [serv_port] [-a] [serv_address]\n");
        exit(1);
    }

    memset(&serv_addr, 0, sizeof(struct sockaddr_in));        //初始化服务器端地址结构
    serv_addr.sin_family = AF_INET;
    for(i = 1; i < argc; i++)                                   //从命令行获取服务器的端口与地址
    {
        if(strcmp("-p", argv[i]) == 0)
        {
            serv_port = atoi(argv[i+1]);
            if(serv_port < 0 || serv_port > 65535)
            {
                printf("invalid serv_addr.sin_port\n");
                exit(1);
            }
            else 
            {
                serv_addr.sin_port = htons(serv_port);
            }
            continue;
        }
        if(strcmp("-a", argv[i]) == 0)
        {
            if(inet_aton(argv[i+1], &serv_addr.sin_addr) == 0)
            {
                printf("invalid server ip address\n");
                exit(1);
            }
            continue;
        }
    }

    if(serv_addr.sin_port == 0 || serv_addr.sin_addr.s_addr == 0)           //检测是否少输入了某项参数
    {
        printf("usage: [-p] [serv_addr.sin_port] [-a] [serv_address]\n");
        exit(1);
    }

    conn_fd = socket(AF_INET, SOCK_STREAM, 0);                              //创建一个tcp套接字
    if(conn_fd < 0){
        my_err("socket", __LINE__);
    }

    if(connect(conn_fd, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr)) < 0){    //向服务器端发送连接请求
        my_err("connect", __LINE__);
    }

    input_userinfo(conn_fd, "username");                    //输入用户名和密码
    input_userinfo(conn_fd, "password");

    if((ret = my_recv(conn_fd, recv_buf, sizeof(recv_buf))) < 0){   //读取欢迎信息并打印
        printf("data is too long\n");
        exit(1);
    }
    for(i = 0; i < ret; i++){
        printf("%c", recv_buf[i]);
    }
    printf("\n");

    close(conn_fd);
    return 0;

}
服务器端：
#include<stdio.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<unistd.h>
#include<string.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<errno.h>
#include "my_recv.h"
#include<stdlib.h>

#define SERV_PORT       4507        //服务器的端口
#define LISTENQ         12          //连接请求队列的最大长度

#define INVALID_USERINFO    'n'     //用户信息无效
#define VALID_USERINFO      'y'     //用户信息有效

#define USERNAME            0       //接受到的是用户名
#define PASSWORD            1       //接受到的是密码

struct userinfo                     //保存用户名和密码的结构体
{
    char username[32];
    char password[32];
};

struct userinfo users[] = 
{
    {"linux", "unix"},
    {"4507", "4508"},
    {"clh", "clh"},
    {"xl", "xl"},
    {" ", " "}                      //以只含一个空格的字符串作为数组的结束标志
};

int find_name(const char * name)
{
    int  i;

    if(name == NULL)
    {
        printf("in find_name, NULL pointer");
        return -2;
    }
    for(i = 0; users[i].username[0] != ' '; i++)
    {
        if(strcmp(users[i].username, name) == 0)
        {
            return i;
        }
    }
    return -1;
}

void send_data(int conn_fd, const char *string)
{
    if(send(conn_fd, string, strlen(string), 0) < 0)
    {
        my_err("send", __LINE__);   //my_err函数在my_recv.h中声明            
    }
}

int main()
{
    int                  sock_fd, conn_fd;
    int                  optval;
    int                  flag_recv = USERNAME;
    int                  ret;
    int                  name_num;
    pid_t                pid;
    socklen_t            cli_len;
    struct sockaddr_in   cli_addr, serv_addr;
    char                 recv_buf[128];

    sock_fd = socket(AF_INET, SOCK_STREAM, 0);          //创建一个TCP套接字
    if(sock_fd < 0)
    {
        my_err("socket", __LINE__);
    }

    optval = 1;                                         //设置该套接字使之可以重新绑定端口
    if(setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR, (void *)&optval, sizeof(int)) < 0)
    {
        my_err("setsocketopt", __LINE__);
    }

    memset(&serv_addr, 0, sizeof(struct sockaddr_in));   //初始化服务器端地址结构
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(SERV_PORT);
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    if(bind(sock_fd, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr_in)) < 0)                        //将套接字绑定到本地端口
    {
        my_err("bind", __LINE__);
    }

    if(listen(sock_fd, LISTENQ) < 0)                    //将套接字转化为监听套接字
    {
        my_err("listen", __LINE__);
    }

    cli_len = sizeof(struct sockaddr_in);
    while(1)
    {
        conn_fd = accept(sock_fd, (struct sockaddr *)&cli_addr, &cli_len);
        if(conn_fd < 0)
        {
            my_err("accept", __LINE__);
        }

        printf("accept a new client, ip: %s\n", inet_ntoa(cli_addr.sin_addr));
        if((pid = fork()) == 0)                         //创建子进程处理刚刚接收的连接请求
        {
            while(1)                                    //子进程
            {
                if((ret = recv(conn_fd, recv_buf, sizeof(recv_buf), 0)) < 0)
                {
                    perror("recv");
                    exit(1);
                }
                recv_buf[ret - 1] = '\0';               //将数据结束标志'\n'替换成字符串结束标志

                if(flag_recv == USERNAME)               //接收到的是用户名
                {
                    name_num = find_name(recv_buf);
                    switch (name_num)
                    {
                        case -1:
                            send_data(conn_fd, "n\n");
                            break;
                        case -2:
                            exit(1);
                            break;
                        default:
                            send_data(conn_fd, "y\n");
                            flag_recv = PASSWORD;
                            break;
                    }
                }
                else if(flag_recv == PASSWORD)          //接收到的是密码 
                {
                    if (strcmp(users[name_num].password, recv_buf) == 0)
                    {
                        send_data(conn_fd, "y\n");
                        send_data(conn_fd, "welcome login my tcp server\n");
                        printf("%s login \n", users[name_num].username);
                        break;
                    }
                    else 
                    {
                        send_data(conn_fd, "n\n");
                    }
                }
            }
            close(sock_fd);
            close(sock_fd);
            exit(0);                                    //结束子进程            
        }
        else
        {
            close(conn_fd);                             //父进程关闭刚刚接收的连接请求，执行accept等待其他连接请求
        }
    }
    return 0;
}
my_recv.h
#ifndef _MY_RECV_H
#define _MY_RECV_H
    #define BUFSIZE 1024
    void my_err(const char * err_string, int line);
    int my_recv(int conn_fd, char * data_buf, int len);
#endif
这里自定义了一个读取数据的函数，实际就是将套接字缓冲区的数据拷贝到自定义缓冲区（以”\n”为结束标志），然后再按格式将数据读出（效果和上面所说的memcpy函数是一样的）。
在该例中，当收到一个新的客户端的连接请求之后，服务器端就会创建一个新的进程来处理客户端的请求。关于进程创建可以参考进程控制。
在该客户端，首先创建了一个TCP套接字，然后调用函数connect请求与服务器端连接，建立连接之后，通过连接套接字首先发送用户名，然后等待服务器确认，若用户存在，则发送密码，若密码正确，则返回欢迎页面。
下面是可执行文件的链接地址：github
执行本程序时，首先在某一终端运行服务器端程序，然后在另外几个终端运行客户端。在客户端执行时输入如下数据： 
./client -a 127.0.0.1 -p 4507
服务器中默认存在用户，用户名和密码分别是： 
   {“linux”, “unix”},   {“4507”, “4508”},   {“clh”, “clh”},   {“xl”, “xl”}。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

UVA 1664 - Conquer a New Region（并查集）
该题巧妙的运用了并查集，运用了类似于最小生成树算法的过程 ，通过该题可以对并查集有一个更深的理解 。 
由于i和j唯一通路上容量的最小值为该两点的容量，求一个点到其他所有点的容量最大值 。
首先，解决两点的容量问题 ，我们将所有边从大到小排序，然后从大到小枚举，我们假设根结点就是要找的城市中心点，那么当又加入一条边时，该边的两个顶点所在的集合设为A、B，集合A、B的顶点a、b，要让谁当中心点呢？ 易知：无论谁当中心点，它与另一个集合中任一点的容量都为该边长度（因为是从大到小枚举的）。
那么为了求出总容量，我们要维护一些值，用空间换时间 。  维护每个顶点的总容量sum[i]，维护每个顶点与之相连的顶点数量，cnt[i]，当前答案ans 。
那么对于a、b点，如果以a为中心，总容量为sum[a] + cnt[b] * e[i].c 。 反之亦然，哪个量大，则以哪个点为城市中心，也就是并查集的根结点 。
该题的巧妙之处在于，将答案结点维护成并查集的根结点，快速的找出一个集合中的城市中心 。 
并查集用了路径压缩之后其实已经很快了，没有必要在改变树的高度，因为那样会改变根结点，不仅写起来麻烦，还丢掉了许多很好的特性 。 
该题就是通过这些特性，维护一些重要的量以达到快速求解的目的 。 请读者细细品味 。 
细节参见代码：
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 200000 + 5;
int n,m,p[maxn];
ll sum[maxn],cnt[maxn];
struct Edge{
    ll a,b,c;
    bool operator < (const Edge& rhs) const {
        return c > rhs.c;
    }
}e[maxn];
int findd(int x) { return p[x] == x ? x : p[x] = findd(p[x]); }
ll solve() {
    for(int i=1;i<=n;i++) { p[i] = i ; sum[i] = 0 ; cnt[i] = 1; }
    ll ans = 0;
    sort(e,e+n-1);
    for(int i=0;i<n-1;i++) {
        int x = findd(e[i].a) , y = findd(e[i].b);
        ll suma = sum[x]+cnt[y]*e[i].c,sumb = sum[y]+cnt[x]*e[i].c;
        if(suma < sumb) {
            p[x] = y; sum[y] = sumb;
            cnt[y] += cnt[x]; ans = sum[y];
        }
        else {
            p[y] = x; sum[x] = suma;
            cnt[x] += cnt[y]; ans = sum[x];
        }
    }
    return ans;
}
int main() {
    while(~scanf("%d",&n)) {
        for(int i=0;i<n-1;i++) 
            scanf("%lld%lld%lld",&e[i].a,&e[i].b,&e[i].c);
        printf("%lld\n",solve());
    }
    return 0;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

【OJ练习】字符加密解密
//题目描述
//1、对输入的字符串进行加解密，并输出。
//2、加密方法为：
//当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a；
//当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0；
//其他字符不做变化。
//3、解密方法为加密的逆过程。
// 
//接口描述：
//    实现接口，每个接口实现1个基本操作：
//void Encrypt (char aucPassword[], char aucResult[])：在该函数中实现字符串加密并输出
//说明：
//1、字符串以\0结尾。
//2、字符串最长100个字符。
// 
//int unEncrypt (char result[], char password[])：在该函数中实现字符串解密并输出
//说明：
//1、字符串以\0结尾。
//2、字符串最长100个字符。
// 
//知识点	字符串
//运行时间限制	10M
//内存限制	128
//输入	
//输入说明
//输入一串要加密的密码
//输入一串加过密的密码
//输出	
//输出说明
//输出加密后的字符
//输出解密后的字符
//样例输入	abcdefg BCDEFGH
//样例输出	BCDEFGH abcdefg

#include<iostream>
#include <string>

using namespace std;

string Encrypt(string s)
{
	if(s.empty())
		return s;
	//处理后的目标字符串
	int len = s.length();
	string dstS ="";
	for(int a=0;a<len;a++)
	{
		if('A'<=s[a]&&s[a]<='Z')
		{
			if(s[a]=='Z')
			{
				dstS+='a';
			}
			else
			{
				dstS+=s[a]+33;
			}
		}
		else if('a'<=s[a]&&s[a]<='z')
		{
			if(s[a]=='z')
			{
				dstS+='A';
			}
			else
			{
				dstS+=s[a]-31;
			}
		}
		else if('0'<=s[a]&&s[a]<='9')
		{
			if(s[a]=='9')
			{
				dstS+='0';
			}
			else
			{
				dstS+=s[a]+1;
			}
		}
		else dstS+=s[a];
	}
	return dstS;
}

string unEncrypt(string s)
{
	if(s.empty())
		return s;
	//处理后的目标字符串
	int len = s.length();
	string dstS ="";
	for(int a=0;a<len;a++)
	{
		if('A'<=s[a]&&s[a]<='Z')
		{
			if(s[a]=='A')
			{
				dstS+='z';
			}
			else
			{
				dstS+=s[a]+31;
			}
		}
		else if('a'<=s[a]&&s[a]<='z')
		{
			if(s[a]=='a')
			{
				dstS+='Z';
			}
			else
			{
				dstS+=s[a]-33;
			}
		}
		else if('0'<=s[a]&&s[a]<='9')
		{
			if(s[a]=='0')
			{
				dstS+='9';
			}
			else
			{
				dstS+=s[a]-1;
			}
		}
		else dstS+=s[a];
	}
	return dstS;
}

int main()
{
	string s1,s2,s3,s4;
	getline(cin,s1);
	s2 = Encrypt(s1);
	cout<<s2<<endl;

	getline(cin,s3);
	s4 = unEncrypt(s3);
	cout<<s4<<endl;
	return 0;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

UICollectionView___新手遇到的问题:
- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath
 *)indexPath
测试始终不走这个代理方法的原因肯定是因为
<span style="font-size:24px;">UICollectionViewFlowLayout *layout = [[[UICollectionViewFlowLayout alloc]init]autorelease];</span>忽略了Flow



如何解决btn同时显示文字和图片  但是文字在图片下方:比较简单的方法,就是用自定义视图,一个放ImageView  一个放label  然后打开用户交互,给自定义视图添加手势.


这种Bug出现,要有三种考虑,第一数据是否解析错误,如果是数据解析错误,最笨的方法就是在解析数据的时候一层一层打印,也可以直接将Model层的属性单独打印.

第二是否走了自定义CollectionViewCell方法,可以在自定义那块加断点,如果程序没有终止,则肯定是注册的时候写错了Class.  第三懒加载的时候各个控件的名称是否错误.



版权声明：本文为博主原创文章，未经博主允许不得转载。

codeforces 571 B. Minimization

B. Minimization


time limit per test
2 seconds


memory limit per test
256 megabytes


input
standard input


output
standard output



You've got array A, consisting of n integers
 and a positive integer k. Array A is
 indexed by integers from 1 to n.

You need to permute the array elements so that value

became minimal possible. In particular, it is allowed not to change order of elements at all.


Input

The first line contains two integers n, k (2 ≤ n ≤ 3·105, 1 ≤ k ≤ min(5000, n - 1)).

The second line contains n integers A[1], A[2], ..., A[n] ( - 109 ≤ A[i] ≤ 109),
 separate by spaces — elements of the array A.



Output

Print the minimum possible value of the sum described in the statement.



Sample test(s)



input
3 2
1 2 4




output
1




input
5 2
3 -5 3 -5 3




output
0




input
6 3
4 3 4 3 2 5




output
3






Note

In the first test one of the optimal permutations is 1 4 2.

In the second test the initial order is optimal.

In the third test one of the optimal permutations is 2 3 4 4 3 5.



思路：
令sz = n/k
可以发现：
有n % k个长度为sz + 1的，有k - n % k 个长度为sz的
dp[i][j]表示取i个长度为sz + 1的和j个长度为sz的最小代价

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

#define LL __int64

const LL INF = 10000000000000000LL;
const int N = 3 * 1e5 + 5;
const int M = 5005;

LL a[N], pre[N];
LL dp[M][M];

void init(int n) {
	pre[0] = pre[1] = 0;
	for(int i = 2; i <= n; ++i) {
		pre[i] = pre[i - 1] + a[i] - a[i - 1];
	}
	for(int i = 0; i < M; ++i) {
		for(int j = 0; j < M; ++j) {
			dp[i][j] = INF;
		}
	}
}

int main() {
	int n, k;
	cin>>n>>k;
	for(int i = 1; i <= n; ++i)
		cin>>a[i];
	sort(a + 1, a + 1 + n);

	int sz = n / k;
	int u = n % k;
	int v = k - u;

	init(n);

	dp[0][0] = 0;
	for(int i = 0; i <= u; ++i) {
		for(int j = 0; j <= v; ++j) {
			int x = i * (sz + 1) + j * sz + 1;
			dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + pre[x + sz] - pre[x]);
			dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + pre[x + sz - 1] - pre[x]);
		}
	}
	cout<<dp[u][v]<<endl;
	return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

柜子开关，经过第i轮的开关切换，柜子开着的还剩几个


版权声明：本文为博主原创文章，未经博主允许不得转载。

递归简论
/**f(x)=2f(x-1)+x^2;f(0)=0;**/
#include <stdio.h>
#include <stdlib.h>
int f(unsigned int x)
{
    if(x==0)
        return 0;//处理基准情况
    //基准情形：你必须总要有某些基准的情形，它们不用递归就能求解
    else
        return 2*f(x-1)+x*x;
    //不断推进：对于那些需要递归求解的情形，递归调用必须总能够朝着产生基准情形的方向推进
}
int main()
{
    unsigned int n;
    while(~scanf("%d",&n))
    {
        printf("%u\n",f(n));
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请附上原文链接，谢谢。

【并查集题目总结】
【并查集题目总结】
问题一：并查集森林的连通分支数（经典，pre[ i ] == i ?）
http://acm.hdu.edu.cn/showproblem.php?pid=1232
问题二：并查集森林所有连通分支最大元素个数（维持一个cnt[ ]数组）
http://acm.hdu.edu.cn/showproblem.php?pid=1856
问题三：构造并查集森林过程中计数不能成环的边数(成环 等价于 根节点相同)
http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=12648
问题四：判断并查集森林的无环且连通
http://acm.hdu.edu.cn/showproblem.php?pid=1272
问题五：查询并查集森林元素到根节点的距离 （记下每个节点到父亲节点距离d[i],然后在路径压缩时维护这个d数组）
http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=33982

后面继续学习，各位盆友要等着笔者哈~

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

简单的同步







简单的同步







 
前言
 
好几天没写写C#的代码了,突发奇想,还是写写吧,别手生了.还是继续写点关于线程的小东西吧,这次说说线程的同步吧.
 
 
 
看下面这一段代码
    class ThreadTest
    {
        static int _val1 = 1, _val2 = 1;
        internal static void Go()
        {
            if (_val2!=0)
            {
                Console.WriteLine(_val1/_val2);
            }
            _val2 = 0;
        }
}
 
分析:乍一看,没问题啊,但是我要告诉你,这段代码是费线程安全的,假设两个线程A和B,A和B都执行到了Go()方法的if判断中,假设_val2=1.所以两个线程都通过了了if判断,线程A执行了CW语句,然后退出了if语句,执行_val2=0,此时val2=0,但是此时线程B才刚刚执行到CW方法,而此时_val2=0.所以你有可能会得到一个divide by zero的异常.
 
so,为了保证线程安全,我们可以使用lock关键字,例如:
 
    class ThreadTest
    {
        static readonly object _locker = new object();
        static int _val1 = 1, _val2 = 1;
        internal static void Go()
        {
            lock (_locker)
            {
                if (_val2 != 0)
                {
                    Console.WriteLine(_val1 / _val2);
                }
                _val2 = 0;
            }
 
        }
    }
 

分析:此时两个线程A和B都只能有一个可以获得_locker锁,所以只能有一个线程来执行lock块的代码.
 
C#的lock关键字实际上是Moitor.Enter和Monitor.Exit的缩写.例如上面所写的代码和下面的等价:
Monitor.Enter(_locker);
            try
            {
                if (_val2 != 0)
                {
                    Console.WriteLine(_val1 / _val2);
                }
                _val2 = 0;
            }
            finally { Monitor.Exit(_locker); }

注意,如果在调用Monitor.Exit之前没有调用Monitor.Enter,则会抛出一个异常.
 
还有,在Monitor.Enter和try方法之间可能会抛出异常.例如在线程上调用Abort,或者是OutOfMemoryException.
 
为了解决这个问题,CLR 4.0提供了Monitor.Enter的重载,增加了lockTaken字段,当Monitor.Enter成果获取锁之后,lockTaken就是True,否则就为false.
 
我们同样可以将上面的代码写成下面这样:
    class ThreadTest
    {
        static readonly object _locker = new object();
        static int _val1 = 1, _val2 = 1;
        internal static void Go()
        {
            
            bool lockTaken = false;
            try
            {
                Monitor.Enter(_locker,ref lockTaken);
                if (_val2 != 0)
                {
                    Console.WriteLine(_val1 / _val2);
                }
                _val2 = 0;
            }
            finally
            {
                if (lockTaken)
                {
                    Monitor.Exit(_locker);
                }
                
            }
 
        }
    }
 

Monitor也提供了TryEnter方法,并且可以传递一个超时时间.如果方法返回true,则代表获取了锁,否则为false.
 
 
 
选择同步对象
 
Monitor.Enter方法的参数是一个object类型,所以任何对象都可以是同步的,考虑下面的代码:
int i=5;	lock(i){}	//锁定值类型
lock(this){}	//锁定this对象
lock(typeof(Product)){}//锁定type对象
string str=”ddd”;	lock(str){}	//锁定字符串

 
锁定值类型会将值类型进行装箱,所以Monitor.Enter进入的是一个对象,但是Monitor.Exit()退出的是另一个不同的对象.
 
锁定this和type对象,会导致无法控制锁的逻辑,并且它很难保证不死锁和频繁的阻塞,在相同进程中锁定type对象会穿越应用程序域.
 
由于字符串驻留机制,所以也不要锁定string.
 
 
 
嵌套锁
 
同一个线程可以多次锁定同一对象.例如
lock(locker)
    lock(locker)
        lock(locker)
        {
            // do something
　　　　　}
 

或者是
Monitor.Enter(locker);
Monitor.Enter(locker);
Monitor.Enter(locker);
//code
Monitor.Exit(locker);
Monitor.Exit(locker);
Monitor.Exit(locker);

 
当一个线程使用一个锁调用另一个方法的时候,嵌套锁就非常的有用.例如:
        static readonly object _locker = new object();
        static void Main(string[] args)
        {
 
            lock (_locker)
            {
                Method();
            }
 
        }
        static void Method()
        {
            lock (_locker)
            {
                //code
            }
        }
 
 
 

死锁

 
先看这样的代码
static readonly object locker1 = new object();
        static readonly object locker2 = new object();
        
        public static void MainThread()
        {
            new Thread(() =>
            {
                lock (locker1)   //获取锁locker1
                {
                    Thread.Sleep(1000);
                    lock (locker2)//尝试获取locker2
                    {
                        Console.WriteLine("locker1   locker2");
                    }
                }
            }).Start();
 
            lock (locker2)//获取锁loccker2
            {
                Thread.Sleep(1000);//尝试获取locker1
                lock (locker1)
                {
                    Console.WriteLine("locker2     locker1");
                }
            }
        }

 
分析:在这里,主线程先获取locker2的锁,然后sleep,接着尝试获取locker1的锁.副线程先获取locker1的锁,然后sleep,接着尝试获取locker2的锁.程序进入死锁状态,两个线程都在等待对方释放自己等待的锁.
 
CLR作为一个独立宿主环境,它不像SQL Server一样,他没有自动检测死锁机制,也不会结束一个线程来破坏死锁.死锁的线程会导致部分线程无限的等待.
 
 
 
 小小的结一下

个人感觉那个死锁的案例,需要记住,记住代码
 
 
 
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

树状数组模拟3个元素的排序  Codeforces 12D Ball
http://codeforces.com/problemset/problem/12/d


Ball


time limit per test
2 seconds


memory limit per test
256 megabytes


input
standard input


output
standard output



N ladies attend the ball in the King's palace. Every lady can be described with three values: beauty, intellect and richness. King's
 Master of Ceremonies knows that ladies are very special creatures. If some lady understands that there is other lady at the ball which is more beautiful, smarter and more rich, she can jump out of the window. He knows values of all ladies and wants to find
 out how many probable self-murderers will be on the ball. Lets denote beauty of the i-th lady by Bi,
 her intellect by Ii and
 her richness by Ri.
 Then i-th lady is a probable self-murderer if there is some j-th
 lady that Bi < Bj, Ii < Ij, Ri < Rj.
 Find the number of probable self-murderers.



Input

The first line contains one integer N (1 ≤ N ≤ 500000).
 The second line contains N integer numbers Bi,
 separated by single spaces. The third and the fourth lines contain sequences Ii and Ri in
 the same format. It is guaranteed that 0 ≤ Bi, Ii, Ri ≤ 109.



Output

Output the answer to the problem.



Sample test(s)



input
3
1 4 2
4 3 2
2 5 3




output
1



模拟3个元素的排序

#include<stdio.h>
#include<iostream>
#include<string.h>
#include<set>
#include<vector>
#include<map>
#include<math.h>
#include<queue>
#include<string>
#include<stdlib.h>
#include<algorithm>
using namespace std;
#define N 500005
#define ll int
ll n;
ll c[N], maxn;
inline ll lowbit(ll x){return x&(-x);}
void change(ll pos, ll val){
	while(pos)c[pos]=max(c[pos],val), pos-=lowbit(pos);
}
ll maxx(ll pos){
	ll ans = -1;
	while(pos<=maxn)ans = max(ans,c[pos]),pos+=lowbit(pos);
	return ans;
}
struct node{
	ll b[3],num;
}w[N];
bool cmp0(node x, node y){return x.b[0]<y.b[0];}
bool cmp1(node x, node y){return x.b[1]>y.b[1];}
int main(){
	ll i,j;
	while(cin>>n) {
		for(i=0;i<n;i++)scanf("%d",&w[i].b[0]);
		for(i=0;i<n;i++)scanf("%d",&w[i].b[1]);
		for(i=0;i<n;i++)scanf("%d",&w[i].b[2]);
		sort(w, w+n, cmp0);
		ll rank = 1;
		w[0].num = 1;
		for(i=1;i<n;i++) {
			if(w[i].b[0]==w[i-1].b[0])w[i].num = rank;
			else w[i].num = ++rank;
		}
		sort(w,w+n,cmp1);
		for(i=1;i<=rank;i++)c[i]=-1;
		maxn = rank;
		i = 0;
		ll ans = 0;
		while(i<n) {
			for(j = i; j < n && w[i].b[1] == w[j].b[1]; j++)
				if(maxx(w[j].num+1)>w[j].b[2])
					ans++;
			for(j = i; j < n && w[i].b[1] == w[j].b[1]; j++)
				change(w[j].num, w[j].b[2]);
			i = j;
		}
		cout<<ans<<endl;
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

洗牌
bool swap(int *a, int x, int y)
{
	if (x==y)
	{
		return false;
	}
	int tmp = a[x];
	*(a+x) = *(a+y);
	*(a+y) = tmp;
	return true;
	
}
bool shuffle(int card[], int n)
{
	int idx = 0;
	for (int i=0; i<n-1; i++)
	{
		int chose = rand()%(n-i-1)+i+1;
		swap(card,chose,i);
	}
	return true;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

python学习笔记6—文件操作来生成船只侧面图像的描述文件
最近在做船只检测的工作需要大量的正样本，之前的一些样本各种形态的船只都有，这一次训练分类器希望使用只含船只侧面的图像，这样检测船的侧面的成功率可能会提高一点。这样就需要大量的船只侧面图像，并生成描述文件。这里我们之前已经生成过全船只的描述文件，只需要挑出侧面的图像，然后根据有的图像从原描述文件中选取存在的图像的描述信息保存在新的描述文件 
描述文件的内容大概是这个样子的
224871_0.jpg 1 6 50 248 82
224871_10.jpg 1 16 79 269 89
224871_11.jpg 1 80 53 122 40
224871_12.jpg 1 53 57 219 79
224871_13.jpg 1 16 94 251 72
224871_14.jpg 1 20 79 197 66
224871_15.jpg 1 6 69 294 98
224871_16.jpg 1 91 86 155 54
224871_17.jpg 1 51 70 202 72
224871_18.jpg 1 6 42 294 99
224871_19.jpg 1 9 36 291 98
224871_1.jpg 1 37 77 243 81
224871_20.jpg 1 27 27 248 83
224871_21.jpg 1 40 63 250 80
224871_22.jpg 1 18 65 234 78
224871_23.jpg 1 12 51 272 89
224871_24.jpg 1 21 83 252 73
224871_25.jpg 1 32 62 230 75
224871_26.jpg 1 0 61 298 99
224871_27.jpg 1 8 100 271 83
224871_28.jpg 1 0 60 275 92
224871_29.jpg 1 72 100 151 49
224871_2.jpg 1 62 46 179 60
224871_30.jpg 1 137 64 149 49
224871_31.jpg 1 34 119 240 80
思路很简单，就是读一行看看那个jpg文件在不在文件夹里面，如果在的话，就把这行复制进新的描述文件。
第一个代码
import glob,os
unfound=0 (u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/*.jpg')]
with open(u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/info.txt', 'r') as f:
    with open(u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/pos8.txt', 'w') as w:
        for filetitle in f.readlines():
            if filetitle.split(u' ')[0] in [os.path.split(filename)[-1] for filename in glob.glob (u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/*.jpg')]:
                w.write(filetitle)
            else:
                unfound=unfound+1        
        print u'一共有%s个图片没找到' % unfound   
这个代码挺短的，但是云讯速度却很慢原因在于第6行每次都要算一下整个集合，太慢了，所以可以优化
第二个代码
import glob,os
unfound,filenamelist=0,[os.path.split(filename)[-1] for filename in glob.glob (u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/*.jpg')]
with open(u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/info.txt', 'r') as f:
    with open(u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/pos8.txt', 'w') as w:
        for filetitle in f.readlines():
            if filetitle.split(u' ')[0] in filenamelist:
                w.write(filetitle)
            else:
                unfound=unfound+1        
        print u'一共有%s个图片没找到' % unfound   
同样行数的代码速度提高了
第三个代码
import glob,os
unfound,filenamelist=0,[os.path.split(filename)[-1] for filename in glob.glob (u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/*.jpg')]
with open(u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/info.txt', 'r') as f:
    with open(u'D:/IP_CV_WorkSpace/Img/第三批分类器/pos8/pos8.txt', 'w') as w:
        filelist=f.readlines();
        found=[w.write(filetitle) for filetitle in filelist if filetitle.split(u' ')[0] in filenamelist]        
        print u'一共有%s个图片没找到' % (len(filelist)-len(found))
使用列表生成器代码更短啦

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，欢迎转载和分享，但请声明出处http://blog.csdn.net/zhzz2012

HDU 2276 Kiki & Little Kiki 2（矩阵快速幂）


Kiki & Little Kiki 2
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2265    Accepted Submission(s): 1146



Problem Description

There are n lights in a circle numbered from 1 to n. The left of light 1 is light n, and the left of light k (1< k<= n) is the light k-1.At time of 0, some of them turn on, and others turn off. 
Change the state of light i (if it's on, turn off it; if it is not on, turn on it) at t+1 second (t >= 0), if the left of light i is on !!! Given the initiation state, please find all lights’ state after M second. (2<= n <=
 100, 1<= M<= 10^8)



 


Input

The input contains one or more data sets. The first line of each data set is an integer m indicate the time, the second line will be a string T, only contains '0' and '1' , and its length n will not exceed 100. It means all lights in the circle from 1 to n.
If the ith character of T is '1', it means the light i is on, otherwise the light is off.



 


Output

For each data set, output all lights' state at m seconds in one line. It only contains character '0' and '1.

 


Sample Input

1
0101111
10
100000001


 


Sample Output

1111000
001000010


 


Source

HDU 8th Programming Contest Site（1）

 


Recommend

lcy   |   We have carefully selected several similar problems for you:  1757 1588 2604 2256 2294 

 


#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
#include<set>
#include<map>

#define L(x) (x<<1)
#define R(x) (x<<1|1)
#define MID(x,y) ((x+y)>>1)

#define bug printf("hihi\n")

#define eps 1e-8
typedef __int64 ll;

using namespace std;

#define INF 0x3f3f3f3f
#define N 101
int n;

struct mat{
   mat(){memset(a,0,sizeof(a));}
   int a[N][N];
   mat operator *(mat b)
   {
       mat c;
       for(int i=0;i<n;i++)
          for(int j=0;j<n;j++)
             for(int k=0;k<n;k++)
                 c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j])%2;
       return c;
   }
};

mat fdd(mat s,int m)
{
    mat ss;
    for(int i=0;i<n;i++) ss.a[i][i]=1;
    while(m)
    {
        if(m&1) ss=ss*s;
        s=s*s;
        m>>=1;
    }
    return ss;
}

int main()
{
    int i,j;
    char c[1000];
    int m;
    while(~scanf("%d",&m))
    {
        scanf("%s",c);
        mat s;
        n=strlen(c);
        for(i=0;i<n;i++)
            s.a[i][0]=c[i]-'0';
        mat ss;
        ss.a[0][0]=ss.a[0][n-1]=1;
        for(i=1;i<n;i++)
            ss.a[i][i]=ss.a[i][i-1]=1;
        ss=fdd(ss,m);
        s=ss*s;
        for(i=0;i<n;i++)
            printf("%d",s.a[i][0]);
      printf("\n");
    }
    return 0;
}





















版权声明：本文为博主原创文章，未经博主允许不得转载。

Round A APAC Test 2016  Problem A. Googol String


Problem A. Googol String



This contest is open for practice. You can try every problem as many times as you like, though we won't keep track of which problems you solve. Read the Quick-Start
 Guide to get started.




Small input
7 points




Solve A-small






Large input
12 points




Solve A-large







Problem
A "0/1 string" is a string in which every character is either 0 or 1. There are two operations that
 can be performed on a 0/1 string:

switch: Every 0 becomes 1 and every 1 becomes 0.
 For example, "100" becomes "011".reverse: The string is reversed. For example, "100" becomes "001".

Consider this infinite sequence of 0/1 strings:

S0 = ""

S1 = "0"

S2 = "001"

S3 = "0010011"

S4 = "001001100011011"

...

SN = SN-1 + "0" + switch(reverse(SN-1)).
You need to figure out the Kth character of Sgoogol, where googol = 10100.
Input
The first line of the input gives the number of test cases, T. Each of the next T lines contains a number K.
Output
For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the Kth character of Sgoogol.
Limits
1 ≤ T ≤ 100.

Small dataset
1 ≤ K ≤ 105.

Large dataset
1 ≤ K ≤ 1018.

Sample






Input 
 


Output 
 



4
1
2
3
10











按题中要求构造字符串，问第k个是0还是1,

其实，我们可以发现，每个字符串都是成倍+1的增长，如果是在中心点（也就是2^n -1）则一定就是0，否则的话，按中心点对称，就是转化为2^n -2 - k;这样，很快就会变的很小或者为中心点，再记录翻转的次数，也就是这样转化的次数，如果是奇数次就是1，否则就是0，直接得到答案了。复杂度为o(log(k));
#define N 205
#define M 100005
#define maxn 205
#define MOD 1000000000000000007
int n,T;
ll p[100];
ll k;
int main()
{
    //freopen("A-large.in", "r", stdin);
    //freopen("A-large.out", "w", stdout);
    p[0] = 1;
    For(i,1,100){
        p[i] = p[i-1] * 2;
        printf("%lld %d\n",p[i],i);
    }
     while(S(T)!=EOF)
    {
        For(ta,1,T+1){
            scanf("%lld",&k);k--;
            int flag = 0,num = 0;
            bool isEnd = false;
            while(k){
                //printf("%lld k ",k);
                For(i,0,100){
                    if(p[i] - 2 >= k){
                        flag = i;
                        break;
                    }
                }
                if(k == p[flag] - 2ll - k){
                    isEnd = true;
                }
                if(isEnd) break;
                num++;


                k = p[flag] - 2ll - k;
            }
            //printf(" num %d ",num);
            if(!(num & 1))
                printf("Case #%d: 0\n",ta);
            else
                printf("Case #%d: 1\n",ta);
        }

    }
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

浅析C#中的Lambda表达式
上文中用了一点篇幅讲述了匿名方法的使用。自从C#3.0开始，就可以使用一种新语法把实现代码赋予委托，即Lambda表达式。只要有委托参数类型的地方，就可以使用Lambda表达式。上文中使用匿名方法的例子可以改为使用Lambda表达式。
语法： 
Lambda表达式的定义方式为：“([参数列表]) => 表达式”。运算符“=>”是一种与赋值运算“=”具有相同优先级的右结合运算符，在英语里读作：“goes to”。
参数： 
只有一个参数：
FunconeParam = s => String.Format("change uppercase {0}", s.ToUpper());
Console.WriteLine(oneParam("test"));
只写出参数名就足够了，上面代码中，Lambda表达式使用了参数s。因为委托类型定义了一个string参数，所以s的类型就是string。该代码实现了调用String.Format()方法来返回一个字符串，在调用该委托时，把字符串写到控制台上。
多个参数：
Func(double, double, double)twoParams = (x,y) => x*y;
Console.WriteLine(twoParams(3,2));
如果委托使用多个参数就把参数名放在花括号中。这里参数x和y的类型是double。 
为了方便，可以在花括号中给变量名添加参数类型：
Func(double, double, double)twoParamsWithType = (double x,double y) => x*y;
Console.WriteLine(twoParamsWithType (3,2));
多行代码： 
如果Lambda表达式只有一条语句，在方法块内就不需要花括号和return语句，因为编译器会添加一条隐式的return语句：
Func square = x => x*x;
但是添加花括号、return语句以及分号是完全合法的：
Func square = x =>
{
return x*x;
};
但是如果Lambda表达式的实现代码中需要多条语句，就必须添加花括号和return语句：
Func lambda = param =>
{
    param += mid;
    param += " fuck";
    return param;
};
注意：如果使用了花括号，一定不要忘了花括号后面的分号！！！
在上述的内容中，多次使用了Func，详细内容请见博客Func<>委托。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

CSU 1335: 高桥和低桥(扫描线) 13年省赛题

1335: 高桥和低桥
Time Limit: 1 Sec  Memory Limit: 128 MB
Submit: 957  Solved: 279
[Submit][Status][Web
 Board]
Description

有个脑筋急转弯是这样的：有距离很近的一高一低两座桥，两次洪水之后高桥被淹了两次，低桥却只被淹了一次，为什么？答案是：因为低桥太低了，第一次洪水退去之后水位依然在低桥之上，所以不算“淹了两次”。举例说明：
假定高桥和低桥的高度分别是5和2，初始水位为1
第一次洪水：水位提高到6（两个桥都被淹），退到2（高桥不再被淹，但低桥仍然被淹）
第二次洪水：水位提高到8（高桥又被淹了），退到3。
没错，文字游戏。关键在于“又”的含义。如果某次洪水退去之后一座桥仍然被淹（即水位不小于桥的高度），那么下次洪水来临水位提高时不能算“又”淹一次。
输入n座桥的高度以及第i次洪水的涨水水位ai和退水水位bi，统计有多少座桥至少被淹了k次。初始水位为1，且每次洪水的涨水水位一定大于上次洪水的退水水位。

Input

输入文件最多包含25组测试数据。每组数据第一行为三个整数n, m, k（1<=n,m,k<=105）。第二行为n个整数hi（2<=hi<=108），即各个桥的高度。以下m行每行包含两个整数ai和bi（1<=bi<ai<=108, ai>bi-1）。输入文件不超过5MB。

Output

对于每组数据，输出至少被淹k次的桥的个数。

Sample Input
2 2 22 56 28 35 3 22 3 4 5 65 34 25 2
Sample Output
Case 1: 1Case 2: 3
HINT
Source

湖南省第九届大学生计算机程序设计竞赛



#include<stdio.h>
#include<algorithm>
#include<string.h>
using namespace std;
const int N = 100010 ;
int num[N],h[N];
int two(int n, int ans)
{
    int l=1 , r=n , mid ;
    while(l<=r)
    {
        mid=(l+r)>>1;
        if(h[mid]>=ans)
            r = mid-1;
        else
            l = mid+1;
    }
    return l;
}
int main()
{
    int n,m,k;
    int T = 0;
    while(scanf("%d%d%d",&n,&m,&k)>0)
    {
        memset(num , 0 , (n+3)*sizeof(int));
        for(int i=1; i<=n; i++)
            scanf("%d",&h[i]);
        sort(h+1, h+1+n);
        int a ,b ,th=2 , id;
        while(m--)
        {
            scanf("%d%d",&a,&b);
            id = two(n , th);
            num[id]++ ;
            id = two(n , a+1 );
            num[id]--;
            th = b+1;
        }
        int ans = 0 , ad= 0;
        for(int i=1; i<=n; i++)
        {
            ad += num[i] ;
            if(ad>=k)
                ans++;
        }
        printf("Case %d: %d\n",++T,ans);
    }
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

三元逆序对 求i<j<k && a[i]>a[j]>a[k] 的对数 树状数组Codeforces 61E Enemy is weak
http://codeforces.com/problemset/problem/61/E







E. Enemy is weak


time limit per test
5 seconds


memory limit per test
256 megabytes


input
standard input


output
standard output



The Romans have attacked again. This time they are much more than the Persians but Shapur is ready to defeat them. He says: "A lion is never afraid of a hundred sheep".

Nevertheless Shapur has to find weaknesses in the Roman army to defeat them. So he gives the army a weakness number.

In Shapur's opinion the weakness of an army is equal to the number of triplets i, j, k such that i < j < k and ai > aj > ak where ax is
 the power of man standing at position x. The Roman army has one special trait — powers of all the people in it are distinct.

Help Shapur find out how weak the Romans are.



Input

The first line of input contains a single number n (3 ≤ n ≤ 106)
 — the number of men in Roman army. Next line contains n different positive integers ai (1 ≤ i ≤ n, 1 ≤ ai ≤ 109)
 — powers of men in the Roman army.



Output

A single integer number, the weakness of the Roman army.

Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also
 you may use %I64d).



Sample test(s)



input
3
3 2 1




output
1




input
3
2 3 1




output
0




input
4
10 8 3 1




output
4




input
4
1 5 4 3




output
1













题意是求 i<j<k && a[i]>a[j]>a[k] 的对数

如果只有2元组那就是求逆序数的做法

三元组的话就用一个树状数组x表示 数字i前面有多少个比自己大的个数

然后每次给这个y数组求和，再把x中>a[i]的个数存入y中即可
即使是4元也可以求了
#include <algorithm>
#include <cctype>
#include <cassert>
#include <cstdio>
#include <cstring>
#include <climits>
#include <vector>
#include<iostream>
using namespace std;
#define ll long long
inline void rd(int &ret)
{
	char c;
	do { c = getchar();
	} while(c < '0' || c > '9');
	ret = c - '0';
	while((c=getchar()) >= '0' && c <= '9')
		ret = ret * 10 + ( c - '0' );
}
#define N 1000005
#define eps 1e-8
#define inf 1000000


ll n;
struct node{
	ll c[N];
	inline ll lowbit(ll x){return x&-x;}
	void init(){memset(c, 0, sizeof c);}
	ll sum(ll x){
		ll ans = 0;
		while(x<=n+10)
			ans += c[x], x+=lowbit(x);
		return ans;
	}
	void change(ll x, ll y){
		while(x)
			c[x] +=y, x-=lowbit(x);
	}
}x, y;
int haifei[1000000], panting[1000000];
int main()
{
	ll i, j;
	while(cin>>n)
	{
		ll ans = 0;
		for(i = 0; i < n; i++)rd(haifei[i]), panting[i] = haifei[i];
		x.init(); y.init();
		sort(haifei, haifei+n);
		for(i = 0; i < n; i++)
		{
			ll b = (lower_bound(haifei, haifei+n, panting[i]) - haifei) +1;
			
			ll siz = y.sum(b);
			ans += siz;
			y.change(b, x.sum(b));
			x.change(b, 1);
		}
		cout<<ans<<endl;
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

杭电ACM1501——Zipper~~DFS
题目的意思是：给你三个字符串，判断第三个字符串是否是前面两个字符串组成的，且前面两个字符串的字符在第三个字符串中的顺序不变。
可以用DP 或者 DFS。
我用的是DFS，需要一个二维数组来存在各个状态是否访问过，访问过的就可以直接跳过，也就是记忆化搜索。


下面的是AC的代码：
#include <iostream>
#include <cstring>
using namespace std;

char str1[205], str2[205];
char str[405];
int length1, length;
bool flag[205][205];         //标记各种状态
bool ans;                    //判断最终结果
void dfs(int x, int y, int z)
{
	if(str1[x] == '\0' && str2[y] == '\0' && str[z] == '\0')  //到最后了，可以匹配成功
	{
		ans = true;
		return;
	}
	if(str1[x] != str[z] && str2[y] != str[z])           //两个都不等于，跳过
		return;
	if(flag[x][y])                                    //访问过，跳过
		return;
	flag[x][y] = true;                                 //标记访问过

	if(str1[x] == str[z])                            //相等，搜索
		dfs(x + 1, y, z + 1);
	if(ans)
		return;
	if(str2[y] == str[z])
		dfs(x, y + 1, z + 1);
}

int main()
{
	int t;
	cin >> t;
	{
		for(int i = 1; i <= t; i++)
		{
			cin >> str1 >> str2 >> str;
			length1 = strlen(str1);
			length = strlen(str);
			memset(flag, false, sizeof(flag));
			ans = false;
			dfs(0, 0, 0);
			if(ans)
				cout << "Data set " << i << ": " << "yes" << endl;
			else
				cout << "Data set " << i << ": " << "no" << endl;
		}
	}
	return 0;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

利用R语言获取最新所有股票数据
本文利用这里提到的方法，进行改进，从而批量获取所有股票的数据，并对股票数据进行了简单的统计。 
首先使用该程序需要用到一个csv文件，记录了各个股票的名称和代码。 
格式如下： 
 
至于制作的话，还是挺简单的，百度一下股票代码，或者直接到这里，可以轻松获得所有股票代码，然后放进excel按空格分割，处理一下就可以了。这里有一份我做好的，不过只有上海的股票有兴趣可以拿去stockid.csv。 
注意，如果是其他的股票的话，请参考我前面提到的博文相应修改代码，
上证代码是 ss，深证代码是 sz，港股代码是 hk
比如茅台：6000519.ss，万科 000002.sz，长江实业 0001.hk
代码中的'.ss'要改成其他。
library(quantmod)
stock=read.csv('F:/Program Files/RStudio/stockid.csv',stringsAsFactors=F)
data=list()
for(i in 1:length(stock$id)){
  try(setSymbolLookup(TEMP=list(name=paste0(stock$id[i],'.ss'))))
  try(getSymbols("TEMP",warnings=F))
  try(data[stock$name[i]]<-list(TEMP))
}
这时候的data是一个list，它存放了你的csv中所有的股票数据，可以通过比如data$浦发银行 ，来得到该股票的信息。 
数据样例： 
 
今天是2015年8月25号，所以获取的数据都是最新的历史数据。 
可以看到一共有6列数据，它们的意思分别是：

Open price 开盘价
High price 最高价
Low price 最低价
Close price 收盘价
volume 交易量
Adjusted price 调整价格

这里稍微对股市稍微统计一下，提供一个例子给大家。将所有股票的收盘价提取出来，然后计算各个股票收盘价的最大最小均值等等。
library(plyr)
closedata<-lapply(data,function(x){
  x=as.data.frame(x)
  return(list(x[,4])) #提取第4列，即收盘价
})
ldply(closedata,function(x)summary(x[[1]])) #对每个股票求summary
部分运行结果：
> ldply(closedata,function(x)summary(x[[1]]))
        .id  Min. 1st Qu. Median   Mean 3rd Qu.  Max.
1  浦发银行  7.11   9.610 13.890 17.760   21.80 61.59
2  白云机场  5.97   7.050  8.920 10.060   11.37 23.03
3  武钢股份  1.99   2.730  4.605  6.106    7.67 22.86
4  东风汽车  2.42   3.130  4.530  4.948    5.97 15.19
5  中国国贸  6.00   9.790 10.800 11.950   12.84 25.58
6  首创股份  3.73   5.705  6.720  8.073    8.18 23.45
7  上海机场 10.35  12.930 14.170 17.880   19.35 42.62
8  包钢股份  2.09   3.910  4.630  4.971    5.95 10.12
9  华能国际  4.06   5.640  6.710  7.508    8.11 18.73
10 皖通高速  3.36   4.240  5.215  5.792    6.49 20.05

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ 题目2763 Housewife Wind（Link Cut Tree修改边权，查询两点间距离）
Housewife Wind




Time Limit: 4000MS
 
Memory Limit: 65536K


Total Submissions: 7639
 
Accepted: 1990




Description
After their royal wedding, Jiajia and Wind hid away in XX Village, to enjoy their ordinary happy life. People in XX Village lived in beautiful huts. There are some pairs of huts connected by bidirectional roads. We say that huts
 in the same pair directly connected. XX Village is so special that we can reach any other huts starting from an arbitrary hut. If each road cannot be walked along twice, then the route between every pair is unique.

Since Jiajia earned enough money, Wind became a housewife. Their children loved to go to other kids, then make a simple call to Wind: 'Mummy, take me home!'

At different times, the time needed to walk along a road may be different. For example, Wind takes 5 minutes on a road normally, but may take 10 minutes if there is a lovely little dog to play with, or take 3 minutes if there is some unknown strange smell surrounding
 the road.

Wind loves her children, so she would like to tell her children the exact time she will spend on the roads. Can you help her?

Input
The first line contains three integers n, q, s. There are n huts in XX Village, q messages to process, and Wind is currently in hut s. n < 100001 , q < 100001.


The following n-1 lines each contains three integers a, b and w. That means there is a road directly connecting hut a and b, time required is w. 1<=w<= 10000.


The following q lines each is one of the following two types:

Message A: 0 u
A kid in hut u calls Wind. She should go to hut u from her current position.
Message B: 1 i w 
The time required for i-th road is changed to w. Note that the time change will not happen when Wind is on her way. The changed can only happen when Wind is staying somewhere, waiting to take the next kid.

Output
For each message A, print an integer X, the time required to take the next child.
Sample Input
3 3 1
1 2 1
2 3 2
0 2
1 2 3
0 3

Sample Output
1
3

Source
POJ Monthly--2006.02.26,zgl & twb

题目大意：操作 0 查询当前点到这个点的最短距离，操作1修改第k个边的权值
Problem: 2763		User: kxh1995
Memory: 7636K		Time: 1141MS
Language: C++		Result: Accepted


ac代码
#include<stdio.h>  
#include<string.h>  
#include<stdlib.h>  
#include<queue>  
#include<iostream>  
using namespace std;  
int head[100010],cnt,vis[100050];  
struct s  
{  
    int u,v,w,next;  
}edge[150050<<1];  
struct LCT    
{    
    int bef[150050],pre[150050],next[150050][2],key[150050],sum[150050],belong[150050];  
    void init()    
    {    
        memset(pre,0,sizeof(pre));  
        memset(next,0,sizeof(next));    
    }  
    void pushup(int x)  
    {  
        sum[x]=key[x]+sum[next[x][1]]+sum[next[x][0]];  
    }  
    void rotate(int x,int kind)    
    {    
        int y,z;    
        y=pre[x];    
        z=pre[y];    
        next[y][!kind]=next[x][kind];    
        pre[next[x][kind]]=y;    
        next[z][next[z][1]==y]=x;    
        pre[x]=z;    
        next[x][kind]=y;    
        pre[y]=x;  
        pushup(y);  
    }    
    void splay(int x)    
    {    
        int rt;    
        for(rt=x;pre[rt];rt=pre[rt]);    
        if(x!=rt)    
        {    
            bef[x]=bef[rt];    
            bef[rt]=0;    
            while(pre[x])    
            {    
                if(next[pre[x]][0]==x)    
                {    
                    rotate(x,1);    
                }    
                else    
                    rotate(x,0);    
            }    
            pushup(x);  
        }    
    }   
    void access(int x)    
    {    
        int fa;    
        for(fa=0;x;x=bef[x])    
        {    
            splay(x);    
            pre[next[x][1]]=0;    
            bef[next[x][1]]=x;    
            next[x][1]=fa;    
            pre[fa]=x;    
            bef[fa]=0;    
            fa=x;    
            pushup(x);  
        }    
    }  
    void change(int x,int val)  
    {  
        int t;  
        t=belong[x-1];  
        key[t]=val;  
        splay(t);  
    }  
    int query(int x,int y)  
    {  
        access(y);  
        for(y=0;x;x=bef[x])  
        {  
            splay(x);  
            if(!bef[x])  
                return sum[y]+sum[next[x][1]];  
            pre[next[x][1]]=0;  
            bef[next[x][1]]=x;  
            next[x][1]=y;  
            pre[y]=x;  
            bef[y]=0;  
            y=x;  
            pushup(x);  
        }  
    }  
}lct;
void add(int u,int v,int w)  
{  
    edge[cnt].u=u;  
    edge[cnt].v=v;  
    edge[cnt].w=w;  
    edge[cnt].next=head[u];  
    head[u]=cnt++;  
}  
void bfs(int u)  
{  
    int i,y;  
    queue<int>q;  
    memset(vis,0,sizeof(vis));  
    vis[u]=1;  
    q.push(u);  
    while(!q.empty())  
    {  
        u=q.front();  
        q.pop();  
        for(int i=head[u];i!=-1;i=edge[i].next)  
        {  
            int v=edge[i].v;  
            if(!vis[v])  
            {  
                lct.bef[v]=u;  
                lct.key[v]=lct.sum[v]=edge[i].w;  
                lct.belong[i>>1]=v;  
                vis[v]=1;  
                q.push(v);  
            }  
        }  
    }  
}  
int main()
{
	int n,m,s;
	while(scanf("%d%d%d",&n,&m,&s)!=EOF)
	{
		int i;
		lct.init();
		cnt=0;
		memset(head,-1,sizeof(head));
		for(i=1;i<n;i++)
		{
			int u,v,w;
			scanf("%d%d%d",&u,&v,&w);
			add(u,v,w);
			add(v,u,w);
		}
		bfs(1);
		while(m--)
		{
			int op;
			scanf("%d",&op);
			if(!op)
			{
				int x;
				scanf("%d",&x);
				printf("%d\n",lct.query(s,x));
				s=x;
			}
			else
			{
				int x,y;
				scanf("%d%d",&x,&y);
				lct.change(x,y);
			}
		}
	}
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

【并查集】hdu 1272 小希的迷宫
【并查集】hdu 1272 小希的迷宫
并查集——并查集森林无环且连通
题目大意
给你连接关系构造一个图，判断图是否无环且满足连通性。
 


说一下思路
①有无环：(a,b)元素a、b根节点是否相同，相同合并边就会成环，不满足题目要求
②连通性：记录之前出现的节点，统计最后根节点==自身的节点个数，正好是1才是一片连通森林！
★再以后并查集初始化 i < _max,这道题有等号就WA了，不知道为什么？？！！！


参考代码
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
#define clr(k,v) memset(k,v,sizeof(k))
using namespace std;

const int _max = 1e5 + 10;
int a,b,pre[_max];
bool ok,v[_max];

void init(){
 for(int i = 1; i < _max; ++ i) pre[i] = i;
}

int find(int x){//查，元素x的根节点
 return pre[x] == x? x : pre[x] = find(pre[x]);
}

void join(int a,int b){//并，边(a,b)
  int x = find(a),y = find(b);
  if(x != y) pre[x] = y;
  else ok = false;//加上(a,b)出现环路
}

int main(){
 #ifndef ONLINE_JUDGE
 freopen("input.txt","r",stdin);
 #endif // ONLINE_JUDGE
 while(scanf("%d%d",&a,&b) == 2){
    if(a == -1 && b == -1) break;
    init();
    ok = true;
    clr(v,0);
    while(a != 0 && b != 0){
        join(a,b);
        v[a] = v[b] = 1;
        scanf("%d%d",&a,&b);
    }
    int cnt = 0;
    for(int i = 1;i < _max; ++ i) if(v[i] == 1&&pre[i] == i) cnt ++ ;
    if(cnt > 1) ok = false;//只有一个连通分支
    puts(ok?"Yes":"No");
 }
 return 0;
}


加粗    Ctrl + B 
斜体    Ctrl + I 
引用    Ctrl + Q
插入链接    Ctrl + L
插入代码    Ctrl + K
插入图片    Ctrl + G
提升标题    Ctrl + H
有序列表    Ctrl + O
无序列表    Ctrl + U
横线    Ctrl + R
撤销    Ctrl + Z
重做    Ctrl + Y


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

python学习笔记5—序列与列表的操作
序列乘法
用数字x乘以一个序列会生成新的序列，而在新的序列中，原来的序列将被重复x次。 
比如输出10个空格可以写成
print(' '*10)
in语句
in语句可以判断一个元素是否在序列里面。
userAndPin = {'lichao':'123456','chenzhao':'123456','wangfei':'123456'}
name=input('请输入用户名：')
if name in userAndPin and input('请输入密码:')==userAndPin.get(name) :
    print('身份验证成功')
else:
    print('无法通过身份验证')
分片赋值
分片赋值可以用来按位置替换、插入和删除操作
#分片替换
language=list('perl')
language[1:]=list('ython')
print(language)#虽然str是不可变的，但是我们可以通过列表作为中间过渡来改变它的量

#分片插入
numbers=[1,5]
numbers[1:1]=[2,3,4]
print(numbers)
#分片删除
numbers[1:-1]=[]
print(numbers)
list的方法
有两条规律： 
1. 除了pop函数既改变了原有序列又返回了非None值,一般的函数要么返回一个值，要么改变了原序列返回None 
2. 不会返回一个改变了的序列。
根据以上两个特点我们可以总结如下。 
只返回值的方法：count()计数,index()搜索 
改变原序列返回None的方法：中尾增：insert(),append(),extend(),中尾删：pop(),remove(),排序、逆序sort(),reverse();

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，欢迎转载和分享，但请声明出处http://blog.csdn.net/zhzz2012

POJ 1308 Is It A Tree?（简单并查集）

Is It A Tree?




Time Limit: 1000MS
 
Memory Limit: 10000K


Total Submissions: 26043
 
Accepted: 8895




Description

A tree is a well-known data structure that is either empty (null, void, nothing) or is a set of one or more nodes connected by directed edges between nodes satisfying the following properties. 

There is exactly one node, called the root, to which no directed edges point. 
Every node except the root has exactly one edge pointing to it. 
There is a unique sequence of directed edges from the root to each node. 
For example, consider the illustrations below, in which nodes are represented by circles and edges are represented by lines with arrowheads. The first two of these are trees, but the last is not. 


In this problem you will be given several descriptions of collections of nodes connected by directed edges. For each of these you are to determine if the collection satisfies the definition of a tree or not.
Input

The input will consist of a sequence of descriptions (test cases) followed by a pair of negative integers. Each test case will consist of a sequence of edge descriptions followed by a pair of zeroes Each edge description will consist of a pair of integers;
 the first integer identifies the node from which the edge begins, and the second integer identifies the node to which the edge is directed. Node numbers will always be greater than zero.
Output

For each test case display the line "Case k is a tree." or the line "Case k is not a tree.", where k corresponds to the test case number (they are sequentially numbered starting with 1).
Sample Input
6 8  5 3  5 2  6 4
5 6  0 0

8 1  7 3  6 2  8 9  7 5
7 4  7 8  7 6  0 0

3 8  6 8  6 4
5 3  5 6  5 2  0 0
-1 -1
Sample Output
Case 1 is a tree.
Case 2 is a tree.
Case 3 is not a tree.
和小希的迷宫相似，符合的无向图连通且没有环。
一些细节比如：
（1）空树也是树。
（2）输入1 1 0 0 这样的自环不符合。
（3）输入1 2 1 2 0 0和1 2 2 1 0 0都是不符合的。
（2）和（3）都在判断环那里考虑到了，不用特地去判断。
HDU的A不了，知道是怎么回事的童鞋留言告诉我下。
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std;

const int MAXN = 100000 + 100;
int parent[MAXN];
bool vis[MAXN];

int find_set(int t)
{
	if (parent[t] == -1)
		return t;
	else
		return parent[t] = find_set(parent[t]);
}

bool union_set(int a, int b)
{
	int t1 = find_set(a);
	int t2 = find_set(b);
	if (t1 != t2)
	{
		parent[t2] = t1;
		return true;
	}
	return false;
}

int main()
{
	int a, b;
	int casen = 1;
	while (scanf("%d%d", &a, &b) != EOF && a>= 0 && b>=0)
	{
		if (a == 0 && b == 0)
		{
			printf("Case %d", casen);
			printf(" is a tree.\n");
			casen++;
			continue;
		}
		memset(vis, false, sizeof(vis));
		memset(parent, -1, sizeof(parent));
		bool ret = true;
		bool ok = true;
		
		ret = union_set(a, b);
		vis[a] = vis[b] = true;
		if (!ret) ok = false;
	
		while (scanf("%d%d", &a, &b) && a)
		{
			ret = union_set(a, b);
			vis[a] = vis[b] = true;
			if (!ret) ok = false;
		}
		int sum = 0;
		for (int i = 0; i < MAXN; i++)
		{
			if (vis[i] && parent[i] == -1)
				sum++;
		}
		if (sum != 1) ok = false;
		printf("Case %d", casen);
		if (ok) printf(" is a tree.\n");
		else printf(" is not a tree.\n");
		casen++;
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

（转载）C#线程（一）
C#中的线程(一)入门 - wota - 博客园





  












Coding Life










 
博客园 ::
首页 ::
新随笔 ::
联系 ::
订阅
 ::
管理







                 
                28 
                Posts ::
                0 Stories
                ::
                91 Comments
                ::
                0 Trackbacks
            









公告








C#中的线程(一)入门


 
文章系参考转载，英文原文网址请参考:http://www.albahari.com/threading/ 
作者 Joseph Albahari,  翻译 Swanky Wu
  中文翻译作者把原文放在了”google 协作”上面，GFW屏蔽，不能访问和查看，因此我根据译文和英文原版整理转载到园子里面。
  本系列文章可以算是一本很出色的C#线程手册，思路清晰，要点都有介绍，看了后对C#的线程及同步等有了更深入的理解。

入门

概述与概念 
创建和开始使用多线程 


线程同步基础 

同步要领 
锁和线程安全 
Interrupt 和 Abort 
线程状态 
等待句柄 
同步环境 


使用多线程 

单元模式和Windows Forms 
BackgroundWorker类 
ReaderWriterLock类 
线程池 
异步委托 
计时器 
局部储存 


高级话题 

非阻止同步 
Wait和Pulse 
Suspend和Resume 
终止线程 



一、入门
1.     概述与概念
   C#支持通过多线程并行地执行代码，一个线程有它独立的执行路径，能够与其它的线程同时地运行。一个C#程序开始于一个单线程，这个单线程是被CLR和操作系统（也称为“主线程”）自动创建的，并具有多线程创建额外的线程。这里的一个简单的例子及其输出：
     除非被指定，否则所有的例子都假定以下命名空间被引用了：     using System;    using System.Threading;
class ThreadTest {
  static void Main() {
    Thread t = new Thread (WriteY);
    t.Start();                          // Run WriteY on the new thread
    while (true) Console.Write ("x");   // Write 'x' forever
  }

  static void WriteY() {
    while (true) Console.Write ("y");   // Write 'y' forever
  }
}
 
   主线程创建了一个新线程“t”，它运行了一个重复打印字母”y”的方法，同时主线程重复但因字母“x”。CLR分配每个线程到它自己的内存堆栈上，来保证局部变量的分离运行。在接下来的方法中我们定义了一个局部变量，然后在主线程和新创建的线程上同时地调用这个方法。
static void Main() {
  new Thread (Go).Start();      // Call Go() on a new thread
  Go();                         // Call Go() on the main thread
}

static void Go() {
  // Declare and use a local variable - 'cycles'
  for (int cycles = 0; cycles < 5; cycles++) Console.Write ('?');
}
 
   变量cycles的副本分别在各自的内存堆栈中创建，输出也一样，可预见，会有10个问号输出。当线程们引用了一些公用的目标实例的时候，他们会共享数据。下面是实例：
class ThreadTest {
 bool done;

 static void Main() {
   ThreadTest tt = new ThreadTest();   // Create a common instance
   new Thread (tt.Go).Start();
   tt.Go();
 }

 // Note that Go is now an instance method
 void Go() {
   if (!done) { done = true; Console.WriteLine ("Done"); }
 }
}
因为在相同的ThreadTest实例中，两个线程都调用了Go()，它们共享了done字段，这个结果输出的是一个"Done"，而不是两个。
 
 
  静态字段提供了另一种在线程间共享数据的方式，下面是一个以done为静态字段的例子：
class ThreadTest {
 static bool done;    // Static fields are shared between all threads

 static void Main() {
   new Thread (Go).Start();
   Go();
 }

 static void Go() {
   if (!done) { done = true; Console.WriteLine ("Done"); }
 }
}
  上述两个例子足以说明， 另一个关键概念， 那就是线程安全(或反之，它的不足之处! ) 输出实际上是不确定的：它可能(虽然不大可能) ， “Done” ，可以被打印两次。然而，如果我们在Go方法里调换指令的顺序， “Done”被打印两次的机会会大幅地上升：
static void Go() {
  if (!done) { Console.WriteLine ("Done"); done = true; }
}

问题就是一个线程在判断if块的时候，正好另一个线程正在执行WriteLine语句——在它将done设置为true之前。 
补救措施是当读写公共字段的时候，提供一个排他锁；C#提供了lock语句来达到这个目的：
class ThreadSafe {
  static bool done;
  static object locker = new object();

  static void Main() {
    new Thread (Go).Start();
    Go();
  }

  static void Go() {
    lock (locker) {
      if (!done) { Console.WriteLine ("Done"); done = true; }
    }
  }
}
   当两个线程争夺一个锁的时候（在这个例子里是locker），一个线程等待，或者说被阻止到那个锁变的可用。在这种情况下，就确保了在同一时刻只有一个线程能进入临界区，所以”Done”只被打印了1次。代码以如此方式在不确定的多线程环境中被叫做线程安全。 
   临时暂停，或阻止是多线程的协同工作，同步活动的本质特征。等待一个排它锁被释放是一个线程被阻止的原因，另一个原因是线程想要暂停或Sleep一段时间：
Thread.Sleep (TimeSpan.FromSeconds (30));         // Block for 30 seconds
一个线程也可以使用它的Join方法来等待另一个线程结束： 
Thread t = new Thread (Go);           // Assume Go is some static method
t.Start();
t.Join();                             // Wait (block) until thread t ends
一个线程，一旦被阻止，它就不再消耗CPU的资源了。 
  线程是如何工作的
   线程被一个线程协调程序管理着——一个CLR委托给操作系统的函数。线程协调程序确保将所有活动的线程被分配适当的执行时间；并且那些等待或阻止的线程——比如说在排它锁中、或在用户输入——都是不消耗CPU时间的。 
   在单核处理器的电脑中，线程协调程序完成一个时间片之后迅速地在活动的线程之间进行切换执行。这就导致“波涛汹涌”的行为，例如在第一个例子，每次重复的X 或 Y 块相当于分给线程的时间片。在Windows XP中时间片通常在10毫秒内选择要比CPU开销在处理线程切换的时候的消耗大的多。(即通常在几微秒区间) 
   在多核的电脑中，多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。这几乎可以肯定仍然会出现一些时间切片, 由于操作系统的需要服务自己的线程，以及一些其他的应用程序。 
   线程由于外部因素（比如时间片）被中断被称为被抢占，在大多数情况下,一个线程方面在被抢占的那一时那一刻就失去了对它的控制权。 
   线程 vs. 进程
    属于一个单一的应用程序的所有的线程逻辑上被包含在一个进程中，进程指一个应用程序所运行的操作系统单元。
    线程于进程有某些相似的地方：比如说进程通常以时间片方式与其它在电脑中运行的进程的方式与一个C#程序线程运行的方式大致相同。二者的关键区别在于进程彼此是完全隔绝的。线程与运行在相同程序其它线程共享(堆heap)内存，这就是线程为何如此有用：一个线程可以在后台读取数据，而另一个线程可以在前台展现已读取的数据。 
  何时使用多线程
    多线程程序一般被用来在后台执行耗时的任务。主线程保持运行，并且工作线程做它的后台工作。对于Windows Forms程序来说，如果主线程试图执行冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应。由于这个原因，应该在工作线程中运行一个耗时任务时添加一个工作线程，即使在主线程上有一个有好的提示“处理中…”，以防止工作无法继续。这就避免了程序出现由操作系统提示的“没有相应”，来诱使用户强制结束程序的进程而导致错误。模式对话框还允许实现“取消”功能，允许继续接收事件，而实际的任务已被工作线程完成。BackgroundWorker恰好可以辅助完成这一功能。 
   在没有用户界面的程序里，比如说Windows Service， 多线程在当一个任务有潜在的耗时，因为它在等待另台电脑的响应（比如一个应用服务器，数据库服务器，或者一个客户端）的实现特别有意义。用工作线程完成任务意味着主线程可以立即做其它的事情。 
   另一个多线程的用途是在方法中完成一个复杂的计算工作。这个方法会在多核的电脑上运行的更快，如果工作量被多个线程分开的话（使用Environment.ProcessorCount属性来侦测处理芯片的数量）。 
   一个C#程序称为多线程的可以通过2种方式：明确地创建和运行多线程，或者使用.NET framework的暗中使用了多线程的特性——比如BackgroundWorker类, 线程池，threading timer，远程服务器，或Web Services或ASP.NET程序。在后面的情况，人们别无选择，必须使用多线程；一个单线程的ASP.NET web server不是太酷，即使有这样的事情；幸运的是，应用服务器中多线程是相当普遍的；唯一值得关心的是提供适当锁机制的静态变量问题。 
  何时不要使用多线程
    多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂，拥有多线程本身并不复杂，复杂是的线程的交互作用，这带来了无论是否交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的bugs。因此，要么多线程的交互设计简单一些，要么就根本不使用多线程。除非你有强烈的重写和调试欲望。 
当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。在某些情况下，太多的I/O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务块的多。稍后我们将实现生产者/耗费者 队列，它提供了上述功能。 
 
2.    创建和开始使用多线程
   线程用Thread类来创建， 通过ThreadStart委托来指明方法从哪里开始运行，下面是ThreadStart委托如何定义的：
public delegate void ThreadStart();
   调用Start方法后，线程开始运行，线程一直到它所调用的方法返回后结束。下面是一个例子，使用了C#的语法创建TheadStart委托：
class ThreadTest {
  static void Main() {
    Thread t = new Thread (new ThreadStart (Go));
    t.Start();   // Run Go() on the new thread.
    Go();        // Simultaneously run Go() in the main thread.
  }
  static void Go() { Console.WriteLine ("hello!"); }
在这个例子中，线程t执行Go()方法，大约与此同时主线程也调用了Go()，结果是两个几乎同时hello被打印出来：
 
一个线程可以通过C#堆委托简短的语法更便利地创建出来：
static void Main() {
  Thread t = new Thread (Go);    // No need to explicitly use ThreadStart
  t.Start();
  ...
}
static void Go() { ... }
在这种情况，ThreadStart被编译器自动推断出来，另一个快捷的方式是使用匿名方法来启动线程：
static void Main() {
  Thread t = new Thread (delegate() { Console.WriteLine ("Hello!"); });
  t.Start();
}
  线程有一个IsAlive属性，在调用Start()之后直到线程结束之前一直为true。一个线程一旦结束便不能重新开始了。 
  将数据传入ThreadStart中
  话又说回来，在上面的例子里，我们想更好地区分开每个线程的输出结果，让其中一个线程输出大写字母。我们传入一个状态字到Go中来完成整个任务，但我们不能使用ThreadStart委托，因为它不接受参数，所幸的是，.NET framework定义了另一个版本的委托叫做ParameterizedThreadStart， 它可以接收一个单独的object类型参数：
public delegate void ParameterizedThreadStart (object obj);
之前的例子看起来是这样的：
 
class ThreadTest {
  static void Main() {
    Thread t = new Thread (Go);
    t.Start (true);             // == Go (true) 
    Go (false);
  }
  static void Go (object upperCase) {
    bool upper = (bool) upperCase;
    Console.WriteLine (upper ? "HELLO!" : "hello!");
  }

  在整个例子中，编译器自动推断出ParameterizedThreadStart委托，因为Go方法接收一个单独的object参数，就像这样写：
Thread t = new Thread (new ParameterizedThreadStart (Go));
t.Start (true);
ParameterizedThreadStart的特性是在使用之前我们必需对我们想要的类型（这里是bool）进行装箱操作，并且它只能接收一个参数。 
  一个替代方案是使用一个匿名方法调用一个普通的方法如下：
static void Main() {
  Thread t = new Thread (delegate() { WriteText ("Hello"); });
  t.Start();
}
static void WriteText (string text) { Console.WriteLine (text); }
  优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。不过这需要将一个外部变量放入到匿名方法中，向下面的一样：
static void Main() {
  string text = "Before";
  Thread t = new Thread (delegate() { WriteText (text); });
  text = "After";
  t.Start();
}
static void WriteText (string text) { Console.WriteLine (text); }
 
  匿名方法打开了一种怪异的现象，当外部变量被后来的部分修改了值的时候，可能会透过外部变量进行无意的互动。有意的互动（通常通过字段）被认为是足够了！一旦线程开始运行了，外部变量最好被处理成只读的——除非有人愿意使用适当的锁。 
  另一种较常见的方式是将对象实例的方法而不是静态方法传入到线程中，对象实例的属性可以告诉线程要做什么，如下列重写了原来的例子：
class ThreadTest {
  bool upper;

  static void Main() {
    ThreadTest instance1 = new ThreadTest();
    instance1.upper = true;
    Thread t = new Thread (instance1.Go);
    t.Start();
    ThreadTest instance2 = new ThreadTest();
    instance2.Go();        // 主线程——运行 upper=false
  }

  void Go() { Console.WriteLine (upper ? "HELLO!" : "hello!"); }
  命名线程
  线程可以通过它的Name属性进行命名，这非产有利于调试：可以用Console.WriteLine打印出线程的名字，Microsoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。线程的名字可以在被任何时间设置——但只能设置一次，重命名会引发异常。 
  程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：
class ThreadNaming {
  static void Main() {
    Thread.CurrentThread.Name = "main";
    Thread worker = new Thread (Go);
    worker.Name = "worker";
    worker.Start();
    Go();
  }
  static void Go() {
    Console.WriteLine ("Hello from " + Thread.CurrentThread.Name);
  }
}
 
  
  前台和后台线程
  线程默认为前台线程，这意味着任何前台线程在运行都会保持程序存活。C#也支持后台线程，当所有前台线程结束后，它们不维持程序的存活。 
  改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。 
  线程的IsBackground属性控制它的前后台状态，如下实例：
class PriorityTest {
  static void Main (string[] args) {
    Thread worker = new Thread (delegate() { Console.ReadLine(); });
    if (args.Length > 0) worker.IsBackground = true;
    worker.Start();
  }
}
   如果程序被调用的时候没有任何参数，工作线程为前台线程，并且将等待ReadLine语句来等待用户的触发回车，这期间，主线程退出，但是程序保持运行，因为一个前台线程仍然活着。 
   另一方面如果有参数传入Main()，工作线程被赋值为后台线程，当主线程结束程序立刻退出，终止了ReadLine。 
   后台线程终止的这种方式，使任何最后操作都被规避了，这种方式是不太合适的。好的方式是明确等待任何后台工作线程完成后再结束程序，可能用一个timeout（大多用Thread.Join）。如果因为某种原因某个工作线程无法完成，可以用试图终止它的方式，如果失败了，再抛弃线程，允许它与 与进程一起消亡。（记录是一个难题，但这个场景下是有意义的） 
   拥有一个后台工作线程是有益的，最直接的理由是它当提到结束程序它总是可能有最后的发言权。交织以不会消亡的前台线程，保证程序的正常退出。抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。 
   对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。 
 
  线程优先级
  线程的Priority 属性确定了线程相对于其它同一进程的活动的线程拥有多少执行时间，以下是级别：
enum ThreadPriority { Lowest, BelowNormal, Normal, AboveNormal, Highest }
  只有多个线程同时为活动时，优先级才有作用。 
  设置一个线程的优先级为高一些，并不意味着它能执行实时的工作，因为它受限于程序的进程的级别。要执行实时的工作，必须提升在System.Diagnostics 命名空间下Process的级别，像下面这样：（我没有告诉你如何做到这一点:)）
Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
   ProcessPriorityClass.High 其实是一个短暂缺口的过程中的最高优先级别：Realtime。设置进程级别到Realtime通知操作系统：你不想让你的进程被抢占了。如果你的程序进入一个偶然的死循环，可以预期，操作系统被锁住了，除了关机没有什么可以拯救你了！基于此，High大体上被认为最高的有用进程级别。 
   如果一个实时的程序有一个用户界面，提升进程的级别是不太好的，因为当用户界面UI过于复杂的时候，界面的更新耗费过多的CPU时间，拖慢了整台电脑。（虽然在写这篇文章的时候,在互联网电话程序Skype侥幸地这么做, 也许是因为它的界面相当简单吧。） 降低主线程的级别、提升进程的级别、确保实时线程不进行界面刷新，但这样并不能避免电脑越来越慢，因为操作系统仍会拨出过多的CPU给整个进程。最理想的方案是使实时工作和用户界面在不同的进程（拥有不同的优先级）运行，通过Remoting或共享内存方式进行通信，共享内存需要Win32 API中的 P/Invoking。(可以搜索看看CreateFileMapping 和 MapViewOfFile) 
  
  异常处理
  任何线程创建范围内try/catch/finally块，当线程开始执行便不再与其有任何关系。考虑下面的程序：
  public static void Main() {
  try {
    new Thread (Go).Start();
  }
  catch (Exception ex) {
    // 不会在这得到异常
    Console.WriteLine ("Exception!");
  }

  static void Go() { throw null; }
 }
  这里try/catch语句一点用也没有，新创建的线程将引发NullReferenceException异常。当你考虑到每个线程有独立的执行路径的时候，便知道这行为是有道理的，
补救方法是在线程处理的方法内加入他们自己的异常处理：
public static void Main() {
   new Thread (Go).Start();
}

static void Go() {
  try {
    ...
    throw null;      // 这个异常在下面会被捕捉到
    ...
  }
  catch (Exception ex) {
    记录异常日志，并且或通知另一个线程
    我们发生错误
    ...
  }
   从.NET 2.0开始，任何线程内的未处理的异常都将导致整个程序关闭，这意味着忽略异常不再是一个选项了。因此为了避免由未处理异常引起的程序崩溃，try/catch块需要出现在每个线程进入的方法内，至少要在产品程序中应该如此。对于经常使用“全局”异常处理的Windows Forms程序员来说，这可能有点麻烦，像下面这样：
using System;
using System.Threading;
using System.Windows.Forms;

static class Program {
  static void Main() {
    Application.ThreadException += HandleError;
    Application.Run (new MainForm());
  }

  static void HandleError (object sender, ThreadExceptionEventArgs e) {
    记录异常或者退出程序或者继续运行...
  }
}
 
Application.ThreadException事件在异常被抛出时触发，以一个Windows信息（比如：键盘，鼠标活着 “paint” 等信息）的方式，简言之，一个Windows Forms程序的几乎所有代码。虽然这看起来很完美，它使人产生一种虚假的安全感——所有的异常都被中央异常处理捕捉到了。由工作线程抛出的异常便是一个没有被Application.ThreadException捕捉到的很好的例外。（在Main方法中的代码，包括构造器的形式，在Windows信息开始前先执行） 
.NET framework为全局异常处理提供了一个更低级别的事件：AppDomain.UnhandledException，这个事件在任何类型的程序（有或没有用户界面）的任何线程有任何未处理的异常触发。尽管它提供了好的不得已的异常处理解决机制，但是这不意味着这能保证程序不崩溃，也不意味着能取消.NET异常对话框。 
在产品程序中，明确地使用异常处理在所有线程进入的方法中是必要的，可以使用包装类和帮助类来分解工作来完成任务，比如使用BackgroundWorker类（在第三部分进行讨论）











        posted on 2010-06-18 21:08 wota 阅读(…) 评论(…)  编辑 收藏






刷新评论刷新页面返回顶部


博客园首页博问新闻闪存程序员招聘知识库


    var enableGoogleAd = canShowAdsense(); 
    fixPostBodyFormat();


  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') +
              '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
  })();


    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function() {
            googletag.defineSlot('/1090369/cnblogs_blogpost_C2', [468, 60], 'div-gpt-ad-1433581717989-0').addService(googletag.pubads());
            googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1433581717989-1').addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.pubads().collapseEmptyDivs();
            googletag.enableServices();
            });
        };
    } catch (e) { }



    
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1433581717989-1'); });
            } else {
                $('#div-gpt-ad-1433581717989-1').hide();
            }
    } catch (e) { }

    





try {
    if (enableGoogleAd) {
        googletag.cmd.push(function () { googletag.display('div-gpt-ad-1433581717989-0'); });
    } else {
        $('#div-gpt-ad-1433581717989-0').hide();
    }
} catch (e) { }






$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});





    Copyright @
    wota
    Powered by:
    .Text and 
    ASP.NET

    Theme by: .NET Monster

 

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

老王赛马

时间限制: 1 Sec  内存限制:
128 MB
提交: 47  解决: 26
[提交][状态][讨论版]
题目描述

赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 
赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 
孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 
比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 
就是这么简单，现在老王也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。老王有N(1≤N≤1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看老王能否赢得比赛。



输入

输入有多组测试数据。 
每组测试数据包括3行： 
第一行输入N(1≤N≤1000)。表示马的数量。 
第二行有N个整型数字，即渊子的N匹马的速度。 
第三行有N个整型数字，即对手的N匹马的速度。 
当N为0时退出。 


输出

若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出“YES”。 
否则输出“NO”。

样例输入

5
2 3 3 4 5
1 2 3 4 5
4
2 2 1 2
2 2 3 1
0

样例输出

YES
NO




#include <stdio.h> 
#include<algorithm> 
using namespace std; 
int n; 
int a[1010]; 
int b[1010]; 
int cmp(int a,int b) 
{ 
    return a>b; 
} 
int cmp1(int a,int b) 
{ 
    return a>b; 
} 
int main() 
{ 
    while(scanf("%d",&n)!=EOF&&n) 
    { 
        int ans = 0; 
        for(int i=0; i<n; i++) 
        scanf("%d",&a[i]); 
        for(int i=0; i<n; i++) 
        scanf("%d",&b[i]); 
        sort(a,a+n,cmp1); 
        sort(b,b+n,cmp); 
        int l=0; 
        for(int i=0;i<n;i++) 
        if(a[l]>b[i]) 
        { 
            ans++; 
            l++; 
        } 
        if((n/2)<ans) 
        printf("YES\n"); 
        else
        printf("NO\n"); 
    }    
    return 0; 
} 
/************************************************************** 
    Problem: 1148  
    Language: C++ 
    Result: 正确 
    Time:0 ms 
    Memory:828 kb 
****************************************************************/


版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 2276（矩阵快速幂）

Kiki & Little Kiki 2
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2301    Accepted Submission(s): 1176



Problem Description

There are n lights in a circle numbered from 1 to n. The left of light 1 is light n, and the left of light k (1< k<= n) is the light k-1.At time of 0, some of them turn on, and others turn off. 
Change the state of light i (if it's on, turn off it; if it is not on, turn on it) at t+1 second (t >= 0), if the left of light i is on !!! Given the initiation state, please find all lights’ state after M second. (2<= n <=
 100, 1<= M<= 10^8)



 


Input

The input contains one or more data sets. The first line of each data set is an integer m indicate the time, the second line will be a string T, only contains '0' and '1' , and its length n will not exceed 100. It means all lights in the circle from 1 to n.
If the ith character of T is '1', it means the light i is on, otherwise the light is off.



 


Output

For each data set, output all lights' state at m seconds in one line. It only contains character '0' and '1.

 


Sample Input

1
0101111
10
100000001


 


Sample Output

1111000
001000010


 


Source

HDU 8th Programming Contest Site（1）

 


Recommend

lcy   |   We have carefully selected several similar problems for you:  1757 1588 2604 2256 2294 

/*
  能够把转换关系找出来的话，这题就是个比较裸的快速幂了
  用a[i]*代表上一层的a[i],通过推样例会发现如下规律：
  a[i]=(a[i]*+a[i-1]*)%2,其中a[1]=(a[1]*a[n]*)%2
  
  第一次敲快速幂，存做模板

*/
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <string>
#include <queue>
#include <map>
#include <stack>
#include <set>
#include <cmath>
#include <vector>
#include<cstdlib>
#define INF 1<<30
#pragma comment (linker,"/STACK:102400000,102400000")
using namespace std;
#define maxn 150
#define moo 2
char s[maxn];
int n,m;
struct Mat
{
    int a[maxn][maxn];
};
Mat res1;
Mat muti(Mat a,Mat b)
{
    Mat res;
    memset(res.a,0,sizeof(res.a));
    for(int i=0;i<n;i++)
    for(int j=0;j<n;j++)
    {
       for(int k=0;k<n;k++)
            res.a[i][j]=(res.a[i][j] + a.a[i][k]*b.a[k][j])%moo;
    }
    return res;
}
Mat pow(Mat res,int m)
{
    Mat ss;
    memset(ss.a,0,sizeof(ss.a));
    for(int i=0;i<n;i++)
        ss.a[i][i]=1;
    while(m)
    {
        if(m%2)
        ss=muti(ss,res);
        res=muti(res,res);
        m/=2;
    }
    return ss;
}
int main()
{
    int ans[maxn];
    Mat oo;
    while(~scanf("%d",&m))
    {
        scanf("%s",s);
        n=strlen(s);
        for(int i=0;i<n;i++)
        ans[i]=s[i]-'0';
        int ant[maxn];
        memset(ant,0,sizeof(ant));
        memset(res1.a,0,sizeof(res1.a));

        res1.a[0][0]=res1.a[n-1][0]=res1.a[n-1][n-1]=1;
        for(int i=0;i<n-1;i++)
            res1.a[i][i]=res1.a[i][i+1]=1;
        oo=pow(res1,m);

        for(int j=0;j<n;j++)
            for(int i=0;i<n;i++)
            ant[j]=(ant[j]+ans[i]*oo.a[i][j])%moo;
            for(int i=0;i<n;i++)
                cout<<ant[i];
            cout<<endl;
    }
    return 0;
}





版权声明：本文为博主原创文章，欢迎指教~

Jocky代码混淆配置使用
反编译工具下载地址：http://download.csdn.net/detail/myfmyfmyfmyf/7307497
jockey代码混淆下载地址：http://download.csdn.net/detail/myfmyfmyfmyf/9043975

一、存在的问题

1、工程中jsp页面及web.xml等xml文件中还有类引用名，如果将java类名进行混淆，jsp及xml中引用的类将找不到。
2、如果对xml、jsp中引用的java类不混淆，其余的混淆，那么在反编译的时候未混淆的更加明显，失去混淆的作用。
3、对所有的java类名不进行混淆，只对类中的方法名混淆，反编译查看不受影响
     

二、安装说明

将links和myplugins两个文件夹拷贝到eclipse的根目录下

  


三、Jocky配置

1、右键点击项目->Jocky->Jock Settings 会弹出一个界面



2、修改工程的编码格式，因为我们的工程是GBK格式所以设置为GBK格式，打开jocky_build.xml文件工修改两处，
      A、xml文件开头部分


    B、<javacencoding="gbk"



3、外部接口不能混淆，最好只是混淆私有方法，不混淆就要增加注释：@preserve
4、如果需要哪个java类名不混淆，就在哪个类名上加注释
@preserve all


四、  使用说明

右键点击项目->Jocky->Jocky Now! 


jocky会将生成的混淆类存入配置中的指定目录（默认是工程下的jocky文件夹）




相关链接：http://www.cnblogs.com/qima/archive/2012/08/06/2625041.html


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ 1010 Tempter of the Bone（DFS奇偶剪枝）

Problem Description
The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately
 to get out of this maze.

The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the
 T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for
 more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him.

 

Input
The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 < N, M < 7; 0 < T < 50), which denote the sizes of the maze and the time at which the door will open, respectively.
 The next N lines give the maze layout, with each line containing M characters. A character is one of the following:

'X': a block of wall, which the doggie cannot enter; 
'S': the start point of the doggie; 
'D': the Door; or
'.': an empty block.

The input is terminated with three 0's. This test case is not to be processed.

 

Output
For each test case, print in one line "YES" if the doggie can survive, or "NO" otherwise.

 

Sample Input

4 4 5
S.X.
..X.
..XD
....
3 4 5
S.X.
..X.
...D
0 0 0

 

Sample Output

NO
YES



题目大意：求狗能不能在T时间内刚好出来，且“.”经过后会变成“X”。
思路：因为有时间T限制所以用DFS，并且若不用奇偶剪纸会TLE。


#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define LL long long
#define inf 0x3f3f3f3f
using namespace std;

int n,m,e1,e2;
int cx[]= {0,0,1,-1},cy[]= {-1,1,0,0};
bool bj;
char Ma[10][10];
int t;
void DFS(int s1,int s2,int ans)
{
    if(ans==t&&s1==e1&&s2==e2)//注意不要写成Ma[s1][s2]=='D'，可能回溯的时候没有把'D',复原
        bj=true;
    if(bj)
        return;
    if( (abs(e1-s1)+abs(e2-s2))%2!=(t-ans)%2 )//奇偶剪枝就是距离为奇数，那么到达的时间也为奇数
        return ;
    for(int i=0;i<4;i++)
    {
        int x=s1+cx[i];
        int y=s2+cy[i];
        if(x>=0&&x<n&&y>=0&&y<m&&Ma[x][y]!='X')
        {
            Ma[x][y]='X';
            DFS(x,y,ans+1);
            Ma[x][y]='.';
        }
    }
}
int main()
{
    int  k,i,j,l;
    while(~scanf("%d%d%d",&n,&m,&t))
    {
        bj=false;
        int s=0;
        if(n==0&&m==0&&t==0)
            break;
        for(i=0; i<n; i++)
            scanf("%s",Ma[i]);
        int s1,s2;
        for(i=0; i<n; i++)
        {
            for(j=0; j<m; j++)
            {
                if(Ma[i][j]=='S')
                {
                    s1=i;
                    s2=j;
                }
                if(Ma[i][j]=='D')
                {
                    e1=i;
                    e2=j;
                }
            }

        }
        Ma[s1][s2]='X';///一定注意把经过的路线变成‘X’，就是因为这WA了好多次
            DFS(s1,s2,0);
        if(bj)
            puts("YES");
        else
            puts("NO");
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

JavaScript中函数定义的三种方式
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<title>无标题文档</title>
</head>

<body>
	<script>
		/*
		 *函数定义的一种方式	
		*/
		function aa(){
			document.write("aaaa");
		}
		
	</script>
	<!--<button name="hanshu" onclick="aa()">按钮</button> -->
	<input type="button" value="按钮" onclick="aa()" />
	<script>
		/*
		* 函数定义的一种方式之二
		*/
		var aa2 = function(a,b){
			return a*b;
		}
		alert(aa2(4,5));
	</script>
	
	<script>
		/*
		*	构造函数定义JavaScript函数，注意Function中的F是大写
		*/
		var add = new Function('a','b','return a+b;');
		//调用上面定义的add函数
		var sum = add(3,4);
		alert(sum);
	</script>
	
</body>
</html>




 可以有返回值，可以用变量来接受其返回值
 如果没有return，则返回undefined.


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU - 2545 树上战争（没有路径压缩的并查集）

树上战争




Time Limit: 4000MS
 
Memory Limit: 32768KB
 
64bit IO Format: %I64d & %I64u




Submit Status


Description

给一棵树，如果树上的某个节点被某个人占据，则它的所有儿子都被占据，lxh和pfz初始时分别站在两个节点上，谁当前所在的点被另一个人占据，他就输了比赛，问谁能获胜 

 




Input

输入包含多组数据 
每组第一行包含两个数N，M（N，M<=100000），N表示树的节点数，M表示询问数，N=M=0表示输入结束。节点的编号为1到N。 
接下来N-1行，每行2个整数A，B(1<=A,B<=N)，表示编号为A的节点是编号为B的节点的父亲 
接下来M行，每行有2个数，表示lxh和pfz的初始位置的编号X，Y(1<=X,Y<=N,X!=Y)，lxh总是先移动 


 




Output

对于每次询问，输出一行，输出获胜者的名字
 




Sample Input


2 1
 1 2
 1 2
 5 2
 1 2
 1 3
 3 4
 3 5
 4 2
 4 5
 0 0 

 




Sample Output


lxh
 pfz
 lxh

提示：
本题输入、输出都很多，请使用scanf和printf代替cin、cout。
        
        

 




简单建树，然后查询到根节点需要的步数，步数少的胜


#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int MAXN = 100000 + 100;
int parent[MAXN];
int n, m;

void make_set()
{
	for (int i = 0; i <= n; i++)
		parent[i] = i;
}

int find_set(int t)
{
	int num = 0;
	int j = parent[t];
	int i = t;
	while (j != i)
	{
		i = j;
		j = parent[j];
		num++;
	}
	return num;
}

void union_set(int a, int b)
{
	parent[b] = a;
}

int main()
{
	while (scanf("%d%d", &n, &m) != EOF && n)
	{
		int a, b;
		make_set();
		for (int i = 0; i < n - 1; i++)
		{
			scanf("%d%d", &a, &b);
			union_set(a, b);
		}
		for (int i = 0; i < m; i++)
		{
			scanf("%d%d", &a, &b);
			int l = find_set(a);
			int p = find_set(b);
			if (p<l) printf("pfz\n");
			else printf("lxh\n");
		}
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

例题8-8 防线 UVa1471
1.题目描述：点击打开链接
2.解题思路：本题要求在一个长度为n的序列中，删除一段连续子序列，使得剩下的序列有一个长度最大的连续递增子序列。按照以往的经验，可以事先用f[i]计算出从i出发的最长连续递增子序列的长度，用g[i]表示以i结尾的最长连续递增子序列的长度，然后枚举j,i(j<=i)即可，然而这么做的时间复杂度O(N^2)的，无法通过本题，还需要进一步优化。


本题的优化环节就在于已知一个i，如何快速找到一个j。由于我们希望得到的连续递增子序列尽可能的长，那么我们希望在A[j]<A[i]时，还可以让g[j]尽可能的大。考虑这样一种情形，A[j]<A[k]且g[j]>g[k]，这意思就是说：在序列...A[j]...A[k]...A[i]....中，以A[j]结尾的连续递增子序列长度比以A[k]结尾的连续递增子序列长度更长一点，那么此时我们只需要保留A[j]即可。或者第二种情况，g[i]==g[k]但A[j]<A[k]，那么我们保留A[j]一定不会丢失最优解。这就非常像经典的LIS问题的O(NlogN)算法的做法。仿照LIS问题的解法，我们不妨令s[i]表示g==i时的最小的A[j]，这样不难得到s[1]<=s[2]<=...<=s[n]，可以用lower_bound找到s[p]>=A[i]的第一个下标p，那么p-1就是s[p‘]<A[i]的最后一个下标p’，此时的p其实就代表了g值（因为每个g值都对应一个最小的A[j]），所以此时的答案就是p-1+f[i]，如果此时的A[i]<s[g[i]]，那么更新s[g[i]]=A[i]。
注意：千万不要写成s[p]=A[i]，因为我们更新的是g[i]的最小值，p只是为了得到p-1。
3.代码：
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include<iostream>
#include<algorithm>
#include<cassert>
#include<string>
#include<sstream>
#include<set>
#include<bitset>
#include<vector>
#include<stack>
#include<map>
#include<queue>
#include<deque>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cctype>
#include<functional>
using namespace std;

#define me(s)  memset(s,0,sizeof(s))
#define rep(i,n) for(int i=0;i<(n);i++)
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef pair <int, int> P;


const int N=200110;
int n,a[N],f[N],g[N],s[N];

int main()
{
    int T;
    for(scanf("%d",&T);T--;)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a[i]);
            if(i==1)g[1]=1;
            else if(a[i]>a[i-1])g[i]=g[i-1]+1;//计算以i结尾的最长子序列的长度
            else g[i]=1;
        }
        for(int i=n;i>=1;i--)
        {
            if(i==n)f[i]=1;
            else if(a[i]<a[i+1])f[i]=f[i+1]+1;//计算以i开始的最长子序列的长度
            else f[i]=1;
        }
        for(int i=1;i<=n;i++)
            s[i]=(1e9)+10;
        s[1]=a[1];
        int res=1;
        for(int i=2;i<=n;i++)
        {
            int p=lower_bound(s+1,s+n+1,a[i])-s;
            res=max(res,p-1+f[i]);  //p-1就是A[j]<A[i]且g[j]最大的那个最大值
            if(a[i]<s[g[i]])s[g[i]]=a[i]; //更新g[i]对应的最小的A[i]
        }
        printf("%d\n",res);
    }
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

android连接wifi相关知识

这里列了很多，但是大致可以分为四个主要的类ScanResult wifiConfiguration WifiInfo WifiManager
(1)ScanResult，主要是通过wifi 硬件的扫描来获取一些周边的wifi 热点的信息。
在我们进行wifi 搜索的时候，一般会搜到这些信息，首先是接入点名字、接入点信息的强弱、还有接入点使用的安全模式，是WPA、WPE。
打开这个类，我们可以看到以下几个信息
BSSID 接入点的地址，这里主要是指小范围几个无线设备相连接所获取的地址，比如说两台笔记本通过无线网卡进行连接，双方的无线网卡分配的地址。
SSID 网络的名字，当我们搜索一个网络时，就是靠这个来区分每个不同的网络接入点。
Capabilities 网络接入的性能，这里主要是来判断网络的加密方式等。
Frequency 频率，每一个频道交互的MHz 数。
Level 等级，主要来判断网络连接的优先数。
这里只提供了一个方法，就是将获得信息编程字符串toString()。
(2)wifiConfiguration 在我们连通一个wifi 接入点的时候，需要获取到的一些信息。大家可以跟我们有线的设备进行对比一下。
这里的数据相对来说比较复杂一下。
六个子类
WifiConfiguration.AuthAlgorthm 用来判断加密方法。
WifiConfiguration.GroupCipher 获取使用GroupCipher 的方法来进行加密。
WifiConfiguration.KeyMgmt 获取使用KeyMgmt 进行。
WifiConfiguration.PairwiseCipher 获取使用WPA 方式的加密。
WifiConfiguration.Protocol 获取使用哪一种协议进行加密。
wifiConfiguration.Status 获取当前网络的状态。
对于上述加密感兴趣的朋友，可以在网上搜索相关的内容。
(3)WifiInfo 在我们的wifi 已经连通了以后，可以通过这个类获得一些已经连通的wifi 连接的信息获取当前链接的信息，这里信息就比较简单了，这里简单介绍一下这里的方法:
getBSSID() 获取BSSID
getDetailedStateOf() 获取客户端的连通性
getHiddenSSID() 获得SSID 是否被隐藏
getIpAddress() 获取IP 地址
getLinkSpeed() 获得连接的速度
getMacAddress() 获得Mac 地址
getRssi() 获得802.11n 网络的信号
getSSID() 获得SSID
getSupplicanState() 返回具体客户端状态的信息
(4)wifiManager 这个不用说，就是用来管理我们的wifi 连接，这里已经定义好了一些类，可以供我们使用。这里来说相对复杂，里面的内容比较多，但是通过字面意思，我们还是可以获得很多相关的信息。这个类里面预先定义了许多常量，我们可以直接使用，不用再次创建。
这里还是简单介绍一下这里的方法：
addNetwork(WifiConfiguration config) 通过获取到的网络的链接状态信息，来添加网络
calculateSignalLevel(int rssi , int numLevels) 计算信号的等级
compareSignalLevel(int rssiA, int rssiB) 对比连接A 和连接B
createWifiLock(int lockType, String tag) 创建一个wifi 锁，锁定当前的wifi 连接
disableNetwork(int netId) 让一个网络连接失效
disconnect() 断开连接
enableNetwork(int netId, Boolean disableOthers) 连接一个连接
getConfiguredNetworks() 获取网络连接的状态
getConnectionInfo() 获取当前连接的信息
getDhcpInfo() 获取DHCP 的信息
getScanResulats() 获取扫描测试的结果
getWifiState() 获取一个wifi 接入点是否有效
isWifiEnabled() 判断一个wifi 连接是否有效
pingSupplicant() ping 一个连接，判断是否能连通
ressociate() 即便连接没有准备好，也要连通
reconnect() 如果连接准备好了，连通
removeNetwork() 移除某一个网络
saveConfiguration() 保留一个配置信息
setWifiEnabled() 让一个连接有效
startScan() 开始扫描
updateNetwork(WifiConfiguration config) 更新一个网络连接的信息
此外wifiManaer 还提供了一个内部的子类，也就是wifiManagerLock，WifiManagerLock 的作用是这样的，在普通的状态下，如果我们的wifi 的状态处于闲置，那么网络的连通，将会暂时中断。但是如果我们把当前的网络状态锁上，那么wifi 连通将会保持在一定状态，当然接触锁定之后，就会恢复常态

但是关于链接加密的wifi现在还没有成功……

 

首先附上一个工具类，有各种WIFI操作方法：

public class WifiAdmin { 
    // 定义WifiManager对象  
    private WifiManager mWifiManager; 
    // 定义WifiInfo对象  
    private WifiInfo mWifiInfo; 
    // 扫描出的网络连接列表  
    private List<ScanResult> mWifiList; 
    // 网络连接列表  
    private List<WifiConfiguration> mWifiConfiguration; 
    // 定义一个WifiLock  
    WifiLock mWifiLock; 
 
    // 构造器  
    public WifiAdmin(Context context) { 
        // 取得WifiManager对象  
        mWifiManager = (WifiManager) context 
                .getSystemService(Context.WIFI_SERVICE); 
        // 取得WifiInfo对象  
        mWifiInfo = mWifiManager.getConnectionInfo(); 
    } 
 
    // 打开WIFI  
    public void openWifi() { 
        if (!mWifiManager.isWifiEnabled()) { 
            mWifiManager.setWifiEnabled(true); 
        } 
    } 
 
    // 关闭WIFI  
    public void closeWifi() { 
        if (mWifiManager.isWifiEnabled()) { 
            mWifiManager.setWifiEnabled(false); 
        } 
    } 
 
    // 检查当前WIFI状态  
    public int checkState() { 
        return mWifiManager.getWifiState(); 
    } 
 
    // 锁定WifiLock  
    public void acquireWifiLock() { 
        mWifiLock.acquire(); 
    } 
 
    // 解锁WifiLock  
    public void releaseWifiLock() { 
        // 判断时候锁定  
        if (mWifiLock.isHeld()) { 
            mWifiLock.acquire(); 
        } 
    } 
 
    // 创建一个WifiLock  
    public void creatWifiLock() { 
        mWifiLock = mWifiManager.createWifiLock("Test"); 
    } 
 
    // 得到配置好的网络  
    public List<WifiConfiguration> getConfiguration() { 
        return mWifiConfiguration; 
    } 
 
    // 指定配置好的网络进行连接  
    public void connectConfiguration(int index) { 
        // 索引大于配置好的网络索引返回  
        if (index > mWifiConfiguration.size()) { 
            return; 
        } 
        // 连接配置好的指定ID的网络  
        mWifiManager.enableNetwork(mWifiConfiguration.get(index).networkId, 
                true); 
    } 
 
    public void startScan() { 
        mWifiManager.startScan(); 
        // 得到扫描结果  
        mWifiList = mWifiManager.getScanResults(); 
        // 得到配置好的网络连接  
        mWifiConfiguration = mWifiManager.getConfiguredNetworks(); 
    } 
 
    // 得到网络列表  
    public List<ScanResult> getWifiList() { 
        return mWifiList; 
    } 
 
    // 查看扫描结果  
    public StringBuilder lookUpScan() { 
        StringBuilder stringBuilder = new StringBuilder(); 
        for (int i = 0; i < mWifiList.size(); i++) { 
            stringBuilder 
                    .append("Index_" + new Integer(i + 1).toString()
 + ":"); 
            // 将ScanResult信息转换成一个字符串包  
            // 其中把包括：BSSID、SSID、capabilities、frequency、level  
            stringBuilder.append((mWifiList.get(i)).toString()); 
            stringBuilder.append("/n"); 
        } 
        return stringBuilder; 
    } 
 
    // 得到MAC地址  
    public String getMacAddress() { 
        return (mWifiInfo == null) ? "NULL" : mWifiInfo.getMacAddress(); 
    } 
 
    // 得到接入点的BSSID  
    public String getBSSID() { 
        return (mWifiInfo == null) ? "NULL" : mWifiInfo.getBSSID(); 
    } 
 
    // 得到IP地址  
    public int getIPAddress() { 
        return (mWifiInfo == null) ? 0 : mWifiInfo.getIpAddress(); 
    } 
 
    // 得到连接的ID  
    public int getNetworkId() { 
        return (mWifiInfo == null) ? 0 : mWifiInfo.getNetworkId(); 
    } 
 
    // 得到WifiInfo的所有信息包  
    public String getWifiInfo() { 
        return (mWifiInfo == null) ? "NULL" : mWifiInfo.toString(); 
    } 
 
    // 添加一个网络并连接  
 public void addNetwork(WifiConfiguration wcg) { 
        int wcgID = mWifiManager.addNetwork(wcg); 
        boolean b =  mWifiManager.enableNetwork(wcgID, true); 
        System.out.println("a--" + wcgID);
        System.out.println("b--" + b);
    } 
 
    // 断开指定ID的网络  
    public void disconnectWifi(int netId) { 
        mWifiManager.disableNetwork(netId); 
        mWifiManager.disconnect(); 
    } 
} 

然后是一个实际应用方法，只验证过没有密码的情况：

 
       WifiConfiguration CreateWifiInfo(String SSID, String Password, int Type) 
      { 
          WifiConfiguration config = new WifiConfiguration();   
           config.allowedAuthAlgorithms.clear(); 
           config.allowedGroupCiphers.clear(); 
           config.allowedKeyManagement.clear(); 
           config.allowedPairwiseCiphers.clear(); 
           config.allowedProtocols.clear(); 
          config.SSID = "\"" + SSID + "\"";   
          if(Type == Data.WIFICIPHER_NOPASS) 
          { 
               config.wepKeys[0] = ""; 
               config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE); 
               config.wepTxKeyIndex = 0; 
          } 
          if(Type == Data.WIFICIPHER_WEP) 
          { 
              config.hiddenSSID = true;
              config.wepKeys[0]= "\""+Password+"\""; 
              config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.SHARED); 
              config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP); 
              config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP); 
              config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP40); 
              config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.WEP104); 
              config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE); 
              config.wepTxKeyIndex = 0; 
          } 
          if(Type == Data.WIFICIPHER_WPA) 
          { 
          config.preSharedKey = "\""+Password+"\""; 
          config.hiddenSSID = true;   
          config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);   
          config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);                         
          config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);                         
          config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);                    
          config.allowedProtocols.set(WifiConfiguration.Protocol.WPA);                      
          config.status = WifiConfiguration.Status.ENABLED;   
          }

           return config; 
               } 

  
}


分为三种情况：1没有密码2用wep加密3用wpa加密

 

 
WifiManager wifiManager = (WifiManager)getSystemService(Context.WIFI_SERVICE);
boolean bRet1 = wifiManager.setWifiEnabled(true);
//add network
if (wifiManager.startScan()) //扫描可用的无线网络
{
List scanResultList = wifiManager.getScanResults();
for (int i = 0; i < scanResultList.size(); i++)
{
ScanResult scanRet = scanResultList.get(i);
if (scanRet.SSID.equalsIgnoreCase("TEST")) //找到 TEST
{
WifiConfiguration config = new WifiConfiguration();
config.SSID = "\"" + scanRet.SSID + "\"";
config.preSharedKey = "\"password\""; //指定密码
config.hiddenSSID = true;
config.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);
config.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);
config.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
config.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);
config.allowedProtocols.set(WifiConfiguration.Protocol.WPA);
config.status = WifiConfiguration.Status.ENABLED;
int netID = wifiManager.addNetwork(config);
boolean bRet = wifiManager.enableNetwork(netID, true);
}
}
}
 

<!-- 以下是使用wifi访问网络所需要的权限-->


android.permission.CHANGE_NETWORK_STATE //修改网络状态的权限


android.permission.CHANGE_WIFI_STATE //修改wifi状态的权限


android.permission.ACCESS_NETWORK_STATE //访问网络权限


android.permission.ACCESS_WIFI_STATE //访问wifi权

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ 2602 Bone Collector--01背包
题目来源：HPU 2602--Bone Collector
Problem Description
Manyyears ago , in Teddy’s hometown there was a man who was called “BoneCollector”. This man like to collect varies of bones , such as dog’s , cow’s ,also he went to the grave
…
The bone collector had a big bag with a volume of V ,and along his trip ofcollecting there are a lot of bones , obviously , different bone has differentvalue and different volume, now given the each bone’s value along his trip ,can you calculate out the maximum
 of the total value the bone collector can get?
 
Input
Thefirst line contain a integer T , the number of cases.
Followed by T cases , each case three lines , the first line contain twointeger N , V, (N <= 1000 , V <= 1000 )representing the number of bonesand the volume of his bag. And the second line contain N integers representingthe value of each bone. The third line
 contain N integers representing thevolume of each bone.
 
 
Output
Oneinteger per line representing the maximum of the total value (this number willbe less than 231).
 
 
Sample Input
1
5 10
1 2 3 4 5
5 4 3 2 1
 
 
Sample Output
14
 
 
考察点：动态规划—01背包
 
题目大意：
给定T组测试数据，每组数据给定一个n(n块骨头)和一个V(背包的容量V)，接下来给定两行分别输入n块骨头的价值和体积。输出背包能装下的最大价值。
题目解析：
动态规划方程：f(n,m)=max{f(n-1,m),f(n-1,m-w[n])+v(n,m)}，根据此递推式可知01背包记录的是当前位置的最优解。
AC代码： 

#include<cstdio>
#include<cstring>
#include<cstring>
#include<algorithm>
using namespace std;
int value[1005],volume[1005];//骨头价值，体积 
int dp[1005][1005];//记录背包体积从0到V所装价值最大值 
int main()
{
	int T;
	int n,V;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&V);
		memset(dp,0,sizeof(dp));//dp数组要初始化为0 
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&value[i]);
		}
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&volume[i]);
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<=V;j++)
			{
				if(j<volume[i])//当前背包体积j不能装下体积为volume[i]的骨头 
				{
					dp[i][j]=dp[i-1][j]; 
				}
				else//当前背包体积j能装下体积为volume[i]的骨头 
				{
					//选择加或不加当前背包的价值 
					dp[i][j]=max(dp[i-1][j],dp[i-1][j-volume[i]]+value[i]);
				}
			}
		}
		printf("%d\n",dp[n][V]);
	}
	return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

python数据类型——字典
引入

没有字典的时候我们可能会这么做：

>>> t = ['name', 'age', 'sex']
>>> v = ['chen', 24, 'male']
>>> zip(t,v)
[('name', 'chen'), ('age', 24), ('sex', 'male')]
>>> v = ['chen', 24]
>>> zip(t,v)
[('name', 'chen'), ('age', 24)]

也可能会使用列表来存储数据，但是这样不够直观，因为访问的时候都是用下标来进行访问。由此，就产生了字典{}这种数据结构 

字典是python种唯一的映射类型（哈希表） 
  字典的对象是可变的，但是字典的键必须使用不可变的对象，并且一个字典中可以使用不同类型的键值。 
  keys() 或者values()返回键列表或者值列表。 
  items()返回包含键值对的元组


创建字典
方法一：{}
>>> dic = {0:0,1:1,2:2}
>>> dic[0]
0
>>> dic[2]
2
>>> dic = {0:'00',1:'11',2:'22'}
>>> dic[0]
'00'
>>> dic = {0:'123',name:'chenwen','x':456}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'name' is not defined
>>> name = None
>>> dic = {0:'123',name:'chenwen','x':456}
>>> name
>>> dic
{0: '123', 'x': 456, None: 'chenwen'}

注意 
上面代码中的，出错信息，意思是，name还没定义，所以之后将name定义之后，才可以顺利创建字典。创建之后，其实是以name的值做键。 
并不是创建字典的时候直接定义name的值。

>>> a = 1
>>> b = 2
>>> dic = {a:'aaa','b':'bbb'}
>>> a
1
>>> b
2
>>> dic
{1: 'aaa', 'b': 'bbb'}
方法二： 使用工厂方法dict()
>>> dict(one=1, two=2)
{'two': 2, 'one': 1}
>>> dict({'one': 1, 'two': 2})
{'two': 2, 'one': 1}
>>> dict(zip(('one', 'two'), (1, 2)))
{'two': 2, 'one': 1}
>>> dict([['two', 2], ['one', 1]])
{'two': 2, 'one': 1}
方法三： 内建方法：fromkeys()

字典中的元素具有相同的值，默认为None

>>> {}.fromkeys(('x','y'))
{'y': None, 'x': None}
>>> {}.fromkeys(('x','y'),-1)
{'y': -1, 'x': -1}
访问字典中的值
>>> dic = {0:'123',name:'chenwen','x':456}
>>> for k in dic:
...     print k
...
0
x
None
>>> for k in dic:
...     print dic[k]
...
123
456
chenwen
更新和删除
>>> dic = {0:'123',name:'chenwen','x':456}
>>> dic['like'] = "DOTA"
>>> dic
{0: '123', 'x': 456, 'like': 'DOTA', None: 'chenwen'}
>>> dic['like'] = "GIRL"
>>> dic
{0: '123', 'x': 456, 'like': 'GIRL', None: 'chenwen'}
>>> del(dic[None])
>>> dic
{0: '123', 'x': 456, 'like': 'GIRL'}
>>> dic.pop(0)
'123'
>>> dic
{'x': 456, 'like': 'GIRL'}
>>> dic.clear()
>>> dic
{}
>>> dic = {0:'123',name:'chenwen','x':456}
>>> del(dic)
>>> dic
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'dic' is not defined
>>> #注意：clear 和del 是不同的，clear只是清空，但是del则是
... #将整个变量删除，相当于没定义

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

lesson2-java虚拟机之jvm结构
﻿﻿
网上找了一大圈，对于java虚拟机，还是不清不楚。这张算是比较靠谱的图了。自己参考Java虚拟机规范 Java SE7版，研究了下java虚拟机的结构，浅显理解吧。下面根据这个图，理解下各个部分。

以上是JAVA虚拟机的结构图，这张图对应了很多jvm机制，比如java的类加载和执行机制，比如java的垃圾回收机制。本文专注于java虚拟机的结构。
在了解java虚拟机的结构之前，我们先大概了解下java虚拟机中可以操作的数据类型。

与java语言类似，jvm可以操作的数据类型可以分为两类:原始类型(primitive type，也常被称为原生类型，基本类型)和引用类型(reference type)。jvm希望尽可能多的类型检查能在程序运行之前完成，即编译器应当在编译期间尽最大努力，完成可能的类型检查，使得虚拟机在运行期间无需进行这些操作。
原始数据类型包括数值类型，boolean类型和returnAddress类型。其中数值类型包括整数类型和浮点类型。
整型有byte，short，int，long，均为有符号二进制补码，默认都为0，char型为16位无符号整数表示，指向基本多文种平面的Unicode码点，以UTF-16编码，默认为Unicode的null码点(\u0000)。
boolean类型为true和false，默认是false。boolean类型的数值，在编译之后，都使用jvm中的int数据类型来代替。jvm会将true映射为1，false映射为0。
returnAddress类型表示一条字节码指令的操作码，在虚拟机支持的所有原始类型中，只有该类型不能直接与java语言的数据类型对应。
浮点类型值得强调的一点是，该类型包含5个特殊数值，正数零，负数零，正无穷大，负无穷大，NaN。在浮点数中，整数0和负数0是相等的，但1.0/0.0会产生正无穷大结果，1.0/-0.0会产生负无穷大结果。NaN是无序的，对它进行任何的数值比较和等值测试，都会返回false。任何数字和NaN进行非等值比较都会返回true，除了其本身以外。
引用数据类型包括，类类型，数组类型，接口类型，默认值是null。在引用类型中有一个特殊的值，null。当一个引用不指向任何对象的时候，它的值就是null，在没有上下文的情况下不具备任何实际的类型，但在有上下文时，其可转换为任意的引用类型。
以上是针对虚拟机的数据类型的简要介绍。下面是运行时数据区的解释。
1.PC寄存器
jvm可以支持多条线程同时执行，每一条jvm线程都有自己私有的pc寄存器。在任意的时刻，一条jvm线程只会执行一个方法的代码，这个正在被执行的方法称为该线程的当前方法，如果这个方法不是native的，那么pc寄存器就保存jvm正在执行的字节码指令的地址，如果该方法是native的，那么pc寄存器的值是undefined。pc寄存器的容量至少应当能保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。
2.Java栈
每一个jvm线程都有自己私有的java虚拟机栈，这个栈和线程同时创建，用于存储栈帧。与传统语言的栈类似，存储局部变量以及中间过程。此外，java栈在方法调用和返回中也扮演了重要角色，因为除了栈帧的出栈和入栈以外，Java栈不再受其他因素的影响，所以栈帧可以在堆中分配，java栈所使用的内存不需要保证是连续的。java栈可以被实现成固定大小的或者是根据计算可动态扩展和收缩的。如果采用固定大小的，那么这个容量应该在jvm线程创建的时候确定。java虚拟机栈发生异常的情况有如下两种:1.线程请求分配的栈容量超过java栈的最大容量，此时会跑出StackOverflowError。2.如果是动态扩展的并且已经尝试过去获取更大的栈空间，但是无法申请到足够的内存去完成扩展，或者在创建新线程时没有足够的内存去创建对应的虚拟机栈，此时会跑出OutOfMemoryError。
3.java堆
java堆是所有jvm线程共享的运行时内存区，也是所有类实例和数组对象分配内存的区域。java堆在虚拟机启动的时候被创建，它存储了被自动内存管理系统(垃圾收集器)所管理的各种对象，这些受管理的对象无需也无法被显示地销毁。java堆的容量可以是固定大小，也可以是程序执行时动态扩展，并在不需要过多空间时自动收缩。java堆所使用的内存不需要保证是连续的。java堆发生异常的情况是，当实际所需的内存超过了自动内存管理系统所能提供的最大容量时，java虚拟机会抛出一个OutOfMemoryError异常。
4.方法区
在java虚拟机中，方法区是可供各个线程共享的运行时内存区。方法区和传统语言中的编译代码存储区或者操作系统的正文段的作用类似，它存储了每一个类的结构信息，例如运行时常量池，字段和方法数据，构造函数和普通方法的字节码，还包括一些类，实例，接口初始化时用到的特殊方法。(特殊方法后面会补充解释)。方法区在虚拟机启动的时候创建，它的容量可以是固定大小，也可以是程序执行时动态扩展，并在不需要过多空间时自动收缩。方法区在实际内存空间中可以是不连续的。如果方法区的内存空间不能满足内存分配请求，java虚拟机将抛出一个OutOfMemoryError异常。运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式(常量池表后面会补充解释)。它包括了若干种不同的常量，从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段的引用。每一个运行时常量池都在虚拟机的方法区中分配。在加载类和接口到虚拟机后，就创建了对应的运行时常量池。会抛出OutOfMemoryError异常。
当虚拟机运行Java程序时，它会查找使用存储在方法区中的类型信息。由于所有线程都共享方法区，因此它们对方法区数据的访问必须被设计为是线程安全的。比如，假设同时有两个线程都企图访问一个名为Lava的类，而这个类还没有被装入虚拟机，那么，这时只应该有一个线程去装载它，而另一个线程则只能等待。
　　对于每个装载的类型，虚拟机都会在方法区中存储以下类型信息：
　　这个类型的全限定名
　　这个类型的直接超类的全限定名（除非这个类型是java.lang.Object，它没有超类）
　　这个类型是类类型还是接口类型
　   这个类型的访问修饰符（public、abstract或final的某个子集）
　　任何直接超接口的全限定名的有序列表
　　除了上面列出的基本类型信息外，虚拟机还得为每个被装载的类型存储以下信息：
　　该类型的常量池
　　字段信息
　　方法信息
　　除了常量以外的所有类（静态）变量
　　一个到类ClassLoader的引用
　　一个到Class类的引用
　　常量池
　　虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用常量的一个有序集合，包括直接常量和对其他类型、字段和方法的符号引用。池中的数据项就像数组一样是通过索引访问的。因为常量池存储了相应类型所用到的所有类型、字段和方法的符号引用，所以它在Java程序的动态连接中起着核心的作用。
　　字段信息
　　对于类型中声明的每一个字段。方法区中必须保存下面的信息。除此之外，这些字段在类或者接口中的声明顺序也必须保存。
　　字段名
　　字段的类型
　　字段的修饰符（public、private、protected、static、final、volatile、transient的某个子集）
　　方法信息
　　对于类型中声明的每一个方法，方法区中必须保存下面的信息。和字段一样，这些方法在类或者接口中的声明顺序也必须保存。
　　方法名
　　方法的返回类型（或void）
　　方法参数的数量和类型（按声明顺序）
　　方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的某个子集）
　　除了上面清单中列出的条目之外，如果某个方法不是抽象的和本地的，它还必须保存下列信息：
　　方法的字节码（bytecodes）
　　操作数栈和该方法的栈帧中的局部变量区的大小
　　异常表
　　类（静态）变量
　　类变量是由所有类实例共享的，但是即使没有任何类实例，它也可以被访问。这些变量只与类有关——而非类的实例，因此它们总是作为类型信息的一部分而存储在方法区。除了在类中声明的编译时常量外，虚拟机在使用某个类之前，必须在方法区中为这些类变量分配空间。
　　而编译时常量（就是那些用final声明以及用编译时已知的值初始化的类变量）则和一般的类变量处理方式不同，每个使用编译时常量的类型都会复制它的所有常量到自己的常量池中，或嵌入到它的字节码流中。作为常量池或字节码流的一部分，编译时常量保存在方法区中——就和一般的类变量一样。但是当一般的类变量作为声明它们的类型的一部分数据面保存的时候，编译时常量作为使用它们的类型的一部分而保存。
　　指向ClassLoader类的引用
　　每个类型被装载的时候，虚拟机必须跟踪它是由启动类装载器还是由用户自定义类装载器装载的。如果是用户自定义类装载器装载的，那么虚拟机必须在类型信息中存储对该装载器的引用。这是作为方法表中的类型数据的一部分保存的。
　　虚拟机会在动态连接期间使用这个信息。当某个类型引用另一个类型的时候，虚拟机会请求装载发起引用类型的类装载器来装载被引用的类型。这个动态连接的过程，对于虚拟机分离命名空间的方式也是至关重要的。为了能够正确地执行动态连接以及维护多个命名空间，虚拟机需要在方法表中得知每个类都是由哪个类装载器装载的。
　　指向Class类的引用
　　对于每一个被装载的类型（不管是类还是接口），虚拟机都会相应地为它创建一个java.lang.Class类的实例，而且虚拟机还必须以某种方式把这个实例和存储在方法区中的类型数据关联起来。
　　在Java程序中，你可以得到并使用指向Class对象的引用。Class类中的一个静态方法可以让用户得到任何已装载的类的Class实例的引用。

public static Class<?> forName(String className)

　　比如，如果调用forName("java.lang.Object")，那么将得到一个代表java.lang.Object的Class对象的引用。可以使用forName()来得到代表任何包中任何类型的Class对象的引用，只要这个类型可以被（或者已经被）装载到当前命名空间中。如果虚拟机无法把请求的类型装载到当前命名空间，那么会抛出ClassNotFoundException异常。
 
　　另一个得到Class对象引用的方法是，可以调用任何对象引用的getClass()方法。这个方法被来自Object类本身的所有对象继承：

public final native Class<?> getClass();

　　比如，如果你有一个到java.lang.Integer类的对象的引用，那么你只需简单地调用Integer对象引用的getClass()方法，就可以得到表示java.lang.Integer类的Class对象。
　　方法区使用实例
　　为了展示虚拟机如何使用方法区中的信息，下面来举例说明：

class Lava {

    private int speed = 5;
    void flow(){
        
    }
}


public class Volcano {
    
    public static void main(String[] args){
        Lava lava = new Lava();
        lava.flow();
    }
}

　　不同的虚拟机实现可能会用完全不同的方法来操作，下面描述的只是其中一种可能——但并不是仅有的一种。
　　要运行Volcano程序，首先得以某种“依赖于实现的”方式告诉虚拟机“Volcano”这个名字。之后，虚拟机将找到并读入相应的class文件“Volcano.class”，然后它会从导入的class文件里的二进制数据中提取类型信息并放到方法区中。通过执行保存在方法区中的字节码，虚拟机开始执行main()方法，在执行时，它会一直持有指向当前类（Volcano类）的常量池（方法区中的一个数据结构）的指针。
　　注意：虚拟机开始执行Volcano类中main()方法的字节码的时候，尽管Lava类还没被装载，但是和大多数（也许所有）虚拟机实现一样，它不会等到把程序中用到的所有类都装载后才开始运行。恰好相反，它只会需要时才装载相应的类。
　　main()的第一条指令告知虚拟机为列在常量池第一项的类分配足够的内存。所以虚拟机使用指向Volcano常量池的指针找到第一项，发现它是一个对Lava类的符号引用，然后它就检查方法区，看Lava类是否已经被加载了。
　　这个符号引用仅仅是一个给出了类Lava的全限定名“Lava”的字符串。为了能让虚拟机尽可能快地从一个名称找到类，虚拟机的设计者应当选择最佳的数据结构和算法。
　　当虚拟机发现还没有装载过名为“Lava”的类时，它就开始查找并装载文件“Lava.class”，并把从读入的二进制数据中提取的类型信息放在方法区中。
　　紧接着，虚拟机以一个直接指向方法区Lava类数据的指针来替换常量池第一项（就是那个字符串“Lava”），以后就可以用这个指针来快速地访问Lava类了。这个替换过程称为常量池解析，即把常量池中的符号引用替换为直接引用。
　　终于，虚拟机准备为一个新的Lava对象分配内存。此时它又需要方法区中的信息。还记得刚刚放到Volcano类常量池第一项的指针吗？现在虚拟机用它来访问Lava类型信息，找出其中记录的这样一条信息：一个Lava对象需要分配多少堆空间。
　　JAVA虚拟机总能够通过存储与方法区的类型信息来确定一个对象需要多少内存，当JAVA虚拟机确定了一个Lava对象的大小后，它就在堆上分配这么大的空间，并把这个对象实例的变量speed初始化为默认初始值0。
　　当把新生成的Lava对象的引用压到栈中，main()方法的第一条指令也完成了。接下来的指令通过这个引用调用Java代码（该代码把speed变量初始化为正确初始值5）。另一条指令将用这个引用调用Lava对象引用的flow()方法。
5.本地方法栈
java虚拟机可能会用到传统的栈(C stack)来支持本地方法，即java语言以外的其他语言编写的方法。这个栈就是本地方法栈。当java虚拟机使用其他语言来实现指令集解释时，也会使用到本地方法栈。如果jvm不支持本地方法，并且自己也不依赖于传统栈，可以无需支持本地方法栈，如果支持，该栈一般在线程创建的时候按线程分配。本地方法栈可以被实现成固定大小的或者是根据计算可动态扩展和收缩的。如果采用固定大小的，那么这个容量应该在jvm线程创建的时候确定。发生异常的情况有如下两种:1.线程请求分配的栈容量超过栈的最大容量，此时会跑出StackOverflowError。2.如果是动态扩展的并且已经尝试过去获取更大的栈空间，但是无法申请到足够的内存去完成扩展，或者在创建新线程时没有足够的内存去创建对应的本地方法栈，此时会跑出OutOfMemoryError。
以上是关于运行时数据区的分类解释。下面对刚刚提到的一些概念进行解释。
6.栈帧
栈帧是用来存储数据和部分过程结果的数据结构，同时也用来处理动态链接，方法返回值和异常分派。栈帧随着方法的调用而创建，随着方法的结束而销毁，无论方法是正常完成还是异常完成，都算作方法结束。栈帧的存储空间分配在java虚拟机栈之中，每一个栈帧都有自己的本地变量表，操作数栈，和指向改方法所属类的运行时常量池的引用。本地变量表和操作数栈的容量，在编译期确定，并通过方法的code属性保存并提供给栈帧使用，code属性在后面会介绍到。当前栈帧，当前方法，当前类概念略过。如果当前方法调用了其他方法，或者当前方法执行结束，那么这个栈帧就不再是当前栈帧。栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一个线程的栈帧。
7.特殊方法
在java虚拟机层面上，java编程语言中的构造器是以一个名为init的特殊实例初始化的形式出现的。init这个方法的名称是由编译期命名的，因为它并非一个合法的java方法名，不可能通过程序编码实现。实例初始化方法只能在实例初始化期间，通过java虚拟机的invokespecial指令调用，只有在实例正在构造时，实例初始化方法才可以访问。一个类或者接口最多可以包含不超过一个类或者接口的初始化方法，类或者接口就是通过这个方法完成初始化的。这个方法是一个不包含参数的，返回类型为void的方法，名为clinit。
8.异常抛出
抛出异常的操作是java虚拟机中精确定义的程序控制权转移的操作。由java虚拟机执行的每个方法都会配有零个至多个异常处理器，异常处理器描述了其在方法代码中的有效作用范围，能处理的异常类型以及处理异常的代码所在的位置。要判断某个异常处理器是否可以处理某个具体的异常，需要同时检查异常出现的位置是否在异常处理的有效作用范围内，并且出现的异常是否是异常处理器声明的异常处理类型或者其子类型。当抛出异常时，java虚拟机搜索当前方法包含的各个异常处理器，如果能找到，则将代码控制权转移到异常处理器中描述的处理异常的分支中。
如果没有找到，并且当前方法调用期间确实发生了异常，那么当前方法操作的本地变量表，操作数栈都将被抛弃，随后它对应的栈帧出栈，线程的方法栈恢复到该方法调用者的栈帧中。未被处理的异常将在该方法的调用者栈帧中重新被抛出，并在整个方法调用链中不断地重复前面描述的处理过程，如果直到该方法调用栈的顶端，都没有找到合适的异常处理，那整个执行线程都将被终止。搜索异常处理器的顺序是很关键的， 在class文件中，每个方法的异常处理器都存在一张表中，运行时，当有异常抛出之后，java虚拟机会按照class文件中的异常处理器表描述的异常处理器顺序去搜索。需要注意的是，java虚拟机本身不会对异常处理器顺序进行排序，所以java语言中对异常处理的语义，实际上是通过编译器适当安排异常处理器在表中的顺序来协助完成的。只有在class文件中明确定义了异常处理器查找顺序，才能保证无论class文件通过何种途径产生，java虚拟机都能有一致的行为表现。
9.类装载子系统
在JAVA虚拟机中，负责查找并装载类型的那部分被称为类装载子系统。
　　JAVA虚拟机有两种类装载器：启动类装载器(bootstrap classloader)和用户自定义类装载器。前者是JAVA虚拟机实现的一部分，后者则是Java程序的一部分。由不同的类装载器装载的类将被放在虚拟机内部的不同命名空间中。
　　类装载器子系统涉及Java虚拟机的其他几个组成部分，以及几个来自java.lang库的类。比如，用户自定义的类装载器是普通的Java对象，它的类必须派生自java.lang.ClassLoader类。ClassLoader中定义的方法为程序提供了访问类装载器机制的接口。此外，对于每一个被装载的类型，JAVA虚拟机都会为它创建一个java.lang.Class类的实例来代表该类型。和所有其他对象一样，用户自定义的类装载器以及Class类的实例都放在内存中的堆区，而装载的类型信息则都位于方法区。
　　类装载器子系统除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及帮助解析符号引用。这些动作必须严格按以下顺序进行：
　　（1）装载——查找并装载类型的二进制数据。
　　（2）连接——指向验证、准备、以及解析（可选）。
　　　　●　验证　　确保被导入类型的正确性。
　　　　●　准备　　为类变量分配内存，并将其初始化为默认值。
　　　　●　解析　　把类型中的符号引用转换为直接引用。
　　（3）初始化——把类变量初始化为正确初始值。
　　每个JAVA虚拟机实现都必须有一个启动类装载器，它知道怎么装载受信任的类。
　　每个类装载器都有自己的命名空间，其中维护着由它装载的类型。所以一个Java程序可以多次装载具有同一个全限定名的多个类型。这样一个类型的全限定名就不足以确定在一个Java虚拟机中的唯一性。因此，当多个类装载器都装载了同名的类型时，为了惟一地标识该类型，还要在类型名称前加上装载该类型（指出它所位于的命名空间）的类装载器标识。
﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

LeetCode（38） Count and Say
题目
The count-and-say sequence is the sequence of integers beginning as follows: 
1, 11, 21, 1211, 111221, …
1 is read off as “one 1” or 11. 
11 is read off as “two 1s” or 21. 
21 is read off as “one 2, then one 1” or 1211. 
Given an integer n, generate the nth sequence.
Note: The sequence of integers will be represented as a string.
分析
这是一道根据规则推导题目，要求给定序列数n，求出该序列对应的字符串。 
 
规则如上图所示。
AC代码
class Solution {
public:
    string countAndSay(int n) {
        if (n <= 0)
            return NULL;

        //n=1时，结果为"1"
        string ret = "1";
        if (n == 1)
            return ret;
        else
        {
            for (int i = 2; i <= n; i++)
                ret = Count(ret);
        }//else
        return ret;

    }

    string Count(const string &str)
    {
        int size = strlen(str.c_str());
        //保存结果
        stringstream ret;
        //保存标识字符
        char flag = str[0];
        //计算标识字符的出现次数
        int count = 0 , i = 0;
        while( i < size )
        {
            //临时循环位
            int pos = i;
            while (str[pos] == flag)
            {
                count++;
                pos++;
            }//while
            ret << count << flag;
            flag = str[pos];
            count = 0;
            //设置下一个循环位
            i = pos;
        }//for
        return ret.str();
    }
};
GitHub测试程序源码

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【VBA研究】关闭保存工作簿时重新计算功能
作者：iamlaosong
为了提高VBA程序运行速度，我们一般会关闭屏幕更新，停止自动计算，如下：
Application.ScreenUpdating = False

Application.Calculation = xlManual

当返回自动计算模式时，系统自动把所有的公式计算一遍，即使不返回自动计算模式，关闭并保存文件时，系统也会自动计算所有公式，当公式复杂，数据量大时，关闭工作簿就会比较慢，如果不想计算，可以关闭这个功能：
Application.CalculateBeforeSave = False
虽然关闭这个功能可以提高关闭速度，但重新打开这个文件时，系统仍然会重新计算一遍，以便保证数据的一致性。



版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 3605 Escape（多重匹配之多对多的匹配）
题意：N个人要要到M个星球上去，告诉每个人可以去哪些星球，以及每个 星球可以住的人数，问所有的人时候都可以安排完 
这题和 HDU1669差不多，HDU1669是一对多的匹配，这是多对多的匹配，一对多的匹配是大家的limit都是一样的，多对多的匹配是大家的limit不都一样，每个人有自己的limit，所以开个数组记录每个人的limit

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<set>
#include<map>
#include<string>
#include<cstring>
#include<stack>
#include<queue>
#include<vector>
#include<cstdlib>
#define lson (rt<<1),L,M
#define rson (rt<<1|1),M+1,R
#define M ((L+R)>>1)
#define cl(a,b) memset(a,b,sizeof(a));
#define LL long long
#define P pair<int,int>
#define X first
#define Y second
#define pb push_back
#define fread(zcc)  freopen(zcc,"r",stdin)
#define fwrite(zcc) freopen(zcc,"w",stdout)
using namespace std;
const int maxn=100015;
const int inf=999999;


vector<int> G[maxn];
int Nx,limit[15],cnt[15];
int matching[15][maxn];
bool vis[15];
bool dfs(int u){
    int N=G[u].size();
    for(int i=0;i<N;i++){
        int v=G[u][i];
        if(vis[v])continue;
        vis[v]=true;
        if(cnt[v]<limit[v]){
            matching[v][cnt[v]++]=u;
            return true;
        }else {
            for(int i=0;i<cnt[v];i++){
                if(dfs(matching[v][i])){
                    matching[v][i]=u;
                    return true;
                }
            }
        }
    }
    return false;
}
bool hungar(){
    cl(cnt,0);
    for(int i=0;i<Nx;i++){
        cl(vis,false);
        if(!dfs(i))return false;
    }
    return true;
}
int main(){
    int n,m;
    while(~scanf("%d%d",&n,&m)){
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                int x;
                scanf("%d",&x);
                if(x)G[i].pb(j);
            }
        }
        for(int i=0;i<m;i++){
            scanf("%d",&limit[i]);
        }
        Nx=n;
        if(hungar()){
            puts("YES");
        }
        else {
            puts("NO");
        }
        for(int i=0;i<=n;i++)G[i].clear();
    }
    return 0;
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

AIZU2303marathon match 概率
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>

using namespace std;
#define LL long long
double p[200];
int t[200];
int v[200];
LL C[100][100];
double dp[105][55];

int main(){
    int n,m,l;
    cin >>  n >> m >> l;
    for(int i = 0;i < n;i++){
        int x,tt,vv;
        scanf("%d%d%d",&x,&tt,&vv);
        p[i] = x / 100.0,t[i] = tt,v[i] = vv;
    }

    for(int i = 0;i <= 50;i++){
        C[i][0] = 1;
        C[i][i] = 1;
        for(int j = 1;j < i;j++){
            C[i][j] = C[i-1][j]+C[i-1][j-1];
            //cout<<C[i][j] << endl;
        }
    }
    for(int i = 0;i < n;i++){
        dp[i][m+1] = 0;
        for(int j = m;j >= 0;j--){ //休息>j次
            dp[i][j] = dp[i][j+1] + C[m][j]*pow(p[i],j)*pow(1-p[i],m-j);
            //cout << dp[i][j] << endl;
        }
    }

    for(int i = 0;i < n;i++){
        double ans = 0;
        if(v[i] != 0){
            for(int j = 0;j <= m;j++){
                double ut = l*1.0/v[i] + j*t[i];
                double pa = C[m][j]*pow(p[i],j)*pow(1-p[i],m-j);
                for(int k = 0;k < n;k++){//赢k个人的概率
                    if(k != i){
                        if(v[k] == 0){
                            pa *= 1;
                            continue;
                        }
                        int tim;
                        if(t[k] == 0){
                            if(l*1.0/v[k] <= ut){
                                pa *= 0;
                            }
                            else{
                                pa *= 1;
                            }
                            continue;
                        }
                        tim = floor((ut-(l*1.0/v[k]))/t[k]);
                        while((tim*t[k]+l*1.0/v[k]) <= ut) tim++;
                        if(tim > m){
                            pa *= 0;
                        }
                        else if(tim < 0){
                            pa *= 1;
                        }else{
                            pa *= dp[k][tim];
                        }

                    }
                }
                //printf("%lf\n",pa);
                ans += pa;
            }
        }
        printf("%.8f\n",ans);
    }
    return 0;
}



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

java  运行时内存分配 堆和栈区别
java 运行时 内存 分配
一个java进程可以包含多个线程
一个Java进程对应唯一一个JVM实例
一个JVM实例唯一对应一个堆
每一个线程有一个自己私有的栈

这儿也可以看出线程共享进程的堆, 但不共享栈 
  这篇文章里有一道 线程和进程面试题

堆

堆是被线程共享的 
  一个进程只有一个堆 
  堆中存放对象本身和数组本身

java 中, 数组(比如 int[]) 也是继承Object对象, 不是继承Object[]
栈

数据结构里面讲了, 栈是先入后出 
  栈中存放的是对象的引用(声明和引用对象是有先后顺序的, 可能也是和栈有关)


堆和栈比较

栈的速度比堆快, 堆分配比栈灵活 
  一般来说, 可用的堆空间比栈大

静态存储区

这点好像有异议, java 到底有没有静态存储区? 
  一般 带有 static 关键字的就存放在静态存储区

细节的就不要深究了

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 3853 LOOPS (概率DP)

题意：一个方格矩阵r*c，现在从(1,1)走到(r,c)，假设当前走到的格子为(i,j)，停留原地概率为p1[i][j]，下一次移动到格子(i,j+1)概率为p2[i][j]，到(i+1,j)概率为p3[i][j]。p1[i][j]+p2[i][j]+p3[i][j]=1。三者需要消耗的能量均为2，问走到(r,c)需要消耗的能量




思路：比较基础的一道概率DP的题目

假设从（i,j）点到（r,c）点需要消耗的能量为dp[i][j]，

dp[i][j]= p1[i][j]*dp[i][j]+p2[i][j]*dp[i][j+1]+p3[i][j]*dp[i+1][j]+2



这时两边都有dp[i][j]，移项，dp[i][j]就可求了。




AC代码：


#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#include<string>
#include<map>
#include<stack>
#include<iostream>
#include<stdlib.h>
using namespace std;

#define esp 1e-6

const int maxn=1005;
typedef long long ll;

double dp[maxn][maxn];
int vis[maxn][maxn];
double p1[maxn][maxn];
double p2[maxn][maxn];
double p3[maxn][maxn];

int n,m;

double dfs(int i,int j)
{
    if(i==n && j==m)return 0;
    if(vis[i][j])return dp[i][j];
    if(i<1||i>n||j<1||j>m)return 0;
    if((1-p1[i][j])<esp)
    {
        vis[i][j]=1;
        return 0;
    }
    vis[i][j]=1;
    return dp[i][j]= (2.0+p2[i][j]*dfs(i,j+1)+p3[i][j]*dfs(i+1,j))*1.0/(1.0-p1[i][j]) ;
}

int main()
{
    while(scanf("%d %d",&n,&m)!=EOF)
    {
        memset(dp,0,sizeof(dp));
        memset(vis,0,sizeof(vis));
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                scanf("%lf%lf%lf",&p1[i][j],&p2[i][j],&p3[i][j]);
            }
        }
        printf("%.3lf\n",dfs(1,1));
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

【组合数学】【高精度】【prufer数列】【HNOI 2008】【bzoj 1005】明明的烦恼
1005: [HNOI2008]明明的烦恼
Time Limit: 1 Sec  Memory Limit: 162 MB
Submit: 3217  Solved: 1290

Description
自从明明学了树的结构,就对奇怪的树产生了兴趣…… 给出标号为1到N的点,以及某些点最终的度数,允许在任意两点间连线,可产生多少棵度数满足要求的树?
Input
第一行为N(0 < N < = 1000),接下来N行,第i+1行给出第i个节点的度数Di,如果对度数不要求,则输入-1
Output
一个整数,表示不同的满足要求的树的个数,无解输出0
Sample Input
3
1
-1
-1

Sample Output
2

HINT
两棵树分别为1-2-3;1-3-2

题解：
苦颓了一中午。。各种不会啊。。于是膜拜了一下题解——>非常神 
顺便学会了一种神奇的无根树的数列——>prufer数列 
要写高精乘高精真是懒得写了，于是偷懒写了一个压位。。
Code：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 1010
#define LL long long
#define p 100000

int n,m=0,s=0,d[N],su[N],ys[N],ans[N*10];

int in(){
    int x=0; char ch=getchar(); bool f=true;
    while (ch<'0' || ch>'9'){
        if (ch=='-') f=false;
        ch=getchar();
    }
    while (ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    if (!f) x=-x;
    return x;
}

void init(){
    for (int i=2; i<=N; i++){
        bool f=true;
        for (int j=2; j<=sqrt(i); j++)
            if (!(i%j)){
                f=false; break;
            }
        if (f) su[++su[0]]=i;
    }
}

void cheng(int x){
    for (int i=1; i<=ans[0]; i++) ans[i]*=x;
    for (int i=1; i<=ans[0]; i++)
        ans[i+1]+=ans[i]/p,ans[i]%=p;
    while (ans[ans[0]+1]){
        ans[0]++;
        ans[ans[0]+1]+=ans[ans[0]]/p;
        ans[ans[0]]%=p;
    }
}

void fenjie(int x,int y){
    for (int i=1; i<=x; i++){
        int xx=i;
        for (int j=1; j<=su[0]; j++){
            if (xx<=1) break;
            while (!(xx%su[j]))
                ys[j]+=y,xx/=su[j];
        }
    }
}

void out(){
    printf("%d",ans[ans[0]]);
    for (int i=ans[0]-1; i>=1; i--)
        printf("%05d",ans[i]);
    printf("\n");
}

int main(){
    n=in(); ans[++ans[0]]=1;
    if (n==1){
        int x=in();
        if (!x) printf("1\n");
        else printf("0\n");
        return 0;
    }
    for (int i=1; i<=n; i++){
        d[i]=in();
        if (!d[i]){
            printf("0\n");
            return 0;
        }
        if (d[i]==-1) m++;
        else d[i]--,s+=d[i];
    }
    if (s>n-2){
        printf("0\n");
        return 0;
    }

    init();
    fenjie(n-2,1),fenjie(n-2-s,-1);
    for (int i=1; i<=n; i++)
        if (d[i]>0) fenjie(d[i],-1);
    for (int i=1; i<=su[0]; i++)
        while (ys[i]--) cheng(su[i]);
    for (int i=1; i<=n-2-s; i++) cheng(m);

    out();
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HDU 3268 Columbus’s bargain


Columbus’s bargain
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 1829    Accepted Submission(s): 465



Problem Description

On the evening of 3 August 1492, Christopher Columbus departed from Palos de la Frontera with a few ships, starting a serious of voyages of finding a new route to India. As you know, just in those voyages, Columbus discovered the America continent which he
 thought was India.

Because the ships are not large enough and there are seldom harbors in his route, Columbus had to buy food and other necessary things from savages. Gold coins were the most popular currency in the world at that time and savages also accept them. Columbus wanted
 to buy N kinds of goods from savages, and each kind of goods has a price in gold coins. Columbus brought enough glass beads with him, because he knew that for savages, a glass bead is as valuable as a gold coin. Columbus could buy an item he need only in four
 ways below:

1.  Pay the price all by gold coins.
2.  Pay by ONE glass bead and some gold coins. In this way, if an item’s price is k gold coins, Columbus could just pay k – 1 gold coins and one glass bead.
3.  Pay by an item which has the same price.
4.  Pay by a cheaper item and some gold coins. 

Columbus found out an interesting thing in the trade rule of savages: For some kinds of goods, when the buyer wanted to buy an item by paying a cheaper item and some gold coins, he didn’t have to pay the price difference, he can pay less. If one could buy an
 item of kind A by paying a cheaper item of kind B plus some gold coins less than the price difference between B and A, Columbus called that there was a “bargain” between kind B and kind A. To get an item, Columbus didn’t have to spend gold coins as many as
 its price because he could use glass beads or took full advantages of “bargains”. So Columbus wanted to know, for any kind of goods, at least how many gold coins he had to spend in order to get one – Columbus called it “actual price” of that kind of goods. 

Just for curiosity, Columbus also wanted to know, how many kinds of goods are there whose “actual price” was equal to the sum of “actual price” of other two kinds.


 


Input

There are several test cases. 
The first line in the input is an integer T indicating the number of test cases ( 0 < T <= 10).
For each test case:
The first line contains an integer N, meaning there are N kinds of goods ( 0 < N <= 20). These N kinds are numbered from 1 to N.

Then N lines follow, each contains two integers Q and P, meaning that the price of the goods of kind Q is P. ( 0 <Q <=N, 0 < P <= 30 )
The next line is a integer M( 0 < M <= 20 ), meaning there are M “bargains”. 

Then M lines follow, each contains three integers N1, N2 and R, meaning that you can get an item of kind N2 by paying an item of kind N1 plus R gold coins. It’s guaranteed that the goods of kind N1 is cheaper than the goods of kind N2 and R is none negative
 and less than the price difference between the goods of kind N2 and kind N1. Please note that R could be zero. 


 


Output

For each test case:
Please output N lines at first. Each line contains two integers n and p, meaning that the “actual price” of the goods of kind n is p gold coins. These N lines should be in the ascending order of kind No. . 

Then output a line containing an integer m, indicating that there are m kinds of goods whose “actual price” is equal to the sum of “actual price” of other two kinds.


 


Sample Input

1
4
1 4
2 9
3 5
4 13
2
1 2 3
3 4 6


 


Sample Output

1 3
2 6
3 4
4 10
1


 




题意：告诉n个物品以及购买每个物品需要的金币数量，对于每个物品，可以且只可以用一个玻璃球来进行代替一个金币，等价的物品之间可以相互交换，告诉a,b,c三个数，b物品可以用a物品加上c个金币来进行交换，求每个货物最少需要多少个金币，以及有多少个货物能够用其他两个货物来进行代替交换。
思路：可以抽象成为最短路问题， 把每个货物看成一个端点，设置一个0点，0到i的权值就是第i个物品的价格，于是可以用floyd求解最短路的方式来求出每个端点最小的价格


#include <iostream>
#include <stdio.h>
#include <string>
#include <cstring>
#include <cmath>
#include <queue>
#define INF 99999999
using namespace std;

int T;

int val;
int mp[1009][1009];

int main()
{
    scanf("%d",&T);
    int k;
    int n;
    int a,b,c;

    while(T--)
    {
        scanf("%d",&n);
       for(int i=0;i<=n;i++)
           for(int j=0;j<=n;j++)
           {
               if(i==j) mp[i][j]=0;
               mp[i][j]=INF;
           }


        for(int i=1;i<=n;i++)
        {
            scanf("%d %d",&k,&val);
            mp[0][i]=val-1;
        }

        scanf("%d",&k);
        for(int i=0;i<k;i++)
        {
            scanf("%d%d%d",&a,&b,&c);
            mp[a][b]=c;
        }

        for(int i=0;i<=n;i++)//存在等价交换
            for(int j=0;j<=n;j++)
        {
            if(mp[0][i]==mp[0][j])
                mp[i][j]=mp[j][i]=0;
        }

        for(int k=0;k<=n;k++)
            for(int i=0;i<=n;i++)
                for(int j=0;j<=n;j++)
                    mp[i][j]=min(mp[i][j],mp[i][k]+mp[k][j]);


        for(int i=1;i<=n;i++)
            printf("%d %d\n",i,mp[0][i]);


        int ans=0;
        for(int i=1;i<=n;i++)
        {
            int flag=0;
            for(int j=1;j<=n;j++)
            {
                if(i==j) continue;
                for(int k=1;k<=n;k++)
                {
                    if(j==k || i==k) continue;
                    if(mp[0][i]==mp[0][j]+mp[0][k])
                    {
                        flag=1;
//                        cout<<"i="<<i<<" ";
//                        cout<<"j="<<j<<" "<<"k="<<k<<endl;
                    }

                }
            }
            if(flag)
            ans++;
        }

        printf("%d\n",ans);

    }
    return 0;
}













版权声明：本文为博主原创文章，未经博主允许不得转载。

快学Scala习题解答—第十六章 XML处理

16.XML处理

16.1<fred/>(0) 得到什么？<fred/>(0)(0)呢？为什么？

回答：<fred/>(0) 得到一个scala.xml.Node，<fred/>(0)(0)也是得到scala.xml.Node。

因为scala.xml.Node 实现了方法 def apply(i: Int): Node，所以支持串接调用。

注意：scala-xml-x.x.x.jar 需要另外导入。


scala> val a = <fred/>
a: scala.xml.Elem = <fred/>
scala> a(0)
res2: scala.xml.Node = <fred/>
scala> a(0)(0)
res3: scala.xml.Node = <fred/>
scala> a(0)(0)(0)
res4: scala.xml.Node = <fred/>
scala> a(0)(0)(0)(0)
res5: scala.xml.Node = <fred/>



? 



16.2如下代码的值是什么？

<ul>

    <li>Opening bracket: [</li>

    <li>Closing bracket: ]</li>   

    <li>Opening brace: {</li>   

  <li>Closing brace: }</li>   

</ul>  


你如何修复它？

回答：会有编译错误。要在XML字面量中包含左花括号和右花括号，连续写两个即可。


package ex16_02
import scala.xml._
object Main extends App{
/*
Multiple markers at this line:
in XML literal: in XML content, please use '}}' to express '}'
I encountered a '}' where I didn't expect one, maybe this tag isn't closed <li>
I encountered a '}' where I didn't expect one, maybe this tag isn't closed <li>
 */
  val a =
<ul>
    <li>Opening bracket: [</li>
    <li>Closing bracket: ]</li>   
    <li>Opening brace: {{</li>   
  <li>Closing brace: }}</li>   
</ul>
     
  println(a)
}
/*output:
<ul>
  <li>Opening bracket: [</li>
  <li>Closing bracket: ]</li>   
  <li>Opening brace: {</li>   
  <li>Closing brace: }</li>   
</ul>
*/




?



16.3 比对 <li>Fred</li> match { case <li>{Text(t)}</li> => t } 和

<li>{"Fred"}</li> match { case <li>{Text(t)}</li> => t }

为什么它们的行为不同？

回答：内嵌表达式中的字符串并不会被转成Text节点而是Atom[String]节点。这和普通的Text节点还是有区别的——Text是Atom[String]的子类。

这对于保存文档没有问题。但如果你事后打算以Text节点的模式对它做匹配时，匹配会失败。像这种情况你应该插入Text节点而不是字符串。


import scala.xml._
object Main extends App {
  val a = <li>Fred</li> match { case <li>{ Text(t) }</li> => t }
  //val b = <li>{ "Fred" }</li> match { case <li>{ Text(t) }</li> => t }
  val c = <li>{ Text("Fred") }</li> match { case <li>{ Text(t) }</li> => t }
  //println("a=" + a)
  println("c=" + c)
}
/*output:
a=Fred
b: Exception in thread "main" scala.MatchError: <li>Fred</li> (of class scala.xml.Elem)
c=Fred
*/




?



16.4读取一个XHTML文件并打印所有不带alt属性的img元素。


import scala.xml._
object Main extends App {
  val root = XML.loadFile("./src/test.xhtml")
  val imgs: NodeSeq = root \\ "img"
  // img \ "@alt " 's type is scala.xml.NodeSeq
  for (img <- imgs if (img \ "@alt").text == "") println(img)
}
/*output:
<img src="hamster.jpg"/>
<img src="frog.jpg"/>
*/
test.xhtml



<html>
<head>
<title>My Scala</title>
</head>
<body>
<p>Hello Scala</p>
<p><img src="hamster.jpg"/></p>
<p><img src="frog.jpg"/></p>
<p><img src="dog.jpg" alt="inu"/></p>
</body>
</html>




? 



16.5打印XHTML文件中所有图像的名称。即，打印所有位�%@A�img元素内的src属性值。


import scala.xml._
object Main extends App {
  val root = XML.loadFile("./src/test.xhtml")
  val imgs: NodeSeq = root \\ "img"
  // img \ "@alt " 's type is scala.xml.NodeSeq
  imgs.foreach { x => println(x \ "@src" text) }
}
/*output:
hamster.jpg
frog.jpg
dog.jpg
*/




?



16.6读取XHTML文件并打印一个包含了文件中给出的所有超链接及其URL的表格。

即，打印所有a元素的child文本和href属性。


import scala.xml._
object Main extends App {
  val root = XML.loadFile("./src/oschina.xhtml")
  val imgs: NodeSeq = root \\ "a"
  imgs.foreach { x => 
    val child = x.child
    println("%s: %s".format(child(0).text, x.attribute("href").getOrElse("")))
    }
}
/*output:
Android: http://www.oschina.net/app
iPhone: http://www.oschina.net/app
WP7: http://www.oschina.net/app
*/




?



oschina.xml:


<html>
<head>
<title>My Scala</title>
</head>
<body>
<p>Hello Scala</p>
<p><img src="hamster.jpg"/></p>
<p><img src="frog.jpg"/></p>
<p><img src="dog.jpg" alt="inu"/></p>
<ul>
<li><a href="http://www.oschina.net/app" class='android' title='Android客户端'>Android</a></li>
<li><a href="http://www.oschina.net/app" class='iphone' title='iPhone 客户端'>iPhone</a></li>
<li><a href="http://www.oschina.net/app" class='wp7' title='Windows Phone 客户端'>WP7</a></li>
</ul>
</body>
</html>




? 



16.7编写一个函数，带一个类型为Map[String, String]的参数，返回一个dl元素，其中针对映射中每个键对应有一个dt，每个值对应有一个dd。例如：

Map("A" -> "1", "B" -> "2")

应产出 <dl><dt>A</dt><dd>1</dd><dt>B</dt><dd>2</dd></dl>


import scala.xml._
object Main extends App {
 def genDl(input: Map[String,String])={
   <dl>{for((k,v) <- input) yield <dt>{k}</dt><dd>{v}</dd>}</dl>
 }
  
 val input = Map("A" -> "1", "B" -> "2")
 println(genDl(input))
}
/*output:
<dl><dt>A</dt><dd>1</dd><dt>B</dt><dd>2</dd></dl>
*/




?



16.8编写一个函数，接受dl元素，将它转成Map[String,String]。该函数应该是前一个练习中的反向处理，前提是所有dt后代都是唯一（各不相同）的。


import scala.xml._
import scala.collection.mutable.Map
object Main extends App {
  def dl2map(input: scala.xml.Elem): Map[String, String] = {
    val map = Map[String, String]()
    val keys = input \ "dt"
    val values = input \ "dd"
    for (i <- 0 until keys.size) map += keys(i).text -> values(i).text
    map
  }
  val input = <dl><dt>A</dt><dd>1</dd><dt>B</dt><dd>2</dd></dl>
  val obj = dl2map(input)
  println(obj)
}
/*output:
Map(A -> 1, B -> 2)
*/




?



16.9对一个XHTML文档进行变换，对所有不带alt属性的img元素添加一个alt="TODO"属性，其余内容完全不变。


import scala.xml._
import scala.xml.transform._
object Main extends App {
  def transform(filename: String) {
    val root = XML.loadFile(filename)
    val rule1 = new RewriteRule {
      override def transform(n: Node) = n match {
        case x @ <img/> => if (x.attributes("alt") == null) x.asInstanceOf[Elem] % Attribute(null, "alt", "TODO", scala.xml.Null) else x
        case _ => n
      }
    }
    val transformed = new RuleTransformer(rule1).transform(root)
    //println(transformed)
    scala.xml.XML.save("./src/test_new.xhtml", transformed(0))
  }
  transform("./src/test.xhtml")
}
/*output:
<html>
<head>
<title>My Scala</title>
</head>
<body>
<p>Hello Scala</p>
<p><img alt="TODO" src="hamster.jpg"/></p>
<p><img alt="TODO" src="frog.jpg"/></p>
<p><img alt="inu" src="dog.jpg"/></p>
</body>
</html>
*/









16.10编写一个函数，读取XHTML文档，执行前一个练习中的变换，并保存结果。确保保存了DTD及所有CDATA内容。


import scala.xml._
import scala.xml.transform._
import scala.xml.parsing.ConstructingParser
import scala.xml.dtd._
object Main extends App {
  def transform(filename: String) {
    val parser = ConstructingParser.fromFile(new java.io.File(filename), preserveWS = true)
    val doc = parser.document
    val root = doc.docElem
    val rule1 = new RewriteRule {
      override def transform(n: Node) = n match {
        case x @ <img/> => if (x.attributes("alt") == null) x.asInstanceOf[Elem] % Attribute(null, "alt", "TODO", scala.xml.Null) else x
        case _          => n
      }
    }
    val transformed = new RuleTransformer(rule1).transform(root)
    //println(transformed)
    scala.xml.XML.save("./src/cdata_new.xhtml", transformed(0),
      enc = "UTF-8",
      xmlDecl = true,
      doctype = DocType("html",
        PublicID("-//W3C//DTD XHTML 1.0 Strict//EN",
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"),
        Nil))
  }
  transform("./src/cdata.xhtml")
}
/*output:
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>My Scala</title>
<script>
<![CDATA[
function matchwo(a,b)
{
if (a < b && a < 0) then
  {
  return 1;
  }
else
  {
  return 0;
  }
}
]]>
</script>
</head>
<body>
<!-- This is a comment -->
<p>Hello Scala</p>
<p><img alt="TODO" src="hamster.jpg"/></p>
<p><img alt="TODO" src="frog.jpg"/></p>
<p><img alt="inu" src="dog.jpg"/></p>
</body>
</html>
*/原文博客地址:http://blog.csdn.net/u011225629/article/details/47618015





?



版权声明：本文为博主原创文章，未经博主允许不得转载。

BZOJ 3107 CQOI2013 二进制a+b 构造
题目大意：给定nn位二进制数a,b,ca,b,c，要求重组三个数的各个位，使得a′+b′=c′a'+b'=c'且最小化c′c'
一个构造题咋这么多人写DP……
不考虑位数限制，显然答案只与三个数中11的个数有关 
令x=cnta,y=cntb,z=cntcx=cnt_a,y=cnt_b,z=cnt_c，其中cntxcnt_x代表xx中11的个数 
不妨令x≥yx\geq y 
以下用x=10,y=5x=10,y=5来举例
若z=1z=1，构造方式如下： 
000001111111111000001111111111 
011110000000001011110000000001 
100000000000000100000000000000 
证明：显然最低位肯定是1+1=101+1=10，然后再往上肯定都是单个11，构造方式唯一
若1<z<y1<z<y，构造方式如下： 
00011111111110001111111111 
01100000001110110000000111 
10000000001101000000000110 
证明： 
若最低位为1+0=11+0=1，则去掉最低位后变成了(x−1,y,z−1)(x-1,y,z-1)或(x,y−1,z−1)(x,y-1,z-1)，二者都需要x+y−z+1x+y-z+1位，算上最低位有x+y−z+2x+y-z+2位，而这种构造法只需要x+y−z+1x+y-z+1位，由数学归纳法可证最低位为1+0=11+0=1不优 
那么最低位为1+1=101+1=10就确定了。然后……然后自己YY吧我没证出来不过应该是对的，感觉数学归纳法啥的能证
若z=yz=y，构造方式如下： 
0111111111101111111111 
0000001111100000011111 
1000001111010000011110 
证明：这种构造方式保证a′a'和b′b'都是最小的，显然最优
若y<z≤xy<z\leq x，构造方式如下： 
0111111111101111111111 
0001111100000011111000 
1001111011110011110111 
证明： 
显然c′c'最小x+1x+1位 
如果想要使c′c'减小，只能将前面的那些00往前挪或将最后一个00往前挪 
显然前面那些00挪不动，只能将最后一个00往前挪(比如变成10011011111001101111) 
这说明最后z−yz-y位必须是1+0=11+0=1 
那么去掉最后z−yz-y位，问题变成了(x+y−z,y,y)(x+y-z,y,y) 
由y=zy=z的证明可得这种构造法是最优的
若x<z<x+yx<z<x+y，构造方式如下： 
01111111111000111111111100 
01110000000110111000000011 
11101111111111110111111111 
证明： 
显然答案至少z+1z+1位，因为zz个1−x1-x个11一定会得到z−xz-x个11， 
而z−x<yz-x<y，矛盾 
然后位数确定后证明就同上了
若z=x+yz=x+y，构造方式如下： 
000001111111111000001111111111 
111110000000000111110000000000 
111111111111111111111111111111 
证明：这个用证明么。。。
然后……就完事了
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int Digit(int x)
{
    int re=0;
    while(x)
        ++re,x>>=1;
    return re;
}
int Count(int x)
{
    int re=0;
    while(x)
        x^=x&-x,++re;
    return re;
}
int main()
{
    //freopen("3107.in","r",stdin);
    //freopen("3107.out","w",stdout);
    int x,y,z,limit,ans;
    cin>>x>>y>>z;
    limit=max( max( Digit(x) , Digit(y) ) , Digit(z) );
    x=Count(x);y=Count(y);z=Count(z);
    if(x<y) swap(x,y);
    if(z<=y) ans=((1<<x)-1)+((1<<z)-1|((1<<y-z)-1<<x));
    else if(z<=x) ans=((1<<x)-1)+((1<<y)-1<<z-y);
    else if(z<=x+y) ans=((1<<x)-1<<z-x)+((1<<z-x)-1|((1<<x+y-z)-1<<z+z-x-y));
    else ans=-1;
    if(Digit(ans)>limit) ans=-1;
    cout<<ans<<endl;
    return 0;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 3435 A new Graph Game 【无向图判断权值最小哈密顿环】【KM算法】






A new Graph Game
Time Limit: 8000/4000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 1934    Accepted Submission(s): 827



Problem Description

An undirected graph is a graph in which the nodes are connected by undirected arcs. An undirected arc is an edge that has no arrow. Both ends of an undirected arc are equivalent--there is no head or tail. Therefore, we represent an edge in an undirected graph
 as a set rather than an ordered pair.
Now given an undirected graph, you could delete any number of edges as you wish. Then you will get one or more connected sub graph from the original one (Any of them should have more than one vertex).
You goal is to make all the connected sub graphs exist the Hamiltonian circuit after the delete operation. What’s more, you want to know the minimum sum of all the weight of the edges on the “Hamiltonian circuit” of all the connected sub graphs (Only one “Hamiltonian
 circuit” will be calculated in one connected sub graph! That is to say if there exist more than one “Hamiltonian circuit” in one connected sub graph, you could only choose the one in which the sum of weight of these edges is minimum).
  For example, we may get two possible sums:


(1)  7 + 10 + 5 = 22
(2)  7 + 10 + 2 = 19
(There are two “Hamiltonian circuit” in this graph!)
 


Input

In the first line there is an integer T, indicates the number of test cases. (T <= 20)
In each case, the first line contains two integers n and m, indicates the number of vertices and the number of edges. (1 <= n <=1000, 0 <= m <= 10000)
Then m lines, each line contains three integers a,b,c ,indicates that there is one edge between a and b, and the weight of it is c . (1 <= a,b <= n, a is not equal to b in any way, 1 <= c <= 10000)

 


Output

Output “Case %d: “first where d is the case number counted from one. Then output “NO” if there is no way to get some connected sub graphs that any of them exists the Hamiltonian circuit after the delete operation. Otherwise, output the minimum sum of weight
 you may get if you delete the edges in the optimal strategy.


 


Sample Input

3

3 4
1 2 5
2 1 2
2 3 10
3 1 7 

3 2
1 2 3
1 2 4

2 2
1 2 3
1 2 4

 


Sample Output

Case 1: 19
Case 2: NO
Case 3: 6
HintIn Case 1:
You could delete edge between 1 and 2 whose weight is 5. 

In Case 2:
It’s impossible to get some connected sub graphs that any of them exists the Hamiltonian circuit after the delete operation. 

 










题意：给你一个N个点M条无向边的图。问你存不存在哈密顿环，若不存在输出NO，反之输出 权值之和最小的哈密顿环。




思路：费用流我不会写o(╯□╰)o，TLE到死 。   KM算法直接就过了，无奈了。  
气死了！！！ 又把做过的费用流用KM刷了一遍。以后碰到这样的题目果断KM，费用流先靠边。


AC代码：2458ms


#include <cstdio>
#include <cstring>
#include <algorithm>
#define INF 0x3f3f3f3f
#define MAXN 1010
using namespace std;
int lx[MAXN], ly[MAXN];
int Map[MAXN][MAXN];
bool visx[MAXN], visy[MAXN];
int slack[MAXN];
int match[MAXN];
int N, M;
void getMap()
{
    for(int i = 1; i <= N; i++)
    {
        for(int j = 1; j <= N; j++)
            Map[i][j] = -INF;//初始化
    }
    int a, b, c;
    while(M--)
    {
        scanf("%d%d%d", &a, &b, &c);
        if(-c > Map[a][b])//去重
            Map[a][b] = Map[b][a] = -c;
    }
}
int DFS(int x)
{
    visx[x] = true;
    for(int y = 1; y <= N; y++)
    {
        if(visy[y]) continue;
        int t = lx[x] + ly[y] - Map[x][y];
        if(t == 0)
        {
            visy[y] = true;
            if(match[y] == -1 || DFS(match[y]))
            {
                match[y] = x;
                return 1;
            }
        }
        else if(slack[y] > t)
            slack[y] = t;
    }
    return 0;
}
int k = 1;
void KM()
{
    memset(match, -1, sizeof(match));
    memset(ly, 0, sizeof(ly));
    for(int x = 1; x <= N; x++)
    {
        lx[x] = -INF;
        for(int y = 1; y <= N; y++)
            lx[x] = max(lx[x], Map[x][y]);
    }
    for(int x = 1; x <= N; x++)
    {
        for(int i = 1; i <= N; i++)
            slack[i] = INF;
        while(1)
        {
            memset(visx, false, sizeof(visx));
            memset(visy, false, sizeof(visy));
            if(DFS(x)) break;
            int d = INF;
            for(int i = 1; i <= N; i++)
            {
                if(!visy[i] && slack[i] < d)
                    d = slack[i];
            }
            for(int i = 1; i <= N; i++)
            {
                if(visx[i])
                   lx[i] -= d;
            }
            for(int i = 1; i <= N; i++)
            {
                if(visy[i])
                    ly[i] += d;
                else
                    slack[i] -= d;
            }
        }
    }
    //判断是否存在完美匹配
    int ans = 0;
    bool flag = true;
    for(int i = 1; i <= N; i++)
    {
        if(match[i] == -1 || Map[match[i]][i] == -INF)
        {
            flag = false;
            break;
        }
        ans += Map[match[i]][i];
    }
    printf("Case %d: ", k++);
    if(flag)
        printf("%d\n", -ans);
    else
        printf("NO\n");
}
int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
    {
        scanf("%d%d", &N, &M);
        getMap();
        KM();
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdu 1004
<span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px; background-color: rgb(255, 255, 255);">Let the Balloon Rise</span>
Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 90782 Accepted Submission(s): 34507


Problem Description
Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges' favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color
 and find the result.

This year, they decide to leave this lovely job to you. 



Input
Input contains multiple test cases. Each test case starts with a number N (0 < N <= 1000) -- the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case
 letters.

A test case with N = 0 terminates the input and this test case is not to be processed.



Output
For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case.



Sample Input

5
green
red
blue
red
red
3
pink
orange
pink
0



Sample Output

red
pink



Author
WU, Jiazhi


Source
ZJCPC2004  




</pre><pre name="code" class="cpp">#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

char color[1111][20],ch[20];
int number[1111],n;

int main ()
{
    int i,j;
    int ok, max, t, k;
    while (scanf ("%d",&n)==1&&n)
    {
        memset(number, 0, sizeof(number));
        memset(color, '\0', sizeof(color));
        k = 0;
        for (i=0; i<n; i++)
        {
            scanf ("%s",ch);
            ok = 0;
            for (j=0; j<k; j++)
            {
                if (strcmp(ch, color[j])==0)
                {
                    number[j]++;
                    ok = 1;
                }
            }
            if (!ok)
            {
                strcpy(color[k], ch);
                number[k]++;
                k++;
            }
        }
        max = 0;
        for (i=0; i<k; i++)
        {
            if (number[i] > max)
            {
                max = number[i];
                t = i;
            }
        }
        printf ("%s\n",color[t]);
    }
    return 0;
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

LeetCode: SingleNumIII
题目链接：https://leetcode.com/problems/single-number-iii/
题目：

Given an array of numbers nums, in which exactly two elements appear only
 once and all the other elements appear exactly twice. Find the two elements that appear only once.

For example:

Given nums = [1, 2, 1, 3, 2, 5], return [3,
 5].

Note:


The order of the result is not important. So in the above example, [5,
 3] is also correct.Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?
题意：给定一个数组nums，其中除了两个元素只出现一次外，其他元素均出现两次，找出仅出现一次的两个元素
  提示：1.对输出结果的顺序不作要求 
2.算法要求线性复杂度
分析：仍然是异或的用法，题目较简单，直接看代码，代码中有注释
代码：public class Solution {
    public int[] singleNumber(int[] nums) {
        int[] single = new int[2];
        int[] wei = new int[32];
        int yhResult = 0;
        
        for(int i=0; i<nums.length; i++) {
            yhResult ^= nums[i];
        }
        
        for(int i=0; i<32; i++) {
            if((yhResult & 1<<i) != 0) {<span style="white-space:pre">				</span>//如果异或结果的某位为1，说明两个单数在该位是不同的
                for(int j=0; j<nums.length; j++) {
                    if((nums[j] & 1<<i) != 0)<span style="white-space:pre">				//按该位相同与不同，分两组</span>分别异或，可直接得出结果元素
                        single[0] ^= nums[j];
                    else
                        single[1] ^= nums[j];
                }
                break;
            }
        }
         return single;
    }
   
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

HDOJ--3790--最短路径问题(双权值问题)
最短路径问题
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 18046    Accepted Submission(s): 5413


Problem Description
给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。
 

Input
输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点。n和m为0时输入结束。
(1<n<=1000, 0<m<100000, s != t)
 

Output
输出 一行有两个数， 最短距离及其花费。
 

Sample Input

3 2
1 2 5 6
2 3 4 5
1 3
0 0

 

Sample Output

9 11

思路：这是一道双权值问题，两个权值的优先度不同，dis权值的优先度更高一些，cos略低,那么在做题的时候，考虑重边的时候需要考虑两个权值，更新的时候也需要考虑两个权值，剩下的就跟模板一样了。（小心在一些简单的地方，把代码给写错了）
ac代码：
#include<stdio.h>//双权值问题 ,注意权值的优先性。 
#include<string.h>
#define INF 0x3f3f3f3f
#define N 1010
int n,m,dis[N],cos[N],map[N][N],cost[N][N],vis[N];
void init(){
	memset(map,INF,sizeof(map));
	memset(cost,INF,sizeof(cost));
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(i==j){
				cost[i][j]=0;
				map[i][j]=0;
			}
}
void getmap(){
	init();
	while(m--){
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		if(map[a][b]>c||(map[a][b]==c&&cost[a][b]>d)){//考虑双权值的重边问题。 
			map[a][b]=map[b][a]=c;
			cost[a][b]=cost[b][a]=d;//错写成cost[a][b]=cost[a][b]，wa了1个多小时。心塞。 
		}

	}
}
void dijkstra(){
	int s,t,i;
	scanf("%d%d",&s,&t);
	memset(vis,0,sizeof(vis));
	for(i=1;i<=n;i++){
		dis[i]=map[s][i];
		cos[i]=cost[s][i];
	}
	vis[s]=1;
	for(i=1;i<n;i++){
		int j,k,lowdis=INF,lowcost=INF;
		for(j=1;j<=n;j++)
			if(!vis[j]&&(lowdis>dis[j]||lowdis==dis[j]&&lowcost>cos[j])){
				lowdis=dis[k=j];
				lowcost=cos[k];
			}
		vis[k]=1;
		for(j=1;j<=n;j++)
			if(!vis[j]){//更新dis和cos时，考虑两个权值，先考虑权值优先度高的 。 
				if(dis[j]>dis[k]+map[k][j]){
					dis[j]=dis[k]+map[k][j];
					cos[j]=cos[k]+cost[k][j];
				}
				if(dis[j]==dis[k]+map[k][j]){
					cos[j]=cos[k]+cost[k][j];
				}	
			}
	}
	printf("%d %d\n",dis[t],cos[t]);
}
int main(){
	while(scanf("%d%d",&n,&m)!=EOF&&(n||m)){
		getmap();
		dijkstra();
	}
	return 0;
} 



版权声明：本文为小小呆原创文章，欲转载，请在后台勾搭本呆。

Instrction Arrangement （hdu 4109 差分约束）

Instrction Arrangement
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 1395    Accepted Submission(s): 584



Problem Description

Ali has taken the Computer Organization and Architecture course this term. He learned that there may be dependence between instructions, like WAR (write after read), WAW, RAW.
If the distance between two instructions is less than the Safe Distance, it will result in hazard, which may cause wrong result. So we need to design special circuit to eliminate hazard. However the most simple way to solve this problem is to add bubbles (useless
 operation), which means wasting time to ensure that the distance between two instructions is not smaller than the Safe Distance.
The definition of the distance between two instructions is the difference between their beginning times.
Now we have many instructions, and we know the dependent relations and Safe Distances between instructions. We also have a very strong CPU with infinite number of cores, so you can run as many instructions as you want simultaneity, and the CPU is so fast that
 it just cost 1ns to finish any instruction.
Your job is to rearrange the instructions so that the CPU can finish all the instructions using minimum time.

 


Input

The input consists several testcases.
The first line has two integers N, M (N <= 1000, M <= 10000), means that there are N instructions and M dependent relations.
The following M lines, each contains three integers X, Y , Z, means the Safe Distance between X and Y is Z, and Y should run after X. The instructions are numbered from 0 to N - 1.


 


Output

Print one integer, the minimum time the CPU needs to run.


 


Sample Input

5 2
1 2 1
3 4 1


 


Sample Output

2
Hint
In the 1st ns, instruction 0, 1 and 3 are executed;
In the 2nd ns, instruction 2 and 4 are executed.
So the answer should be 2.
 


 


Source

2011 Alibaba-Cup Campus Contest

 


Recommend

lcy   |   We have carefully selected several similar problems for you:  4103 4105 4104 4101 4102 

 
题意：安排n个任务在CPU上工作，告诉m个限制，u，v，z表示v必须在u指令之后执行，并且u和v之间要间隔z秒，问把所有的任务完成最少时间为多少。
思路：差分约束系统，由题意：dist[v]-dist[u]>=z，变形得：dist[u]<=dist[v]-z，根据这个建图v->u权为-z，源点到i权为0，i到汇点权为-1，然后求最短路，答案为 -dist[n+1].
代码：
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<string>
#include<iostream>
#include<queue>
#include<cmath>
#include<map>
#include<stack>
#include<set>
using namespace std;
#define REPF( i , a , b ) for ( int i = a ; i <= b ; ++ i )
#define REP( i , n ) for ( int i = 0 ; i < n ; ++ i )
#define CLEAR( a , x ) memset ( a , x , sizeof a )
const int INF=0x3f3f3f3f;
typedef long long LL;

const int MAXM = 100000;
const int MAXN = 1005;

struct Edge
{
    int u,v,len,next;
}edge[MAXM];

int n,m,num;
int head[MAXN],dist[MAXN],inq[MAXN];

void init()
{
    num=0;
    memset(head,-1,sizeof(head));
}

void addedge(int u,int v,int len)
{
    edge[num].u=u;
    edge[num].v=v;
    edge[num].len=len;
    edge[num].next=head[u];
    head[u]=num++;
}

void spfa()
{
    memset(dist,INF,sizeof(dist));
    memset(inq,0,sizeof(inq));
    inq[0]=1;
    dist[0]=0;
    queue<int>Q;
    Q.push(0);
    while (!Q.empty())
    {
        int u=Q.front();
        Q.pop();
        inq[u]=0;
        for (int i=head[u];~i;i=edge[i].next)
        {
            int v=edge[i].v;
            if (dist[v]>dist[u]+edge[i].len)
            {
                dist[v]=dist[u]+edge[i].len;
                if (!inq[v])
                {
                    inq[v]=1;
                    Q.push(v);
                }
            }
        }
    }
    printf("%d\n",-dist[n+1]);
}

int main()
{
    int i,j,u,v,w;
    while (~scanf("%d%d",&n,&m))
    {
        init();
        for (i=0;i<m;i++)
        {
            scanf("%d%d%d",&u,&v,&w);
            u++,v++;
            addedge(v,u,-w);
        }
        for (i=1;i<=n;i++)
        {
            addedge(0,i,0);
            addedge(i,n+1,-1);
        }
        spfa();
    }
    return 0;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

Google APAC 2016 University Graduates Test Round A解题报告

这是google 2016年校招的在线笔试第一轮，题目的链接可点击https://code.google.com/codejam/contest/4284486/dashboard，由于大多是考察基础知识，所以比竞赛题目要简单很多。
A.Googol String
注意到K最大是101810^{18}，每一个字符串的前缀都是前一个字符串，因此只要找到第一个长度不小于K的SnS_n，然后递归求解就行了。由于字符串长度是指数增长的，因此递归层数很小。
GG = 10**19
sz = [0]
while sz[-1] < GG:
    sz.append(sz[-1] * 2 + 1)
R = lambda: int(raw_input().strip())
T = R()
def solve(pos, kk):
    assert(sz[pos] >= kk)
    mid = sz[pos] / 2 + 1
    if kk == mid: return 0
    elif kk < mid: return solve(pos - 1, kk)
    else:
        kk -= mid
        return 1 - solve(pos - 1, sz[pos - 1] - kk + 1)

for i in xrange(T):
    print 'Case #' + str(i + 1) + ': ',
    K = R()
    print solve(len(sz) - 1, K)
B.gCube
将各个维度相乘就可以算出体积，对于目标长度，可以通过二分得到答案。我一开始没注意到大数据会有乘法溢出的问题，导致大数据挂了，要不然就满分了。。。解决浮点乘法溢出的办法也很简单：取对数。把乘法变成加法。
#include <bits/stdc++.h>
#define FOR(i, n) for (int i = 0; i < n; ++i)
using namespace std;
typedef long long ll;
typedef pair<int, int> point;
void solve() {
    int N, Q, l, r;
    cin >> N >> Q;
    vector<double> arr(N);
    FOR(i, N) cin >> arr[i];
    FOR(i, Q) {
        cin >> l >> r;
        long double cur = 0.0;
        for (int j = l; j <= r; ++j) {
            cur += log(arr[j]);
        }
        long double low = 0.0, up = 1e10;
        int cnt = 0;
        while (cnt < 1000) {
            ++cnt;
            long double mid = (low + up) / 2.0;
            long double val = (long double)(r - l + 1) * log(mid);
            if (val > cur) up = mid;
            else low = mid;
        }
        cout << fixed << setprecision(10) << (low + up) / 2.0 << endl;
    }
    return;
}
int main() {
    int TestCase;
    cin >> TestCase;
    FOR(caseID, TestCase) {
        cout << "Case #" << caseID + 1 << ":" << endl;
        solve();
    }
    return 0;
}
C. gCampus
简单来说，就是要求判断一条边是否有可能出现在最短路上，一个比较简单的图论题。首先通过floyd算法求出所有点对之间的最短路径，时间复杂度O(N3)O(N^3)，然后对于每一条边(u,v)(u, v)，枚举所有的顶点对，判断是否有下式成立：
distance(i, j) = distance(i, u) + w(u, v) + distance(v, j)

如果上式对于某个(i,j)(i, j)顶点对成立，则说明(u,v)(u, v)这条边在某条最短路径上。
#include <bits/stdc++.h>
#define FOR(i, n) for (int i = 0; i < n; ++i)
using namespace std;
typedef long long ll;
typedef pair<int, int> point;
const ll INF = (ll)1e14;
struct Edge {
    int from, to, idx;
    ll wei;
    Edge(int _f, int _t, ll _w, int _i): from(_f), to(_t), wei(_w), idx(_i) {}
};
void solve() {
    int n, m, x, y;
    ll w;
    scanf("%d %d", &n, &m);
    vector<Edge> arr;
    ll g[105][105];
    FOR(i, n) FOR(j, n) {
        if (i == j) g[i][j] = 0;
        else g[i][j] = INF;
    }
    FOR(i, m) {
        cin >> x >> y >> w;
        g[x][y] = min(g[x][y], w);
        g[y][x] = min(g[y][x], w);
        arr.push_back(Edge(x, y, w, i));
    }
    ll dis[105][105];
    FOR(i, n) FOR(j, n) {
        dis[i][j] = g[i][j];
    }
    FOR(k, n) FOR(i, n) FOR(j, n) {
        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
    }
    vector<bool> ok(m, false);
    FOR(i, m) {
        int f = arr[i].from, t = arr[i].to;
        ll w = arr[i].wei;
        FOR(j, n) FOR(k, n) {
            if (ok[i] || dis[j][k] == dis[j][f] + w + dis[t][k]) {
                ok[i] = true;
                break;
            }
        }
        if (!ok[i]) {
            cout << i << endl;
        }
    }
    return;
}
int main() {
    int TestCase;
    cin >> TestCase;
    FOR(caseID, TestCase) {
        cout << "Case #" << caseID + 1 << ":" << endl;
        solve();
    }
    return 0;
}
D.gSnake
一个看上去比较麻烦的模拟题，google每年都会出这种题目，关键在于要把思路理清楚，让代码尽量简洁一点，否则很容易出bug。
对于贪吃蛇的身体，由于每次只是头部和尾部可能发生变化，因此只需要维护一个双端队列deque，每次向前移动，删除尾部元素，更新头部元素即可。
对于吃食物，可以用一个集合set来维护那些食物已经被吃过了，虽然总的食物点可能达到101010^{10}，但注意到XiX_i不超过10610^6，而一旦没有了命令，贪吃蛇只能在一个方向前进，最多额外吃10510^5单位食物，因此内存是完全可以承受的。
对于判断贪吃蛇是否因为碰到自己身体而死的情况，可以用哈希表map来维护每个位置上的贪吃蛇身体数目，一旦发现一个位置上出现了超过一个贪吃蛇身体，就说明它碰到了自己的身体，游戏结束。
最终代码只有80行。
#include <bits/stdc++.h>
#define FOR(i, n) for (int i = 0; i < n; ++i)
using namespace std;
typedef long long ll;
typedef pair<int, int> point;
typedef pair<int, char> rec;
const int dir_x[] = {1, 0, -1, 0};
const int dir_y[] = {0, -1, 0, 1};
set<point> eat;
inline bool has_food(point& pos) {
    int cc = pos.first + pos.second;
    if (cc % 2 == 0) return false;
    if (eat.find(pos) != eat.end()) return false;
    return true;
}
inline void eat_food(point& pos) {
    eat.insert(pos);
}
void solve() {
    int Q, row, col;
    cin >> Q >> row >> col;
    deque<point> snake;
    eat.clear();
    int d = 3, ptr = 0;
    vector<rec> cmd(Q);
    FOR(i, Q) cin >> cmd[i].first >> cmd[i].second;
    sort(cmd.begin(), cmd.end());
    map<point, int> visited;
    snake.push_back({0, 0});
    visited[{0, 0}] = 1;
    int tt = 1;
    while (true) {
        if (tt > 1500000) {
            cout << snake.size() << endl;
            return;
        }
        point tp = snake.front();
        tp.first = (tp.first + dir_x[d] + row) % row;
        tp.second = (tp.second + dir_y[d] + col) % col;
        if (!has_food(tp)) {
            --visited[snake.back()];
            if (visited[snake.back()] == 0) visited.erase(snake.back());
            ++visited[tp];
            if (visited[tp] >= 2) {
                cout << snake.size() << endl;
                return;
            }
            snake.push_front(tp);
            snake.pop_back();
        }
        else {
            eat_food(tp);
            ++visited[tp];
            if (visited[tp] >= 2) {
                cout << snake.size() << endl;
                return;
            }
            snake.push_front(tp);
        }
        if (ptr < cmd.size() && cmd[ptr].first == tt) {
            if (cmd[ptr].second == 'L') d = (d - 1 + 4) % 4;
            else {
                d = (d + 1) % 4;
                assert(cmd[ptr].second == 'R');
            }
            ++ptr;
        }
        ++tt; // increase clock
    }
    return;
}
int main() {
    int TestCase;
    cin >> TestCase;
    FOR(caseID, TestCase) {
        cout << "Case #" << caseID + 1 << ": ";
        solve();
    }
    return 0;
}
第一次用markdown在csdn上写博客，请大家多指教。
也祝2016年毕业的童鞋拿到理想的offer，我参加这个笔试完全是for fun，对于被我挤掉名额的那个同学说一声sorry。。。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

拷贝构造函数的参数为什么必须是引用？
拷贝构造函数的参数为什么必须是const引用？
先看如下代码：





class CExample {  
private:  
    int a;  
public:  
    //构造函数  
    CExample(int b)  
    { a = b;}  
      
    //拷贝构造函数  
    CExample(const CExample& C)  
    {  
        a = C.a;  
    }  
};  
  
int main()  
{  
    CExample A(100);  
    CExample B（A）; 
    return 0;  
}   



1 首先讨论为什么必须要是引用？

如果这里改成非引用 ：


 CExample(const CExample
 C)  
    {  
        a = C.a;  
    }  


首先编译器这一关就过不了，会报错，如下图：




原因：


那在调用拷贝构造函数的时候 


CExample B(A);



上面 B(A) 中实参 A  赋给形参 C（CExample(const CExample
 C)） 的时候，也需要拷贝构造函数 C(A) ，这个 C(A)  中的 A 又要赋给形参 C'.......这是不是要无限次的进行拷贝？
所以，如果使用引用就可以避免这样的无限循环。




2 那为什么要用const引用？
 const 更多是给程序员的一个限制， 告诉程序员这个变量是只读的。因此为了安全， 一般建议所有的只读变量加const限制以防止程序员犯错。因为复制构造函数是用引用方式传递复制对象，引用方式传递的是地址，因此在构造函数内对该引用的修改会影响源对象。而你在用对象a1构造a2时，自然不希望复制构造函数会改变a1的内容，因此要防止复制构造函数内部修改该引用，所以用const声明。 





版权声明：本文为博主原创文章，未经博主允许不得转载。

Item 10：赋值运算符要返回自己的引用 Effective C++笔记

Item 10：Have assignment operators return a reference to *this.


这是关于赋值运算符的编程惯例，用来支持链式的赋值语句：

int x, y, z;
...
x = y = z = 1;



在C++中，它相当于：

x = ( y = ( z = 1 ) );



这是因为=运算符是右结合的，链式赋值时会从右向左运算。链式写法的赋值已经成为了惯例，
 所以我们自定义的对象最好也能支持链式的赋值，这需要重载=运算符时返回当前对象的引用：

class Widget {
public:
    Widget& operator=(const Widget& rhs){   // return type is a reference to
      return *this;                         // return the left-hand object
    }
    Widget& operator+=(const Widget& rhs){  // the convention applies to
       return *this;                        // +=, -=, *=, etc.
    }
};



说到运算符的结合性，不妨来研究一下最费解的运算符,的行为。首先，它的返回值是后面表达式的值：

int a;
a = (1, 2, 3);
cout<<a<<endl;



上述代码的输出结果是3。如果你写成了a
 = 1, 2, 3，输出结果将会是1。
 因为=运算符的优先级高于,，此时第一个表达式变成了a
 = 1，第二个是b，第三个是c。
 那么结合性呢？,运算符是左结合的：

cout<<1, cout<<2, cout<<3;



输出是：

123




除非注明，本博客文章均为原创，转载请以链接形式标明本文地址： http://harttle.com/2015/07/28/effective-cpp-10.html


版权声明：本文为博主原创文章，转载请附上原文链接。

POJ 1080 Human Gene Functions(DP LCS)
Description
It is well known that a human gene can be considered as a sequence, consisting of four nucleotides, which are simply denoted by four letters, A, C, G, and T. Biologists have been interested in identifying human genes and determining
 their functions, because these can be used to diagnose human diseases and to design new drugs for them.


A human gene can be identified through a series of time-consuming biological experiments, often with the help of computer programs. Once a sequence of a gene is obtained, the next job is to determine its function.

One of the methods for biologists to use in determining the function of a new gene sequence that they have just identified is to search a database with the new gene as a query. The database to be searched stores many gene sequences and their functions – many
 researchers have been submitting their genes and functions to the database and the database is freely accessible through the Internet.


A database search will return a list of gene sequences from the database that are similar to the query gene.

Biologists assume that sequence similarity often implies functional similarity. So, the function of the new gene might be one of the functions that the genes from the list have. To exactly determine which one is the right one another series of biological experiments
 will be needed. 

Your job is to make a program that compares two genes and determines their similarity as explained below. Your program may be used as a part of the database search if you can provide an efficient one.

Given two genes AGTGATG and GTTAG, how similar are they? One of the methods to measure the similarity

of two genes is called alignment. In an alignment, spaces are inserted, if necessary, in appropriate positions of

the genes to make them equally long and score the resulting genes according to a scoring matrix.


For example, one space is inserted into AGTGATG to result in AGTGAT-G, and three spaces are inserted into GTTAG to result in –GT--TAG. A space is denoted by a minus sign (-). The two genes are now of equal

length. These two strings are aligned: 

AGTGAT-G 
-GT--TAG 

In this alignment, there are four matches, namely, G in the second position, T in the third, T in the sixth, and G in the eighth. Each pair of aligned characters is assigned a score according to the following scoring matrix.



denotes that a space-space match is not allowed. The score of the alignment above is (-3)+5+5+(-2)+(-3)+5+(-3)+5=9.


Of course, many other alignments are possible. One is shown below (a different number of spaces are inserted into different positions):


AGTGATG 
-GTTA-G 

This alignment gives a score of (-3)+5+5+(-2)+5+(-1) +5=14. So, this one is better than the previous one. As a matter of fact, this one is optimal since no other alignment can have a higher score. So, it is said that the

similarity of the two genes is 14. 
Input
The input consists of T test cases. The number of test cases ) (T is given in the first line of the input file. Each test case consists of two lines: each line contains an integer, the length of a gene, followed by a gene sequence.
 The length of each gene sequence is at least one and does not exceed 100. 
Output
The output should print the similarity of each test case, one per line.

Sample Input
2 
7 AGTGATG 
5 GTTAG 
7 AGCTATT 
9 AGCTTTAAA 
Sample Output
14
21 




题目大意：给定两个字符串在两串中可以在任意位置上添加空格，并使兩串对齐，使得两字符串对应值相加后最大。


思路：此题和LCS，类似主要就是状态方程的问题因为任何一个字母都有可能和‘ ’组合，所以先初始化一个表格，也在程序中进行初始化，即每行的第一个数与‘  ’组合的情况故有dp[i][0]=dp[i-1][0]+match[a[i]]['  '](类似的每列也是这么初始化)。


转移方程：dp[i][j]=max(  dp[i-1][j]+match[a[i]]['  '] ,dp[i][j-1]+match['  '][b[j]] ,dp[i][j],dp[i-1][j-1]+match[a[i]][b[j]] ).

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define LL long long
#define inf 0x3f3f3f3f
using namespace std;
int dp[500][500],match[100][100];
char a[125],b[125];
void ini()//该图表弱复制：http://www.cnblogs.com/zhourongqing/archive/2012/08/09/2629840.html
{//感谢大神。。
    match['A']['A']=match['C']['C']=match['G']['G']=match['T']['T']=5;
    match['A']['C']=match['C']['A']=match['A']['T']=match['T']['A']=-1;
    match[' ']['T']=match['T'][' ']=-1;
    match['A']['G']=match['G']['A']=match['C']['T']=match['T']['C']=-2;
    match['G']['T']=match['T']['G']=match['G'][' ']=match[' ']['G']=-2;
    match['A'][' ']=match[' ']['A']=match['C']['G']=match['G']['C']=-3;
    match['C'][' ']=match[' ']['C']=-4;
}
int main()
{
    int n,m,x,k,i,j;
    int cla;
    ini();
    scanf("%d",&cla);
    while(cla--)
    {
        dp[0][0]=0;
        scanf("%d%s",&n,a+1);
        scanf("%d%s",&m,b+1);
        for(i=1; i<=n; i++)
            dp[i][0]=dp[i-1][0]+match[a[i]][' '];
        for(i=1; i<=m; i++)
            dp[0][i]=dp[0][i-1]+match[' '][b[i]];
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=m;j++)
            {
                dp[i][j]=max(dp[i-1][j]+match[a[i]][' '],dp[i][j-1]+match[' '][b[j]]);
                dp[i][j]=max(dp[i-1][j-1]+match[a[i]][b[j]],dp[i][j]);
            }
        }
        printf("%d\n",dp[n][m]);
    }
    return 0;
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

hdoj 1023 Train Problem II 【卡特兰数】
Train Problem II
Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 6928    Accepted Submission(s): 3750


Problem Description
As we all know the Train Problem I, the boss of the Ignatius Train Station want to know if all the trains come in strict-increasing order, how many orders that all the trains can get out of the railway.

 

Input
The input contains several test cases. Each test cases consists of a number N(1<=N<=100). The input is terminated by the end of file.

 

Output
For each test case, you should output how many ways that all the trains can get out of the railway.

 

Sample Input

1
2
3
10

 

Sample Output

1
2
5
16796

Hint
The result will be very large, so you may not process it by 32-bit integers.
 

 

代码：
 
/*
原理： 
 令h(0)=1,h(1)=1，catalan数满足递推式[1] ：
 h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0) (n>=2)
 例如：h(2)=h(0)*h(1)+h(1)*h(0)=1*1+1*1=2
 h(3)=h(0)*h(2)+h(1)*h(1)+h(2)*h(0)=1*2+1*1+2*1=5
 另类递推式[2]  ：
 h(n)=h(n-1)*(4*n-2)/(n+1);
 递推关系的解为：
 h(n)=C(2n,n)/(n+1) (n=0,1,2,...)
 递推关系的另类解为：
 h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,...)
*/
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
int a[110][110]={0};//二维数组a[输入的n][n的卡特兰数的每一位的值]； 
int b[110];//记录位数； 
void catalan()//求卡特兰数； 
{
	int i,j,len,carry,temp;
	a[1][0]=b[1]=1;
	len=1;
	for(i=2;i<=100;i++)
	{
		for(j=0;j<len;j++)//乘法； 
		{
			a[i][j]=a[i-1][j]*(4*(i-1)+2);
		}
		carry=0;
		for(j=0;j<len;j++)//处理相乘结果； 
		{
			temp=a[i][j]+carry;
			a[i][j]=temp%10;
			carry=temp/10;
		}
		while(carry)//进位处理； 
		{
			a[i][len++]=carry%10;
			carry/=10;
		}
		carry=0;
		for(j=len-1;j>=0;j--)//除法； 
		{
			temp=carry*10+a[i][j];
			a[i][j]=temp/(i+1);
			carry=temp%(i+1);
		}
		while(!a[i][len-1])//高位零处理； 
		{
			len--;
	    }
		b[i]=len;
	}
}
int main()
{
	int n,i;
	catalan();
	while(scanf("%d",&n)!=EOF)
	{
		for(i=b[n]-1;i>=0;i--)
		{
			printf("%d",a[n][i]);
		}
		printf("\n");
	}
	return 0;
}

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

ConcurrentHashMap源码（二）--initTable
在ConcurrentHashMap的put方法中，第一次添加元素的时候table是空的（使用空的构造函数），就会执行initTable方法。


下面就来看一下jdk8是怎么初始化这个table的，如何保证并发不出问题。


关于unsafe.compareAndSwap的用法，可以参见我以前的博客 AtomicInteger分析--自实现无锁并发。




private final Node<K,V>[] initTable() {
        Node<K,V>[] tab; int sc;

		//这个有个死循环，
        while ((tab = table) == null || tab.length == 0) {
			//2.sizeCtl何时为0？看后面
            if ((sc = sizeCtl) < 0)
                Thread.yield(); // lost initialization race; just spin
			//1.这里有个if,如果没进这个if，则继续循环
			//什么时候没进这个if呢？
			//	-就是unsafe.compareAndSwapInt失败的时候，
			//什么时候失败呢？
			//	-当其他的线程也对sizeCtl进行了修改（内存里实际的值与手上拿的不一样，这个时候就返回false了。svn一样）
			//2.如果成功了，则进入if,同时，内存中的sizeCtl的值也被修改成了-1，这个时候就可以看到1处做的判断：如果小于0，则放弃此次执行
			//3.如果未成功，那继续while：
			//	-这个时候要么其他的线程已经将table初始化好了，table!=null，直接返回table就行了
			//  -要么其他线程正在初始化这个表，此时的sizeCtl是-1.所以放弃此次执行。（等待其他线程）
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if ((tab = table) == null || tab.length == 0) {
						//这里就是初始化一个table数组
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = tab = nt;
                        sc = n - (n >>> 2);
                    }
                } finally {
					//结束后将sizeCtl设置为新的table的容量（而不是-1）
                    sizeCtl = sc;
                }
				//初始化完成了，那就break。
                break;
            }
        }
        return tab;
    }



版权声明：本文为博主原创文章，未经博主允许不得转载。

Java-collections总结
纸上得来终觉浅，绝知此事要躬行
  --陆游    问渠那得清如许，为有源头活水来  --朱熹



类Collections是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。


java.lang.Object
        java.util.Collections


Collections中常用的方法：
（1）sort()排序方法
        函数定义：public static <T extends Comparable<?
 super T>> void sort(List<T> list) 根据元素的
        自然顺序对指定列表按升序进行排序。
        参数：要排序的列表。
        函数定义： public static <T> void sort(List<T> list,Comparator<? super T> c)，根据指定比较器产生的顺序对指定列表进行排序。此列表内的所有元素都必须可使用指定比较器相互比较。
        参数：list-要排序的列表；c-确定列表顺序的比较器。
（2）binarySearch()二分查找方法
        函数定义：public static <T> int binarySearch(List<? extends Comparable<? super T>> list,T key)
        使用二分搜索法搜索指定列表，以获得指定对象，在进行此方法调用前比较要将列表元素按照升序排序，否则结果不确定，此方法会执行O(n)次链接遍历和O(log n)次元素比较。
        参数: list-要搜索的链表，key-要搜索的键。
        函数定义： public static <T> int binarySearch(List<? extends T> list, T
 key, Comparator<? super T> c) 根据指定的比较器对列表进行升序排序。
        参数：list-要搜索的列表，key-要搜索的键，c-排序列表的比较器。
（3）reverse()反转方法
         函数定义：public
 static void reverse(List<?> list)，反转指定列表中元素的顺序，此方法以线性时间运行。
        参数：list-元素要被反转的列表
（4）shuffle()改组方法
       函数定义：public static
 void shuffle(List<?> list)，使用默认随机源对指定列表进行置换，所有置换发生的可能性都是大致相等的。
        参数：list-要改组的列表
        函数定义：public
 static void shuffle(List<?> list,Random rnd),使用指定的随机源对指定列表进行置换。
    参数：list-要改组的列表，rnd-用来改组列表的随机源。
（5）swap()交换方法
        函数定义：public static void swap(List<?> list,int i，int j)，在指定列表的指定位置处交换元素。
        参数：list-进行元素交换的列表，i-要交换的一个元素的索引，j-要交换的另一个元素的索引。
（6）fill()替换方法
        函数定义：public static <T> void fill(List<?
 super T> list,T obj)，使用指定元素替换指定列表中的所有元素，线性时间运行。
        参数:list-使用指定元素填充的列表，obj-用来填充指定列表的元素。
（7）copy()复制方法
        函数定义：public static <T> void copy(List<?
 super T> dest,List<? extends T> src)，将所有元素从一个列表复制到另一个列表。执行此操作后，目标列表中每个已复制元素的索引将等同于源列表中该元素的索引，目标列表的长度至少必须等于源列表。
        参数：dest-目标列表，src-源列表。
（8）min()最小值法
        函数定义：public static <T extends Object & Comparable<?
 super T>> T min(Collection<? extends T> coll)，根据元素的自然顺序返回给定Collection的最小元素，Collection中的所有元素必须实现Comparable接口，此外，collection中的所有元素都必须是可相互比较的。
        参数：coll-将确定其最小元素的collection。
        函数定义：public static <T> T min(Collection<?
 extends T> coll,Comparator<? super T> comp),根据指定比较器产生的顺序，返回给定collection的最小元素。
        参数：coll-将确定其最小元素的collection，comp-用来确定最小元素的比较器。
（9）max()最大值方法
        函数定义：public static <T extends Object & Comparable<?
 super T>> T max(Collection<? extends T> coll)，根据元素的自然顺序，返回给定collection的最大元素。
        参数：coll-将确定其最大元素的collection。
        函数定义：public static <T> T max(Collection<?extends
 T> coll,Comparator<? super T> comp)，根据指定比较器产生的顺序，返回给定collection的最大元素。
        参数：coll-将确定其最大元素的collection，comp-用来确定最大元素的比较器
（10）rotate()轮换方法
        函数定义：public static void rotate(List<?> list，int distance)，根据指定的距离轮转指定列表中的元素。
        参数：list-要轮换的列表，distance-列表轮换的距离，可以使0、负数或者大于list.size()的数。
（11）replaceAll()替换所有函数
        函数定义：public static <T> boolean replaceAll(List<T> list,T oldVal,T newVal)，使用另一个值替换列表总出现的所有的某一指定值。
        参数：list-在其中进行替换的列表；oldVal-将被替换的原值；newVal-替换oldVald的新值。


示例代码：

public class Hello {public static void main(String[] args) {        System.out.println("sort");        List list=new ArrayList<Double>();       double array[] = {112, 111, 23, 456, 231 };        for (int i = 0; i < array.length; i++) {            list.add(new Double(array[i]));        }        Collections.sort(list);//自然排序        for (int i = 0; i < array.length; i++) {            System.out.println(list.get(i));        }        System.out.println("shuffle");        Collections.shuffle(list);//置换        for (int i = 0; i < array.length; i++) {            System.out.println(list.get(i));        }        Collections.sort(list);//自然排序        System.out.println("reverse");        Collections. reverse (list);//反转        for (int i = 0; i < array.length; i++) {            System.out.println(list.get(i));        }        Collections.sort(list);//自然排序        System.out.println("copy");        List li = new ArrayList();        double arr[] = {1131,333};        for(int j=0;j<arr.length;j++){            li.add(new Double(arr[j]));        }        Collections.copy(list,li);//拷贝        for (int i = 0; i <list.size(); i++) {            System.out.println(list.get(i));        }        System.out.println("min");        System.out.println(Collections.min(list));//返回最小值        System.out.println("max");        System.out.println(Collections.max(list));//返回最大值        System.out.println("rotate");        Collections.rotate(list,-1);//循环        for (int i = 0; i <list.size(); i++) {            System.out.println( list.get(i));        }         System.out.println("binarySearch");        Collections.sort(list);        System.out.println(list);        System.out.println(Collections.binarySearch(list, 333.0));//二分查找    }}




以上是Collections比较常用的方法，Collections还有很多其他的方法，如下表：





方法摘要



static




<T> boolean





addAll(Collection<?
 super T> c, T... elements) 
          将所有指定元素添加到指定 collection 中。



static




<T> Queue<T>





asLifoQueue(Deque<T> deque) 
          以后进先出 (Lifo) Queue 的形式返回某个 Deque 的视图。



static




<T> int





binarySearch(List<?
 extends Comparable<? super T>> list, T key) 
          使用二分搜索法搜索指定列表，以获得指定对象。



static




<T> int





binarySearch(List<?
 extends T> list, T key, Comparator<? super T> c) 
          使用二分搜索法搜索指定列表，以获得指定对象。



static




<E> Collection<E>





checkedCollection(Collection<E> c,
 Class<E> type) 
          返回指定 collection 的一个动态类型安全视图。



static




<E> List<E>





checkedList(List<E> list,
 Class<E> type) 
          返回指定列表的一个动态类型安全视图。



static




<K,V> Map<K,V>





checkedMap(Map<K,V> m,
 Class<K> keyType, Class<V> valueType) 
          返回指定映射的一个动态类型安全视图。



static




<E> Set<E>





checkedSet(Set<E> s,
 Class<E> type) 
          返回指定 set 的一个动态类型安全视图。



static




<K,V> SortedMap<K,V>





checkedSortedMap(SortedMap<K,V> m,
 Class<K> keyType, Class<V> valueType) 
          返回指定有序映射的一个动态类型安全视图。



static




<E> SortedSet<E>





checkedSortedSet(SortedSet<E> s,
 Class<E> type) 
          返回指定有序 set 的一个动态类型安全视图。



static




<T> void





copy(List<? super T> dest,
 List<? extends T> src) 
          将所有元素从一个列表复制到另一个列表。



static boolean

disjoint(Collection<?> c1,
 Collection<?> c2) 
          如果两个指定 collection 中没有相同的元素，则返回 true。



static




<T> List<T>





emptyList() 
          返回空的列表（不可变的）。



static




<K,V> Map<K,V>





emptyMap() 
          返回空的映射（不可变的）。



static




<T> Set<T>





emptySet() 
          返回空的 set（不可变的）。



static




<T> Enumeration<T>





enumeration(Collection<T> c) 
          返回一个指定 collection 上的枚举。



static




<T> void





fill(List<? super T> list,
 T obj) 
          使用指定元素替换指定列表中的所有元素。



static int

frequency(Collection<?> c,
 Object o) 
          返回指定 collection 中等于指定对象的元素数。



static int

indexOfSubList(List<?> source,
 List<?> target) 
          返回指定源列表中第一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回 -1。



static int

lastIndexOfSubList(List<?> source,
 List<?> target) 
          返回指定源列表中最后一次出现指定目标列表的起始位置；如果没有出现这样的列表，则返回 -1。



static




<T> ArrayList<T>





list(Enumeration<T> e) 
          返回一个数组列表，它按返回顺序包含指定枚举返回的元素。



static




<T extends Object & Comparable<? super T>> 
T





max(Collection<? extends
 T> coll) 
          根据元素的自然顺序，返回给定 collection 的最大元素。



static




<T> T





max(Collection<? extends
 T> coll, Comparator<? super T> comp) 
          根据指定比较器产生的顺序，返回给定 collection 的最大元素。



static




<T extends Object & Comparable<? super T>> 
T





min(Collection<? extends
 T> coll) 
          根据元素的自然顺序 返回给定 collection 的最小元素。



static




<T> T





min(Collection<? extends
 T> coll, Comparator<? super T> comp) 
          根据指定比较器产生的顺序，返回给定 collection 的最小元素。



static




<T> List<T>





nCopies(int n, T o) 
          返回由指定对象的 n 个副本组成的不可变列表。



static




<E> Set<E>





newSetFromMap(Map<E,Boolean> map) 
          返回指定映射支持的 set。



static




<T> boolean





replaceAll(List<T> list,
 T oldVal, T newVal) 
          使用另一个值替换列表中出现的所有某一指定值。



static void

reverse(List<?> list) 
          反转指定列表中元素的顺序。



static




<T> Comparator<T>





reverseOrder() 
          返回一个比较器，它强行逆转实现了 Comparable接口的对象 collection 的自然顺序。



static




<T> Comparator<T>





reverseOrder(Comparator<T> cmp) 
          返回一个比较器，它强行逆转指定比较器的顺序。



static void

rotate(List<?> list,
 int distance) 
          根据指定的距离轮换指定列表中的元素。



static void

shuffle(List<?> list) 
          使用默认随机源对指定列表进行置换。



static void

shuffle(List<?> list,
 Random rnd) 
          使用指定的随机源对指定列表进行置换。



static




<T> Set<T>





singleton(T o) 
          返回一个只包含指定对象的不可变 set。



static




<T> List<T>





singletonList(T o) 
          返回一个只包含指定对象的不可变列表。



static




<K,V> Map<K,V>





singletonMap(K key,
 V value) 
          返回一个不可变的映射，它只将指定键映射到指定值。



static




<T extends Comparable<? super T>> 
void





sort(List<T> list) 
          根据元素的自然顺序 对指定列表按升序进行排序。



static




<T> void





sort(List<T> list,
 Comparator<? super T> c) 
          根据指定比较器产生的顺序对指定列表进行排序。



static void

swap(List<?> list,
 int i, int j) 
          在指定列表的指定位置处交换元素。



static




<T> Collection<T>





synchronizedCollection(Collection<T> c) 
          返回指定 collection 支持的同步（线程安全的）collection。



static




<T> List<T>





synchronizedList(List<T> list) 
          返回指定列表支持的同步（线程安全的）列表。



static




<K,V> Map<K,V>





synchronizedMap(Map<K,V> m) 
          返回由指定映射支持的同步（线程安全的）映射。



static




<T> Set<T>





synchronizedSet(Set<T> s) 
          返回指定 set 支持的同步（线程安全的）set。



static




<K,V> SortedMap<K,V>





synchronizedSortedMap(SortedMap<K,V> m) 
          返回指定有序映射支持的同步（线程安全的）有序映射。



static




<T> SortedSet<T>





synchronizedSortedSet(SortedSet<T> s) 
          返回指定有序 set 支持的同步（线程安全的）有序 set。



static




<T> Collection<T>





unmodifiableCollection(Collection<?
 extends T> c) 
          返回指定 collection 的不可修改视图。



static




<T> List<T>





unmodifiableList(List<?
 extends T> list) 
          返回指定列表的不可修改视图。



static




<K,V> Map<K,V>





unmodifiableMap(Map<?
 extends K,? extends V> m) 
          返回指定映射的不可修改视图。



static




<T> Set<T>





unmodifiableSet(Set<?
 extends T> s) 
          返回指定 set 的不可修改视图。



static




<K,V> SortedMap<K,V>





unmodifiableSortedMap(SortedMap<K,?
 extends V> m) 
          返回指定有序映射的不可修改视图。



static




<T> SortedSet<T>





unmodifiableSortedSet(SortedSet<T> s) 
          返回指定有序 set 的不可修改视图。








    



版权声明：知识在于分享，技术在于交流，转载时请留一个博主的链接就好

OJ 刷题---运动员分组
 题目要求：




输入代码：
#include<iostream>
using namespace std;
#define team 1000//定义最多可分的组数
#define num 8//定义跑道数
int person[team];//定义该数组保存分类后每个小组的人数
int main()
{
    int i,personNum,teamNum,remainder;
    cin>>personNum;
    teamNum=(personNum/num)+(personNum%num);//分为几组
    for(i=0; i<teamNum; i++)
    {
        person[i]=personNum/teamNum;//平均每组的人数
    }
    remainder=personNum%teamNum;//平均后剩余人数
    for(i=0; i<remainder; i++) //按序号给组数加上余数的人
    {
        person[i] ++;//剩余的人数，每组都平分，使人数差减少到最少
    }
    for(i=0; i<teamNum; i++)//输出分组后每组的人数
    {
        cout<<person[i]<<endl;
    }
    return 0;
}





运行结果：



版权声明：本文为博主原创文章，未经博主允许不得转载。

C hicken and rabbit s

时间限制: 1 Sec  内存限制:
32 MB
提交: 40  解决: 29
[提交][状态][讨论版]
题目描述

Chicken and rabbits are in a same cage. As we all know, chicken has two legs but rabbit has four. Now
we know the number of legs in the cage is A, please tell me how many animals may in the cage at least
and at most.


输入

The first line of the input contains the number of test cases in the file. Each test case that follows
consists of one lines. each case contains only one integer numbers A specifying the total legs in the
cage .


输出

For each test case, print a line contains the answer


样例输入

2
3
20

样例输出

0 0
5 10




#include<stdio.h> 
int main() 
{ 
     int n; 
    scanf("%d",&n); 
    while(n--) 
    { 
        long long m; 
        scanf("%lld",&m); 
        if(m%2==1) 
        { 
            printf("0 0\n"); 
            continue;  
        }    
        if(m%4==0) 
        printf("%lld ",m/4); 
        else
        printf("%lld ",m/4+1); 
        printf("%lld\n",m/2); 
    } 
    return 0; 
    } 
/************************************************************** 
    Problem: 1205  
    Language: C 
    Result: 正确 
    Time:0 ms 
    Memory:768 kb 
****************************************************************/


版权声明：本文为博主原创文章，未经博主允许不得转载。

引用三方Dll时，产生“does not have a strong name”错误
【问题描述】
1.在项目中，右键添加三方.dll文件时，无法生成，会出现如下错误。

2.这是因为.dll文件没有使用签名文件进行签名，存在着一切安全隐患，固编辑器组织生成这一行为。
对于签名详情见博文：http://www.windowsdevcenter.com/pub/a/dotnet/2003/04/28/strongnaming.html
如图所示，dll的公钥值为null。

【解决方案】
1.我们需要一个签名文件.snk；
使用签名工具sn.exe进行签名，sn.exe工具在“C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Bin”目录下，在cmd中使用"set PATH=%PATH%;C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Bin"命令添加环境变量，这样就可以在命令行中使用；
生成一个你的密钥：sn -k mykey.snk

2.把dll文件反编译成il文件；
ildasm
 /all /out=MLitJson.il MLitJson.dll 

3.使用mykey.snk密钥对il文件进行签名，并输出为dll；
 ilasm
 /dll /key=mykey.snk 
MLitJson.il

如上操作都在命令行下进行。
【结果】
最后我们可以看到MLitJson已经被签名了，这样我们就可以任意引用它了。




参考：http://www.codeproject.com/Tips/341645/Referenced-assembly-does-not-have-a-strong-name

版权声明：本文为博主原创文章，未经博主允许不得转载。

Kth Smallest Element in a BST


Kth Smallest Element in a BST








题目如下：



Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note: 
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.





题目意思是说求的二叉查找树的第K小的值




思路：




我们知道二叉查找树的中序遍历为有序的，从小到大排列求第K小的值就是从大到小排列的第K个树，既然这样，我们可以先访问左孩子，然后根节点，然后右孩子，这样得到的序列就是从大到小，在记录K的值就是




代码如下：（用栈记录节点，一个节点出栈，k--，直到k==1）


重点注意，先访问左孩子，然后根节点，然后右孩子


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {

        stack<TreeNode *> result;
        TreeNode *p=root;

        while(!result.empty()||p!=NULL)
        {
            while(p)
            {
                result.push(p);
                p=p->left;
            }

            if(!result.empty())
            {
                p=result.top();
                result.pop();
                if(k==1)
                    return p->val;
                else
                    k--;
                p=p->right;
            }
        }
    }
};





版权声明：本文为博主原创文章，未经博主允许不得转载。

Count and Say --leetcode


Count and Say --leetcode








题目如下


The count-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, ...

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.
Given an integer n, generate the nth sequence.

Note: The sequence of integers will be represented as a string.




题目的意思是要递推，求第N词出现的字符串.（提取句子中出现的数字，如下解析）



如第一次: 1 (1个1)

第二次，在一次的基础上1求： 1个1 11（2个1）

第三次在第二次的基础上11求： 2个1 21（1个2，1个1）

第四次在第三次的基础上21求： 1个2，1个1 1211（1个1，1个2，2个1）

第五次在第四次基础上1211求：1个1，1个2，2个1 111221


注意，如果出现相同的 ，如第四次有1211 ，后面两位11出现了重复，那么需要统计总次数2，就是2个1，没有出现重复的就用1个表示




代码思路就是采用递推的方法，初始为“1”，然后递推求的下一个字符串result，然后替换掉初始字符串,中间需要用一个count记录出现的重复次数，我们用上面的第四次求的第五次为例：



对于
  temp="1211"  此时初始的值

  result=”“  此时的值，中间值

然后用 j=0;while（j<temp.length()）循环遍历 temp，用 t=j+1指向j的下一个字符，看看是不是相等，求的count的个数

第一次：  t指向2  此时 不 相等  那么count=1，  result=count+temp[j]=11;  令j=t；
第二次：j指向2，t指 向 1 ， 此时不相等，那么count=1；result=count+temp[j]=11+12=1112;
第三次：j指向1，t指向1，相等，那么t继续往前，count+1,直到字符结束，count=2,result=1112+count+temp[j]=1112+2+1=111221



如下：

class Solution {
public:
    string countAndSay(int n) {

        if(n<1)
            return "";

        string temp="1";
        string result;

        for(int i=2;i<=n;i++)
        {
            result="";
            int j=0;
            while(j<temp.length())
            {
                int t=j+1;
                int count=1;

                while(t<temp.length()&&temp[j]==temp[t])
                {
                    count++;
                    t++;
                }

                result+=(count+'0');
                result+=temp[j];
                j=t;
            }

            temp=result;
        }

        return temp;

    }
};





版权声明：本文为博主原创文章，未经博主允许不得转载。

POJ - 1611 The Suspects（简单并查集）

The Suspects




Time Limit: 1000MS
 
Memory Limit: 20000KB
 
64bit IO Format: %I64d & %I64u




Submit Status


Description

严重急性呼吸系统综合症( SARS), 一种原因不明的非典型性肺炎,从2003年3月中旬开始被认为是全球威胁。为了减少传播给别人的机会, 最好的策略是隔离可能的患者。
在Not-Spreading-Your-Sickness大学( NSYSU), 有许多学生团体。同一组的学生经常彼此相通,一个学生可以同时加入几个小组。为了防止非典的传播,NSYSU收集了所有学生团体的成员名单。他们的标准操作程序(SOP)如下：
一旦一组中有一个可能的患者, 组内的所有成员就都是可能的患者。
然而,他们发现当一个学生被确认为可能的患者后不容易识别所有可能的患者。你的工作是编写一个程序, 发现所有可能的患者。
 




Input

输入文件包含多组数据。
对于每组测试数据：
第一行为两个整数n和m, 其中n是学生的数量, m是团体的数量。0 < n <= 30000，0 <= m <= 500。
每个学生编号是一个0到n-1之间的整数，一开始只有0号学生被视为可能的患者。
紧随其后的是团体的成员列表，每组一行。
每一行有一个整数k，代表成员数量。之后,有k个整数代表这个群体的学生。一行中的所有整数由至少一个空格隔开。
n = m = 0表示输入结束，不需要处理。




Output

对于每组测试数据, 输出一行可能的患者。



Sample Input

100 4
2 1 2
5 10 13 11 12 14
2 0 1
2 99 2
200 2
1 5
5 1 2 3 4 5
1 0
0 0




Sample Output

4
1
1


简单并查集，最后遍历一下找到多少点和0在同一个集合就好了。
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std; 

const int MAXN = 30000 + 100;
int n, m;
int parent[MAXN];
int a[MAXN];

void make_set()
{
	for (int i = 0; i <= n; i++)
		parent[i] = i;
}

int find_set(int t)
{
	if (parent[t] == t)
		return t;
	else
		return parent[t] = find_set(parent[t]);
}

void union_set(int a, int b)
{
	int t1 = find_set(a);
	int t2 = find_set(b);
	if (t1 != t2)
	{
		parent[t2] = t1;
	}
}

int main()
{
	while (scanf("%d%d", &n, &m) != EOF&&n)
	{
		int num;
		make_set();
		for (int i = 0; i < m; i++)
		{
			scanf("%d", &num);
			for (int j = 0; j < num; j++)
				scanf("%d", &a[j]);
			for (int j = 1; j < num; j++)
			{
				union_set(a[j - 1], a[j]);
			}
		}
		int sum = 0;
		for (int i = 0; i < n; i++)
		{
			if (find_set(parent[0]) == find_set(parent[i]))
				sum++;
		}
		printf("%d\n", sum);
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

python解析ini、conf、cfg文件
1.使用python自带的ConfigParser模块：

#test.cfg文件内容：
[sec_a]
a_key1 = 20
a_key2 = 10
 
[sec_b]
b_key1 = 121
b_key2 = b_value2
b_key3 = $r
b_key4 = 127.0.0.1

读配置文件    



# -* - coding: UTF-8 -* -
import ConfigParser
#生成config对象
conf = ConfigParser.ConfigParser()
#用config对象读取配置文件
conf.read("test.cfg")
#以列表形式返回所有的section
sections = conf.sections()
print 'sections:', sections         #sections: ['sec_b', 'sec_a']
#得到指定section的所有option
options = conf.options("sec_a")
print 'options:', options           #options: ['a_key1', 'a_key2']
#得到指定section的所有键值对
kvs = conf.items("sec_a")
print 'sec_a:', kvs                 #sec_a: [('a_key1', '20'), ('a_key2', '10')]
#指定section，option读取值
str_val = conf.get("sec_a", "a_key1")
int_val = conf.getint("sec_a", "a_key2")
 
print "value for sec_a's a_key1:", str_val   #value for sec_a's a_key1: 20
print "value for sec_a's a_key2:", int_val   #value for sec_a's a_key2: 10
 
#写配置文件


#更新指定section，option的值
conf.set("sec_b", "b_key3", "new-$r")
#写入指定section增加新option和值
conf.set("sec_b", "b_newkey", "new-value")
#增加新的section
conf.add_section('a_new_section')
conf.set('a_new_section', 'new_key', 'new_value')
#写回配置文件
conf.write(open("test.cfg", "w"))

2.ConfigParser的一些问题：

                    1，不能区分大小写。
                    2，重新写入的ini文件不能保留原有 INI文件的注释。
                    3，重新写入的ini文件不能保持原有的顺序。
                    4，不支持嵌套。
                    5，不支持格式校验。

尝试下：configobj模块

    
#读文件
from configobj import ConfigObj  
    config = ConfigObj(filename)  
    #  
    value1 = config['keyword1']  
    value2 = config['keyword2']  
    #  
    section1 = config['section1']  
    value3 = section1['keyword3']  
    value4 = section1['keyword4']  
    #  
    # you could also write  
    value3 = config['section1']['keyword3']  
    value4 = config['section1']['keyword4'] 
     
     
#写文件如下：
from configobj import ConfigObj
config = ConfigObj()
config.filename = filename
#
config['keyword1'] = value1
config['keyword2'] = value2
#
config['section1'] = {}
config['section1']['keyword3'] = value3
config['section1']['keyword4'] = value4
#
section2 = {
    'keyword5': value5,
    'keyword6': value6,
    'sub-section': {
        'keyword7': value7
        }
}
config['section2'] = section2
#
config['section3'] = {}
config['section3']['keyword 8'] = [value8, value9, value10]
config['section3']['keyword 9'] = [value11, value12, value13]
#
config.write()


版权声明：本文为博主原创文章，未经博主允许不得转载。

