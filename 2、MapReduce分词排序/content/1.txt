(素材源码) 猫猫学iOS 之UIDynamic重力、弹性碰撞吸附等现象PS有惊喜
猫猫分享，必须精品
原创文章，欢迎转载。转载请注明：翟乃玉的博客 
地址：http://blog.csdn.net/u013357243
一：效果
 
 
 
 

二：代码
#import "ViewController.h"
#import "DemoViewController.h"

@interface ViewController ()
{
    // 功能名称的数组
    NSArray *_functions;
}

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    _functions = @[@"吸附行为", @"推动行为", @"刚性附加行为", @"弹性附加行为", @"碰撞检测"];
}

#pragma mark - 数据源方法
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return _functions.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 使用Storyboard建立的UITabeViewController，其中的Cell是已经注册过的
    static NSString *ID = @"Cell";
    // 永远都会找到一个单元格，如果缓冲池中没有，会自动新建
    /**
     dequeueReusableCellWithIdentifier 直接查询可重用单元格
     dequeueReusableCellWithIdentifier:forIndexPath: 查询“注册的”可重用单元格，此方法中indexPath本身没有用处

        * 强制判断是否注册了单元格

     如果已经注册过单元格，以上两个方法等效。

     如果在StoryBoard中指定了单元格的可重用标示符，单元格的优化将有系统接管，不再需要判断cell == nil
     */
//    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID forIndexPath:indexPath];

//    if (cell == nil) {
//        NSLog(@"come here");
//        
//        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];
//    }

    cell.textLabel.text = _functions[indexPath.row];

    return cell;
}

#pragma mark - 代理方法
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    DemoViewController *controller = [[DemoViewController alloc] init];

    // 指定标题
    controller.title = _functions[indexPath.row];
    controller.function = indexPath.row;

    [self.navigationController pushViewController:controller animated:YES];
}

#import "DemoViewController.h"
#import "DemoView.h"
#import "SnapView.h"
#import "PushView.h"
#import "AttachmentView.h"
#import "SpringView.h"
#import "CollisionView.h"

@interface DemoViewController ()

@end

@implementation DemoViewController

//- (void)loadView
//{
//    self.view = [[DemoView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame];
//}

- (void)viewDidLoad
{
    [super viewDidLoad];

    NSLog(@"功能代号： %d", self.function);
    // 在此根据实际的功能代号加载实际的视图

    DemoView *demoView = nil;
    switch (self.function) {
        case kDemoFunctionSnap:
            demoView = [[SnapView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionPush:
            demoView = [[PushView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionAttachment:
            demoView = [[AttachmentView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionSpring:
            demoView = [[SpringView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionCollision:
            demoView = [[CollisionView alloc] initWithFrame:self.view.bounds];
            break;
        default:
            break;
    }

    [self.view addSubview:demoView];
}


@end

主要框框就这样啦，贴出了的代码仅仅部分
三：素材代码下载地址
http://download.csdn.net/detail/u013357243/9043837
ps：很久没有上传源代码了，最近帮朋友做做项目然后自己学学习，感觉iOS学习起来比Android体验好多了，注意撒，是学习体验。。。
ps2：猫猫要找工作了，北广深有木有人收留。。。喵呜
ps3：惊喜~~~

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

最老程序员创业开发实训1---Android应用架构之MVC
我们都知道Android中基本组件是Activity，每个界面都是一个Activity，自从2.3版本开始，又增加了Fragment组件，提供了适应于各种屏幕方法。但是由于Android系统只是提供了各种可用的编程技术，并没有对应用架构进规定。实践中，很多项目将所有功能都添加到了Activity中，使Activity变得十分臃肿，不便于进行后期修改和维护。如果我们要一个人来开发一个系统，那么必须采用高效的应用架构，方便调试及维护。
在开发应用中，采用MVC架构无疑是一种最安全的选择，将应用按照控制器、视图、模型来组织，使系统的耦合减少，灵活性增加，更方便于调试和维护。但是问题就来了，通常程序员们会说：Android平台所有组件都是基于MVC的，我的应用自然就是基于MVC架构的呀！其实这是一种典型的错解，Android组件是基于MVC的不假，但是你的程序在Activity中既保存着从网络获取到的数据，又负责页面更新和显示，同时还有业务逻辑，这时这个Activity就几乎同时拥有了模型、视图、控制器功能了，实际上是不符合MVC精神的。
那么在Android平台中，怎样体现MVC架构呢？关于这一点，很多不同的看法。在这里只向大家介绍其中的一种，之所以选择这种，是因为他与IOS平台上的理念一致，我们要同时开发Android和IOS系统，那么同样理念的东西，自然是我们最佳选择了。
对于一个Android中最基本的组件Activity来说，我们可以将布局文件视为视图（View），而Activity可以视为控制器（Controller），控制器需要与视图进行交互，这时就需要在Activity中获取页面中的各个控件，在Android中通过findViewById方法来实现，而在IOS平台中，采用IOutlet形式实现。当视图中产生一个事件，如用户点击某按钮，这时需要触发一个事件，这时Android有两种处理方式，一种是直接在布局文件中写click=""，另一种是通过在Activity中通过调用setOnclickListener来实现，我推荐采用第二种方案，因为这样不仅是避免了视图与控制器逻辑搅合在一起，同时也为了与IOS中采用IAction方式保存一致。这样当需要改变界面内容时，可以在Activity中通过对界面中的控件进行操作，而界面中产生的事件，通过Activity中定义的事件处理函数来进行处理。这样就有效的区分了控制器和视图的职能。
对于界面中需要显示的数据，我们需要设计单独的模型类，Activity在需要时，调用模型类的相关方法，获取数据并显示到界面中，但是模型类不直接调用Activity的方法。那么，如果模型中的数据改变了，怎样通知界面进行更新呢？这里我们采用事件总线机制，当模型数据发生改变时，会向系统总线发送一个事件。所有Activity会向自己所感兴趣的事件进行注册，方法就将自己的Handler实例加入到事件总线的列表中。这样当模型数据改后，事件总件收到来自模型类的事件，找出对该事件感兴趣的Hanlder实例列表，依次向每个Handler实例发送消息，这样每个相关的Activity就可以对模型类数据变化做出正确的响应了。在IOS中，每个类的属性会有willSet,
 didSet这样的观察者方法，可以在这些方法中向事件总线发送事件。
应用程序架构如下图所示：


从上图可以看出，模型（Model）和视图（View）不会主动调用Activity，同时模型（Model）和视图（View）之不发生直接的关系，二者之间的交互都统一通过Activity来进行。稍后我们将看到，在IOS平台下，我们也会采用相同的架构。
在下一篇博文中，我们将以这个架构为指导，做程序开始时的Splash页面。然后我们会回过头来，描述在IOS平台下，采用Swift 2.0来实现相同的功能。


大家的支持是我继续前进的动力，请大家多多支持：
银行账号：622202 0200 1078 56128 闫涛
我的支付宝：yt7589@hotmail.com


版权声明：本文为博主原创文章，未经博主允许不得转载。

猫猫学iOS 之UIDynamic重力、弹性碰撞吸附等现象
猫猫分享，必须精品
原创文章，欢迎转载。转载请注明：翟乃玉的博客 
地址：http://blog.csdn.net/u013357243
一：效果
重力和碰撞 

吸附现象 

二：简介
什么是UIDynamic 
UIDynamic是从iOS 7开始引入的一种新技术，隶属于UIKit框架 
可以认为是一种物理引擎，能模拟和仿真现实生活中的物理现象 
重力、弹性碰撞等现象
物理引擎的价值 
广泛用于游戏开发，经典成功案例是“愤怒的小鸟” 
让开发人员可以在远离物理学公式的情况下，实现炫酷的物理仿真效果 
提高了游戏开发效率，产生更多优秀好玩的物理仿真游戏
知名的2D物理引擎
    Box2d
    Chipmunk

三：使用步骤和代码
步骤
要想使用UIDynamic来实现物理仿真效果，大致的步骤如下 
1，创建一个物理仿真器（顺便设置仿真范围）。
2，创建相应的物理仿真行为（顺便添加物理仿真元素）。
3，将物理仿真行为添加到物理仿真器中  开始仿真。

简单认识
物理仿真元素（Dynamic Item）谁要进行物理仿真？
物理仿真行为（Dynamic Behavior） 执行怎样的物理仿真效果？怎样的动画效果？
物理仿真器（Dynamic Animator）让物理仿真元素执行具体的物理仿真行为
注意： 
不是任何对象都能做物理仿真元素。 
不是任何对象都能进行物理仿真。
任何遵守了UIDynamicItem协议的对象才能做物理仿真元素。 
UIView默认已经遵守了UIDynamicItem协议，因此任何UI控件都能做物理仿真。 
UICollectionViewLayoutAttributes类默认也遵守UIDynamicItem协议。
UIDynamic提供了以下几种物理仿真行为
UIGravityBehavior：重力行为 
UICollisionBehavior：碰撞行为 
UISnapBehavior：捕捉行为 
UIPushBehavior：推动行为 
UIAttachmentBehavior：附着行为 
UIDynamicItemBehavior：动力元素行为
物理仿真行为须知 
上述所有物理仿真行为都继承自UIDynamicBehavior 
所有的UIDynamicBehavior都可以独立进行 
组合使用多种行为时，可以实现一些比较复杂的效果
物理仿真器
它可以让物理仿真元素执行物理仿真行为 
它是UIDynamicAnimator类型的对象
UIDynamicAnimator的初始化
- (instancetype)initWithReferenceView:(UIView *)view;
view参数：是一个参照视图，表示物理仿真的范围 
UIDynamicAnimator的常见方法
- (void)addBehavior:(UIDynamicBehavior *)behavior;
添加1个物理仿真行为
- (void)removeBehavior:(UIDynamicBehavior *)behavior;
移除1个物理仿真行为
- (void)removeAllBehaviors;
移除之前添加过的所有物理仿真行为
UIDynamicAnimator的常见属性
@property (nonatomic, readonly) UIView* referenceView;
参照视图
@property (nonatomic, readonly, copy) NSArray* behaviors;
添加到物理仿真器中的所有物理仿真行为
@property (nonatomic, readonly, getter = isRunning) BOOL running;
是否正在进行物理仿真
@property (nonatomic, assign) id <UIDynamicAnimatorDelegate> delegate;
代理对象（能监听物理仿真器的仿真过程，比如开始和结束）
代码
演示效果小应用的实现代码
#import "HMViewController.h"

@interface HMViewController ()
/**
 *  红色view
 */
@property (weak, nonatomic) IBOutlet UIView *redView;
/**
 *  物理仿真器
 */
@property (nonatomic, strong) UIDynamicAnimator *anim;

@property (weak, nonatomic) IBOutlet UISegmentedControl *st;
@end

@implementation HMViewController

- (UIDynamicAnimator *)anim
{
    if (!_anim) {
        _anim = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
    }
    return _anim;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
//    [self test];
//    [self test2];
    [self test3:touches];
}

-(void)test3:(NSSet *)touches
{
    // 1.获取当前触摸的手指
    UITouch *touch = [touches anyObject];
    // 2.更具手指取出位置
    CGPoint point = [touch locationInView:touch.view];

    // 吸附行为
    // 1.创建物理仿真器
    // 2.创建物理仿真行为
    UISnapBehavior *snapB = [[UISnapBehavior alloc] initWithItem:self.redView snapToPoint:point];

    // 设置吸附行为的"减震"
    snapB.damping = 0;

    // 注意: 吸附行为默认只能吸附一次, 如果多次吸附必须从仿真器中移除再重新添加
    [self.anim removeAllBehaviors];

    // 3.将物理仿真行为添加到仿真器中
    [self.anim addBehavior:snapB];
}

- (void)test2
{
    // 碰撞
    // 1.创建物理仿真器
    // 2.创建物理仿真行为
    UIGravityBehavior *gravigtyB = [[UIGravityBehavior alloc] initWithItems:@[self.redView]];
    //    gravigtyB.magnitude = 100;

    // 创建碰撞仿真行为
    UICollisionBehavior *collisionB = [[UICollisionBehavior alloc] initWithItems:@[self.redView, self.st]];
    // 设置碰撞的边界
    //    collisionB.translatesReferenceBoundsIntoBoundary = YES;

    // 添加直线边界
    //    [collisionB addBoundaryWithIdentifier:@"line" fromPoint:CGPointMake(0, 200) toPoint:CGPointMake(320, 420)];

    // 添加图形的边界
    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:self.view.frame];
    [collisionB addBoundaryWithIdentifier:@"abc" forPath:path];


    // 3.将物理仿真行为添加到仿真器中
    [self.anim addBehavior:gravigtyB];
    [self.anim addBehavior:collisionB];
}

/**
 *  重力
 */
- (void)test
{
    // 演示重力行为
    // 1.创建物理仿真器
    // 并且指定了当前控制器的view作为仿真范围
    //    UIDynamicAnimator *anim = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];

    // 2.创建物理仿真行为
    // 并且指定红色为作为仿真元素
    UIGravityBehavior *gravityB = [[UIGravityBehavior alloc] initWithItems:@[self.redView]];


    // 设置重力的方向
    //    gravityB.gravityDirection = CGVectorMake(1, 0);
    //    gravityB.gravityDirection = CGVectorMake(0, -1);
    //    gravityB.gravityDirection = CGVectorMake(1, 1);
    // 设置重力的角度
    //    gravityB.angle = M_PI_2;

    // 设置重力的加速度
    gravityB.magnitude = 100.0;

    // 3.将物理仿真行为添加到仿真器中
    [self.anim addBehavior:gravityB];
}
@end

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

android 圆形ListView实现，并附带圆角ImageView
转载请注明出处：王亟亟的大牛之路
平时 垂直向下的ListView已经司空见惯，换一种带一定角度的圆角ListView应该会给用户不同的体验
项目目录： 
 
2个自定义View一个主Activity 
MainActivity
public class MainActivity extends Activity {

    private ListView lv;
    //本地图片模拟数据源
    private int[] images = new int[] { R.drawable.p1, R.drawable.p2, R.drawable.p3 };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        lv = (ListView)findViewById(R.id.lv);
        lv.setAdapter(new MyAdapter(MakeData()));
        try {
            changeGroupFlag(lv);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //翻滚的过程中不断绘制
        lv.setOnScrollListener(new OnScrollListener() {
            @Override
            public void onScrollStateChanged(AbsListView view, int scrollState) {
            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                for (int i = 0; i < lv.getChildCount(); i++) {
                    lv.getChildAt(i).invalidate();
                }
            }
        });
        //监听事件，测试是否会出现item移位
        lv.setOnItemClickListener(new OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                Toast.makeText(MainActivity.this,"第"+position+"个被按到了", Toast.LENGTH_SHORT).show();
            }
        });
    }
    //自定义适配器
    class MyAdapter extends BaseAdapter {

        public final class ViewHolder{
        public ImageView imageView;
        public TextView text;
        }
        //传入的数据源
        private List<String> data;

        public MyAdapter(List<String> data){
            this.data=data;
        }

        @Override
        public int getCount() {
            return data.size();
        }

        @Override
        public Object getItem(int position) {
            return null;
        }

        @Override
        public long getItemId(int position) {
            return 0;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
             ViewHolder holder = null;
             if (convertView == null) {
                holder=new ViewHolder(); 
                MatrixView m = (MatrixView)LayoutInflater.from(MainActivity.this).inflate(R.layout.view_list_item, null);
                m.setParentHeight(lv.getHeight());
                convertView = m;
                holder.text=(TextView)convertView.findViewById(R.id.text);
                holder.imageView = (ImageView)convertView.findViewById(R.id.image);
                convertView.setTag(holder);
              }else {
                 holder = (ViewHolder)convertView.getTag();
              }
             holder.text.setText(data.get(position)+"");
             holder.imageView.setImageResource(images[position % images.length]);          
            return convertView;
        }

    }

    public void changeGroupFlag(Object obj) throws Exception// 反射替换对所有String进行替换
    {
        Field[] f = obj.getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredFields(); // 获得成员映射数组
        for (Field tem : f) // 迭代for循环
        {
            if (tem.getName().equals("mGroupFlags")) {
                tem.setAccessible(true);
                Integer mGroupFlags = (Integer)tem.get(obj); // 返回内容
                int newGroupFlags = mGroupFlags & 0xfffff8;
                tem.set(obj, newGroupFlags);// 替换成员值
            }
        }
    }

    private List<String> MakeData(){
        List<String> data=new ArrayList<String>();
        for(int k=0;k<100;k++){
            data.add("麦麦你好 "+k);
        }
        return data;
    }
}
自定义圆角图片
public class RoundImageView extends ImageView {

    private float xRadius = 10;
    private float yRadius = 10;
    private Paint paint = new Paint();

    public RoundImageView(Context context) {
        super(context);
    }

    public RoundImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public float getxRadius() {
        return xRadius;
    }

    public void setxRadius(float xRadius) {
        this.xRadius = xRadius;
    }

    public float getyRadius() {
        return yRadius;
    }

    public void setyRadius(float yRadius) {
        this.yRadius = yRadius;
    }

    @SuppressWarnings("deprecation")
    @Override
    protected void onDraw(Canvas canvas) {
        // java.lang.ClassCastException: android.graphics.drawable.TransitionDrawable cannot be cast
        // to android.graphics.drawable.BitmapDrawable
        BitmapShader shader;
        if (getDrawable() instanceof BitmapDrawable) {
            BitmapDrawable bitmapDrawable = (BitmapDrawable)getDrawable();
            // clip
            shader = new BitmapShader(bitmapDrawable.getBitmap(), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
            RectF rect = new RectF(0.0f, 0.0f, getWidth(), getHeight());
            int width = bitmapDrawable.getBitmap().getWidth();
            int height = bitmapDrawable.getBitmap().getHeight();
            RectF src = null;
            if (((float)width) / height > 1) {
                src = new RectF(0.0f, 0.0f, height, height);
            } else {
                src = new RectF(0.0f, 0.0f, width, width);
            }
            Matrix matrix = canvas.getMatrix();
            matrix.setRectToRect(src, rect, Matrix.ScaleToFit.CENTER);
            shader.setLocalMatrix(matrix);

            // 抗锯齿
            paint.setAntiAlias(true);
            paint.setShader(shader);
            // draw round circle for HeadImage or other
            canvas.drawRoundRect(rect, this.getWidth() / 2, this.getHeight() / 2, paint);
            // canvas.drawRoundRect(rect, xRadius, yRadius / 2, paint);
        }
    }
}
自定义布局
public class MatrixView extends LinearLayout {
    private int h = 0;
    private float fullAngelFactor = 10f;
    private float fullScaleFactor=1;
    public MatrixView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public void setParentHeight(int height) {
        h = height;
    }

    @Override
    protected void dispatchDraw(Canvas canvas) {
        canvas.save();
        int top = getTop();

        float rotate = calculateAngel(top, h);
        float scale = calcuylateScale(top, h);

        Matrix m = canvas.getMatrix();
        m.preTranslate(-2 / getWidth(), -2 / getHeight());
        m.postScale(scale, scale);
        m.postTranslate(2 / getWidth(), 2 / getHeight());
        m.postRotate(rotate);
        canvas.concat(m);
        super.dispatchDraw(canvas);
        canvas.restore();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }

    private float calculateAngel(int top, int h) {
        float result = 0f;
        if (top < h / 2f) {
            result = (top - (h / 2f)) / (h / 2f) * fullAngelFactor;
        } else if (top > h / 2f) {
            result = (top - (h / 2f)) / (h / 2f) * fullAngelFactor;
        }
        return result;
    }

    private float calcuylateScale(int top, int h) {
        float result = 0f;

        result = (1f - 1f/2f*Math.abs((top - h / 2f)) / (h / 2f)) * fullScaleFactor;
        return result;

    }
}

private float fullAngelFactor 为旋转的角度 
 private float fullScaleFactor 为试图放大缩小的比例
private float fullAngelFactor=40f时：
主布局就补贴了，就是一个ListView
每一个Item
<?xml version="1.0" encoding="utf-8"?>
<com.wjj.test.MatrixView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal" >

    <com.wjj.test.RoundImageView
        android:id="@+id/image"
        android:layout_width="80dp"
        android:layout_height="80dp"
        android:layout_marginLeft="30dp"
        android:scaleType="centerCrop" />

    <TextView
        android:id="@+id/text"
        android:layout_width="match_parent"
        android:layout_height="80dp"
        android:gravity="left|center_vertical"
        android:paddingLeft="20dp"
        android:textSize="18sp" />

</com.wjj.test.MatrixView>
具体实现可以看代码，附上源码下载地址：http://yunpan.cn/cmy9fi3fMDY7U  访问密码 0982
部分代码来源于互联网，如有重复请见谅

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        RecyclerView 列表控件中简单实现时间线
时间
时间，时间，时间啊；走慢一点吧～
看见很多软件中都有时间线的东西，貌似天气啊，旅游啊什么的最多了；具体实现方式很多，在本篇文章中讲解一种自定义View封装的方式。
效果
先来看看效果。 

分析
软件中，可以看见前面的时间线也就是线条加上圆圈组成；当然这里的圆圈与线条也都是可以随意换成其他的，比如图片等等。
当然这里最简单的来说，是上面一个线条，然后一个圆圈，然后下面一个线条；上线条在第一条数据时不做显示，下线条在最后一条数据时不做显示。

这里自定义布局部分也就是把旁边的线条与圆圈封装到一起，并使用简单的方法来控制是否显示。 
当封装好了后，与旁边的文字部分也就是水瓶方向的线性布局了，然后设置为每一个的RecyclerView 的Item的布局也就完成了。
控件
控件很简单，首先我们继承View，取名为 TimeLineMarker 就OK。
Attrs 属性
开始控件之前先准备好需要的属性。
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="TimeLineMarker">
        <attr name="markerSize" format="dimension" />
        <attr name="marker" format="color|reference" />
        <attr name="beginLine" format="color|reference" />
        <attr name="endLine" format="color|reference" />
        <attr name="lineSize" format="dimension" />
    </declare-styleable>
</resources>
在这里也就准备了线条的大小、开始线条、结束线条、中间标示部分及大小。
属性与现实
    private int mMarkerSize = 24;
    private int mLineSize = 12;
    private Drawable mBeginLine;
    private Drawable mEndLine;
    private Drawable mMarkerDrawable;

    @Override
    protected void onDraw(Canvas canvas) {
        if (mBeginLine != null) {
            mBeginLine.draw(canvas);
        }

        if (mEndLine != null) {
            mEndLine.draw(canvas);
        }

        if (mMarkerDrawable != null) {
            mMarkerDrawable.draw(canvas);
        }

        super.onDraw(canvas);
    }
两个大小属性，3个具体的Drawable，然后在onDraw方法中进行具体的显示也就OK。
构造与属性初始化
在上面我们定义了属性，在这里我们在构造函数中获取XML所设置的属性。

    public TimeLineMarker(Context context) {
        this(context, null);
    }

    public TimeLineMarker(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public TimeLineMarker(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init(attrs);
    }

    private void init(AttributeSet attrs) {
        // Load attributes
        final TypedArray a = getContext().obtainStyledAttributes(
                attrs, R.styleable.TimeLineMarker, 0, 0);

        mMarkerSize = a.getDimensionPixelSize(
                R.styleable.TimeLineMarker_markerSize,
                mMarkerSize);

        mLineSize = a.getDimensionPixelSize(
                R.styleable.TimeLineMarker_lineSize,
                mLineSize);

        mBeginLine = a.getDrawable(
                R.styleable.TimeLineMarker_beginLine);

        mEndLine = a.getDrawable(
                R.styleable.TimeLineMarker_endLine);

        mMarkerDrawable = a.getDrawable(
                R.styleable.TimeLineMarker_marker);

        a.recycle();

        if (mBeginLine != null)
            mBeginLine.setCallback(this);

        if (mEndLine != null)
            mEndLine.setCallback(this);

        if (mMarkerDrawable != null)
            mMarkerDrawable.setCallback(this);
    }
Drawable 的位置与大小初始化
属性啥的有了，具体的Drawable 也有了，要显示的地方调用也是OK了；但是如果没有进行进行具体的位置调整这一切也都没有意义。
    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        initDrawableSize();
    }

    private void initDrawableSize() {
        int pLeft = getPaddingLeft();
        int pRight = getPaddingRight();
        int pTop = getPaddingTop();
        int pBottom = getPaddingBottom();

        int width = getWidth();
        int height = getHeight();

        int cWidth = width - pLeft - pRight;
        int cHeight = height - pTop - pBottom;

        Rect bounds;

        if (mMarkerDrawable != null) {
            // Size
            int markerSize = Math.min(mMarkerSize, Math.min(cWidth, cHeight));
            mMarkerDrawable.setBounds(pLeft, pTop,
                    pLeft + markerSize, pTop + markerSize);

            bounds = mMarkerDrawable.getBounds();
        } else {
            bounds = new Rect(pLeft, pTop, pLeft + cWidth, pTop + cHeight);
        }


        int halfLineSize = mLineSize >> 1;
        int lineLeft = bounds.centerX() - halfLineSize;

        if (mBeginLine != null) {
            mBeginLine.setBounds(lineLeft, 0, lineLeft + mLineSize, bounds.top);
        }

        if (mEndLine != null) {
            mEndLine.setBounds(lineLeft, bounds.bottom, lineLeft + mLineSize, height);
        }
    }
initDrawableSize 方法进行具体的运算，而运算的时间点就是当控件的大小改变（onSizeChanged）的时候。
在初始化中采用了一定的投机取巧；这里利用了上内边距与下内边距分别作为上线条与下线条的长度；而线条与中间的标识都采用了水平距中。
其他设置方法

    public void setLineSize(int lineSize) {
        if (mLineSize != lineSize) {
            this.mLineSize = lineSize;
            initDrawableSize();
            invalidate();
        }
    }

    public void setMarkerSize(int markerSize) {
        if (this.mMarkerSize != markerSize) {
            mMarkerSize = markerSize;
            initDrawableSize();
            invalidate();
        }
    }

    public void setBeginLine(Drawable beginLine) {
        if (this.mBeginLine != beginLine) {
            this.mBeginLine = beginLine;
            if (mBeginLine != null) {
                mBeginLine.setCallback(this);
            }
            initDrawableSize();
            invalidate();
        }
    }

    public void setEndLine(Drawable endLine) {
        if (this.mEndLine != endLine) {
            this.mEndLine = endLine;
            if (mEndLine != null) {
                mEndLine.setCallback(this);
            }
            initDrawableSize();
            invalidate();
        }
    }

    public void setMarkerDrawable(Drawable markerDrawable) {
        if (this.mMarkerDrawable != markerDrawable) {
            this.mMarkerDrawable = markerDrawable;
            if (mMarkerDrawable != null) {
                mMarkerDrawable.setCallback(this);
            }
            initDrawableSize();
            invalidate();
        }
    }
在设置中，首先判断是否更改，如果更改那么就更新并重新计算位置；随后刷新界面。

到这里，控件差不多准备OK了，其中还有很多可以完善的地方，比如加上快捷设置颜色什么的，也可以加上大小计算的东西。同时还可以加上时间线是水瓶还是垂直等等。在这里就不累赘介绍哪些了。下面来看看如何使用。

使用
XML布局
ITEM布局item_time_line.xml
<?xml version="1.0" encoding="utf-8"?>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:paddingLeft="@dimen/lay_16"
    android:paddingRight="@dimen/lay_16"
    tools:ignore="MissingPrefix">

    <net.qiujuer.example.timeline.widget.TimeLineMarker
        android:id="@+id/item_time_line_mark"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:paddingBottom="@dimen/lay_16"
        android:paddingLeft="@dimen/lay_4"
        android:paddingRight="@dimen/lay_4"
        android:paddingTop="@dimen/lay_16"
        app:beginLine="@color/black_alpha_32"
        app:endLine="@color/black_alpha_32"
        app:lineSize="2dp"
        app:marker="@drawable/ic_timeline_default_marker"
        app:markerSize="24dp" />

    <TextView
        android:id="@+id/item_time_line_txt"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:paddingBottom="@dimen/lay_16"
        android:paddingLeft="@dimen/lay_4"
        android:paddingRight="@dimen/lay_4"
        android:paddingTop="@dimen/lay_16"
        android:textColor="@color/grey_600"
        android:textSize="@dimen/font_16" />

</LinearLayout>
在这里我们之间使用顺序布局，左边是TimelIne控件，右边是一个简单的字体控件，具体使用中可以细化一些。 
在TImeLine控件中我们的Mark是使用的drawable/ic_timeline_default_marker；这个就是一个简单的圆圈而已；对于自己美化可以使用一张图片代替或者更加复杂的布局；当然上面的线条就更加简单了，就直接使用颜色代替。
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="@color/cyan_500" />
    <stroke
        android:width="1dp"
        android:color="@color/black_alpha_32" />
</shape>
主界面XML RecyclerView
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity">

    <android.support.v7.widget.RecyclerView
        android:id="@+id/time_line_recycler"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clickable="true"
        android:fadeScrollbars="true"
        android:fadingEdge="none"
        android:focusable="true"
        android:focusableInTouchMode="true"
        android:overScrollMode="never"
        android:scrollbarSize="2dp"
        android:scrollbarThumbVertical="@color/cyan_500"
        android:scrollbars="vertical" />

</RelativeLayout>
在这里就是加上了一个RecyclerView 控件在主界面就OK。
Java代码部分
在开始之前先来看看我们的文件具体有些神马。 


widget中就是具体的自定义控件，model是具体的数据模型，adapter部分，这里有一个Recyclerview的adapter文件，以及一个具体的Item TimeLineViewHolder，当然在这里还定义了一个ItemType类，该类用来标示每个Item的类型，比如头部，第一个，普通，最后一个，底部等等。

TimeLineModel.java
package net.qiujuer.example.timeline.model;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineModel {
    private String name;
    private int age;

    public TimeLineModel() {

    }

    public TimeLineModel(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }
}

一个名字，一个年龄也就OK。
ItemType.java
package net.qiujuer.example.timeline.adapter;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class ItemType {
    public final static int NORMAL = 0;

    public final static int HEADER = 1;
    public final static int FOOTER = 2;

    public final static int START = 4;
    public final static int END = 8;

    public final static int ATOM = 16;
}

分别定义了几个静态值，分别代表普通、头部、底部、开始、结束、原子；当然其中有些可以不用定义。
TimeLineViewHolder.java
package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.View;
import android.widget.TextView;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;
import net.qiujuer.example.timeline.widget.TimeLineMarker;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineViewHolder extends RecyclerView.ViewHolder {
    private TextView mName;

    public TimeLineViewHolder(View itemView, int type) {
        super(itemView);

        mName = (TextView) itemView.findViewById(R.id.item_time_line_txt);

        TimeLineMarker mMarker = (TimeLineMarker) itemView.findViewById(R.id.item_time_line_mark);
        if (type == ItemType.ATOM) {
            mMarker.setBeginLine(null);
            mMarker.setEndLine(null);
        } else if (type == ItemType.START) {
            mMarker.setBeginLine(null);
        } else if (type == ItemType.END) {
            mMarker.setEndLine(null);
        }

    }

    public void setData(TimeLineModel data) {
        mName.setText("Name:" + data.getName() + " Age:" + data.getAge());
    }
}

该文件为RecyclerView 的Adapter中每个Item需要实现的Holder类。 
在该类中，我们在构造函数中需要传入一个根View同时传入一个当然item的状态。 
随后使用find….找到控件，在这里我们把TextView保存起来，而TimeLineView找到后直接进行初始化设置。 
根据传入的ItemType来判断是否是第一个，最后一个，以及原子；然后设置TimeLineView的属性。 
在下面的setData方法中我们显示具体的Model数据。
TimeLineAdapter.java
适配器部分，我们需要做的工作是；根据具体的数据渲染上对应的界面就OK。
package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;

import java.util.List;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineAdapter extends RecyclerView.Adapter<TimeLineViewHolder> {
    private List<TimeLineModel> mDataSet;

    public TimeLineAdapter(List<TimeLineModel> models) {
        mDataSet = models;
    }

    @Override
    public int getItemViewType(int position) {
        final int size = mDataSet.size() - 1;
        if (size == 0)
            return ItemType.ATOM;
        else if (position == 0)
            return ItemType.START;
        else if (position == size)
            return ItemType.END;
        else return ItemType.NORMAL;
    }

    @Override
    public TimeLineViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        // Create a new view.
        View v = LayoutInflater.from(viewGroup.getContext())
                .inflate(R.layout.item_time_line, viewGroup, false);
        return new TimeLineViewHolder(v, viewType);
    }

    @Override
    public void onBindViewHolder(TimeLineViewHolder timeLineViewHolder, int i) {
        timeLineViewHolder.setData(mDataSet.get(i));
    }

    @Override
    public int getItemCount() {
        return mDataSet.size();
    }
}

在这里需要着重说一下：我复写了getItemViewType方法；在该方法中我们需要设置对应的Item的类型；在这里传入的是item的坐标，需要返回的是item的具体状态，该状态标示是int类型；在这里我使用的是ItemType的静态属性。
该方法会在调用onCreateViewHolder方法之前调用；而onCreateViewHolder方法中的第二个参数int值也就是从getItemViewType之中来；所以我们可以在这里进行对应的数据状态标示。
而在onCreateViewHolder方法中我们返回一个：TimeLineViewHolder就OK，随后在onBindViewHolder方法中进行数据初始化操作。

MainActivity.java
上面所有都准备好了，下面就进行具体的显示。 
在这里就只贴出核心代码了；篇幅也是有些长。

    private RecyclerView mRecycler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mRecycler = (RecyclerView) findViewById(R.id.time_line_recycler);
        initRecycler();
    }

    private void initRecycler() {
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);

        TimeLineAdapter adapter = new TimeLineAdapter(getData());

        mRecycler.setLayoutManager(layoutManager);
        mRecycler.setAdapter(adapter);
    }

    private List<TimeLineModel> getData() {
        List<TimeLineModel> models = new ArrayList<TimeLineModel>();

        models.add(new TimeLineModel("XiaoMing", 21));
        models.add(new TimeLineModel("XiaoFang", 20));
        models.add(new TimeLineModel("XiaoHua", 25));
        models.add(new TimeLineModel("XiaoA", 22));
        models.add(new TimeLineModel("XiaoNiu", 23));

        return models;
    }
在这里就是傻瓜的操作了，流程就是准备好对应的数据，装进Adapter，准备好对应的布局方式，然后都设置到RecyclerView中就OK。
效果
来看看具体的效果： 

效果虽然简单，但是也算是五脏具全；其中无非就是控件的自定义。这个自定义是可以扩展的，大家可以扩展为水平方向试试。
代码
博客代码都开源到项目中了。 
地址：https://github.com/qiujuer/BeFoot/tree/master/blog/sample/TimeLine
写在最后
文章的开始截屏来源于：最近没事儿捣鼓了一个APP［UPMiss］，一个简单的生日，纪念日提醒软件；欢迎大家尝鲜。
｛UPMiss｝ 思念你的夏天 
下载地址：

魅族
百度 这个审核有问题，明明没有支付的东西，结果说有支付的SDK存在，不得不说百度的自动审核有很大漏洞。
豌豆荚 新版2.0还在审核中！

======================================================== 
作者：qiujuer 
博客：blog.csdn.net/qiujuer 
网站：www.qiujuer.net 
开源库：github.com/qiujuer/Genius-Android 
开源库：github.com/qiujuer/Blink 
转载请注明出处：http://blog.csdn.net/qiujuer/article/details/47910185 
—— 学之开源，用于开源；初学者的心态，与君共勉！
========================================================

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        IOS不用AutoLayout也能实现自动布局的类(4)----MyTableLayout横空出世
       前面的几篇文章里我分别介绍了线性布局(MyLinearLayout)，相对布局(MyRelativeLayout)，框架布局(MyFrameLayout)这三种布局。这三种布局中
 ：
线性布局主要应用于容器视图里面的所有子视图依次从上往下排列或者从左往右排列的场景。


垂直线性布局


子视图1


子视图2


子视图3


子视图4





水平线性布局


子视图1
子视图2
子视图3
子视图4




当然我们也可以用线性布局嵌套线性布局的方法来实现一些复杂的界面布局，比如(这个例子如果用MyTableLayout实现将更加简单)：




复杂布局






水平线性布局子视图1
水平线性布局子视图2











子视图1
子视图2
子视图3











子视图1


子视图2


子视图3









相对布局主要用于容器视图中的各个子视图之间的位置和高宽以及子视图和容器视图之间具有一定的依赖和约束关系的场景。比如说子视图1的位置在子视图2的右下角，并且宽度等于子视图3的宽度，而子视图3的底部又在容器视图的底部。
           

相对布局


子视图1(等宽3)
 
 


 
子视图2
 


 
 
子视图3(等宽1)



相对布局因为需要指定各子视图之间的依赖关系，因此如果设置不当就会产生递归死循环的情况，而且在某种程度上不利于子视图之间的位置的更新和变化等等，其中IOS自带的AutoLayout其实就是一套相对布局的实现，相对布局功能很强大也可以很容易布局复杂的界面，缺点是使用不当的话就容易造成约束死循环的情况。


框架布局主要用于容器视图中的个子视图在容器视图的上，中，下，左，中，右，拉升填充，居中显示等11种情况。


框架布局


左上
中上
右上


左中
居中
右中


左下
中下
右下




框架布局中的子视图只跟容器视图之间产生关系，子视图之间没有任何关联关系。


一、表格布局的介绍


    在一些实际的应用界面中，我们希望我们的子视图以表格的形式展示出来，这些表格展示可以是正规的几行几列并且固定高宽的形式，也可能是每一行的列数都不同，也可能是每行的高度不一样，也可能是一行内的各列的宽度也不一样，


               水平表格布局
                                                                                                                           
            
                                                                                                                                                 垂直表格布局










































要实现上面的两种界面风格，我们可以借助MyTableLayout来实现。


MyTableLayout是从MyLinearLayout中继承而来，因此表格布局也分为垂直表格布局和水平表格布局，样式请参考上面的图例的展示风格。而表格的风格样式同样通过
orientation属性来设置。不管是垂直表格布局还是水平表格布局。我们在建立了表格布局视图并指定了表格风格后，我们首先的步骤是要为表格添加行(如果是水平表格其实就是添加列，下面如果为说明都是如此概念)，那这个步骤可以通过MyTableLayout的方法：



-(void)addRow:(CGFloat)rowHeight colWidth:(CGFloat)colWidth;
-(void)insertRow:(CGFloat)rowHeight colWidth:(CGFloat)colWidth atIndex:(NSInteger)rowIndex;


来实现，前者是往表格布局尾部添加一行，而后者则是在指定的位置插入一行。这里需要说明的参数是rowHeight,colWidth的意义，我们知道只要我们插入一行时我们总是需要指出插入的这一行的行高是多少，同时要指出插入的这行的列单元格的宽度是如何指定的(每列的宽度固定，还是有单元格自己指定等等)




 rowHeight
为-1时表示由最高的单元格视图决定本行高度，每个单元格视图需要自己设置高度；为0表示均分高度，单元格视图不需要设置高度；大于0表示固定高度，单元格视图不需要设置高度.




 colWidth 
为-2时表示每个单元格视图需要自己指定宽度，整体行宽和表格布局一致；为-1表示每个单元格视图需要自己指定宽度，整个行宽包裹所有子视图；为0表示均分宽度，这时候单元格视图不必设置宽度；大于0表示单元格视图固定宽度，这时候单元格视图可以不必设置宽度。

同时我们也提供了对行操作的其他方法：


//删除指定的行

-(void)removeRowAt:(NSInteger)rowIndex;
//交行两个行的内容
-(void)exchangeRowAt:(NSInteger)rowIndex1 withRow:(NSInteger)rowIndex2;

//得到行视图，从返回我们可以看出，我们调用插入行操作时，系统内部会自动建立一个MyLinearLayout线性布局视图作为行视图，如果是垂直表格则默认是水平线性布局，而如果是水平表格则默认是垂直线性布局，因此我们可以通过这个方法来设置行的其他的各种属性，比如说行间距(xxxMargin来实现)。
-(MyLinearLayout*)viewAtRowIndex:(NSInteger)rowIndex;

//返回当前有多少行
-(NSUInteger)countOfRow;




当我们插入了一行后，我们就需要为这一行添加单元格视图(列视图)，每一行都可以无限制的添加单元格视图，也就是说一行可以有很多的列，每一行的列数都可以不一样，我们可以通过如下的方法来添加或者删除列：



-(void)addCol:(UIView*)colView atRow:(NSInteger)rowIndex;
-(void)insertCol:(UIView*)colView atIndexPath:(NSIndexPath*)indexPath;
-(void)removeColAt:(NSIndexPath*)indexPath;
-(void)exchangeColAt:(NSIndexPath*)indexPath1 withCol:(NSIndexPath*)indexPath2;


注意上面的添加列时，需要指定在哪一行添加列，在添加列之前必须要把行添加进去，也就是说行索引rowIndex不能越界，为了简单的描述行索引和列索引的关系我们使用了NSIndexPath这个对象来描述，我们对NSIndexPath进行了扩展，以便用于方便的指定行和列的索引：



@interface NSIndexPath(MyTableLayoutEx)



+(instancetype)indexPathForCol:(NSInteger)col inRow:(NSInteger)row;




@property(nonatomic,assign,readonly)
NSInteger col;




@end






同时我们也方便的提供了单元格列视图的获取和数量的获取的方法


//返回列视图

-(UIView*)viewAtIndexPath:(NSIndexPath*)indexPath;

//返回指定行的列的数量。

-(NSUInteger)countOfColInRow:(NSInteger)rowIndex;




上面就是我们对表格布局的所有函数的介绍，使用起来也很简单，步骤就是先添加行，然后在每行中依次一个个的添加列视图，也就是单元格视图。


我们将分别建立两个风格的表格进行例子的说明。




二、垂直表格


   所谓垂直表格就是行是从上往下，一行一行布局起来的，所有行内的单元格视图都是从左往右一列一列布局起来的，建立垂直表格是默认的表格。先看界面布局效果。












我们分别建立了6行不同尺寸的表格，上可以看出每一行的列数不一样，每一行的高度不一样，每一行的总体列宽不一样，每一行的每一列的宽度都不一样，而这些我们都是通过在插入行时通过设置不同的rowHeight,colWidth来达到效果的。具体代码参考如下：


-(void)loadView
{
    [super loadView];
    
    /*
     有的时候我们希望让一个布局视图放入到非布局视图中去，但又希望布局视图的宽高和非布局父视图宽高一致。
     这时候我们可以设置height,width来指定自身的高宽，我们也可以通过leftMargin = 0,rightMargin = 0来让其跟父视图保持一样的宽度，但如果是这样的话还需要设置wrapContentWidth = NO. 设置高度同理。
     */
    MyTableLayout *tbll = [MyTableLayout new];
    tbll.wrapContentHeight = NO;  //对于线性布局来说必须要设置为NO才能高度和非布局的父视图一样高
    tbll.leftMargin = tbll.rightMargin = 0;  //宽度和非布局父视图一样宽
    tbll.topMargin = tbll.bottomMargin = 0;  //高度和非布局父视图一样高
    [self.view addSubview:tbll];

    
    //第一行固定高度固定宽度
    [tbll addRow:30 colWidth:30];
    [tbll viewAtRowIndex:0].backgroundColor = [UIColor colorWithWhite:0.1 alpha:1];
    
    UIView *colView = [UIView new];
    colView.leftMargin = 10; //可以使用leftMargin,topMargin,rightMargin,bottomMargin来调整间隔
    colView.topMargin = 5;
    colView.bottomMargin = 5;
    colView.rightMargin = 40;
    
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:0];
    
    colView = [UIView new];
    colView.leftMargin = 20;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:0];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:0];
    
    //第二行固定高度，均分宽度
    [tbll addRow:40 colWidth:0];
    [tbll viewAtRowIndex:1].backgroundColor = [UIColor colorWithWhite:0.2 alpha:1];

    
    colView = [UIView new];
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor yellowColor];
    [tbll addCol:colView atRow:1];
    
    //第三行固定高度，子视图自己决定宽度。
    [tbll addRow:30 colWidth:-1];
    [tbll viewAtRowIndex:2].backgroundColor = [UIColor colorWithWhite:0.3 alpha:1];
    colView = [UIView new];
    colView.width = 100;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:2];

    colView = [UIView new];
    colView.width = 200;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:2];
    
    //第四行固定高度，子视图自己决定宽度。
    [tbll addRow:30 colWidth:-2];
    [tbll viewAtRowIndex:3].backgroundColor = [UIColor colorWithWhite:0.4 alpha:1];
    colView = [UIView new];
    colView.width = 80;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:3];
    
    colView = [UIView new];
    colView.width = 200;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:3];
    
    //第五行高度均分.这里设置为0表示剩余高度再均分。宽度均分,
    [tbll addRow:0 colWidth:0];
    MyLinearLayout *row4 = [tbll viewAtRowIndex:4];
    //可以设置行的属性.比如padding, 线条颜色，
    row4.padding = UIEdgeInsetsMake(3, 3, 3, 3);
    row4.topBorderLine = [[MyBorderLineDraw alloc] initWithColor:[UIColor blackColor]];
    row4.topBorderLine.thick = 2;
    row4.backgroundColor = [UIColor colorWithWhite:0.5 alpha:1];

    colView = [UIView new];
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:4];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:4];
    
    //第六行高度由子视图决定，均分宽度
    [tbll addRow:-1 colWidth:0];
    [tbll viewAtRowIndex:5].backgroundColor = [UIColor colorWithWhite:0.6 alpha:1];
    
    colView = [UIView new];
    colView.height = 80;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:5];
    
    colView = [UIView new];
    colView.height = 120;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:5];
    
    colView = [UIView new];
    colView.height = 70;
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:5];





    
    
}

上面的代码中我们在插入行时分别为rowHeight,colWidth设置了6种不同的参数的组合，我们看到其中有些行中需要指定每个单元格的列宽和行高，而有的则不需要。是否需要单元格指定行高和列宽则是有rowHeight,colWidth的不同的参数值决定的。 有时候我们的表格可能需要指定行间距和列间距，而这些都可以通过行视图的xxMargin, 和列视图的xxxMargin的设置来进行个性化的定制，这里需要强调一下rowHeight,colWidth都等于0的情况，他们的意义是表示行和列会均分高度和宽度。


  举例来说，假设我们建立了一个宽高为100*100的表格布局，而我们第一行的rowHeight,colWidth设置为0时，则当插入第一行时则这一行的高度就是100，而这一行插入第一列时则这一列的宽度就是100，而如果再插入一列时则两列的宽度都会调整为50，同样当我们再次插入一行时则两行的高度都将会调整为50. （这个像不像HTML中的表格的行列的宽高指定的风格）








三、水平表格（瀑布流）


   所谓水平表格就是行是从左往右，一行一行布局起来的，所有行内的单元格视图都是从上往下一列一列布局起来的，建立水平表格需要将
orientation = LVORIENTATION_HORZ， 水平表格也就是一个瀑布流风格的表格，我们可以通过将表格放入到UIScrollView中进行从上到下的滚动以便展示所有内容。先看界面布局效果：









这个例子我们也跟上面一样，建立了6行(注意水平表格里面行的概念就是指列，而列则是指行)，同时我们把表格布局加入到了一个UIScrollView下，以便能有滚动的效果。我们为了延长表格的高度，我们对第三行的第三个单元格视图特意设置了一个很高的高度。代码如下：


-(void)loadView
{
    [super loadView];
    
    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds];
    scrollView.autoresizingMask =  UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
    [self.view addSubview:scrollView];
    
    
    
    /*
     有的时候我们希望让一个布局视图放入到非布局视图中去，但又希望布局视图的宽高和非布局父视图宽高一致。
     这时候我们可以设置height,width来指定自身的高宽，我们也可以通过leftMargin = 0,rightMargin = 0来让其跟父视图保持一样的宽度，但如果是这样的话还需要设置wrapContentWidth = NO. 设置高度同理。
     */
    MyTableLayout *tbll = [MyTableLayout new];
    tbll.orientation = LVORIENTATION_HORZ;
    tbll.wrapContentWidth = NO;  //对于线性布局来说必须要设置为NO才能宽度和非布局的父视图一样宽
    tbll.wrapContentHeight = YES; //这里设定高度由子视图决定。
    tbll.leftMargin = tbll.rightMargin = 0;  //宽度和非布局父视图一样宽
    [scrollView addSubview:tbll];
    
    
    //需要注意的是因为这里的表格设置为水平表格，所以下面所的行高，其实是行宽，而列宽，其实是列高
    
    
    //第一行固定高度固定宽度
    [tbll addRow:30 colWidth:30];
    [tbll viewAtRowIndex:0].backgroundColor = [UIColor colorWithWhite:0.1 alpha:1];
    
    UIView *colView = [UIView new];
    colView.leftMargin = 5; //可以使用leftMargin,topMargin,rightMargin,bottomMargin来调整间隔
    colView.topMargin = 5;
    colView.bottomMargin = 5;
    colView.rightMargin = 5;
    
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:0];
    
    colView = [UIView new];
    colView.topMargin = 20;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:0];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:0];
    
    //第二行固定高度，均分宽度
    [tbll addRow:40 colWidth:0];
    [tbll viewAtRowIndex:1].backgroundColor = [UIColor colorWithWhite:0.2 alpha:1];
    
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor yellowColor];
    [tbll addCol:colView atRow:1];
    
    //第三行固定高度，子视图自己决定宽度。
    [tbll addRow:30 colWidth:-1];
    [tbll viewAtRowIndex:2].backgroundColor = [UIColor colorWithWhite:0.3 alpha:1];
    colView = [UIView new];
    colView.height = 100;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:2];
    
    colView = [UIView new];
    colView.height = 200;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:2];
    
    colView = [UIView new];
    colView.height = 1000;
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:2];
    
    //第四行固定高度，子视图自己决定宽度。
    [tbll addRow:30 colWidth:-2];
    [tbll viewAtRowIndex:3].backgroundColor = [UIColor colorWithWhite:0.4 alpha:1];
    colView = [UIView new];
    colView.height = 80;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:3];
    
    colView = [UIView new];
    colView.height = 200;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:3];
    
    //第五行高度均分.这里设置为0表示剩余高度再均分。宽度均分,
    [tbll addRow:0 colWidth:0];
    MyLinearLayout *row4 = [tbll viewAtRowIndex:4];
    //可以设置行的属性.比如padding, 线条颜色，
    row4.padding = UIEdgeInsetsMake(3, 3, 3, 3);
    row4.leftBorderLine = [[MyBorderLineDraw alloc] initWithColor:[UIColor blackColor]];
    row4.leftBorderLine.thick = 2;
    row4.backgroundColor = [UIColor colorWithWhite:0.5 alpha:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:4];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:4];
    
    //第六行高度由子视图决定，均分宽度
    [tbll addRow:-1 colWidth:0];
    [tbll viewAtRowIndex:5].backgroundColor = [UIColor colorWithWhite:0.6 alpha:1];
    
    colView = [UIView new];
    colView.width = 80;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:5];
    
    colView = [UIView new];
    colView.width = 120;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:5];
    
    colView = [UIView new];
    colView.width = 70;
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:5];
    
    
    
    
    
    
}

这段代码的内容和上面的垂直表格相似，只是把一些原来的宽度值改为了高度值而已。


四、总结
    好了，表格布局的内容就介绍到这里了，表格布局的内部实现其实就是一个线性布局套线性布局的封装，但是他简化了我们插入视图的方法，从而很容易的布局出各种风格的布局，我们可以从上往下依次布局，也可以从左往右依次布局。如果您觉得这篇文章能够帮助到您，或者能成为您界面布局的解决方案，那么请到我的github：


https://github.com/youngsoft/MyLinearLayout 中下载这套界面解决框架库，如果您觉得好用就记得给我点赞哦，如果有什么不明确的可以加我QQ:156355113联系我。



































版权声明：本文为博主原创文章，未经博主允许不得转载。

(素材源码) 猫猫学iOS 之UIDynamic重力、弹性碰撞吸附等现象牛逼Demo
猫猫分享，必须精品
原创文章，欢迎转载。转载请注明：翟乃玉的博客 
地址：http://blog.csdn.net/u013357243
一：效果
 
 
 
 

二：代码
#import "ViewController.h"
#import "DemoViewController.h"

@interface ViewController ()
{
    // 功能名称的数组
    NSArray *_functions;
}

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    _functions = @[@"吸附行为", @"推动行为", @"刚性附加行为", @"弹性附加行为", @"碰撞检测"];
}

#pragma mark - 数据源方法
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return _functions.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 使用Storyboard建立的UITabeViewController，其中的Cell是已经注册过的
    static NSString *ID = @"Cell";
    // 永远都会找到一个单元格，如果缓冲池中没有，会自动新建
    /**
     dequeueReusableCellWithIdentifier 直接查询可重用单元格
     dequeueReusableCellWithIdentifier:forIndexPath: 查询“注册的”可重用单元格，此方法中indexPath本身没有用处

        * 强制判断是否注册了单元格

     如果已经注册过单元格，以上两个方法等效。

     如果在StoryBoard中指定了单元格的可重用标示符，单元格的优化将有系统接管，不再需要判断cell == nil
     */
//    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID forIndexPath:indexPath];

//    if (cell == nil) {
//        NSLog(@"come here");
//        
//        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];
//    }

    cell.textLabel.text = _functions[indexPath.row];

    return cell;
}

#pragma mark - 代理方法
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    DemoViewController *controller = [[DemoViewController alloc] init];

    // 指定标题
    controller.title = _functions[indexPath.row];
    controller.function = indexPath.row;

    [self.navigationController pushViewController:controller animated:YES];
}

#import "DemoViewController.h"
#import "DemoView.h"
#import "SnapView.h"
#import "PushView.h"
#import "AttachmentView.h"
#import "SpringView.h"
#import "CollisionView.h"

@interface DemoViewController ()

@end

@implementation DemoViewController

//- (void)loadView
//{
//    self.view = [[DemoView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame];
//}

- (void)viewDidLoad
{
    [super viewDidLoad];

    NSLog(@"功能代号： %d", self.function);
    // 在此根据实际的功能代号加载实际的视图

    DemoView *demoView = nil;
    switch (self.function) {
        case kDemoFunctionSnap:
            demoView = [[SnapView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionPush:
            demoView = [[PushView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionAttachment:
            demoView = [[AttachmentView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionSpring:
            demoView = [[SpringView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionCollision:
            demoView = [[CollisionView alloc] initWithFrame:self.view.bounds];
            break;
        default:
            break;
    }

    [self.view addSubview:demoView];
}


@end

主要框框就这样啦，贴出了的代码仅仅部分
三：素材代码下载地址
代码上传中。。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

无需Root也能Hook？——Depoxsed框架演示


之前我们介绍过rovo89在Githu上的Xposed框架，我们也介绍了如何使用Xposed框架进行
登录劫持，和广告注入。
但是，之后很多朋友都在问我，这个Xposed框架使用起来很确实很好用。可是就是有一
个巨大的缺点，就是需要Root权限。很多设备都没有Root权限，有没有一个不需要Root
权限的Hook框架。
答案是，确定的。就是目前的Alibab的开源框架，Dexposed框架。
github地址 ： https://github.com/alibaba/dexposed

Dexposed
它的官方介绍如下：

它基于ROOT社区著名开源项目Xposed改造剥离了ROOT部分，演化为服务于所在应用自

身的AOP框架，并在Apache 2.0协议下开源。

Xposed是XDA社区用户rovo89开发并管理的一个项目，它通过修改Android 
  Dalvik运行时的Zygote进程，使用Xposed 
  Bridge将第三方代码注入到Android应用的方法调用中，实现非侵入式的在运行期动态

修改系统和应用行为的能力。
Dexposed的原理也是很简单，如它介绍中所说的。它是Xposed框架剥离掉了Root部分的
功能。

不熟悉Xposed原理的，可以看这里

http://blog.csdn.net/yzzst/article/details/47659987
没有Root权限，那么Xposed框架式无法替换app_process的，当然也就无法进行整个系统
级应用程序的注入了。当然，对自我程序本身还是没有问题的。
目前Dexposed的主要应用场景有以下几种：

AOP编程 
插桩 (如测试、性能监控等) 
在线热补丁 
SDK hooking以提供更好的开发体验


AOP为Aspect Oriented 
  Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程

序功能的统一维护的一种技术。
看到这里，很多小伙伴估计都会产生疑问，我靠，不能进行登录劫持了，不能注入广告
了。我用你来干什么。/(ㄒoㄒ)/~


AOP编程，在线热补丁
没错，Dexposed框架主要的功能，还是提供作为AOP框架使用。这么一来的话，我们之前
也介绍过Android的插件实现方式。这里我们所用Dexposed框架来实现的话，插件模型将
会更加简单。
首先先介绍一下，Dexposed框架也提供了一个与Xposed框架类似的方法。

/**
  * 该系统是否支持hook
  */
public static synchronized boolean canDexposed(Context context)

/**
  * 寻找并hook一个指定的方法
  * @param clazz 类的class
  * @param methodName hook的方法名称
  * @param parameterTypesAndCallback 参数和返回callback
  * @return 
  */
public static Unhook findAndHookMethod(Class<?> clazz, String methodName, Object... parameterTypesAndCallback)

在线热补丁实例
如何进行在线的热补丁呢？我们这里以alibaba的demo为例。
如在主线版本中，我们有一个showDialog方法。已经发布出去了。但是，突然发现有一
点bug或者突发性需求，我们不能够理解的发版更新。

这里就能够通过之前我们所说的DexClassLoader的方式，载入线上的插件Path.apk

。 
 2. 通过Dexposed框架，动态的Hook并替换主线版本中的showDialog函数方法。
具体的逻辑如下图所示：

看到上面的效果说明图之后，相信大家对Dexposed的在线热补丁已经有一定的了解了。
这里我们也不用做过多的赘述。
当然，你可能想到很多使用热补丁的应用方向，比如：

Bug补丁修复
插件功能 
等等

Dexposed框架原理很简单，功能也算不上强大。但是，确实特别实用。我也是推荐各大
Android开发者，特别是创业公司使用。是墙裂推荐！！

下面是主工程中与补丁工程中的逻辑实现。这里，童鞋们可以对比着效果图看一下。

如果大家对动态的使用DexClassLoader载入一个apk代码还存在疑问。 可以clone一下

dexposed的源码学习学习。

当然，这里还是推荐大家去我的博客看看，Android的插件原理。 
  地址：http://blog.csdn.net/yzzst/article/details/45582315

主工程中，MainActivity showDialog方法的定义
public class MainActivity extends Activity {

    //..........一些忽略掉的代码

    private void showDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle("Dexposed sample")
                .setMessage("Please clone patchsample project to generate apk, and copy it to \"/Android/data/com.taobao.dexposed/cache/patch.apk\"")
                .setPositiveButton("ok", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int whichButton) {
                    }
                }).create().show();
    }
}
在线热补丁，Path.apk中的代码
/**
  * 插件的补丁类
  */
public class DialogPatch implements IPatch {

    @Override
    public void handlePatch(final PatchParam arg0) throws Throwable {       
        // 获取主程序的ClassLoader
        Class<?> cls = null;
        try {
            // 获取主程序的MainActivity类
            cls= arg0.context.getClassLoader().loadClass("com.taobao.dexposed.MainActivity");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return;
        }

        // hook并替换MainActivity中的showDialog方法
        DexposedBridge.findAndHookMethod(cls, "showDialog", new XC_MethodReplacement() {
            @Override
            protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {
                // 弹出一个插件中的Dialog
                Activity mainActivity = (Activity) param.thisObject;
                AlertDialog.Builder builder = new AlertDialog.Builder(mainActivity);
                builder.setTitle("Dexposed sample")
                        .setMessage("The dialog is shown from patch apk!")
                        .setPositiveButton("ok", new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int whichButton) {
                            }
                        }).create().show();
                return null;                 
            }
        });
    }

}
/*  
* @author zhoushengtao(周圣韬)  
* @since 2015年8月26日 凌晨0:08:22  
* @weixin stchou_zst  
* @blog http://blog.csdn.net/yzzst 
* @交流学习QQ群：341989536  
* @私人QQ：445914891  
/ 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：转载请标注：http://blog.csdn.net/yzzst 。 本文为博主原创文章，未经博主允许不得转载。

[置顶]
        AS1.3 及其以上预览版新插件－实验版（NDK）
序
在新版的AS预览版中我发现对于NDK的支持有所变化。 
在新的插件版本中加强了对NDK的支持以及性能的优化。 
于是查询了一下文档，特此写了该文章，为尝鲜的朋友准备，喜欢尝鲜的朋友可以试试，个人感觉味道不错。 
在之前版本的时候我写过如何在AS中编译NDK： 
 [Android] 环境配置之Android Studio开发NDK
本篇文章是一篇半翻译文章，来源于AS的说明文档，在文章底部会附上原文链接。 
本篇文章中的东西来源于预览版，本文章中的方法已测试有效；但不建议用于生产开发。
介绍
这是一个新的试验性插件，该组建基于新的Gradle组建模型；在配置上能显著减少时间。在新的插件中包括了使用JNI开发NDK的一键式操作。在本指南中提供了详细的使用方式，同时强调了新的插件与原始插件之间的区别。
警告：该插件是试验性插件。有关该插件的Gradle API也并不是最终版本。这意味着他只是特定版本的API，也可能只能在特定版本中使用。
此外。DSL可能发生大量改变，在最终版本中有可能采用新的API代替。
该实验插件是改善了NDK集成与性能相关的早期预览版本（这两个问题来自于用户反馈）。
需求

Gradle 2.5 （仅仅）
Android NDK R10e 版本（如果你需要使用NDK）
SDK 构建工具最低版本 19.0.0 ，一些功能可能需要更新的版本
AS 1.3 预览版及其更高版本

迁移
从之前版本迁移到最新预览版。在下面显示了新的预览版的项目结构，更改的地方使用红色表示。

./gradle/wrapper/gradle-wrapper.properties
新的插件仅仅只支持 gradle-2.5.

＃Wed Apr 10 15:27:10 PDT 2013 
  distributionBase=GRADLE_USER_HOME 
  distributionPath=wrapper/dists 
  zipStoreBase=GRADLE_USER_HOME 
  zipStorePath=wrapper/dists 
  distributionUrl=https://services.gradle.org/distributions/gradle-2.5-all.zip

./build.gradle
其中Classpath 应该配置为 com.android.tools.build:gradle-experimental 以前是  com.android.tools.build:gradle 
当前可使用版本为： 0.2.0.
// 提示: 顶层配置，你也可以在你的子项目或者子Model中添加对应配置

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle-experimental:0.2.0'

        // 提示: 别把项目所需依赖写在这里，他们属于Model中的 build.gradle 文件
    }
}

allprojects {
    repositories {
        jcenter()
    }
}
./app/build.gradle
在该插件中有着许多有关DSL变化。其中很多变化似乎有些奇葩，并不必要；因为在我看来插件变化应该尽量简单以减少插件迁移的代价。
DSL 变更:

Apply 默认插件名现在是 com.android.model.application 在之前的版本中是：com.android.application.  如果我们的Model是另外的库或者aar 那么现在应该为:  com.android.model.library
根配置应该加上 model { }  模块
大多属性应该加上 '='  操作符
如果是为集合添加对应的元素应该使用 '+=' 操作符

使得 DSL 更局限性的变更:

buildTypes, productFlavors 和 signingConfigs 配置必须写在 android { } 模块以外
能在 android { } 模块中嵌套使用的配置需要加上with 关键字.
属性也将只能使用所支持的直接属性，而没法使用其他类型而后进行转换（如果该属性是int类型，将只能输入int值，而不能是string字符然后强制转换）。例如: 
文件类型属性将直接接受文件类型，而不接受String类型。
不能直接使用 minSdkVersion 接受一个 int 或者 string 类型，而需要写为：minSdkVersion.apiLevel = 15.
创建一个buildType 或者 productFlavor 等标记需要调用 create方法.  修改一个现有的，如buildType中的release或者debug标记可以直接使用名称就可以了.
现在修改DSL 的变量或者任务是非常非常局限的. 


dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.2.0'
}
NDK 相关
在该实验插件中使用NDK创建Android本地程序。  你需要： 
使用下载工具下载 NDK 包并配置好环境. 
在项目local.properties 文件中设置 ndk.dir 变量并指定你的 NDK 路径，也可以在环境变量中设置 ANDROID_NDK_HOME 为你计算机上的 NDK 路径. 
在你的 model 中的 build.gradle 文件中添加 android.ndk 板块.  
已知局限

不支持NDK-only模块；仅仅支持混合的app或者lib库的项目编译。
编译项目时并不会重复编译已编译完成的JNI代码（AAR库中的所有so文件仅仅只是简单打包到APK中，不会进行重复编译）。
不支持创建可依赖静态库。
不支持使用诸如cpu_features 的NDK库。
不支持集成外部构建系统。

Model 中的 build.gradle 中的 NDK 配置诸如这样: 

提示：项目中的 moduleName 属性是必须的，它定义了 NDK 所生成的文件名。
默认情况下，JNI 文件应该放到项目的目录为：src/main/jni ，在其中你可以放C/C++代码；当然你也可以重新定义该默认目录。
model {
    android {
        compileSdkVersion = 22
        buildToolsVersion = "22.0.1"
    }
    android.ndk {
        moduleName = "native"
    }
    android.sources {
        main {
            jni {
                source {
                    srcDir 'src'
                }
            }
        }
    }
}
其他的编译属性你可以设置到android.ndk { } 模块中，诸如：
model {
    android {
        compileSdkVersion = 22
        buildToolsVersion = "22.0.1"
    }
    android.ndk {
        // 所有可以在 android.ndk 中定义的配置.
        moduleName = "native"
        toolchain = "clang"
        toolchainVersion = "3.5"

        // 提示：CFlags 是一个C的资源, 其命名与常规的属性并不一样.  这是一个技术限制，但在以后会解决。

        CFlags += "-DCUSTOM_DEFINE"
        cppFlags += "-DCUSTOM_DEFINE"
        ldFlags += "-L/custom/lib/path"
        ldLibs += "log"
        stl = "stlport_static"
    }
    android.buildTypes {
        release {
            ndk.with {
                debuggable = true
            }
        }
    }
    android.productFlavors {
        create("arm") {
            ndk.with {
                // 你可以在 productFlavors 和 buildTypes 节点中配置 NDK 相关的属性
                abiFilters += "armeabi-v7a"
            }
        }
        create("fat") {
            // 如果未指定 ndk.abiFilters 属性，那么将会生成所有的CPU版本ABI.
        }
    }

    // 你可以修改所有的 NDK 属性
    components.android {
        binaries.afterEach { binary ->
            binary.mergedNdkConfig.cppFlags.add(
                    "-DVARIANT=\"" + binary.name + "\"")
        }
    }
}

原文链接
需要梯子： 
http://tools.android.com/tech-docs/new-build-system/gradle-experimental
案例
这里有一些Google官方的案例，地址： 
https://github.com/googlesamples/android-ndk. 
我的博客中的案例会放到： 
https://github.com/qiujuer/BeFoot
======================================================== 
作者：qiujuer 
博客：blog.csdn.net/qiujuer 
网站：www.qiujuer.net 
开源库：github.com/qiujuer/Genius-Android 
开源库：github.com/qiujuer/Blink 
转载请注明出处：http://blog.csdn.net/qiujuer/article/details/47961763 
—— 学之开源，用于开源；初学者的心态，与君共勉！
========================================================

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Activity组件启动过程及ActivityManagerService(AMS)（一）
    在前面《Android启动过程》中提到了System进程启动ActivityManagerService服务，AMS是由Android提供的用于管理Activity（不仅仅指Activity，还包括其他三个组件）运行状态的系统进程，则是平时编写APK应用程序时使用得最频繁的一个系统服务。
    AMS是通过ActivityStack（和其它数据结构）来记录、管理系统中的Activity（和其它组件）状态，并提供查询功能的一个系统服务，负责启动和调度应用程序组件。



一、AMS功能概述
1、回到《Android启动过程》中提到的使用SystemServer中ServerThread来启动AMS服务：


/** @path: \frameworks\base\services\java\com\android\server\SystemServer.java */ 
class ServerThread extends Thread {
    @Override
    public void run() {
        ......   
        // Critical services...
        boolean onlyCore = false;
        try {
            // 创建Activity Manager实例
            context = ActivityManagerService.main(factoryTest);
             .....
            // 将AMS注册到ServiceManager中（前面分析提到这一步是在创建PMS实例之后才进行注册）
            ActivityManagerService.setSystemProcess();
        } catch (RuntimeException e) {
        }
    }
}


2、如前所述，其是通过调用ActivityManagerService#main函数来创建AMS实例及AMS线程：




/** @path \frameworks\base\services\java\com\android\server\am\ActivityManagerService.java **/ 
public final class ActivityManagerService extends ActivityManagerNative
    implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
  
    static ActivityManagerService mSelf;  
 
    public static final Context main(int factoryTest) {
        /** 创建一个AThread线程 ,这里用来创建AMS实例*/
        AThread thr = new AThread();
        thr.start();   // 启动AMS线程
 
        synchronized (thr) {
        /** 这里运来判断AMS是否启动成功，失败则一直等待 **/
            while (thr.mService == null) {
                try {
                  // 注意这里会wait，直至AThread中AMS创建完成，调用notiyAll方法才唤醒
                    thr.wait();
                } catch (InterruptedException e) {
                }
            }
        }
 
        // 将AThread中创建的AMS实例赋值给m,再赋值给AMS静态变量mSelf
        ActivityManagerService m = thr.mService;
        mSelf = m;
      
        /** AMS两个最重要核心——
         *  - ActivityStack：Activity的记录者与管理者，同时也为AMS管理系统运行情况提供了基础
         *  - ActivityTask**/
        ActivityThread at = ActivityThread.systemMain();
        mSystemThread = at;
        Context context = at.getSystemContext();
        context.setTheme(android.R.style.Theme_Holo);
        m.mContext = context;
        m.mFactoryTest = factoryTest;
        /** 创建一个ActivityStack对象 **/
        m.mMainStack = new ActivityStack(m, context, true); 
      
        m.mBatteryStatsService.publish(context);
        m.mUsageStatsService.publish(context);
      
        synchronized (thr) {
            thr.mReady = true;
            // 唤醒AMS线程
            thr.notifyAll();
        }
 
        /*** 开始运行  ***/
        m.startRunning(null, null, null, null);
      
        return context;
    }
  
    static class AThread extends Thread {
        ActivityManagerService mService;
        boolean mReady = false;
 
        public AThread() {
            super("ActivityManager");
        }
 
        public void run() {
        /** 创建消息Loopr循环 **/
            Looper.prepare();
 
            android.os.Process.setThreadPriority(
                    android.os.Process.THREAD_PRIORITY_FOREGROUND);
            android.os.Process.setCanSelfBackground(false);
 
            /** 在这里创建AMS实例，用以作为系统中的Activity管理服务 **/
            ActivityManagerService m = new ActivityManagerService();
 
            synchronized (this) {
                mService = m;
                // 这里唤醒前面等待的线程
                notifyAll();
            }
 
            synchronized (this) {
                while (!mReady) {
                    try {
                       // 创建完成后wait等待，直至System线程将其唤醒
                        wait();
                    } catch (InterruptedException e) {
                    }
                }
            }
            Looper.loop();
        }
    }
}

3、通过ActivityManagerService#setSystemProcess将AMS注册到ServiceManager中：


/** @path \frameworks\base\services\java\com\android\server\am\ActivityManagerService.java **/
public static void setSystemProcess() {
    try {
        // mSelf是静态变量，即前面启动的AMS实例
        ActivityManagerService m = mSelf;
       
        /** 这里通过ServiceManager来注册各种服务，其中AMS服务的主体是第一个即"activity" **/
        ServiceManager.addService("activity", m, true);
        ServiceManager.addService("meminfo", new MemBinder(m));
        ServiceManager.addService("gfxinfo", new GraphicsBinder(m));
        ServiceManager.addService("dbinfo", new DbBinder(m));
        if (MONITOR_CPU_USAGE) {
            ServiceManager.addService("cpuinfo", new CpuBinder(m));
        }
        ServiceManager.addService("permission", new PermissionController(m));
 
        ApplicationInfo info =
            mSelf.mContext.getPackageManager().getApplicationInfo(
                        "android", STOCK_PM_FLAGS);
        mSystemThread.installSystemApplicationInfo(info);
  
        synchronized (mSelf) {
            ProcessRecord app = mSelf.newProcessRecordLocked(
                    mSystemThread.getApplicationThread(), info,
                    info.processName, false);
            app.persistent = true;
            app.pid = MY_PID;
            app.maxAdj = ProcessList.SYSTEM_ADJ;
            mSelf.mProcessNames.put(app.processName, app.uid, app);
            synchronized (mSelf.mPidsSelfLocked) {
                mSelf.mPidsSelfLocked.put(app.pid, app);
            }
            mSelf.updateLruProcessLocked(app, true);
        }
    } catch (PackageManager.NameNotFoundException e) {
    }
}






    下面来看AMS是如何对Activity的启动产生影响的。




二、根Activity组件启动过程：


1、Activity分类：
    Activity组件分为两种类型：一种是根Activity，一种是子Activity。
1）根Activity以快捷方式图标的形式显示在应用程序启动器上，它的启动过程代表了一个Android应用程序的启动过程。
     根Activity在manifest.xml文件中的声明：




<activity
    android:name="com.loadingUI.LoadingActivity"
    android:label="@string/Loadinging_activity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
    </intent-filter>
</activity>   Launcher组件在启动时，会向PackageManagerService查询系统中所有“action”等于"action.MAIN"以及"category"等于"category.LAUNCHER"的Activity组件，为每一个Activity组件创建一个快捷图标。



    (这也是为什么要将Launcher Activity的intent filter设为上述模式的原因)。
    当想启动一个应用时，通过点击应用程序启动器Launcher界面上的图标来启动


2）子Activity由根Activity或者其他子Activity来启动，它们可能与启动它们的Activity运行在同一进程，也可能运行在不同的进程中。
     启动方式分有显式启动与隐式启动两种。按照软件工程的角度，隐式启动可以减少Android应用程序组件之间的依赖耦合度。
    
2、根Activity（记为MainActivity）的总启动过程总结如下：
1）Launch组件向AMS发送启动根Activity组件的请求；
2）AMS响应Launch请求，将根Activity组件的信息保存下来，并向Launch发送一个进入中止状态的进程间通信请求。
3）Launch进入中止状态后，向AMS发送消息；
4）AMS接收到消息后，会检查启动根Activity的应用程序进程是否已经存在；若不存在，则启动该应用程序进程。
5）根Activity应用程序进程启动完成后，该进程会向AMS发送一个启动完成的进程间通信请求。
6）AMS将其保存的根Activity组件的信息发送给创建的根Activity应用程序进程，使得其继续启动根Activity组件。




3、根Activity详细启动过程：
    先来分析启动的前几步如下图：



    启动根Activity一般是通过点击快捷图标，Launch组件启动Activity。先看其点击响应函数：

1）Launcher类：



public final class Launcher extends Activity
        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks, View.OnTouchListener
1.2）点击响应函数Launcher#onClick：






/** \packages\apps\Launcher2\src\com\android\launcher2*/
public void onClick(View v) {
    ...
    Object tag = v.getTag();
    if (tag instanceof ShortcutInfo) {
        // 这里组装启动intent的信息
        final Intent intent = ((ShortcutInfo) tag).intent;
        int[] pos = new int[2];
        v.getLocationOnScreen(pos);
        intent.setSourceBounds(new Rect(pos[0], pos[1],
                pos[0] + v.getWidth(), pos[1] + v.getHeight()));
 
        /** 看到通过这个函数用来启动一个应用的根Activity*/
        boolean success = startActivitySafely(v, intent, tag);
 
        if (success && v instanceof BubbleTextView) {
            mWaitingForResume = (BubbleTextView) v;
            mWaitingForResume.setStayPressed(true);
        }
    } 
    .......
}    可以看到Launcher通过函数startActivitySafely来启动应用程序的根Activity;





1.2）Launcher#startActivitySafely方法：




/** \packages\apps\Launcher2\src\com\android\launcher2*/
boolean startActivitySafely(View v, Intent intent, Object tag) {
    boolean success = false;
    try {
    /** 函数很简单，只是对startActivity进行了安全封装*/
        success = startActivity(v, intent, tag);
    } catch (ActivityNotFoundException e) {
    ...
    }
    return success;
}    可以看到startActivitySafely仅仅是对startActivity方法做了一个try-catch安全封装，用以安全启动，最终目的仍是调用startActivity来启动根Activity。






1.3）Launcher#startActivity函数：



boolean startActivity(View v, Intent intent, Object tag) {
    /*** 设置启动标志***/
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
    try {
        // Only launch using the new animation if the shortcut has not opted out (this is a
        // private contract between launcher and may be ignored in the future).
        boolean useLaunchAnimation = (v != null) &&
                !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);
        UserHandle user = (UserHandle) intent.getParcelableExtra(ApplicationInfo.EXTRA_PROFILE);
        LauncherApps launcherApps = (LauncherApps)
                this.getSystemService(Context.LAUNCHER_APPS_SERVICE);
        // 当添加新的启动动画时，使用此启动方式
        if (useLaunchAnimation) {
            ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0,
                    v.getMeasuredWidth(), v.getMeasuredHeight());
            if (user == null || user.equals(android.os.Process.myUserHandle())) {
              /** 注意这里将会调用父类的startActivity*/
                startActivity(intent, opts.toBundle());
            } else {
                launcherApps.startMainActivity(intent.getComponent(), user,
                        intent.getSourceBounds(), opts.toBundle());
            }
        } else { // 默认的启动方式
            if (user == null || user.equals(android.os.Process.myUserHandle())) {
             
              /** 调用父类Activity的startActivity来启动 **/
                startActivity(intent);
            } else {
                launcherApps.startMainActivity(intent.getComponent(), user,
                        intent.getSourceBounds(), null);
            }
        }
        return true;
    } catch (SecurityException e) {
    ...
    }
    return false;
}


    上面代码重要完成两个工作：
1> 设置Activity的启动标志位Intent.FLAG_ACTIVITY_NEW_TASK（如果设置了此标志，这个activity将成为一个新task的历史堆栈中的第一个activity。这个task定义了一个原子组activities，用户可以对其进行移除。各种tasks可以移到前面或者后面；在一个特定的task中，所有的activities总是保持相同的顺序。当使用这个标志时，如果一个包含此activity的task已经运行了，新的activity不会启动；同时，当前的task将简单的被提到窗口最前面。查看FLAG_ACTIVITY_MULTIPLE_TASK可以禁止这个行为）


2>  调用startActivity方法来继续启动根Activity组件；可以看到Launcher类中并未实现两个/一个参数的startActivity的方法，可知其在父类Activity中，这里将会调用Activity.startActivity()函数；


4、Activity类
    熟悉的Activity类:


    public class Activity extends ContextThemeWrapper
    implements LayoutInflater.Factory2,
    Window.Callback, KeyEvent.Callback,
    OnCreateContextMenuListener, ComponentCallbacks2,
    Window.OnWindowDismissedCallback


1、前面调用到的Activity#startActivity方法：



/** \frameworks\base\core\java\android\app\Activity.java*/ 
@Override
public void startActivity(Intent intent) {
    this.startActivity(intent, null);
}
 
@Override
public void startActivity(Intent intent, @Nullable Bundle options) {
    if (options != null) {
        startActivityForResult(intent, -1, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        startActivityForResult(intent, -1);
    }
}    最终将会调用startActivityForResult来执行函数，第二个参数设为-1表示不需要知道最终的执行结果。





2、来分析Activity#startActivityForResult方法:



public void startActivityForResult(Intent intent, int requestCode) {
    startActivityForResult(intent, requestCode, null);
}
 
public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {
    /** mParent在调用attach函数时传入*/
    if (mParent == null) {
    /** Instrumentation类用以监控应用程序与系统之间的交互，
     *  这里通过其execStartActivity来启动Activity组件**/
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData());
        }
        /** 这个本情况下不需要*/
        if (requestCode >= 0) {
            mStartedActivity = true;
        }
 
        /** 有关界面加载SurfaceFlinger*/
        final View decor = mWindow != null ? mWindow.peekDecorView() : null;
        if (decor != null) {
            decor.cancelPendingInputEvents();
        }
    } else {
       ...
    }
    if (options != null && !isTopOfTask()) {
        mActivityTransitionState.startExitOutTransition(this, options);
    }
}注意execStartActivity中的传参param：



1）mToken:



private IBinder mToken;


    mToken是一个Binder代理对象，指向了ActivityManagerService中一个类型为ActivityRecord的Binder本地对象。每一个已经启动的Activity组件在AMS（ActivityManagerService）中都存在一个对应的ActivityRecord对象，用来维护对应的Activity组件的运行状态及信息。
在调用execStartActivity函数时，传入实参mToken，使得可以将其传递给AMS，以便AMS接下来可以获得Launcher组件的详细信息。


前面提到调用execStartActivity方法，该方法是Instrumentation类中的方法。


5、Instrumentation类

    Instrumentation是执行application instrumentation代码的基类。当应用程序运行的时候instrumentation处于开启，Instrumentation将在任何应用程序运行前初始化，可以通过它监测系统与应用程序之间的交互。Instrumentation
 implementation通过的AndroidManifest.xml中的<instrumentation>标签进行描述。

    Instrumentation似乎有些类似与window中的“钩子（Hook）函数”，在系统与应用程序之间安装了个“窃听器”。


1、Instrumentation#execStartActivity函数：
先看调用传参：


Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);函数源码：





/** \frameworks\base\core\java\android\app\Instrumentation.java*/
public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, Activity target,
        Intent intent, int requestCode, Bundle options) {
    IApplicationThread whoThread = (IApplicationThread) contextThread;
   
    /** mActivityMonitors定义：List<ActivityMonitor> mActivityMonitors;
     *  ActivityMoniter：有关特定的Intent的监视。
     *  一个ActivityMoniter类的实例通过函数addMonitor
     *  （Instrumentation.ActivityMonitor）添加到当前
     *  instrumentation中，一旦添加后，每当启动一个新的Activity，
     *  ActivityMoniter就会检测，如果匹配，其hit count计数更新
     *  等其他操作。一个ActivityMonitor也可以用来寻找一个Activity，
     *  通过waitForActivity（）方法，这个函数将返直到匹配的活动被创建。*/
    // 这里与主线无关，可以不用关心
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i=0; i<N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
   
    /** 主要的代码从这里开始**/
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
       
        // 主要的执行函数在这里，调用了ActivityManagerNative中的startActivity
        int result = ActivityManagerNative.getDefault()
            .startActivity(whoThread, who.getBasePackageName(), intent,
                    intent.resolveTypeIfNeeded(who.getContentResolver()),
                    token, target != null ? target.mEmbeddedID : null,
                    requestCode, 0, null, options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
    }
    return null;
}   上述代码中最重要的作用是调用了ActivityManagerNative.getDefault().startActivity方法；getDefault用以获取AMS的一个代理对象ActivityManagerNative，接着再调用它的成员函数startActivity来通知AMS将有一个Activity组件启动。





6、ActivityManagerNative类：
看一下其继承关系：



    /** \frameworks\base\core\java\android\app\ActivityManagerNative.java*/
    public abstract class ActivityManagerNative extends Binder implements IActivityManager


1、ActivityManagerNative#getDefault函数：



    /** \frameworks\base\core\java\android\app\ActivityManagerNative.java*/
    static public IActivityManager getDefault() {
        // 单例类Singleton中的函数，get是Singleton类中的方法，见下面附I
        return gDefault.get();
    }
   
    // Singleton为单例模式的实现，是个抽象类，见附一
    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {
        protected IActivityManager create() {
            // 前面AMS分析中提到的AMS的主要服务"activity"，通过SM获取
            IBinder b = ServiceManager.getService("activity");
            ...
            IActivityManager am = asInterface(b);
            ...
            return am;
        }
    };
   
    static public IActivityManager asInterface(IBinder obj) {
        if (obj == null) {
            return null;
        }
        IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);
        if (in != null) {
            return in;
        }
        return new ActivityManagerProxy(obj);
    }
    可以看到当调用getDefault函数时，会返回gDefault.get()，返回一个IActivityManager类；





附I、Singleton类
    再看一下gDefault的定义，gDefault是个泛型类Singleton的对象实例，Singleton是个单例模式实现类，它是一个抽象类，它的定义如下：



    /**
     * Singleton helper class for lazily initialization.
     * Modeled after frameworks/base/include/utils/Singleton.h
     */
    public abstract class Singleton<T> {
        private T mInstance;
 
        protected abstract T create();
 
        public final T get() {
            synchronized (this) {
                if (mInstance == null) {
                    mInstance = create();
                }
                return mInstance;
            }
        }
    }    可以看到gDefault的定义是Singleton<IActivityManager>，调用get函数则是返回IActivityManager的具体实例对象。




    在定义gDefault时，需要重写abstract函数create()；在create函数中，可以看到它通过ServiceManager获取到一个服务名为"activity"的服务代理对象即一个引用了ActivtyManagerService的代理对象。
    而后通过asInterface将其封装成一个ActivityManagerProxy代理对象；
    因此调用getDefault最终获取到的返回结果时ActivityManagerService的代理对象。   
回到前面的步骤可知，ActivityManagerNative.getDefault().startActivity方法最终调用的是ActivityManagerProxy.startActivity方法。


2）ActivityManagerProxy类：（ActivityManagerNative的内部类）



/** \frameworks\base\core\java\android\app\ActivityManagerNative.java*/
class ActivityManagerProxy implements IActivityManager {
   
    public ActivityManagerProxy(IBinder remote) {
        mRemote = remote;
    }
 
    public IBinder asBinder() {
        return mRemote;
    }
 
    public int startActivity(IApplicationThread caller,
            String callingPackage, Intent intent, String resolvedType,
            IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle options)
            throws RemoteException {
        /*** 写入启动Activity的信息到Parcel对象data中 **/
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        data.writeString(callingPackage);
        intent.writeToParcel(data, 0);
        data.writeString(resolvedType);
        data.writeStrongBinder(resultTo);
        data.writeString(resultWho);
        data.writeInt(requestCode);
        data.writeInt(startFlags);
        if (profilerInfo != null) {
            data.writeInt(1);
            profilerInfo.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
        } else {
            data.writeInt(0);
        }
        if (options != null) {
            data.writeInt(1);
            options.writeToParcel(data, 0);
        } else {
            data.writeInt(0);
        }
        /** 通过Binder进行进程间通信，通过mRemote来向AMS发送START_ACTIVITY_TRANSACTION类型
         *  的进程间请求 **/
        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
        reply.readException();
        int result = reply.readInt();
        reply.recycle();
        data.recycle();
        return result;
    }
}    和通常的Binder通信机制相同，这里使用ActivityManagerProxy将Activity组件的信息封装到一个Parcel对象中，通过Binder机制传递给AMS，发起进程间通信请求。接下来的启动操作则会在AMS中进行。





版权声明：本文为博主原创文章，未经博主允许不得转载。

SpannableUtil，Android复合文本的使用
前些天有个大神告诉我，你写这么多TetxtView实际上就实现了一个TextView的功能。 
我说我要设置background，textsize，textcolor阿，还有各种点击事件，一个TextView怎么能实现呢？ 
他丢给了我一个TextViewUtil文件，我稍稍看了下，里面主要用到了 SpannableString 这个神奇的东西。 
于是就想深究一下这个SpannableString到底怎么去使用，都有哪些神奇的功能呢？
一边学习、一边写demo、一边看效果……
我写了这么个工具类，里面的注释已经很详细了（PS：详细得自己都不高兴再写文字讲解了- -）：
public class SpannableUtil
{
    /**
     * 仅实现了大部分效果
     * 有些些方法还需调整 
     * 后面有点偷懒 直接给了构造方法的参数  没有多写几个重载来更好地支持自定义
    **/
/**
 *  1、BackgroundColorSpan 背景色 
    2、ClickableSpan 文本可点击，有点击事件
    3、ForegroundColorSpan 文本颜色（前景色）
    4、MaskFilterSpan 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)  (经测试无效，不知如何生效  硬件加速关闭也没有效果)
    5、MetricAffectingSpan 父类，一般不用
    6、RasterizerSpan 光栅效果                                                   (经测试无效，不知如何生效  硬件加速关闭也没有效果)
    7、StrikethroughSpan 删除线（中划线）
    8、SuggestionSpan 相当于占位符
    9、UnderlineSpan 下划线
    10、AbsoluteSizeSpan 绝对大小（文本字体）
    11、DynamicDrawableSpan 设置图片，基于文本基线或底部对齐。
    12、ImageSpan 图片
    13、RelativeSizeSpan 相对大小（文本字体）
    14、ReplacementSpan 父类，一般不用
    15、ScaleXSpan 基于x轴缩放
    16、StyleSpan 字体样式：粗体、斜体等
    17、SubscriptSpan 下标（数学公式会用到）
    18、SuperscriptSpan 上标（数学公式会用到）
    19、TextAppearanceSpan 文本外貌（包括字体、大小、样式和颜色）                       
    20、TypefaceSpan 文本字体
    21、URLSpan 文本超链接
**/
    /**
     * 1
     * BackgroundColorSpan 背景色 
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param color
     * @return
     */
    public static SpannableString setBackgroundColorSpan(String content,int startIndex,int endIndex,int color) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new BackgroundColorSpan( color ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 2
     * ClickableSpan 文本可点击，有点击事件
     * 去下划线的可点击span
     * @param content
     * @param startIndex
     * @param endIndex
     * @param url
     * @return
     */
    public static SpannableString setClickableSpan(String content,int startIndex,int endIndex,final String url) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new ClickableSpan() {

            @Override
            public void updateDrawState(TextPaint ds) {
//              super.updateDrawState(ds);
                ds.setColor(ds.linkColor);
                ds.setUnderlineText(false); 
            }

            @Override
            public void onClick(View widget) {
                //url处理  跳转网页或其他
                Uri uri = Uri.parse(url);
                Context context = widget.getContext();
                Intent intent = new Intent(Intent.ACTION_VIEW, uri);
                intent.putExtra(Browser.EXTRA_APPLICATION_ID,
                        context.getPackageName());
                context.startActivity(intent);
                Log.i("span", url);
            }

        }, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 2重载
     * ClickableSpan 文本可点击，有点击事件
     * 去下划线的可点击span
     * @param content
     * @param startIndex
     * @param endIndex
     * @param clickableSpan 自己重写ClickableSpan的 updateDrawState与onClick方法
     * @return
     */
    public static SpannableString setClickableSpan(String content,int startIndex,int endIndex,ClickableSpan clickableSpan) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        if (null != clickableSpan) {
            spannableString.setSpan(clickableSpan, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }else {
            spannableString.setSpan(new ClickableSpan() {
                @Override
                public void onClick(View widget) {
                    Log.i("span", "clicked");
                }
            }, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return spannableString;
    }

    /**
     * 3
     * ForegroundColorSpan 前景色 
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param color
     * @return
     */
    public static SpannableString setForegroundColorSpan(String content,int startIndex,int endIndex,int color) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new ForegroundColorSpan( color ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 17
     *  SubscriptSpan 下标（数学公式会用到）
     * @param content
     * @param startIndex
     * @param endIndex
     * @return
     */
    public static SpannableString setSubscriptSpan( String content, int startIndex, int endIndex ){
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return null;
        }

        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan( new SubscriptSpan( ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE );

        return spannableString;
    }

    /**
     * 18
     *  SuperscriptSpan 上标（数学公式会用到）
     * @param content
     * @param startIndex
     * @param endIndex
     * @return
     */
    public static SpannableString setSuperscriptSpan( String content, int startIndex, int endIndex ){
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return null;
        }

        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan( new SuperscriptSpan( ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE );

        return spannableString;
    }
    /**
     * 4 (经测试无效，不知如何生效  硬件加速关闭也没有效果)
     * MaskFilterSpan 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)
     * @param content
     * @param startIndex
     * @param endIndex
     * @param blurMaskFilter    模糊
     * @param embossMaskFilter  浮雕
     * @param maskFilter        其他自定义效果
     * @return
     */
    public static SpannableString setMaskFilterSpan(String content,int startIndex,int endIndex,
            BlurMaskFilter blurMaskFilter,EmbossMaskFilter embossMaskFilter,MaskFilter maskFilter) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        if (null == blurMaskFilter) {
            spannableString.setSpan(new BlurMaskFilter(50, Blur.SOLID), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }else {
            spannableString.setSpan(blurMaskFilter, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (null == embossMaskFilter) {
            spannableString.setSpan(new EmbossMaskFilter(new float[]{1,1,1}, 0.4f, 6, (float)3.5), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }else {
            spannableString.setSpan(embossMaskFilter, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (null != maskFilter) {
            spannableString.setSpan(maskFilter, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return spannableString;
    }
    /**
     * 6 (经测试无效，不知如何生效  硬件加速关闭也没有效果)
     * RasterizerSpan 光栅效果 
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @return
     */
    public static SpannableString setRasterizerSpan(String content,int startIndex,int endIndex) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new RasterizerSpan(new Rasterizer()), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }
    /**
     * 7
     * StrikethroughSpan 删除线（中划线）
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @return
     */
    public static SpannableString setStrikethroughSpan(String content,int startIndex,int endIndex) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new StrikethroughSpan(), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 8
     * SuggestionSpan 替换建议
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @return
     */
    public static SpannableString setSuggestionSpan(String content,int startIndex,int endIndex) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new SuggestionSpan(Locale.CHINESE,new String[]{"SuggestionSpan1","SuggestionSpan2","SuggestionSpan3"}, SuggestionSpan.FLAG_EASY_CORRECT), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }
    /**
     * 9
     * UnderlineSpan 下划线
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @return
     */
    public static SpannableString setUnderlineSpan(String content,int startIndex,int endIndex) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new UnderlineSpan(), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 10   
     * AbsoluteSizeSpan 绝对大小（文本字体）(不建议使用，因为此处指定的字号大小以px为单位)
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param size 字号，单位px
     * @return
     */
    public static SpannableString setAbsoluteSizeSpan(String content,int startIndex,int endIndex,int size) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new AbsoluteSizeSpan(size), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 11
     * DynamicDrawableSpan 设置图片，基于文本基线或底部对齐
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param drawable 显示的图片
     * @return
     */
    public static SpannableString setDynamicDrawableSpan(String content,int startIndex,int endIndex,final Drawable drawable) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        //基线对齐
        spannableString.setSpan(new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BASELINE) {

            @Override
            public Drawable getDrawable() {
                Drawable d = drawable;
                d.setBounds(0, 0, 50, 50);
                return d;
            }

        }, startIndex, startIndex + 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        //底部对齐
        spannableString.setSpan(new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BOTTOM) {

            @Override
            public Drawable getDrawable() {
                Drawable d = drawable;
                d.setBounds(0, 0, 50, 50);
                return d;
            }

        }, startIndex + 1, startIndex + 2, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 12
     * ImageSpan 图片
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param drawable 显示的图片
     * @return
     */
    public static SpannableString setImageSpan(String content,int startIndex,int endIndex,final Drawable drawable) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        drawable.setBounds(0, 0, 50, 50);
        spannableString.setSpan(new ImageSpan(drawable), startIndex, startIndex + 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 13
     * RelativeSizeSpan 相对大小（文本字体）
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param size 字缩放倍数
     * @return
     */
    public static SpannableString setRelativeSizeSpan(String content,int startIndex,int endIndex,float size) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new RelativeSizeSpan(size), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }
//  ScaleXSpan 基于x轴缩放

    /**
     * 15
     * ScaleXSpan 基于x轴缩放
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param size x轴缩放倍数
     * @return
     */
    public static SpannableString setScaleXSpan(String content,int startIndex,int endIndex,float size) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new ScaleXSpan(size), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 16
     * StyleSpan 字体样式：粗体、斜体等
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param flag  Typeface.xxx
     * @return
     */
    public static SpannableString setStyleSpan(String content,int startIndex,int endIndex,int flag) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new StyleSpan(flag), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }
    /**
     * 19
     * TextAppearanceSpan 文本字体
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param context
     * @return
     */
    public static SpannableString setTextAppearanceSpan(String content,int startIndex,int endIndex,Context activity) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new TextAppearanceSpan(activity,android.R.style.TextAppearance_Holo_Large_Inverse), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 20
     * TypefaceSpan 文本字体
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param family The font family for this typeface.  Examples include
     * "monospace", "serif", and "sans-serif".
     * @return
     */
    public static SpannableString setTypefaceSpan(String content,int startIndex,int endIndex,String family) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new TypefaceSpan(family), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }


    /**
     * 21
     * URLSpan 文本超链接
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param url 
     * @return
     */
    public static SpannableString setURLSpan( String content, int startIndex, int endIndex, String url ){
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }

        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new URLSpan( url ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

        return spannableString;
    }
}
注意使用了ClickableSpan 点击事件必须调用TextView的setMovementMethod(LinkMovementMethod.getInstance());方法否则无效
代码量确实不小= =本来以为只需要几个小时的 结果花了我昨天一个下午外加今天一个上午 完成demo + 稍微优化。然而这里面还是有没有解决的东西 。。。比如 MaskFilterSpan 和RasterizerSpan 这两个顽疾，在API19下一直都没跑出来效果，关闭了硬件加速也没有效果。
如果有大神能够解决，万望告知……毕竟觉得MaskFilterSpan 能自定义很多效果，如果不能用的话，痒痒的。
另外，不知各位对Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 这个属性可有疑问。 我搜索出来有人是这样说的： 
Spanned.SPAN_EXCLUSIVE_EXCLUSIVE — 不包含两端start和end所在的端点 
   Spanned.SPAN_EXCLUSIVE_INCLUSIVE — 不包含端start，但包含end所在的端点 
   Spanned.SPAN_INCLUSIVE_EXCLUSIVE — 包含端start，但不包含end所在的端点 
   Spanned.SPAN_INCLUSIVE_INCLUSIVE— 包含两端start和end所在的端点 
但我尝试后好像并不是这样。 

此处引用 http://aichixihongshi.iteye.com/blog/1207503 的文章 
   Spanned.SPAN_EXCLUSIVE_EXCLUSIVE，这是在 setSpan 时需要指定的 flag，它的意义我试了很久也没试出来，睡个觉，今天早上才突然有点想法，试之，果然。它是用来标识在 Span 
  范围内的文本前后输入新的字符时是否把它们也应用这个效果。分别有  
  Spanned.SPAN_EXCLUSIVE_EXCLUSIVE(前后都不包括)、 
  Spanned.SPAN_INCLUSIVE_EXCLUSIVE(前面包括，后面不包括)、 
  Spanned.SPAN_EXCLUSIVE_INCLUSIVE(前面不包括，后面包括)、 
  Spanned.SPAN_INCLUSIVE_INCLUSIVE(前后都包括)。 
  看个截图就更明白了： 
 
  对比一下 


demo地址：http://download.csdn.net/download/yaosongqwe/9048655 
如积分不够，可以回复留下邮箱，我会发送至各位的邮箱。 

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为YS尘笑原创文章，未经本人允许不得转载。

如果在 unity中滚动 3D 骰子
孙广东   2015.8.16目的:     这篇文章的主要目的是为了让您了解有关如果在 unity中滚动 3D 骰子                建设一个棋盘游戏   但因为骰子困扰   ;         这个问题分为两个主要部分:	         如何掷骰子。	        确定是 1和6之间的随机一个整数面值 (六面临标准骰子)。 如何掷骰子 步骤-1:   将标准骰子模型导入 unity3D。调整Transform ，如图所示，将 刚体添加到它。步骤 -2:  现在将代码片段添加 到脚本 。           注: 这段代码使您能够使用鼠标触发 ，如果进行适当更改，你可以轻松地变为触摸设备。 if (Input.GetMouseButtonDown (0))
{
//initial click to roll a dice
initPos = Input.mousePosition;
 
//return x component of dice from screen to view point
initXpose = cam.ScreenToViewportPoint (Input.mousePosition).x;
}
 
//current position of mouse
Vector3 currentPos = Input.mousePosition;
 
//get all position along with mouse pointer movement
Vector3 newPos = cam.ScreenToWorldPoint (newVector3(currentPos.x,currentPos.y,Mathf.Clamp(currentPos.y/10,10,50)));
 
//translate from screen to world coordinates  
newPos = cam.ScreenToWorldPoint (currentPos);
 
if (Input.GetMouseButtonUp (0))
{
initPos = cam.ScreenToWorldPoint (initPos);
 
//Method use to roll the dice
RollTheDice(newPos);
//use identify face value on dice
StartCoroutine(GetDiceCount ());
}
 
//Method Roll the Dice
void RollTheDice(Vector3 lastPos)
{
               diceObject.rigidbody.AddTorque(Vector3.Cross(lastPos, initPos) * 1000, orceMode.Impulse);
lastPos.y += 12;
diceObject.rigidbody.AddForce (((lastPos - initPos).normalized) * (Vector3.Distance (lastPos, initPos)) * 25 * duceObject.rigidbody.mass);
}步骤-3:  RollTheDice 方法是如何工作的:	         最初，掷骰子时 扭矩Torque 被添加 旋转骰子。然后 力Force 被增加， 所以它会给真正的骰子被滚动的外观和感觉。        转矩的计算使用 交叉产品的 lastPos 和 initPos 对移动旋转像真正的骰子，并将在鼠标的方向移动 。	同样添加力Force ，以掷骰子的鼠标的方向。 //Coroutine to get dice count
void GetDiceCount()
{
if (Vector3.Dot (transform.forward, Vector3.up) > 1)
diceCount = 5;
if (Vector3.Dot (-transform.forward, Vector3.up) > 1)
diceCount = 2;
if (Vector3.Dot (transform.up, Vector3.up) > 1)
diceCount = 3;
if (Vector3.Dot (-transform.up, Vector3.up) >1)
diceCount = 4;
if (Vector3.Dot (transform.right, Vector3.up) >1)
diceCount = 6;
if (Vector3.Dot (-transform.right, Vector3.up) >1)
diceCount = 1;
Debug.Log ("diceCount :" + diceCount);
}步骤-4:  以上代码段说明如何确定在骰子上随机的面值。	        这段代码必须包含在脚本中，  骰子在hierarchy和transforms 应该是如图 1 所示。	       点数用于查找哪一张脸是将被考虑。	

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 6.0中的新技术有哪些

最近 Google 正式发布了 Android M，并命名为“棉花糖”(Marshmallow)，对于开发者来说，有哪些新的技术和变化呢?本文尝试总结一下 Android 6.0(API 23)给开发者带来新的技术和改变。

权限管理
权限管理是 Android M 最大的改变，权限管理更加精细，并且由以前的安装时静态授权，改为现在的运行时动态授权。大家对 Android 的权限吐槽已久，Android 应该能极大的改善这方面的问题。主要改变有：
系统设置中可以对 APP 各个权限单独控制
权限根据内容进行分组了
普通权限还是在安装时授权
其他权限在运行时系统弹窗授权，并且要解析使用这个权限的目的
对于开发者来说，需要小心处理权限相关的问题。在使用某个功能的时候，需要总是判断是否有改权限，并且通过合适的方式请求用户授权。关于 Android M 权限的处理，可以参考官方文档。
另外，这篇文章结合图文和代码讲述了 Android M 中权限模型，比较清晰，可以参考一下。
APP Linking
这是一个把 APP 和网页直接打通的技术，能够让 APP 能够直接来处理你的网站普通的 URL 链接，来展示你对应的网站内容。这绝对是一个值得关注的改进，Web 和 APP 之间缝隙将越来越小。这对既有网站又有 APP 的应用来说非常有利，例如知乎和淘宝等。
有点类似于之前的 APP 的 Deep link，可以通过特殊的 Schema 也可以让 APP 直接打开对应的内容。APP Linking 的特点是，只要使用传统的 URL 就可以，而且是根据 URL 的域名对应特定的 APP 的。
开发者需要做的是在 AndroidManifest.xml 做一下对应的声明即可。如果需要让系统默认用你的 APP 打开对应的 URL 的话，还需要网站配合提供 assetlinks.json。详情可以参考这里。
APP 数据自动备份
支持 APP 数据自动备份到 Google Drive，在你换手机的时候，能够直接把 APP 的数据恢复到你的手机上，你还可以配置些数据那些数据需要或者不需要备份。而且不用写任何代码就自动实现了。详情可以参考这里。
然而这些对国内的开发者来说，并没有什么用。国内厂商的 ROM 有些已经有或者准备会跟上，到时候都能享受到这样的便利。
指纹解锁
Android 官方支持指纹认证，可以用在解锁，或者任何需要验证用户的地方，例如支付。提供了新的 API FingerprintManager，让第三方 APP 来用来获得指纹认证的功能。具体使用方法可以参考这个实例。
直接分享
直接分享是在 APP 内直接弹出一个选择分享到其他应用的中的对象的列表，中间省略了选择需要分享的 APP，选择“联系人”之类的操作。Android 中分享已经做得很好了，这里又更进一步简化了分享操作。如果要让你的 APP 支持被直接分享，需要实现一个ChooserTargetService，并且实现对应的处理分享 Intent 的 Activity。具体使用可以参考这里。
支持蓝牙触控笔
系统内置支持蓝牙触控笔，这样 Android 系统就默认支持高大上的触控笔了。并提供了 API 让你的 APP 来响应触控笔事件。
低功耗蓝牙扫描优化
优化了低功耗蓝牙扫描优化的扫描。现在低功耗蓝牙的应用越来越多，很多 APP 都需要扫描设备，扫描设备是一个非常重的操作，希望这次改动，能够带来一些改善。
支持主题化的 ColorStateLists
使用 context.getColorStateList(int id) 来获取当前主题对应的 ColorStateLists。
相机 API
提供 API setTorchMode()) 来直接开关闪光灯，并且可以监听闪光灯的开光状态，以前很多 APP 已经支持用闪光灯来做手电筒，现在官方提供 API 来做这样的事情了。
从 Android 5.0 开始，就提供了一套全新的相机 API Camera2，这里在此基础上添加了处理相关 API。
其他
另外还有很多的改进，因为涉及的方面太专业，或者是没有使用到相关功能，我就不详细说了，可以参考官方概述：
有语音交互 API
Hotspot 2.0 支持
4k 屏支持
语音和视频 API 的改进
Android 企业用户特性，例如多用户支持，静默安装等。
推荐阅读：
资深程序员编程经验分享

为什么程序员有高薪却不高兴？



版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 自定义主菜单
本文介绍一个超简单的自定义主菜单，效果如下：


原理：其实就是对原生的Dialog的一个简单的封装。并加上显示和隐藏的动画效果。再给控件加上回调事件。


TestDialog.java
public class TestDialog implements OnClickListener {
	private Context mContext;
	private Dialog mDialog;
	private Display mDisplay;
	private TextView mTitle;
	private TextView mOk, mCancel;
	private LinearLayout mContent;
	private List<String> mItems = null;
	private List<OnCustomItemClickListener> mListeners = null;
	private List<Drawable> mDrawables = null;

	public TestDialog(Context context) {
		this.mContext = context;
		WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
		mDisplay = windowManager.getDefaultDisplay();
	}

	/**
	 * builder()创建
	 * 
	 * @return
	 */
	public TestDialog builder(int layout) {
		initView(layout);
		return this;
	}

	/**
	 * 初始化Dialog视图的方法
	 * 
	 * @param layout
	 */
	private void initView(int layout) {
		View view = LayoutInflater.from(mContext).inflate(layout, null);
		view.setMinimumWidth(mDisplay.getWidth());
		//
		mTitle = (TextView) view.findViewById(R.id.menu_title);
		mContent = (LinearLayout) view.findViewById(R.id.menu_content);
		mOk = (TextView) view.findViewById(R.id.menu_ok);
		mCancel = (TextView) view.findViewById(R.id.menu_cancel);
		mOk.setOnClickListener(this);
		mCancel.setOnClickListener(this);
		mDialog = new Dialog(mContext, R.style.DialogStyle);
		mDialog.setContentView(view);
		Window dialogWindow = mDialog.getWindow();
		dialogWindow.setGravity(Gravity.LEFT | Gravity.BOTTOM);
		WindowManager.LayoutParams lp = dialogWindow.getAttributes();
		lp.x = 0;
		lp.y = 0;
		dialogWindow.setAttributes(lp);
	}

	/**
	 * 
	 * @param 是否能取消
	 * @return
	 */
	public TestDialog setCancelable(boolean b) {
		if (mDialog != null) {
			mDialog.setCancelable(b);
		}
		return this;
	}

	/**
	 * 设置对话框标题
	 * 
	 * @param title
	 * @return
	 */
	public TestDialog setTitle(String title) {
		if (mDialog != null) {
			mTitle.setText(title);
			mTitle.setVisibility(View.VISIBLE);
		}
		return this;
	}

	/**
	 * 
	 * @param 点击Dialog以外的部分是否可以取消
	 * @return
	 */

	public TestDialog set(boolean b) {
		if (mDialog != null) {
			mDialog.setCanceledOnTouchOutside(b);
		}
		return this;
	}

	/**
	 * 取消
	 */
	public void dismiss() {
		mDialog.dismiss();
	}

	/**
	 * 用来装视图数据的集合
	 * 
	 * @param title
	 * @return
	 */
	public TestDialog addItem(String title, Drawable drawable, OnCustomItemClickListener clickListener) {
		if (mItems == null) {
			mItems = new ArrayList<String>();
		}
		if (mListeners == null) {
			mListeners = new ArrayList<TestDialog.OnCustomItemClickListener>();
		}
		if (mDrawables == null) {
			mDrawables = new ArrayList<Drawable>();
		}
		mItems.add(title);
		mListeners.add(clickListener);
		mDrawables.add(drawable);
		return this;
	}

	private void setItem() {
		if (mItems == null || mItems.size() <= 0) {
			return;
		}
		int count = mItems.size();
		for (int i = 0; i < count; i++) {
			final int index = i;
			TextView view = new TextView(mContext);
			view.setText("object" + 1);
			view.setCompoundDrawablesRelativeWithIntrinsicBounds(null, mDrawables.get(i), null, null);
			view.setOnClickListener(new OnClickListener() {

				@Override
				public void onClick(View v) {
					// TODO Auto-generated method stub
					mListeners.get(index).onClick(index);
				}
			});
			mContent.addView(view);
		}
	}

	public void show() {
		setItem();
		mDialog.show();
	}

	public interface OnCustomItemClickListener {
		public abstract void onClick(int v);
	}

	@Override
	public void onClick(View v) {
		if (v == mOk) {

		} else if (v == mCancel) {

		}
		mDialog.dismiss();

	}

}
用到的Teme：
<style name="DialogStyle" parent="@android:style/Theme.Dialog">

        <!-- 背景透明 -->
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:windowContentOverlay">@null</item>
        <!-- 浮于Activity之上 -->
        <item name="android:windowIsFloating">true</item>
        <!-- 边框 -->
        <item name="android:windowFrame">@null</item>
        <!-- Dialog以外的区域模糊效果 -->
        <item name="android:backgroundDimEnabled">true</item>
        <!-- 无标题 -->
        <item name="android:windowNoTitle">true</item>
        <!-- 半透明 -->
        <item name="android:windowIsTranslucent">true</item>
        <!-- Dialog进入及退出动画 -->
        <item name="android:windowAnimationStyle">@style/ActionSheetDialogAnimation</item>
    </style>

    <style name="ActionSheetDialogAnimation" parent="@android:style/Animation.Dialog">
        <item name="android:windowEnterAnimation">@anim/dialog_in</item>
        <item name="android:windowExitAnimation">@anim/dialog_out</item>
    </style>动画文件：
dialog_in.xml
<?xml version="1.0" encoding="utf-8"?>
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="200"
    android:fromYDelta="100%"
    android:toYDelta="0" />dialog_out.xml
<?xml version="1.0" encoding="utf-8"?>
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="200"
    android:fromYDelta="0"
    android:toYDelta="100%" />


用到的布局文件：
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@android:color/white"
    android:orientation="vertical" >

    <TextView
        android:id="@+id/menu_title"
        android:layout_width="match_parent"
        android:layout_height="45dip"
        android:background="@drawable/menu_item_background"
        android:gravity="center"
        android:visibility="gone" />

    <LinearLayout
        android:id="@+id/menu_content"
        android:layout_width="match_parent"
        android:layout_height="150dip"
        android:gravity="center_vertical"
        android:orientation="horizontal" >
    </LinearLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1px"
        android:background="@android:color/darker_gray" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="45dip"
        android:orientation="horizontal" >

        <TextView
            android:id="@+id/menu_ok"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:background="@drawable/menu_item_background"
            android:gravity="center"
            android:text="@string/menu_ok" />

        <View
            android:layout_width="1px"
            android:layout_height="match_parent"
            android:background="@android:color/darker_gray" />

        <TextView
            android:id="@+id/menu_cancel"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:background="@drawable/menu_item_background"
            android:gravity="center"
            android:text="@string/menu_cancel" />
    </LinearLayout>

</LinearLayout>


用到的背景
<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:drawable="@android:color/darker_gray" android:state_focused="true"></item>
    <item android:drawable="@android:color/darker_gray" android:state_pressed="true"></item>
    <item android:drawable="@android:color/white"></item>

</selector>

在Activity中使用：
findViewById(R.id.click).setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				TestDialog dialog = new TestDialog(MainActivity.this);
				dialog.builder(R.layout.menu);
				dialog.setCancelable(false);
				dialog.addItem("微博1", getResources().getDrawable(R.drawable.ic_weibo), new OnCustomItemClickListener() {

					@Override
					public void onClick(int v) {
						Toast.makeText(getBaseContext(), "1", 1).show();
					}
				});
				dialog.addItem("微博2", getResources().getDrawable(R.drawable.ic_weibo), new OnCustomItemClickListener() {

					@Override
					public void onClick(int v) {
						Toast.makeText(getBaseContext(), "3", 1).show();
					}
				});
				dialog.show();
			}
		});



版权声明：本文是博主原创文章，你可以在未经博主允许的情况下随便转载。顾明伟 http://blog.csdn.net/u013045971

Android通过startService实现批量下载示例
关于startService的基本使用概述及其生命周期可参见博客《Android中startService的使用及Service生命周期》。
本文通过批量下载文件的简单示例，演示startService以及stopService(startId)的使用流程。
系统界面如下: 

界面很简单，就一个按钮“批量下载文章”，通过该Activity上的按钮启动DownloadService。
DownloadService是用来进行下载CSDN上博客文章的服务，代码如下:
package com.ispring.startservicedemo;

import android.app.Service;
import android.content.Intent;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.util.Log;
import android.widget.Toast;

import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

public class DownloadService extends Service {
    //存储所有的startId
    private List<Integer> allStartIdList = new ArrayList<>();
    //存储已经下载完成的startId
    private List<Integer> finishedStartIdList = new ArrayList<>();

    private Handler handler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            if(msg.what == 1){
                String tip = (String)msg.obj;
                Toast.makeText(DownloadService.this, tip, Toast.LENGTH_LONG).show();
            }
        }
    };

    class DownloadThread extends Thread {

        //对应的intent的startId信息
        private int startId = 0;

        //要下载的文章名称
        private String blogName = null;

        //要下载的文章地址
        private String blogUrl = null;

        public DownloadThread(int startId, String name, String url){
            this.startId = startId;
            this.blogName = name;
            this.blogUrl = url;
        }

        @Override
        public void run() {
            HttpURLConnection conn = null;
            InputStream is = null;
            try{
                //下载指定的文件
                URL url = new URL(this.blogUrl);
                conn = (HttpURLConnection)url.openConnection();
                if(conn != null){
                    //我们在此处得到所下载文章的输入流，可以将其以文件的形式写入到存储卡上面或
                    //将其读取出文本显示在App中
                    is = conn.getInputStream();
                }
            }catch (MalformedURLException e){
                e.printStackTrace();
            }catch (IOException e){
                e.printStackTrace();
            }finally {
                if(conn != null){
                    conn.disconnect();
                }
            }

            finishedStartIdList.add(startId);

            if(finishedStartIdList.containsAll(allStartIdList)){
                String tip = "全部下载完成, 数量" + finishedStartIdList.size();
                Message msg = handler.obtainMessage(1);
                msg.obj = tip;
                handler.sendMessage(msg);
            }

            Log.i("DemoLog", "stopSelf(" + startId + ")");
            stopSelf(startId);
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Log.i("DemoLog", "DownloadService -> onCreate");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        allStartIdList.add(startId);
        String name = intent.getStringExtra("name");
        String url = intent.getStringExtra("url");
        Log.i("DemoLog", "DownloadService -> onStartCommand, startId: " + startId + ", name: " + name);
        DownloadThread downloadThread = new DownloadThread(startId, name, url);
        downloadThread.start();
        return START_REDELIVER_INTENT;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.i("DemoLog", "DownloadService -> onDestroy");
    }
}
DownloadActivity的代码如下:
package com.ispring.startservicedemo;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


public class DownloadActivity extends Activity implements Button.OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_download);
    }

    @Override
    public void onClick(View v) {
        List<String> list = new ArrayList<>();
        list.add("Android中Handler的使用;http://blog.csdn.net/iispring/article/details/47115879");
        list.add("深入源码解析Android中的Handler,Message,MessageQueue,Looper;http://blog.csdn.net/iispring/article/details/47180325");
        list.add("Android新线程中更新主线程UI中的View方法汇总;http://blog.csdn.net/iispring/article/details/47300819");
        list.add("Android中HandlerThread的使用及原理解析;http://blog.csdn.net/iispring/article/details/47320407");
        list.add("Android中Looper的quit方法和quitSafely方法;http://blog.csdn.net/iispring/article/details/47622705");

        Iterator iterator = list.iterator();

        while (iterator.hasNext()){
            String str = (String)iterator.next();
            String[] splits = str.split(";");
            String name = splits[0];
            String url = splits[1];
            Intent intent = new Intent(this, DownloadService.class);
            intent.putExtra("name", name);
            intent.putExtra("url", url);
            startService(intent);
        }
    }
}
当我们单击了按钮“批量下载文章”时，我们会多次调用Activity的startService方法，其中我们在其参数intent中存储了文章名name以及文章的地址url，由于我们多次调用了startService方法，所以会批量下载文章。
点击按钮后，控制台运行结果如下所示: 

调用了startService之后，Android Framework接收到了intent信息，第一次会先创建DownloadService的实例，然后执行其onCreate回调方法，onCreate在Service的生命周期中只会调用一次。
调用了onCreate方法后，Android会自动回调其onStartCommand方法，其实每次调用Context的startService都会触发onStartCommand回调方法，所以onStartCommand在Service的生命周期中可能会被调用多次。在onStartCommand方法中我们可以获得intent和startId，intent即我们调用startService方法时传入的参数，startId是Android自动分配的，每次调用startService都会自动得到一个startId，一个startId就意味着一个job，也就是意味着一次下载任务。我们在DownloadService中有两个字段allStartIdList和finishedStartIdList。allStartIdList存储着所有的startId，我们在onStartCommand方法一开始就把我们得到的startId放入到allStartIdList中存储，然后我们根据intent读取到文章名name和文章地址url，并根据这些信息创建一个新的线程DownloadThread，该线程用于执行实际的网络请求下载工作。需要注意的是，为了代码简化起见我们在onStartCommand中只要得到intent就开辟一个新线程(DownloadThread)，但是在实际生产环境中这样的开销比较大（线程新建、线程销毁），应该尽量使用线程池以节约开销。
执行了DownloadThread的start方法后，就会执行DownloadThread线程的run方法，在该方法中我们会执行网络请求，获取博客文章的输入流，当我们获取到该输入流之后，我们就认为下载完成了，此时我们可以将其以文件的形式写入到存储卡上，也可以将其读取出文本显示在App上，此处我们没有对输入流做任何处理，我们就认为下载完成了。下载完成后，我们把startId存入到finishedStartIdList中，finishedStartIdList存储着所有已经完成的job的startId。当finishedStartIdList中已经包含了allStartIdList的所有startId时，说明我们所有的下载任务完成了，我们会通过handler让主线程显示Toast告知用户文章下载完成。在run方法的最后我们会执行Service的stopSelf(startId)方法。需要注意的是我们在stopSelf方法中传入了startId，这意味着我们不是直接停止Service的运行，我们只是停止该startId对应的job的执行，如果所有的startId所对应的job都停止了，那么整个Service才会停止，当整个Service停止时，才会触发执行Service的onDestroy回调方法。
本文只是通过批量下载博文这一简单示例演示通过startService以及stopSelf(startId)使用Service基本使用流程，代码没有进行优化，希望对大家学习Service有所帮助。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

6）Win10-UWA开发  应用生命周期
﻿﻿﻿﻿孙广东   2015.8.24本主题介绍了 Windows 运行时应用的生命周期，从部署它一直到删除它。通过正确地启动、挂起和恢复你的应用，可确保客户拥有最佳应用体验。应用执行状态此图表现了应用执行状态之间的转换。我们在后面几部分中介绍了这些状态和事件。有关每个状态转换以及你的应用应如何响应的详细信息，请参阅有关 ApplicationExecutionState 枚举的参考文档。部署为了能够以任何方式激活应用，必须先对其进行部署。在以下情况下应特别注意进行基本部署：当用户安装你的应用时，或者当你使用 Visual Studio 以在开发和测试期间本地构建并运行自己的应用时。有关此部署以及高级部署方案的详细信息，请参阅应用包和部署。应用启动每当用户激活一个应用而且该应用进程之前处于 NotRunning 状态时，它就会启动。应用可能处于 NotRunning 状态，原因有：它从未启动、它运行后出现了故障，或者它被挂起后无法保留在内存中而被系统终止。当应用启动时，Windows 显示应用的一个初始屏幕。若要配置此初始屏幕，请参阅“添加初始屏幕”（HTML 或 XAML）。当初始屏幕显示时，应用代码还应该确保该应用已准备好向用户显示其用户界面。应用的主要任务是注册事件处理程序和设置它需要加载初始页面的任何自定义 UI。这些任务仅应占用几秒的时间。如果某个应用需要从网络请求数据或者需要从磁盘检索大量的数据，这些活动应在激活以外完成。应用在等待完成这些长时间运行的操作时，可以使用自己的自定义加载 UI 或延长的初始屏幕。有关详细信息，请参阅“如何延长初始屏幕”（HTML 或 XAML）以及初始屏幕示例。在应用完成激活后，它将进入 Running 状态，随后初始屏幕将消失（并且其所有资源和对象将被清除）。显示一个窗口、从激活处理程序返回，以及完成一定的延期，这些是应用完成激活的具体方式。有关详细信息，请参阅“如何激活应用”（HTML 或 XAML）。应用激活应用可以由用户通过各种合约和扩展激活。若要参与激活，则必须将你的应用注册为接收 WinJS activated 事件 (HTML) 或覆盖 OnActivated 方法 (XAML)。（对于 HTML，WebUIApplication.activated 是另一个可用于处理激活的事件。） 你的应用的激活代码可以通过测试了解其激活原因以及是否已经处于 Running 状态。应用可以使用以下任意激活类型进行激活：Activation type描述缓存的文件用户希望保存你的应用对其进行内容管理的文件。相机用户希望通过所连的相机拍照或捕获视频。联系人选取器用户希望挑选联系人。设备用户希望你的应用能处理自动播放。文件用户的应用启动一个文件，该文件的类型是应用已注册可处理的类型。文件打开选取器用户希望挑选应用提供的文件或文件夹。文件保存选取器用户希望保存文件并选择了你的应用。启动用户启动应用或点击一个内容磁贴。打印任务用户希望你的应用处理打印任务。协议用户的应用启动一个 URL，其协议是应用已注册可处理的协议。搜索用户希望搜索你的应用。共享目标用户希望你的应用作为共享操作的目标。 为 Windows 8.1 及更高版本构建的应用可以使用上述任意方式激活，也可以使用这些激活类型激活。Activation type描述添加约会用户希望向其日历中添加约会。还在 Windows Phone 上受支持。删除约会用户希望从其日历中删除约会。还在 Windows Phone 上受支持。替换约会用户希望替换其日历中的约会。还在 Windows Phone 上受支持。显示期限用户希望在其日历上显示特定的期限。还在 Windows Phone 上受支持。呼叫联系人用户希望呼叫联系人。定位联系人用户希望定位联系人（获取联系人的位置）。向联系人发送消息用户希望向联系人发送消息。发布联系人用户希望发布联系人。通过视频呼叫联系人用户希望通过视频呼叫联系人。锁屏通话用户希望在锁屏状态下接受呼叫。限制启动用户启动了受限制的应用。 使用这些类型可以激活 Windows Phone 应用。Activation type描述VoiceCommand作为语音命令的结果，已激活应用程序。PickerReturned选择选取器后，应用程序已被激活。WalletAction已激活应用程序以执行电子钱包操作。PickFileContinuation为文件选取器操作挂起应用后，应用程序已被激活。PickSaveFileContinuation为文件保存选取器操作挂起应用后，应用程序已被激活。PickFolderContinuation为文件夹选取器操作挂起应用后，应用程序已被激活。WebAuthenticationBrokerContinuation为 Web 身份验证代理操作挂起应用后，应用程序已被激活。 当操作系统终止你的应用后用户又重新启动它时，你的应用可以使用激活还原以前保存的数据。Windows 在应用挂起后可能出于一些原因而将其终止。用户可以手动关闭你的应用或者注销，否则系统的资源可能不足。如果用户在 Windows 终止你的应用之后启动它，该应用将收到一个 activated 事件 (HTML) 或 Application.OnActivated 回调 (XAML)，并且用户将看到应用的初始屏幕，直到该应用激活为止。你可以通过此事件确定你的应用是否需要还原其在上次挂起时保存的数据，或者是否必须加载应用的默认数据。由于初始屏幕已出现，因此你的应用代码可以在不明显拖延用户时间的情况下花费一些处理时间来完成此激活操作，然而在重新启动或继续该操作时前面所提到的关于运行时间较长的操作的问题仍存在。activated/OnActivated 事件数据包括一个 PreviousExecutionState 属性，用于告诉你应用在激活之前处于哪种状态。此属性是 ApplicationExecutionState 枚举中的值之一：  终止原因PreviousExecutionState 属性的值采取的操作已由系统终止（例如，因为资源限制）Terminated还原会话数据被用户关闭或被用户终止进程ClosedByUser  使用默认数据启动意外终止，或者应用在当前用户会话期间未运行NotRunning使用默认数据启动 注意  当前用户会话基于 Windows 登录。只要当前用户未显式注销、关闭当前用户会话，或者 Windows 未出于其他原因而重新启动它，该会话便可以保留在诸如锁屏身份验证、切换用户等多个事件中。PreviousExecutionState 还可能有 Running 或 Suspended 值，但在这些情况下，你的应用不是之前终止的，因此不必担心还原数据。注意  如果你使用计算机的管理员帐户登录，则你将无法激活任何 Windows 运行时应用。有关详细信息，请参阅应用扩展。OnActivated 与 XAML 应用中的特定激活的对比在 XAML 激活模型和 Application 类 中，可使用 OnActivated 方法来处理所有可能的激活类型。但是，更常见的做法是使用不同的方法来处理最常见的激活类型，而对于不太常见的激活类型，则仅使用 OnActivated 作为回滚方法。例如， Application 具有 OnLaunched 方法，用于在 ActivationKind 是 Launch 时作为回调进行调用，这是适用于大多数应用的典型激活方法。有超过 6 种 On* 方法可用于特定的激活：OnCachedFileUpdaterActivated、OnFileActivated、OnFileOpenPickerActivated、OnFileSavePickerActivated、OnSearchActivated 和 OnShareTargetActivated。XAML 应用的起始模板具有一个针对 OnLaunched 的实现和一个适用于 Suspending 的处理程序，并且兼具每个模板中预定义的 SuspensionManager 类中的这两种合并方法。对于 SuspensionManager 的作用的描述在本主题的范围内；有关详细信息，请参阅适用于应用的 C#、VB 和 C++ 项目模板。应用挂起应用可在用户离开它或设备进入电量不足状态时挂起。大部分应用会在用户离开它们时挂起。当用户将一个应用移动到后台时，Windows 将等待几秒，以查看用户是否打算立即返回该应用。如果用户在此时间段内没有切换回，Windows 将挂起该应用。如果应用已经为 WinJS checkpoint 事件（适用于 HTML）或 Application.Suspending 事件（适用于 XAML）注册一个事件处理程序，则在要挂起该应用之前调用此代码。你可以使用事件处理程序保存相关应用和用户数据。我们建议使用应用程序数据 API 完成此目的，因为它们可保证在应用进入 Suspended 状态之前完成工作。有关详细信息，请参阅使用 Windows 运行时访问应用数据。你还应释放独占资源和文件句柄，这样在你的应用没有使用它们时其他应用可以访问。通常，你的应用应该在处理挂起事件时立即保存其状态并释放其独占资源和文件句柄，并且此代码最多只需 1 秒便可完成工作。如果应用在 Windows 上未在 5 秒内和在 Windows Phone 上未在 1 至 10 秒之间从挂起事件中返回，则 Windows 假设应用已停止响应并终止该应用。Windows 会尝试在内存中保留尽可能多的挂起应用。通过将这些应用保留在内存中，可确保用户在已挂起的应用之间快速且可靠地切换。但是，如果没有足够的资源将应用保留在内存中，则 Windows 可能会终止你的应用。应用不会收到它们被终止的通知，所以你保存应用数据的唯一机会是在挂起期间。当应用确定它在终止后被激活时，它应该加载它在挂起期间保存的应用数据，以使其按照被挂起前的方式运行。有些应用必须继续运行才能完成后台任务。例如，你的应用可以在后台继续播放音频；有关详细信息，请参阅“如何在后台播放音频”（HTML 或 XAML）。此外，即使你的应用挂起甚至终止，后台传输操作仍将继续；有关详细信息，请参阅“如何下载文件”（HTML 或 XAML）。有关指南，请参阅应用挂起和恢复指南。有关示例代码，请参阅“如何挂起应用”（HTML 或 XAML）。应用可见性当用户从你的应用切换到其他应用时，你的应用将不再可见，但仍保持 Running 状态，直到 Windows 可以挂起它为止。如果用户离开你的应用，但在挂起它之前又激活或返回到该应用，它会保持 Running 状态。当应用可见性更改时，你的应用不会收到激活事件，因为它仍在运行中。Windows 只需根据需要来回切换应用即可。如果你的应用需要在用户离开和返回时执行某些操作，则可以处理 visibilitychange 事件 (HTML) 或 Window.VisibilityChanged 事件 (XAML)。可见性事件不按挂起/恢复或激活事件排序。不要假定这些事件按特定的顺序传入。应用恢复挂起的应用在用户切换到该应用或设备从电量不足状态恢复时恢复。有关应用在恢复时所处状态的枚举，请参阅 ApplicationExecutionState。应用从 Suspended 状态恢复时，它会进入 Running 状态并从挂起的位置和时间处继续运行。 不会丢失任何应用数据，但前提是数据是保存在内存中的。因此，大多数应用在恢复时不需要执行任何操作。但是，应用可能挂起数小时甚至数天。因此，如果应用拥有可能已过时的内容或网络连接，这些内容或网络连接应该在应用恢复时刷新。如果应用已经为 WebUIApplication.resuming 事件 (HTML) 或 Application.Resuming 事件 (XAML) 注册一个事件处理程序，则在应用从 Suspended 状态恢复时调用它。你可以使用该事件处理程序刷新应用内容和数据。注意  具体而言，HTML 应用通常不需要专门处理 resuming，因为 activated 将在相同的情况下触发。你可以使用 activated 事件数据中的 ActivationKind 信息来确定是否恢复应用；此模式在起始项目模板的 default.js 文件中显示。如果挂起的应用被激活以加入一个应用合约或扩展，它会首先收到 Resuming 事件，然后收到 Activated 事件。当应用挂起时，它不会收到它注册接收的网络事件。这些事件没有排队，所以它们会丢失。因此，你的应用应该在恢复时测试网络状态。有关指南，请参阅应用挂起和恢复指南。有关示例代码，请参阅“如何恢复应用”（HTML 或 XAML）。注意  在 Windows Phone 应用商店应用的 XAML 应用中，每次用户从“开始”磁贴或应用列表启动应用时都会调用 OnLaunched，即便该应用当前在内存中已挂起也是如此。在 Windows 上，从“开始”磁贴或应用列表启动挂起的应用不会调用此方法。应用关闭通常，用户不需要关闭应用，他们可以让 Windows 管理它们。但是，用户可以选择以下方法来关闭应用：使用关闭手势，在 Windows 上按 Alt+F4，或在 Windows Phone 上使用任务切换器。你不能在应用中包括任何 UI 以让用户关闭应用，否则该应用不会通过应用商店的认证过程。没有任何特殊事件指示用户已关闭应用。在用户关闭应用之后，它将被挂起并终止，然后进入 NotRunning 状态。在 Windows 8.1 以及更高版本中，在用户关闭应用之后，该应用将从屏幕中移除并切换列表，但并未显式终止。注意  如果你的应用依赖于 Windows 8 的用户关闭行为，则在将系统升级到 Windows 8.1 时可在此应用中启用此行为。若要启用 Windows 8 的用户关闭行为，请使用 ApplicationView.TerminateAppOnFinalViewClose 属性将你的 Windows 8.1 应用设置为在最后一个窗口关闭后终止。如果应用已经为 Suspending 事件注册了一个事件处理程序，当应用被挂起时则会调用该处理程序。你可以使用此事件处理程序将相关应用程序和用户数据保存到持久性存储中。用户关闭行为:  建议你决定当用户关闭应用后再激活应用时，应用具有的行为。应用被 Windows 终止或被用户终止可能没有任何区别。如果应用在被用户关闭时需要执行与被 Windows 关闭时不同的操作，你可以使用激活事件处理程序确定应用是被用户终止的还是被 Windows 终止的。请参阅 ApplicationExecutionState 枚举参考中 ClosedByUser 和 Terminated 状态的说明。如果你要维护一个 Windows 8 应用，请注意处理 ClosedByUser 的方式可能与 Windows 8.1 应用所使用的方式不同。我们建议，应用不要以编程方式自行关闭，除非绝对必要。例如，如果应用检测到内存泄漏，它可以关闭自己来确保用户个人数据的安全。当你以编程方式关闭应用时，系统会将此视为应用崩溃。应用故障应用需要遵守系统故障体验，只需返回到“开始”屏幕。系统故障体验旨在让用户尽快返回执行的操作，因此不应提供警告对话框或其他通知，因为这会拖延用户的时间。应用消失应清楚地告诉用户出现了问题。如果你的应用出现故障、停止响应或者发生意外，Windows 将请求用户同意向 Microsoft 发送问题报告。Microsoft 在问题报告中向你提供错误数据的一个子集，这样你可以使用这些数据改进你的应用。你可以在“仪表板”中应用的“质量”页面中看到此数据。当用户在应用出现故障之后激活该应用时，其激活事件处理程序将收到 NotRunning 的 ApplicationExecutionState 值，并且将显示其初始 UI 和数据。崩溃后，请勿经常使用原本将用于 Resuming 和 Suspended 的应用数据，因为该数据可能已损坏；请参阅应用挂起和恢复指南。应用删除当用户删除你的应用时，会一同删除应用及其所有本地数据。删除应用不会影响存储在公用位置的用户数据，例如文档或图片库中的文件。应用生命周期和 Visual Studio 项目模板对于 HTML 或 XAML 应用，在起始 Visual Studio 项目模板中提供了与应用生命周期相关的基本代码。基本代码可处理启动激活，甚至可以在添加任何你自己的代码之前显示其主要 UI。应用程序生命周期中的关键 APIWindows.ApplicationModel 命名空间Windows.ApplicationModel.Activation 命名空间Windows.ApplicationModel.Core 命名空间Windows.UI.WebUI 命名空间 (HTML)Windows.UI.Xaml.Application 类 (XAML)Windows.UI.Xaml.Window 类 (XAML)WinJS.Application 命名空间 (HTML)

版权声明：本文为博主原创文章，未经博主允许不得转载。

swift详解之十二-----------------泛型
泛型
注：本文详细讲解泛型，对写一些公共方法，共用的东西的时候很有帮助。想成为一个优秀的程序员吗？这个必须掌握

泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活可重用的函数和类型。
下面直接看一个简单的示例 ， 泛型其实就是在写的时候不指定是哪种类型 ， 只有再用得时候才指定类型 ，这些类型可以给一些限定。例如 Array Dictionary 等 
写一个简单的交换数据的方法，不限定类型
func swapTwoValue<T>(inout a:T,inout _ b:T){
    let temp:T = a
    a = b
    b = temp
}
这里用T代表一种类型 ，但是没有指定 ， 在函数参数和函数体中都可以使用 
var a = 10 , b = 20
swapTwoValue(&a, &b)
print("\(a) , \(b)")//20 , 10

var c = "hello" ,d = "world"
swapTwoValue(&c, &d)
print("\(c) , \(d)") //world , hello
可以看到用Int 和 String 类型都可以使用此方法 
T只代表一种类型 如果传入两种类型就会报错 
var s1 = "hello"
var s2 = 10
swapTwoValue(&s1, &s2)// cannot invoke 'swapTwoValue' with an argument list of type '(inout String, inout Int)'
当然你也可以指定两种类型
func dic<k,v>(a:k,_ b:v){

}
我们这里模拟实现一个栈的操作。栈的特点是后进先出 
struct IntStack{
    var items = [Int]()

    mutating func push(item:Int){
        items.append(item)
    }

    mutating func pop(){
        items.removeLast()
    }
}
var intStack = IntStack();
intStack.push(1);
print(intStack.items) //[1]
这是一个Int类型的 ，我们看下泛型的 
struct Stack<T>{
    var items = [T]()

    mutating func push(item:T){
        items.append(item)
    }

    mutating func pop()->T{
           return items.removeLast()
    }

    subscript(i:Int)->T{
        get{
            return items[i]
        }
        set{
            items[i]=newValue
        }
    }
}


var stack = Stack<String>();

stack.push("hello")
stack.push("ww")
print(stack[0]) //hello
stack[1] = "world"
print(stack) //Stack<Swift.String>(items: ["hello", "world"]
这里只实现了基本的pop 和push功能 
我们也可以扩展我们的泛型 ，而且不需要提供参数类型
extension Stack{
    var topItem:T?{
        return items.isEmpty ? nil:items[items.count-1]
    }
}
var s1 = Stack<Int>();
s1.push(20)
s1.push(19)
print(s1.topItem) //Optional(19)
我们也可以对泛型进行约束 
protocol A{}
func func1<T:A>(t:T){

}
这里这个泛型类型必须为协议A的遵循者 ， 这里也可以写某个类 代表类的继承者 
不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。 
不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个Equatable协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持Equatable协议。
func findIndex<T: Equatable>(array: [T], valueToFind: T) -> Int? {
    for (index, value) in  array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
let strs = ["sss","aaa","ddd"];
print(findIndex(strs, valueToFind: "ddd"))  //2
关联类型  
当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名(或别名)。作用于关联类型上实际类型是不需要指定的，直到该协议接受。关联类型被指定为typealias关键字。
protocol Container{
    //声明一个类型 不指定是什么类型
    typealias itemType
    mutating func append(item:itemType)
    subscript(i:Int)->itemType{ get }
}
这里定义一个协议 ， 声明一个类型 不指定是什么类型 ， 然后有个append有一个itemType类型的参数 ， 还有个下标脚本，就是数组的基本操作 
struct Quene<T>:Container{

    var items = [T]()

    //可以推断出是T

    mutating func append(item:T)
    {
        items.append(item)
    }

     subscript(i:Int)->T{
           return items[i]
     }
}
这里可以智能推断是typealias itemType 就是这里的泛型T
非常简单 ，使用就不再赘述 
我们也可以使用where字句来约束泛型 ，放在泛型参数后面即可 。
//可以通过where语句来定义约束
func compare<c1:Container,c2:Container
    where c1.itemType == c2.itemType,c1.itemType:Equatable>(a:c1 , _ b:c2){

    //这里就可以为所欲为了

}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Design Support Library概览
尊重劳动成果，转载请注明出处：http://blog.csdn.net/growth58/article/details/47972467 
关注新浪微博：@于卫国 
邮箱：yuweiguocn@gmail.com
简介
在Google I/O 2015大会中，Google为Android开发者介绍了Design Support Library。这个library可以让开发者很容易地实现更多Material Design概念到他们的应用中，因为很多关键元素是不可用的在原来的框架外。首先就是很易于使用，Design Support Library向下兼容到API 7。Design Support Library可以引入到你的Android工程中通过导入Gradle依赖。
compile 'com.android.support:design:22.2.0'
视觉组件 
在Design支持库中有两个主要类别的工具：

视觉组件
动作组件

我们先看看有哪些新的视觉组件可以应用到你的App上。
Material Text Input
EditText自从最开始就已经在Android中了，并且使用很简单，他们一直没有什么改变。使用Design Support Library，Google已经介绍了新的包含容器叫作TextInputLayout。这个新的view添加功能到标准的EditText上，例如支持让你的用户界面弹出错误消息和动画提示。
正如下面的代码所示，TextInputLayout 可以包含在你的布局文件中包裹一个标准的EditText。
<android.support.design.widget.TextInputLayout
    android:id="@+id/textinput"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <EditText
        android:id="@+id/edittext"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="What is your name?" />

</android.support.design.widget.TextInputLayout>
Gianluca Segato 会带着你学习TextInputLayout 组件的使用在教程中。
Floating Action Buttons
在Material Design 应用中最占优势的用户界面组件之一就是Floating Action Buttons。自从他们的介绍后，开发者不得不从头开始创建这些按钮或者是从很多第三方设计的类库特别是这些按钮相关的选择一个。
使用Design 支持库，floating action buttons可以包含在一个布局中并且挂靠在屏幕的一部分用简单几行代码。每个按钮都可以用icons和colors很容易地进行自定义。可以使用两个sizes ，standard (56dp) 和 mini (40dp)。最大的优势之一是Google已经支持这些按钮作为他们的设计演变。
<android.support.design.widget.FloatingActionButton
    android:id="@+id/fab"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="end|bottom"
    android:layout_margin="16dp"
    android:src="@drawable/ic_fab" />
导航组件
当ViewPager 和DrawerLayout 组件通过v4 support library可用时，Google已经对其进行了扩展通过提供两个新的相关的部件。第一个是官方版本常用的ViewPagerIndicator library由Jake Wharton开发称为TabLayout。第二个是NavigationView，提供drawer header的支持。
TabLayout
TabLayout组件可以用代码使用addTab方法手动添加内容。看看下面的例子。
tabLayout.addTab(tabLayout.newTab().setText("Tab 1"));
tabLayout.addTab(tabLayout.newTab().setText("Tab 2"));
tabLayout.addTab(tabLayout.newTab().setText("Tab 3"));
另外，你可以将TabLayout和ViewPager组件进行关联。通过调用setupWithViewPager()可以完成，使用ViewPager作为参数。这是另一种方式切换ViewPager的页面。应该注意的是getPageTitle()需要被重写当使用TabLayout和ViewPager时给每个Tab一个合适的名称。

NavigationView
NavigationView是一个新的部件继承了DrawerLayout的功能。开发者使用这个组件能很容易地添加头布局到drawer 和标记已选择的部分。
除此之外，它现在可以通过菜单资源文件非常简单地创建sections和subsections在drawer 中。一个NavigationView需要和一个DrawerLayout进行关联在XML文件中。
<android.support.v4.widget.DrawerLayout      xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_height="match_parent"
    android:layout_width="match_parent"
    android:fitsSystemWindows="true">

    <include layout="@layout/content"/>

    <android.support.design.widget.NavigationView
        android:id="@+id/nav_view"
        android:layout_height="match_parent"
        android:layout_width="wrap_content"
        android:layout_gravity="start"
        android:fitsSystemWindows="true"
        app:headerLayout="@layout/nav_header"
        app:menu="@menu/drawer_view"/>

</android.support.v4.widget.DrawerLayout>

增强的Toasts
Toast消息成为Android中主要的功能已经多年，一个新的用户界面部件叫作Snackbar可用于提供相似功能但改善了外观。Snackbar 不仅能给用户提示短时间的信息，它还支持一个动作添加到上下文中基于你的应用的功能并且可以使用手势滑掉使其消失。
Snackbar 比Toast功能有所增强，使用它需要注意的是需要创建一个可以被用来找到应用显示的最底部的View。
Snackbar.make( view, "Action", Snackbar.LENGTH_LONG )
    .setAction("Action!", new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Log.e("App", "Action!");
        }
    } )
    .show();

动作组件
一个用户界面特效和动画在Material Design中是非常重要的。为了促进这个，Googlen已经发布了多个常见用例的组件在Design支持库中。Kerry Perez-Huanca将会在教程中带着大家学习Design支持库中的这方面的组件。
Reactive Views
你可能已经注意到了在之前例子中的FloatingActionButton会在Snackbar出现的时候向上移动。这是用一个新的部件叫作CoordinatorLayout完成的，用它包裹的view应该给其它view留出空间。
改善Quick Return and Toolbars
很多开发者询问用最简单的方式显示一个视差图片作用于快速返回设计模式，随着用户上下滑动而出现或消失。你可以在Play Store的应用列表看到这个效果。为了让开发者实现这个功能不用写大量冗余代码，Google发布了CollapsingToolBarLayout 和AppBarLayout views。在这些部件里使用不同的选项，开发者能固定views在屏幕的顶部或特定的位置当这些views应该随着用户滑动显示时。

总结
Design 支持库带来了大量期待已久的工具在Android上。当它和AppCompat 库配合使用时，它变得很容易地添加Material Design到应用上并且保持向下兼容。
可以在Google官方相关的应用上找到这些新组件是怎样工作的很多例子，CheeseSquare，Tuts+将会继续提供深入教程在怎样实现这些新特征上。
请我喝杯咖啡，请使用支付宝扫描下方二维码： 

原文地址：http://code.tutsplus.com/articles/overview-of-the-android-design-support-library–cms-24234

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
解析程序员的几个成长阶段

软件开发这个行业往往是供不应求，这跟开发人员的素质有很大的关系，在这个浮躁的圈子里，能在一家公司呆上三年以上的程序员，通常就会把持领导岗位，结果做出来的东西大多非常糟糕。这也说明了，程序员的能力不能完全靠工作年限来划分。怎么样才可以成为一名合格的高级程序员？今天为大家解析程序员的几个成长阶段。

初级程序员
初级开发人员是这样的，刚从学校出来，就像坐井观天中的青蛙一样，自认为什么都会。突然间，你发现自己面对的问题，靠学校中的那点知识是远远不够的。问题要更复杂，更凌乱，没有理论上说的那么纯粹。你正处于放弃还是坚持的分叉路口，你不知道该怎么办。
对策就是专心致志，专心致志地竭尽全力学习。初级开发人员需要大量的指导、监督和辅导，否则他们将会在这一阶段呆上很长一段时间。因此，实际上你也可以将这一阶段视为策略和日常技术的吸收消化时期。
初级开发人员关注代码，而不注重开发，他们不明白两者之间的区别。如果一个程序员表示“要是代码不需要面向所有用户，那他们会更喜欢编码”，那么我可以判断这是一个初级开发人员。
一个优秀的初级开发人员给定一个已知任务之后，就能够迅速良好地执行。
中级开发人员逐渐能够意识到失败(通常是他们自己的失败)模式，并认识到比起实际构建匆匆忙忙去做重点任务其实所需要的时间和精力更多，并且也不会因为有人说要改一改而一下子垂头丧气。他们也经历过自以为写出了引以为豪的内容，实际上证明是垃圾的悲惨遭遇。

中级程序员
中级开发人员寻寻觅觅于用正确的方法去构建，去解决问题，他们会通过实验、文献和与其他程序员的讨论去发现这些正确的方法。这实际上已经是学习软件架构的水准，而不再是构建代码(我们在学校里学的就是这个)水平。
没有受到监督的中级开发人员构建的系统之所以失败的原因和初级开发人员的失败原因截然不同。初级开发人员会构建一堆稍微有点用的算法。而优秀的中级开发人员会跳出《Design Patterns》和《Domain DrivenDesign》的禁锢。虽然这些都是学习构建大型OO系统的好书，但是直接应用理论只会导致死板的设计结果，不重要的地方灵活多变，重要的地方却又死板无法更改。
你可以信任中级开发人员构建的系统，他们的系统毫无疑问比初级开发人员做的要好，但是时间久了，依然会有各种问题出现，成为拦路虎。一个可悲的事实是，绝大多数高级开发人员，甚至团队领导者其实都还只是——中级开发人员。当然，大多数人都没有这样的自我觉悟，原因是他们根本没有和更高水平的人一起工作过。
一个优秀的中级开发人员应该懂得使用代码来解决问题只是一种手段而不是目的。然而，他们仍然深爱着纯粹的设计，仍然渴望寻求所谓“正确的方式”来构建软件。
优秀的中级开发人员依然需要少量的监管。毫无疑问，他们能够提升代码设计，并在设计讨论中发挥重要作用。他们是开发团队中的主力。但是，对于他们，进一步的指导和更高层次的监管依然至关重要。

高级程序员
高级开发人员熟悉失败。他们已经经历过编写的代码在低于设计和超越设计的情况下都失败的情况。他们深思熟虑，在面对问题时，能够心智成熟地评估成功与失败。高级开发人员已经跳出了中级开发人员深爱的复杂性，开始沉迷于简单。
高级开发人员悉知自己的长处和短处，力争尽可能地扬长避短。
高级开发人员深知理论联系实际的重要。他们明白，世上没有所谓的构建软件的“正确方式”，建立良好软件的唯一途径是要将理论适应客户、代码库、团队、工具和组织的需求。
高级开发人员理解并权衡领域涉及的一切，同时会思考如何去支持设计模式、库、框架和流程。
高级开发人员不仅仅了解自我，还知晓组织和客户的工作方式和价值观，以及对于组织和客户而言成功相关的重要和不重要的因素。一旦出现问题，高级开发人员会想方设法地去解决。“这不是我的工作”——他们永远，永远也不会说这样的话语。
高级开发人员心里明白，他们的工作应该是提供解决问题的办法，而不是写代码。
不像中级开发人员辛苦耕耘于枯燥的日常工作，高级开发人员会退一步，去思考是什么导致了这些无聊的工作。他们会评估修复根本问题的成本，要么直接解决这些问题，要么研究起来以便于最终彻底解决。
高级开发人员明白，单枪匹马是搞不定项目的。他们的主要作用是帮助团队变得更好，同时争取个人共同进步。
高级开发人员深刻理解，领导一职代表的不是权力，而是授权，不是方向，而是服务。
如果你的团队中一个高级开发人员都没有起到领导作用，那么你的项目是注定要失败的。一队伟大的中级开发人员固然能让你走得很远，但是他们构建的软件的好日子却是屈指可数的，其最终结果要么是关门大吉，要么是高风险高成本的重写。高级开发人员才是唯一能胜任选择技术和平台的人。
简单粗暴的分类方法
我非常讨厌现在流行的根据工作经验年限来给程序员划分档次的方法。多年的经验的确能让你增加见识，但这都是一些几乎毫无意义的背景信息。
更重要的是，我们的行业需要刚从大学毕业活力四射的年轻人，也需要那些有着15—20年工作经验的老程序员。我们应该从团队和企业的角度来思考人才组成。
推荐阅读：
程序员的三大发展方向

20年资深程序员编程经验分享


版权声明：本文为博主原创文章，未经博主允许不得转载。

anroid OpenGL ES之 向shader传递数据
android OpenGL ES开发之前世今生 
android OpenGL ES开发之shader 
anroid OpenGL ES之 向shader传递数据
void glUseProgram( int program );
glUseProgram()真正载入着色器程序到我们的程序中在这之后我们就可以向shader中传递数据了
int glGetAttribLocation( int program, String name );
向shader中的Attribute变量或者Uniform变量传递数据，首先要知道其在内存中的位置。glGetAttribLocation()得到属性的位置。program参数是程序的句柄，name参数是shader程序中变量的名称
void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, int offset)
glVertexAttribPointer可以向Attribute变量传递数据。参数index是变量位置参数size， 1 for float; 2 for vec2; 3 for vec3参数type，可选 GLES20.GL_FLOAT GLES20.GL_INT参数normalized，为true，则把数据按比例缩小到-1~1
int glGetUniformLocation( int program, String name );
glGetUniformLocation获得Uniform变量在内存中的位置
void glUniform1f( int location, float x );
glUniform1f向Uniform变量传递数据

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift下拉菜单动画实现
学iOS开发时间也不短了，但对CoreGraphics自定义动画这块一直都不算太熟练，一是因为默认动画可以在一定程度上满足需求，二也是因为自定义动画这块的第三方库相当多，我也一直没有重复造轮子，但前几天在AppCoda上看到一篇关于自定义动画Demo的文章，觉得还不错，认真研读一下也当弥补自己知识面的漏洞了


先上效果图








文件目录图如下








NewsTableView是效果图中下方的内容展示页面，MenuTableView是上方黑色的Menu列表，MenuTransitionManger就是这篇文章的重点--菜单动画控制类

首先我们来看一下这个类的的接口部分



<pre name="code" class="plain">    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        let menuTableViewController = segue.destinationViewController as! MenuTableViewController
        menuTableViewController.currentItem = self.title!
        menuTableViewController.transitioningDelegate = self.menuTransitionManager
        self.menuTransitionManager.delegate = self
    }


这个prepareForSegue函数位于NewsTableViewController中，menuTransitionManager是控制类在当前类的实例，在该函数中，我们通过segue获取了动画的目的视图控制器，也就是menuTableViewController，然后将他的过渡动画代理设置成了我们实例化的控制类，最后一行代码是为了实现点击空白处dismiss掉弹出菜单，这个最后再讲



class MenuTransitionManager: NSObject, UIViewControllerAnimatedTransitioning, UIViewControllerTransitioningDelegate {
   
    var duration = 0.5
    var isPresenting = false
   
    var snapshot:UIView? {
        didSet {
            if let _delegate = delegate {
                let tapGestureRecognizer = UITapGestureRecognizer(target: _delegate, action: "dismiss")
                snapshot?.addGestureRecognizer(tapGestureRecognizer)
            }
        }
    }
   
    var delegate:MenuTransitionManagerDelegate?
   
    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -> NSTimeInterval {
        return duration
    }
   
    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
       
        //得到源视图和目的视图的引用
        let fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)!
        let toView = transitionContext.viewForKey(UITransitionContextToViewKey)!
       
        //设置变换过程
        let container = transitionContext.containerView()
        let moveDown = CGAffineTransformMakeTranslation(0, container!.frame.height - 150)
        print("container!.frame.height - 150 \(container!.frame.height - 150)")
        let moveUp = CGAffineTransformMakeTranslation(0, -50)
       
        //将两个视图添加到容器视图中
        if isPresenting {
            toView.transform = moveUp
            snapshot = fromView.snapshotViewAfterScreenUpdates(true)
            print("toView.frame: \(toView.frame)")
            print("fromView.frame: \(fromView.frame)")
            print("snapshot.frame: \(snapshot!.frame)")
            container?.addSubview(toView)
            container?.addSubview(snapshot!)
        }
       
        //展示动画
        UIView.animateWithDuration(duration, delay: 0.0, usingSpringWithDamping: 0.9, initialSpringVelocity: 0.3, options: [], animations: {
           
            if self.isPresenting {
                self.snapshot?.transform = moveDown
                toView.transform = CGAffineTransformIdentity
            } else {
                self.snapshot?.transform = CGAffineTransformIdentity
                fromView.transform = moveUp
            }
           
           
            }, completion: { finished in
               
                transitionContext.completeTransition(true)
                if !self.isPresenting {
                    self.snapshot?.removeFromSuperview()
                }
        })
    }
   
    func animationControllerForDismissedController(dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        isPresenting = false
        return self
    }
   
    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
       
        isPresenting = true
        return self
    }
   
}
这是菜单动画控制类的具体代码实现，要做ViewController的过渡动画代理首先必须遵守UIViewControllerTransitioningDelegate，而UIViewControllerAnimatedTransitioning协议用于提供具体的动画动作


最后的两个函数用于在弹出和收回菜单时改变isPresenting标志的真假以展示正确的弹出或收回动画


animateTransition函数是真正的动画执行函数，首先调用当前transitionContext的viewForKey函数来获得源视图和目的视图的引用，在当前的项目里也就分别是NewsTableView和MenuTableView，MoveDown动画用于在弹出菜单时下方的NewsTableView的snapshot，也就是覆盖在原NewsTableView上的截图为弹出的MenuTableView让出150的y轴空间，MoveUp动画用在了两个地方，一个是弹出时MenuView先向上50再向下展示，有种bounce的效果，第二个是NewsTableView在snapshot恢复原位置时向上移动50，说实话我没看懂这里，因为执行到这里的时候在最上层展示的是MenuTableView和snapshot，修改NewsTableView的动画效果大概没什么用，我把这句注释掉和把y轴位移由-50改为-5000都没发现什么变化，如果我理解错了请告诉我..


snapshotViewAfterScreenUpdates是iOS7提供的API，用于快速简单的创建一张某个View的截图，常用于页面转换动画


后面的UIView.animateWithDuration是动画的具体执行过程，CGAffineTransformIdentity是View动画执行前的位置，如果弹出，截图y轴向下移动150，MenuTableView放置到原位置，也就是这个View在自己ViewController的位置，如果收回，截图回到原位置


最后我来说一下这段为实现点击空白处返回的代码


    var snapshot:UIView? {
        didSet {
            if let _delegate = delegate {
                let tapGestureRecognizer = UITapGestureRecognizer(target: _delegate, action: "dismiss")
                snapshot?.addGestureRecognizer(tapGestureRecognizer)
            }
        }
    }
这是Swift语法里的Property observer，当snapshot被赋值时，我们为其添加点击事件，这个点击事件由delegate的dismiss函数执行，这是经典的delegate设计模式了，NewsTableViewController作为代理的执行者，执行dismiss函数



    func dismiss() {
        dismissViewControllerAnimated(true, completion: nil)
    }


然后又触发了那个isPresenting = false的函数，随之引发收回菜单的动画效果


整个工程可在原链接中下载到：http://www.appcoda.com/slide-down-menu-swift/
可能需要科学上网 :) 觉得我讲的清楚的可以点个赞 (ﾉ ○ Д ○)ﾉ　





版权声明：本文为博主原创文章，未经博主允许不得转载。

android 自定义Button,满足你对Button呈现样式的一系列要求
转载请注明出处：王亟亟的大牛之路
我们平时自定义的一些Button通常是改改颜色啊，文本啊，圆角啊之类的。如果要做到再高级点就需要用一个大布局还拼接了，如果一个页面有很多样式不同的这样的按钮，还真不怎么好操作。 
今天给大家上一个FancyButton能很好的帮助我们简化这些操作 
项目结构： 

只有一个类外加一些assets包下的字体文件或资源文件的一些Icon就能呈现以下效果：
 
首先先介绍下FancyButton这个类的一些重要的方法和实现：
继承LinearLayout根据我们的实际场景需要再判断为水平还是垂直的LinearLayout
public class FancyButton extends LinearLayout
一系列的初始化操作和参数申明
 private Context mContext;

    // 初始化背景参数
    private int mDefaultBackgroundColor         = Color.BLACK;
    private int mFocusBackgroundColor           = 0;

    //初始化字体参数
    private int mDefaultTextColor               = Color.WHITE;
    private int mDefaultIconColor               = Color.WHITE;
    private int mTextPosition                   = 1;
    private int mDefaultTextSize                = 15;
    private int mDefaultTextGravity             = 0x11; // Gravity.CENTER
    private String mText                        = null;

    // 初始化Icon参数
    private Drawable mIconResource              = null;
    private int  mFontIconSize                  = 15;
    private String mFontIcon                    = null;
    private int mIconPosition                   = 1;

    private int mIconPaddingLeft                = 10;
    private int mIconPaddingRight               = 10;
    private int mIconPaddingTop                 = 0;
    private int mIconPaddingBottom              = 0;


    private int mBorderColor                    = Color.TRANSPARENT;
    private int mBorderWidth                    = 0;

    private int mRadius                         = 0;

    private Typeface mTextTypeFace = null;
    private Typeface mIconTypeFace = null;


    /**
     * 标识图标位置的标记
     */
    public static final int POSITION_LEFT       = 1;
    public static final int POSITION_RIGHT      = 2;
    public static final int POSITION_TOP        = 3;
    public static final int POSITION_BOTTOM     = 4;
    //默认字体
    private String mDefaultIconFont = "fontawesome.ttf";
    private String mDefaultTextFont = "robotoregular.ttf";

    private ImageView mIconView;
    private TextView mFontIconView;
    private TextView mTextView;

构造函数
 /**
     * 默认构造函数
     * @param context : Context
     */
    public FancyButton(Context context){
        super(context);
        this.mContext   = context;

        mTextTypeFace   = Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", mDefaultTextFont));
        mIconTypeFace   = Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", mDefaultIconFont));

        initializeFancyButton();
    }

    /**
     * 默认构造函数调用布局
     * @param context : Context
     * @param attrs : Attributes Array
     */
    public FancyButton(Context context, AttributeSet attrs){
        super(context,attrs);
        this.mContext = context;

        TypedArray attrsArray   = context.obtainStyledAttributes(attrs,R.styleable.FancyButtonsAttrs, 0, 0);
        initAttributsArray(attrsArray);
        attrsArray.recycle();

        initializeFancyButton();

    }
对一些控件所需的素材进行初始化操作
 /**
     * 各种初始化
     */
    private void initializeFancyButton(){

        initializeButtonContainer();

        mTextView       = setupTextView();
        mIconView       = setupIconView();
        mFontIconView   = setupFontIconView();

        int iconIndex,textIndex;
        View view1,view2;

        if(mIconView == null && mFontIconView == null && mTextView == null){
            Button tempTextView = new Button(mContext);
            tempTextView.setText("Fancy Button");
            this.addView(tempTextView);

        }else{
            this.removeAllViews();
            setupBackground();

            ArrayList<View> views = new ArrayList<>();

            if(mIconPosition == POSITION_LEFT || mIconPosition == POSITION_TOP){

                if(mIconView != null){
                    views.add(mIconView);
                }

                if(mFontIconView != null){
                    views.add(mFontIconView);
                }
                if(mTextView != null){
                    views.add(mTextView);
                }

            }else{
                if(mTextView != null){
                    views.add(mTextView);
                }

                if(mIconView != null){
                    views.add(mIconView);
                }

                if(mFontIconView != null){
                    views.add(mFontIconView);
                }

            }

            for(View view : views){
                this.addView(view);
            }
        }
    }
 /**
     * 设置文本视图
     * @return : TextView
     */
    private TextView setupTextView(){
        if (mText != null) {
            TextView textView = new TextView(mContext);
            textView.setText(mText);
            textView.setGravity(mDefaultTextGravity);
            textView.setTextColor(mDefaultTextColor);
            textView.setTextSize(mDefaultTextSize);

            textView.setLayoutParams(new TableLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT, 1f));
            if (!isInEditMode() && mTextTypeFace!=null) {
                textView.setTypeface(mTextTypeFace);
            }
            return textView;
        }
        return null;
    }

    /**
     * 设置字体图标视图
     * @return : TextView
     */
    private TextView setupFontIconView(){

        if(mFontIcon!=null){
            TextView fontIconView = new TextView(mContext);
            fontIconView.setTextColor(mDefaultIconColor);

            LayoutParams iconTextViewParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT,1f);
            iconTextViewParams.rightMargin = mIconPaddingRight;
            iconTextViewParams.leftMargin = mIconPaddingLeft;
            iconTextViewParams.topMargin = mIconPaddingTop;
            iconTextViewParams.bottomMargin = mIconPaddingBottom;

            if(mTextView != null){

                if(mIconPosition==POSITION_TOP || mIconPosition==POSITION_BOTTOM){
                    iconTextViewParams.gravity = Gravity.CENTER;
                    fontIconView.setGravity(Gravity.CENTER);
                }
                else{
                    fontIconView.setGravity(Gravity.CENTER_VERTICAL);
                    iconTextViewParams.gravity = Gravity.CENTER_VERTICAL;
                }
            }else{
                iconTextViewParams.gravity = Gravity.CENTER;
                fontIconView.setGravity(Gravity.CENTER_VERTICAL);
            }


            fontIconView.setLayoutParams(iconTextViewParams);
            if(!isInEditMode()){
                fontIconView.setTextSize(mFontIconSize);
                fontIconView.setText(mFontIcon);
                fontIconView.setTypeface(mIconTypeFace);
            }else{
                fontIconView.setText("O");
            }
            return fontIconView;
        }
        return null;
    }

    /**
     * 文本图标资源视图
     * @return : ImageView
     */
    private ImageView setupIconView(){
        if (mIconResource != null){
            ImageView iconView = new ImageView(mContext);
            iconView.setImageDrawable(mIconResource);
            iconView.setPadding(mIconPaddingLeft, mIconPaddingTop, mIconPaddingRight, mIconPaddingBottom);

            LayoutParams iconViewParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            if(mTextView!=null){
                if(mIconPosition==POSITION_TOP || mIconPosition==POSITION_BOTTOM)
                    iconViewParams.gravity = Gravity.CENTER;
                else
                    iconViewParams.gravity = Gravity.START;

                iconViewParams.rightMargin = 10;
                iconViewParams.leftMargin = 10;
            }else{
                iconViewParams.gravity = Gravity.CENTER_VERTICAL;
            }
            iconView.setLayoutParams(iconViewParams);

            return iconView;
        }
        return null;
    }

    /**
     * 初始化属性数组
     * @param attrsArray : Attributes array
     */
    private void initAttributsArray(TypedArray attrsArray){

        mDefaultBackgroundColor         = attrsArray.getColor(R.styleable.FancyButtonsAttrs_defaultColor,mDefaultBackgroundColor);
        mFocusBackgroundColor           = attrsArray.getColor(R.styleable.FancyButtonsAttrs_focusColor,mFocusBackgroundColor);

        mDefaultTextColor               = attrsArray.getColor(R.styleable.FancyButtonsAttrs_textColor,mDefaultTextColor);
        // if default color is set then the icon's color is the same (the default for icon's color)
        mDefaultIconColor               = attrsArray.getColor(R.styleable.FancyButtonsAttrs_iconColor,mDefaultTextColor);
        mDefaultTextSize                = (int) attrsArray.getDimension(R.styleable.FancyButtonsAttrs_textSize,mDefaultTextSize);
        mDefaultTextGravity             = attrsArray.getInt(R.styleable.FancyButtonsAttrs_textGravity, mDefaultTextGravity);

        mBorderColor                    = attrsArray.getColor(R.styleable.FancyButtonsAttrs_borderColor,mBorderColor);
        mBorderWidth                    = (int) attrsArray.getDimension(R.styleable.FancyButtonsAttrs_borderWidth,mBorderWidth);

        mRadius                         = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_radius,mRadius);
        mFontIconSize                   = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_fontIconSize,mFontIconSize);

        mIconPaddingLeft                = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_iconPaddingLeft,mIconPaddingLeft);
        mIconPaddingRight               = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_iconPaddingRight,mIconPaddingRight);
        mIconPaddingTop                 = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_iconPaddingTop,mIconPaddingTop);
        mIconPaddingBottom              = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_iconPaddingBottom,mIconPaddingBottom);

        String text                     = attrsArray.getString(R.styleable.FancyButtonsAttrs_text);
        mIconPosition                   = attrsArray.getInt(R.styleable.FancyButtonsAttrs_iconPosition,mIconPosition);

        String fontIcon                 = attrsArray.getString(R.styleable.FancyButtonsAttrs_fontIconResource);

        String iconFontFamily           = attrsArray.getString(R.styleable.FancyButtonsAttrs_iconFont);
        String textFontFamily           = attrsArray.getString(R.styleable.FancyButtonsAttrs_textFont);

        Drawable icon = null;
        try{
            mIconResource               = attrsArray.getDrawable(R.styleable.FancyButtonsAttrs_iconResource);

        }catch(Exception e){
            mIconResource = null;
        }

        if(fontIcon!=null)
            mFontIcon = fontIcon;

        if(text!=null)
            mText = text;

        if(!isInEditMode()){
            if(iconFontFamily!=null){
                try{
                    mIconTypeFace = Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", iconFontFamily));
                }catch(Exception e){
                    Log.e("Fancy", e.getMessage());
                    mIconTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", mDefaultIconFont));
                }

            }else{
                mIconTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", mDefaultIconFont));
            }

            if(textFontFamily!=null){
                try{
                    mTextTypeFace = Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", textFontFamily));
                }
                catch(Exception e){
                    mTextTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", mDefaultTextFont));
                }

            }else{
                mTextTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", mDefaultTextFont));
            }


        }



    }
    @SuppressLint("NewApi")
    private void setupBackground(){

        // 默认Drawable
        GradientDrawable drawable = new GradientDrawable();
        drawable.setCornerRadius(mRadius);
        drawable.setColor(mDefaultBackgroundColor);
        if (mBorderColor != 0) {
            drawable.setStroke(mBorderWidth, mBorderColor);
        }

        // 焦点/按下 Drawable
        GradientDrawable drawable2 = new GradientDrawable();
        drawable2.setCornerRadius(mRadius);
        drawable2.setColor(mFocusBackgroundColor);
        if (mBorderColor != 0) {
            drawable2.setStroke(mBorderWidth, mBorderColor);
        }

        StateListDrawable states = new StateListDrawable();

        if(mFocusBackgroundColor!=0){
            states.addState(new int[] { android.R.attr.state_pressed }, drawable2);
            states.addState(new int[] { android.R.attr.state_focused }, drawable2);
        }
        states.addState(new int[] {}, drawable);

        if(android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            this.setBackgroundDrawable(states);
        } else {
            this.setBackground(states);
        }
    }

    /**
     * 初始化按钮的容器
     */
    private void initializeButtonContainer(){

        if(mIconPosition == POSITION_TOP || mIconPosition == POSITION_BOTTOM){
            this.setOrientation(LinearLayout.VERTICAL);
        }else{
            this.setOrientation(LinearLayout.HORIZONTAL);
        }
        LayoutParams containerParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        this.setLayoutParams(containerParams);
        this.setGravity(Gravity.CENTER_VERTICAL);
        this.setClickable(true);
        this.setFocusable(true);
        if(mIconResource==null && mFontIcon==null && getPaddingLeft()==0 && getPaddingRight()==0 && getPaddingTop()==0 && getPaddingBottom()==0){
            this.setPadding(20, 20, 20, 20);
        }
    }

    /**
     * 设置文字内容
     * @param text : Text
     */
    public void setText(String text){
        this.mText = text;
        if(mTextView == null)
            initializeFancyButton();
        else
            mTextView.setText(text);
    }

    /**
     * 设置文字颜色
     * @param color : Color
     * use Color.parse('#code')
     */
    public void setTextColor(int color){
        this.mDefaultTextColor = color;
        if(mTextView == null)
            initializeFancyButton();
        else
            mTextView.setTextColor(color);

    }

    /**
     * 设置图标的颜色独立于文本颜色
     * @param color : Color
     */
    public void setIconColor(int color){
        if(mFontIconView != null) {
            mFontIconView.setTextColor(color);
        }
    }

    /**
     * 设置背景颜色
     * @param color : use Color.parse('#code')
     */
    public void setBackgroundColor(int color){
        this.mDefaultBackgroundColor = color;
        if(mIconView != null || mFontIconView != null || mTextView != null){
            this.setupBackground();
        }
    }

    /**
     * 设置焦点时按钮的颜色
     * @param color : use Color.parse('#code')
     */
    public void setFocusBackgroundColor(int color){
        this.mFocusBackgroundColor = color;
        if(mIconView != null || mFontIconView != null || mTextView != null)
            this.setupBackground();

    }

    /**
     * 设置文字的大小
     * @param textSize : Text Size
     */
    public void setTextSize(int textSize){
        this.mDefaultTextSize = textSize;
        if(mTextView != null)
            mTextView.setTextSize(textSize);
    }

    /**
     * 设置文本重力位置
     * @param gravity : Text Gravity
     */

    public void setTextGravity(int gravity) {
        this.mDefaultTextGravity = gravity;
        if (mTextView != null) {
            mTextView.setGravity(gravity);
        }
    }

    /**
     * 设置间距
     * @param paddingLeft : Padding Left
     * @param paddingTop : Padding Top
     * @param paddingRight : Padding Right
     * @param paddingBottom : Padding Bottom
     */
    public void setIconPadding(int paddingLeft, int paddingTop, int paddingRight, int paddingBottom){
        this.mIconPaddingLeft = paddingLeft;
        this.mIconPaddingTop = paddingTop;
        this.mIconPaddingRight = paddingRight;
        this.mIconPaddingBottom = paddingBottom;
        if(mIconView != null){
            mIconView.setPadding(this.mIconPaddingLeft, this.mIconPaddingTop, this.mIconPaddingRight, this.mIconPaddingBottom);
        }
        if(mFontIconView != null){
            mFontIconView.setPadding(this.mIconPaddingLeft, this.mIconPaddingTop, this.mIconPaddingRight, this.mIconPaddingBottom);
        }
    }

    /**
     * 设置icon来自于资源文件
     * @param drawable : Drawable resource
     */
    public void setIconResource(int drawable){
        this.mIconResource = mContext.getResources().getDrawable(drawable);
        if(mIconView == null || mFontIconView != null) {
            mFontIconView= null;
            initializeFancyButton();
        }
        else
            mIconView.setImageDrawable(mIconResource);
    }

    /**
     * 设置一种字符作为Icon图
     * @param icon : Icon value eg : \uf082
     */
    public void setIconResource(String icon){
        this.mFontIcon = icon;
        if(mFontIconView == null) {
            mIconView=null;
            initializeFancyButton();
        }
        else
            mFontIconView.setText(icon);
    }

    /**
     * 设置Icon尺寸(仅限字符Icon)
     * @param iconSize : Icon Size
     */
    public void setFontIconSize(int iconSize){
        this.mFontIconSize = iconSize;
        if(mFontIconView!=null)
            mFontIconView.setTextSize(iconSize);
    }

    /**
     * 设置图标位置
     * 使用全局变量 (FancyButton.POSITION_LEFT, FancyButton.POSITION_RIGHT, FancyButton.POSITION_TOP, FancyButton.POSITION_BOTTOM)
     * @param position : Position
     */
    public void setIconPosition(int position){
        if(position>0 && position<5)
            mIconPosition = position;
        else
            mIconPosition = POSITION_LEFT;

        initializeFancyButton();
    }

    /**
     * 设置按钮边框的颜色
     * @param color : Color
     * use Color.parse('#code')
     */
    public void setBorderColor(int color){
        this.mBorderColor = color;
        if(mIconView!=null || mFontIconView!=null || mTextView!=null){
            this.setupBackground();
        }
    }

    /**
     * 设置按钮的宽度
     * @param width : Width
     */
    public void setBorderWidth(int width){
        this.mBorderWidth = width;
        if(mIconView != null || mFontIconView != null || mTextView != null){
            this.setupBackground();
        }
    }

    /**
     * 设置按钮的边框半径
     * @param radius : Radius
     */
    public void setRadius(int radius){
        this.mRadius = radius;
        if(mIconView != null || mFontIconView != null || mTextView != null){
            this.setupBackground();
        }
    }

    /**
     * 设置按钮文本的自定义字体
     * @param fontName : Font Name
     * Place your text fonts in assets/fonts/
     */
    public void setCustomTextFont(String fontName){
        try{
            mTextTypeFace = Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", fontName));
        }catch(Exception e){
            Log.e("FancyButtons", e.getMessage());
            mTextTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", mDefaultTextFont));
        }

        if(mTextView==null)
            initializeFancyButton();
        else
            mTextView.setTypeface(mTextTypeFace);

    }

    /**
     * 设置按钮图标的自定义字体
     * @param fontName : Font Name
     * Place your icon fonts in assets/iconfonts/
     */
    public void setCustomIconFont(String fontName){
        try{
            mIconTypeFace = Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", fontName));
        }catch(Exception e){
            Log.e("FancyButtons", e.getMessage());
            mIconTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", mDefaultIconFont));
        }

        if(mFontIconView == null)
            initializeFancyButton();
        else
            mFontIconView.setTypeface(mIconTypeFace);

    }

}

布局文件
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:fancy="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <LinearLayout
        android:id="@+id/section1"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical" >

        <LinearLayout
            android:id="@+id/section_facebook"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#3b5998"
            android:gravity="center_horizontal"
            android:orientation="vertical"
            android:padding="20dp" >

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_facebook_like"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#3b5998"
                fancy:focusColor="#5577bd"
                fancy:fontIconResource="@string/icon_like"
                fancy:fontIconSize="10sp"
                fancy:iconPosition="right"
                fancy:radius="30dp"
                fancy:text="Like my facebook page"
                fancy:textColor="#FFFFFF"/>

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_facebook_share"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#3b5998"
                fancy:focusColor="#5577bd"
                fancy:fontIconResource="@string/icon_share"
                fancy:fontIconSize="10sp"
                fancy:iconPosition="right"
                fancy:iconPaddingLeft="20dp"
                fancy:iconPaddingRight= "0dp"
                fancy:radius="30dp"
                fancy:text="Share the link"
                fancy:textColor="#FFFFFF"/>

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_facebook_follow"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#3b5998"
                fancy:focusColor="#5577bd"
                fancy:fontIconResource="@string/icon_follow"
                fancy:fontIconSize="10sp"
                fancy:iconPosition="right"
                fancy:radius="30dp"
                fancy:text="Follow Mehdi Sakout"
                fancy:textColor="#FFFFFF" />
        </LinearLayout>


        <LinearLayout
            android:id="@+id/section_socialnetworks"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#ffffff"
            android:gravity="center_horizontal"
            android:minHeight="200dp"
            android:orientation="vertical"
            android:padding="20dp" >

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_marginBottom="15dp"
                android:gravity="center" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_android"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#55acee"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/twitter"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:radius="30dp"
                    fancy:textColor="#FFFFFF" />

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_dropbox"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#007ee5"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/dropbox"
                    fancy:radius="30dp">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>
            </LinearLayout>

            <LinearLayout
                android:id="@+id/sn_pos2"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_marginBottom="15dp"
                android:gravity="center"
                android:orientation="horizontal" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_instagram"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#3f729b"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/instagram"
                    fancy:radius="30dp">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_sound"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#ff8800"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/soundcloud"
                    fancy:radius="30dp">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>
            </LinearLayout>

            <LinearLayout
                android:id="@+id/LinearLayout1"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:gravity="center"
                android:orientation="horizontal" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_gplus"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#dd4b39"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/gplus"
                    fancy:radius="30dp">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_facebook"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#000000"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/github"
                    fancy:radius="30dp" >
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>
            </LinearLayout>
        </LinearLayout>
        <LinearLayout
            android:id="@+id/section_spotify"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#222326"
            android:gravity="center_horizontal"
            android:orientation="vertical"
            android:padding="20dp" >
            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_spotify"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:paddingBottom="10dp"
                android:paddingLeft="20dp"
                android:paddingRight="20dp"
                android:paddingTop="10dp"
                fancy:defaultColor="#7ab800"
                fancy:focusColor="#9bd823"
                fancy:fontIconResource="&#xf04b;"
                fancy:iconPosition="left"
                fancy:radius="30dp"
                fancy:text="SHUFFLE PLAY"
                fancy:textColor="#FFFFFF" />

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_spotify_pause"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:paddingBottom="10dp"
                android:paddingLeft="20dp"
                android:paddingRight="20dp"
                android:paddingTop="10dp"
                fancy:defaultColor="#7ab800"
                fancy:focusColor="#9bd823"
                fancy:fontIconResource="&#xf04c;"
                fancy:iconPosition="left"
                fancy:radius="30dp"
                fancy:text="PAUSE"
                fancy:textColor="#FFFFFF" />
            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_spotify_follow"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingBottom="10dp"
                android:paddingLeft="20dp"
                android:paddingRight="20dp"
                android:paddingTop="10dp"
                fancy:defaultColor="#222326"
                fancy:focusColor="#424243"
                fancy:radius="30dp"
                fancy:text="FOLOW"
                fancy:borderColor="#88898c"
                fancy:borderWidth="1dp"
                fancy:textColor="#dfe0d9" />
        </LinearLayout>
        <LinearLayout
            android:id="@+id/section_twitter"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#55acee"
            android:gravity="center_horizontal"
            android:orientation="vertical"
            android:padding="20dp" >

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_twitter_follow"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:padding="5dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="2dp"
                fancy:defaultColor="#55acee"
                fancy:focusColor="#8cc9f8"
                fancy:iconPaddingLeft="40dp"
                fancy:iconResource="@drawable/twitter"
                fancy:text="Follow me on Twitter"
                fancy:textColor="#FFFFFF"/>

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_twitter_followers"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="2dp"
                fancy:defaultColor="#55acee"
                fancy:focusColor="#8cc9f8"
                fancy:fontIconResource="@string/icon_user"
                fancy:fontIconSize="10sp"
                fancy:iconPosition="top"
                fancy:text="2145 followers"
                fancy:textColor="#FFFFFF"/>
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#ff5f69"
            android:gravity="center"
            android:paddingBottom="30dp"
            android:paddingTop="30dp" >

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_create_account"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="20dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#ff5f69"
                fancy:focusColor="#ff838b"
                fancy:radius="30dp"
                fancy:text="Create an account"
                fancy:textColor="#FFFFFF" >
            </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_login"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingBottom="10dp"
                android:paddingLeft="20dp"
                android:paddingRight="20dp"
                android:paddingTop="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#ff5f69"
                fancy:focusColor="#ff838b"
                fancy:fontIconResource="@string/icon_user"
                fancy:iconPosition="left"
                fancy:radius="30dp"
                fancy:text="Login"
                fancy:textColor="#FFFFFF" />

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:padding="20dp"
            android:layout_height="wrap_content"
            android:orientation="vertical" >

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_download"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="10dp"
                    android:padding="10dp"
                    fancy:borderColor="#FFFFFF"
                    fancy:borderWidth="2dp"
                    fancy:defaultColor="#3b414f"
                    fancy:focusColor="#8cc9f8"
                    fancy:fontIconResource="@string/icon_download"
                    fancy:fontIconSize="10sp"
                    fancy:iconPosition="top"
                    fancy:radius="10dp"
                    fancy:text="Download the file"
                    fancy:textColor="#FFFFFF">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_upload"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="10dp"
                    android:padding="10dp"
                    fancy:borderColor="#FFFFFF"
                    fancy:borderWidth="2dp"
                    fancy:defaultColor="#3b414f"
                    fancy:focusColor="#8cc9f8"
                    fancy:fontIconResource="@string/icon_upload"
                    fancy:fontIconSize="10sp"
                    fancy:radius="10dp"
                    fancy:iconPosition="bottom"
                    fancy:text="Upload"
                    fancy:textColor="#FFFFFF">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

            </LinearLayout>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_twitter"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="10dp"
                    android:padding="10dp"
                    fancy:borderColor="#FFFFFF"
                    fancy:borderWidth="2dp"
                    fancy:defaultColor="#40a75a"
                    fancy:focusColor="#8cc9f8"
                    fancy:fontIconResource="@string/icon_user"
                    fancy:fontIconSize="15sp"
                    fancy:iconPosition="left"
                    fancy:text="Send"
                    fancy:radius="10dp"
                    fancy:textColor="#FFFFFF">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

            </LinearLayout>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_decline"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="20dp"
                    android:padding="10dp"
                    fancy:borderColor="#FFFFFF"
                    fancy:borderWidth="0dp"
                    fancy:defaultColor="#d86262"
                    fancy:focusColor="#2e5071"
                    fancy:fontIconResource="@string/icon_mute"
                    fancy:fontIconSize="10dp"
                    fancy:iconPosition="right"
                    fancy:radius="30dp"
                    fancy:text="Mute"
                    fancy:textColor="#ffffff" />

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_answer"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="20dp"
                    android:gravity="right"
                    android:padding="10dp"
                    fancy:defaultColor="#7ed862"
                    fancy:focusColor="#2e5071"
                    fancy:fontIconResource="@string/icon_answer"
                    fancy:fontIconSize="10dp"
                    fancy:iconPosition="right"
                    fancy:radius="30dp"
                    fancy:text="Answer the call"
                    fancy:textColor="#ffffff" />

            </LinearLayout>

        </LinearLayout>

    </LinearLayout>

</ScrollView>

MainActivity补贴了，什么代码都没写，自动生成的一个Activity.
所有的一系列你所需的一些格式要求都可以在XML文件内预设，如果需要用代码编写就只需要调用上面的一些列Set方法就可以了。 
源码地址：http://yunpan.cn/cmy8gXMhNr8Zj  访问密码 a74d

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【cocos2d-x 3.7 飞机大战】 决战南海I (十二) 游戏结束场景
        游戏结束的时候，要显示分数，还要能够选择是返回主场景还是退出游戏



	// 退出游戏
	void menuCloseCallback(cocos2d::Ref* pSender);

	// 返回主界面
	void menuMainCallback(cocos2d::Ref* pSender);



实现该功能的代码如下

bool GameOver::init()
{
	//////////////////////////////
	// 1. super init first
	if (!Layer::init())
	{
		return false;
	}

	bool bRect = false;

	//背景音乐
	if (CocosDenshion::SimpleAudioEngine::getInstance()->isBackgroundMusicPlaying())
	{
		CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(true);
		CocosDenshion::SimpleAudioEngine::getInstance()->playBackgroundMusic("sound/game_over.mp3", true);
	}

	do 
	{
		Size visibleSize = Director::getInstance()->getVisibleSize();
		Vec2 origin = Director::getInstance()->getVisibleOrigin();

		//添加背景图片
		auto m_background = Sprite::createWithSpriteFrameName("backgroundGameOver.png");
		m_background->setPosition(Point(visibleSize.width / 2, visibleSize.height / 2));
		m_background->setAnchorPoint(Vec2(0.5, 0.5));
		CC_BREAK_IF(!m_background);

		this->addChild(m_background);

		//添加分数
		auto score_int = UserDefault::getInstance()->getIntegerForKey("currentScore");
		auto score_str = __String::createWithFormat("%d", score_int);
		auto score = Label::createWithTTF(score_str->getCString(), "fonts/DFPShaoNvW5-GB.ttf", 40);
		score->setPosition(Point(visibleSize.width / 2, visibleSize.height/3*2));
		score->setColor(Color3B(255, 0, 0));
		CC_BREAK_IF(!score);

		this->addChild(score);

		//设定等级

		//设置标签 并 获取中文文本
		auto dictionary = Dictionary::createWithContentsOfFile("fonts/AboutMe.xml");
		String rank_str;

		switch (score_int/1000)
		{
		case 0:
			rank_str = ((__String*)(dictionary->objectForKey("Eleven")))->getCString();
			break;
		case 1:
			rank_str = ((__String*)(dictionary->objectForKey("Ten")))->getCString();
			break;
		case 2:
			rank_str = ((__String*)(dictionary->objectForKey("Nine")))->getCString();
			break;
		case 3:
			rank_str = ((__String*)(dictionary->objectForKey("Eight")))->getCString();
			break;
		case 4:
			rank_str = ((__String*)(dictionary->objectForKey("Seven")))->getCString();
			break;
		case 5:
			rank_str = ((__String*)(dictionary->objectForKey("Six")))->getCString();
			break;
		case 6:
			rank_str = ((__String*)(dictionary->objectForKey("Five")))->getCString();
			break;
		case 7:
			rank_str = ((__String*)(dictionary->objectForKey("Four")))->getCString();
			break;
		case 8:
			rank_str = ((__String*)(dictionary->objectForKey("Three")))->getCString();
			break;
		case 9:
			rank_str = ((__String*)(dictionary->objectForKey("Two")))->getCString();
			break;
		case 10:
			rank_str = ((__String*)(dictionary->objectForKey("One")))->getCString();
			break;
		default:
			rank_str = ((__String*)(dictionary->objectForKey("Zere")))->getCString();
			break;
		};

		auto m_label1 = Label::createWithTTF(
			rank_str.getCString(),
			"fonts/DFPShaoNvW5-GB.ttf",
			65
			);
		m_label1->setColor(Color3B(255, 0, 0));
		m_label1->setPosition(Point(visibleSize.width / 2, visibleSize.height / 2 - m_label1->getContentSize().height));

		this->addChild(m_label1);


		/////////////////////////////
		// 2. add a menu item with "X" image, which is clicked to quit the program
		//    you may modify it.

		//退出游戏 按钮
		auto tempClose1 = Sprite::createWithSpriteFrameName("GameOver_nor.png");
		auto tempClose2 = Sprite::createWithSpriteFrameName("GameOver_touched.png");

		auto closeItem = MenuItemSprite::create(
			tempClose1, tempClose2, CC_CALLBACK_1(GameOver::menuCloseCallback, this)
			);

		//返回主界面 按钮
		auto tempBack1 = Sprite::createWithSpriteFrameName("ReturnGame_nor.png");
		auto tempBack2 = Sprite::createWithSpriteFrameName("ReturnGame_touched.png");

		auto backItem = MenuItemSprite::create(
			tempBack1, tempBack2, CC_CALLBACK_1(GameOver::menuMainCallback, this)
			);

		// create menu, it's an autorelease object
		auto menu = Menu::create(closeItem, backItem, NULL);
		menu->alignItemsVerticallyWithPadding(closeItem->getContentSize().height / 2);
		menu->setPosition(Vec2(origin.x + visibleSize.width / 2, visibleSize.height / 4));
		CC_BREAK_IF(!menu);

		this->addChild(menu, 1);

		bRect = true;
	} while (0);

	/////////////////////////////
	// 3. add your codes below...


	return true;
}

// 退出游戏
void GameOver::menuCloseCallback(Ref* pSender)
{
	Director::getInstance()->end();

#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)
	exit(0);
#endif
}

// 返回主界面
void GameOver::menuMainCallback(cocos2d::Ref* pSender)
{
	CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(true);
	Director::getInstance()->replaceScene(TransitionProgressRadialCCW::create(0.8f,HelloWorld::createScene()));
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

cocoapods应用第一部分-xcode创建.framework相关
问题的提出:
随着项目的越来越大,可能会出现好几个团队共同维护一个项目的情况,例如:项目组A负责其中的A块,项目组B负责其中的B块.....这几块彼此之间既独立,也相互联系.对于这种情况,可以采用约定的方式,比如,你只修改你那块,不要修改公共的.如果要修改公共的,那么必须要通知一下其它组,大家共同决定怎么修改,这种方式有一个很大的问题,很有可能不经意间就改了别的团队的代码.还有维护的越来越复杂等.
诸如此类的问题,很自然的我们会考虑每个团队建立一个静态库
 IOS的静态库有两种,.a和.framework,  动态库.framework居多.   静态库建议也生成.framework模式的,好处是.framework包含了相关的.h文件等..a文件还要自己添加相关的.h文件
   静态库：链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝.例如我们在我们的程序中使用了百度地图的.a文件,另外一个应用也使用了百度地图.a.这样整个系统中,会出现两个 百度地图.a文件

   动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存.系统提供的库基本上都属于此类,例如UIKit等,A应用和B应用中都用到了UIKit,系统只加载了一份在内存中.IOS中对于第三方的动态库,很遗憾,目前还不支持的.
一:framework的制作
   从xcode6开始,已经提供了制作.framework的选项了


下面我们用系统自带的来新建.framework.然后再添加一个依赖库 AFNetworking
1) xcode的菜单栏  File -> New Project  建立一个名为  YohunlUtilsLib 的Cocoa Touch Framework的工程. 将Target 改为 7.0(由于现在大多数应用都还要支持7.0sdk,故此处我们修改为支持7.0)


这时候,编译一下,你可能会遇到警告  


          (null): Embedded dylibs/frameworks only run on iOS 8 or later


别着急,这个是由于 从IOS8开始,建立的framework可以是动态的(并不是完全意义上的动态,这里的动态,其实还是要嵌入到我们的应用中,而不能够从网上下载,然后用dlopen动态加载的).


我们要修改 Mach-O Type.从默认的Dynamic Library 改为 Static Library,再编译,警告消失




那么选择 Dynamic Library 还是   Static Library 有什么影响呢? 我已经实际的检验过了.(我采用了一个包含了 第三方库 AFnetworking的测试工程)


  Static Library 支持IOS8.0 sdk以下的,从目前来看,大多数工程都还要支持7.0 sdk,所以我们最常用的就是Static Library  

当我们使用   Static Library时候,生成的framework直接如同添加普通文件的形式添加进来就可以了.它会自动在








不过当我们运行的时候,会提示:
当生成后,添加到示例工程中,






好吧,这种模式的添加,看来有些问题呀,还要自己添加依赖库,这些依赖库都是系统的,根据提示自己添加就可以了
再运行,OK







当我们使用 Dynamic Library模式(只有IOS8.0及以上才支持)的时候.如同普通文件一样添加到示例工程中去的话,运行,会出现提示:

dyld: Library not loaded: @rpath/NetTestLib.framework/NetTestLib
  Referenced from: /Users/yohunl/Library/Developer/CoreSimulator/Devices/B1DBCA26-C113-4C74-BB81-297D4AF1E0C8/data/Containers/Bundle/Application/C1B4F6D5-96FD-4245-8E6D-4F1C569EEF6F/TestFramework.app/TestFramework
  Reason: image not found







解决的方式 
在工程的配置  Embedded Binaries下面添加.而不是在 Linked Frameworks and Libraries下添加.这种方式,不需要添加 AFNetworking所需要的系统库,这一点不知道是什么原因!!!如果有知道原因的,请也告知我一下啊






再运行,OK




2)  命令行,进入目录下  pod init 建立一个podfile文件,因为我们制作的.framework需要用到AFNetworking网络库 PS:你也可以用任意的方式建立这个podfile文件
    打开它,因为我采用 pod init命令建立的,打开后你会发现它已经有内容了


修改其内容为
                   platform :ios, '7.0'
                   inhibit_all_warnings!


                  target 'YohunlUtilsLib' do
                        pod 'AFNetworking'
                  end


                  target 'YohunlUtilsLibTests' do
                  end


再执行 pod install 建立依赖
打开工程,添加一个文件  YONetwork.h,在其中添加方法
@interfaceYONetwork :NSObject
/**
 *  
获取github上用户的repo
 *
 *  @paramuser   用户名
 *  @paramsuccess成功的回调
 *  @paramfailure失败的回调
 */
- (void)getGithubReposForUser:(NSString*)user
 withSuccess:(void(^)(idresponseObject))success
 failure:(void(^)(NSError*error))failure;


/**
 *  
测试 getGithubReposForUser:withSuccess:failure的
 */
- (void)test;
@end
#import"YONetwork.h"
#import 
"AFNetworking.h"
@implementationYONetwork
- (void)getGithubReposForUser:(NSString*)user
 withSuccess:(void(^)(idresponseObject))success
 failure:(void(^)(NSError*error))failure
{
    
AFHTTPRequestOperationManager 
*manager = [AFHTTPRequestOperationManagermanager];
    [manager 
GET:[NSStringstringWithFormat:@"https://api.github.com/users/%@/repos",
 user] 
parameters:nilsuccess:^(AFHTTPRequestOperation*operation,id
responseObject) {
        success(responseObject);
    } 
failure:^(AFHTTPRequestOperation*operation,NSError*error)
 {
        failure(error);
    }];
}


- (void) test {
    [selfgetGithubReposForUser:@"yohunl"withSuccess:^(idresponseObject)
 {
        
NSLog(@"getGithubReposForUser response = %@",responseObject);
    } 
failure:^(NSError*error) {
        
NSLog(@"getGithubReposForUser error = %@",error);
    }];
}
@end




编译运行 (command + B),生成相应的.framework文件 
菜单 -  organizer 


可以看到目录结构如下:


其中的 YohunlUtilsLib.framework 就是我们要的  : 注意,YohunlUtilsLib.framework中并没有包含AFNetworking库的内容,这一点我们可以用如下的命令来验证.
命令进入 Debug-iphoneos
$ lipo -info YohunlUtilsLib.framework/YohunlUtilsLib
输出
Architectures in the fat file: YohunlUtilsLib.framework/YohunlUtilsLib are: armv7 arm64
说明我们生成的真机framework:YohunlUtilsLib.framework 包含了两种架构 armv7
 arm64
分离出每一种架构
$ mkdir armV7  当前目录建立文件夹,用于存放分离后的架构,和分离出的.o文件
$ lipo YohunlUtilsLib.framework/YohunlUtilsLib -thin armv7 -output ./armv7/YohunlUtilsLib_armv7  分离出armv7架构到文件夹armV7下
$ cd armV7 进入文件夹
$ ar -x YohunlUtilsLib_armv7  分离出armv7架构的所有的.o文件
分离后,如图:


可以看到,最后的.framework中,并没有包含我们pod添加的 AFNetworking.所以 当我们把我们生成的YohunlUtilsLib.framework给别人使用过的时候,别人自己要在项目中添加
 AFNetworking,否则会提示找不到的错误. 
 验证的方式可以参见 http://jiapumin.iteye.com/blog/2119102  主要是利用命令   


3) 我们使用命令来合并我们生成的真机和模拟器的framework
建立一个新的target




target建立后


添加如下的合并模拟器和真机的脚本

# Constants
SF_TARGET_NAME=${PROJECT_NAME}
#自定义的用来存放最后合并的framework
UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal



#IPHONE_DEVICE_BUILD_DIR=${BUILD_DIR}/${CONFIGURATION}-iphoneos

WORKSPACE_NAME=${PROJECT_NAME}.xcworkspace
YO_SCHEME=${PROJECT_NAME}

#clean build是先清除原来的build
xcodebuild -workspace ${WORKSPACE_NAME} -scheme ${YO_SCHEME} -sdk iphonesimulator -configuration"${CONFIGURATION}"clean build
xcodebuild -workspace ${WORKSPACE_NAME} -scheme ${YO_SCHEME} -sdk iphoneos -configuration"${CONFIGURATION}"clean build

# build project
#xcodebuild -project "${PROJECT_FILE_PATH}" -target "${TARGET_NAME}" -configuration "${CONFIGURATION}" -sdk iphoneos BUILD_DIR="${BUILD_DIR}" OBJROOT="${OBJROOT}" BUILD_ROOT="${BUILD_ROOT}"
 CONFIGURATION_BUILD_DIR="${IPHONE_DEVICE_BUILD_DIR}/arm64" SYMROOT="${SYMROOT}" ARCHS='arm64' VALID_ARCHS='arm64' $ACTION

#xcodebuild -project "${PROJECT_FILE_PATH}" -target "${TARGET_NAME}" -configuration "${CONFIGURATION}" -sdk iphoneos BUILD_DIR="${BUILD_DIR}" OBJROOT="${OBJROOT}" BUILD_ROOT="${BUILD_ROOT}" 
 CONFIGURATION_BUILD_DIR="${IPHONE_DEVICE_BUILD_DIR}/armv7" SYMROOT="${SYMROOT}" ARCHS='armv7 armv7s' VALID_ARCHS='armv7 armv7s' $ACTION

# Copy the framework structure to the universal folder (clean it first)
#因为framework的合并,lipo只是合并了最后的二进制可执行文件,所以其它的需要我们自己复制过来
#先移除原来的
rm -rf 
"${UNIVERSAL_OUTPUTFOLDER}"
mkdir -p 
"${UNIVERSAL_OUTPUTFOLDER}"
cp -R 
"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework" 
"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework"

#合并模拟器和真机的架构
lipo -create  
"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/${PROJECT_NAME}""${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework/${PROJECT_NAME}"-output"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/${PROJECT_NAME}"

open 
"${UNIVERSAL_OUTPUTFOLDER}"












对于以上的脚本,其中用到了很多的 xcode预定义的变量,这些变量怎么来的呢?你可以在命令行下, 输入
xcodebuild -workspace YohunlUtilsLib.xcworkspace -scheme YohunlUtilsLib -sdk iphonesimulator -configuration Debug -showBuildSettings > xcodebuild_showBuildSettings.txt
来将所有的xcode预定义变量都导入到文本xcodebuild_showBuildSettings.txt 中,然后你就可以选用你需要的啦


当然了,我们一般都应该合并release模式的,而不是debug模式的framework,这个可以在






ccmmand+B 编译
如果不出错的话,应该会弹出




到此处,我们的framework建立好了,下面可以建立一个测试工程来测试一下,是否可以了


4)建立一个single View Application的测试上述framework的工程 TestFrameworkDemo
将上一步生成的 Release-universal/YohunlUtilsLib.framework 加入到工程 TestFrameworkDemo
再写一个测试用例:




运行,这时候,你会收到错误提示


还记得前面说过吧,我们打包的framework并不包含
此时,我们有两种方式解决这个问题:
 1. 将我们生成 YohunlUtilsLib.framework 过程中生成的libAFNetworking.a 拷贝过来,添加到工程中(当然了,你要自己合并 libAFNetworking的真机和模拟器的.a文件) [这种方式的好处是可以保证我们的YohunlUtilsLib.framework使用到的libAFNetworking和我们一样的版本,保证了兼容性,,但同时也增加了集成的复杂性,我们要申明我们的framework用到了哪些第三方和第三方的版本信息]
2.在TestFrameworkDemo 工程中,增加 podFile文件,在其中加入 依赖  pod 'AFNetworking'
  重新pod install一下 [推荐这种方式,因为,我们用到的第三方都可以使用pod管理,方便],下面就以这种方法来说明




运行,OK!!!
源码在  https://github.com/yohunl/TestFrameworkDemo.git
framework在  https://github.com/yohunl/YohunlUtilsLib.git


二:使用 pod 的命令  pod lib create 来创建 使用pod的framework

采用cocoapods自带的命令,比较方便的http://guides.cocoapods.org/making/using-pod-lib-create 
  例如  pod lib create BZLib.可以自带demo的
命令如下   
pod lib create YohunlUtilsPod

注意:各个版本的cocoapods生成的示例工程结构什么的,会有点不一样,比如最新的带有demo的生成的lib工程就本身就是target的名字,但是之前版本target的名字是 名字_example


pod lib create 工程名  使会让你确认4个问题,由此来建立工程,4个问题都是很简单的,你可以自行选择


  






注意到了没?这里我们的 YohunlUtilsPod 目录下,并没有podfile文件,那么我们建立的库要怎么依赖第三方的啊.这里就是 
YohunlUtilsPod.podspec 文件出场了,在这个文件中,可以制定我们生成的framework依赖于什么.有关于spec文件,是关键文件,原则上,只要我们把这个文件交给别人,别人就可以添加我们的lib到工程里了




编辑YohunlUtilsPod.podspec 文件(此文件实际上是 ruby格式的,如果你用ruby相关的编辑器打开,就能高亮显示了),修改内容为
Pod::Spec.new do |s|
  s.name             = "YohunlUtilsPod"
  s.version          = "1.0.0"
  s.summary          = "测试pod生成framework的YohunlUtilsPod."

  s.description      = "测试用的,我们用来测试使用pod
 lib create 生成的framework工程"

  s.homepage         = "https://github.com/yohunl/YohunlUtilsPod"
  # s.screenshots     = "www.example.com/screenshots_1", "www.example.com/screenshots_2"
  s.license          = 'MIT'
  s.author           = { "yohunl" => 
"yohunl@163.com" }
  s.source           = { :git => "https://github.com/yohunl/YohunlUtilsPod.git", :tag => s.version.to_s }

  # s.social_media_url = 'https://twitter.com/<TWITTER_USERNAME>'

  s.platform     = :ios, '7.0'
  s.requires_arc = true

  s.source_files = 'Pod/Classes/**/*'
  s.resource_bundles = {
    'YohunlUtilsPod' => ['Pod/Assets/*.png']
  }

  # s.public_header_files = 'Pod/Classes/**/*.h'
  # s.frameworks = 'UIKit', 'MapKit'
   s.dependency 'AFNetworking'
end 
验证podspec文件是否正确是使用命令  在podspec所在目录下执行  pod lib lint


如果提示错误的话,它会给出详细的提示,你照着修改就好了,备注:我已经将源码上传到了github上(你也可以上传你的私有git服务器,一般公司都应该有自己的git服务器)


更改完后,在工程中再加入  YONetwork.h和.YONetwork.m 



再运行 pod install  
如果提示 
SZ-lingdaiping:Example yohunl$ pod install
Updating local specs repositories
Analyzing dependencies
Fetching podspec for `YohunlUtilsPod` from `../`
[!] Unable to satisfy the following requirements:

- `YohunlUtilsPod (from `../`)` required by `Podfile`
- `YohunlUtilsPod (from `../`)` required by `Podfile`
- `YohunlUtilsPod (= 0.1.0)` required by `Podfile.lock`


那么删掉  Podfile.lock文件,因为我们更改了podspec文件里的库的版本号了


看到没,是在 Development Pods文件夹下,因为并没有上传到官方去,所以,在此处是 私有的,所以在Development Pods文件夹下  .


接下来,如同第一个一样,添加一个新的target,添加 run script脚本 ,运行它,得到  


建立一个测试工程


注意上面图里面的文字,此处因为我们的framework工程采用dynamic 模式的(上文有论述!!!)  所以需要在Embedded Binaries下添加相应的库.至于为什么还要添加 AFNetworking.framework,上面也有论述,是因为我们打包的.framework并没有包含AFNetworking.framework,如果不加上,运行起来,还是要报错的哦


好了,第一部分讲完了
那么我们怎么使用 像我们使用其它开源库那样的,只要在demo工程里添加一句
pod ‘YohunlUtilsPod' 然后pod install一下就可以添加呢?(当然了,这种方式,我们一般是直接源码模式的framework加入demo工程)


这就是第二部分要讲的.






参考文档:
http://maxao.free.fr/xcode-plugin-interface/build-settings.html#variables
ttps://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/0-Introduction/introduction.html
ttp://outofmemory.cn/shell/learn-shell-in-30-minutes/
http://www.cnblogs.com/wendingding/p/3893095.html
http://www.cnblogs.com/brycezhang/p/4117180.html
http://wenva.github.io/2015/07/08/创建自己的CocoaPods私有仓库.html
http://insert.io/framework-ios8-xcode6/

















版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        iOS 类似简单的第三方微博客户端,可进行登录微博浏览相关信息
Demo地址：https://github.com/ChenNan-FRAM/Fenvo （如果你觉得有用麻烦star一下感激不尽）
Fenvo
Objective-C, iOS
类似简单的第三方微博客户端,可进行登录微博浏览相关信息。在这个过程我是遇到很多的问题，但是大部分都顺利解决了，相信如果你的项目有类似的地方我的项目里面也能够给你提供一定的帮助，如果需要，可以给我留言或者在Github上联系我。
UI简陋，暂未完善。有UI大师指点就最好了。 这个应用我是从开始学后为了实践自己的能力一直在编写的，不是什么大神级人物，只是一个忠诚的iOS开发者，喜欢美好，简单的东西。如果你也有兴趣加入我一起完善这个第三方微博客户端可以给我留言或者push我。如果你有什么想法，我也很乐于交流探讨。可以点击上方的Demo进入我的Github。


已实现模块

登录、注册
微博个人关注微博主页内容（微博信息图片浏览，转发，回复，赞，收藏等）
微博个人信息内容模块


正在实现模块

写微博，发送微博
个人消息提醒（评论回复、赞、粉丝）


主要数据模型（Model）

WeiboMsg.h   //主要微博信
WeiboGeoInfo.h  //地理信息
WeiboRemind.h  //提示信息
WeiboUserInfo.h  //用户个人信息
WeiboVisibleInfo.h  //微博可见性
WeiboPrivacySetting.h //微博隐私分组
WeiboComment.h  //评论
——-暂未完成———
WeiboChatMsg.h  //私信 


远程数据请求功能（RPC）


已增加功能：
请求个人关注用户微博
请求公共微博
请求个人评论数据
请求某微博评论列表数据


主要控制器（ViewController）

FollowingWBViewController.h //用户关注微博首页
ProfileViewController.h //用户个人主页 
AlbumView.h //用户原创图片
UserInfoView.h //用户个人简介
WeiboTableView.h //用户个人已发送微博
FollowingListTableViewController.h //用户粉丝列表
FollowerListTableViewController.h //用户关注列表
NewWeiboVC.h //用户写新微博
WebViewController.h //微博附带网站跳转
未完待续


各种自定义控件
位于WeiboMsgComponent组下

WeiboCommentView //微博评论页
WeiboForwardView //微博转发页
WebImageBrowser //微博网络图片浏览
WBImageBrowser //微博本地图片浏览（写微博）
OriginalTableViewCell //微博基本Cell
WeiboAvatarView //微博头像
WeiboLabel //由MLEmojiLabel更改而来，微博label
WBImageSelect //更改自QBImagePickerController，多图选择
未完待续


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        火云开发课堂 - 《使用Cocos2d-x 开发3D游戏》系列 第八节:灯光
《使用Cocos2d-x 开发3D游戏》系列在线课程            第八节:灯光 视频地址：http://edu.csdn.net/course/detail/1330/20808?auto_start=1交流论坛：http://www.firestonegames.com/bbs/forum.php 工程下载地址：http://www.firestonegames.com/bbs/forum.php?mod=viewthread&tid=31&extra=page%3D1  课程截图：           实例工程演示：    ﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Animation动画详解（二）： 组合动画特效
前言
    上一篇博客Android Animation动画详解（一）： 补间动画 我已经为大家介绍了Android补间动画的四种形式，相信读过该博客的兄弟们一起都了解了。如果你还不了解，那点链接过去研读一番，然后再过来跟着我一起学习如何把简单的动画效果组合在一起，做出比较酷炫的动画特效吧。


一、 动画的续播
    如题，大家想想，如果一个页面上包含了许多动画，这些动画要求按顺序播放，即一个动画播放完成后，继续播放另一个动画，使得这些动画具有连贯性。那该如何实现呢？ 有开发经验或者是逻辑思维的人肯定会想，对动画进行监听啊，如果这个动画播放完了，再去播放另一个动画不就好了。
    Congratulations， 你和我想的是一样一样的。
    我们看下通过这种动画播放监听如何去做：

 private void continueAnim(){
        // 先加载第一个动画
        Animation translate = AnimationUtils.loadAnimation(getActivity(), R.anim.translate_animation);
        // 在加载第二个动画
        final Animation scale = AnimationUtils.loadAnimation(getActivity(), R.anim.scale_animation);

        // 接下来，我们队第一个动画进行监听，当它播放完成后，我们播放第二个动画
        translate.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                imgView.startAnimation(scale);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }
        });
        imgView.startAnimation(translate);
    }
    注释我已经写得挺详细了，可以说，这种方法so easy，没啥可说的。



    除了上面介绍的使用监听器监听动画播放结束之外，还有一个更easy方法，也是我们优先推荐使用的，那就是Animation Set。
    这里，我们要引入一个动画的属性：startOffset。 如何去使用呢？看下定义动画的代码：

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:fillAfter="true"
    android:fillEnabled="true">

    <alpha
        android:fromAlpha="0"
        android:toAlpha="1"
        android:duration="3000"/>

    <translate
        android:duration="1000"
        android:fromXDelta="0"
        android:fromYDelta="0"
        android:toXDelta="100"
        android:toYDelta="100"
        android:startOffset="3000"
        />
</set>
  仔细看下translate定义的动画，它其中就有一个属性startOffset，这个属性的值，其实就是alpha动画的duration的值，他的意思是，延迟三秒后播放，其实也就是第一个alpha动画播放完成后再播放。

Animation continueAnim = AnimationUtils.loadAnimation(getActivity(), R.anim.continue_animation);
imgView.startAnimation(continueAnim);
好啦，写到这，让我们看下运行的效果吧：





二、 动画的重播
    重播动画，故名思议，就是动画重复播放。大家看下上面那个gif的动态图，其实就是重复播放动画。那Android如何重复播放动画呢？
   其实very easy，因为Android本身为定义动画提供了两个属性repeatCount和repeatMode，只要为你的动画设置上这两个属性，那就ok了！
   为了方便记忆，让我们稍微看下代码吧：

    <translate
        android:duration="1000"
        android:fromXDelta="0"
        android:fromYDelta="0"
        android:toXDelta="100"
        android:toYDelta="100"
        android:repeatCount="5"
        android:repeatMode="restart"
        />
这里我们指定了repeatCount为5，则动画要播放5次，repeatMode为“restart”，则动画每次都是重复播放。repeatMode还有个取值“reverse”，这是指让动画倒叙播放。 看下效果。



三、 Activity的切换动画
    说道Activity切换动画，我想大家肯定都不陌生，比如你玩淘宝、美团啥的，你会发现它们的页面切换都是从右向左滑动进入的，这其实就是Activity切换动画的应用。或许大家初始会觉得挺难，但我要告诉你的是，其实这玩意真简单，如果你已经会了如何定义动画（特指补间动画），那么你只要再理解下一个方法——overridePendingTransition即可。
    先让我们一起看下这个方法的定义：
/**
     * @param enterAnim A resource ID of the animation resource to use for
     * the incoming activity.  Use 0 for no animation.
     * @param exitAnim A resource ID of the animation resource to use for
     * the outgoing activity.  Use 0 for no animation.
     */
    public void overridePendingTransition(int enterAnim, int exitAnim) {
        try {
            ActivityManagerNative.getDefault().overridePendingTransition(
                    mToken, getPackageName(), enterAnim, exitAnim);
        } catch (RemoteException e) {
        }
    }第一个参数enterAnim就是说新的要启动的Activity进入时的动画，第二个参数exitAnim，说的其实是原先的Activity退出时的动画效果。
接下来让我们定义两个动画资源：fade_in.xml和hold_out.xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/accelerate_interpolator"
    >
    <alpha
        android:fromAlpha="0.2"
        android:toAlpha="1.0"
        android:duration="1000"
        />
</set><?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/accelerate_interpolator">

    <translate
        android:fromXDelta="0%p"
        android:toXDelta="100%p"
        android:duration="1000"
        />
</set>
定义动画结束后，那我们只需要在启动新Activity或者结束Activity时，复写overridePendingTransition方法，并传入动画就好啦：
Intent intent = new Intent(getActivity(),SecondActivity.class);
startActivity(intent);
overridePendingTransition(R.anim.fade_in,R.anim.hold_out);
或者是：
public void back(View view){
        finish();
        overridePendingTransition(R.anim.fade_in,R.anim.hold_out);
}看下效果吧：


有没有被惊叹道，原来就这么easy啊！ 赶快自己也动手试下吧。


Follow Me：
    其实Android简单的动画就这么些个，复杂的动画无非也是把这些动画整合在一起使用而已，大家遇到复杂的动画不要太慌，只要分析清楚它的实现原理，一步步的来解锁，都是可以搞定的啦。
    之后，我会再写两篇博客，介绍我在开发过程中使用过的两次动画，当然，并不是很难的那种，只是分享经验而已，敬请期待，欢迎指点。


源码下载地址（免费）：http://download.csdn.net/detail/zuiwuyuan/9047739

版权声明：本文为博主原创文章，未经博主允许不得转载。

windows  android JNI 使用和环境搭建

     网上看了很多文章，有的太老了，有的不说的不是很清楚，这个一步一步开始使用android JNI 方法
     参考：http://bbs.51cto.com/thread-948244-1.html###
                  http://www.cnblogs.com/kissazi2/p/3298884.html    

    使用GNUStep作为C/C++编译器，选择这个的原因是，编译器小，很快就下载完成


（一）下载安装编译环境
          1.打开网站  http://www.gnustep.org/

    
进入后，下载安装，从上到下的顺序安装就行了

   

 安装成功后启动shell，方法
   

打开GNUstep->Shell，输入make -v 和 gcc -v命令，验证是否安装成功




下载DNK 我下载的地址是：https://dl.google.com/android/ndk/android-ndk64-r10-windows-x86.zip
看文章 http://www.cnblogs.com/yaotong/archive/2011/01/25/1943615.html 上面有很多原生地址
google的地址是打不开的，但是可以直接下载，真是感谢啊！呵呵！

 注意：下载下来后解压遇到说文件重复是否覆盖，我选择的是覆盖，小写名字覆盖大写名字；（这里没做深入研究，只看了一下两个文件）
 配置ndk环境变量，gnustep是模拟linux的环境的，打开gnustep的安装目录下的D:\GNUstep\GNUstep\GNUstep.conf文件，添加以下内容：

复制内容到剪贴板

NDK=/d/android-ndk64-r10-windows-x86/android-ndk-r10
export=NDK



NDK的位置就是你下载后解压好，放的位置：




说明如果不知道ndk目录在linux下应该是在哪里，你可以打开gnustep的命令窗口，输入mount，就可以找到对应的盘符。


到此环境部署完成

（二）建立工程，写例子代码

      1.建立工程com.example.test4；
    添加 类JniTest  

package com.example.test4;

public class JniTest {
	 public native final String init();
	 public native final void init2(int a,int b);
}
// main 中的代码
public class MainActivity extends Activity {

    static{
        System.loadLibrary("JniTest");
    }
 
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        JniTest jniTest = new JniTest();
        String s = jniTest.init();
     
    }
}
 



2.开始-运行-cmd，到工程目录
使用cmd :F:\workspace2\test4>javah -classpath ./src -d ./jni  -jni com.example.test4.JniTest

    
-classpath <路径> 用于装入类的路径
-d <目录> 输出目录
-jni 生成 JNI样式的头文件（默认）
     
手动添加 com_example_test4_JniTest.c Android.mk 文件
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := JniTest
LOCAL_SRC_FILES := com_example_test4_JniTest.c

include $(BUILD_SHARED_LIBRARY)
// 这里只实现了一个接口

#include <string.h>
#include <jni.h>
#include "com_example_test4_JniTest.h"

jstring
Java_com_example_test4_JniTest_init
  (JNIEnv* env, jobject thiz){
          return (*env)->NewStringUTF(env, "我的测试JIN接口");
}



其中你只需要该LOCAL_MODULE和LOCAL_SRC_FILES就可以了。
说明:LOCAL_MODULE是描述模块的，用来给java调用的模块名，会生成对应的libtestJni.so
LOCAL_SRC_FILES就是源文件啦，多个文件空格隔开即可。
接下来，我们要开始编译生成so文件咯。
打开gnustep的命令窗口，进入到项目底下，输入$NDK/ndk-build命令，即可自动生成libs/armeabi/libtestJni.so文件。

F5刷新工程

F11debug Eclipse test4工程，可以看到MainActivity中的调用 String s = jniTest.init();  就是在c文件中写的字符串
（3）自动编译

   直接从http://bbs.51cto.com/thread-948244-1.html### 中cp 过来了
右击jni工程的properties-->Builders-->NEW -->;Program 可以看到以下内容：



argument：--login -c "cd /e/myWorkSpace/android/hellJni && $NDK/ndk-build"
切换到Refresh 标签页



切换到Build Options标签页

这样就完成了配置，点击确定可看到控制台自动编译程序了






版权声明：本文为博主原创文章，未经博主允许不得转载。

Android插件化开发之OpenAtlas插件的安装与卸载、更新与回滚
用过Android的同学都知道，手机上的APP可以进行安装，安装完之后可以卸载，安装完后如果有新版本的话可以更新。此外还有一点，就是像windows那样，从win7升级到win10感觉不满意可以回滚到win7。但是回滚功能貌似在Android里是没有的。
OpenAtlas也是如此，在我们的宿主上安装的插件，也是类似这个机制。OpenAtlas为我们提供了很好的插件安装，卸载，更新，回滚的功能。
假设现在你有一个apk，但是前提是这个apk中的四大组件要在你的宿主的清单文件中进行注册，也就是OpenAtlas的初衷不是运行其他的Apk，而是模块化。想将它安装为插件，首先要有这个apk，按照正常流程开发就可以了。
然后我们将它放在sd卡的根目录，假设文件名为test-openatlas-debug.apk，更新代码就是这样子的
try {
    File file=new File("/sdcard/test-openatlas-debug.apk");
    if (!file.exists()){
        Toast.makeText(MainActivity.this, "Test Update pkg not exist", Toast.LENGTH_LONG).show();
    }
    Atlas.getInstance().installBundle("com.lizhangqu.test1",file);
} catch (BundleException e) {
    e.printStackTrace();
}
由于宿主中已经有com.lizhangqu.test这个插件了，所以上面的更新代码将插件安装的位置修改为了com.lizhangqu.test1，installBundle函数的两个参数，第一个是安装的位置，一般传插件的包名就可以了，第二个参数是插件的文件。安装完后对应目录下/data/data/package name/files/storage/下就会有对应的目录生成，如图所示。

如果要卸载的话也很简单，只要一句话
Atlas.getInstance().uninstallBundle("com.lizhangqu.test1");
参数为对应的插件包名，也就是之前安装的第一个参数。
搞定了安装与卸载，我们来看下如何进行插件的更新。插件的更新其实类似于插件的安装。当插件有新版本的时候，我们需要对其进行更新，拿到新apk后，将其放在sd卡根目录，下面进行更新，我们以名为test插件为例。
File file=new File("/sdcard/test-openatlas-debug.apk");
if (!file.exists()){
    Toast.makeText(MainActivity.this, "Test Update pkg not exist", Toast.LENGTH_LONG).show();
}
try {
    Atlas.getInstance().updateBundle("com.lizhangqu.test",file);
} catch (BundleException e) {
    e.printStackTrace();
}
值得注意的是，插件的安装与卸载时不必重启宿主的，但是插件的更新是需要重启宿主的。在更新插件前，test插件的内容如下所示。

以及对应的文件夹内容如下

更新了一个版本后界面就变得不一样了。记得重启宿主。如图所示。

可以看到一些细微的区别，就是上面多了update1。
然后看看对应的文件夹是不是多了一个版本。

但是，一旦你更新到新的一个版本后，你突然发现有bug，这时候你想回滚到之前的一个版本怎么办，其实也很简单。
Atlas.getInstance().restoreBundle(new String[]{"com.lizhangqu.test"});
参数是一个字符串数组，可以同时回滚多个插件，这里只回滚了test插件。重启后你发现插件变回原来的样子了。
简简单单的四个操作，安装，卸载，更新，回滚，使得OpenAtlas变得十分灵活。我们可以随心所欲的进行控制，但是唯一的不足就是四大组件必须在宿主清单中注册，这也给了动态更新加大了难度。如果你想能够直接进行安装，更新插件，前提是你不引入新的组件，因为这些组件你必须注册，还有一个解决方法就是如果你的插件只是UI部分，不涉及新的广播，Service，ContentProvider，仅仅是涉及Activity，那么你完全可以使用Fragment进行代替，解决方案见

Android插件化开发之解决OpenAtlas组件在宿主的注册问题

当然，如果你有兴趣，也可以阅读这一系列文章

Android插件化开发之OpenAtlas初体验
Android插件化开发之OpenAtlas生成插件信息列表
Android插件化开发之OpenAtlas资源打包工具补丁aapt的编译
Android插件化开发之OpenAtlas插件适配
Android插件化开发之解决OpenAtlas组件在宿主的注册问题
Android插件化开发之OpenAtlas中四大组件与Application功能的验证
Android插件化开发之OpenAtlas插件启动方式与插件启动广播

最后，给出源码地址，直接放github上了，反复上传csdn太繁琐了。 
 - https://github.com/lizhangqu/OpenAtlasDemo

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Studio中Android Support Library升级到 23.0.0 报错！
Android Support Library升级到 23.0.0  报错解决方案不得不说，真能折腾！将Android Studio中SDK下的 Android Support Library 升级到了23.0.0，结果倒好了，创建项目出问题了，还比较奇葩：卧槽你大爷！尼玛还能不能好好玩耍了。各种卸载重装，就差重装系统了。后来在神器stackoverflow中找到了这么一篇：http://stackoverflow.com/questions/32092511/resource-error-in-android-studio-after-update-no-resource-found原因：23.0之前有基于apac.http package 的引用，升级后没引用了，所以才导致新建项目报错。解决方案：https://code.google.com/p/android/issues/detail?id=183122#makechanges参照以上方法：第一：打开Project，找到Project中的build.gradle，将compile 'com.android.support:appcompat-v7:23.0.0'设置为compile 'com.android.support:appcompat-v7:22.2.1'第二：进入sdk\extras\android\m2repository\com\android\support\appcompat-v7 ，删除23.0.0文件夹，删除maven-metadata.xml中的<version>23.0.0</version>，如图：第三：clean and rebuild.最近使用Android Studio 出现各种问题，哎，一个问题出现就得折腾大半天，而且作为天朝的程序员，Studio好慢啊！穷的天天吃馒头，哪里来的票票搞VPN（别说俺抠门啊）。不过总得来说还是感觉Studio耍起来不管是IDE的界面，还是编码效率，高大上，到位！

版权声明：本文为博主原创文章，未经博主允许不得转载。

(素材源码) 猫猫学iOS 之UIDynamic重力、弹性碰撞吸附等现象PS有惊喜
猫猫分享，必须精品
原创文章，欢迎转载。转载请注明：翟乃玉的博客 
地址：http://blog.csdn.net/u013357243
一：效果
 
 
 
 

二：代码
#import "ViewController.h"
#import "DemoViewController.h"

@interface ViewController ()
{
    // 功能名称的数组
    NSArray *_functions;
}

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    _functions = @[@"吸附行为", @"推动行为", @"刚性附加行为", @"弹性附加行为", @"碰撞检测"];
}

#pragma mark - 数据源方法
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return _functions.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 使用Storyboard建立的UITabeViewController，其中的Cell是已经注册过的
    static NSString *ID = @"Cell";
    // 永远都会找到一个单元格，如果缓冲池中没有，会自动新建
    /**
     dequeueReusableCellWithIdentifier 直接查询可重用单元格
     dequeueReusableCellWithIdentifier:forIndexPath: 查询“注册的”可重用单元格，此方法中indexPath本身没有用处

        * 强制判断是否注册了单元格

     如果已经注册过单元格，以上两个方法等效。

     如果在StoryBoard中指定了单元格的可重用标示符，单元格的优化将有系统接管，不再需要判断cell == nil
     */
//    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID forIndexPath:indexPath];

//    if (cell == nil) {
//        NSLog(@"come here");
//        
//        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];
//    }

    cell.textLabel.text = _functions[indexPath.row];

    return cell;
}

#pragma mark - 代理方法
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    DemoViewController *controller = [[DemoViewController alloc] init];

    // 指定标题
    controller.title = _functions[indexPath.row];
    controller.function = indexPath.row;

    [self.navigationController pushViewController:controller animated:YES];
}

#import "DemoViewController.h"
#import "DemoView.h"
#import "SnapView.h"
#import "PushView.h"
#import "AttachmentView.h"
#import "SpringView.h"
#import "CollisionView.h"

@interface DemoViewController ()

@end

@implementation DemoViewController

//- (void)loadView
//{
//    self.view = [[DemoView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame];
//}

- (void)viewDidLoad
{
    [super viewDidLoad];

    NSLog(@"功能代号： %d", self.function);
    // 在此根据实际的功能代号加载实际的视图

    DemoView *demoView = nil;
    switch (self.function) {
        case kDemoFunctionSnap:
            demoView = [[SnapView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionPush:
            demoView = [[PushView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionAttachment:
            demoView = [[AttachmentView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionSpring:
            demoView = [[SpringView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionCollision:
            demoView = [[CollisionView alloc] initWithFrame:self.view.bounds];
            break;
        default:
            break;
    }

    [self.view addSubview:demoView];
}


@end

主要框框就这样啦，贴出了的代码仅仅部分
三：素材代码下载地址
http://download.csdn.net/detail/u013357243/9043837
ps：很久没有上传源代码了，最近帮朋友做做项目然后自己学学习，感觉iOS学习起来比Android体验好多了，注意撒，是学习体验。。。
ps2：猫猫要找工作了，北广深有木有人收留。。。喵呜
ps3：惊喜~~~

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

最老程序员创业开发实训1---Android应用架构之MVC
我们都知道Android中基本组件是Activity，每个界面都是一个Activity，自从2.3版本开始，又增加了Fragment组件，提供了适应于各种屏幕方法。但是由于Android系统只是提供了各种可用的编程技术，并没有对应用架构进规定。实践中，很多项目将所有功能都添加到了Activity中，使Activity变得十分臃肿，不便于进行后期修改和维护。如果我们要一个人来开发一个系统，那么必须采用高效的应用架构，方便调试及维护。
在开发应用中，采用MVC架构无疑是一种最安全的选择，将应用按照控制器、视图、模型来组织，使系统的耦合减少，灵活性增加，更方便于调试和维护。但是问题就来了，通常程序员们会说：Android平台所有组件都是基于MVC的，我的应用自然就是基于MVC架构的呀！其实这是一种典型的错解，Android组件是基于MVC的不假，但是你的程序在Activity中既保存着从网络获取到的数据，又负责页面更新和显示，同时还有业务逻辑，这时这个Activity就几乎同时拥有了模型、视图、控制器功能了，实际上是不符合MVC精神的。
那么在Android平台中，怎样体现MVC架构呢？关于这一点，很多不同的看法。在这里只向大家介绍其中的一种，之所以选择这种，是因为他与IOS平台上的理念一致，我们要同时开发Android和IOS系统，那么同样理念的东西，自然是我们最佳选择了。
对于一个Android中最基本的组件Activity来说，我们可以将布局文件视为视图（View），而Activity可以视为控制器（Controller），控制器需要与视图进行交互，这时就需要在Activity中获取页面中的各个控件，在Android中通过findViewById方法来实现，而在IOS平台中，采用IOutlet形式实现。当视图中产生一个事件，如用户点击某按钮，这时需要触发一个事件，这时Android有两种处理方式，一种是直接在布局文件中写click=""，另一种是通过在Activity中通过调用setOnclickListener来实现，我推荐采用第二种方案，因为这样不仅是避免了视图与控制器逻辑搅合在一起，同时也为了与IOS中采用IAction方式保存一致。这样当需要改变界面内容时，可以在Activity中通过对界面中的控件进行操作，而界面中产生的事件，通过Activity中定义的事件处理函数来进行处理。这样就有效的区分了控制器和视图的职能。
对于界面中需要显示的数据，我们需要设计单独的模型类，Activity在需要时，调用模型类的相关方法，获取数据并显示到界面中，但是模型类不直接调用Activity的方法。那么，如果模型中的数据改变了，怎样通知界面进行更新呢？这里我们采用事件总线机制，当模型数据发生改变时，会向系统总线发送一个事件。所有Activity会向自己所感兴趣的事件进行注册，方法就将自己的Handler实例加入到事件总线的列表中。这样当模型数据改后，事件总件收到来自模型类的事件，找出对该事件感兴趣的Hanlder实例列表，依次向每个Handler实例发送消息，这样每个相关的Activity就可以对模型类数据变化做出正确的响应了。在IOS中，每个类的属性会有willSet,
 didSet这样的观察者方法，可以在这些方法中向事件总线发送事件。
应用程序架构如下图所示：


从上图可以看出，模型（Model）和视图（View）不会主动调用Activity，同时模型（Model）和视图（View）之不发生直接的关系，二者之间的交互都统一通过Activity来进行。稍后我们将看到，在IOS平台下，我们也会采用相同的架构。
在下一篇博文中，我们将以这个架构为指导，做程序开始时的Splash页面。然后我们会回过头来，描述在IOS平台下，采用Swift 2.0来实现相同的功能。


大家的支持是我继续前进的动力，请大家多多支持：
银行账号：622202 0200 1078 56128 闫涛
我的支付宝：yt7589@hotmail.com


版权声明：本文为博主原创文章，未经博主允许不得转载。

猫猫学iOS 之UIDynamic重力、弹性碰撞吸附等现象
猫猫分享，必须精品
原创文章，欢迎转载。转载请注明：翟乃玉的博客 
地址：http://blog.csdn.net/u013357243
一：效果
重力和碰撞 

吸附现象 

二：简介
什么是UIDynamic 
UIDynamic是从iOS 7开始引入的一种新技术，隶属于UIKit框架 
可以认为是一种物理引擎，能模拟和仿真现实生活中的物理现象 
重力、弹性碰撞等现象
物理引擎的价值 
广泛用于游戏开发，经典成功案例是“愤怒的小鸟” 
让开发人员可以在远离物理学公式的情况下，实现炫酷的物理仿真效果 
提高了游戏开发效率，产生更多优秀好玩的物理仿真游戏
知名的2D物理引擎
    Box2d
    Chipmunk

三：使用步骤和代码
步骤
要想使用UIDynamic来实现物理仿真效果，大致的步骤如下 
1，创建一个物理仿真器（顺便设置仿真范围）。
2，创建相应的物理仿真行为（顺便添加物理仿真元素）。
3，将物理仿真行为添加到物理仿真器中  开始仿真。

简单认识
物理仿真元素（Dynamic Item）谁要进行物理仿真？
物理仿真行为（Dynamic Behavior） 执行怎样的物理仿真效果？怎样的动画效果？
物理仿真器（Dynamic Animator）让物理仿真元素执行具体的物理仿真行为
注意： 
不是任何对象都能做物理仿真元素。 
不是任何对象都能进行物理仿真。
任何遵守了UIDynamicItem协议的对象才能做物理仿真元素。 
UIView默认已经遵守了UIDynamicItem协议，因此任何UI控件都能做物理仿真。 
UICollectionViewLayoutAttributes类默认也遵守UIDynamicItem协议。
UIDynamic提供了以下几种物理仿真行为
UIGravityBehavior：重力行为 
UICollisionBehavior：碰撞行为 
UISnapBehavior：捕捉行为 
UIPushBehavior：推动行为 
UIAttachmentBehavior：附着行为 
UIDynamicItemBehavior：动力元素行为
物理仿真行为须知 
上述所有物理仿真行为都继承自UIDynamicBehavior 
所有的UIDynamicBehavior都可以独立进行 
组合使用多种行为时，可以实现一些比较复杂的效果
物理仿真器
它可以让物理仿真元素执行物理仿真行为 
它是UIDynamicAnimator类型的对象
UIDynamicAnimator的初始化
- (instancetype)initWithReferenceView:(UIView *)view;
view参数：是一个参照视图，表示物理仿真的范围 
UIDynamicAnimator的常见方法
- (void)addBehavior:(UIDynamicBehavior *)behavior;
添加1个物理仿真行为
- (void)removeBehavior:(UIDynamicBehavior *)behavior;
移除1个物理仿真行为
- (void)removeAllBehaviors;
移除之前添加过的所有物理仿真行为
UIDynamicAnimator的常见属性
@property (nonatomic, readonly) UIView* referenceView;
参照视图
@property (nonatomic, readonly, copy) NSArray* behaviors;
添加到物理仿真器中的所有物理仿真行为
@property (nonatomic, readonly, getter = isRunning) BOOL running;
是否正在进行物理仿真
@property (nonatomic, assign) id <UIDynamicAnimatorDelegate> delegate;
代理对象（能监听物理仿真器的仿真过程，比如开始和结束）
代码
演示效果小应用的实现代码
#import "HMViewController.h"

@interface HMViewController ()
/**
 *  红色view
 */
@property (weak, nonatomic) IBOutlet UIView *redView;
/**
 *  物理仿真器
 */
@property (nonatomic, strong) UIDynamicAnimator *anim;

@property (weak, nonatomic) IBOutlet UISegmentedControl *st;
@end

@implementation HMViewController

- (UIDynamicAnimator *)anim
{
    if (!_anim) {
        _anim = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
    }
    return _anim;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
//    [self test];
//    [self test2];
    [self test3:touches];
}

-(void)test3:(NSSet *)touches
{
    // 1.获取当前触摸的手指
    UITouch *touch = [touches anyObject];
    // 2.更具手指取出位置
    CGPoint point = [touch locationInView:touch.view];

    // 吸附行为
    // 1.创建物理仿真器
    // 2.创建物理仿真行为
    UISnapBehavior *snapB = [[UISnapBehavior alloc] initWithItem:self.redView snapToPoint:point];

    // 设置吸附行为的"减震"
    snapB.damping = 0;

    // 注意: 吸附行为默认只能吸附一次, 如果多次吸附必须从仿真器中移除再重新添加
    [self.anim removeAllBehaviors];

    // 3.将物理仿真行为添加到仿真器中
    [self.anim addBehavior:snapB];
}

- (void)test2
{
    // 碰撞
    // 1.创建物理仿真器
    // 2.创建物理仿真行为
    UIGravityBehavior *gravigtyB = [[UIGravityBehavior alloc] initWithItems:@[self.redView]];
    //    gravigtyB.magnitude = 100;

    // 创建碰撞仿真行为
    UICollisionBehavior *collisionB = [[UICollisionBehavior alloc] initWithItems:@[self.redView, self.st]];
    // 设置碰撞的边界
    //    collisionB.translatesReferenceBoundsIntoBoundary = YES;

    // 添加直线边界
    //    [collisionB addBoundaryWithIdentifier:@"line" fromPoint:CGPointMake(0, 200) toPoint:CGPointMake(320, 420)];

    // 添加图形的边界
    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:self.view.frame];
    [collisionB addBoundaryWithIdentifier:@"abc" forPath:path];


    // 3.将物理仿真行为添加到仿真器中
    [self.anim addBehavior:gravigtyB];
    [self.anim addBehavior:collisionB];
}

/**
 *  重力
 */
- (void)test
{
    // 演示重力行为
    // 1.创建物理仿真器
    // 并且指定了当前控制器的view作为仿真范围
    //    UIDynamicAnimator *anim = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];

    // 2.创建物理仿真行为
    // 并且指定红色为作为仿真元素
    UIGravityBehavior *gravityB = [[UIGravityBehavior alloc] initWithItems:@[self.redView]];


    // 设置重力的方向
    //    gravityB.gravityDirection = CGVectorMake(1, 0);
    //    gravityB.gravityDirection = CGVectorMake(0, -1);
    //    gravityB.gravityDirection = CGVectorMake(1, 1);
    // 设置重力的角度
    //    gravityB.angle = M_PI_2;

    // 设置重力的加速度
    gravityB.magnitude = 100.0;

    // 3.将物理仿真行为添加到仿真器中
    [self.anim addBehavior:gravityB];
}
@end

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

android 圆形ListView实现，并附带圆角ImageView
转载请注明出处：王亟亟的大牛之路
平时 垂直向下的ListView已经司空见惯，换一种带一定角度的圆角ListView应该会给用户不同的体验
项目目录： 
 
2个自定义View一个主Activity 
MainActivity
public class MainActivity extends Activity {

    private ListView lv;
    //本地图片模拟数据源
    private int[] images = new int[] { R.drawable.p1, R.drawable.p2, R.drawable.p3 };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        lv = (ListView)findViewById(R.id.lv);
        lv.setAdapter(new MyAdapter(MakeData()));
        try {
            changeGroupFlag(lv);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //翻滚的过程中不断绘制
        lv.setOnScrollListener(new OnScrollListener() {
            @Override
            public void onScrollStateChanged(AbsListView view, int scrollState) {
            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                for (int i = 0; i < lv.getChildCount(); i++) {
                    lv.getChildAt(i).invalidate();
                }
            }
        });
        //监听事件，测试是否会出现item移位
        lv.setOnItemClickListener(new OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                Toast.makeText(MainActivity.this,"第"+position+"个被按到了", Toast.LENGTH_SHORT).show();
            }
        });
    }
    //自定义适配器
    class MyAdapter extends BaseAdapter {

        public final class ViewHolder{
        public ImageView imageView;
        public TextView text;
        }
        //传入的数据源
        private List<String> data;

        public MyAdapter(List<String> data){
            this.data=data;
        }

        @Override
        public int getCount() {
            return data.size();
        }

        @Override
        public Object getItem(int position) {
            return null;
        }

        @Override
        public long getItemId(int position) {
            return 0;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
             ViewHolder holder = null;
             if (convertView == null) {
                holder=new ViewHolder(); 
                MatrixView m = (MatrixView)LayoutInflater.from(MainActivity.this).inflate(R.layout.view_list_item, null);
                m.setParentHeight(lv.getHeight());
                convertView = m;
                holder.text=(TextView)convertView.findViewById(R.id.text);
                holder.imageView = (ImageView)convertView.findViewById(R.id.image);
                convertView.setTag(holder);
              }else {
                 holder = (ViewHolder)convertView.getTag();
              }
             holder.text.setText(data.get(position)+"");
             holder.imageView.setImageResource(images[position % images.length]);          
            return convertView;
        }

    }

    public void changeGroupFlag(Object obj) throws Exception// 反射替换对所有String进行替换
    {
        Field[] f = obj.getClass().getSuperclass().getSuperclass().getSuperclass().getDeclaredFields(); // 获得成员映射数组
        for (Field tem : f) // 迭代for循环
        {
            if (tem.getName().equals("mGroupFlags")) {
                tem.setAccessible(true);
                Integer mGroupFlags = (Integer)tem.get(obj); // 返回内容
                int newGroupFlags = mGroupFlags & 0xfffff8;
                tem.set(obj, newGroupFlags);// 替换成员值
            }
        }
    }

    private List<String> MakeData(){
        List<String> data=new ArrayList<String>();
        for(int k=0;k<100;k++){
            data.add("麦麦你好 "+k);
        }
        return data;
    }
}
自定义圆角图片
public class RoundImageView extends ImageView {

    private float xRadius = 10;
    private float yRadius = 10;
    private Paint paint = new Paint();

    public RoundImageView(Context context) {
        super(context);
    }

    public RoundImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public float getxRadius() {
        return xRadius;
    }

    public void setxRadius(float xRadius) {
        this.xRadius = xRadius;
    }

    public float getyRadius() {
        return yRadius;
    }

    public void setyRadius(float yRadius) {
        this.yRadius = yRadius;
    }

    @SuppressWarnings("deprecation")
    @Override
    protected void onDraw(Canvas canvas) {
        // java.lang.ClassCastException: android.graphics.drawable.TransitionDrawable cannot be cast
        // to android.graphics.drawable.BitmapDrawable
        BitmapShader shader;
        if (getDrawable() instanceof BitmapDrawable) {
            BitmapDrawable bitmapDrawable = (BitmapDrawable)getDrawable();
            // clip
            shader = new BitmapShader(bitmapDrawable.getBitmap(), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
            RectF rect = new RectF(0.0f, 0.0f, getWidth(), getHeight());
            int width = bitmapDrawable.getBitmap().getWidth();
            int height = bitmapDrawable.getBitmap().getHeight();
            RectF src = null;
            if (((float)width) / height > 1) {
                src = new RectF(0.0f, 0.0f, height, height);
            } else {
                src = new RectF(0.0f, 0.0f, width, width);
            }
            Matrix matrix = canvas.getMatrix();
            matrix.setRectToRect(src, rect, Matrix.ScaleToFit.CENTER);
            shader.setLocalMatrix(matrix);

            // 抗锯齿
            paint.setAntiAlias(true);
            paint.setShader(shader);
            // draw round circle for HeadImage or other
            canvas.drawRoundRect(rect, this.getWidth() / 2, this.getHeight() / 2, paint);
            // canvas.drawRoundRect(rect, xRadius, yRadius / 2, paint);
        }
    }
}
自定义布局
public class MatrixView extends LinearLayout {
    private int h = 0;
    private float fullAngelFactor = 10f;
    private float fullScaleFactor=1;
    public MatrixView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public void setParentHeight(int height) {
        h = height;
    }

    @Override
    protected void dispatchDraw(Canvas canvas) {
        canvas.save();
        int top = getTop();

        float rotate = calculateAngel(top, h);
        float scale = calcuylateScale(top, h);

        Matrix m = canvas.getMatrix();
        m.preTranslate(-2 / getWidth(), -2 / getHeight());
        m.postScale(scale, scale);
        m.postTranslate(2 / getWidth(), 2 / getHeight());
        m.postRotate(rotate);
        canvas.concat(m);
        super.dispatchDraw(canvas);
        canvas.restore();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }

    private float calculateAngel(int top, int h) {
        float result = 0f;
        if (top < h / 2f) {
            result = (top - (h / 2f)) / (h / 2f) * fullAngelFactor;
        } else if (top > h / 2f) {
            result = (top - (h / 2f)) / (h / 2f) * fullAngelFactor;
        }
        return result;
    }

    private float calcuylateScale(int top, int h) {
        float result = 0f;

        result = (1f - 1f/2f*Math.abs((top - h / 2f)) / (h / 2f)) * fullScaleFactor;
        return result;

    }
}

private float fullAngelFactor 为旋转的角度 
 private float fullScaleFactor 为试图放大缩小的比例
private float fullAngelFactor=40f时：
主布局就补贴了，就是一个ListView
每一个Item
<?xml version="1.0" encoding="utf-8"?>
<com.wjj.test.MatrixView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal" >

    <com.wjj.test.RoundImageView
        android:id="@+id/image"
        android:layout_width="80dp"
        android:layout_height="80dp"
        android:layout_marginLeft="30dp"
        android:scaleType="centerCrop" />

    <TextView
        android:id="@+id/text"
        android:layout_width="match_parent"
        android:layout_height="80dp"
        android:gravity="left|center_vertical"
        android:paddingLeft="20dp"
        android:textSize="18sp" />

</com.wjj.test.MatrixView>
具体实现可以看代码，附上源码下载地址：http://yunpan.cn/cmy9fi3fMDY7U  访问密码 0982
部分代码来源于互联网，如有重复请见谅

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        RecyclerView 列表控件中简单实现时间线
时间
时间，时间，时间啊；走慢一点吧～
看见很多软件中都有时间线的东西，貌似天气啊，旅游啊什么的最多了；具体实现方式很多，在本篇文章中讲解一种自定义View封装的方式。
效果
先来看看效果。 

分析
软件中，可以看见前面的时间线也就是线条加上圆圈组成；当然这里的圆圈与线条也都是可以随意换成其他的，比如图片等等。
当然这里最简单的来说，是上面一个线条，然后一个圆圈，然后下面一个线条；上线条在第一条数据时不做显示，下线条在最后一条数据时不做显示。

这里自定义布局部分也就是把旁边的线条与圆圈封装到一起，并使用简单的方法来控制是否显示。 
当封装好了后，与旁边的文字部分也就是水瓶方向的线性布局了，然后设置为每一个的RecyclerView 的Item的布局也就完成了。
控件
控件很简单，首先我们继承View，取名为 TimeLineMarker 就OK。
Attrs 属性
开始控件之前先准备好需要的属性。
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="TimeLineMarker">
        <attr name="markerSize" format="dimension" />
        <attr name="marker" format="color|reference" />
        <attr name="beginLine" format="color|reference" />
        <attr name="endLine" format="color|reference" />
        <attr name="lineSize" format="dimension" />
    </declare-styleable>
</resources>
在这里也就准备了线条的大小、开始线条、结束线条、中间标示部分及大小。
属性与现实
    private int mMarkerSize = 24;
    private int mLineSize = 12;
    private Drawable mBeginLine;
    private Drawable mEndLine;
    private Drawable mMarkerDrawable;

    @Override
    protected void onDraw(Canvas canvas) {
        if (mBeginLine != null) {
            mBeginLine.draw(canvas);
        }

        if (mEndLine != null) {
            mEndLine.draw(canvas);
        }

        if (mMarkerDrawable != null) {
            mMarkerDrawable.draw(canvas);
        }

        super.onDraw(canvas);
    }
两个大小属性，3个具体的Drawable，然后在onDraw方法中进行具体的显示也就OK。
构造与属性初始化
在上面我们定义了属性，在这里我们在构造函数中获取XML所设置的属性。

    public TimeLineMarker(Context context) {
        this(context, null);
    }

    public TimeLineMarker(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public TimeLineMarker(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init(attrs);
    }

    private void init(AttributeSet attrs) {
        // Load attributes
        final TypedArray a = getContext().obtainStyledAttributes(
                attrs, R.styleable.TimeLineMarker, 0, 0);

        mMarkerSize = a.getDimensionPixelSize(
                R.styleable.TimeLineMarker_markerSize,
                mMarkerSize);

        mLineSize = a.getDimensionPixelSize(
                R.styleable.TimeLineMarker_lineSize,
                mLineSize);

        mBeginLine = a.getDrawable(
                R.styleable.TimeLineMarker_beginLine);

        mEndLine = a.getDrawable(
                R.styleable.TimeLineMarker_endLine);

        mMarkerDrawable = a.getDrawable(
                R.styleable.TimeLineMarker_marker);

        a.recycle();

        if (mBeginLine != null)
            mBeginLine.setCallback(this);

        if (mEndLine != null)
            mEndLine.setCallback(this);

        if (mMarkerDrawable != null)
            mMarkerDrawable.setCallback(this);
    }
Drawable 的位置与大小初始化
属性啥的有了，具体的Drawable 也有了，要显示的地方调用也是OK了；但是如果没有进行进行具体的位置调整这一切也都没有意义。
    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        initDrawableSize();
    }

    private void initDrawableSize() {
        int pLeft = getPaddingLeft();
        int pRight = getPaddingRight();
        int pTop = getPaddingTop();
        int pBottom = getPaddingBottom();

        int width = getWidth();
        int height = getHeight();

        int cWidth = width - pLeft - pRight;
        int cHeight = height - pTop - pBottom;

        Rect bounds;

        if (mMarkerDrawable != null) {
            // Size
            int markerSize = Math.min(mMarkerSize, Math.min(cWidth, cHeight));
            mMarkerDrawable.setBounds(pLeft, pTop,
                    pLeft + markerSize, pTop + markerSize);

            bounds = mMarkerDrawable.getBounds();
        } else {
            bounds = new Rect(pLeft, pTop, pLeft + cWidth, pTop + cHeight);
        }


        int halfLineSize = mLineSize >> 1;
        int lineLeft = bounds.centerX() - halfLineSize;

        if (mBeginLine != null) {
            mBeginLine.setBounds(lineLeft, 0, lineLeft + mLineSize, bounds.top);
        }

        if (mEndLine != null) {
            mEndLine.setBounds(lineLeft, bounds.bottom, lineLeft + mLineSize, height);
        }
    }
initDrawableSize 方法进行具体的运算，而运算的时间点就是当控件的大小改变（onSizeChanged）的时候。
在初始化中采用了一定的投机取巧；这里利用了上内边距与下内边距分别作为上线条与下线条的长度；而线条与中间的标识都采用了水平距中。
其他设置方法

    public void setLineSize(int lineSize) {
        if (mLineSize != lineSize) {
            this.mLineSize = lineSize;
            initDrawableSize();
            invalidate();
        }
    }

    public void setMarkerSize(int markerSize) {
        if (this.mMarkerSize != markerSize) {
            mMarkerSize = markerSize;
            initDrawableSize();
            invalidate();
        }
    }

    public void setBeginLine(Drawable beginLine) {
        if (this.mBeginLine != beginLine) {
            this.mBeginLine = beginLine;
            if (mBeginLine != null) {
                mBeginLine.setCallback(this);
            }
            initDrawableSize();
            invalidate();
        }
    }

    public void setEndLine(Drawable endLine) {
        if (this.mEndLine != endLine) {
            this.mEndLine = endLine;
            if (mEndLine != null) {
                mEndLine.setCallback(this);
            }
            initDrawableSize();
            invalidate();
        }
    }

    public void setMarkerDrawable(Drawable markerDrawable) {
        if (this.mMarkerDrawable != markerDrawable) {
            this.mMarkerDrawable = markerDrawable;
            if (mMarkerDrawable != null) {
                mMarkerDrawable.setCallback(this);
            }
            initDrawableSize();
            invalidate();
        }
    }
在设置中，首先判断是否更改，如果更改那么就更新并重新计算位置；随后刷新界面。

到这里，控件差不多准备OK了，其中还有很多可以完善的地方，比如加上快捷设置颜色什么的，也可以加上大小计算的东西。同时还可以加上时间线是水瓶还是垂直等等。在这里就不累赘介绍哪些了。下面来看看如何使用。

使用
XML布局
ITEM布局item_time_line.xml
<?xml version="1.0" encoding="utf-8"?>

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:paddingLeft="@dimen/lay_16"
    android:paddingRight="@dimen/lay_16"
    tools:ignore="MissingPrefix">

    <net.qiujuer.example.timeline.widget.TimeLineMarker
        android:id="@+id/item_time_line_mark"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:paddingBottom="@dimen/lay_16"
        android:paddingLeft="@dimen/lay_4"
        android:paddingRight="@dimen/lay_4"
        android:paddingTop="@dimen/lay_16"
        app:beginLine="@color/black_alpha_32"
        app:endLine="@color/black_alpha_32"
        app:lineSize="2dp"
        app:marker="@drawable/ic_timeline_default_marker"
        app:markerSize="24dp" />

    <TextView
        android:id="@+id/item_time_line_txt"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:paddingBottom="@dimen/lay_16"
        android:paddingLeft="@dimen/lay_4"
        android:paddingRight="@dimen/lay_4"
        android:paddingTop="@dimen/lay_16"
        android:textColor="@color/grey_600"
        android:textSize="@dimen/font_16" />

</LinearLayout>
在这里我们之间使用顺序布局，左边是TimelIne控件，右边是一个简单的字体控件，具体使用中可以细化一些。 
在TImeLine控件中我们的Mark是使用的drawable/ic_timeline_default_marker；这个就是一个简单的圆圈而已；对于自己美化可以使用一张图片代替或者更加复杂的布局；当然上面的线条就更加简单了，就直接使用颜色代替。
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="@color/cyan_500" />
    <stroke
        android:width="1dp"
        android:color="@color/black_alpha_32" />
</shape>
主界面XML RecyclerView
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity">

    <android.support.v7.widget.RecyclerView
        android:id="@+id/time_line_recycler"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:clickable="true"
        android:fadeScrollbars="true"
        android:fadingEdge="none"
        android:focusable="true"
        android:focusableInTouchMode="true"
        android:overScrollMode="never"
        android:scrollbarSize="2dp"
        android:scrollbarThumbVertical="@color/cyan_500"
        android:scrollbars="vertical" />

</RelativeLayout>
在这里就是加上了一个RecyclerView 控件在主界面就OK。
Java代码部分
在开始之前先来看看我们的文件具体有些神马。 


widget中就是具体的自定义控件，model是具体的数据模型，adapter部分，这里有一个Recyclerview的adapter文件，以及一个具体的Item TimeLineViewHolder，当然在这里还定义了一个ItemType类，该类用来标示每个Item的类型，比如头部，第一个，普通，最后一个，底部等等。

TimeLineModel.java
package net.qiujuer.example.timeline.model;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineModel {
    private String name;
    private int age;

    public TimeLineModel() {

    }

    public TimeLineModel(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }
}

一个名字，一个年龄也就OK。
ItemType.java
package net.qiujuer.example.timeline.adapter;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class ItemType {
    public final static int NORMAL = 0;

    public final static int HEADER = 1;
    public final static int FOOTER = 2;

    public final static int START = 4;
    public final static int END = 8;

    public final static int ATOM = 16;
}

分别定义了几个静态值，分别代表普通、头部、底部、开始、结束、原子；当然其中有些可以不用定义。
TimeLineViewHolder.java
package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.View;
import android.widget.TextView;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;
import net.qiujuer.example.timeline.widget.TimeLineMarker;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineViewHolder extends RecyclerView.ViewHolder {
    private TextView mName;

    public TimeLineViewHolder(View itemView, int type) {
        super(itemView);

        mName = (TextView) itemView.findViewById(R.id.item_time_line_txt);

        TimeLineMarker mMarker = (TimeLineMarker) itemView.findViewById(R.id.item_time_line_mark);
        if (type == ItemType.ATOM) {
            mMarker.setBeginLine(null);
            mMarker.setEndLine(null);
        } else if (type == ItemType.START) {
            mMarker.setBeginLine(null);
        } else if (type == ItemType.END) {
            mMarker.setEndLine(null);
        }

    }

    public void setData(TimeLineModel data) {
        mName.setText("Name:" + data.getName() + " Age:" + data.getAge());
    }
}

该文件为RecyclerView 的Adapter中每个Item需要实现的Holder类。 
在该类中，我们在构造函数中需要传入一个根View同时传入一个当然item的状态。 
随后使用find….找到控件，在这里我们把TextView保存起来，而TimeLineView找到后直接进行初始化设置。 
根据传入的ItemType来判断是否是第一个，最后一个，以及原子；然后设置TimeLineView的属性。 
在下面的setData方法中我们显示具体的Model数据。
TimeLineAdapter.java
适配器部分，我们需要做的工作是；根据具体的数据渲染上对应的界面就OK。
package net.qiujuer.example.timeline.adapter;

import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import net.qiujuer.example.timeline.R;
import net.qiujuer.example.timeline.model.TimeLineModel;

import java.util.List;

/**
 * Created by qiujuer
 * on 15/8/23.
 */
public class TimeLineAdapter extends RecyclerView.Adapter<TimeLineViewHolder> {
    private List<TimeLineModel> mDataSet;

    public TimeLineAdapter(List<TimeLineModel> models) {
        mDataSet = models;
    }

    @Override
    public int getItemViewType(int position) {
        final int size = mDataSet.size() - 1;
        if (size == 0)
            return ItemType.ATOM;
        else if (position == 0)
            return ItemType.START;
        else if (position == size)
            return ItemType.END;
        else return ItemType.NORMAL;
    }

    @Override
    public TimeLineViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        // Create a new view.
        View v = LayoutInflater.from(viewGroup.getContext())
                .inflate(R.layout.item_time_line, viewGroup, false);
        return new TimeLineViewHolder(v, viewType);
    }

    @Override
    public void onBindViewHolder(TimeLineViewHolder timeLineViewHolder, int i) {
        timeLineViewHolder.setData(mDataSet.get(i));
    }

    @Override
    public int getItemCount() {
        return mDataSet.size();
    }
}

在这里需要着重说一下：我复写了getItemViewType方法；在该方法中我们需要设置对应的Item的类型；在这里传入的是item的坐标，需要返回的是item的具体状态，该状态标示是int类型；在这里我使用的是ItemType的静态属性。
该方法会在调用onCreateViewHolder方法之前调用；而onCreateViewHolder方法中的第二个参数int值也就是从getItemViewType之中来；所以我们可以在这里进行对应的数据状态标示。
而在onCreateViewHolder方法中我们返回一个：TimeLineViewHolder就OK，随后在onBindViewHolder方法中进行数据初始化操作。

MainActivity.java
上面所有都准备好了，下面就进行具体的显示。 
在这里就只贴出核心代码了；篇幅也是有些长。

    private RecyclerView mRecycler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mRecycler = (RecyclerView) findViewById(R.id.time_line_recycler);
        initRecycler();
    }

    private void initRecycler() {
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);

        TimeLineAdapter adapter = new TimeLineAdapter(getData());

        mRecycler.setLayoutManager(layoutManager);
        mRecycler.setAdapter(adapter);
    }

    private List<TimeLineModel> getData() {
        List<TimeLineModel> models = new ArrayList<TimeLineModel>();

        models.add(new TimeLineModel("XiaoMing", 21));
        models.add(new TimeLineModel("XiaoFang", 20));
        models.add(new TimeLineModel("XiaoHua", 25));
        models.add(new TimeLineModel("XiaoA", 22));
        models.add(new TimeLineModel("XiaoNiu", 23));

        return models;
    }
在这里就是傻瓜的操作了，流程就是准备好对应的数据，装进Adapter，准备好对应的布局方式，然后都设置到RecyclerView中就OK。
效果
来看看具体的效果： 

效果虽然简单，但是也算是五脏具全；其中无非就是控件的自定义。这个自定义是可以扩展的，大家可以扩展为水平方向试试。
代码
博客代码都开源到项目中了。 
地址：https://github.com/qiujuer/BeFoot/tree/master/blog/sample/TimeLine
写在最后
文章的开始截屏来源于：最近没事儿捣鼓了一个APP［UPMiss］，一个简单的生日，纪念日提醒软件；欢迎大家尝鲜。
｛UPMiss｝ 思念你的夏天 
下载地址：

魅族
百度 这个审核有问题，明明没有支付的东西，结果说有支付的SDK存在，不得不说百度的自动审核有很大漏洞。
豌豆荚 新版2.0还在审核中！

======================================================== 
作者：qiujuer 
博客：blog.csdn.net/qiujuer 
网站：www.qiujuer.net 
开源库：github.com/qiujuer/Genius-Android 
开源库：github.com/qiujuer/Blink 
转载请注明出处：http://blog.csdn.net/qiujuer/article/details/47910185 
—— 学之开源，用于开源；初学者的心态，与君共勉！
========================================================

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        IOS不用AutoLayout也能实现自动布局的类(4)----MyTableLayout横空出世
       前面的几篇文章里我分别介绍了线性布局(MyLinearLayout)，相对布局(MyRelativeLayout)，框架布局(MyFrameLayout)这三种布局。这三种布局中
 ：
线性布局主要应用于容器视图里面的所有子视图依次从上往下排列或者从左往右排列的场景。


垂直线性布局


子视图1


子视图2


子视图3


子视图4





水平线性布局


子视图1
子视图2
子视图3
子视图4




当然我们也可以用线性布局嵌套线性布局的方法来实现一些复杂的界面布局，比如(这个例子如果用MyTableLayout实现将更加简单)：




复杂布局






水平线性布局子视图1
水平线性布局子视图2











子视图1
子视图2
子视图3











子视图1


子视图2


子视图3









相对布局主要用于容器视图中的各个子视图之间的位置和高宽以及子视图和容器视图之间具有一定的依赖和约束关系的场景。比如说子视图1的位置在子视图2的右下角，并且宽度等于子视图3的宽度，而子视图3的底部又在容器视图的底部。
           

相对布局


子视图1(等宽3)
 
 


 
子视图2
 


 
 
子视图3(等宽1)



相对布局因为需要指定各子视图之间的依赖关系，因此如果设置不当就会产生递归死循环的情况，而且在某种程度上不利于子视图之间的位置的更新和变化等等，其中IOS自带的AutoLayout其实就是一套相对布局的实现，相对布局功能很强大也可以很容易布局复杂的界面，缺点是使用不当的话就容易造成约束死循环的情况。


框架布局主要用于容器视图中的个子视图在容器视图的上，中，下，左，中，右，拉升填充，居中显示等11种情况。


框架布局


左上
中上
右上


左中
居中
右中


左下
中下
右下




框架布局中的子视图只跟容器视图之间产生关系，子视图之间没有任何关联关系。


一、表格布局的介绍


    在一些实际的应用界面中，我们希望我们的子视图以表格的形式展示出来，这些表格展示可以是正规的几行几列并且固定高宽的形式，也可能是每一行的列数都不同，也可能是每行的高度不一样，也可能是一行内的各列的宽度也不一样，


               水平表格布局
                                                                                                                           
            
                                                                                                                                                 垂直表格布局










































要实现上面的两种界面风格，我们可以借助MyTableLayout来实现。


MyTableLayout是从MyLinearLayout中继承而来，因此表格布局也分为垂直表格布局和水平表格布局，样式请参考上面的图例的展示风格。而表格的风格样式同样通过
orientation属性来设置。不管是垂直表格布局还是水平表格布局。我们在建立了表格布局视图并指定了表格风格后，我们首先的步骤是要为表格添加行(如果是水平表格其实就是添加列，下面如果为说明都是如此概念)，那这个步骤可以通过MyTableLayout的方法：



-(void)addRow:(CGFloat)rowHeight colWidth:(CGFloat)colWidth;
-(void)insertRow:(CGFloat)rowHeight colWidth:(CGFloat)colWidth atIndex:(NSInteger)rowIndex;


来实现，前者是往表格布局尾部添加一行，而后者则是在指定的位置插入一行。这里需要说明的参数是rowHeight,colWidth的意义，我们知道只要我们插入一行时我们总是需要指出插入的这一行的行高是多少，同时要指出插入的这行的列单元格的宽度是如何指定的(每列的宽度固定，还是有单元格自己指定等等)




 rowHeight
为-1时表示由最高的单元格视图决定本行高度，每个单元格视图需要自己设置高度；为0表示均分高度，单元格视图不需要设置高度；大于0表示固定高度，单元格视图不需要设置高度.




 colWidth 
为-2时表示每个单元格视图需要自己指定宽度，整体行宽和表格布局一致；为-1表示每个单元格视图需要自己指定宽度，整个行宽包裹所有子视图；为0表示均分宽度，这时候单元格视图不必设置宽度；大于0表示单元格视图固定宽度，这时候单元格视图可以不必设置宽度。

同时我们也提供了对行操作的其他方法：


//删除指定的行

-(void)removeRowAt:(NSInteger)rowIndex;
//交行两个行的内容
-(void)exchangeRowAt:(NSInteger)rowIndex1 withRow:(NSInteger)rowIndex2;

//得到行视图，从返回我们可以看出，我们调用插入行操作时，系统内部会自动建立一个MyLinearLayout线性布局视图作为行视图，如果是垂直表格则默认是水平线性布局，而如果是水平表格则默认是垂直线性布局，因此我们可以通过这个方法来设置行的其他的各种属性，比如说行间距(xxxMargin来实现)。
-(MyLinearLayout*)viewAtRowIndex:(NSInteger)rowIndex;

//返回当前有多少行
-(NSUInteger)countOfRow;




当我们插入了一行后，我们就需要为这一行添加单元格视图(列视图)，每一行都可以无限制的添加单元格视图，也就是说一行可以有很多的列，每一行的列数都可以不一样，我们可以通过如下的方法来添加或者删除列：



-(void)addCol:(UIView*)colView atRow:(NSInteger)rowIndex;
-(void)insertCol:(UIView*)colView atIndexPath:(NSIndexPath*)indexPath;
-(void)removeColAt:(NSIndexPath*)indexPath;
-(void)exchangeColAt:(NSIndexPath*)indexPath1 withCol:(NSIndexPath*)indexPath2;


注意上面的添加列时，需要指定在哪一行添加列，在添加列之前必须要把行添加进去，也就是说行索引rowIndex不能越界，为了简单的描述行索引和列索引的关系我们使用了NSIndexPath这个对象来描述，我们对NSIndexPath进行了扩展，以便用于方便的指定行和列的索引：



@interface NSIndexPath(MyTableLayoutEx)



+(instancetype)indexPathForCol:(NSInteger)col inRow:(NSInteger)row;




@property(nonatomic,assign,readonly)
NSInteger col;




@end






同时我们也方便的提供了单元格列视图的获取和数量的获取的方法


//返回列视图

-(UIView*)viewAtIndexPath:(NSIndexPath*)indexPath;

//返回指定行的列的数量。

-(NSUInteger)countOfColInRow:(NSInteger)rowIndex;




上面就是我们对表格布局的所有函数的介绍，使用起来也很简单，步骤就是先添加行，然后在每行中依次一个个的添加列视图，也就是单元格视图。


我们将分别建立两个风格的表格进行例子的说明。




二、垂直表格


   所谓垂直表格就是行是从上往下，一行一行布局起来的，所有行内的单元格视图都是从左往右一列一列布局起来的，建立垂直表格是默认的表格。先看界面布局效果。












我们分别建立了6行不同尺寸的表格，上可以看出每一行的列数不一样，每一行的高度不一样，每一行的总体列宽不一样，每一行的每一列的宽度都不一样，而这些我们都是通过在插入行时通过设置不同的rowHeight,colWidth来达到效果的。具体代码参考如下：


-(void)loadView
{
    [super loadView];
    
    /*
     有的时候我们希望让一个布局视图放入到非布局视图中去，但又希望布局视图的宽高和非布局父视图宽高一致。
     这时候我们可以设置height,width来指定自身的高宽，我们也可以通过leftMargin = 0,rightMargin = 0来让其跟父视图保持一样的宽度，但如果是这样的话还需要设置wrapContentWidth = NO. 设置高度同理。
     */
    MyTableLayout *tbll = [MyTableLayout new];
    tbll.wrapContentHeight = NO;  //对于线性布局来说必须要设置为NO才能高度和非布局的父视图一样高
    tbll.leftMargin = tbll.rightMargin = 0;  //宽度和非布局父视图一样宽
    tbll.topMargin = tbll.bottomMargin = 0;  //高度和非布局父视图一样高
    [self.view addSubview:tbll];

    
    //第一行固定高度固定宽度
    [tbll addRow:30 colWidth:30];
    [tbll viewAtRowIndex:0].backgroundColor = [UIColor colorWithWhite:0.1 alpha:1];
    
    UIView *colView = [UIView new];
    colView.leftMargin = 10; //可以使用leftMargin,topMargin,rightMargin,bottomMargin来调整间隔
    colView.topMargin = 5;
    colView.bottomMargin = 5;
    colView.rightMargin = 40;
    
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:0];
    
    colView = [UIView new];
    colView.leftMargin = 20;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:0];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:0];
    
    //第二行固定高度，均分宽度
    [tbll addRow:40 colWidth:0];
    [tbll viewAtRowIndex:1].backgroundColor = [UIColor colorWithWhite:0.2 alpha:1];

    
    colView = [UIView new];
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor yellowColor];
    [tbll addCol:colView atRow:1];
    
    //第三行固定高度，子视图自己决定宽度。
    [tbll addRow:30 colWidth:-1];
    [tbll viewAtRowIndex:2].backgroundColor = [UIColor colorWithWhite:0.3 alpha:1];
    colView = [UIView new];
    colView.width = 100;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:2];

    colView = [UIView new];
    colView.width = 200;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:2];
    
    //第四行固定高度，子视图自己决定宽度。
    [tbll addRow:30 colWidth:-2];
    [tbll viewAtRowIndex:3].backgroundColor = [UIColor colorWithWhite:0.4 alpha:1];
    colView = [UIView new];
    colView.width = 80;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:3];
    
    colView = [UIView new];
    colView.width = 200;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:3];
    
    //第五行高度均分.这里设置为0表示剩余高度再均分。宽度均分,
    [tbll addRow:0 colWidth:0];
    MyLinearLayout *row4 = [tbll viewAtRowIndex:4];
    //可以设置行的属性.比如padding, 线条颜色，
    row4.padding = UIEdgeInsetsMake(3, 3, 3, 3);
    row4.topBorderLine = [[MyBorderLineDraw alloc] initWithColor:[UIColor blackColor]];
    row4.topBorderLine.thick = 2;
    row4.backgroundColor = [UIColor colorWithWhite:0.5 alpha:1];

    colView = [UIView new];
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:4];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:4];
    
    //第六行高度由子视图决定，均分宽度
    [tbll addRow:-1 colWidth:0];
    [tbll viewAtRowIndex:5].backgroundColor = [UIColor colorWithWhite:0.6 alpha:1];
    
    colView = [UIView new];
    colView.height = 80;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:5];
    
    colView = [UIView new];
    colView.height = 120;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:5];
    
    colView = [UIView new];
    colView.height = 70;
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:5];





    
    
}

上面的代码中我们在插入行时分别为rowHeight,colWidth设置了6种不同的参数的组合，我们看到其中有些行中需要指定每个单元格的列宽和行高，而有的则不需要。是否需要单元格指定行高和列宽则是有rowHeight,colWidth的不同的参数值决定的。 有时候我们的表格可能需要指定行间距和列间距，而这些都可以通过行视图的xxMargin, 和列视图的xxxMargin的设置来进行个性化的定制，这里需要强调一下rowHeight,colWidth都等于0的情况，他们的意义是表示行和列会均分高度和宽度。


  举例来说，假设我们建立了一个宽高为100*100的表格布局，而我们第一行的rowHeight,colWidth设置为0时，则当插入第一行时则这一行的高度就是100，而这一行插入第一列时则这一列的宽度就是100，而如果再插入一列时则两列的宽度都会调整为50，同样当我们再次插入一行时则两行的高度都将会调整为50. （这个像不像HTML中的表格的行列的宽高指定的风格）








三、水平表格（瀑布流）


   所谓水平表格就是行是从左往右，一行一行布局起来的，所有行内的单元格视图都是从上往下一列一列布局起来的，建立水平表格需要将
orientation = LVORIENTATION_HORZ， 水平表格也就是一个瀑布流风格的表格，我们可以通过将表格放入到UIScrollView中进行从上到下的滚动以便展示所有内容。先看界面布局效果：









这个例子我们也跟上面一样，建立了6行(注意水平表格里面行的概念就是指列，而列则是指行)，同时我们把表格布局加入到了一个UIScrollView下，以便能有滚动的效果。我们为了延长表格的高度，我们对第三行的第三个单元格视图特意设置了一个很高的高度。代码如下：


-(void)loadView
{
    [super loadView];
    
    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds];
    scrollView.autoresizingMask =  UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
    [self.view addSubview:scrollView];
    
    
    
    /*
     有的时候我们希望让一个布局视图放入到非布局视图中去，但又希望布局视图的宽高和非布局父视图宽高一致。
     这时候我们可以设置height,width来指定自身的高宽，我们也可以通过leftMargin = 0,rightMargin = 0来让其跟父视图保持一样的宽度，但如果是这样的话还需要设置wrapContentWidth = NO. 设置高度同理。
     */
    MyTableLayout *tbll = [MyTableLayout new];
    tbll.orientation = LVORIENTATION_HORZ;
    tbll.wrapContentWidth = NO;  //对于线性布局来说必须要设置为NO才能宽度和非布局的父视图一样宽
    tbll.wrapContentHeight = YES; //这里设定高度由子视图决定。
    tbll.leftMargin = tbll.rightMargin = 0;  //宽度和非布局父视图一样宽
    [scrollView addSubview:tbll];
    
    
    //需要注意的是因为这里的表格设置为水平表格，所以下面所的行高，其实是行宽，而列宽，其实是列高
    
    
    //第一行固定高度固定宽度
    [tbll addRow:30 colWidth:30];
    [tbll viewAtRowIndex:0].backgroundColor = [UIColor colorWithWhite:0.1 alpha:1];
    
    UIView *colView = [UIView new];
    colView.leftMargin = 5; //可以使用leftMargin,topMargin,rightMargin,bottomMargin来调整间隔
    colView.topMargin = 5;
    colView.bottomMargin = 5;
    colView.rightMargin = 5;
    
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:0];
    
    colView = [UIView new];
    colView.topMargin = 20;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:0];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:0];
    
    //第二行固定高度，均分宽度
    [tbll addRow:40 colWidth:0];
    [tbll viewAtRowIndex:1].backgroundColor = [UIColor colorWithWhite:0.2 alpha:1];
    
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor yellowColor];
    [tbll addCol:colView atRow:1];
    
    //第三行固定高度，子视图自己决定宽度。
    [tbll addRow:30 colWidth:-1];
    [tbll viewAtRowIndex:2].backgroundColor = [UIColor colorWithWhite:0.3 alpha:1];
    colView = [UIView new];
    colView.height = 100;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:2];
    
    colView = [UIView new];
    colView.height = 200;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:2];
    
    colView = [UIView new];
    colView.height = 1000;
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:2];
    
    //第四行固定高度，子视图自己决定宽度。
    [tbll addRow:30 colWidth:-2];
    [tbll viewAtRowIndex:3].backgroundColor = [UIColor colorWithWhite:0.4 alpha:1];
    colView = [UIView new];
    colView.height = 80;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:3];
    
    colView = [UIView new];
    colView.height = 200;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:3];
    
    //第五行高度均分.这里设置为0表示剩余高度再均分。宽度均分,
    [tbll addRow:0 colWidth:0];
    MyLinearLayout *row4 = [tbll viewAtRowIndex:4];
    //可以设置行的属性.比如padding, 线条颜色，
    row4.padding = UIEdgeInsetsMake(3, 3, 3, 3);
    row4.leftBorderLine = [[MyBorderLineDraw alloc] initWithColor:[UIColor blackColor]];
    row4.leftBorderLine.thick = 2;
    row4.backgroundColor = [UIColor colorWithWhite:0.5 alpha:1];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:4];
    
    colView = [UIView new];
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:4];
    
    //第六行高度由子视图决定，均分宽度
    [tbll addRow:-1 colWidth:0];
    [tbll viewAtRowIndex:5].backgroundColor = [UIColor colorWithWhite:0.6 alpha:1];
    
    colView = [UIView new];
    colView.width = 80;
    colView.backgroundColor = [UIColor redColor];
    [tbll addCol:colView atRow:5];
    
    colView = [UIView new];
    colView.width = 120;
    colView.backgroundColor = [UIColor greenColor];
    [tbll addCol:colView atRow:5];
    
    colView = [UIView new];
    colView.width = 70;
    colView.backgroundColor = [UIColor blueColor];
    [tbll addCol:colView atRow:5];
    
    
    
    
    
    
}

这段代码的内容和上面的垂直表格相似，只是把一些原来的宽度值改为了高度值而已。


四、总结
    好了，表格布局的内容就介绍到这里了，表格布局的内部实现其实就是一个线性布局套线性布局的封装，但是他简化了我们插入视图的方法，从而很容易的布局出各种风格的布局，我们可以从上往下依次布局，也可以从左往右依次布局。如果您觉得这篇文章能够帮助到您，或者能成为您界面布局的解决方案，那么请到我的github：


https://github.com/youngsoft/MyLinearLayout 中下载这套界面解决框架库，如果您觉得好用就记得给我点赞哦，如果有什么不明确的可以加我QQ:156355113联系我。



































版权声明：本文为博主原创文章，未经博主允许不得转载。

(素材源码) 猫猫学iOS 之UIDynamic重力、弹性碰撞吸附等现象牛逼Demo
猫猫分享，必须精品
原创文章，欢迎转载。转载请注明：翟乃玉的博客 
地址：http://blog.csdn.net/u013357243
一：效果
 
 
 
 

二：代码
#import "ViewController.h"
#import "DemoViewController.h"

@interface ViewController ()
{
    // 功能名称的数组
    NSArray *_functions;
}

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    _functions = @[@"吸附行为", @"推动行为", @"刚性附加行为", @"弹性附加行为", @"碰撞检测"];
}

#pragma mark - 数据源方法
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return _functions.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 使用Storyboard建立的UITabeViewController，其中的Cell是已经注册过的
    static NSString *ID = @"Cell";
    // 永远都会找到一个单元格，如果缓冲池中没有，会自动新建
    /**
     dequeueReusableCellWithIdentifier 直接查询可重用单元格
     dequeueReusableCellWithIdentifier:forIndexPath: 查询“注册的”可重用单元格，此方法中indexPath本身没有用处

        * 强制判断是否注册了单元格

     如果已经注册过单元格，以上两个方法等效。

     如果在StoryBoard中指定了单元格的可重用标示符，单元格的优化将有系统接管，不再需要判断cell == nil
     */
//    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID forIndexPath:indexPath];

//    if (cell == nil) {
//        NSLog(@"come here");
//        
//        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];
//    }

    cell.textLabel.text = _functions[indexPath.row];

    return cell;
}

#pragma mark - 代理方法
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    DemoViewController *controller = [[DemoViewController alloc] init];

    // 指定标题
    controller.title = _functions[indexPath.row];
    controller.function = indexPath.row;

    [self.navigationController pushViewController:controller animated:YES];
}

#import "DemoViewController.h"
#import "DemoView.h"
#import "SnapView.h"
#import "PushView.h"
#import "AttachmentView.h"
#import "SpringView.h"
#import "CollisionView.h"

@interface DemoViewController ()

@end

@implementation DemoViewController

//- (void)loadView
//{
//    self.view = [[DemoView alloc] initWithFrame:[UIScreen mainScreen].applicationFrame];
//}

- (void)viewDidLoad
{
    [super viewDidLoad];

    NSLog(@"功能代号： %d", self.function);
    // 在此根据实际的功能代号加载实际的视图

    DemoView *demoView = nil;
    switch (self.function) {
        case kDemoFunctionSnap:
            demoView = [[SnapView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionPush:
            demoView = [[PushView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionAttachment:
            demoView = [[AttachmentView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionSpring:
            demoView = [[SpringView alloc] initWithFrame:self.view.bounds];
            break;
        case kDemoFunctionCollision:
            demoView = [[CollisionView alloc] initWithFrame:self.view.bounds];
            break;
        default:
            break;
    }

    [self.view addSubview:demoView];
}


@end

主要框框就这样啦，贴出了的代码仅仅部分
三：素材代码下载地址
代码上传中。。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

无需Root也能Hook？——Depoxsed框架演示


之前我们介绍过rovo89在Githu上的Xposed框架，我们也介绍了如何使用Xposed框架进行
登录劫持，和广告注入。
但是，之后很多朋友都在问我，这个Xposed框架使用起来很确实很好用。可是就是有一
个巨大的缺点，就是需要Root权限。很多设备都没有Root权限，有没有一个不需要Root
权限的Hook框架。
答案是，确定的。就是目前的Alibab的开源框架，Dexposed框架。
github地址 ： https://github.com/alibaba/dexposed

Dexposed
它的官方介绍如下：

它基于ROOT社区著名开源项目Xposed改造剥离了ROOT部分，演化为服务于所在应用自

身的AOP框架，并在Apache 2.0协议下开源。

Xposed是XDA社区用户rovo89开发并管理的一个项目，它通过修改Android 
  Dalvik运行时的Zygote进程，使用Xposed 
  Bridge将第三方代码注入到Android应用的方法调用中，实现非侵入式的在运行期动态

修改系统和应用行为的能力。
Dexposed的原理也是很简单，如它介绍中所说的。它是Xposed框架剥离掉了Root部分的
功能。

不熟悉Xposed原理的，可以看这里

http://blog.csdn.net/yzzst/article/details/47659987
没有Root权限，那么Xposed框架式无法替换app_process的，当然也就无法进行整个系统
级应用程序的注入了。当然，对自我程序本身还是没有问题的。
目前Dexposed的主要应用场景有以下几种：

AOP编程 
插桩 (如测试、性能监控等) 
在线热补丁 
SDK hooking以提供更好的开发体验


AOP为Aspect Oriented 
  Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程

序功能的统一维护的一种技术。
看到这里，很多小伙伴估计都会产生疑问，我靠，不能进行登录劫持了，不能注入广告
了。我用你来干什么。/(ㄒoㄒ)/~


AOP编程，在线热补丁
没错，Dexposed框架主要的功能，还是提供作为AOP框架使用。这么一来的话，我们之前
也介绍过Android的插件实现方式。这里我们所用Dexposed框架来实现的话，插件模型将
会更加简单。
首先先介绍一下，Dexposed框架也提供了一个与Xposed框架类似的方法。

/**
  * 该系统是否支持hook
  */
public static synchronized boolean canDexposed(Context context)

/**
  * 寻找并hook一个指定的方法
  * @param clazz 类的class
  * @param methodName hook的方法名称
  * @param parameterTypesAndCallback 参数和返回callback
  * @return 
  */
public static Unhook findAndHookMethod(Class<?> clazz, String methodName, Object... parameterTypesAndCallback)

在线热补丁实例
如何进行在线的热补丁呢？我们这里以alibaba的demo为例。
如在主线版本中，我们有一个showDialog方法。已经发布出去了。但是，突然发现有一
点bug或者突发性需求，我们不能够理解的发版更新。

这里就能够通过之前我们所说的DexClassLoader的方式，载入线上的插件Path.apk

。 
 2. 通过Dexposed框架，动态的Hook并替换主线版本中的showDialog函数方法。
具体的逻辑如下图所示：

看到上面的效果说明图之后，相信大家对Dexposed的在线热补丁已经有一定的了解了。
这里我们也不用做过多的赘述。
当然，你可能想到很多使用热补丁的应用方向，比如：

Bug补丁修复
插件功能 
等等

Dexposed框架原理很简单，功能也算不上强大。但是，确实特别实用。我也是推荐各大
Android开发者，特别是创业公司使用。是墙裂推荐！！

下面是主工程中与补丁工程中的逻辑实现。这里，童鞋们可以对比着效果图看一下。

如果大家对动态的使用DexClassLoader载入一个apk代码还存在疑问。 可以clone一下

dexposed的源码学习学习。

当然，这里还是推荐大家去我的博客看看，Android的插件原理。 
  地址：http://blog.csdn.net/yzzst/article/details/45582315

主工程中，MainActivity showDialog方法的定义
public class MainActivity extends Activity {

    //..........一些忽略掉的代码

    private void showDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle("Dexposed sample")
                .setMessage("Please clone patchsample project to generate apk, and copy it to \"/Android/data/com.taobao.dexposed/cache/patch.apk\"")
                .setPositiveButton("ok", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int whichButton) {
                    }
                }).create().show();
    }
}
在线热补丁，Path.apk中的代码
/**
  * 插件的补丁类
  */
public class DialogPatch implements IPatch {

    @Override
    public void handlePatch(final PatchParam arg0) throws Throwable {       
        // 获取主程序的ClassLoader
        Class<?> cls = null;
        try {
            // 获取主程序的MainActivity类
            cls= arg0.context.getClassLoader().loadClass("com.taobao.dexposed.MainActivity");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return;
        }

        // hook并替换MainActivity中的showDialog方法
        DexposedBridge.findAndHookMethod(cls, "showDialog", new XC_MethodReplacement() {
            @Override
            protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {
                // 弹出一个插件中的Dialog
                Activity mainActivity = (Activity) param.thisObject;
                AlertDialog.Builder builder = new AlertDialog.Builder(mainActivity);
                builder.setTitle("Dexposed sample")
                        .setMessage("The dialog is shown from patch apk!")
                        .setPositiveButton("ok", new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int whichButton) {
                            }
                        }).create().show();
                return null;                 
            }
        });
    }

}
/*  
* @author zhoushengtao(周圣韬)  
* @since 2015年8月26日 凌晨0:08:22  
* @weixin stchou_zst  
* @blog http://blog.csdn.net/yzzst 
* @交流学习QQ群：341989536  
* @私人QQ：445914891  
/ 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：转载请标注：http://blog.csdn.net/yzzst 。 本文为博主原创文章，未经博主允许不得转载。

[置顶]
        AS1.3 及其以上预览版新插件－实验版（NDK）
序
在新版的AS预览版中我发现对于NDK的支持有所变化。 
在新的插件版本中加强了对NDK的支持以及性能的优化。 
于是查询了一下文档，特此写了该文章，为尝鲜的朋友准备，喜欢尝鲜的朋友可以试试，个人感觉味道不错。 
在之前版本的时候我写过如何在AS中编译NDK： 
 [Android] 环境配置之Android Studio开发NDK
本篇文章是一篇半翻译文章，来源于AS的说明文档，在文章底部会附上原文链接。 
本篇文章中的东西来源于预览版，本文章中的方法已测试有效；但不建议用于生产开发。
介绍
这是一个新的试验性插件，该组建基于新的Gradle组建模型；在配置上能显著减少时间。在新的插件中包括了使用JNI开发NDK的一键式操作。在本指南中提供了详细的使用方式，同时强调了新的插件与原始插件之间的区别。
警告：该插件是试验性插件。有关该插件的Gradle API也并不是最终版本。这意味着他只是特定版本的API，也可能只能在特定版本中使用。
此外。DSL可能发生大量改变，在最终版本中有可能采用新的API代替。
该实验插件是改善了NDK集成与性能相关的早期预览版本（这两个问题来自于用户反馈）。
需求

Gradle 2.5 （仅仅）
Android NDK R10e 版本（如果你需要使用NDK）
SDK 构建工具最低版本 19.0.0 ，一些功能可能需要更新的版本
AS 1.3 预览版及其更高版本

迁移
从之前版本迁移到最新预览版。在下面显示了新的预览版的项目结构，更改的地方使用红色表示。

./gradle/wrapper/gradle-wrapper.properties
新的插件仅仅只支持 gradle-2.5.

＃Wed Apr 10 15:27:10 PDT 2013 
  distributionBase=GRADLE_USER_HOME 
  distributionPath=wrapper/dists 
  zipStoreBase=GRADLE_USER_HOME 
  zipStorePath=wrapper/dists 
  distributionUrl=https://services.gradle.org/distributions/gradle-2.5-all.zip

./build.gradle
其中Classpath 应该配置为 com.android.tools.build:gradle-experimental 以前是  com.android.tools.build:gradle 
当前可使用版本为： 0.2.0.
// 提示: 顶层配置，你也可以在你的子项目或者子Model中添加对应配置

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle-experimental:0.2.0'

        // 提示: 别把项目所需依赖写在这里，他们属于Model中的 build.gradle 文件
    }
}

allprojects {
    repositories {
        jcenter()
    }
}
./app/build.gradle
在该插件中有着许多有关DSL变化。其中很多变化似乎有些奇葩，并不必要；因为在我看来插件变化应该尽量简单以减少插件迁移的代价。
DSL 变更:

Apply 默认插件名现在是 com.android.model.application 在之前的版本中是：com.android.application.  如果我们的Model是另外的库或者aar 那么现在应该为:  com.android.model.library
根配置应该加上 model { }  模块
大多属性应该加上 '='  操作符
如果是为集合添加对应的元素应该使用 '+=' 操作符

使得 DSL 更局限性的变更:

buildTypes, productFlavors 和 signingConfigs 配置必须写在 android { } 模块以外
能在 android { } 模块中嵌套使用的配置需要加上with 关键字.
属性也将只能使用所支持的直接属性，而没法使用其他类型而后进行转换（如果该属性是int类型，将只能输入int值，而不能是string字符然后强制转换）。例如: 
文件类型属性将直接接受文件类型，而不接受String类型。
不能直接使用 minSdkVersion 接受一个 int 或者 string 类型，而需要写为：minSdkVersion.apiLevel = 15.
创建一个buildType 或者 productFlavor 等标记需要调用 create方法.  修改一个现有的，如buildType中的release或者debug标记可以直接使用名称就可以了.
现在修改DSL 的变量或者任务是非常非常局限的. 


dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.2.0'
}
NDK 相关
在该实验插件中使用NDK创建Android本地程序。  你需要： 
使用下载工具下载 NDK 包并配置好环境. 
在项目local.properties 文件中设置 ndk.dir 变量并指定你的 NDK 路径，也可以在环境变量中设置 ANDROID_NDK_HOME 为你计算机上的 NDK 路径. 
在你的 model 中的 build.gradle 文件中添加 android.ndk 板块.  
已知局限

不支持NDK-only模块；仅仅支持混合的app或者lib库的项目编译。
编译项目时并不会重复编译已编译完成的JNI代码（AAR库中的所有so文件仅仅只是简单打包到APK中，不会进行重复编译）。
不支持创建可依赖静态库。
不支持使用诸如cpu_features 的NDK库。
不支持集成外部构建系统。

Model 中的 build.gradle 中的 NDK 配置诸如这样: 

提示：项目中的 moduleName 属性是必须的，它定义了 NDK 所生成的文件名。
默认情况下，JNI 文件应该放到项目的目录为：src/main/jni ，在其中你可以放C/C++代码；当然你也可以重新定义该默认目录。
model {
    android {
        compileSdkVersion = 22
        buildToolsVersion = "22.0.1"
    }
    android.ndk {
        moduleName = "native"
    }
    android.sources {
        main {
            jni {
                source {
                    srcDir 'src'
                }
            }
        }
    }
}
其他的编译属性你可以设置到android.ndk { } 模块中，诸如：
model {
    android {
        compileSdkVersion = 22
        buildToolsVersion = "22.0.1"
    }
    android.ndk {
        // 所有可以在 android.ndk 中定义的配置.
        moduleName = "native"
        toolchain = "clang"
        toolchainVersion = "3.5"

        // 提示：CFlags 是一个C的资源, 其命名与常规的属性并不一样.  这是一个技术限制，但在以后会解决。

        CFlags += "-DCUSTOM_DEFINE"
        cppFlags += "-DCUSTOM_DEFINE"
        ldFlags += "-L/custom/lib/path"
        ldLibs += "log"
        stl = "stlport_static"
    }
    android.buildTypes {
        release {
            ndk.with {
                debuggable = true
            }
        }
    }
    android.productFlavors {
        create("arm") {
            ndk.with {
                // 你可以在 productFlavors 和 buildTypes 节点中配置 NDK 相关的属性
                abiFilters += "armeabi-v7a"
            }
        }
        create("fat") {
            // 如果未指定 ndk.abiFilters 属性，那么将会生成所有的CPU版本ABI.
        }
    }

    // 你可以修改所有的 NDK 属性
    components.android {
        binaries.afterEach { binary ->
            binary.mergedNdkConfig.cppFlags.add(
                    "-DVARIANT=\"" + binary.name + "\"")
        }
    }
}

原文链接
需要梯子： 
http://tools.android.com/tech-docs/new-build-system/gradle-experimental
案例
这里有一些Google官方的案例，地址： 
https://github.com/googlesamples/android-ndk. 
我的博客中的案例会放到： 
https://github.com/qiujuer/BeFoot
======================================================== 
作者：qiujuer 
博客：blog.csdn.net/qiujuer 
网站：www.qiujuer.net 
开源库：github.com/qiujuer/Genius-Android 
开源库：github.com/qiujuer/Blink 
转载请注明出处：http://blog.csdn.net/qiujuer/article/details/47961763 
—— 学之开源，用于开源；初学者的心态，与君共勉！
========================================================

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Activity组件启动过程及ActivityManagerService(AMS)（一）
    在前面《Android启动过程》中提到了System进程启动ActivityManagerService服务，AMS是由Android提供的用于管理Activity（不仅仅指Activity，还包括其他三个组件）运行状态的系统进程，则是平时编写APK应用程序时使用得最频繁的一个系统服务。
    AMS是通过ActivityStack（和其它数据结构）来记录、管理系统中的Activity（和其它组件）状态，并提供查询功能的一个系统服务，负责启动和调度应用程序组件。



一、AMS功能概述
1、回到《Android启动过程》中提到的使用SystemServer中ServerThread来启动AMS服务：


/** @path: \frameworks\base\services\java\com\android\server\SystemServer.java */ 
class ServerThread extends Thread {
    @Override
    public void run() {
        ......   
        // Critical services...
        boolean onlyCore = false;
        try {
            // 创建Activity Manager实例
            context = ActivityManagerService.main(factoryTest);
             .....
            // 将AMS注册到ServiceManager中（前面分析提到这一步是在创建PMS实例之后才进行注册）
            ActivityManagerService.setSystemProcess();
        } catch (RuntimeException e) {
        }
    }
}


2、如前所述，其是通过调用ActivityManagerService#main函数来创建AMS实例及AMS线程：




/** @path \frameworks\base\services\java\com\android\server\am\ActivityManagerService.java **/ 
public final class ActivityManagerService extends ActivityManagerNative
    implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
  
    static ActivityManagerService mSelf;  
 
    public static final Context main(int factoryTest) {
        /** 创建一个AThread线程 ,这里用来创建AMS实例*/
        AThread thr = new AThread();
        thr.start();   // 启动AMS线程
 
        synchronized (thr) {
        /** 这里运来判断AMS是否启动成功，失败则一直等待 **/
            while (thr.mService == null) {
                try {
                  // 注意这里会wait，直至AThread中AMS创建完成，调用notiyAll方法才唤醒
                    thr.wait();
                } catch (InterruptedException e) {
                }
            }
        }
 
        // 将AThread中创建的AMS实例赋值给m,再赋值给AMS静态变量mSelf
        ActivityManagerService m = thr.mService;
        mSelf = m;
      
        /** AMS两个最重要核心——
         *  - ActivityStack：Activity的记录者与管理者，同时也为AMS管理系统运行情况提供了基础
         *  - ActivityTask**/
        ActivityThread at = ActivityThread.systemMain();
        mSystemThread = at;
        Context context = at.getSystemContext();
        context.setTheme(android.R.style.Theme_Holo);
        m.mContext = context;
        m.mFactoryTest = factoryTest;
        /** 创建一个ActivityStack对象 **/
        m.mMainStack = new ActivityStack(m, context, true); 
      
        m.mBatteryStatsService.publish(context);
        m.mUsageStatsService.publish(context);
      
        synchronized (thr) {
            thr.mReady = true;
            // 唤醒AMS线程
            thr.notifyAll();
        }
 
        /*** 开始运行  ***/
        m.startRunning(null, null, null, null);
      
        return context;
    }
  
    static class AThread extends Thread {
        ActivityManagerService mService;
        boolean mReady = false;
 
        public AThread() {
            super("ActivityManager");
        }
 
        public void run() {
        /** 创建消息Loopr循环 **/
            Looper.prepare();
 
            android.os.Process.setThreadPriority(
                    android.os.Process.THREAD_PRIORITY_FOREGROUND);
            android.os.Process.setCanSelfBackground(false);
 
            /** 在这里创建AMS实例，用以作为系统中的Activity管理服务 **/
            ActivityManagerService m = new ActivityManagerService();
 
            synchronized (this) {
                mService = m;
                // 这里唤醒前面等待的线程
                notifyAll();
            }
 
            synchronized (this) {
                while (!mReady) {
                    try {
                       // 创建完成后wait等待，直至System线程将其唤醒
                        wait();
                    } catch (InterruptedException e) {
                    }
                }
            }
            Looper.loop();
        }
    }
}

3、通过ActivityManagerService#setSystemProcess将AMS注册到ServiceManager中：


/** @path \frameworks\base\services\java\com\android\server\am\ActivityManagerService.java **/
public static void setSystemProcess() {
    try {
        // mSelf是静态变量，即前面启动的AMS实例
        ActivityManagerService m = mSelf;
       
        /** 这里通过ServiceManager来注册各种服务，其中AMS服务的主体是第一个即"activity" **/
        ServiceManager.addService("activity", m, true);
        ServiceManager.addService("meminfo", new MemBinder(m));
        ServiceManager.addService("gfxinfo", new GraphicsBinder(m));
        ServiceManager.addService("dbinfo", new DbBinder(m));
        if (MONITOR_CPU_USAGE) {
            ServiceManager.addService("cpuinfo", new CpuBinder(m));
        }
        ServiceManager.addService("permission", new PermissionController(m));
 
        ApplicationInfo info =
            mSelf.mContext.getPackageManager().getApplicationInfo(
                        "android", STOCK_PM_FLAGS);
        mSystemThread.installSystemApplicationInfo(info);
  
        synchronized (mSelf) {
            ProcessRecord app = mSelf.newProcessRecordLocked(
                    mSystemThread.getApplicationThread(), info,
                    info.processName, false);
            app.persistent = true;
            app.pid = MY_PID;
            app.maxAdj = ProcessList.SYSTEM_ADJ;
            mSelf.mProcessNames.put(app.processName, app.uid, app);
            synchronized (mSelf.mPidsSelfLocked) {
                mSelf.mPidsSelfLocked.put(app.pid, app);
            }
            mSelf.updateLruProcessLocked(app, true);
        }
    } catch (PackageManager.NameNotFoundException e) {
    }
}






    下面来看AMS是如何对Activity的启动产生影响的。




二、根Activity组件启动过程：


1、Activity分类：
    Activity组件分为两种类型：一种是根Activity，一种是子Activity。
1）根Activity以快捷方式图标的形式显示在应用程序启动器上，它的启动过程代表了一个Android应用程序的启动过程。
     根Activity在manifest.xml文件中的声明：




<activity
    android:name="com.loadingUI.LoadingActivity"
    android:label="@string/Loadinging_activity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
    </intent-filter>
</activity>   Launcher组件在启动时，会向PackageManagerService查询系统中所有“action”等于"action.MAIN"以及"category"等于"category.LAUNCHER"的Activity组件，为每一个Activity组件创建一个快捷图标。



    (这也是为什么要将Launcher Activity的intent filter设为上述模式的原因)。
    当想启动一个应用时，通过点击应用程序启动器Launcher界面上的图标来启动


2）子Activity由根Activity或者其他子Activity来启动，它们可能与启动它们的Activity运行在同一进程，也可能运行在不同的进程中。
     启动方式分有显式启动与隐式启动两种。按照软件工程的角度，隐式启动可以减少Android应用程序组件之间的依赖耦合度。
    
2、根Activity（记为MainActivity）的总启动过程总结如下：
1）Launch组件向AMS发送启动根Activity组件的请求；
2）AMS响应Launch请求，将根Activity组件的信息保存下来，并向Launch发送一个进入中止状态的进程间通信请求。
3）Launch进入中止状态后，向AMS发送消息；
4）AMS接收到消息后，会检查启动根Activity的应用程序进程是否已经存在；若不存在，则启动该应用程序进程。
5）根Activity应用程序进程启动完成后，该进程会向AMS发送一个启动完成的进程间通信请求。
6）AMS将其保存的根Activity组件的信息发送给创建的根Activity应用程序进程，使得其继续启动根Activity组件。




3、根Activity详细启动过程：
    先来分析启动的前几步如下图：



    启动根Activity一般是通过点击快捷图标，Launch组件启动Activity。先看其点击响应函数：

1）Launcher类：



public final class Launcher extends Activity
        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks, View.OnTouchListener
1.2）点击响应函数Launcher#onClick：






/** \packages\apps\Launcher2\src\com\android\launcher2*/
public void onClick(View v) {
    ...
    Object tag = v.getTag();
    if (tag instanceof ShortcutInfo) {
        // 这里组装启动intent的信息
        final Intent intent = ((ShortcutInfo) tag).intent;
        int[] pos = new int[2];
        v.getLocationOnScreen(pos);
        intent.setSourceBounds(new Rect(pos[0], pos[1],
                pos[0] + v.getWidth(), pos[1] + v.getHeight()));
 
        /** 看到通过这个函数用来启动一个应用的根Activity*/
        boolean success = startActivitySafely(v, intent, tag);
 
        if (success && v instanceof BubbleTextView) {
            mWaitingForResume = (BubbleTextView) v;
            mWaitingForResume.setStayPressed(true);
        }
    } 
    .......
}    可以看到Launcher通过函数startActivitySafely来启动应用程序的根Activity;





1.2）Launcher#startActivitySafely方法：




/** \packages\apps\Launcher2\src\com\android\launcher2*/
boolean startActivitySafely(View v, Intent intent, Object tag) {
    boolean success = false;
    try {
    /** 函数很简单，只是对startActivity进行了安全封装*/
        success = startActivity(v, intent, tag);
    } catch (ActivityNotFoundException e) {
    ...
    }
    return success;
}    可以看到startActivitySafely仅仅是对startActivity方法做了一个try-catch安全封装，用以安全启动，最终目的仍是调用startActivity来启动根Activity。






1.3）Launcher#startActivity函数：



boolean startActivity(View v, Intent intent, Object tag) {
    /*** 设置启动标志***/
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
    try {
        // Only launch using the new animation if the shortcut has not opted out (this is a
        // private contract between launcher and may be ignored in the future).
        boolean useLaunchAnimation = (v != null) &&
                !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);
        UserHandle user = (UserHandle) intent.getParcelableExtra(ApplicationInfo.EXTRA_PROFILE);
        LauncherApps launcherApps = (LauncherApps)
                this.getSystemService(Context.LAUNCHER_APPS_SERVICE);
        // 当添加新的启动动画时，使用此启动方式
        if (useLaunchAnimation) {
            ActivityOptions opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0,
                    v.getMeasuredWidth(), v.getMeasuredHeight());
            if (user == null || user.equals(android.os.Process.myUserHandle())) {
              /** 注意这里将会调用父类的startActivity*/
                startActivity(intent, opts.toBundle());
            } else {
                launcherApps.startMainActivity(intent.getComponent(), user,
                        intent.getSourceBounds(), opts.toBundle());
            }
        } else { // 默认的启动方式
            if (user == null || user.equals(android.os.Process.myUserHandle())) {
             
              /** 调用父类Activity的startActivity来启动 **/
                startActivity(intent);
            } else {
                launcherApps.startMainActivity(intent.getComponent(), user,
                        intent.getSourceBounds(), null);
            }
        }
        return true;
    } catch (SecurityException e) {
    ...
    }
    return false;
}


    上面代码重要完成两个工作：
1> 设置Activity的启动标志位Intent.FLAG_ACTIVITY_NEW_TASK（如果设置了此标志，这个activity将成为一个新task的历史堆栈中的第一个activity。这个task定义了一个原子组activities，用户可以对其进行移除。各种tasks可以移到前面或者后面；在一个特定的task中，所有的activities总是保持相同的顺序。当使用这个标志时，如果一个包含此activity的task已经运行了，新的activity不会启动；同时，当前的task将简单的被提到窗口最前面。查看FLAG_ACTIVITY_MULTIPLE_TASK可以禁止这个行为）


2>  调用startActivity方法来继续启动根Activity组件；可以看到Launcher类中并未实现两个/一个参数的startActivity的方法，可知其在父类Activity中，这里将会调用Activity.startActivity()函数；


4、Activity类
    熟悉的Activity类:


    public class Activity extends ContextThemeWrapper
    implements LayoutInflater.Factory2,
    Window.Callback, KeyEvent.Callback,
    OnCreateContextMenuListener, ComponentCallbacks2,
    Window.OnWindowDismissedCallback


1、前面调用到的Activity#startActivity方法：



/** \frameworks\base\core\java\android\app\Activity.java*/ 
@Override
public void startActivity(Intent intent) {
    this.startActivity(intent, null);
}
 
@Override
public void startActivity(Intent intent, @Nullable Bundle options) {
    if (options != null) {
        startActivityForResult(intent, -1, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        startActivityForResult(intent, -1);
    }
}    最终将会调用startActivityForResult来执行函数，第二个参数设为-1表示不需要知道最终的执行结果。





2、来分析Activity#startActivityForResult方法:



public void startActivityForResult(Intent intent, int requestCode) {
    startActivityForResult(intent, requestCode, null);
}
 
public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {
    /** mParent在调用attach函数时传入*/
    if (mParent == null) {
    /** Instrumentation类用以监控应用程序与系统之间的交互，
     *  这里通过其execStartActivity来启动Activity组件**/
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData());
        }
        /** 这个本情况下不需要*/
        if (requestCode >= 0) {
            mStartedActivity = true;
        }
 
        /** 有关界面加载SurfaceFlinger*/
        final View decor = mWindow != null ? mWindow.peekDecorView() : null;
        if (decor != null) {
            decor.cancelPendingInputEvents();
        }
    } else {
       ...
    }
    if (options != null && !isTopOfTask()) {
        mActivityTransitionState.startExitOutTransition(this, options);
    }
}注意execStartActivity中的传参param：



1）mToken:



private IBinder mToken;


    mToken是一个Binder代理对象，指向了ActivityManagerService中一个类型为ActivityRecord的Binder本地对象。每一个已经启动的Activity组件在AMS（ActivityManagerService）中都存在一个对应的ActivityRecord对象，用来维护对应的Activity组件的运行状态及信息。
在调用execStartActivity函数时，传入实参mToken，使得可以将其传递给AMS，以便AMS接下来可以获得Launcher组件的详细信息。


前面提到调用execStartActivity方法，该方法是Instrumentation类中的方法。


5、Instrumentation类

    Instrumentation是执行application instrumentation代码的基类。当应用程序运行的时候instrumentation处于开启，Instrumentation将在任何应用程序运行前初始化，可以通过它监测系统与应用程序之间的交互。Instrumentation
 implementation通过的AndroidManifest.xml中的<instrumentation>标签进行描述。

    Instrumentation似乎有些类似与window中的“钩子（Hook）函数”，在系统与应用程序之间安装了个“窃听器”。


1、Instrumentation#execStartActivity函数：
先看调用传参：


Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);函数源码：





/** \frameworks\base\core\java\android\app\Instrumentation.java*/
public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, Activity target,
        Intent intent, int requestCode, Bundle options) {
    IApplicationThread whoThread = (IApplicationThread) contextThread;
   
    /** mActivityMonitors定义：List<ActivityMonitor> mActivityMonitors;
     *  ActivityMoniter：有关特定的Intent的监视。
     *  一个ActivityMoniter类的实例通过函数addMonitor
     *  （Instrumentation.ActivityMonitor）添加到当前
     *  instrumentation中，一旦添加后，每当启动一个新的Activity，
     *  ActivityMoniter就会检测，如果匹配，其hit count计数更新
     *  等其他操作。一个ActivityMonitor也可以用来寻找一个Activity，
     *  通过waitForActivity（）方法，这个函数将返直到匹配的活动被创建。*/
    // 这里与主线无关，可以不用关心
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i=0; i<N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
   
    /** 主要的代码从这里开始**/
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
       
        // 主要的执行函数在这里，调用了ActivityManagerNative中的startActivity
        int result = ActivityManagerNative.getDefault()
            .startActivity(whoThread, who.getBasePackageName(), intent,
                    intent.resolveTypeIfNeeded(who.getContentResolver()),
                    token, target != null ? target.mEmbeddedID : null,
                    requestCode, 0, null, options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
    }
    return null;
}   上述代码中最重要的作用是调用了ActivityManagerNative.getDefault().startActivity方法；getDefault用以获取AMS的一个代理对象ActivityManagerNative，接着再调用它的成员函数startActivity来通知AMS将有一个Activity组件启动。





6、ActivityManagerNative类：
看一下其继承关系：



    /** \frameworks\base\core\java\android\app\ActivityManagerNative.java*/
    public abstract class ActivityManagerNative extends Binder implements IActivityManager


1、ActivityManagerNative#getDefault函数：



    /** \frameworks\base\core\java\android\app\ActivityManagerNative.java*/
    static public IActivityManager getDefault() {
        // 单例类Singleton中的函数，get是Singleton类中的方法，见下面附I
        return gDefault.get();
    }
   
    // Singleton为单例模式的实现，是个抽象类，见附一
    private static final Singleton<IActivityManager> gDefault = new Singleton<IActivityManager>() {
        protected IActivityManager create() {
            // 前面AMS分析中提到的AMS的主要服务"activity"，通过SM获取
            IBinder b = ServiceManager.getService("activity");
            ...
            IActivityManager am = asInterface(b);
            ...
            return am;
        }
    };
   
    static public IActivityManager asInterface(IBinder obj) {
        if (obj == null) {
            return null;
        }
        IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);
        if (in != null) {
            return in;
        }
        return new ActivityManagerProxy(obj);
    }
    可以看到当调用getDefault函数时，会返回gDefault.get()，返回一个IActivityManager类；





附I、Singleton类
    再看一下gDefault的定义，gDefault是个泛型类Singleton的对象实例，Singleton是个单例模式实现类，它是一个抽象类，它的定义如下：



    /**
     * Singleton helper class for lazily initialization.
     * Modeled after frameworks/base/include/utils/Singleton.h
     */
    public abstract class Singleton<T> {
        private T mInstance;
 
        protected abstract T create();
 
        public final T get() {
            synchronized (this) {
                if (mInstance == null) {
                    mInstance = create();
                }
                return mInstance;
            }
        }
    }    可以看到gDefault的定义是Singleton<IActivityManager>，调用get函数则是返回IActivityManager的具体实例对象。




    在定义gDefault时，需要重写abstract函数create()；在create函数中，可以看到它通过ServiceManager获取到一个服务名为"activity"的服务代理对象即一个引用了ActivtyManagerService的代理对象。
    而后通过asInterface将其封装成一个ActivityManagerProxy代理对象；
    因此调用getDefault最终获取到的返回结果时ActivityManagerService的代理对象。   
回到前面的步骤可知，ActivityManagerNative.getDefault().startActivity方法最终调用的是ActivityManagerProxy.startActivity方法。


2）ActivityManagerProxy类：（ActivityManagerNative的内部类）



/** \frameworks\base\core\java\android\app\ActivityManagerNative.java*/
class ActivityManagerProxy implements IActivityManager {
   
    public ActivityManagerProxy(IBinder remote) {
        mRemote = remote;
    }
 
    public IBinder asBinder() {
        return mRemote;
    }
 
    public int startActivity(IApplicationThread caller,
            String callingPackage, Intent intent, String resolvedType,
            IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle options)
            throws RemoteException {
        /*** 写入启动Activity的信息到Parcel对象data中 **/
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        data.writeString(callingPackage);
        intent.writeToParcel(data, 0);
        data.writeString(resolvedType);
        data.writeStrongBinder(resultTo);
        data.writeString(resultWho);
        data.writeInt(requestCode);
        data.writeInt(startFlags);
        if (profilerInfo != null) {
            data.writeInt(1);
            profilerInfo.writeToParcel(data,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
        } else {
            data.writeInt(0);
        }
        if (options != null) {
            data.writeInt(1);
            options.writeToParcel(data, 0);
        } else {
            data.writeInt(0);
        }
        /** 通过Binder进行进程间通信，通过mRemote来向AMS发送START_ACTIVITY_TRANSACTION类型
         *  的进程间请求 **/
        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
        reply.readException();
        int result = reply.readInt();
        reply.recycle();
        data.recycle();
        return result;
    }
}    和通常的Binder通信机制相同，这里使用ActivityManagerProxy将Activity组件的信息封装到一个Parcel对象中，通过Binder机制传递给AMS，发起进程间通信请求。接下来的启动操作则会在AMS中进行。





版权声明：本文为博主原创文章，未经博主允许不得转载。

SpannableUtil，Android复合文本的使用
前些天有个大神告诉我，你写这么多TetxtView实际上就实现了一个TextView的功能。 
我说我要设置background，textsize，textcolor阿，还有各种点击事件，一个TextView怎么能实现呢？ 
他丢给了我一个TextViewUtil文件，我稍稍看了下，里面主要用到了 SpannableString 这个神奇的东西。 
于是就想深究一下这个SpannableString到底怎么去使用，都有哪些神奇的功能呢？
一边学习、一边写demo、一边看效果……
我写了这么个工具类，里面的注释已经很详细了（PS：详细得自己都不高兴再写文字讲解了- -）：
public class SpannableUtil
{
    /**
     * 仅实现了大部分效果
     * 有些些方法还需调整 
     * 后面有点偷懒 直接给了构造方法的参数  没有多写几个重载来更好地支持自定义
    **/
/**
 *  1、BackgroundColorSpan 背景色 
    2、ClickableSpan 文本可点击，有点击事件
    3、ForegroundColorSpan 文本颜色（前景色）
    4、MaskFilterSpan 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)  (经测试无效，不知如何生效  硬件加速关闭也没有效果)
    5、MetricAffectingSpan 父类，一般不用
    6、RasterizerSpan 光栅效果                                                   (经测试无效，不知如何生效  硬件加速关闭也没有效果)
    7、StrikethroughSpan 删除线（中划线）
    8、SuggestionSpan 相当于占位符
    9、UnderlineSpan 下划线
    10、AbsoluteSizeSpan 绝对大小（文本字体）
    11、DynamicDrawableSpan 设置图片，基于文本基线或底部对齐。
    12、ImageSpan 图片
    13、RelativeSizeSpan 相对大小（文本字体）
    14、ReplacementSpan 父类，一般不用
    15、ScaleXSpan 基于x轴缩放
    16、StyleSpan 字体样式：粗体、斜体等
    17、SubscriptSpan 下标（数学公式会用到）
    18、SuperscriptSpan 上标（数学公式会用到）
    19、TextAppearanceSpan 文本外貌（包括字体、大小、样式和颜色）                       
    20、TypefaceSpan 文本字体
    21、URLSpan 文本超链接
**/
    /**
     * 1
     * BackgroundColorSpan 背景色 
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param color
     * @return
     */
    public static SpannableString setBackgroundColorSpan(String content,int startIndex,int endIndex,int color) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new BackgroundColorSpan( color ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 2
     * ClickableSpan 文本可点击，有点击事件
     * 去下划线的可点击span
     * @param content
     * @param startIndex
     * @param endIndex
     * @param url
     * @return
     */
    public static SpannableString setClickableSpan(String content,int startIndex,int endIndex,final String url) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new ClickableSpan() {

            @Override
            public void updateDrawState(TextPaint ds) {
//              super.updateDrawState(ds);
                ds.setColor(ds.linkColor);
                ds.setUnderlineText(false); 
            }

            @Override
            public void onClick(View widget) {
                //url处理  跳转网页或其他
                Uri uri = Uri.parse(url);
                Context context = widget.getContext();
                Intent intent = new Intent(Intent.ACTION_VIEW, uri);
                intent.putExtra(Browser.EXTRA_APPLICATION_ID,
                        context.getPackageName());
                context.startActivity(intent);
                Log.i("span", url);
            }

        }, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 2重载
     * ClickableSpan 文本可点击，有点击事件
     * 去下划线的可点击span
     * @param content
     * @param startIndex
     * @param endIndex
     * @param clickableSpan 自己重写ClickableSpan的 updateDrawState与onClick方法
     * @return
     */
    public static SpannableString setClickableSpan(String content,int startIndex,int endIndex,ClickableSpan clickableSpan) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        if (null != clickableSpan) {
            spannableString.setSpan(clickableSpan, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }else {
            spannableString.setSpan(new ClickableSpan() {
                @Override
                public void onClick(View widget) {
                    Log.i("span", "clicked");
                }
            }, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return spannableString;
    }

    /**
     * 3
     * ForegroundColorSpan 前景色 
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param color
     * @return
     */
    public static SpannableString setForegroundColorSpan(String content,int startIndex,int endIndex,int color) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new ForegroundColorSpan( color ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 17
     *  SubscriptSpan 下标（数学公式会用到）
     * @param content
     * @param startIndex
     * @param endIndex
     * @return
     */
    public static SpannableString setSubscriptSpan( String content, int startIndex, int endIndex ){
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return null;
        }

        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan( new SubscriptSpan( ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE );

        return spannableString;
    }

    /**
     * 18
     *  SuperscriptSpan 上标（数学公式会用到）
     * @param content
     * @param startIndex
     * @param endIndex
     * @return
     */
    public static SpannableString setSuperscriptSpan( String content, int startIndex, int endIndex ){
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return null;
        }

        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan( new SuperscriptSpan( ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE );

        return spannableString;
    }
    /**
     * 4 (经测试无效，不知如何生效  硬件加速关闭也没有效果)
     * MaskFilterSpan 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)
     * @param content
     * @param startIndex
     * @param endIndex
     * @param blurMaskFilter    模糊
     * @param embossMaskFilter  浮雕
     * @param maskFilter        其他自定义效果
     * @return
     */
    public static SpannableString setMaskFilterSpan(String content,int startIndex,int endIndex,
            BlurMaskFilter blurMaskFilter,EmbossMaskFilter embossMaskFilter,MaskFilter maskFilter) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        if (null == blurMaskFilter) {
            spannableString.setSpan(new BlurMaskFilter(50, Blur.SOLID), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }else {
            spannableString.setSpan(blurMaskFilter, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (null == embossMaskFilter) {
            spannableString.setSpan(new EmbossMaskFilter(new float[]{1,1,1}, 0.4f, 6, (float)3.5), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }else {
            spannableString.setSpan(embossMaskFilter, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        if (null != maskFilter) {
            spannableString.setSpan(maskFilter, startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return spannableString;
    }
    /**
     * 6 (经测试无效，不知如何生效  硬件加速关闭也没有效果)
     * RasterizerSpan 光栅效果 
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @return
     */
    public static SpannableString setRasterizerSpan(String content,int startIndex,int endIndex) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new RasterizerSpan(new Rasterizer()), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }
    /**
     * 7
     * StrikethroughSpan 删除线（中划线）
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @return
     */
    public static SpannableString setStrikethroughSpan(String content,int startIndex,int endIndex) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new StrikethroughSpan(), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 8
     * SuggestionSpan 替换建议
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @return
     */
    public static SpannableString setSuggestionSpan(String content,int startIndex,int endIndex) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new SuggestionSpan(Locale.CHINESE,new String[]{"SuggestionSpan1","SuggestionSpan2","SuggestionSpan3"}, SuggestionSpan.FLAG_EASY_CORRECT), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }
    /**
     * 9
     * UnderlineSpan 下划线
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @return
     */
    public static SpannableString setUnderlineSpan(String content,int startIndex,int endIndex) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new UnderlineSpan(), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 10   
     * AbsoluteSizeSpan 绝对大小（文本字体）(不建议使用，因为此处指定的字号大小以px为单位)
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param size 字号，单位px
     * @return
     */
    public static SpannableString setAbsoluteSizeSpan(String content,int startIndex,int endIndex,int size) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new AbsoluteSizeSpan(size), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 11
     * DynamicDrawableSpan 设置图片，基于文本基线或底部对齐
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param drawable 显示的图片
     * @return
     */
    public static SpannableString setDynamicDrawableSpan(String content,int startIndex,int endIndex,final Drawable drawable) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        //基线对齐
        spannableString.setSpan(new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BASELINE) {

            @Override
            public Drawable getDrawable() {
                Drawable d = drawable;
                d.setBounds(0, 0, 50, 50);
                return d;
            }

        }, startIndex, startIndex + 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        //底部对齐
        spannableString.setSpan(new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BOTTOM) {

            @Override
            public Drawable getDrawable() {
                Drawable d = drawable;
                d.setBounds(0, 0, 50, 50);
                return d;
            }

        }, startIndex + 1, startIndex + 2, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 12
     * ImageSpan 图片
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param drawable 显示的图片
     * @return
     */
    public static SpannableString setImageSpan(String content,int startIndex,int endIndex,final Drawable drawable) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        drawable.setBounds(0, 0, 50, 50);
        spannableString.setSpan(new ImageSpan(drawable), startIndex, startIndex + 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 13
     * RelativeSizeSpan 相对大小（文本字体）
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param size 字缩放倍数
     * @return
     */
    public static SpannableString setRelativeSizeSpan(String content,int startIndex,int endIndex,float size) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new RelativeSizeSpan(size), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }
//  ScaleXSpan 基于x轴缩放

    /**
     * 15
     * ScaleXSpan 基于x轴缩放
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param size x轴缩放倍数
     * @return
     */
    public static SpannableString setScaleXSpan(String content,int startIndex,int endIndex,float size) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new ScaleXSpan(size), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 16
     * StyleSpan 字体样式：粗体、斜体等
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param flag  Typeface.xxx
     * @return
     */
    public static SpannableString setStyleSpan(String content,int startIndex,int endIndex,int flag) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new StyleSpan(flag), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }
    /**
     * 19
     * TextAppearanceSpan 文本字体
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param context
     * @return
     */
    public static SpannableString setTextAppearanceSpan(String content,int startIndex,int endIndex,Context activity) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new TextAppearanceSpan(activity,android.R.style.TextAppearance_Holo_Large_Inverse), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }

    /**
     * 20
     * TypefaceSpan 文本字体
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param family The font family for this typeface.  Examples include
     * "monospace", "serif", and "sans-serif".
     * @return
     */
    public static SpannableString setTypefaceSpan(String content,int startIndex,int endIndex,String family) {
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }
        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new TypefaceSpan(family), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        return spannableString;
    }


    /**
     * 21
     * URLSpan 文本超链接
     * @param context
     * @param start_index
     * @param end_index 设为0则到最后
     * @param url 
     * @return
     */
    public static SpannableString setURLSpan( String content, int startIndex, int endIndex, String url ){
        if (0 == endIndex) {
            endIndex = content.length();
        }
        if( TextUtils.isEmpty( content ) || startIndex < 0 || endIndex > content.length( ) || startIndex >= endIndex ){
            return new SpannableString(content);
        }

        SpannableString spannableString = new SpannableString( content );
        spannableString.setSpan(new URLSpan( url ), startIndex, endIndex, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

        return spannableString;
    }
}
注意使用了ClickableSpan 点击事件必须调用TextView的setMovementMethod(LinkMovementMethod.getInstance());方法否则无效
代码量确实不小= =本来以为只需要几个小时的 结果花了我昨天一个下午外加今天一个上午 完成demo + 稍微优化。然而这里面还是有没有解决的东西 。。。比如 MaskFilterSpan 和RasterizerSpan 这两个顽疾，在API19下一直都没跑出来效果，关闭了硬件加速也没有效果。
如果有大神能够解决，万望告知……毕竟觉得MaskFilterSpan 能自定义很多效果，如果不能用的话，痒痒的。
另外，不知各位对Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 这个属性可有疑问。 我搜索出来有人是这样说的： 
Spanned.SPAN_EXCLUSIVE_EXCLUSIVE — 不包含两端start和end所在的端点 
   Spanned.SPAN_EXCLUSIVE_INCLUSIVE — 不包含端start，但包含end所在的端点 
   Spanned.SPAN_INCLUSIVE_EXCLUSIVE — 包含端start，但不包含end所在的端点 
   Spanned.SPAN_INCLUSIVE_INCLUSIVE— 包含两端start和end所在的端点 
但我尝试后好像并不是这样。 

此处引用 http://aichixihongshi.iteye.com/blog/1207503 的文章 
   Spanned.SPAN_EXCLUSIVE_EXCLUSIVE，这是在 setSpan 时需要指定的 flag，它的意义我试了很久也没试出来，睡个觉，今天早上才突然有点想法，试之，果然。它是用来标识在 Span 
  范围内的文本前后输入新的字符时是否把它们也应用这个效果。分别有  
  Spanned.SPAN_EXCLUSIVE_EXCLUSIVE(前后都不包括)、 
  Spanned.SPAN_INCLUSIVE_EXCLUSIVE(前面包括，后面不包括)、 
  Spanned.SPAN_EXCLUSIVE_INCLUSIVE(前面不包括，后面包括)、 
  Spanned.SPAN_INCLUSIVE_INCLUSIVE(前后都包括)。 
  看个截图就更明白了： 
 
  对比一下 


demo地址：http://download.csdn.net/download/yaosongqwe/9048655 
如积分不够，可以回复留下邮箱，我会发送至各位的邮箱。 

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为YS尘笑原创文章，未经本人允许不得转载。

如果在 unity中滚动 3D 骰子
孙广东   2015.8.16目的:     这篇文章的主要目的是为了让您了解有关如果在 unity中滚动 3D 骰子                建设一个棋盘游戏   但因为骰子困扰   ;         这个问题分为两个主要部分:	         如何掷骰子。	        确定是 1和6之间的随机一个整数面值 (六面临标准骰子)。 如何掷骰子 步骤-1:   将标准骰子模型导入 unity3D。调整Transform ，如图所示，将 刚体添加到它。步骤 -2:  现在将代码片段添加 到脚本 。           注: 这段代码使您能够使用鼠标触发 ，如果进行适当更改，你可以轻松地变为触摸设备。 if (Input.GetMouseButtonDown (0))
{
//initial click to roll a dice
initPos = Input.mousePosition;
 
//return x component of dice from screen to view point
initXpose = cam.ScreenToViewportPoint (Input.mousePosition).x;
}
 
//current position of mouse
Vector3 currentPos = Input.mousePosition;
 
//get all position along with mouse pointer movement
Vector3 newPos = cam.ScreenToWorldPoint (newVector3(currentPos.x,currentPos.y,Mathf.Clamp(currentPos.y/10,10,50)));
 
//translate from screen to world coordinates  
newPos = cam.ScreenToWorldPoint (currentPos);
 
if (Input.GetMouseButtonUp (0))
{
initPos = cam.ScreenToWorldPoint (initPos);
 
//Method use to roll the dice
RollTheDice(newPos);
//use identify face value on dice
StartCoroutine(GetDiceCount ());
}
 
//Method Roll the Dice
void RollTheDice(Vector3 lastPos)
{
               diceObject.rigidbody.AddTorque(Vector3.Cross(lastPos, initPos) * 1000, orceMode.Impulse);
lastPos.y += 12;
diceObject.rigidbody.AddForce (((lastPos - initPos).normalized) * (Vector3.Distance (lastPos, initPos)) * 25 * duceObject.rigidbody.mass);
}步骤-3:  RollTheDice 方法是如何工作的:	         最初，掷骰子时 扭矩Torque 被添加 旋转骰子。然后 力Force 被增加， 所以它会给真正的骰子被滚动的外观和感觉。        转矩的计算使用 交叉产品的 lastPos 和 initPos 对移动旋转像真正的骰子，并将在鼠标的方向移动 。	同样添加力Force ，以掷骰子的鼠标的方向。 //Coroutine to get dice count
void GetDiceCount()
{
if (Vector3.Dot (transform.forward, Vector3.up) > 1)
diceCount = 5;
if (Vector3.Dot (-transform.forward, Vector3.up) > 1)
diceCount = 2;
if (Vector3.Dot (transform.up, Vector3.up) > 1)
diceCount = 3;
if (Vector3.Dot (-transform.up, Vector3.up) >1)
diceCount = 4;
if (Vector3.Dot (transform.right, Vector3.up) >1)
diceCount = 6;
if (Vector3.Dot (-transform.right, Vector3.up) >1)
diceCount = 1;
Debug.Log ("diceCount :" + diceCount);
}步骤-4:  以上代码段说明如何确定在骰子上随机的面值。	        这段代码必须包含在脚本中，  骰子在hierarchy和transforms 应该是如图 1 所示。	       点数用于查找哪一张脸是将被考虑。	

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 6.0中的新技术有哪些

最近 Google 正式发布了 Android M，并命名为“棉花糖”(Marshmallow)，对于开发者来说，有哪些新的技术和变化呢?本文尝试总结一下 Android 6.0(API 23)给开发者带来新的技术和改变。

权限管理
权限管理是 Android M 最大的改变，权限管理更加精细，并且由以前的安装时静态授权，改为现在的运行时动态授权。大家对 Android 的权限吐槽已久，Android 应该能极大的改善这方面的问题。主要改变有：
系统设置中可以对 APP 各个权限单独控制
权限根据内容进行分组了
普通权限还是在安装时授权
其他权限在运行时系统弹窗授权，并且要解析使用这个权限的目的
对于开发者来说，需要小心处理权限相关的问题。在使用某个功能的时候，需要总是判断是否有改权限，并且通过合适的方式请求用户授权。关于 Android M 权限的处理，可以参考官方文档。
另外，这篇文章结合图文和代码讲述了 Android M 中权限模型，比较清晰，可以参考一下。
APP Linking
这是一个把 APP 和网页直接打通的技术，能够让 APP 能够直接来处理你的网站普通的 URL 链接，来展示你对应的网站内容。这绝对是一个值得关注的改进，Web 和 APP 之间缝隙将越来越小。这对既有网站又有 APP 的应用来说非常有利，例如知乎和淘宝等。
有点类似于之前的 APP 的 Deep link，可以通过特殊的 Schema 也可以让 APP 直接打开对应的内容。APP Linking 的特点是，只要使用传统的 URL 就可以，而且是根据 URL 的域名对应特定的 APP 的。
开发者需要做的是在 AndroidManifest.xml 做一下对应的声明即可。如果需要让系统默认用你的 APP 打开对应的 URL 的话，还需要网站配合提供 assetlinks.json。详情可以参考这里。
APP 数据自动备份
支持 APP 数据自动备份到 Google Drive，在你换手机的时候，能够直接把 APP 的数据恢复到你的手机上，你还可以配置些数据那些数据需要或者不需要备份。而且不用写任何代码就自动实现了。详情可以参考这里。
然而这些对国内的开发者来说，并没有什么用。国内厂商的 ROM 有些已经有或者准备会跟上，到时候都能享受到这样的便利。
指纹解锁
Android 官方支持指纹认证，可以用在解锁，或者任何需要验证用户的地方，例如支付。提供了新的 API FingerprintManager，让第三方 APP 来用来获得指纹认证的功能。具体使用方法可以参考这个实例。
直接分享
直接分享是在 APP 内直接弹出一个选择分享到其他应用的中的对象的列表，中间省略了选择需要分享的 APP，选择“联系人”之类的操作。Android 中分享已经做得很好了，这里又更进一步简化了分享操作。如果要让你的 APP 支持被直接分享，需要实现一个ChooserTargetService，并且实现对应的处理分享 Intent 的 Activity。具体使用可以参考这里。
支持蓝牙触控笔
系统内置支持蓝牙触控笔，这样 Android 系统就默认支持高大上的触控笔了。并提供了 API 让你的 APP 来响应触控笔事件。
低功耗蓝牙扫描优化
优化了低功耗蓝牙扫描优化的扫描。现在低功耗蓝牙的应用越来越多，很多 APP 都需要扫描设备，扫描设备是一个非常重的操作，希望这次改动，能够带来一些改善。
支持主题化的 ColorStateLists
使用 context.getColorStateList(int id) 来获取当前主题对应的 ColorStateLists。
相机 API
提供 API setTorchMode()) 来直接开关闪光灯，并且可以监听闪光灯的开光状态，以前很多 APP 已经支持用闪光灯来做手电筒，现在官方提供 API 来做这样的事情了。
从 Android 5.0 开始，就提供了一套全新的相机 API Camera2，这里在此基础上添加了处理相关 API。
其他
另外还有很多的改进，因为涉及的方面太专业，或者是没有使用到相关功能，我就不详细说了，可以参考官方概述：
有语音交互 API
Hotspot 2.0 支持
4k 屏支持
语音和视频 API 的改进
Android 企业用户特性，例如多用户支持，静默安装等。
推荐阅读：
资深程序员编程经验分享

为什么程序员有高薪却不高兴？



版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 自定义主菜单
本文介绍一个超简单的自定义主菜单，效果如下：


原理：其实就是对原生的Dialog的一个简单的封装。并加上显示和隐藏的动画效果。再给控件加上回调事件。


TestDialog.java
public class TestDialog implements OnClickListener {
	private Context mContext;
	private Dialog mDialog;
	private Display mDisplay;
	private TextView mTitle;
	private TextView mOk, mCancel;
	private LinearLayout mContent;
	private List<String> mItems = null;
	private List<OnCustomItemClickListener> mListeners = null;
	private List<Drawable> mDrawables = null;

	public TestDialog(Context context) {
		this.mContext = context;
		WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
		mDisplay = windowManager.getDefaultDisplay();
	}

	/**
	 * builder()创建
	 * 
	 * @return
	 */
	public TestDialog builder(int layout) {
		initView(layout);
		return this;
	}

	/**
	 * 初始化Dialog视图的方法
	 * 
	 * @param layout
	 */
	private void initView(int layout) {
		View view = LayoutInflater.from(mContext).inflate(layout, null);
		view.setMinimumWidth(mDisplay.getWidth());
		//
		mTitle = (TextView) view.findViewById(R.id.menu_title);
		mContent = (LinearLayout) view.findViewById(R.id.menu_content);
		mOk = (TextView) view.findViewById(R.id.menu_ok);
		mCancel = (TextView) view.findViewById(R.id.menu_cancel);
		mOk.setOnClickListener(this);
		mCancel.setOnClickListener(this);
		mDialog = new Dialog(mContext, R.style.DialogStyle);
		mDialog.setContentView(view);
		Window dialogWindow = mDialog.getWindow();
		dialogWindow.setGravity(Gravity.LEFT | Gravity.BOTTOM);
		WindowManager.LayoutParams lp = dialogWindow.getAttributes();
		lp.x = 0;
		lp.y = 0;
		dialogWindow.setAttributes(lp);
	}

	/**
	 * 
	 * @param 是否能取消
	 * @return
	 */
	public TestDialog setCancelable(boolean b) {
		if (mDialog != null) {
			mDialog.setCancelable(b);
		}
		return this;
	}

	/**
	 * 设置对话框标题
	 * 
	 * @param title
	 * @return
	 */
	public TestDialog setTitle(String title) {
		if (mDialog != null) {
			mTitle.setText(title);
			mTitle.setVisibility(View.VISIBLE);
		}
		return this;
	}

	/**
	 * 
	 * @param 点击Dialog以外的部分是否可以取消
	 * @return
	 */

	public TestDialog set(boolean b) {
		if (mDialog != null) {
			mDialog.setCanceledOnTouchOutside(b);
		}
		return this;
	}

	/**
	 * 取消
	 */
	public void dismiss() {
		mDialog.dismiss();
	}

	/**
	 * 用来装视图数据的集合
	 * 
	 * @param title
	 * @return
	 */
	public TestDialog addItem(String title, Drawable drawable, OnCustomItemClickListener clickListener) {
		if (mItems == null) {
			mItems = new ArrayList<String>();
		}
		if (mListeners == null) {
			mListeners = new ArrayList<TestDialog.OnCustomItemClickListener>();
		}
		if (mDrawables == null) {
			mDrawables = new ArrayList<Drawable>();
		}
		mItems.add(title);
		mListeners.add(clickListener);
		mDrawables.add(drawable);
		return this;
	}

	private void setItem() {
		if (mItems == null || mItems.size() <= 0) {
			return;
		}
		int count = mItems.size();
		for (int i = 0; i < count; i++) {
			final int index = i;
			TextView view = new TextView(mContext);
			view.setText("object" + 1);
			view.setCompoundDrawablesRelativeWithIntrinsicBounds(null, mDrawables.get(i), null, null);
			view.setOnClickListener(new OnClickListener() {

				@Override
				public void onClick(View v) {
					// TODO Auto-generated method stub
					mListeners.get(index).onClick(index);
				}
			});
			mContent.addView(view);
		}
	}

	public void show() {
		setItem();
		mDialog.show();
	}

	public interface OnCustomItemClickListener {
		public abstract void onClick(int v);
	}

	@Override
	public void onClick(View v) {
		if (v == mOk) {

		} else if (v == mCancel) {

		}
		mDialog.dismiss();

	}

}
用到的Teme：
<style name="DialogStyle" parent="@android:style/Theme.Dialog">

        <!-- 背景透明 -->
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:windowContentOverlay">@null</item>
        <!-- 浮于Activity之上 -->
        <item name="android:windowIsFloating">true</item>
        <!-- 边框 -->
        <item name="android:windowFrame">@null</item>
        <!-- Dialog以外的区域模糊效果 -->
        <item name="android:backgroundDimEnabled">true</item>
        <!-- 无标题 -->
        <item name="android:windowNoTitle">true</item>
        <!-- 半透明 -->
        <item name="android:windowIsTranslucent">true</item>
        <!-- Dialog进入及退出动画 -->
        <item name="android:windowAnimationStyle">@style/ActionSheetDialogAnimation</item>
    </style>

    <style name="ActionSheetDialogAnimation" parent="@android:style/Animation.Dialog">
        <item name="android:windowEnterAnimation">@anim/dialog_in</item>
        <item name="android:windowExitAnimation">@anim/dialog_out</item>
    </style>动画文件：
dialog_in.xml
<?xml version="1.0" encoding="utf-8"?>
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="200"
    android:fromYDelta="100%"
    android:toYDelta="0" />dialog_out.xml
<?xml version="1.0" encoding="utf-8"?>
<translate xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="200"
    android:fromYDelta="0"
    android:toYDelta="100%" />


用到的布局文件：
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@android:color/white"
    android:orientation="vertical" >

    <TextView
        android:id="@+id/menu_title"
        android:layout_width="match_parent"
        android:layout_height="45dip"
        android:background="@drawable/menu_item_background"
        android:gravity="center"
        android:visibility="gone" />

    <LinearLayout
        android:id="@+id/menu_content"
        android:layout_width="match_parent"
        android:layout_height="150dip"
        android:gravity="center_vertical"
        android:orientation="horizontal" >
    </LinearLayout>

    <View
        android:layout_width="match_parent"
        android:layout_height="1px"
        android:background="@android:color/darker_gray" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="45dip"
        android:orientation="horizontal" >

        <TextView
            android:id="@+id/menu_ok"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:background="@drawable/menu_item_background"
            android:gravity="center"
            android:text="@string/menu_ok" />

        <View
            android:layout_width="1px"
            android:layout_height="match_parent"
            android:background="@android:color/darker_gray" />

        <TextView
            android:id="@+id/menu_cancel"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:background="@drawable/menu_item_background"
            android:gravity="center"
            android:text="@string/menu_cancel" />
    </LinearLayout>

</LinearLayout>


用到的背景
<selector xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:drawable="@android:color/darker_gray" android:state_focused="true"></item>
    <item android:drawable="@android:color/darker_gray" android:state_pressed="true"></item>
    <item android:drawable="@android:color/white"></item>

</selector>

在Activity中使用：
findViewById(R.id.click).setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				TestDialog dialog = new TestDialog(MainActivity.this);
				dialog.builder(R.layout.menu);
				dialog.setCancelable(false);
				dialog.addItem("微博1", getResources().getDrawable(R.drawable.ic_weibo), new OnCustomItemClickListener() {

					@Override
					public void onClick(int v) {
						Toast.makeText(getBaseContext(), "1", 1).show();
					}
				});
				dialog.addItem("微博2", getResources().getDrawable(R.drawable.ic_weibo), new OnCustomItemClickListener() {

					@Override
					public void onClick(int v) {
						Toast.makeText(getBaseContext(), "3", 1).show();
					}
				});
				dialog.show();
			}
		});



版权声明：本文是博主原创文章，你可以在未经博主允许的情况下随便转载。顾明伟 http://blog.csdn.net/u013045971

Android通过startService实现批量下载示例
关于startService的基本使用概述及其生命周期可参见博客《Android中startService的使用及Service生命周期》。
本文通过批量下载文件的简单示例，演示startService以及stopService(startId)的使用流程。
系统界面如下: 

界面很简单，就一个按钮“批量下载文章”，通过该Activity上的按钮启动DownloadService。
DownloadService是用来进行下载CSDN上博客文章的服务，代码如下:
package com.ispring.startservicedemo;

import android.app.Service;
import android.content.Intent;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.util.Log;
import android.widget.Toast;

import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

public class DownloadService extends Service {
    //存储所有的startId
    private List<Integer> allStartIdList = new ArrayList<>();
    //存储已经下载完成的startId
    private List<Integer> finishedStartIdList = new ArrayList<>();

    private Handler handler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            if(msg.what == 1){
                String tip = (String)msg.obj;
                Toast.makeText(DownloadService.this, tip, Toast.LENGTH_LONG).show();
            }
        }
    };

    class DownloadThread extends Thread {

        //对应的intent的startId信息
        private int startId = 0;

        //要下载的文章名称
        private String blogName = null;

        //要下载的文章地址
        private String blogUrl = null;

        public DownloadThread(int startId, String name, String url){
            this.startId = startId;
            this.blogName = name;
            this.blogUrl = url;
        }

        @Override
        public void run() {
            HttpURLConnection conn = null;
            InputStream is = null;
            try{
                //下载指定的文件
                URL url = new URL(this.blogUrl);
                conn = (HttpURLConnection)url.openConnection();
                if(conn != null){
                    //我们在此处得到所下载文章的输入流，可以将其以文件的形式写入到存储卡上面或
                    //将其读取出文本显示在App中
                    is = conn.getInputStream();
                }
            }catch (MalformedURLException e){
                e.printStackTrace();
            }catch (IOException e){
                e.printStackTrace();
            }finally {
                if(conn != null){
                    conn.disconnect();
                }
            }

            finishedStartIdList.add(startId);

            if(finishedStartIdList.containsAll(allStartIdList)){
                String tip = "全部下载完成, 数量" + finishedStartIdList.size();
                Message msg = handler.obtainMessage(1);
                msg.obj = tip;
                handler.sendMessage(msg);
            }

            Log.i("DemoLog", "stopSelf(" + startId + ")");
            stopSelf(startId);
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Log.i("DemoLog", "DownloadService -> onCreate");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        allStartIdList.add(startId);
        String name = intent.getStringExtra("name");
        String url = intent.getStringExtra("url");
        Log.i("DemoLog", "DownloadService -> onStartCommand, startId: " + startId + ", name: " + name);
        DownloadThread downloadThread = new DownloadThread(startId, name, url);
        downloadThread.start();
        return START_REDELIVER_INTENT;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.i("DemoLog", "DownloadService -> onDestroy");
    }
}
DownloadActivity的代码如下:
package com.ispring.startservicedemo;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


public class DownloadActivity extends Activity implements Button.OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_download);
    }

    @Override
    public void onClick(View v) {
        List<String> list = new ArrayList<>();
        list.add("Android中Handler的使用;http://blog.csdn.net/iispring/article/details/47115879");
        list.add("深入源码解析Android中的Handler,Message,MessageQueue,Looper;http://blog.csdn.net/iispring/article/details/47180325");
        list.add("Android新线程中更新主线程UI中的View方法汇总;http://blog.csdn.net/iispring/article/details/47300819");
        list.add("Android中HandlerThread的使用及原理解析;http://blog.csdn.net/iispring/article/details/47320407");
        list.add("Android中Looper的quit方法和quitSafely方法;http://blog.csdn.net/iispring/article/details/47622705");

        Iterator iterator = list.iterator();

        while (iterator.hasNext()){
            String str = (String)iterator.next();
            String[] splits = str.split(";");
            String name = splits[0];
            String url = splits[1];
            Intent intent = new Intent(this, DownloadService.class);
            intent.putExtra("name", name);
            intent.putExtra("url", url);
            startService(intent);
        }
    }
}
当我们单击了按钮“批量下载文章”时，我们会多次调用Activity的startService方法，其中我们在其参数intent中存储了文章名name以及文章的地址url，由于我们多次调用了startService方法，所以会批量下载文章。
点击按钮后，控制台运行结果如下所示: 

调用了startService之后，Android Framework接收到了intent信息，第一次会先创建DownloadService的实例，然后执行其onCreate回调方法，onCreate在Service的生命周期中只会调用一次。
调用了onCreate方法后，Android会自动回调其onStartCommand方法，其实每次调用Context的startService都会触发onStartCommand回调方法，所以onStartCommand在Service的生命周期中可能会被调用多次。在onStartCommand方法中我们可以获得intent和startId，intent即我们调用startService方法时传入的参数，startId是Android自动分配的，每次调用startService都会自动得到一个startId，一个startId就意味着一个job，也就是意味着一次下载任务。我们在DownloadService中有两个字段allStartIdList和finishedStartIdList。allStartIdList存储着所有的startId，我们在onStartCommand方法一开始就把我们得到的startId放入到allStartIdList中存储，然后我们根据intent读取到文章名name和文章地址url，并根据这些信息创建一个新的线程DownloadThread，该线程用于执行实际的网络请求下载工作。需要注意的是，为了代码简化起见我们在onStartCommand中只要得到intent就开辟一个新线程(DownloadThread)，但是在实际生产环境中这样的开销比较大（线程新建、线程销毁），应该尽量使用线程池以节约开销。
执行了DownloadThread的start方法后，就会执行DownloadThread线程的run方法，在该方法中我们会执行网络请求，获取博客文章的输入流，当我们获取到该输入流之后，我们就认为下载完成了，此时我们可以将其以文件的形式写入到存储卡上，也可以将其读取出文本显示在App上，此处我们没有对输入流做任何处理，我们就认为下载完成了。下载完成后，我们把startId存入到finishedStartIdList中，finishedStartIdList存储着所有已经完成的job的startId。当finishedStartIdList中已经包含了allStartIdList的所有startId时，说明我们所有的下载任务完成了，我们会通过handler让主线程显示Toast告知用户文章下载完成。在run方法的最后我们会执行Service的stopSelf(startId)方法。需要注意的是我们在stopSelf方法中传入了startId，这意味着我们不是直接停止Service的运行，我们只是停止该startId对应的job的执行，如果所有的startId所对应的job都停止了，那么整个Service才会停止，当整个Service停止时，才会触发执行Service的onDestroy回调方法。
本文只是通过批量下载博文这一简单示例演示通过startService以及stopSelf(startId)使用Service基本使用流程，代码没有进行优化，希望对大家学习Service有所帮助。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

6）Win10-UWA开发  应用生命周期
﻿﻿﻿﻿孙广东   2015.8.24本主题介绍了 Windows 运行时应用的生命周期，从部署它一直到删除它。通过正确地启动、挂起和恢复你的应用，可确保客户拥有最佳应用体验。应用执行状态此图表现了应用执行状态之间的转换。我们在后面几部分中介绍了这些状态和事件。有关每个状态转换以及你的应用应如何响应的详细信息，请参阅有关 ApplicationExecutionState 枚举的参考文档。部署为了能够以任何方式激活应用，必须先对其进行部署。在以下情况下应特别注意进行基本部署：当用户安装你的应用时，或者当你使用 Visual Studio 以在开发和测试期间本地构建并运行自己的应用时。有关此部署以及高级部署方案的详细信息，请参阅应用包和部署。应用启动每当用户激活一个应用而且该应用进程之前处于 NotRunning 状态时，它就会启动。应用可能处于 NotRunning 状态，原因有：它从未启动、它运行后出现了故障，或者它被挂起后无法保留在内存中而被系统终止。当应用启动时，Windows 显示应用的一个初始屏幕。若要配置此初始屏幕，请参阅“添加初始屏幕”（HTML 或 XAML）。当初始屏幕显示时，应用代码还应该确保该应用已准备好向用户显示其用户界面。应用的主要任务是注册事件处理程序和设置它需要加载初始页面的任何自定义 UI。这些任务仅应占用几秒的时间。如果某个应用需要从网络请求数据或者需要从磁盘检索大量的数据，这些活动应在激活以外完成。应用在等待完成这些长时间运行的操作时，可以使用自己的自定义加载 UI 或延长的初始屏幕。有关详细信息，请参阅“如何延长初始屏幕”（HTML 或 XAML）以及初始屏幕示例。在应用完成激活后，它将进入 Running 状态，随后初始屏幕将消失（并且其所有资源和对象将被清除）。显示一个窗口、从激活处理程序返回，以及完成一定的延期，这些是应用完成激活的具体方式。有关详细信息，请参阅“如何激活应用”（HTML 或 XAML）。应用激活应用可以由用户通过各种合约和扩展激活。若要参与激活，则必须将你的应用注册为接收 WinJS activated 事件 (HTML) 或覆盖 OnActivated 方法 (XAML)。（对于 HTML，WebUIApplication.activated 是另一个可用于处理激活的事件。） 你的应用的激活代码可以通过测试了解其激活原因以及是否已经处于 Running 状态。应用可以使用以下任意激活类型进行激活：Activation type描述缓存的文件用户希望保存你的应用对其进行内容管理的文件。相机用户希望通过所连的相机拍照或捕获视频。联系人选取器用户希望挑选联系人。设备用户希望你的应用能处理自动播放。文件用户的应用启动一个文件，该文件的类型是应用已注册可处理的类型。文件打开选取器用户希望挑选应用提供的文件或文件夹。文件保存选取器用户希望保存文件并选择了你的应用。启动用户启动应用或点击一个内容磁贴。打印任务用户希望你的应用处理打印任务。协议用户的应用启动一个 URL，其协议是应用已注册可处理的协议。搜索用户希望搜索你的应用。共享目标用户希望你的应用作为共享操作的目标。 为 Windows 8.1 及更高版本构建的应用可以使用上述任意方式激活，也可以使用这些激活类型激活。Activation type描述添加约会用户希望向其日历中添加约会。还在 Windows Phone 上受支持。删除约会用户希望从其日历中删除约会。还在 Windows Phone 上受支持。替换约会用户希望替换其日历中的约会。还在 Windows Phone 上受支持。显示期限用户希望在其日历上显示特定的期限。还在 Windows Phone 上受支持。呼叫联系人用户希望呼叫联系人。定位联系人用户希望定位联系人（获取联系人的位置）。向联系人发送消息用户希望向联系人发送消息。发布联系人用户希望发布联系人。通过视频呼叫联系人用户希望通过视频呼叫联系人。锁屏通话用户希望在锁屏状态下接受呼叫。限制启动用户启动了受限制的应用。 使用这些类型可以激活 Windows Phone 应用。Activation type描述VoiceCommand作为语音命令的结果，已激活应用程序。PickerReturned选择选取器后，应用程序已被激活。WalletAction已激活应用程序以执行电子钱包操作。PickFileContinuation为文件选取器操作挂起应用后，应用程序已被激活。PickSaveFileContinuation为文件保存选取器操作挂起应用后，应用程序已被激活。PickFolderContinuation为文件夹选取器操作挂起应用后，应用程序已被激活。WebAuthenticationBrokerContinuation为 Web 身份验证代理操作挂起应用后，应用程序已被激活。 当操作系统终止你的应用后用户又重新启动它时，你的应用可以使用激活还原以前保存的数据。Windows 在应用挂起后可能出于一些原因而将其终止。用户可以手动关闭你的应用或者注销，否则系统的资源可能不足。如果用户在 Windows 终止你的应用之后启动它，该应用将收到一个 activated 事件 (HTML) 或 Application.OnActivated 回调 (XAML)，并且用户将看到应用的初始屏幕，直到该应用激活为止。你可以通过此事件确定你的应用是否需要还原其在上次挂起时保存的数据，或者是否必须加载应用的默认数据。由于初始屏幕已出现，因此你的应用代码可以在不明显拖延用户时间的情况下花费一些处理时间来完成此激活操作，然而在重新启动或继续该操作时前面所提到的关于运行时间较长的操作的问题仍存在。activated/OnActivated 事件数据包括一个 PreviousExecutionState 属性，用于告诉你应用在激活之前处于哪种状态。此属性是 ApplicationExecutionState 枚举中的值之一：  终止原因PreviousExecutionState 属性的值采取的操作已由系统终止（例如，因为资源限制）Terminated还原会话数据被用户关闭或被用户终止进程ClosedByUser  使用默认数据启动意外终止，或者应用在当前用户会话期间未运行NotRunning使用默认数据启动 注意  当前用户会话基于 Windows 登录。只要当前用户未显式注销、关闭当前用户会话，或者 Windows 未出于其他原因而重新启动它，该会话便可以保留在诸如锁屏身份验证、切换用户等多个事件中。PreviousExecutionState 还可能有 Running 或 Suspended 值，但在这些情况下，你的应用不是之前终止的，因此不必担心还原数据。注意  如果你使用计算机的管理员帐户登录，则你将无法激活任何 Windows 运行时应用。有关详细信息，请参阅应用扩展。OnActivated 与 XAML 应用中的特定激活的对比在 XAML 激活模型和 Application 类 中，可使用 OnActivated 方法来处理所有可能的激活类型。但是，更常见的做法是使用不同的方法来处理最常见的激活类型，而对于不太常见的激活类型，则仅使用 OnActivated 作为回滚方法。例如， Application 具有 OnLaunched 方法，用于在 ActivationKind 是 Launch 时作为回调进行调用，这是适用于大多数应用的典型激活方法。有超过 6 种 On* 方法可用于特定的激活：OnCachedFileUpdaterActivated、OnFileActivated、OnFileOpenPickerActivated、OnFileSavePickerActivated、OnSearchActivated 和 OnShareTargetActivated。XAML 应用的起始模板具有一个针对 OnLaunched 的实现和一个适用于 Suspending 的处理程序，并且兼具每个模板中预定义的 SuspensionManager 类中的这两种合并方法。对于 SuspensionManager 的作用的描述在本主题的范围内；有关详细信息，请参阅适用于应用的 C#、VB 和 C++ 项目模板。应用挂起应用可在用户离开它或设备进入电量不足状态时挂起。大部分应用会在用户离开它们时挂起。当用户将一个应用移动到后台时，Windows 将等待几秒，以查看用户是否打算立即返回该应用。如果用户在此时间段内没有切换回，Windows 将挂起该应用。如果应用已经为 WinJS checkpoint 事件（适用于 HTML）或 Application.Suspending 事件（适用于 XAML）注册一个事件处理程序，则在要挂起该应用之前调用此代码。你可以使用事件处理程序保存相关应用和用户数据。我们建议使用应用程序数据 API 完成此目的，因为它们可保证在应用进入 Suspended 状态之前完成工作。有关详细信息，请参阅使用 Windows 运行时访问应用数据。你还应释放独占资源和文件句柄，这样在你的应用没有使用它们时其他应用可以访问。通常，你的应用应该在处理挂起事件时立即保存其状态并释放其独占资源和文件句柄，并且此代码最多只需 1 秒便可完成工作。如果应用在 Windows 上未在 5 秒内和在 Windows Phone 上未在 1 至 10 秒之间从挂起事件中返回，则 Windows 假设应用已停止响应并终止该应用。Windows 会尝试在内存中保留尽可能多的挂起应用。通过将这些应用保留在内存中，可确保用户在已挂起的应用之间快速且可靠地切换。但是，如果没有足够的资源将应用保留在内存中，则 Windows 可能会终止你的应用。应用不会收到它们被终止的通知，所以你保存应用数据的唯一机会是在挂起期间。当应用确定它在终止后被激活时，它应该加载它在挂起期间保存的应用数据，以使其按照被挂起前的方式运行。有些应用必须继续运行才能完成后台任务。例如，你的应用可以在后台继续播放音频；有关详细信息，请参阅“如何在后台播放音频”（HTML 或 XAML）。此外，即使你的应用挂起甚至终止，后台传输操作仍将继续；有关详细信息，请参阅“如何下载文件”（HTML 或 XAML）。有关指南，请参阅应用挂起和恢复指南。有关示例代码，请参阅“如何挂起应用”（HTML 或 XAML）。应用可见性当用户从你的应用切换到其他应用时，你的应用将不再可见，但仍保持 Running 状态，直到 Windows 可以挂起它为止。如果用户离开你的应用，但在挂起它之前又激活或返回到该应用，它会保持 Running 状态。当应用可见性更改时，你的应用不会收到激活事件，因为它仍在运行中。Windows 只需根据需要来回切换应用即可。如果你的应用需要在用户离开和返回时执行某些操作，则可以处理 visibilitychange 事件 (HTML) 或 Window.VisibilityChanged 事件 (XAML)。可见性事件不按挂起/恢复或激活事件排序。不要假定这些事件按特定的顺序传入。应用恢复挂起的应用在用户切换到该应用或设备从电量不足状态恢复时恢复。有关应用在恢复时所处状态的枚举，请参阅 ApplicationExecutionState。应用从 Suspended 状态恢复时，它会进入 Running 状态并从挂起的位置和时间处继续运行。 不会丢失任何应用数据，但前提是数据是保存在内存中的。因此，大多数应用在恢复时不需要执行任何操作。但是，应用可能挂起数小时甚至数天。因此，如果应用拥有可能已过时的内容或网络连接，这些内容或网络连接应该在应用恢复时刷新。如果应用已经为 WebUIApplication.resuming 事件 (HTML) 或 Application.Resuming 事件 (XAML) 注册一个事件处理程序，则在应用从 Suspended 状态恢复时调用它。你可以使用该事件处理程序刷新应用内容和数据。注意  具体而言，HTML 应用通常不需要专门处理 resuming，因为 activated 将在相同的情况下触发。你可以使用 activated 事件数据中的 ActivationKind 信息来确定是否恢复应用；此模式在起始项目模板的 default.js 文件中显示。如果挂起的应用被激活以加入一个应用合约或扩展，它会首先收到 Resuming 事件，然后收到 Activated 事件。当应用挂起时，它不会收到它注册接收的网络事件。这些事件没有排队，所以它们会丢失。因此，你的应用应该在恢复时测试网络状态。有关指南，请参阅应用挂起和恢复指南。有关示例代码，请参阅“如何恢复应用”（HTML 或 XAML）。注意  在 Windows Phone 应用商店应用的 XAML 应用中，每次用户从“开始”磁贴或应用列表启动应用时都会调用 OnLaunched，即便该应用当前在内存中已挂起也是如此。在 Windows 上，从“开始”磁贴或应用列表启动挂起的应用不会调用此方法。应用关闭通常，用户不需要关闭应用，他们可以让 Windows 管理它们。但是，用户可以选择以下方法来关闭应用：使用关闭手势，在 Windows 上按 Alt+F4，或在 Windows Phone 上使用任务切换器。你不能在应用中包括任何 UI 以让用户关闭应用，否则该应用不会通过应用商店的认证过程。没有任何特殊事件指示用户已关闭应用。在用户关闭应用之后，它将被挂起并终止，然后进入 NotRunning 状态。在 Windows 8.1 以及更高版本中，在用户关闭应用之后，该应用将从屏幕中移除并切换列表，但并未显式终止。注意  如果你的应用依赖于 Windows 8 的用户关闭行为，则在将系统升级到 Windows 8.1 时可在此应用中启用此行为。若要启用 Windows 8 的用户关闭行为，请使用 ApplicationView.TerminateAppOnFinalViewClose 属性将你的 Windows 8.1 应用设置为在最后一个窗口关闭后终止。如果应用已经为 Suspending 事件注册了一个事件处理程序，当应用被挂起时则会调用该处理程序。你可以使用此事件处理程序将相关应用程序和用户数据保存到持久性存储中。用户关闭行为:  建议你决定当用户关闭应用后再激活应用时，应用具有的行为。应用被 Windows 终止或被用户终止可能没有任何区别。如果应用在被用户关闭时需要执行与被 Windows 关闭时不同的操作，你可以使用激活事件处理程序确定应用是被用户终止的还是被 Windows 终止的。请参阅 ApplicationExecutionState 枚举参考中 ClosedByUser 和 Terminated 状态的说明。如果你要维护一个 Windows 8 应用，请注意处理 ClosedByUser 的方式可能与 Windows 8.1 应用所使用的方式不同。我们建议，应用不要以编程方式自行关闭，除非绝对必要。例如，如果应用检测到内存泄漏，它可以关闭自己来确保用户个人数据的安全。当你以编程方式关闭应用时，系统会将此视为应用崩溃。应用故障应用需要遵守系统故障体验，只需返回到“开始”屏幕。系统故障体验旨在让用户尽快返回执行的操作，因此不应提供警告对话框或其他通知，因为这会拖延用户的时间。应用消失应清楚地告诉用户出现了问题。如果你的应用出现故障、停止响应或者发生意外，Windows 将请求用户同意向 Microsoft 发送问题报告。Microsoft 在问题报告中向你提供错误数据的一个子集，这样你可以使用这些数据改进你的应用。你可以在“仪表板”中应用的“质量”页面中看到此数据。当用户在应用出现故障之后激活该应用时，其激活事件处理程序将收到 NotRunning 的 ApplicationExecutionState 值，并且将显示其初始 UI 和数据。崩溃后，请勿经常使用原本将用于 Resuming 和 Suspended 的应用数据，因为该数据可能已损坏；请参阅应用挂起和恢复指南。应用删除当用户删除你的应用时，会一同删除应用及其所有本地数据。删除应用不会影响存储在公用位置的用户数据，例如文档或图片库中的文件。应用生命周期和 Visual Studio 项目模板对于 HTML 或 XAML 应用，在起始 Visual Studio 项目模板中提供了与应用生命周期相关的基本代码。基本代码可处理启动激活，甚至可以在添加任何你自己的代码之前显示其主要 UI。应用程序生命周期中的关键 APIWindows.ApplicationModel 命名空间Windows.ApplicationModel.Activation 命名空间Windows.ApplicationModel.Core 命名空间Windows.UI.WebUI 命名空间 (HTML)Windows.UI.Xaml.Application 类 (XAML)Windows.UI.Xaml.Window 类 (XAML)WinJS.Application 命名空间 (HTML)

版权声明：本文为博主原创文章，未经博主允许不得转载。

swift详解之十二-----------------泛型
泛型
注：本文详细讲解泛型，对写一些公共方法，共用的东西的时候很有帮助。想成为一个优秀的程序员吗？这个必须掌握

泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活可重用的函数和类型。
下面直接看一个简单的示例 ， 泛型其实就是在写的时候不指定是哪种类型 ， 只有再用得时候才指定类型 ，这些类型可以给一些限定。例如 Array Dictionary 等 
写一个简单的交换数据的方法，不限定类型
func swapTwoValue<T>(inout a:T,inout _ b:T){
    let temp:T = a
    a = b
    b = temp
}
这里用T代表一种类型 ，但是没有指定 ， 在函数参数和函数体中都可以使用 
var a = 10 , b = 20
swapTwoValue(&a, &b)
print("\(a) , \(b)")//20 , 10

var c = "hello" ,d = "world"
swapTwoValue(&c, &d)
print("\(c) , \(d)") //world , hello
可以看到用Int 和 String 类型都可以使用此方法 
T只代表一种类型 如果传入两种类型就会报错 
var s1 = "hello"
var s2 = 10
swapTwoValue(&s1, &s2)// cannot invoke 'swapTwoValue' with an argument list of type '(inout String, inout Int)'
当然你也可以指定两种类型
func dic<k,v>(a:k,_ b:v){

}
我们这里模拟实现一个栈的操作。栈的特点是后进先出 
struct IntStack{
    var items = [Int]()

    mutating func push(item:Int){
        items.append(item)
    }

    mutating func pop(){
        items.removeLast()
    }
}
var intStack = IntStack();
intStack.push(1);
print(intStack.items) //[1]
这是一个Int类型的 ，我们看下泛型的 
struct Stack<T>{
    var items = [T]()

    mutating func push(item:T){
        items.append(item)
    }

    mutating func pop()->T{
           return items.removeLast()
    }

    subscript(i:Int)->T{
        get{
            return items[i]
        }
        set{
            items[i]=newValue
        }
    }
}


var stack = Stack<String>();

stack.push("hello")
stack.push("ww")
print(stack[0]) //hello
stack[1] = "world"
print(stack) //Stack<Swift.String>(items: ["hello", "world"]
这里只实现了基本的pop 和push功能 
我们也可以扩展我们的泛型 ，而且不需要提供参数类型
extension Stack{
    var topItem:T?{
        return items.isEmpty ? nil:items[items.count-1]
    }
}
var s1 = Stack<Int>();
s1.push(20)
s1.push(19)
print(s1.topItem) //Optional(19)
我们也可以对泛型进行约束 
protocol A{}
func func1<T:A>(t:T){

}
这里这个泛型类型必须为协议A的遵循者 ， 这里也可以写某个类 代表类的继承者 
不是所有的 Swift 中的类型都可以用等式符（==）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。 
不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个Equatable协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift 标准类型自动支持Equatable协议。
func findIndex<T: Equatable>(array: [T], valueToFind: T) -> Int? {
    for (index, value) in  array.enumerate() {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
let strs = ["sss","aaa","ddd"];
print(findIndex(strs, valueToFind: "ddd"))  //2
关联类型  
当定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名(或别名)。作用于关联类型上实际类型是不需要指定的，直到该协议接受。关联类型被指定为typealias关键字。
protocol Container{
    //声明一个类型 不指定是什么类型
    typealias itemType
    mutating func append(item:itemType)
    subscript(i:Int)->itemType{ get }
}
这里定义一个协议 ， 声明一个类型 不指定是什么类型 ， 然后有个append有一个itemType类型的参数 ， 还有个下标脚本，就是数组的基本操作 
struct Quene<T>:Container{

    var items = [T]()

    //可以推断出是T

    mutating func append(item:T)
    {
        items.append(item)
    }

     subscript(i:Int)->T{
           return items[i]
     }
}
这里可以智能推断是typealias itemType 就是这里的泛型T
非常简单 ，使用就不再赘述 
我们也可以使用where字句来约束泛型 ，放在泛型参数后面即可 。
//可以通过where语句来定义约束
func compare<c1:Container,c2:Container
    where c1.itemType == c2.itemType,c1.itemType:Equatable>(a:c1 , _ b:c2){

    //这里就可以为所欲为了

}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Design Support Library概览
尊重劳动成果，转载请注明出处：http://blog.csdn.net/growth58/article/details/47972467 
关注新浪微博：@于卫国 
邮箱：yuweiguocn@gmail.com
简介
在Google I/O 2015大会中，Google为Android开发者介绍了Design Support Library。这个library可以让开发者很容易地实现更多Material Design概念到他们的应用中，因为很多关键元素是不可用的在原来的框架外。首先就是很易于使用，Design Support Library向下兼容到API 7。Design Support Library可以引入到你的Android工程中通过导入Gradle依赖。
compile 'com.android.support:design:22.2.0'
视觉组件 
在Design支持库中有两个主要类别的工具：

视觉组件
动作组件

我们先看看有哪些新的视觉组件可以应用到你的App上。
Material Text Input
EditText自从最开始就已经在Android中了，并且使用很简单，他们一直没有什么改变。使用Design Support Library，Google已经介绍了新的包含容器叫作TextInputLayout。这个新的view添加功能到标准的EditText上，例如支持让你的用户界面弹出错误消息和动画提示。
正如下面的代码所示，TextInputLayout 可以包含在你的布局文件中包裹一个标准的EditText。
<android.support.design.widget.TextInputLayout
    android:id="@+id/textinput"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <EditText
        android:id="@+id/edittext"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="What is your name?" />

</android.support.design.widget.TextInputLayout>
Gianluca Segato 会带着你学习TextInputLayout 组件的使用在教程中。
Floating Action Buttons
在Material Design 应用中最占优势的用户界面组件之一就是Floating Action Buttons。自从他们的介绍后，开发者不得不从头开始创建这些按钮或者是从很多第三方设计的类库特别是这些按钮相关的选择一个。
使用Design 支持库，floating action buttons可以包含在一个布局中并且挂靠在屏幕的一部分用简单几行代码。每个按钮都可以用icons和colors很容易地进行自定义。可以使用两个sizes ，standard (56dp) 和 mini (40dp)。最大的优势之一是Google已经支持这些按钮作为他们的设计演变。
<android.support.design.widget.FloatingActionButton
    android:id="@+id/fab"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="end|bottom"
    android:layout_margin="16dp"
    android:src="@drawable/ic_fab" />
导航组件
当ViewPager 和DrawerLayout 组件通过v4 support library可用时，Google已经对其进行了扩展通过提供两个新的相关的部件。第一个是官方版本常用的ViewPagerIndicator library由Jake Wharton开发称为TabLayout。第二个是NavigationView，提供drawer header的支持。
TabLayout
TabLayout组件可以用代码使用addTab方法手动添加内容。看看下面的例子。
tabLayout.addTab(tabLayout.newTab().setText("Tab 1"));
tabLayout.addTab(tabLayout.newTab().setText("Tab 2"));
tabLayout.addTab(tabLayout.newTab().setText("Tab 3"));
另外，你可以将TabLayout和ViewPager组件进行关联。通过调用setupWithViewPager()可以完成，使用ViewPager作为参数。这是另一种方式切换ViewPager的页面。应该注意的是getPageTitle()需要被重写当使用TabLayout和ViewPager时给每个Tab一个合适的名称。

NavigationView
NavigationView是一个新的部件继承了DrawerLayout的功能。开发者使用这个组件能很容易地添加头布局到drawer 和标记已选择的部分。
除此之外，它现在可以通过菜单资源文件非常简单地创建sections和subsections在drawer 中。一个NavigationView需要和一个DrawerLayout进行关联在XML文件中。
<android.support.v4.widget.DrawerLayout      xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/drawer_layout"
    android:layout_height="match_parent"
    android:layout_width="match_parent"
    android:fitsSystemWindows="true">

    <include layout="@layout/content"/>

    <android.support.design.widget.NavigationView
        android:id="@+id/nav_view"
        android:layout_height="match_parent"
        android:layout_width="wrap_content"
        android:layout_gravity="start"
        android:fitsSystemWindows="true"
        app:headerLayout="@layout/nav_header"
        app:menu="@menu/drawer_view"/>

</android.support.v4.widget.DrawerLayout>

增强的Toasts
Toast消息成为Android中主要的功能已经多年，一个新的用户界面部件叫作Snackbar可用于提供相似功能但改善了外观。Snackbar 不仅能给用户提示短时间的信息，它还支持一个动作添加到上下文中基于你的应用的功能并且可以使用手势滑掉使其消失。
Snackbar 比Toast功能有所增强，使用它需要注意的是需要创建一个可以被用来找到应用显示的最底部的View。
Snackbar.make( view, "Action", Snackbar.LENGTH_LONG )
    .setAction("Action!", new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Log.e("App", "Action!");
        }
    } )
    .show();

动作组件
一个用户界面特效和动画在Material Design中是非常重要的。为了促进这个，Googlen已经发布了多个常见用例的组件在Design支持库中。Kerry Perez-Huanca将会在教程中带着大家学习Design支持库中的这方面的组件。
Reactive Views
你可能已经注意到了在之前例子中的FloatingActionButton会在Snackbar出现的时候向上移动。这是用一个新的部件叫作CoordinatorLayout完成的，用它包裹的view应该给其它view留出空间。
改善Quick Return and Toolbars
很多开发者询问用最简单的方式显示一个视差图片作用于快速返回设计模式，随着用户上下滑动而出现或消失。你可以在Play Store的应用列表看到这个效果。为了让开发者实现这个功能不用写大量冗余代码，Google发布了CollapsingToolBarLayout 和AppBarLayout views。在这些部件里使用不同的选项，开发者能固定views在屏幕的顶部或特定的位置当这些views应该随着用户滑动显示时。

总结
Design 支持库带来了大量期待已久的工具在Android上。当它和AppCompat 库配合使用时，它变得很容易地添加Material Design到应用上并且保持向下兼容。
可以在Google官方相关的应用上找到这些新组件是怎样工作的很多例子，CheeseSquare，Tuts+将会继续提供深入教程在怎样实现这些新特征上。
请我喝杯咖啡，请使用支付宝扫描下方二维码： 

原文地址：http://code.tutsplus.com/articles/overview-of-the-android-design-support-library–cms-24234

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
解析程序员的几个成长阶段

软件开发这个行业往往是供不应求，这跟开发人员的素质有很大的关系，在这个浮躁的圈子里，能在一家公司呆上三年以上的程序员，通常就会把持领导岗位，结果做出来的东西大多非常糟糕。这也说明了，程序员的能力不能完全靠工作年限来划分。怎么样才可以成为一名合格的高级程序员？今天为大家解析程序员的几个成长阶段。

初级程序员
初级开发人员是这样的，刚从学校出来，就像坐井观天中的青蛙一样，自认为什么都会。突然间，你发现自己面对的问题，靠学校中的那点知识是远远不够的。问题要更复杂，更凌乱，没有理论上说的那么纯粹。你正处于放弃还是坚持的分叉路口，你不知道该怎么办。
对策就是专心致志，专心致志地竭尽全力学习。初级开发人员需要大量的指导、监督和辅导，否则他们将会在这一阶段呆上很长一段时间。因此，实际上你也可以将这一阶段视为策略和日常技术的吸收消化时期。
初级开发人员关注代码，而不注重开发，他们不明白两者之间的区别。如果一个程序员表示“要是代码不需要面向所有用户，那他们会更喜欢编码”，那么我可以判断这是一个初级开发人员。
一个优秀的初级开发人员给定一个已知任务之后，就能够迅速良好地执行。
中级开发人员逐渐能够意识到失败(通常是他们自己的失败)模式，并认识到比起实际构建匆匆忙忙去做重点任务其实所需要的时间和精力更多，并且也不会因为有人说要改一改而一下子垂头丧气。他们也经历过自以为写出了引以为豪的内容，实际上证明是垃圾的悲惨遭遇。

中级程序员
中级开发人员寻寻觅觅于用正确的方法去构建，去解决问题，他们会通过实验、文献和与其他程序员的讨论去发现这些正确的方法。这实际上已经是学习软件架构的水准，而不再是构建代码(我们在学校里学的就是这个)水平。
没有受到监督的中级开发人员构建的系统之所以失败的原因和初级开发人员的失败原因截然不同。初级开发人员会构建一堆稍微有点用的算法。而优秀的中级开发人员会跳出《Design Patterns》和《Domain DrivenDesign》的禁锢。虽然这些都是学习构建大型OO系统的好书，但是直接应用理论只会导致死板的设计结果，不重要的地方灵活多变，重要的地方却又死板无法更改。
你可以信任中级开发人员构建的系统，他们的系统毫无疑问比初级开发人员做的要好，但是时间久了，依然会有各种问题出现，成为拦路虎。一个可悲的事实是，绝大多数高级开发人员，甚至团队领导者其实都还只是——中级开发人员。当然，大多数人都没有这样的自我觉悟，原因是他们根本没有和更高水平的人一起工作过。
一个优秀的中级开发人员应该懂得使用代码来解决问题只是一种手段而不是目的。然而，他们仍然深爱着纯粹的设计，仍然渴望寻求所谓“正确的方式”来构建软件。
优秀的中级开发人员依然需要少量的监管。毫无疑问，他们能够提升代码设计，并在设计讨论中发挥重要作用。他们是开发团队中的主力。但是，对于他们，进一步的指导和更高层次的监管依然至关重要。

高级程序员
高级开发人员熟悉失败。他们已经经历过编写的代码在低于设计和超越设计的情况下都失败的情况。他们深思熟虑，在面对问题时，能够心智成熟地评估成功与失败。高级开发人员已经跳出了中级开发人员深爱的复杂性，开始沉迷于简单。
高级开发人员悉知自己的长处和短处，力争尽可能地扬长避短。
高级开发人员深知理论联系实际的重要。他们明白，世上没有所谓的构建软件的“正确方式”，建立良好软件的唯一途径是要将理论适应客户、代码库、团队、工具和组织的需求。
高级开发人员理解并权衡领域涉及的一切，同时会思考如何去支持设计模式、库、框架和流程。
高级开发人员不仅仅了解自我，还知晓组织和客户的工作方式和价值观，以及对于组织和客户而言成功相关的重要和不重要的因素。一旦出现问题，高级开发人员会想方设法地去解决。“这不是我的工作”——他们永远，永远也不会说这样的话语。
高级开发人员心里明白，他们的工作应该是提供解决问题的办法，而不是写代码。
不像中级开发人员辛苦耕耘于枯燥的日常工作，高级开发人员会退一步，去思考是什么导致了这些无聊的工作。他们会评估修复根本问题的成本，要么直接解决这些问题，要么研究起来以便于最终彻底解决。
高级开发人员明白，单枪匹马是搞不定项目的。他们的主要作用是帮助团队变得更好，同时争取个人共同进步。
高级开发人员深刻理解，领导一职代表的不是权力，而是授权，不是方向，而是服务。
如果你的团队中一个高级开发人员都没有起到领导作用，那么你的项目是注定要失败的。一队伟大的中级开发人员固然能让你走得很远，但是他们构建的软件的好日子却是屈指可数的，其最终结果要么是关门大吉，要么是高风险高成本的重写。高级开发人员才是唯一能胜任选择技术和平台的人。
简单粗暴的分类方法
我非常讨厌现在流行的根据工作经验年限来给程序员划分档次的方法。多年的经验的确能让你增加见识，但这都是一些几乎毫无意义的背景信息。
更重要的是，我们的行业需要刚从大学毕业活力四射的年轻人，也需要那些有着15—20年工作经验的老程序员。我们应该从团队和企业的角度来思考人才组成。
推荐阅读：
程序员的三大发展方向

20年资深程序员编程经验分享


版权声明：本文为博主原创文章，未经博主允许不得转载。

anroid OpenGL ES之 向shader传递数据
android OpenGL ES开发之前世今生 
android OpenGL ES开发之shader 
anroid OpenGL ES之 向shader传递数据
void glUseProgram( int program );
glUseProgram()真正载入着色器程序到我们的程序中在这之后我们就可以向shader中传递数据了
int glGetAttribLocation( int program, String name );
向shader中的Attribute变量或者Uniform变量传递数据，首先要知道其在内存中的位置。glGetAttribLocation()得到属性的位置。program参数是程序的句柄，name参数是shader程序中变量的名称
void glVertexAttribPointer(int index, int size, int type, boolean normalized, int stride, int offset)
glVertexAttribPointer可以向Attribute变量传递数据。参数index是变量位置参数size， 1 for float; 2 for vec2; 3 for vec3参数type，可选 GLES20.GL_FLOAT GLES20.GL_INT参数normalized，为true，则把数据按比例缩小到-1~1
int glGetUniformLocation( int program, String name );
glGetUniformLocation获得Uniform变量在内存中的位置
void glUniform1f( int location, float x );
glUniform1f向Uniform变量传递数据

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift下拉菜单动画实现
学iOS开发时间也不短了，但对CoreGraphics自定义动画这块一直都不算太熟练，一是因为默认动画可以在一定程度上满足需求，二也是因为自定义动画这块的第三方库相当多，我也一直没有重复造轮子，但前几天在AppCoda上看到一篇关于自定义动画Demo的文章，觉得还不错，认真研读一下也当弥补自己知识面的漏洞了


先上效果图








文件目录图如下








NewsTableView是效果图中下方的内容展示页面，MenuTableView是上方黑色的Menu列表，MenuTransitionManger就是这篇文章的重点--菜单动画控制类

首先我们来看一下这个类的的接口部分



<pre name="code" class="plain">    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        let menuTableViewController = segue.destinationViewController as! MenuTableViewController
        menuTableViewController.currentItem = self.title!
        menuTableViewController.transitioningDelegate = self.menuTransitionManager
        self.menuTransitionManager.delegate = self
    }


这个prepareForSegue函数位于NewsTableViewController中，menuTransitionManager是控制类在当前类的实例，在该函数中，我们通过segue获取了动画的目的视图控制器，也就是menuTableViewController，然后将他的过渡动画代理设置成了我们实例化的控制类，最后一行代码是为了实现点击空白处dismiss掉弹出菜单，这个最后再讲



class MenuTransitionManager: NSObject, UIViewControllerAnimatedTransitioning, UIViewControllerTransitioningDelegate {
   
    var duration = 0.5
    var isPresenting = false
   
    var snapshot:UIView? {
        didSet {
            if let _delegate = delegate {
                let tapGestureRecognizer = UITapGestureRecognizer(target: _delegate, action: "dismiss")
                snapshot?.addGestureRecognizer(tapGestureRecognizer)
            }
        }
    }
   
    var delegate:MenuTransitionManagerDelegate?
   
    func transitionDuration(transitionContext: UIViewControllerContextTransitioning?) -> NSTimeInterval {
        return duration
    }
   
    func animateTransition(transitionContext: UIViewControllerContextTransitioning) {
       
        //得到源视图和目的视图的引用
        let fromView = transitionContext.viewForKey(UITransitionContextFromViewKey)!
        let toView = transitionContext.viewForKey(UITransitionContextToViewKey)!
       
        //设置变换过程
        let container = transitionContext.containerView()
        let moveDown = CGAffineTransformMakeTranslation(0, container!.frame.height - 150)
        print("container!.frame.height - 150 \(container!.frame.height - 150)")
        let moveUp = CGAffineTransformMakeTranslation(0, -50)
       
        //将两个视图添加到容器视图中
        if isPresenting {
            toView.transform = moveUp
            snapshot = fromView.snapshotViewAfterScreenUpdates(true)
            print("toView.frame: \(toView.frame)")
            print("fromView.frame: \(fromView.frame)")
            print("snapshot.frame: \(snapshot!.frame)")
            container?.addSubview(toView)
            container?.addSubview(snapshot!)
        }
       
        //展示动画
        UIView.animateWithDuration(duration, delay: 0.0, usingSpringWithDamping: 0.9, initialSpringVelocity: 0.3, options: [], animations: {
           
            if self.isPresenting {
                self.snapshot?.transform = moveDown
                toView.transform = CGAffineTransformIdentity
            } else {
                self.snapshot?.transform = CGAffineTransformIdentity
                fromView.transform = moveUp
            }
           
           
            }, completion: { finished in
               
                transitionContext.completeTransition(true)
                if !self.isPresenting {
                    self.snapshot?.removeFromSuperview()
                }
        })
    }
   
    func animationControllerForDismissedController(dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        isPresenting = false
        return self
    }
   
    func animationControllerForPresentedController(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
       
        isPresenting = true
        return self
    }
   
}
这是菜单动画控制类的具体代码实现，要做ViewController的过渡动画代理首先必须遵守UIViewControllerTransitioningDelegate，而UIViewControllerAnimatedTransitioning协议用于提供具体的动画动作


最后的两个函数用于在弹出和收回菜单时改变isPresenting标志的真假以展示正确的弹出或收回动画


animateTransition函数是真正的动画执行函数，首先调用当前transitionContext的viewForKey函数来获得源视图和目的视图的引用，在当前的项目里也就分别是NewsTableView和MenuTableView，MoveDown动画用于在弹出菜单时下方的NewsTableView的snapshot，也就是覆盖在原NewsTableView上的截图为弹出的MenuTableView让出150的y轴空间，MoveUp动画用在了两个地方，一个是弹出时MenuView先向上50再向下展示，有种bounce的效果，第二个是NewsTableView在snapshot恢复原位置时向上移动50，说实话我没看懂这里，因为执行到这里的时候在最上层展示的是MenuTableView和snapshot，修改NewsTableView的动画效果大概没什么用，我把这句注释掉和把y轴位移由-50改为-5000都没发现什么变化，如果我理解错了请告诉我..


snapshotViewAfterScreenUpdates是iOS7提供的API，用于快速简单的创建一张某个View的截图，常用于页面转换动画


后面的UIView.animateWithDuration是动画的具体执行过程，CGAffineTransformIdentity是View动画执行前的位置，如果弹出，截图y轴向下移动150，MenuTableView放置到原位置，也就是这个View在自己ViewController的位置，如果收回，截图回到原位置


最后我来说一下这段为实现点击空白处返回的代码


    var snapshot:UIView? {
        didSet {
            if let _delegate = delegate {
                let tapGestureRecognizer = UITapGestureRecognizer(target: _delegate, action: "dismiss")
                snapshot?.addGestureRecognizer(tapGestureRecognizer)
            }
        }
    }
这是Swift语法里的Property observer，当snapshot被赋值时，我们为其添加点击事件，这个点击事件由delegate的dismiss函数执行，这是经典的delegate设计模式了，NewsTableViewController作为代理的执行者，执行dismiss函数



    func dismiss() {
        dismissViewControllerAnimated(true, completion: nil)
    }


然后又触发了那个isPresenting = false的函数，随之引发收回菜单的动画效果


整个工程可在原链接中下载到：http://www.appcoda.com/slide-down-menu-swift/
可能需要科学上网 :) 觉得我讲的清楚的可以点个赞 (ﾉ ○ Д ○)ﾉ　





版权声明：本文为博主原创文章，未经博主允许不得转载。

android 自定义Button,满足你对Button呈现样式的一系列要求
转载请注明出处：王亟亟的大牛之路
我们平时自定义的一些Button通常是改改颜色啊，文本啊，圆角啊之类的。如果要做到再高级点就需要用一个大布局还拼接了，如果一个页面有很多样式不同的这样的按钮，还真不怎么好操作。 
今天给大家上一个FancyButton能很好的帮助我们简化这些操作 
项目结构： 

只有一个类外加一些assets包下的字体文件或资源文件的一些Icon就能呈现以下效果：
 
首先先介绍下FancyButton这个类的一些重要的方法和实现：
继承LinearLayout根据我们的实际场景需要再判断为水平还是垂直的LinearLayout
public class FancyButton extends LinearLayout
一系列的初始化操作和参数申明
 private Context mContext;

    // 初始化背景参数
    private int mDefaultBackgroundColor         = Color.BLACK;
    private int mFocusBackgroundColor           = 0;

    //初始化字体参数
    private int mDefaultTextColor               = Color.WHITE;
    private int mDefaultIconColor               = Color.WHITE;
    private int mTextPosition                   = 1;
    private int mDefaultTextSize                = 15;
    private int mDefaultTextGravity             = 0x11; // Gravity.CENTER
    private String mText                        = null;

    // 初始化Icon参数
    private Drawable mIconResource              = null;
    private int  mFontIconSize                  = 15;
    private String mFontIcon                    = null;
    private int mIconPosition                   = 1;

    private int mIconPaddingLeft                = 10;
    private int mIconPaddingRight               = 10;
    private int mIconPaddingTop                 = 0;
    private int mIconPaddingBottom              = 0;


    private int mBorderColor                    = Color.TRANSPARENT;
    private int mBorderWidth                    = 0;

    private int mRadius                         = 0;

    private Typeface mTextTypeFace = null;
    private Typeface mIconTypeFace = null;


    /**
     * 标识图标位置的标记
     */
    public static final int POSITION_LEFT       = 1;
    public static final int POSITION_RIGHT      = 2;
    public static final int POSITION_TOP        = 3;
    public static final int POSITION_BOTTOM     = 4;
    //默认字体
    private String mDefaultIconFont = "fontawesome.ttf";
    private String mDefaultTextFont = "robotoregular.ttf";

    private ImageView mIconView;
    private TextView mFontIconView;
    private TextView mTextView;

构造函数
 /**
     * 默认构造函数
     * @param context : Context
     */
    public FancyButton(Context context){
        super(context);
        this.mContext   = context;

        mTextTypeFace   = Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", mDefaultTextFont));
        mIconTypeFace   = Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", mDefaultIconFont));

        initializeFancyButton();
    }

    /**
     * 默认构造函数调用布局
     * @param context : Context
     * @param attrs : Attributes Array
     */
    public FancyButton(Context context, AttributeSet attrs){
        super(context,attrs);
        this.mContext = context;

        TypedArray attrsArray   = context.obtainStyledAttributes(attrs,R.styleable.FancyButtonsAttrs, 0, 0);
        initAttributsArray(attrsArray);
        attrsArray.recycle();

        initializeFancyButton();

    }
对一些控件所需的素材进行初始化操作
 /**
     * 各种初始化
     */
    private void initializeFancyButton(){

        initializeButtonContainer();

        mTextView       = setupTextView();
        mIconView       = setupIconView();
        mFontIconView   = setupFontIconView();

        int iconIndex,textIndex;
        View view1,view2;

        if(mIconView == null && mFontIconView == null && mTextView == null){
            Button tempTextView = new Button(mContext);
            tempTextView.setText("Fancy Button");
            this.addView(tempTextView);

        }else{
            this.removeAllViews();
            setupBackground();

            ArrayList<View> views = new ArrayList<>();

            if(mIconPosition == POSITION_LEFT || mIconPosition == POSITION_TOP){

                if(mIconView != null){
                    views.add(mIconView);
                }

                if(mFontIconView != null){
                    views.add(mFontIconView);
                }
                if(mTextView != null){
                    views.add(mTextView);
                }

            }else{
                if(mTextView != null){
                    views.add(mTextView);
                }

                if(mIconView != null){
                    views.add(mIconView);
                }

                if(mFontIconView != null){
                    views.add(mFontIconView);
                }

            }

            for(View view : views){
                this.addView(view);
            }
        }
    }
 /**
     * 设置文本视图
     * @return : TextView
     */
    private TextView setupTextView(){
        if (mText != null) {
            TextView textView = new TextView(mContext);
            textView.setText(mText);
            textView.setGravity(mDefaultTextGravity);
            textView.setTextColor(mDefaultTextColor);
            textView.setTextSize(mDefaultTextSize);

            textView.setLayoutParams(new TableLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT, 1f));
            if (!isInEditMode() && mTextTypeFace!=null) {
                textView.setTypeface(mTextTypeFace);
            }
            return textView;
        }
        return null;
    }

    /**
     * 设置字体图标视图
     * @return : TextView
     */
    private TextView setupFontIconView(){

        if(mFontIcon!=null){
            TextView fontIconView = new TextView(mContext);
            fontIconView.setTextColor(mDefaultIconColor);

            LayoutParams iconTextViewParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT,1f);
            iconTextViewParams.rightMargin = mIconPaddingRight;
            iconTextViewParams.leftMargin = mIconPaddingLeft;
            iconTextViewParams.topMargin = mIconPaddingTop;
            iconTextViewParams.bottomMargin = mIconPaddingBottom;

            if(mTextView != null){

                if(mIconPosition==POSITION_TOP || mIconPosition==POSITION_BOTTOM){
                    iconTextViewParams.gravity = Gravity.CENTER;
                    fontIconView.setGravity(Gravity.CENTER);
                }
                else{
                    fontIconView.setGravity(Gravity.CENTER_VERTICAL);
                    iconTextViewParams.gravity = Gravity.CENTER_VERTICAL;
                }
            }else{
                iconTextViewParams.gravity = Gravity.CENTER;
                fontIconView.setGravity(Gravity.CENTER_VERTICAL);
            }


            fontIconView.setLayoutParams(iconTextViewParams);
            if(!isInEditMode()){
                fontIconView.setTextSize(mFontIconSize);
                fontIconView.setText(mFontIcon);
                fontIconView.setTypeface(mIconTypeFace);
            }else{
                fontIconView.setText("O");
            }
            return fontIconView;
        }
        return null;
    }

    /**
     * 文本图标资源视图
     * @return : ImageView
     */
    private ImageView setupIconView(){
        if (mIconResource != null){
            ImageView iconView = new ImageView(mContext);
            iconView.setImageDrawable(mIconResource);
            iconView.setPadding(mIconPaddingLeft, mIconPaddingTop, mIconPaddingRight, mIconPaddingBottom);

            LayoutParams iconViewParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            if(mTextView!=null){
                if(mIconPosition==POSITION_TOP || mIconPosition==POSITION_BOTTOM)
                    iconViewParams.gravity = Gravity.CENTER;
                else
                    iconViewParams.gravity = Gravity.START;

                iconViewParams.rightMargin = 10;
                iconViewParams.leftMargin = 10;
            }else{
                iconViewParams.gravity = Gravity.CENTER_VERTICAL;
            }
            iconView.setLayoutParams(iconViewParams);

            return iconView;
        }
        return null;
    }

    /**
     * 初始化属性数组
     * @param attrsArray : Attributes array
     */
    private void initAttributsArray(TypedArray attrsArray){

        mDefaultBackgroundColor         = attrsArray.getColor(R.styleable.FancyButtonsAttrs_defaultColor,mDefaultBackgroundColor);
        mFocusBackgroundColor           = attrsArray.getColor(R.styleable.FancyButtonsAttrs_focusColor,mFocusBackgroundColor);

        mDefaultTextColor               = attrsArray.getColor(R.styleable.FancyButtonsAttrs_textColor,mDefaultTextColor);
        // if default color is set then the icon's color is the same (the default for icon's color)
        mDefaultIconColor               = attrsArray.getColor(R.styleable.FancyButtonsAttrs_iconColor,mDefaultTextColor);
        mDefaultTextSize                = (int) attrsArray.getDimension(R.styleable.FancyButtonsAttrs_textSize,mDefaultTextSize);
        mDefaultTextGravity             = attrsArray.getInt(R.styleable.FancyButtonsAttrs_textGravity, mDefaultTextGravity);

        mBorderColor                    = attrsArray.getColor(R.styleable.FancyButtonsAttrs_borderColor,mBorderColor);
        mBorderWidth                    = (int) attrsArray.getDimension(R.styleable.FancyButtonsAttrs_borderWidth,mBorderWidth);

        mRadius                         = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_radius,mRadius);
        mFontIconSize                   = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_fontIconSize,mFontIconSize);

        mIconPaddingLeft                = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_iconPaddingLeft,mIconPaddingLeft);
        mIconPaddingRight               = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_iconPaddingRight,mIconPaddingRight);
        mIconPaddingTop                 = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_iconPaddingTop,mIconPaddingTop);
        mIconPaddingBottom              = (int)attrsArray.getDimension(R.styleable.FancyButtonsAttrs_iconPaddingBottom,mIconPaddingBottom);

        String text                     = attrsArray.getString(R.styleable.FancyButtonsAttrs_text);
        mIconPosition                   = attrsArray.getInt(R.styleable.FancyButtonsAttrs_iconPosition,mIconPosition);

        String fontIcon                 = attrsArray.getString(R.styleable.FancyButtonsAttrs_fontIconResource);

        String iconFontFamily           = attrsArray.getString(R.styleable.FancyButtonsAttrs_iconFont);
        String textFontFamily           = attrsArray.getString(R.styleable.FancyButtonsAttrs_textFont);

        Drawable icon = null;
        try{
            mIconResource               = attrsArray.getDrawable(R.styleable.FancyButtonsAttrs_iconResource);

        }catch(Exception e){
            mIconResource = null;
        }

        if(fontIcon!=null)
            mFontIcon = fontIcon;

        if(text!=null)
            mText = text;

        if(!isInEditMode()){
            if(iconFontFamily!=null){
                try{
                    mIconTypeFace = Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", iconFontFamily));
                }catch(Exception e){
                    Log.e("Fancy", e.getMessage());
                    mIconTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", mDefaultIconFont));
                }

            }else{
                mIconTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", mDefaultIconFont));
            }

            if(textFontFamily!=null){
                try{
                    mTextTypeFace = Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", textFontFamily));
                }
                catch(Exception e){
                    mTextTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", mDefaultTextFont));
                }

            }else{
                mTextTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", mDefaultTextFont));
            }


        }



    }
    @SuppressLint("NewApi")
    private void setupBackground(){

        // 默认Drawable
        GradientDrawable drawable = new GradientDrawable();
        drawable.setCornerRadius(mRadius);
        drawable.setColor(mDefaultBackgroundColor);
        if (mBorderColor != 0) {
            drawable.setStroke(mBorderWidth, mBorderColor);
        }

        // 焦点/按下 Drawable
        GradientDrawable drawable2 = new GradientDrawable();
        drawable2.setCornerRadius(mRadius);
        drawable2.setColor(mFocusBackgroundColor);
        if (mBorderColor != 0) {
            drawable2.setStroke(mBorderWidth, mBorderColor);
        }

        StateListDrawable states = new StateListDrawable();

        if(mFocusBackgroundColor!=0){
            states.addState(new int[] { android.R.attr.state_pressed }, drawable2);
            states.addState(new int[] { android.R.attr.state_focused }, drawable2);
        }
        states.addState(new int[] {}, drawable);

        if(android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN) {
            this.setBackgroundDrawable(states);
        } else {
            this.setBackground(states);
        }
    }

    /**
     * 初始化按钮的容器
     */
    private void initializeButtonContainer(){

        if(mIconPosition == POSITION_TOP || mIconPosition == POSITION_BOTTOM){
            this.setOrientation(LinearLayout.VERTICAL);
        }else{
            this.setOrientation(LinearLayout.HORIZONTAL);
        }
        LayoutParams containerParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        this.setLayoutParams(containerParams);
        this.setGravity(Gravity.CENTER_VERTICAL);
        this.setClickable(true);
        this.setFocusable(true);
        if(mIconResource==null && mFontIcon==null && getPaddingLeft()==0 && getPaddingRight()==0 && getPaddingTop()==0 && getPaddingBottom()==0){
            this.setPadding(20, 20, 20, 20);
        }
    }

    /**
     * 设置文字内容
     * @param text : Text
     */
    public void setText(String text){
        this.mText = text;
        if(mTextView == null)
            initializeFancyButton();
        else
            mTextView.setText(text);
    }

    /**
     * 设置文字颜色
     * @param color : Color
     * use Color.parse('#code')
     */
    public void setTextColor(int color){
        this.mDefaultTextColor = color;
        if(mTextView == null)
            initializeFancyButton();
        else
            mTextView.setTextColor(color);

    }

    /**
     * 设置图标的颜色独立于文本颜色
     * @param color : Color
     */
    public void setIconColor(int color){
        if(mFontIconView != null) {
            mFontIconView.setTextColor(color);
        }
    }

    /**
     * 设置背景颜色
     * @param color : use Color.parse('#code')
     */
    public void setBackgroundColor(int color){
        this.mDefaultBackgroundColor = color;
        if(mIconView != null || mFontIconView != null || mTextView != null){
            this.setupBackground();
        }
    }

    /**
     * 设置焦点时按钮的颜色
     * @param color : use Color.parse('#code')
     */
    public void setFocusBackgroundColor(int color){
        this.mFocusBackgroundColor = color;
        if(mIconView != null || mFontIconView != null || mTextView != null)
            this.setupBackground();

    }

    /**
     * 设置文字的大小
     * @param textSize : Text Size
     */
    public void setTextSize(int textSize){
        this.mDefaultTextSize = textSize;
        if(mTextView != null)
            mTextView.setTextSize(textSize);
    }

    /**
     * 设置文本重力位置
     * @param gravity : Text Gravity
     */

    public void setTextGravity(int gravity) {
        this.mDefaultTextGravity = gravity;
        if (mTextView != null) {
            mTextView.setGravity(gravity);
        }
    }

    /**
     * 设置间距
     * @param paddingLeft : Padding Left
     * @param paddingTop : Padding Top
     * @param paddingRight : Padding Right
     * @param paddingBottom : Padding Bottom
     */
    public void setIconPadding(int paddingLeft, int paddingTop, int paddingRight, int paddingBottom){
        this.mIconPaddingLeft = paddingLeft;
        this.mIconPaddingTop = paddingTop;
        this.mIconPaddingRight = paddingRight;
        this.mIconPaddingBottom = paddingBottom;
        if(mIconView != null){
            mIconView.setPadding(this.mIconPaddingLeft, this.mIconPaddingTop, this.mIconPaddingRight, this.mIconPaddingBottom);
        }
        if(mFontIconView != null){
            mFontIconView.setPadding(this.mIconPaddingLeft, this.mIconPaddingTop, this.mIconPaddingRight, this.mIconPaddingBottom);
        }
    }

    /**
     * 设置icon来自于资源文件
     * @param drawable : Drawable resource
     */
    public void setIconResource(int drawable){
        this.mIconResource = mContext.getResources().getDrawable(drawable);
        if(mIconView == null || mFontIconView != null) {
            mFontIconView= null;
            initializeFancyButton();
        }
        else
            mIconView.setImageDrawable(mIconResource);
    }

    /**
     * 设置一种字符作为Icon图
     * @param icon : Icon value eg : \uf082
     */
    public void setIconResource(String icon){
        this.mFontIcon = icon;
        if(mFontIconView == null) {
            mIconView=null;
            initializeFancyButton();
        }
        else
            mFontIconView.setText(icon);
    }

    /**
     * 设置Icon尺寸(仅限字符Icon)
     * @param iconSize : Icon Size
     */
    public void setFontIconSize(int iconSize){
        this.mFontIconSize = iconSize;
        if(mFontIconView!=null)
            mFontIconView.setTextSize(iconSize);
    }

    /**
     * 设置图标位置
     * 使用全局变量 (FancyButton.POSITION_LEFT, FancyButton.POSITION_RIGHT, FancyButton.POSITION_TOP, FancyButton.POSITION_BOTTOM)
     * @param position : Position
     */
    public void setIconPosition(int position){
        if(position>0 && position<5)
            mIconPosition = position;
        else
            mIconPosition = POSITION_LEFT;

        initializeFancyButton();
    }

    /**
     * 设置按钮边框的颜色
     * @param color : Color
     * use Color.parse('#code')
     */
    public void setBorderColor(int color){
        this.mBorderColor = color;
        if(mIconView!=null || mFontIconView!=null || mTextView!=null){
            this.setupBackground();
        }
    }

    /**
     * 设置按钮的宽度
     * @param width : Width
     */
    public void setBorderWidth(int width){
        this.mBorderWidth = width;
        if(mIconView != null || mFontIconView != null || mTextView != null){
            this.setupBackground();
        }
    }

    /**
     * 设置按钮的边框半径
     * @param radius : Radius
     */
    public void setRadius(int radius){
        this.mRadius = radius;
        if(mIconView != null || mFontIconView != null || mTextView != null){
            this.setupBackground();
        }
    }

    /**
     * 设置按钮文本的自定义字体
     * @param fontName : Font Name
     * Place your text fonts in assets/fonts/
     */
    public void setCustomTextFont(String fontName){
        try{
            mTextTypeFace = Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", fontName));
        }catch(Exception e){
            Log.e("FancyButtons", e.getMessage());
            mTextTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("fonts/%s", mDefaultTextFont));
        }

        if(mTextView==null)
            initializeFancyButton();
        else
            mTextView.setTypeface(mTextTypeFace);

    }

    /**
     * 设置按钮图标的自定义字体
     * @param fontName : Font Name
     * Place your icon fonts in assets/iconfonts/
     */
    public void setCustomIconFont(String fontName){
        try{
            mIconTypeFace = Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", fontName));
        }catch(Exception e){
            Log.e("FancyButtons", e.getMessage());
            mIconTypeFace= Typeface.createFromAsset(mContext.getAssets(), String.format("iconfonts/%s", mDefaultIconFont));
        }

        if(mFontIconView == null)
            initializeFancyButton();
        else
            mFontIconView.setTypeface(mIconTypeFace);

    }

}

布局文件
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:fancy="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content" android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".MainActivity">

    <LinearLayout
        android:id="@+id/section1"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical" >

        <LinearLayout
            android:id="@+id/section_facebook"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#3b5998"
            android:gravity="center_horizontal"
            android:orientation="vertical"
            android:padding="20dp" >

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_facebook_like"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#3b5998"
                fancy:focusColor="#5577bd"
                fancy:fontIconResource="@string/icon_like"
                fancy:fontIconSize="10sp"
                fancy:iconPosition="right"
                fancy:radius="30dp"
                fancy:text="Like my facebook page"
                fancy:textColor="#FFFFFF"/>

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_facebook_share"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#3b5998"
                fancy:focusColor="#5577bd"
                fancy:fontIconResource="@string/icon_share"
                fancy:fontIconSize="10sp"
                fancy:iconPosition="right"
                fancy:iconPaddingLeft="20dp"
                fancy:iconPaddingRight= "0dp"
                fancy:radius="30dp"
                fancy:text="Share the link"
                fancy:textColor="#FFFFFF"/>

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_facebook_follow"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#3b5998"
                fancy:focusColor="#5577bd"
                fancy:fontIconResource="@string/icon_follow"
                fancy:fontIconSize="10sp"
                fancy:iconPosition="right"
                fancy:radius="30dp"
                fancy:text="Follow Mehdi Sakout"
                fancy:textColor="#FFFFFF" />
        </LinearLayout>


        <LinearLayout
            android:id="@+id/section_socialnetworks"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#ffffff"
            android:gravity="center_horizontal"
            android:minHeight="200dp"
            android:orientation="vertical"
            android:padding="20dp" >

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_marginBottom="15dp"
                android:gravity="center" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_android"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#55acee"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/twitter"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:radius="30dp"
                    fancy:textColor="#FFFFFF" />

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_dropbox"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#007ee5"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/dropbox"
                    fancy:radius="30dp">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>
            </LinearLayout>

            <LinearLayout
                android:id="@+id/sn_pos2"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_marginBottom="15dp"
                android:gravity="center"
                android:orientation="horizontal" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_instagram"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#3f729b"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/instagram"
                    fancy:radius="30dp">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_sound"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#ff8800"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/soundcloud"
                    fancy:radius="30dp">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>
            </LinearLayout>

            <LinearLayout
                android:id="@+id/LinearLayout1"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:gravity="center"
                android:orientation="horizontal" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_gplus"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#dd4b39"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/gplus"
                    fancy:radius="30dp">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_facebook"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="10dp"
                    android:padding="10dp"
                    fancy:defaultColor="#000000"
                    fancy:iconPaddingLeft="0dp"
                    fancy:iconPaddingRight="0dp"
                    fancy:focusColor="#313131"
                    fancy:iconResource="@drawable/github"
                    fancy:radius="30dp" >
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>
            </LinearLayout>
        </LinearLayout>
        <LinearLayout
            android:id="@+id/section_spotify"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#222326"
            android:gravity="center_horizontal"
            android:orientation="vertical"
            android:padding="20dp" >
            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_spotify"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:paddingBottom="10dp"
                android:paddingLeft="20dp"
                android:paddingRight="20dp"
                android:paddingTop="10dp"
                fancy:defaultColor="#7ab800"
                fancy:focusColor="#9bd823"
                fancy:fontIconResource="&#xf04b;"
                fancy:iconPosition="left"
                fancy:radius="30dp"
                fancy:text="SHUFFLE PLAY"
                fancy:textColor="#FFFFFF" />

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_spotify_pause"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:paddingBottom="10dp"
                android:paddingLeft="20dp"
                android:paddingRight="20dp"
                android:paddingTop="10dp"
                fancy:defaultColor="#7ab800"
                fancy:focusColor="#9bd823"
                fancy:fontIconResource="&#xf04c;"
                fancy:iconPosition="left"
                fancy:radius="30dp"
                fancy:text="PAUSE"
                fancy:textColor="#FFFFFF" />
            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_spotify_follow"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingBottom="10dp"
                android:paddingLeft="20dp"
                android:paddingRight="20dp"
                android:paddingTop="10dp"
                fancy:defaultColor="#222326"
                fancy:focusColor="#424243"
                fancy:radius="30dp"
                fancy:text="FOLOW"
                fancy:borderColor="#88898c"
                fancy:borderWidth="1dp"
                fancy:textColor="#dfe0d9" />
        </LinearLayout>
        <LinearLayout
            android:id="@+id/section_twitter"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#55acee"
            android:gravity="center_horizontal"
            android:orientation="vertical"
            android:padding="20dp" >

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_twitter_follow"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="20dp"
                android:padding="5dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="2dp"
                fancy:defaultColor="#55acee"
                fancy:focusColor="#8cc9f8"
                fancy:iconPaddingLeft="40dp"
                fancy:iconResource="@drawable/twitter"
                fancy:text="Follow me on Twitter"
                fancy:textColor="#FFFFFF"/>

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_twitter_followers"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="2dp"
                fancy:defaultColor="#55acee"
                fancy:focusColor="#8cc9f8"
                fancy:fontIconResource="@string/icon_user"
                fancy:fontIconSize="10sp"
                fancy:iconPosition="top"
                fancy:text="2145 followers"
                fancy:textColor="#FFFFFF"/>
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#ff5f69"
            android:gravity="center"
            android:paddingBottom="30dp"
            android:paddingTop="30dp" >

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_create_account"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="20dp"
                android:padding="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#ff5f69"
                fancy:focusColor="#ff838b"
                fancy:radius="30dp"
                fancy:text="Create an account"
                fancy:textColor="#FFFFFF" >
            </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

            <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                android:id="@+id/btn_login"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingBottom="10dp"
                android:paddingLeft="20dp"
                android:paddingRight="20dp"
                android:paddingTop="10dp"
                fancy:borderColor="#FFFFFF"
                fancy:borderWidth="1dp"
                fancy:defaultColor="#ff5f69"
                fancy:focusColor="#ff838b"
                fancy:fontIconResource="@string/icon_user"
                fancy:iconPosition="left"
                fancy:radius="30dp"
                fancy:text="Login"
                fancy:textColor="#FFFFFF" />

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:padding="20dp"
            android:layout_height="wrap_content"
            android:orientation="vertical" >

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_download"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="10dp"
                    android:padding="10dp"
                    fancy:borderColor="#FFFFFF"
                    fancy:borderWidth="2dp"
                    fancy:defaultColor="#3b414f"
                    fancy:focusColor="#8cc9f8"
                    fancy:fontIconResource="@string/icon_download"
                    fancy:fontIconSize="10sp"
                    fancy:iconPosition="top"
                    fancy:radius="10dp"
                    fancy:text="Download the file"
                    fancy:textColor="#FFFFFF">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_upload"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="10dp"
                    android:padding="10dp"
                    fancy:borderColor="#FFFFFF"
                    fancy:borderWidth="2dp"
                    fancy:defaultColor="#3b414f"
                    fancy:focusColor="#8cc9f8"
                    fancy:fontIconResource="@string/icon_upload"
                    fancy:fontIconSize="10sp"
                    fancy:radius="10dp"
                    fancy:iconPosition="bottom"
                    fancy:text="Upload"
                    fancy:textColor="#FFFFFF">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

            </LinearLayout>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_twitter"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginBottom="10dp"
                    android:padding="10dp"
                    fancy:borderColor="#FFFFFF"
                    fancy:borderWidth="2dp"
                    fancy:defaultColor="#40a75a"
                    fancy:focusColor="#8cc9f8"
                    fancy:fontIconResource="@string/icon_user"
                    fancy:fontIconSize="15sp"
                    fancy:iconPosition="left"
                    fancy:text="Send"
                    fancy:radius="10dp"
                    fancy:textColor="#FFFFFF">
                </fancybuttons.wjj.com.fancybuttonsdemo.FancyButton>

            </LinearLayout>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content" >

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_decline"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="20dp"
                    android:padding="10dp"
                    fancy:borderColor="#FFFFFF"
                    fancy:borderWidth="0dp"
                    fancy:defaultColor="#d86262"
                    fancy:focusColor="#2e5071"
                    fancy:fontIconResource="@string/icon_mute"
                    fancy:fontIconSize="10dp"
                    fancy:iconPosition="right"
                    fancy:radius="30dp"
                    fancy:text="Mute"
                    fancy:textColor="#ffffff" />

                <fancybuttons.wjj.com.fancybuttonsdemo.FancyButton
                    android:id="@+id/btn_answer"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="20dp"
                    android:gravity="right"
                    android:padding="10dp"
                    fancy:defaultColor="#7ed862"
                    fancy:focusColor="#2e5071"
                    fancy:fontIconResource="@string/icon_answer"
                    fancy:fontIconSize="10dp"
                    fancy:iconPosition="right"
                    fancy:radius="30dp"
                    fancy:text="Answer the call"
                    fancy:textColor="#ffffff" />

            </LinearLayout>

        </LinearLayout>

    </LinearLayout>

</ScrollView>

MainActivity补贴了，什么代码都没写，自动生成的一个Activity.
所有的一系列你所需的一些格式要求都可以在XML文件内预设，如果需要用代码编写就只需要调用上面的一些列Set方法就可以了。 
源码地址：http://yunpan.cn/cmy8gXMhNr8Zj  访问密码 a74d

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【cocos2d-x 3.7 飞机大战】 决战南海I (十二) 游戏结束场景
        游戏结束的时候，要显示分数，还要能够选择是返回主场景还是退出游戏



	// 退出游戏
	void menuCloseCallback(cocos2d::Ref* pSender);

	// 返回主界面
	void menuMainCallback(cocos2d::Ref* pSender);



实现该功能的代码如下

bool GameOver::init()
{
	//////////////////////////////
	// 1. super init first
	if (!Layer::init())
	{
		return false;
	}

	bool bRect = false;

	//背景音乐
	if (CocosDenshion::SimpleAudioEngine::getInstance()->isBackgroundMusicPlaying())
	{
		CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(true);
		CocosDenshion::SimpleAudioEngine::getInstance()->playBackgroundMusic("sound/game_over.mp3", true);
	}

	do 
	{
		Size visibleSize = Director::getInstance()->getVisibleSize();
		Vec2 origin = Director::getInstance()->getVisibleOrigin();

		//添加背景图片
		auto m_background = Sprite::createWithSpriteFrameName("backgroundGameOver.png");
		m_background->setPosition(Point(visibleSize.width / 2, visibleSize.height / 2));
		m_background->setAnchorPoint(Vec2(0.5, 0.5));
		CC_BREAK_IF(!m_background);

		this->addChild(m_background);

		//添加分数
		auto score_int = UserDefault::getInstance()->getIntegerForKey("currentScore");
		auto score_str = __String::createWithFormat("%d", score_int);
		auto score = Label::createWithTTF(score_str->getCString(), "fonts/DFPShaoNvW5-GB.ttf", 40);
		score->setPosition(Point(visibleSize.width / 2, visibleSize.height/3*2));
		score->setColor(Color3B(255, 0, 0));
		CC_BREAK_IF(!score);

		this->addChild(score);

		//设定等级

		//设置标签 并 获取中文文本
		auto dictionary = Dictionary::createWithContentsOfFile("fonts/AboutMe.xml");
		String rank_str;

		switch (score_int/1000)
		{
		case 0:
			rank_str = ((__String*)(dictionary->objectForKey("Eleven")))->getCString();
			break;
		case 1:
			rank_str = ((__String*)(dictionary->objectForKey("Ten")))->getCString();
			break;
		case 2:
			rank_str = ((__String*)(dictionary->objectForKey("Nine")))->getCString();
			break;
		case 3:
			rank_str = ((__String*)(dictionary->objectForKey("Eight")))->getCString();
			break;
		case 4:
			rank_str = ((__String*)(dictionary->objectForKey("Seven")))->getCString();
			break;
		case 5:
			rank_str = ((__String*)(dictionary->objectForKey("Six")))->getCString();
			break;
		case 6:
			rank_str = ((__String*)(dictionary->objectForKey("Five")))->getCString();
			break;
		case 7:
			rank_str = ((__String*)(dictionary->objectForKey("Four")))->getCString();
			break;
		case 8:
			rank_str = ((__String*)(dictionary->objectForKey("Three")))->getCString();
			break;
		case 9:
			rank_str = ((__String*)(dictionary->objectForKey("Two")))->getCString();
			break;
		case 10:
			rank_str = ((__String*)(dictionary->objectForKey("One")))->getCString();
			break;
		default:
			rank_str = ((__String*)(dictionary->objectForKey("Zere")))->getCString();
			break;
		};

		auto m_label1 = Label::createWithTTF(
			rank_str.getCString(),
			"fonts/DFPShaoNvW5-GB.ttf",
			65
			);
		m_label1->setColor(Color3B(255, 0, 0));
		m_label1->setPosition(Point(visibleSize.width / 2, visibleSize.height / 2 - m_label1->getContentSize().height));

		this->addChild(m_label1);


		/////////////////////////////
		// 2. add a menu item with "X" image, which is clicked to quit the program
		//    you may modify it.

		//退出游戏 按钮
		auto tempClose1 = Sprite::createWithSpriteFrameName("GameOver_nor.png");
		auto tempClose2 = Sprite::createWithSpriteFrameName("GameOver_touched.png");

		auto closeItem = MenuItemSprite::create(
			tempClose1, tempClose2, CC_CALLBACK_1(GameOver::menuCloseCallback, this)
			);

		//返回主界面 按钮
		auto tempBack1 = Sprite::createWithSpriteFrameName("ReturnGame_nor.png");
		auto tempBack2 = Sprite::createWithSpriteFrameName("ReturnGame_touched.png");

		auto backItem = MenuItemSprite::create(
			tempBack1, tempBack2, CC_CALLBACK_1(GameOver::menuMainCallback, this)
			);

		// create menu, it's an autorelease object
		auto menu = Menu::create(closeItem, backItem, NULL);
		menu->alignItemsVerticallyWithPadding(closeItem->getContentSize().height / 2);
		menu->setPosition(Vec2(origin.x + visibleSize.width / 2, visibleSize.height / 4));
		CC_BREAK_IF(!menu);

		this->addChild(menu, 1);

		bRect = true;
	} while (0);

	/////////////////////////////
	// 3. add your codes below...


	return true;
}

// 退出游戏
void GameOver::menuCloseCallback(Ref* pSender)
{
	Director::getInstance()->end();

#if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)
	exit(0);
#endif
}

// 返回主界面
void GameOver::menuMainCallback(cocos2d::Ref* pSender)
{
	CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(true);
	Director::getInstance()->replaceScene(TransitionProgressRadialCCW::create(0.8f,HelloWorld::createScene()));
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

cocoapods应用第一部分-xcode创建.framework相关
问题的提出:
随着项目的越来越大,可能会出现好几个团队共同维护一个项目的情况,例如:项目组A负责其中的A块,项目组B负责其中的B块.....这几块彼此之间既独立,也相互联系.对于这种情况,可以采用约定的方式,比如,你只修改你那块,不要修改公共的.如果要修改公共的,那么必须要通知一下其它组,大家共同决定怎么修改,这种方式有一个很大的问题,很有可能不经意间就改了别的团队的代码.还有维护的越来越复杂等.
诸如此类的问题,很自然的我们会考虑每个团队建立一个静态库
 IOS的静态库有两种,.a和.framework,  动态库.framework居多.   静态库建议也生成.framework模式的,好处是.framework包含了相关的.h文件等..a文件还要自己添加相关的.h文件
   静态库：链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝.例如我们在我们的程序中使用了百度地图的.a文件,另外一个应用也使用了百度地图.a.这样整个系统中,会出现两个 百度地图.a文件

   动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存.系统提供的库基本上都属于此类,例如UIKit等,A应用和B应用中都用到了UIKit,系统只加载了一份在内存中.IOS中对于第三方的动态库,很遗憾,目前还不支持的.
一:framework的制作
   从xcode6开始,已经提供了制作.framework的选项了


下面我们用系统自带的来新建.framework.然后再添加一个依赖库 AFNetworking
1) xcode的菜单栏  File -> New Project  建立一个名为  YohunlUtilsLib 的Cocoa Touch Framework的工程. 将Target 改为 7.0(由于现在大多数应用都还要支持7.0sdk,故此处我们修改为支持7.0)


这时候,编译一下,你可能会遇到警告  


          (null): Embedded dylibs/frameworks only run on iOS 8 or later


别着急,这个是由于 从IOS8开始,建立的framework可以是动态的(并不是完全意义上的动态,这里的动态,其实还是要嵌入到我们的应用中,而不能够从网上下载,然后用dlopen动态加载的).


我们要修改 Mach-O Type.从默认的Dynamic Library 改为 Static Library,再编译,警告消失




那么选择 Dynamic Library 还是   Static Library 有什么影响呢? 我已经实际的检验过了.(我采用了一个包含了 第三方库 AFnetworking的测试工程)


  Static Library 支持IOS8.0 sdk以下的,从目前来看,大多数工程都还要支持7.0 sdk,所以我们最常用的就是Static Library  

当我们使用   Static Library时候,生成的framework直接如同添加普通文件的形式添加进来就可以了.它会自动在








不过当我们运行的时候,会提示:
当生成后,添加到示例工程中,






好吧,这种模式的添加,看来有些问题呀,还要自己添加依赖库,这些依赖库都是系统的,根据提示自己添加就可以了
再运行,OK







当我们使用 Dynamic Library模式(只有IOS8.0及以上才支持)的时候.如同普通文件一样添加到示例工程中去的话,运行,会出现提示:

dyld: Library not loaded: @rpath/NetTestLib.framework/NetTestLib
  Referenced from: /Users/yohunl/Library/Developer/CoreSimulator/Devices/B1DBCA26-C113-4C74-BB81-297D4AF1E0C8/data/Containers/Bundle/Application/C1B4F6D5-96FD-4245-8E6D-4F1C569EEF6F/TestFramework.app/TestFramework
  Reason: image not found







解决的方式 
在工程的配置  Embedded Binaries下面添加.而不是在 Linked Frameworks and Libraries下添加.这种方式,不需要添加 AFNetworking所需要的系统库,这一点不知道是什么原因!!!如果有知道原因的,请也告知我一下啊






再运行,OK




2)  命令行,进入目录下  pod init 建立一个podfile文件,因为我们制作的.framework需要用到AFNetworking网络库 PS:你也可以用任意的方式建立这个podfile文件
    打开它,因为我采用 pod init命令建立的,打开后你会发现它已经有内容了


修改其内容为
                   platform :ios, '7.0'
                   inhibit_all_warnings!


                  target 'YohunlUtilsLib' do
                        pod 'AFNetworking'
                  end


                  target 'YohunlUtilsLibTests' do
                  end


再执行 pod install 建立依赖
打开工程,添加一个文件  YONetwork.h,在其中添加方法
@interfaceYONetwork :NSObject
/**
 *  
获取github上用户的repo
 *
 *  @paramuser   用户名
 *  @paramsuccess成功的回调
 *  @paramfailure失败的回调
 */
- (void)getGithubReposForUser:(NSString*)user
 withSuccess:(void(^)(idresponseObject))success
 failure:(void(^)(NSError*error))failure;


/**
 *  
测试 getGithubReposForUser:withSuccess:failure的
 */
- (void)test;
@end
#import"YONetwork.h"
#import 
"AFNetworking.h"
@implementationYONetwork
- (void)getGithubReposForUser:(NSString*)user
 withSuccess:(void(^)(idresponseObject))success
 failure:(void(^)(NSError*error))failure
{
    
AFHTTPRequestOperationManager 
*manager = [AFHTTPRequestOperationManagermanager];
    [manager 
GET:[NSStringstringWithFormat:@"https://api.github.com/users/%@/repos",
 user] 
parameters:nilsuccess:^(AFHTTPRequestOperation*operation,id
responseObject) {
        success(responseObject);
    } 
failure:^(AFHTTPRequestOperation*operation,NSError*error)
 {
        failure(error);
    }];
}


- (void) test {
    [selfgetGithubReposForUser:@"yohunl"withSuccess:^(idresponseObject)
 {
        
NSLog(@"getGithubReposForUser response = %@",responseObject);
    } 
failure:^(NSError*error) {
        
NSLog(@"getGithubReposForUser error = %@",error);
    }];
}
@end




编译运行 (command + B),生成相应的.framework文件 
菜单 -  organizer 


可以看到目录结构如下:


其中的 YohunlUtilsLib.framework 就是我们要的  : 注意,YohunlUtilsLib.framework中并没有包含AFNetworking库的内容,这一点我们可以用如下的命令来验证.
命令进入 Debug-iphoneos
$ lipo -info YohunlUtilsLib.framework/YohunlUtilsLib
输出
Architectures in the fat file: YohunlUtilsLib.framework/YohunlUtilsLib are: armv7 arm64
说明我们生成的真机framework:YohunlUtilsLib.framework 包含了两种架构 armv7
 arm64
分离出每一种架构
$ mkdir armV7  当前目录建立文件夹,用于存放分离后的架构,和分离出的.o文件
$ lipo YohunlUtilsLib.framework/YohunlUtilsLib -thin armv7 -output ./armv7/YohunlUtilsLib_armv7  分离出armv7架构到文件夹armV7下
$ cd armV7 进入文件夹
$ ar -x YohunlUtilsLib_armv7  分离出armv7架构的所有的.o文件
分离后,如图:


可以看到,最后的.framework中,并没有包含我们pod添加的 AFNetworking.所以 当我们把我们生成的YohunlUtilsLib.framework给别人使用过的时候,别人自己要在项目中添加
 AFNetworking,否则会提示找不到的错误. 
 验证的方式可以参见 http://jiapumin.iteye.com/blog/2119102  主要是利用命令   


3) 我们使用命令来合并我们生成的真机和模拟器的framework
建立一个新的target




target建立后


添加如下的合并模拟器和真机的脚本

# Constants
SF_TARGET_NAME=${PROJECT_NAME}
#自定义的用来存放最后合并的framework
UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal



#IPHONE_DEVICE_BUILD_DIR=${BUILD_DIR}/${CONFIGURATION}-iphoneos

WORKSPACE_NAME=${PROJECT_NAME}.xcworkspace
YO_SCHEME=${PROJECT_NAME}

#clean build是先清除原来的build
xcodebuild -workspace ${WORKSPACE_NAME} -scheme ${YO_SCHEME} -sdk iphonesimulator -configuration"${CONFIGURATION}"clean build
xcodebuild -workspace ${WORKSPACE_NAME} -scheme ${YO_SCHEME} -sdk iphoneos -configuration"${CONFIGURATION}"clean build

# build project
#xcodebuild -project "${PROJECT_FILE_PATH}" -target "${TARGET_NAME}" -configuration "${CONFIGURATION}" -sdk iphoneos BUILD_DIR="${BUILD_DIR}" OBJROOT="${OBJROOT}" BUILD_ROOT="${BUILD_ROOT}"
 CONFIGURATION_BUILD_DIR="${IPHONE_DEVICE_BUILD_DIR}/arm64" SYMROOT="${SYMROOT}" ARCHS='arm64' VALID_ARCHS='arm64' $ACTION

#xcodebuild -project "${PROJECT_FILE_PATH}" -target "${TARGET_NAME}" -configuration "${CONFIGURATION}" -sdk iphoneos BUILD_DIR="${BUILD_DIR}" OBJROOT="${OBJROOT}" BUILD_ROOT="${BUILD_ROOT}" 
 CONFIGURATION_BUILD_DIR="${IPHONE_DEVICE_BUILD_DIR}/armv7" SYMROOT="${SYMROOT}" ARCHS='armv7 armv7s' VALID_ARCHS='armv7 armv7s' $ACTION

# Copy the framework structure to the universal folder (clean it first)
#因为framework的合并,lipo只是合并了最后的二进制可执行文件,所以其它的需要我们自己复制过来
#先移除原来的
rm -rf 
"${UNIVERSAL_OUTPUTFOLDER}"
mkdir -p 
"${UNIVERSAL_OUTPUTFOLDER}"
cp -R 
"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework" 
"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework"

#合并模拟器和真机的架构
lipo -create  
"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/${PROJECT_NAME}""${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework/${PROJECT_NAME}"-output"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/${PROJECT_NAME}"

open 
"${UNIVERSAL_OUTPUTFOLDER}"












对于以上的脚本,其中用到了很多的 xcode预定义的变量,这些变量怎么来的呢?你可以在命令行下, 输入
xcodebuild -workspace YohunlUtilsLib.xcworkspace -scheme YohunlUtilsLib -sdk iphonesimulator -configuration Debug -showBuildSettings > xcodebuild_showBuildSettings.txt
来将所有的xcode预定义变量都导入到文本xcodebuild_showBuildSettings.txt 中,然后你就可以选用你需要的啦


当然了,我们一般都应该合并release模式的,而不是debug模式的framework,这个可以在






ccmmand+B 编译
如果不出错的话,应该会弹出




到此处,我们的framework建立好了,下面可以建立一个测试工程来测试一下,是否可以了


4)建立一个single View Application的测试上述framework的工程 TestFrameworkDemo
将上一步生成的 Release-universal/YohunlUtilsLib.framework 加入到工程 TestFrameworkDemo
再写一个测试用例:




运行,这时候,你会收到错误提示


还记得前面说过吧,我们打包的framework并不包含
此时,我们有两种方式解决这个问题:
 1. 将我们生成 YohunlUtilsLib.framework 过程中生成的libAFNetworking.a 拷贝过来,添加到工程中(当然了,你要自己合并 libAFNetworking的真机和模拟器的.a文件) [这种方式的好处是可以保证我们的YohunlUtilsLib.framework使用到的libAFNetworking和我们一样的版本,保证了兼容性,,但同时也增加了集成的复杂性,我们要申明我们的framework用到了哪些第三方和第三方的版本信息]
2.在TestFrameworkDemo 工程中,增加 podFile文件,在其中加入 依赖  pod 'AFNetworking'
  重新pod install一下 [推荐这种方式,因为,我们用到的第三方都可以使用pod管理,方便],下面就以这种方法来说明




运行,OK!!!
源码在  https://github.com/yohunl/TestFrameworkDemo.git
framework在  https://github.com/yohunl/YohunlUtilsLib.git


二:使用 pod 的命令  pod lib create 来创建 使用pod的framework

采用cocoapods自带的命令,比较方便的http://guides.cocoapods.org/making/using-pod-lib-create 
  例如  pod lib create BZLib.可以自带demo的
命令如下   
pod lib create YohunlUtilsPod

注意:各个版本的cocoapods生成的示例工程结构什么的,会有点不一样,比如最新的带有demo的生成的lib工程就本身就是target的名字,但是之前版本target的名字是 名字_example


pod lib create 工程名  使会让你确认4个问题,由此来建立工程,4个问题都是很简单的,你可以自行选择


  






注意到了没?这里我们的 YohunlUtilsPod 目录下,并没有podfile文件,那么我们建立的库要怎么依赖第三方的啊.这里就是 
YohunlUtilsPod.podspec 文件出场了,在这个文件中,可以制定我们生成的framework依赖于什么.有关于spec文件,是关键文件,原则上,只要我们把这个文件交给别人,别人就可以添加我们的lib到工程里了




编辑YohunlUtilsPod.podspec 文件(此文件实际上是 ruby格式的,如果你用ruby相关的编辑器打开,就能高亮显示了),修改内容为
Pod::Spec.new do |s|
  s.name             = "YohunlUtilsPod"
  s.version          = "1.0.0"
  s.summary          = "测试pod生成framework的YohunlUtilsPod."

  s.description      = "测试用的,我们用来测试使用pod
 lib create 生成的framework工程"

  s.homepage         = "https://github.com/yohunl/YohunlUtilsPod"
  # s.screenshots     = "www.example.com/screenshots_1", "www.example.com/screenshots_2"
  s.license          = 'MIT'
  s.author           = { "yohunl" => 
"yohunl@163.com" }
  s.source           = { :git => "https://github.com/yohunl/YohunlUtilsPod.git", :tag => s.version.to_s }

  # s.social_media_url = 'https://twitter.com/<TWITTER_USERNAME>'

  s.platform     = :ios, '7.0'
  s.requires_arc = true

  s.source_files = 'Pod/Classes/**/*'
  s.resource_bundles = {
    'YohunlUtilsPod' => ['Pod/Assets/*.png']
  }

  # s.public_header_files = 'Pod/Classes/**/*.h'
  # s.frameworks = 'UIKit', 'MapKit'
   s.dependency 'AFNetworking'
end 
验证podspec文件是否正确是使用命令  在podspec所在目录下执行  pod lib lint


如果提示错误的话,它会给出详细的提示,你照着修改就好了,备注:我已经将源码上传到了github上(你也可以上传你的私有git服务器,一般公司都应该有自己的git服务器)


更改完后,在工程中再加入  YONetwork.h和.YONetwork.m 



再运行 pod install  
如果提示 
SZ-lingdaiping:Example yohunl$ pod install
Updating local specs repositories
Analyzing dependencies
Fetching podspec for `YohunlUtilsPod` from `../`
[!] Unable to satisfy the following requirements:

- `YohunlUtilsPod (from `../`)` required by `Podfile`
- `YohunlUtilsPod (from `../`)` required by `Podfile`
- `YohunlUtilsPod (= 0.1.0)` required by `Podfile.lock`


那么删掉  Podfile.lock文件,因为我们更改了podspec文件里的库的版本号了


看到没,是在 Development Pods文件夹下,因为并没有上传到官方去,所以,在此处是 私有的,所以在Development Pods文件夹下  .


接下来,如同第一个一样,添加一个新的target,添加 run script脚本 ,运行它,得到  


建立一个测试工程


注意上面图里面的文字,此处因为我们的framework工程采用dynamic 模式的(上文有论述!!!)  所以需要在Embedded Binaries下添加相应的库.至于为什么还要添加 AFNetworking.framework,上面也有论述,是因为我们打包的.framework并没有包含AFNetworking.framework,如果不加上,运行起来,还是要报错的哦


好了,第一部分讲完了
那么我们怎么使用 像我们使用其它开源库那样的,只要在demo工程里添加一句
pod ‘YohunlUtilsPod' 然后pod install一下就可以添加呢?(当然了,这种方式,我们一般是直接源码模式的framework加入demo工程)


这就是第二部分要讲的.






参考文档:
http://maxao.free.fr/xcode-plugin-interface/build-settings.html#variables
ttps://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/0-Introduction/introduction.html
ttp://outofmemory.cn/shell/learn-shell-in-30-minutes/
http://www.cnblogs.com/wendingding/p/3893095.html
http://www.cnblogs.com/brycezhang/p/4117180.html
http://wenva.github.io/2015/07/08/创建自己的CocoaPods私有仓库.html
http://insert.io/framework-ios8-xcode6/

















版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        iOS 类似简单的第三方微博客户端,可进行登录微博浏览相关信息
Demo地址：https://github.com/ChenNan-FRAM/Fenvo （如果你觉得有用麻烦star一下感激不尽）
Fenvo
Objective-C, iOS
类似简单的第三方微博客户端,可进行登录微博浏览相关信息。在这个过程我是遇到很多的问题，但是大部分都顺利解决了，相信如果你的项目有类似的地方我的项目里面也能够给你提供一定的帮助，如果需要，可以给我留言或者在Github上联系我。
UI简陋，暂未完善。有UI大师指点就最好了。 这个应用我是从开始学后为了实践自己的能力一直在编写的，不是什么大神级人物，只是一个忠诚的iOS开发者，喜欢美好，简单的东西。如果你也有兴趣加入我一起完善这个第三方微博客户端可以给我留言或者push我。如果你有什么想法，我也很乐于交流探讨。可以点击上方的Demo进入我的Github。


已实现模块

登录、注册
微博个人关注微博主页内容（微博信息图片浏览，转发，回复，赞，收藏等）
微博个人信息内容模块


正在实现模块

写微博，发送微博
个人消息提醒（评论回复、赞、粉丝）


主要数据模型（Model）

WeiboMsg.h   //主要微博信
WeiboGeoInfo.h  //地理信息
WeiboRemind.h  //提示信息
WeiboUserInfo.h  //用户个人信息
WeiboVisibleInfo.h  //微博可见性
WeiboPrivacySetting.h //微博隐私分组
WeiboComment.h  //评论
——-暂未完成———
WeiboChatMsg.h  //私信 


远程数据请求功能（RPC）


已增加功能：
请求个人关注用户微博
请求公共微博
请求个人评论数据
请求某微博评论列表数据


主要控制器（ViewController）

FollowingWBViewController.h //用户关注微博首页
ProfileViewController.h //用户个人主页 
AlbumView.h //用户原创图片
UserInfoView.h //用户个人简介
WeiboTableView.h //用户个人已发送微博
FollowingListTableViewController.h //用户粉丝列表
FollowerListTableViewController.h //用户关注列表
NewWeiboVC.h //用户写新微博
WebViewController.h //微博附带网站跳转
未完待续


各种自定义控件
位于WeiboMsgComponent组下

WeiboCommentView //微博评论页
WeiboForwardView //微博转发页
WebImageBrowser //微博网络图片浏览
WBImageBrowser //微博本地图片浏览（写微博）
OriginalTableViewCell //微博基本Cell
WeiboAvatarView //微博头像
WeiboLabel //由MLEmojiLabel更改而来，微博label
WBImageSelect //更改自QBImagePickerController，多图选择
未完待续


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        火云开发课堂 - 《使用Cocos2d-x 开发3D游戏》系列 第八节:灯光
《使用Cocos2d-x 开发3D游戏》系列在线课程            第八节:灯光 视频地址：http://edu.csdn.net/course/detail/1330/20808?auto_start=1交流论坛：http://www.firestonegames.com/bbs/forum.php 工程下载地址：http://www.firestonegames.com/bbs/forum.php?mod=viewthread&tid=31&extra=page%3D1  课程截图：           实例工程演示：    ﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Animation动画详解（二）： 组合动画特效
前言
    上一篇博客Android Animation动画详解（一）： 补间动画 我已经为大家介绍了Android补间动画的四种形式，相信读过该博客的兄弟们一起都了解了。如果你还不了解，那点链接过去研读一番，然后再过来跟着我一起学习如何把简单的动画效果组合在一起，做出比较酷炫的动画特效吧。


一、 动画的续播
    如题，大家想想，如果一个页面上包含了许多动画，这些动画要求按顺序播放，即一个动画播放完成后，继续播放另一个动画，使得这些动画具有连贯性。那该如何实现呢？ 有开发经验或者是逻辑思维的人肯定会想，对动画进行监听啊，如果这个动画播放完了，再去播放另一个动画不就好了。
    Congratulations， 你和我想的是一样一样的。
    我们看下通过这种动画播放监听如何去做：

 private void continueAnim(){
        // 先加载第一个动画
        Animation translate = AnimationUtils.loadAnimation(getActivity(), R.anim.translate_animation);
        // 在加载第二个动画
        final Animation scale = AnimationUtils.loadAnimation(getActivity(), R.anim.scale_animation);

        // 接下来，我们队第一个动画进行监听，当它播放完成后，我们播放第二个动画
        translate.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                imgView.startAnimation(scale);
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }
        });
        imgView.startAnimation(translate);
    }
    注释我已经写得挺详细了，可以说，这种方法so easy，没啥可说的。



    除了上面介绍的使用监听器监听动画播放结束之外，还有一个更easy方法，也是我们优先推荐使用的，那就是Animation Set。
    这里，我们要引入一个动画的属性：startOffset。 如何去使用呢？看下定义动画的代码：

<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:fillAfter="true"
    android:fillEnabled="true">

    <alpha
        android:fromAlpha="0"
        android:toAlpha="1"
        android:duration="3000"/>

    <translate
        android:duration="1000"
        android:fromXDelta="0"
        android:fromYDelta="0"
        android:toXDelta="100"
        android:toYDelta="100"
        android:startOffset="3000"
        />
</set>
  仔细看下translate定义的动画，它其中就有一个属性startOffset，这个属性的值，其实就是alpha动画的duration的值，他的意思是，延迟三秒后播放，其实也就是第一个alpha动画播放完成后再播放。

Animation continueAnim = AnimationUtils.loadAnimation(getActivity(), R.anim.continue_animation);
imgView.startAnimation(continueAnim);
好啦，写到这，让我们看下运行的效果吧：





二、 动画的重播
    重播动画，故名思议，就是动画重复播放。大家看下上面那个gif的动态图，其实就是重复播放动画。那Android如何重复播放动画呢？
   其实very easy，因为Android本身为定义动画提供了两个属性repeatCount和repeatMode，只要为你的动画设置上这两个属性，那就ok了！
   为了方便记忆，让我们稍微看下代码吧：

    <translate
        android:duration="1000"
        android:fromXDelta="0"
        android:fromYDelta="0"
        android:toXDelta="100"
        android:toYDelta="100"
        android:repeatCount="5"
        android:repeatMode="restart"
        />
这里我们指定了repeatCount为5，则动画要播放5次，repeatMode为“restart”，则动画每次都是重复播放。repeatMode还有个取值“reverse”，这是指让动画倒叙播放。 看下效果。



三、 Activity的切换动画
    说道Activity切换动画，我想大家肯定都不陌生，比如你玩淘宝、美团啥的，你会发现它们的页面切换都是从右向左滑动进入的，这其实就是Activity切换动画的应用。或许大家初始会觉得挺难，但我要告诉你的是，其实这玩意真简单，如果你已经会了如何定义动画（特指补间动画），那么你只要再理解下一个方法——overridePendingTransition即可。
    先让我们一起看下这个方法的定义：
/**
     * @param enterAnim A resource ID of the animation resource to use for
     * the incoming activity.  Use 0 for no animation.
     * @param exitAnim A resource ID of the animation resource to use for
     * the outgoing activity.  Use 0 for no animation.
     */
    public void overridePendingTransition(int enterAnim, int exitAnim) {
        try {
            ActivityManagerNative.getDefault().overridePendingTransition(
                    mToken, getPackageName(), enterAnim, exitAnim);
        } catch (RemoteException e) {
        }
    }第一个参数enterAnim就是说新的要启动的Activity进入时的动画，第二个参数exitAnim，说的其实是原先的Activity退出时的动画效果。
接下来让我们定义两个动画资源：fade_in.xml和hold_out.xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/accelerate_interpolator"
    >
    <alpha
        android:fromAlpha="0.2"
        android:toAlpha="1.0"
        android:duration="1000"
        />
</set><?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/accelerate_interpolator">

    <translate
        android:fromXDelta="0%p"
        android:toXDelta="100%p"
        android:duration="1000"
        />
</set>
定义动画结束后，那我们只需要在启动新Activity或者结束Activity时，复写overridePendingTransition方法，并传入动画就好啦：
Intent intent = new Intent(getActivity(),SecondActivity.class);
startActivity(intent);
overridePendingTransition(R.anim.fade_in,R.anim.hold_out);
或者是：
public void back(View view){
        finish();
        overridePendingTransition(R.anim.fade_in,R.anim.hold_out);
}看下效果吧：


有没有被惊叹道，原来就这么easy啊！ 赶快自己也动手试下吧。


Follow Me：
    其实Android简单的动画就这么些个，复杂的动画无非也是把这些动画整合在一起使用而已，大家遇到复杂的动画不要太慌，只要分析清楚它的实现原理，一步步的来解锁，都是可以搞定的啦。
    之后，我会再写两篇博客，介绍我在开发过程中使用过的两次动画，当然，并不是很难的那种，只是分享经验而已，敬请期待，欢迎指点。


源码下载地址（免费）：http://download.csdn.net/detail/zuiwuyuan/9047739

版权声明：本文为博主原创文章，未经博主允许不得转载。

windows  android JNI 使用和环境搭建

     网上看了很多文章，有的太老了，有的不说的不是很清楚，这个一步一步开始使用android JNI 方法
     参考：http://bbs.51cto.com/thread-948244-1.html###
                  http://www.cnblogs.com/kissazi2/p/3298884.html    

    使用GNUStep作为C/C++编译器，选择这个的原因是，编译器小，很快就下载完成


（一）下载安装编译环境
          1.打开网站  http://www.gnustep.org/

    
进入后，下载安装，从上到下的顺序安装就行了

   

 安装成功后启动shell，方法
   

打开GNUstep->Shell，输入make -v 和 gcc -v命令，验证是否安装成功




下载DNK 我下载的地址是：https://dl.google.com/android/ndk/android-ndk64-r10-windows-x86.zip
看文章 http://www.cnblogs.com/yaotong/archive/2011/01/25/1943615.html 上面有很多原生地址
google的地址是打不开的，但是可以直接下载，真是感谢啊！呵呵！

 注意：下载下来后解压遇到说文件重复是否覆盖，我选择的是覆盖，小写名字覆盖大写名字；（这里没做深入研究，只看了一下两个文件）
 配置ndk环境变量，gnustep是模拟linux的环境的，打开gnustep的安装目录下的D:\GNUstep\GNUstep\GNUstep.conf文件，添加以下内容：

复制内容到剪贴板

NDK=/d/android-ndk64-r10-windows-x86/android-ndk-r10
export=NDK



NDK的位置就是你下载后解压好，放的位置：




说明如果不知道ndk目录在linux下应该是在哪里，你可以打开gnustep的命令窗口，输入mount，就可以找到对应的盘符。


到此环境部署完成

（二）建立工程，写例子代码

      1.建立工程com.example.test4；
    添加 类JniTest  

package com.example.test4;

public class JniTest {
	 public native final String init();
	 public native final void init2(int a,int b);
}
// main 中的代码
public class MainActivity extends Activity {

    static{
        System.loadLibrary("JniTest");
    }
 
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        JniTest jniTest = new JniTest();
        String s = jniTest.init();
     
    }
}
 



2.开始-运行-cmd，到工程目录
使用cmd :F:\workspace2\test4>javah -classpath ./src -d ./jni  -jni com.example.test4.JniTest

    
-classpath <路径> 用于装入类的路径
-d <目录> 输出目录
-jni 生成 JNI样式的头文件（默认）
     
手动添加 com_example_test4_JniTest.c Android.mk 文件
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := JniTest
LOCAL_SRC_FILES := com_example_test4_JniTest.c

include $(BUILD_SHARED_LIBRARY)
// 这里只实现了一个接口

#include <string.h>
#include <jni.h>
#include "com_example_test4_JniTest.h"

jstring
Java_com_example_test4_JniTest_init
  (JNIEnv* env, jobject thiz){
          return (*env)->NewStringUTF(env, "我的测试JIN接口");
}



其中你只需要该LOCAL_MODULE和LOCAL_SRC_FILES就可以了。
说明:LOCAL_MODULE是描述模块的，用来给java调用的模块名，会生成对应的libtestJni.so
LOCAL_SRC_FILES就是源文件啦，多个文件空格隔开即可。
接下来，我们要开始编译生成so文件咯。
打开gnustep的命令窗口，进入到项目底下，输入$NDK/ndk-build命令，即可自动生成libs/armeabi/libtestJni.so文件。

F5刷新工程

F11debug Eclipse test4工程，可以看到MainActivity中的调用 String s = jniTest.init();  就是在c文件中写的字符串
（3）自动编译

   直接从http://bbs.51cto.com/thread-948244-1.html### 中cp 过来了
右击jni工程的properties-->Builders-->NEW -->;Program 可以看到以下内容：



argument：--login -c "cd /e/myWorkSpace/android/hellJni && $NDK/ndk-build"
切换到Refresh 标签页



切换到Build Options标签页

这样就完成了配置，点击确定可看到控制台自动编译程序了






版权声明：本文为博主原创文章，未经博主允许不得转载。

Android插件化开发之OpenAtlas插件的安装与卸载、更新与回滚
用过Android的同学都知道，手机上的APP可以进行安装，安装完之后可以卸载，安装完后如果有新版本的话可以更新。此外还有一点，就是像windows那样，从win7升级到win10感觉不满意可以回滚到win7。但是回滚功能貌似在Android里是没有的。
OpenAtlas也是如此，在我们的宿主上安装的插件，也是类似这个机制。OpenAtlas为我们提供了很好的插件安装，卸载，更新，回滚的功能。
假设现在你有一个apk，但是前提是这个apk中的四大组件要在你的宿主的清单文件中进行注册，也就是OpenAtlas的初衷不是运行其他的Apk，而是模块化。想将它安装为插件，首先要有这个apk，按照正常流程开发就可以了。
然后我们将它放在sd卡的根目录，假设文件名为test-openatlas-debug.apk，更新代码就是这样子的
try {
    File file=new File("/sdcard/test-openatlas-debug.apk");
    if (!file.exists()){
        Toast.makeText(MainActivity.this, "Test Update pkg not exist", Toast.LENGTH_LONG).show();
    }
    Atlas.getInstance().installBundle("com.lizhangqu.test1",file);
} catch (BundleException e) {
    e.printStackTrace();
}
由于宿主中已经有com.lizhangqu.test这个插件了，所以上面的更新代码将插件安装的位置修改为了com.lizhangqu.test1，installBundle函数的两个参数，第一个是安装的位置，一般传插件的包名就可以了，第二个参数是插件的文件。安装完后对应目录下/data/data/package name/files/storage/下就会有对应的目录生成，如图所示。

如果要卸载的话也很简单，只要一句话
Atlas.getInstance().uninstallBundle("com.lizhangqu.test1");
参数为对应的插件包名，也就是之前安装的第一个参数。
搞定了安装与卸载，我们来看下如何进行插件的更新。插件的更新其实类似于插件的安装。当插件有新版本的时候，我们需要对其进行更新，拿到新apk后，将其放在sd卡根目录，下面进行更新，我们以名为test插件为例。
File file=new File("/sdcard/test-openatlas-debug.apk");
if (!file.exists()){
    Toast.makeText(MainActivity.this, "Test Update pkg not exist", Toast.LENGTH_LONG).show();
}
try {
    Atlas.getInstance().updateBundle("com.lizhangqu.test",file);
} catch (BundleException e) {
    e.printStackTrace();
}
值得注意的是，插件的安装与卸载时不必重启宿主的，但是插件的更新是需要重启宿主的。在更新插件前，test插件的内容如下所示。

以及对应的文件夹内容如下

更新了一个版本后界面就变得不一样了。记得重启宿主。如图所示。

可以看到一些细微的区别，就是上面多了update1。
然后看看对应的文件夹是不是多了一个版本。

但是，一旦你更新到新的一个版本后，你突然发现有bug，这时候你想回滚到之前的一个版本怎么办，其实也很简单。
Atlas.getInstance().restoreBundle(new String[]{"com.lizhangqu.test"});
参数是一个字符串数组，可以同时回滚多个插件，这里只回滚了test插件。重启后你发现插件变回原来的样子了。
简简单单的四个操作，安装，卸载，更新，回滚，使得OpenAtlas变得十分灵活。我们可以随心所欲的进行控制，但是唯一的不足就是四大组件必须在宿主清单中注册，这也给了动态更新加大了难度。如果你想能够直接进行安装，更新插件，前提是你不引入新的组件，因为这些组件你必须注册，还有一个解决方法就是如果你的插件只是UI部分，不涉及新的广播，Service，ContentProvider，仅仅是涉及Activity，那么你完全可以使用Fragment进行代替，解决方案见

Android插件化开发之解决OpenAtlas组件在宿主的注册问题

当然，如果你有兴趣，也可以阅读这一系列文章

Android插件化开发之OpenAtlas初体验
Android插件化开发之OpenAtlas生成插件信息列表
Android插件化开发之OpenAtlas资源打包工具补丁aapt的编译
Android插件化开发之OpenAtlas插件适配
Android插件化开发之解决OpenAtlas组件在宿主的注册问题
Android插件化开发之OpenAtlas中四大组件与Application功能的验证
Android插件化开发之OpenAtlas插件启动方式与插件启动广播

最后，给出源码地址，直接放github上了，反复上传csdn太繁琐了。 
 - https://github.com/lizhangqu/OpenAtlasDemo

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Studio中Android Support Library升级到 23.0.0 报错！
Android Support Library升级到 23.0.0  报错解决方案不得不说，真能折腾！将Android Studio中SDK下的 Android Support Library 升级到了23.0.0，结果倒好了，创建项目出问题了，还比较奇葩：卧槽你大爷！尼玛还能不能好好玩耍了。各种卸载重装，就差重装系统了。后来在神器stackoverflow中找到了这么一篇：http://stackoverflow.com/questions/32092511/resource-error-in-android-studio-after-update-no-resource-found原因：23.0之前有基于apac.http package 的引用，升级后没引用了，所以才导致新建项目报错。解决方案：https://code.google.com/p/android/issues/detail?id=183122#makechanges参照以上方法：第一：打开Project，找到Project中的build.gradle，将compile 'com.android.support:appcompat-v7:23.0.0'设置为compile 'com.android.support:appcompat-v7:22.2.1'第二：进入sdk\extras\android\m2repository\com\android\support\appcompat-v7 ，删除23.0.0文件夹，删除maven-metadata.xml中的<version>23.0.0</version>，如图：第三：clean and rebuild.最近使用Android Studio 出现各种问题，哎，一个问题出现就得折腾大半天，而且作为天朝的程序员，Studio好慢啊！穷的天天吃馒头，哪里来的票票搞VPN（别说俺抠门啊）。不过总得来说还是感觉Studio耍起来不管是IDE的界面，还是编码效率，高大上，到位！

版权声明：本文为博主原创文章，未经博主允许不得转载。

新手程序员必读：推进编程工作的七条箴言

如果大家属于刚刚涉足专业软件开发世界的新人，各位可能会以为自己完全能够凭借着多年来在计算机科学及编程领域获得的教育及/或培训顺利玩转一切。不过在这一行业沉浸多年的老鸟开发者则希望提醒大家，单凭科班灌输的知识还远远不够，我们还需要从实践当中了解到更多极具指导性的宝贵财富。

为了掌握这些真知灼见，我与多位经验丰富的资深开发人员进行了沟通——他们至少在软件技术领域拥有十年乃至更长的从业经历(有几位甚至已经从业数十年)。提到他们希望自己在刚刚毕业并初次涉足编程行业时能够了解到哪些箴言，他们都有着自己的答案。无论大家是刚步出校门的应届生还是已经在编程领域有些心得的从业者，下面这些来自老鸟们的建议相信都能在未来的发展道路上帮助各位找到正确方向。

一、了解与底层系统相关的一切

当然，软件开发工作当中的重要组成部分之一正是编程语言本身。不过正如各位前辈所分享的心得所言，开发人员同样需要了解堆栈之下所发生的一切。

“很多语言会以抽象形式将系统级别的运作机制剥离出去，而这种抽象性确实非常重要，因为它允许开发人员在大部分时间内保持更高的生产效率。”Acquia公司技术支持工程师Pete Bull指出。“不过当大家遇到障碍或者说非常严重的错误时，则需要对引擎盖之下运作的一切拥有相当程度的理解。我们需要有能力调试某项进程，并查看系统调用以真正掌握特定代码片段与系统其余部分之间的交互活动，”他在采访邮件当中写道。

同样的，Platform.sh公司客户满意度副总裁Robert Douglass告诉我们，“当我刚开始上手编程工作时，计算机本身还蕴含着大量我无法理解甚至闻所未闻的奥秘。文件系统、网络以及数据如何驻留在内存当中，这就是三个典型的实例。这部分知识的缺失，意味着我根本无法真正从编程角度出发了解开发项目中的某些目标。”



二、熟悉命令行工具

作为一位开发人员，大家很可能会把大量时间用在使用IDE或者代码编辑器身上。不过需要提醒大家，如果了解如何在命令行上实现同样的操作，那么各位的日常生活绝对会变得更加轻松。

“有时候，大家会发现自己只能使用一台配置一切就绪，但可用工具非常有限的设备，”一位已经拥有二十年从业经历的资深程序员告诉我们。“要像熟悉呼吸那样熟练掌握shell，包括find、comm、diff、vi/vm、sed以及awk等等。有时候利用正确的合作行编写小型脚本来查找必须马上进行修改的文件将非常重要——因为生产体系很可能已经受到了影响、而造成URL指向未知文件的那位技术人员还在斐济度假呢。”

作为一位开发者，Bull最初使用的是微软工具，但随后逐步转移到了Linux阵营。他表示“我已经学习到大量与命令行相关的专业知识，并意识到Linux系统之上提供的这些功能的重要地位。现在我能够轻松地重新调用几年前自己编写完成的代码，或者拿出几天或者几周时间对grep + awk作出进一步改进。”

三、调试器是我们的好朋友

要想显著节约宝贵时间，非常重要的一点就是利用相关工具追踪各类bug。Novartis公司生物信息学开发人员Dave Varon对于调试器的重要意义作出了强调，并解释了其如何帮助我们获得远超过初始学习成本的收益。“学习使用调试器，快快快!”他在采访当中指出。“拿出一、两天时间好好钻研配置一番。在此之后，如果发现结果与预期不符，那么马上调试：设置断点、贯穿代码，特别是第三方代码。这不仅能够帮助我们大大降低问题出现机率，同时也能够让大家在其间学习到很多原本只能通过阅读他人代码掌握的知识。”

四、学习编写测试

一部分开发人员认为单元测试——具体来讲，就是编写测试以验证小型代码单元是否起到了其应有的作用——非常关键。来自Strategic Power Systems公司的数据库开发人员Richard Handloff就是其中之一。“我认为我能给新人们提供的最好建议，就是学习如何编写出优秀的测试机制，并在项目开发初期就制定出一套可行的测试方案，”他在采访邮件当中写道。

五、制定改变规划，了解新型系统

时至今日，每位从业者都清楚地意识到技术正在快速发展转变。这种现象不仅影响着我们心爱的客户的实际体验，同时也改变着底层系统、语言乃至程序员们日常工作所使用的各类工具。

Milestone Made公司创始人兼移动开发者Adam Wulf建议称，新晋程序员们应当准备好——而且抢先一步——应对技术变革。“就目前来讲，我认为大家应该以四年为周期就学习全新技术堆栈作好规划，”他表示。“良好的基础知识当然能够始终发挥作用，不过我们每天所使用的工具乃至技术方案每过四年就会发生颠覆性的变更。”

“项目不应再利用单一框架以单一语言编写而成，”一位不愿透露姓名的开发者建议道。“大家千万不要在某个项目当中只使用一种开发方式，因此请尽快适应在不同项目之间进行语言/技术转换的实际需求，”他在采访邮件当中写道。



六、与他人保持良好关系

尽管常规概念下的程序员都会戴着耳机在自己的小世界里埋头工作，但不可否认的是，我们仍然需要同他人并肩协作。Sinclair Digital Ventures公司CTO Ben Miller着重强调了作为团队成员角色工作对于实现职业生涯成功的重要意义。“大型项目往往是由众多活动组件构建而成，如果我们无法顺利完成协作，那么组件的合并将成为一项不可能实现的任务。”他在采访邮件当中指出。“在尝试对某种算法进行优化之前，请先与团队进行沟通并确保任何能够帮助团队成员减轻工作压力的任务分配规划都已经部署到位。编程是一项团队竞技项目，千万别忽视了这一点!”

Varon还着重强调了人际交往能力的重要性，表示“如果大家无法自行完成API或者调试的审查工作，请借力于他人。我们自认为编写出了一段堪称杰作的代码，并不意味着它就一定出色或者没有进一步提升的空间。跟在大学里一样，同处一室的其他同伴也面临着同样的问题，而且每个人都有可能找到了解决问题的最佳答案。与同事们建立起融洽的合作关系，有时候甚至单纯向对方描述问题就足以帮助我们找到解决灵感。”

另一位不愿透露姓名的受方者也表达了类似的想法，即成为团队中一员对于顺利完成任务所起到的积极作用。“即使当前的工作比较繁重，我们也应当尽可能帮助其他成员解决各类难题，这将让大家的职业生涯走得更加顺畅，”他表示。不过在这种情况下，他也提醒大家“但请注意，要保证有理有节的帮助强度，否则我们很可能身陷其中而耽误了自己的份内职责。”

七、勇敢迈出自己的道路，以自由职业身份编写代码

Miller在这里提出了一项有趣的建议，而且乍看起来似乎难以理解。他在采访中告诉我，“在工作之外编写代码更易于实现职业生涯提升。找到最简单的问题解决办法并对代码进行免费的弹性设置与维护，那么客户自然会提供更多工作供我们完成。他们甚至会邀请我们以教师的身份指导其内部开发人员，”他解释道。“简而言之，过分担心当下这份工作是否稳定反而会阻碍职业生涯的健康发展。”



推荐阅读

程序员未来发展三大方向

20年资深程序员编程经验分享

解析程序员的几个成长阶段

为什么程序员有高薪却不高兴？


程序员如何持续提升自己的开发技能


版权声明：本文为博主原创文章，未经博主允许不得转载。

Android:ListView(一)
ListView四种适配器： 
1、ArrayAdapte 
2、SimpleAdapter 
3、SimpleCursorAdapter 
4、BaseAdapter 
       下面是基于后面3中适配器实现的，还有一个就是SimpleAdapter的加强版，也就是plus，哈哈。主要是实现带图片功能，第一种适配器比较简单，准备用它实现显示分组。下面是实现功能截图以及代码。


上图实现的核心代码：
public class ListView1 extends Activity {
    private ListView listView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.listview1);

         listView = (ListView) this.findViewById(R.id.listView1);
         showSimpleAdapter();
    }
    private void showSimpleAdapter() {
        List<HashMap<String, Object>> data = new ArrayList<HashMap<String,Object>>();
            for (int i = 0; i < 4; i++) {
                HashMap<String, Object> item = new HashMap<String, Object>();
                item.put("name","atm"+i );
                item.put("age",10+i );
                data.add(item);
            }

    /**
     * Context context  上下文信息
       List<? extends Map<String, ?>> data   将该数据显示在界面上
       int resource     数据需要显示的地方
       String[] from    从什么地方
       int[] to         显示到什么地方
         */
        SimpleAdapter adapter = new SimpleAdapter(this, data, R.layout.item,new String[]{"name", "age"}, new int[]{R.id.text1,R.id.text2});

        listView.setAdapter(adapter);


    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }


}

上图实现的核心代码：
public class ListView2 extends Activity {
    private ListView listView;
    private ServiceTest serviceTest;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.listview1);

         listView = (ListView) this.findViewById(R.id.listView1);
         serviceTest=new ServiceTest(getApplicationContext());
         showSimpleCursorAdapter();
    }

    private void showSimpleCursorAdapter() {
        Cursor cursor =serviceTest.Find_cursor();
        SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, R.layout.item, cursor,
                new String[]{"name", "age"}, new int[]{R.id.text1, R.id.text2});
        listView.setAdapter(adapter);
    }
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }
}

上图实现的核心代码：
public class ListView3 extends Activity {
        private ListView listView;
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.listview2);

             listView = (ListView) this.findViewById(R.id.listView2);
             showSimpleAdapter();
        }
        private void showSimpleAdapter() {
        SimpleAdapter adapter = new SimpleAdapter(
                this, getData(), R.layout.item_plus,new String[]{"name", "age", "img"}, new int[]{R.id.name,R.id.age,R.id.img});

            listView.setAdapter(adapter);
        }

        @Override
        public boolean onCreateOptionsMenu(Menu menu) {
            // Inflate the menu; this adds items to the action bar if it is present.
            getMenuInflater().inflate(R.menu.main, menu);
            return true;
        }
        private List<Map<String, Object>> getData() {
            List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();

            Map<String, Object> map = new HashMap<String, Object>();
            map.put("name", "atm1");
            map.put("age", 1);
            map.put("img", R.drawable.img2);
            list.add(map);

            map = new HashMap<String, Object>();
            map.put("name", "atm2");
            map.put("age", 2);
            map.put("img", R.drawable.love);
            list.add(map);

            map = new HashMap<String, Object>();
            map.put("name", "atm3");
            map.put("age", 3);
            map.put("img", R.drawable.img1);
            list.add(map);

            return list;
        }

    }


上图实现的核心代码：
public class ListView4 extends Activity {
        private ListView listView;
        private ServiceTest serviceTest;
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.listview1);

             listView = (ListView) this.findViewById(R.id.listView1);
             serviceTest=new ServiceTest(this);
             listView.setOnItemClickListener(new ItemClickListener());
             showMyAdapter();
        }

        //点击后，获取给View上的数据
        private final class ItemClickListener implements OnItemClickListener{
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                ListView listview = (ListView)parent;
                UserInfo userinfo = (UserInfo) listview.getItemAtPosition(position);
                Toast.makeText(getApplicationContext(), userinfo.getUser_id()+"  "+userinfo.getUser_name(), 1).show();
            }
        }
        private void showMyAdapter() {
            // TODO Auto-generated method stub
            List<UserInfo> list=serviceTest.Findall();
            MyAdapter  myAdapter=new MyAdapter(this, list, R.layout.item);
            listView.setAdapter(myAdapter);
        }
        @Override
        public boolean onCreateOptionsMenu(Menu menu) {
            // Inflate the menu; this adds items to the action bar if it is present.
            getMenuInflater().inflate(R.menu.main, menu);
            return true;
        }
    }
代码下载请点击：代码下载

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android四大组件之Activity介绍
1、activity
（1）一个Activity通常就是一个单独的屏幕（窗口）,简单来说activity就是一个交互界面，一般应用程序都要由一个或者多个activity组成。
 
（2）Activity之间通过Intent进行通信。
 
（3）android应用中每一个Activity都必须要在AndroidManifest.xml配置文件中声明，否则系统将不识别也不执行该Activity。
 
（4）Activity的生命周期
 
一个Activity的启动顺序：
　　onCreate()——>onStart()——>onResume()
 
当另一个Activity启动时:
　　第一个Activity onPause()——>第二个Activity onCreate()——>onStart()——>onResume()
——>第一个Activity onStop()
 
当返回到第一个Activity时：
　　第二个Activity onPause() ——> 第一个Activity onRestart()——>onStart()——>onResume()——>第二个Activity onStop()——>onDestroy()
 
2.Activity状态
　　一般认为Activity有以下四种状态：
 
　　活动的：当一个Activity在栈顶，它是可视的、有焦点、可接受用户输入的。Android试图尽最大可能保持它活动状态，杀死其它Activity来确保当前活动Activity有足够的资源可使用。当另外一个Activity被激活，这个将会被暂停。
 
　　暂停：在很多情况下，你的Activity可视但是它没有焦点，换句话说它被暂停了。有可能原因是一个透明或者非全屏的Activity被激活。
 
　　当被暂停，一个Activity仍会当成活动状态，只不过是不可以接受用户输入。在极特殊的情况下，Android将会杀死一个暂停的Activity来为活动的Activity提供充足的资源。当一个Activity变为完全隐藏，它将会变成停止。
 
　　停止：当一个Activity不是可视的，它“停止”了。这个Activity将仍然在内存中保存它所有的状态和会员信息。尽管如此，当其它地方需要内存时，它将是最有可能被释放资源的。当一个Activity停止后，一个很重要的步骤是要保存数据和当前UI状态。一旦一个Activity退出或关闭了，它将变为待用状态。
 
待用： 在一个Activity被杀死后和被装在前，它是待用状态的。待用Acitivity被移除Activity栈，并且需要在显示和可用之前重新启动它。
 
日前，爱内测（www.ineice.com）推出了针对移动应用的Activity组件进行安全漏洞检测

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 6.0中的新技术有哪些

最近 Google 正式发布了 Android M，并命名为“棉花糖”(Marshmallow)，对于开发者来说，有哪些新的技术和变化呢?本文尝试总结一下 Android 6.0(API 23)给开发者带来新的技术和改变。



权限管理

权限管理是 Android M 最大的改变，权限管理更加精细，并且由以前的安装时静态授权，改为现在的运行时动态授权。大家对 Android 的权限吐槽已久，Android 应该能极大的改善这方面的问题。主要改变有：

系统设置中可以对 APP 各个权限单独控制

权限根据内容进行分组了

普通权限还是在安装时授权

其他权限在运行时系统弹窗授权，并且要解析使用这个权限的目的

对于开发者来说，需要小心处理权限相关的问题。在使用某个功能的时候，需要总是判断是否有改权限，并且通过合适的方式请求用户授权。关于 Android M 权限的处理，可以参考官方文档。

另外，这篇文章结合图文和代码讲述了 Android M 中权限模型，比较清晰，可以参考一下。

APP Linking

这是一个把 APP 和网页直接打通的技术，能够让 APP 能够直接来处理你的网站普通的 URL 链接，来展示你对应的网站内容。这绝对是一个值得关注的改进，Web 和 APP 之间缝隙将越来越小。这对既有网站又有 APP 的应用来说非常有利，例如知乎和淘宝等。

有点类似于之前的 APP 的 Deep link，可以通过特殊的 Schema 也可以让 APP 直接打开对应的内容。APP Linking 的特点是，只要使用传统的 URL 就可以，而且是根据 URL 的域名对应特定的 APP 的。

开发者需要做的是在 AndroidManifest.xml 做一下对应的声明即可。如果需要让系统默认用你的 APP 打开对应的 URL 的话，还需要网站配合提供 assetlinks.json。详情可以参考这里。

APP 数据自动备份

支持 APP 数据自动备份到 Google Drive，在你换手机的时候，能够直接把 APP 的数据恢复到你的手机上，你还可以配置些数据那些数据需要或者不需要备份。而且不用写任何代码就自动实现了。详情可以参考这里。

然而这些对国内的开发者来说，并没有什么用。国内厂商的 ROM 有些已经有或者准备会跟上，到时候都能享受到这样的便利。

指纹解锁

Android 官方支持指纹认证，可以用在解锁，或者任何需要验证用户的地方，例如支付。提供了新的 API FingerprintManager，让第三方 APP 来用来获得指纹认证的功能。具体使用方法可以参考这个实例。

直接分享

直接分享是在 APP 内直接弹出一个选择分享到其他应用的中的对象的列表，中间省略了选择需要分享的 APP，选择“联系人”之类的操作。Android 中分享已经做得很好了，这里又更进一步简化了分享操作。如果要让你的 APP 支持被直接分享，需要实现一个ChooserTargetService，并且实现对应的处理分享 Intent 的 Activity。具体使用可以参考这里。

支持蓝牙触控笔

系统内置支持蓝牙触控笔，这样 Android 系统就默认支持高大上的触控笔了。并提供了 API 让你的 APP 来响应触控笔事件。

低功耗蓝牙扫描优化

优化了低功耗蓝牙扫描优化的扫描。现在低功耗蓝牙的应用越来越多，很多 APP 都需要扫描设备，扫描设备是一个非常重的操作，希望这次改动，能够带来一些改善。

支持主题化的 ColorStateLists

使用 context.getColorStateList(int id) 来获取当前主题对应的 ColorStateLists。

相机 API

提供 API setTorchMode()) 来直接开关闪光灯，并且可以监听闪光灯的开光状态，以前很多 APP 已经支持用闪光灯来做手电筒，现在官方提供 API 来做这样的事情了。

从 Android 5.0 开始，就提供了一套全新的相机 API Camera2，这里在此基础上添加了处理相关 API。

其他

另外还有很多的改进，因为涉及的方面太专业，或者是没有使用到相关功能，我就不详细说了，可以参考官方概述：

有语音交互 API

Hotspot 2.0 支持

4k 屏支持

语音和视频 API 的改进

Android 企业用户特性，例如多用户支持，静默安装等



推荐阅读

程序员未来发展三大方向

20年资深程序员编程经验分享

解析程序员的几个成长阶段

为什么程序员有高薪却不高兴？


程序员如何持续提升自己的开发技能


版权声明：本文为博主原创文章，未经博主允许不得转载。

实战使用Axure设计App,使用WebStorm开发 – 构建页面架构
在本文中，将继续介绍在 WebStorm 中开发，去实现App的功能需求。 就像盖房子一样，第一步需要把整个工程的页面结构先勾勒出来，先让各个页面流转起来，然后再去细化每个页面。 所有工程代码放在了 https://github.com/zhangsichu/DeliveryApp 同时上篇文章中创建的初始化工程，也Tag了 TheInitialProject，您可以使用 Git checkout 这个Tag, 也可以直接到：https://github.com/zhangsichu/DeliveryApp/releases/tag/TheInitialProject 去下载初始化的工程代码，得到最初的 ionic 创建好的工程。git checkout TheInitialProject在本App中，咱们采用了 Ionic 作为基础的工程框架，Ionic 是基于 AngularJS 来构建的，所以第一步就是先把页面路由和URL设定好。创建工程的 service 和 controller，并在 app.js 添加路由设定。 咱们在 AngularJS 中 ng-app 的名字取名为 ddApp. 1. 在 js 目录下添加 services.js 和 controllers.js 并在 index.html中添加引用。 a) 在 service.js 下声明 ddApp.services Moduleangular.module(ddApp.services, []);b)在controller.js下声明ddApp.controllers Moduleangular.module(ddApp.controllers, [ddApp.services])c)在app.js 添加Module依赖angular.module(ddApp, [ionic, ddApp.services, ddApp.controllers])d)在 index.html中添加 Javascript 文件引用<script src="js/app.js"></script> <script src="js/services.js"></script> <script src="js/controllers.js"></script>到这一步您可以执行以下 ionic serveionic serve在浏览器里看看现在的页面情况 2. 添加路由和功能页面 a) 在 app.js 里添加app的路由。 代码很简单，设定App中Url对应的状态，和对应要访问的页面，同时也需在 www 目录下创建 templates 文件夹和对应的页面文件。b) 修改 controller.js 添加空的 Controller 当 templates 下对应的 html 创建完成后，需要在 controllers.js 下为每个页面先写一个空的 controller，稍后我们会去实现实际的业务功能。 c) 修改 index.html 修改 App 为 navigate view  到这一步您可以执行以下 ionic serveionic serve在浏览器里访问 http://localhost:8100/#/login 或者 http://localhost:8100/#/login 看看效果。 3. 让页面动起来 功能页面都创建好了，现在就要在页面里写功能了，让页面动起来了。 给每个页面添加按钮，在对应的 Controller 里添加功能代码。如在 Login页面里 添加 login 按钮，给它添加功能。<h1>Login</h1> <button ng-click="doLogin();">登陆</button>在Controller 里添加页面跳转的功能。 页面最后完成的样子。  到这一步完成的代码在：https://github.com/zhangsichu/DeliveryApp/releases/tag/AllPages 可以下载到。 你也可以执行 git checkout AllPagesgit checkout AllPages原文链接 http://zhangsichu.com/blogview.asp?Content_Id=157

版权声明：本文为博主原创文章，未经博主允许不得转载。

使用@autoclosure提高Swift代码质量
在Swift中方法终于成为了“一等公民”，可以作为参数被方法利用，在接触今天的内容之前，你必须了解Swift中方法和闭包的概念。Swift支持方法嵌套，Swift中的方法和闭包在类型上是有区别的。也就是说传入方法类型的参数也可以接收闭包，可是方法只能传入匹配方法返回值类型的参数，也就是说在运行方法前需要先执行参数中的方法算出返回值在传入参数运行调用该参数的方法，如果在一个方法中使用了多个判断语句可以提前中断，那么很多时候不需要知道后面的参数的具体值，比如下面的例子
 func expensiveMethod() -> Bool{
    NSThread.sleepForTimeInterval(10.0)
    println("执行了很久")
    return true
    }
另外一个方法and需要传入两个Bool类型的参数：
 func and(first:Bool,second:Bool)->Bool{
    println("执行and方法")
    return first&&second
    }
现在调用试试：
let result = and(false, second: expensiveMethod())
你会发现速度非常的慢，这是因为先运行expensiveMethod方法算出了返回值再去执行and方法的方法体。中控台打印： 
执行了很久 
执行and方法 
         而可能and方法的结果只通过第一个参数就可以执行了，这时候更好的办法是把第二个参数改为返回Bool类型的方法，然后传入一个闭包：
    func and(first:Bool,getSecond:()->Bool)->Bool{
        if !first{
        return false
        }else{
        return getSecond()
        }
    }
调用的方法也要修改：
let result = and(false, getSecond: { return self.expensiveMethod()})
这样的修改运行速度变快了，但是程序员使用这个API的时候需要写完整的闭包结构，比较麻烦，这个时候@autoclosure就派上用场了。使用这个修饰符可以使API调用时输入返回值即可：
 func and(first:Bool,@autoclosure getSecond:()->Bool)->Bool{
        if !first{
        return false
        }else{
        return getSecond()
        }
    }
这样在调用时就可以简化输入了：
let result = and(false, getSecond: expensiveMethod())
要注意的是@autoclosure只能用在（）->T这样无参数的闭包中

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

HTML5仿Apple Watch时钟动画
HTML5仿Apple Watch时钟动画
该款HTML5时钟是仿Apple
 Watch界面模拟出来的，可以根据本地时间实时更新指针数据，其华丽的界面却有苹果的风格。

下载地址：http://www.devstore.cn/code/info/266.html
运行截图：



版权声明：本文为博主原创文章，未经博主允许不得转载。

Android画布更新过程OnDraw调用过程

onDraw是触发的外置接口，用户可以复写这个方法，这样当回调onDraw时，就可以绘制出用户需要的画面

这个接口方法类似onLayout的回调，利用layout(l,t,r,b)就可以触发。 而这里onDraw方法需要invalidateI() 或者postInvalidate()来触发

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        设计模式在游戏中的应用--外观模式（八）
外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。外观模式相当于KFC里面的套餐，大多数人去FKC吃中饭，本质其实就是为了填饱肚子，消费者需要主食、饮料和小吃，有了各种套餐之后，消费者去KFC可以选择各种套餐就能满足自己的需要，不至于由于自己不会点餐都点主食而造成口渴和难以下咽的情况。套餐可以满足大多数人的需求。 
MMORPG游戏中也有着一些外观模式的应用，例如游戏中一种套餐可以让玩家升级到满级，学习和装备了最高的技能和装备。 
相关的流程图如下： 

相关的代码如下：
// MVC.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <iostream>
#include <string>
#include <sstream>
using namespace std;


class Skill
{
public:
    Skill(){};
public:
    void EquipSkill()
    {
        cout<<"EquipSkill"<<endl;
    }
};

class Level
{
public:
    Level(){};
public:
    void GetMaxLevel()
    {
        cout<<"Level Up 100 "<<endl;
    }
};


class Equip
{
public:
    Equip(){};
public:
    void GetBestEquip()
    {
        cout<<"Top Equip "<<endl;
    }
};

class Player
{
public:
    Player()
    {
        pSkill = new Skill();
        pLevel = new Level();
        pEquip = new Equip();
    };
public:
    void Superman()
    {
        pSkill->EquipSkill();
        pLevel->GetMaxLevel();
        pEquip->GetBestEquip();
    }
private:
    Skill* pSkill;
    Level* pLevel;
    Equip* pEquip;

};


void main()
{
    Player* player = new Player();
    player->Superman();
}


外观模式是在一些基础接口之上建立的高级接口，例如在MVC的各个层级之间需要使用外观模式来生成一些易于调用的接口。同时，在游戏的开发过程当中会使用很多的外部库，可是这些外部库的接口不是那么地人性化，这时我们的第一印象就是对其进行封装，其本质就是使用外观模式来得到一些高级的利用我们使用的接口。 
还有其实我们的游戏开发过程当中会有很多的作弊码，这些作弊码就是基于我们的游戏框架作为基础接口来生成的作弊码接口。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        猫猫新开通了新浪微博，欢迎小伙伴们来关注哟
猫猫新开通了新浪微博，欢迎小伙伴们来关注哟
新浪微博地址： http://weibo.com/znycat

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android插件化开发之OpenAtlas插件启动方式与插件启动广播
到现在为止已经写了6篇文章了

Android插件化开发之OpenAtlas初体验
Android插件化开发之OpenAtlas生成插件信息列表
Android插件化开发之OpenAtlas资源打包工具补丁aapt的编译
Android插件化开发之OpenAtlas插件适配
Android插件化开发之解决OpenAtlas组件在宿主的注册问题
Android插件化开发之OpenAtlas中四大组件与Application功能的验证

这篇文章主要介绍一下OpenAtlas插件的几种启动方式，在AtlasConfig这个类中，有几个静态字符串数组
public class AtlasConfig {
    public static String[] DELAY = new String[]{};
    public static String[] AUTO = new String[]{};
    public static String[] STORE = new String[]{};
}

也就是OpenAtlas的插件的启动的三种方式，DELAY 为延时加载，即用到的时候才会去加载。AUTO 为随宿主启动而启动，而STORE看名字还不知道他的启动方式是怎么样的。我们看下什么地方引用了它，其实整个框架中就两个函数引用了它，在OptDexProcess类中
/**** 对已安装并且安装方式为STORE的Bundle进行dexopt操作 ****/
    private void optStoreDex() {
        for (Bundle bundle : Atlas.getInstance().getBundles()) {
            if (!(bundle == null || contains(AtlasConfig.STORE, bundle.getLocation()))) {
                try {
                    ((BundleImpl) bundle).optDexFile();
                    Log.e("OptDexProcess", "optStoreDex");
                } catch (Throwable e) {
                    if (e instanceof DexLoadException) {
                        throw ((RuntimeException) e);
                    }
                    Log.e("OptDexProcess", "Error while dexopt >>>", e);
                }
            }
        }
    }

    /**** 对全部安装方式为Store的Bundle进行dexopt操作 ***/
    private void optStoreDex2() {
        for (String bundle : AtlasConfig.STORE) {
            Bundle bundle2 = Atlas.getInstance().getBundle(bundle);
            if (bundle2 != null) {
                try {
                    ((BundleImpl) bundle2).optDexFile();
                    Log.e("OptDexProcess", "optStoreDex2");
                } catch (Throwable e) {
                    if (e instanceof DexLoadException) {
                        throw ((RuntimeException) e);
                    }
                    Log.e("OptDexProcess", "Error while dexopt >>>", e);
                }
            }
        }
    }
看函数好像是对dex继续优化。

在Android系统中，一个App的所有代码都在一个Dex文件里面。Dex是一个类似Jar的存 
  储了多有Java编译字节码的归档文件。因为Android系统使用Dalvik虚拟机，所以需要把 
  使用Java Compiler编译之后的class文件转换成Dalvik能够执行的class文件。这里需要强 
  调的是，Dex和Jar一样是一个归档文件，里面仍然是Java代码对应的字节码文件。 
  当Android系统启动一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的 
  工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这 
  个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文 
  件的效率要高很多。

但是呢，我在里面加入了日志，看输出，仍然看不到其输出，只有随宿主启动的才会进行odex优化，配置了STORE，也看不到优化的日志输出，这里姑且不去理会，也可能是我使用的方式不对，一般我们使用DELAY或者AUTO即可。我们对之前的几个插件进行配置。让test随宿主启动，让zxing延时加载，其他几个为STORE（其实在效果上和DELAY差不多，只不过可能内部真的进行了odex优化，然而我看不到日志输出而已），配置的位置呢，在我们宿主的Applictaion中即可，使用静态代码块。
public class BootApp extends AtlasApp {
    static{
        AtlasConfig.DELAY = new String[]{"com.lizhangqu.zxing"};
        AtlasConfig.AUTO = new String[]{"com.lizhangqu.test"};
        AtlasConfig.STORE = new String[]{"com.lizhangqu.fragment","com.lizhangqu.component"};
    }
    @Override
    public void onCreate() {
        super.onCreate();
    }
}

下面的插件启动的日志输出。随宿主启动的插件 

延时加载的插件，只要启动了它才会被加载。
 
还有一个重要的问题就是插件如果随宿主启动，我们要知道插件是否安装成功。安装成功后进行页面跳转。而插件只需要安装一次，安装完后就可直接启动了。这里OpenAtlas提供了一个广播，当插件安装完成后会广播该消息。我们注册该广播即可。
public class BootActivity extends Activity {
    private BundlesInstallBroadcastReceiver atlasBroadCast;
    private class BundlesInstallBroadcastReceiver extends BroadcastReceiver {

        private BundlesInstallBroadcastReceiver() {
        }
        @Override
        public void onReceive(Context context, Intent intent) {
            try {
                startActivity(new Intent(BootActivity.this,MainActivity.class));
                BootActivity.this.finish();
                Log.e("TAG","BundlesInstallBroadcastReceiver,the bundle has install");
            } catch (Exception e) {
            }
        }
    }
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_boot);
        if ("false".equals(System.getProperty("BUNDLES_INSTALLED", "false"))) {
            this.atlasBroadCast = new BundlesInstallBroadcastReceiver();
            registerReceiver(this.atlasBroadCast, new IntentFilter(PlatformConfigure.ACTION_BROADCAST_BUNDLES_INSTALLED));
        }else{
            startActivity(new Intent(BootActivity.this,MainActivity.class));
            BootActivity.this.finish();
        }
    }
}

就这样，可以监听到插件的安装，当时该广播只有安装插件的时候会广播，安装成功后之后就不会再进行广播了，使用的时候注意一下就好了。
源代码，就不传csdn，放在github上，有兴趣的clone下来看看就好了。

https://github.com/lizhangqu/OpenAtlasDemo


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

ios开发技巧（一）

iOS的一些小技巧

TableView不显示没内容的Cell怎么办?

类似这种,我不想让下面那些空的显示.




很简单.

self.tableView.tableFooterView = [[UIView alloc] init];
试过的都说好.

加完这句之后就变成了这样.




自定义了leftBarbuttonItem左滑返回手势失效了怎么办?
    self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]
                                         initWithImage:img
                                         style:UIBarButtonItemStylePlain
                                         target:self
                                         action:@selector(onBack:)];
self.navigationController.interactivePopGestureRecognizer.delegate = (id<UIGestureRecognizerDelegate>)self;

ScrollView莫名其妙不能在viewController划到顶怎么办?
self.automaticallyAdjustsScrollViewInsets = NO;

键盘事件写的好烦躁,都想摔键盘了,怎么办?

买个结实的键盘.使用IQKeyboardManager(github上可搜索),用完之后腰也不疼了,腿也不酸了.

为什么我的app老是不流畅,到底哪里出了问题?

如图




这个神器叫做:KMCGeigerCounter
快去github搬运吧.

怎么在不新建一个Cell的情况下调整separaLine的位置?

_myTableView.separatorInset = UIEdgeInsetsMake(0, 100, 0, 0);

怎么点击self.view就让键盘收起,需要添加一个tapGestures么?
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
   [self.view endEditing:YES];
}

怎么给每个ViewController设定默认的背景图片?

使用基类啊,少年.

想在代码里改在xib里添加的layoutAttributes,但是怎么用代码找啊?

像拉button一样的拉你的约束.nslayoutattribute也是可以拉线的.

怎么像safari一样滑动的时候隐藏navigationbar?

navigationController.hidesBarsOnSwipe = Yes

导航条返回键带的title太讨厌了,怎么让它消失!
[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)
                                                     forBarMetrics:UIBarMetricsDefault];

CoreData用起来好烦,语法又臭又长,怎么办?

MagicalRecord

CollectionView 怎么实现tableview那种悬停的header?

CSStickyHeaderFlowLayout

版权声明：本文为博主原创文章，未经博主允许不得转载。

游戏人工智能开发之人群的动态行为交互仿真
博主把实验效果做成了视频，可以先看一下：
youtube（清晰）:https://youtu.be/S5wLx-zMrIE
优酷：http://v.youku.com/v_show/id_XMTMxOTM3NTE1Ng==.html
TX：http://v.qq.com/page/q/m/x/q0163gorwmx.html



动态人群交互模拟基于一般适应综合征理论General Adaptation Syndrome Theory


先了解一下什么是  一般适应综合征(general adaptation syndrome)
一般适应综合征(general adaptation syndrome)是由于持续的应急状态所引起的一种生理反应模式，其目的在于克服应急反应产生的影响，保证身体适应外界环境的能力。这种反应模式可分三个阶段：警觉阶段，抵御阶段，衰竭阶段。
例：
    假如把尖锐的呼啸声作为一种老鼠生活的环境中，你就会发现下列情况：开始，老鼠的紧张状态明显加强，心率增快，警惕性增高，骨骼集中的血管收缩，而多竖 起，双目直视，这就是警觉阶段。而活，在肾上腺分泌出比平时多的肾上腺素的作用下，老鼠的行为好似处于相对的正常状态，这就是抵御阶段。最后，老鼠过早死 于心力衰竭，这就是衰竭阶段。将死亡的老鼠解剖，你会发现老鼠的肾上腺明显的肿大。这表明，老鼠在克服应激状态中，肾上腺分泌出大量的肾上腺素，等它把应 付困难环境的积蓄力量全部耗尽，身体衰竭。表面看来，老鼠死于心脏病，但是，经过仔细的研究，老鼠的真正的死因是由于持续不断的应急状态所造成的。
词义关联

    一般适应综合征是由加拿大生理学家H.塞利首先提出来的，并且作了大量的动物实验来证明应激状态的影响。
以上解释来自网络
我们要模拟的就是，人物根据不同压力来做出不同行为。



根据人类固有性格不同而不同的行为，行为根据人类性格变化而动态变化。
使用著名心理学理论 --------  一般适应综合征理论General Adaptation Syndrome Theory
模拟仿真各种变化和压力，压力变化，步行速度变量发生改变
适用于游戏，虚拟现实等交互式应用程序
行为的差异主要来自于人类特点，人类行为的多种差异是由不同因素产生的，如刺激的不同，遗传因素，生理状态，认知状态，社会环境，文化环境，以前的生活经历，和个人个性特征。尽管有这么多种因素，行为也可以分为几个基本类型
归因理论（Attribution theory）：人力资源管理和社会心理学的激励理论之一，归因是指观察者为了预测和评价被观察者的行为，对环境加以控制和对行为加以激励或控制，而对被观察者的行为过程所进行的因果解释和推论。因为归因理论（Attribution theory）把这些原因分为意向属性和情景属性。人模糊地意识到需要的心理状态。当人的需要以模糊的形式反映在意识之中时，所产生的不明确的需求意念就是意向。简单来说就是个人的个性因素。情景属性是外部因素如现在的环境状态。我们将要模拟的人物代理需要人物个性，和环境情景来模拟。
情境因素称为压力，应激源对人物代理产生的效果将被当做压力来测量，我们模拟一般适应综合征理论General Adaptation Syndrome Theory作为人类如何应对压力的模型。
基于心理学模型进行人群仿真，动态模拟人群的行为模式，考虑各种类型的压力。模拟中人的行为受两个方面影响，是上面提到过的人的个性和情境因素。
应激源的函数在时间和空间上产生各种各样真实世界中的人群行为。包括好多基于时间约束的应激源如人物代理的位置和其他环境因素。这些应激源可以和目标导向（goal-directed）结合，多人物代理模拟能产生多样行为。将意向属性作为内部权重，情景属性作为外部权重，人物代理从应激源（作为一个函数）收到我们模拟压力的测量值，就是这两个权重。



压力
一些研究人员描述人类如何应对压力，包括生理性变化和外部行为变化，人在有压力的时候攻击性增加。而且压力的反应会随着时间改变。


人群模拟技术
人群模拟（crowd simulation）和多智能导航（multi-agent navigation）是一个活跃的研究领域，我们主要关注人群行为的交互式方法。


行为模型
我们对于模拟复杂的行为使用基于规则（Rule-based）的方法，包括：原动力、知觉、行为和认知成分等来模拟行人行为和模拟决策过程。知觉是客观事物直接作用于感官而在头脑中产生的对事物整体的认识。认知成分是态度的其余组成成分的基础。
可你模拟行为如侵略、社会优先级、权威、保护和引导等。
许多研究人员已经在人群种仿真方面上使用心理因素。
这些行为模式的选择必须遵守给定的规则，比如一个人物代理，程序告诉他，饿了吃面包，结果那个人找不到面包店，饿死在了拉面馆门口。

压力的心理模型
广义上讲,压力可以被定义为任何变化引起的环境和个体之间的交互。一般般来说，压力产生因为环境要求与个人能力之间的矛盾，当人们觉得他们需要应对挑战时他们会觉得紧张。应激源产生压力，他可以是一种情况、一个对象、或者其他个体。有许多压力的来源，本文主要关注以下几点：

1.个人的负荷(具有挑战性的情况下),如时间限制与每个人物代理的目标;
2.感知到的威胁,如火灾危险的动物或对象;
3.不愉快的事情,如热、噪音、空气污染(吸烟,恶臭)和过度拥挤。


一般性适应综合征(general adaptation syndrome)
 
一般GAS模型作为应对任何压力源(毒素、寒冷、受伤、疲劳、恐惧等)反应的GAS模型有三个阶段:预警,抵抗,衰竭（如上图）。在感受到压力时,在预警阶段,他们准备好了为“战斗”或“逃走”。左图是GAS模型模拟压力随着时间的变化，在预警阶段迅速提升，在抵抗阶段提升到峰值，在衰竭阶段随着时间压力减弱，右图是近似模型α为压力达到峰值的速度也是压力产生速度，决定预警期长短，β是压力的峰值大小。


我们首先设置一个任务代理正在受到的压力ψ，我们的目标是计算一个任务代理的应激反应定义为S。压力的变化速率α，代表人物代理并不马上应对压力，有预警阶段作为一个缓冲。为了把任务代理的应急反应强度限制，我们设置一个压力的峰值β，这是因为如果压力无限增强的话，就会限制人物代理的响应，行为也不自然。
把这些值结合到一起得到如下公式：
 
dS/dt为应激反应曲线的斜率也就是压力增长和衰减速度。
S的上限为β，因为性能问题我们把α和β设为常量。

每个人的α和β都不相同，我们可以自己设定，或者使用测得的真实值。

所以，这个系统有三个步骤
1.    应激源提供压力
2.    基于GAS模型的压力积累函数
3.    多代理模拟算法（multi-agent simulation algorithm），通过改变代理的攻击性和冲动可以改变代理的行为。
 


压力感知
感知到的压力ψ与先前自身带有的压力I有如下关系：
 
k为比例因子，n为指数，这两个参数大小取决于应激源的种类。
压力源的原型
四种压力原型：

时间压力
在一个特定时间达到一个目标而产生时间压力，如：过马路、在大门关闭之前登上火车、在火灾中逃离建筑物。
去模拟这种类型的压力，人物代理有一个目标位置和一个固定时间限制tallowed，我们模拟时间压力的强度It，根据时间限制与预计到达时间差，也就是剩余到达时间来模拟这个函数：
 
testimated是到达目标预计时间，例如：testimated= distRemaing/avgSpeed.

环境应激
环境应激由环境状态产生，例如：噪音、高温、强光、烟雾。在区域中这种应激源的强度一般是常量：
 
A是产生应激环境区域，pa是当前人物代理位置。

位置应激
这是应激源结合本地压力产生源。不同于环境应激，位置应激为压力随着人物代理与应激源的距离的减小而增加，包括静态的应激源如火焰，或者动态的应激源如一辆疾驰的车或者一个暴力分子。
 

pa为人物代理位置ps为应激源位置
pa为人物代理位置ps为应激源位置
如果一个很大区域有着高强度的刺激，我们也可以用高斯分布：


人际压力
来自其他人物代理的压力，常见的例子如拥挤。我们通过一个密度阈值与当前密度的差距来定义压力函数：
 
ncur是单位区域内在当前的周围人数，npref是相同区域内周围人数的阈值。

压力模型
以上四种压力每种都用强度I来定义，结合公式2，用来求出感知到的压力ψ。一个人物代理的应激反应S由公式1求得。
α和β可变变量来控制代理的应激反应，人们基于自身的防御系统和个人性格产生压力的变化，α越大对压力产生的反应越快，β越大人能产生的反应越大。

多应激源
当面对多压力，我们计算出每个压力值在进行加权处理求得总压力，人们可选择自己对不同刺激的不同反应强度作为权重w。
 
wi是每个应激源Si的权重，赋予人们压力的优先级。


我们可观察到人物代理主要的响应是增加积极地和冲动行为，我们希望它能显示侵略性和冲动的变化


加入行为变化
以两个范围作为群体行为的原则，可以被视为高级参数。范围一，定义PC1，外向的性格有更多激烈的行为。第二范围，PC2的谨慎行为很多。根据这两个维度，我们可以选择仿真所需参数。我们用压力行为向量作为参数表示这个差异，Bstress作为人物代理感知到压力的能力


例如PC1与PC2分别为积极的，和仔细的。


结合人格特性
一个矩阵Apc给予一个关于PC1＆PC2之间的线性映射，矩阵Aadj映射了各种不同性格的描述。我们决定人物代理的最终行为是线性的结合这两个矩阵，第一个代表情景响应，第二个代表人物代理固有的性格个性。
下面方程求出仿真参数，根据固有的个性特征和动态变化的压力反应来描述人物代理的行为，
 

P是响应一个人物代理固有个性的向量。当一个人物代理感知到压力并且S值增加，Bstress效果增加因此压力性的行为也增多。当压力消失了，S将会减少，人物代理的行为也会回到初始人物个性行为P。



实践结果
请先观看视频：
youtube（清晰）:https://youtu.be/S5wLx-zMrIE
优酷：http://v.youku.com/v_show/id_XMTMxOTM3NTE1Ng==.html
TX：http://v.qq.com/page/q/m/x/q0163gorwmx.html

对立小组
两组人物代理通过走廊向相互反向移动。
受目标压力与人际压力。

过马路
一个人物代理过马路的十字路口，信号剩余时间作为压力源。



在40s的时候压力较少，人物代理漫不经心的过道




在剩余时间少的时候压力变大，人物变走为跑

追逐
一个怪物追赶人物代理。通过怪物与人物代理的位置来计算压力，是位置应激



四散而逃


距离由近及远，压力由大到小


多个压力存在权重


疏散
一千人物代理撤离一个办公环境。压力来自于火灾。因为人数多，所以拥挤作为第二应激源（人际压力）；

人物性格不同行为不同



参考：Interactive Simulation of Dynamic Crowd Behaviors using General Adaptation Syndrome Theory



                                                ---------  by wolf96   http://blog.csdn.net/wolf96







版权声明：本文为博主原创文章，未经博主允许不得转载。

spring 配置bean的方法及依赖注入发方式
Bean 的配置方式：通过全类名（反射）、通过工厂方法（静态工厂方法 & 实例工厂方法）、FactoryBean
这里根据全类名配置bean
<bean id="helloWord" class="com.spring.HelloWord">
 <property name="userName" value="springsss"></property>
</bean>



依赖注入发方式：

属性注入：
applicationContext.xml配置文件为：
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:p="http://www.springframework.org/schema/p"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd">
<!-- 配置bean -->
<bean id="helloWord" class="com.spring.HelloWord">
 <property name="userName" value="springsss"></property>
</bean>
</beans>

package com.spring;
public class HelloWord {
private String userName;
public void setUserName(String userName) {
this.userName = userName;
}
public void hello() {
System.out.println("hello:" + userName);
}
public HelloWord(){
System.out.println("construct!!!!!!!!!!");
}
}



package com.spring;


import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class Test {
public static void main(String[] args) {
/**
* 创建对象及为对象赋值交给spring完成
*/
// HelloWord helloWord = new HelloWord();
// helloWord.setUserName("hello");
// helloWord.hello();

//1.创建spring IOC容器
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");


//2从容器中获得Bean
HelloWord helloWord = (HelloWord) ctx.getBean("helloWord");


//3.调用方法
helloWord.hello();

}
}

输出结果为：
construct!!!!!!!!!!
hello:springsss





构造器注入：
applicationContext.xml文件为
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:p="http://www.springframework.org/schema/p"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd">
<!-- 配置bean -->
<bean id="car" class="com.spring.Car">
<constructor-arg value="green"></constructor-arg>
<constructor-arg value="22"></constructor-arg>
</bean>
</beans>



public class Car {
 private String name;
 private String color;
 private int num;
public Car(String color, int num) {
super();
this.color = color;
this.num = num;
}
@Override
public String toString() {
return "Car [name=" + name + ", color=" + color + ", num=" + num + "]";
}


}



package com.spring;


import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class Test {
public static void main(String[] args) {


//1.创建spring IOC容器
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");


Car car = (Car) ctx.getBean("car");
System.out.println(car.toString());

}
}

输出结果为：
Car [name=null, color=green, num=22]






版权声明：本文为博主原创文章，未经博主允许不得转载。

使用@noescape解决Swift闭包“保留环”问题
在使用Swift进行编程的时候我们经常使用闭包，闭包虽然好，但是不可避免地会带来“保留环”问题，考虑下面的情况： 
在某个动画框架中有一个loop函数：
 func loop(duration:NSTimeInterval,reverse:Bool,animations:()->Bool )
在我们自己的类中定义一个动画方法，使用了这个函数：
class MyView:UIView{

    func animations(){
        loop(duration:0.5,reverse:true){
        self.scale(1.25)
        }
    }
    func scale(scale:Double){...}
}
你会发现在闭包中捕获了self，loop函数循环每次都调用闭包，这样会一直保留self。而闭包中的操作其实是一成不变的，没有必要每次都访问。如果我们只调用一次animations闭包，给它拍一张快照就可以解决这个问题了，这就要用到@noescape:
func loop(duration:NSTimeInterval,reverse:Bool,@ noescape animations:()->Bool )
这样就不会有保留环问题，因为这个闭包只被执行一次，即便发生循环时也会绕过闭包。@noescape还是个新角色，但是系统库中已经有些地方在使用了，比如我们熟悉的reduce方法：
func reduce<U>(initial: U, combine: @noescape (U, T) -> U) -> U

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift学习笔记之公用库和模块化
静态库和动态库
先补充一下静态库和动态库的知识。这部分内容我也不太熟，没有开发经验，如有错误欢迎打脸。
静态库
静态库的代码追加到可执行文件内，被多次使⽤用就有多份冗余拷⻉。
好处就是应用程序包自身可以独立运行，而不好的地方就是包会略显臃肿，库不能共享。
iOS 中静态库的形式是 .a 和 .framework (自己创建的 .framework 是静态库)。
.a
.a 文件在真正使用的时候需要提供头文件和资源文件。以前 Xcode 中默认提供的就是这种方式。不过编译出来静态库只支持特定的一种硬件架构体系，如果你想生成一个 Universal 的静态库的话，需要通过工具来将多个静态库进行合并。而且使用的时候需要另外配合 .h 文件，相比之下 framework 会是更好的选择。
.framework
framework 不但可以包含二进制文件，还可以包含头文件，资源文件等，甚至可以支持多个版本。不过各个应用所使用的自己的公用库，最终都需要 link 进可执行文件，所以本质上还是一个静态库。
动态库
动态库的代码和可执行文件是分开独立的，程序运行时由系统动态加载到内存，系统只加载一次，多个程序共用节省内存。
动态库的优劣与静态库相反，动态链接库需要库环境，但由于本身不集成库内容，会比较小，同时也为和其他应用共享库的使用提供了可能。
iOS 中动态库的形式是 .dylib 和 .framework (系统的 .framework 是动态库)。
现状
出于安全层面的考虑， AppStore 不允许使用第三方的动态链接库。我们可以通过 framework 编写自己的公用库。随着 Xcode6 开始支持新建 framework ，再也不用手动配置了。iOS-Universal-Framework 也宣布停止更新。
模块
模块化 (modules) 是在 2012年的 LLVM Developers Meeting 中提出的。简单说就是用树形的结构化描述来取代以往的平坦式 #include ，对框架进行封装，从而解决以往方法的脆弱性和扩展性不足的问题。 (这段我也不太懂，只是翻译了一下。。。)
以 UIKit 为例， module.map 大概是这个样子：
framework module UIKit {  
    umbrella header "UIKit.h"
    module * {export *}
    link framework "UIKit"
}

使用的时候用 @import 即可。如果所有代码都需要这样重写必定是一项浩大的工程，所以 Apple 已经提前把这部分工作做好了。只要使用的是 iOS7 的 SDK，将 Enable Modules 打开后，然后保持原来的 #import 写法就行了，编译器会在编译的时候自动地把可能的地方换成 modules 的写法去编译。

References

Module System of Swift
iOS如何创建和使用静态库
ios开发中的动态链接库和静态链接库


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

什么情况让程序员处于水生火热中

都说程序员是高薪一族，但是时薪不高啊!“干得比驴累，吃得比猪差，起得比鸡早，睡得比狗晚，看上去比谁都好，五年后比谁都老。很多程序员都曾这样感慨和抱怨过自己的生活状态。长期处于这种”亚健康状态，程序员们也有疲倦的时候，面对刁难的客户、不懂开发的领导，代码一直改改改，写出低质量的代码不由自主。



每一个程序员在他的职业生涯中某一天都会突然获得开示，这种开示在通常某一个夜晚悄然降临，有时是以图灵本人托梦的形式出现。这一开示的主要内容如下：程序员是真正理解思维和逻辑真谛的人。非程序员是被蒙蔽的无知者。

写出低质量的代码的特征包括但不限于：

· 心安理得地写出低质量的代码

· 最终写出了低质量代码却不在之后改善它

· 自以为写出了质量很高但实际质量很低的代码

低质量的特征包括但不限于：

· 文件关系混乱

· 注释过期、不明确或者没有

· 文档过期、不明确或者没有

· 架构乱设计

· 过度设计

· 不检查用户输入的错误情况

· 不检查API或者函数返回的errorcode或者exception

· 没有单元测试等自动化测试过程

· 编译起来很难

· 到处复制代码，公用的部分不整理成内部库

很多在互联网行业滚打的程序员发表了自己独到见解，你是否也是这么认为了?来一起和志同道合的程序员同伴们好好聊聊吧。



知乎网友：Fireman A，曾经是某电信公司的网站及应用负责人

每一个程序员对于世界上其他程序员有着不可推卸的责任。每一个程序员都必须尽力维护程序员这一高贵种族的延续，并保证世界的命运控制在程序员手中，既不被无知者淹没，也不被机器智能取代。

完成这一使命的唯一方式，是保证稳定地出产低质量，难以理解，修改和维护的代码。每一个负责任的程序员，他每一年的产出，必须为另外三个程序员制造一年的就业机会。唯此，程序员一族可生生不息，整个IT行业欣欣向荣。

知乎网友：苏莉安

「负责验收的领导都打好招呼了，到时候走个过场就行。反正项目经费到手之后这东西也不会有人真用，抓紧时间，两周之内完成。对了，首页做漂亮点。」

知乎网友：狗叔，攻城狮B

“这个功能大概几天能完成?”

“五天吧。”

“给你三天，代码跑起来再说。”

匿名用户

你知道我碰到过客户主动要求降低代码质量并加 BUG 的情况吗?原来他是要把我们的项目送去第三方机构评测，但是又害怕对方收钱不办事，不加几个 BUG 怎么知道对方测没测?不降低点代码质量搞得混乱点，怎么防止对方拿了代码又出去卖或者开发同类产品?

我被客户“高瞻远瞩”的思考深深的“折服”了，于是我生平第一次开始琢磨怎么才能把一切搞乱?怎么才可以把 BUG 加的有深有浅……

知乎网友：陈萌萌，其实我是一个AI_(:з」∠)_

“别想太多，先让代码work起来，大家都这么干的!”简直是神借口啊!

每个有责任心的程序员大神（小编一直以来对程序员一族的敬称）都是不允许自己写出低质量的代码的，在上述网友的境遇相信很多大神们都常常遇到，所以这些借口，不这些无法避免的环境改变了大神们高贵的初心，写出了低质量的代码，让大神们也在水生火热的境遇中煎熬。



推荐阅读

程序员未来发展三大方向

20年资深程序员编程经验分享

解析程序员的几个成长阶段

为什么程序员有高薪却不高兴？


程序员如何持续提升自己的开发技能





版权声明：本文为博主原创文章，未经博主允许不得转载。

Volley源码解析
人人都说Volley写的非常优秀，今天我们就打开volley的源码，来看看volley是怎么实现网络请求的，首先，我们从刚开始使用入手
mRequestQueue = Volley.newRequestQueue(App.getInstance());
跟进代码，Volley.newRequestQueue，
public static RequestQueue newRequestQueue(Context context, HttpStack stack) {
    // 缓存目录
    File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);

    // 拼装UA
    String userAgent = "volley/0";
    try {
        String packageName = context.getPackageName();

        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
        userAgent = packageName + "/" + info.versionCode;
    } catch (NameNotFoundException e) {
    }

    // 如果HttpStack为空
    if (stack == null) {
        // 判断sdk版本
        // HurlStack和HttpClientStack内部分别使用HttpUrlConnection和HttpClient
        // 进行网络请求
        if (Build.VERSION.SDK_INT >= 9) {
            // 使用HttpUrlConnection
            stack = new HurlStack();
        } else {
            // 使用HttpClient
            // Prior to Gingerbread, HttpUrlConnection was unreliable.
            // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
            stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
        }
    }

    // 创建NetWork
    Network network = new BasicNetwork(stack);
    // 初始化请求队列，注意：**这里并不是一个线程**，并启动它
    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);
    queue.start();

    return queue;
  }
这里面初始化了HttpStack, NetWork, RequestQueue， 并startRequestQueue，需要注意的是：RequestQueue并不是一个线程
进入RequestQueue.start，
public void start() {
    stop();  // Make sure any currently running dispatchers are stopped.
    // Create the cache dispatcher and start it.
    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    // Create network dispatchers (and corresponding threads) up to the pool size.
    for (int i = 0; i < mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
                mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        networkDispatcher.start();
    }
}
首先调用stop保证CacheDispatcher和NetworkDispatcher都quit， 然后新建CacheDispatcher并启动，这里是一个线程，内部是一个死循环，然后创建几个(默认4个)NetworkDispatcher，并全部启动，内部同样是死循环。
CacheDispatcher.run,
@Override
public void run() {
    if (DEBUG) VolleyLog.v("start new dispatcher");
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

    // Make a blocking call to initialize the cache.
    mCache.initialize();

    while (true) {
        try {
            // Get a request from the cache triage queue, blocking until
            // at least one is available.
            // 从缓存的请求中获取一个请求，如果没有 这里会阻塞
            final Request request = mCacheQueue.take();
            // 标记：刚从缓存获取的
            request.addMarker("cache-queue-take");

            // If the request has been canceled, don't bother dispatching it.
            // 如果请求被cancel了，结束请求
            if (request.isCanceled()) {
                request.finish("cache-discard-canceled");
                continue;
            }

            // Attempt to retrieve this item from cache.
            // 根据缓存的请求的key试图从本地缓存中获取缓存的http
            Cache.Entry entry = mCache.get(request.getCacheKey());
            // 如果获取到的本地缓存是null
            if (entry == null) {
                // 标记缓存丢失
                request.addMarker("cache-miss");
                // Cache miss; send off to the network dispatcher.
                // 并将该请求放到网络请求队列中
                mNetworkQueue.put(request);
                continue;
            }

            // If it is completely expired, just send it to the network.
            // 如果本地缓存过期
            if (entry.isExpired()) {
                // 标记过期
                request.addMarker("cache-hit-expired");
                request.setCacheEntry(entry);
                // 并将请求重新放入网络请求队列中
                mNetworkQueue.put(request);
                continue;
            }

            // We have a cache hit; parse its data for delivery back to the request.
            // 到这里，就是已经本地缓存的http可用
            request.addMarker("cache-hit");
            // 将数据解析成Response mark
            Response<?> response = request.parseNetworkResponse(
                    new NetworkResponse(entry.data, entry.responseHeaders));
            request.addMarker("cache-hit-parsed");

            // 如果数据不需要重新获取
            if (!entry.refreshNeeded()) {
                // Completely unexpired cache hit. Just deliver the response.
                // 直接回调到我们设置的Listener mark
                mDelivery.postResponse(request, response);
            } else {
                // Soft-expired cache hit. We can deliver the cached response,
                // but we need to also send the request to the network for
                // refreshing.
                // 到这里说明我们缓存的http需要刷新
                request.addMarker("cache-hit-refresh-needed");
                request.setCacheEntry(entry);

                // Mark the response as intermediate.
                response.intermediate = true;

                // 这里将结果回调并且又将请求放到请求队列中 mark
                // Post the intermediate response back to the user and have
                // the delivery then forward the request along to the network.
                mDelivery.postResponse(request, response, new Runnable() {
                    @Override
                    public void run() {
                        try {
                            mNetworkQueue.put(request);
                        } catch (InterruptedException e) {
                            // Not much we can do about this.
                        }
                    }
                });
            }

        } catch (InterruptedException e) {
            // We may have been interrupted because it was time to quit.
            if (mQuit) {
                return;
            }
            continue;
        }
    }
}
这里面的内容虽然多，但是逻辑简单，就是从缓存的请求中获取一个请求，并判断本地是否存在缓存的http并且判断是否过期，根据判断的状态来决定是否将请求放到网络请求队列中等待请求的发起，还是直接从本地缓存的数据中直接获取数据。这里面几个mark的地方，我们过会再看，接下来我们来看看NetworkDispatcher
NetworkDispatcher.run
@Override
public void run() {
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    Request request;
    while (true) { // 也是一个死循环
        try {
            // Take a request from the queue.
            // 从请求队列中获取一个请求
            // 如果请求是一个缓存的请求，
            // 则在CacheDispatche通过一系列判断将请求放入网络请求队列
            request = mQueue.take();
        } catch (InterruptedException e) {
            // We may have been interrupted because it was time to quit.
            if (mQuit) {
                return;
            }
            continue;
        }

        try {
            request.addMarker("network-queue-take");

            // If the request was cancelled already, do not perform the
            // network request.
            // 请求canceled
            if (request.isCanceled()) {
                request.finish("network-discard-cancelled");
                continue;
            }

            // Tag the request (if API >= 14)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());
            }

            // Perform the network request.
            // 通过NetWork.performRequest来真正的请求网络
            // 并将分析后的结果封装到networkResponse中返回
            // 这里面包含了statusCode，data，headers，notModified
            // mark
            NetworkResponse networkResponse = mNetwork.performRequest(request);
            request.addMarker("network-http-complete");

            // If the server returned 304 AND we delivered a response already,
            // we're done -- don't deliver a second identical response.
            if (networkResponse.notModified && request.hasHadResponseDelivered()) {
                request.finish("not-modified");
                continue;
            }

            // Parse the response here on the worker thread.
            // 这里将返回的结果根据我们使用的不同的request进行解析
            // 解析成我们想要的数据（例如JSONObjectRequest是把结果解析成JSONObject）
            Response<?> response = request.parseNetworkResponse(networkResponse);
            request.addMarker("network-parse-complete");

            // Write to cache if applicable.
            // TODO: Only update cache metadata instead of entire record for 304s.
            // 如果允许缓存，将请求的内容缓存起来
            if (request.shouldCache() && response.cacheEntry != null) {
                mCache.put(request.getCacheKey(), response.cacheEntry);
                request.addMarker("network-cache-written");
            }

            // Post the response back.
            // 标记请求已经投递
            request.markDelivered();
            // 将结果投递到我们的Listener mark
            mDelivery.postResponse(request, response);
        } catch (VolleyError volleyError) {
            parseAndDeliverNetworkError(request, volleyError);
        } catch (Exception e) {
            VolleyLog.e(e, "Unhandled exception %s", e.toString());
            mDelivery.postError(request, new VolleyError(e));
        }
    }
}
现在我们整个流程走通了，但是还是迷迷糊糊的，为什么呢？因为我们还有几个细节的地方没有去看，仔细看注释的话，很多地方我都打了mark标记，接下来我们就一块来看看这些mark的地方实现的细节。
CacheDispatcher.run
// 将数据解析成Response mark
Response<?> response = request.parseNetworkResponse(new NetworkResponse(entry.data, entry.responseHeaders));
这里是将数据解析成Response，唉？怎么一下到解析数据了，请求网络还没有呢？ 仔细看，这里是缓存的数据。Request是一个接口，我们来到一个它的实现类JSONObjectRequest中来看看，
...
@Override
protected Response<JSONObject> parseNetworkResponse(NetworkResponse response) {
    try {
        String jsonString =
            new String(response.data, HttpHeaderParser.parseCharset(response.headers));
        return Response.success(new JSONObject(jsonString),
                HttpHeaderParser.parseCacheHeaders(response));
    } catch (UnsupportedEncodingException e) {
        return Response.error(new ParseError(e));
    } catch (JSONException je) {
        return Response.error(new ParseError(je));
    }
}
这里首先将response.data这个byte数组按照http头信息中的charset构造成一个String，然后返回Response.success()，参数是我们new的一个JSONObject，为什么是JSONObject？ 别忘了这里是JSONObjectRequest, 回想一下，我们使用JSONObjectRequest的时候，onResponse中是不是直接返回了一个JSONObject。 
继续看看Response.success,
/** Returns a successful response containing the parsed result. */
public static <T> Response<T> success(T result, Cache.Entry cacheEntry) {
    return new Response<T>(result, cacheEntry);
}
用我们传进来的值构造了一个Response对象，看看Response的构造方法，
private Response(T result, Cache.Entry cacheEntry) {
    this.result = result;
    this.cacheEntry = cacheEntry;
    this.error = null;
}

private Response(VolleyError error) {
    this.result = null;
    this.cacheEntry = null;
    this.error = error;
}
简答的将数据保存了一下，那我们在使用的时候怎么获取到的数据呢？
new Response.Listener() {
  public void onResponse();
}
Response肯定有一个Listener和ErrorListener的接口，
/** Callback interface for delivering parsed responses. */
public interface Listener<T> {
    /** Called when a response is received. */
    public void onResponse(T response);
}

/** Callback interface for delivering error responses. */
public interface ErrorListener {
    /**
     * Callback method that an error has been occurred with the
     * provided error code and optional user-readable message.
     */
    public void onErrorResponse(VolleyError error);
}
至于何时去回调的接口，我们接着看下一个mark的地方
// 直接回调到我们设置的Listener mark
mDelivery.postResponse(request, response);
ResponseDelivery是一个接口，我们去看他的实现类——ExecutorDelivery 
这个类的构造有一个handler的参数，
/**
 * Creates a new response delivery interface.
 * @param handler {@link Handler} to post responses on
 */
public ExecutorDelivery(final Handler handler) {
    // Make an Executor that just wraps the handler.
    mResponsePoster = new Executor() {
        @Override
        public void execute(Runnable command) {
            handler.post(command);
        }
    };
}
在哪初始化的呢？在我们初始化RequestQueue的时候其实是去调用了另外一个RequestQueue的构造，
public RequestQueue(Cache cache, Network network, int threadPoolSize) {
    this(cache, network, threadPoolSize,
            new ExecutorDelivery(new Handler(Looper.getMainLooper())));
}

public RequestQueue(Cache cache, Network network, int threadPoolSize,
        ResponseDelivery delivery) {
    mCache = cache;
    mNetwork = network;
    mDispatchers = new NetworkDispatcher[threadPoolSize];
    mDelivery = delivery;
}
看最后一个参数，就是要找的ResponseDelivery，在new的时候我们是给它了一个handler,该handler指定了Looper使用UI线程上的Looper。 
继续看ExecutorDelivery，
public ExecutorDelivery(final Handler handler) {
  // Make an Executor that just wraps the handler.
  mResponsePoster = new Executor() {
      @Override
      public void execute(Runnable command) {
          handler.post(command);
      }
  };
}
构造上就做了一件事，new了一个Executor,并重写了execute方法，在这里面我们使用UI线程上的handler post了一个Runnable，post到哪了？肯定是到UI线程了！也就是说command的run方法里面的内容是在UI线程中执行的，我们严重怀疑，回调的工作是在这干的！ 
继续看看我们关心的postResponse方法，
@Override
public void postResponse(Request<?> request, Response<?> response) {
    postResponse(request, response, null);
}

@Override
public void postResponse(Request<?> request, Response<?> response, Runnable runnable) {
    request.markDelivered();
    request.addMarker("post-response");
    mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
}
标记了一个request，并且post了new ResponseDeliveryRunnable()【这里前面刚说了】， 
ResponseDeliveryRunnable是ExecutorDelivery的一个内部类，来看看干嘛了，
private class ResponseDeliveryRunnable implements Runnable {
    private final Request mRequest;
    private final Response mResponse;
    private final Runnable mRunnable;

    public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) {
        mRequest = request;
        mResponse = response;
        mRunnable = runnable;
    }

    @SuppressWarnings("unchecked")
    @Override
    public void run() {
        // If this request has canceled, finish it and don't deliver.
        if (mRequest.isCanceled()) {
            mRequest.finish("canceled-at-delivery");
            return;
        }

        // Deliver a normal response or error, depending.
        if (mResponse.isSuccess()) {
            mRequest.deliverResponse(mResponse.result);
        } else {
            mRequest.deliverError(mResponse.error);
        }

        // If this is an intermediate response, add a marker, otherwise we're done
        // and the request can be finished.
        if (mResponse.intermediate) {
            mRequest.addMarker("intermediate-response");
        } else {
            mRequest.finish("done");
        }

        // If we have been provided a post-delivery runnable, run it.
        if (mRunnable != null) {
            mRunnable.run();
        }
   }
}
继承了实现了Runnable接口，并且有三个参数，这三个参数从哪来我们是非常关心的，来捋捋吧，
@Override
public void postResponse(Request<?> request, Response<?> response) {
    postResponse(request, response, null);
}

@Override
public void postResponse(Request<?> request, Response<?> response, Runnable runnable) {
    request.markDelivered();
    request.addMarker("post-response");
    mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
}
看来是我们从CacheDispatcher传递过来的，
if (!entry.refreshNeeded()) {
    // Completely unexpired cache hit. Just deliver the response.
    mDelivery.postResponse(request, response);
} else {
...
}
这里我们调用了两个参数的那个方法，所以Runnable为null，requst和response哪来的呢？
 final Request request = mCacheQueue.take();
 Response<?> response = request.parseNetworkResponse(
                  new NetworkResponse(entry.data, entry.responseHeaders));
看到了吗，熟悉的代码，这里的代码我们已经分析过来，request是我们从队列中获取的，response是我们包装后的结果，至于怎么包装的还急得吗？
@Override
protected Response<JSONObject> parseNetworkResponse(NetworkResponse response) {
    try {
        String jsonString =
            new String(response.data, HttpHeaderParser.parseCharset(response.headers));
        return Response.success(new JSONObject(jsonString),
                HttpHeaderParser.parseCacheHeaders(response));
    } catch (UnsupportedEncodingException e) {
        return Response.error(new ParseError(e));
    } catch (JSONException je) {
        return Response.error(new ParseError(je));
    }
}
又回来了，终于找到了参数的来源了，好，那我们继续分析代码，在ResponseDeliveryRunnable.run中有这么几行代码，
// Deliver a normal response or error, depending.
if (mResponse.isSuccess()) {
    mRequest.deliverResponse(mResponse.result);
} else {
    mRequest.deliverError(mResponse.error);
}
这里是在UI线程中执行了，利用我们的request去deliverResponse，
@Override
protected void deliverResponse(T response) {
    mListener.onResponse(response);
}
哈哈，终于看见曙光了，只需要关心mListener是不是我们写的那个参数就ok啦，
public JsonRequest(String url, String requestBody, Listener<T> listener,
        ErrorListener errorListener) {
    this(Method.DEPRECATED_GET_OR_POST, url, requestBody, listener, errorListener);
}

public JsonRequest(int method, String url, String requestBody, Listener<T> listener,
        ErrorListener errorListener) {
    super(method, url, errorListener);
    mListener = listener;
    mRequestBody = requestBody;
}
果然是！到现在为止，一个请求如果加入到缓存队列，接着从缓存队列中加入到请求队列，判断该请求是否有对应的本地缓存，包装请求结果，然后各种调用，到最后回调到我们的listener都已经捋清楚了，唯一还没看的就是网络请求部分了，我们继续找mark的地方，
// 这里将结果回调并且又将请求放到请求队列中 mark
// Post the intermediate response back to the user and have
// the delivery then forward the request along to the network.
mDelivery.postResponse(request, response, new Runnable() {
@Override
public void run() {
    try {
        mNetworkQueue.put(request);
    } catch (InterruptedException e) {
        // Not much we can do about this.
    }
}
});
这里执行了那个三个构造的ResponseDeliveryRunnable，mRunnable肯定不为空，所以
// If we have been provided a post-delivery runnable, run it.
if (mRunnable != null) {
    mRunnable.run();
}
得以执行，也就是说我们重新将request加入到了请求队列中，继续看mark的地方， 
NetworkDispatcher.run中，还记得这里干了嘛吗？ 这里是不断从mNetworkQueue队列中获取一个request,并且执行，来看我们mark的地方，
// Perform the network request.
// 通过NetWork.performRequest来真正的请求网络
// 并将分析后的结果封装到networkResponse中返回
// 这里面包含了statusCode，data，headers，notModified
// mark
NetworkResponse networkResponse = mNetwork.performRequest(request);
request.addMarker("network-http-complete");
NetWork是一个接口，我们来看它的实现类——BasicNetwork，也就是我们在刚开始看到new的那个，BasicNetwork.performRequest
@Override
public NetworkResponse performRequest(Request<?> request) throws VolleyError {
    long requestStart = SystemClock.elapsedRealtime();
    while (true) {
        HttpResponse httpResponse = null;
        byte[] responseContents = null;
        Map<String, String> responseHeaders = new HashMap<String, String>();
        try {
            // Gather headers.
            Map<String, String> headers = new HashMap<String, String>();
            // 从Cache中获取header，并添加到Map中
            addCacheHeaders(headers, request.getCacheEntry());
            // 执行网络请求
            httpResponse = mHttpStack.performRequest(request, headers);
            // 获取状态
            StatusLine statusLine = httpResponse.getStatusLine();
            int statusCode = statusLine.getStatusCode();

            // 将header放到上面定义的responseHeaders中
            responseHeaders = convertHeaders(httpResponse.getAllHeaders());
            // Handle cache validation.
            // 内容没有修改
            if (statusCode == HttpStatus.SC_NOT_MODIFIED) {
               // 这里构造了NetworkResponse
                return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED,
                        request.getCacheEntry().data, responseHeaders, true);
            }
            // 将返回的内容转化为byte数组
            responseContents = entityToBytes(httpResponse.getEntity());
            // if the request is slow, log it.
            // 标记访问慢的请求
            long requestLifetime = SystemClock.elapsedRealtime() - requestStart;
            logSlowRequests(requestLifetime, request, responseContents, statusLine);

            if (statusCode != HttpStatus.SC_OK && statusCode != HttpStatus.SC_NO_CONTENT) {
                throw new IOException();
            }
            // 构造NetworkResponse并返回
            // 这里面包含状态吗， 返回的内容， header
            return new NetworkResponse(statusCode, responseContents, responseHeaders, false);
        } catch (SocketTimeoutException e) {
            attemptRetryOnException("socket", request, new TimeoutError());
        } catch (ConnectTimeoutException e) {
            attemptRetryOnException("connection", request, new TimeoutError());
        } catch (MalformedURLException e) {
            throw new RuntimeException("Bad URL " + request.getUrl(), e);
        } catch (IOException e) {
            int statusCode = 0;
            NetworkResponse networkResponse = null;
            if (httpResponse != null) {
                statusCode = httpResponse.getStatusLine().getStatusCode();
            } else {
                throw new NoConnectionError(e);
            }
            VolleyLog.e("Unexpected response code %d for %s", statusCode, request.getUrl());
            if (responseContents != null) {
                networkResponse = new NetworkResponse(statusCode, responseContents,
                        responseHeaders, false);
                if (statusCode == HttpStatus.SC_UNAUTHORIZED ||
                        statusCode == HttpStatus.SC_FORBIDDEN) {
                    attemptRetryOnException("auth",
                            request, new AuthFailureError(networkResponse));
                } else {
                    // TODO: Only throw ServerError for 5xx status codes.
                    throw new ServerError(networkResponse);
                }
            } else {
                throw new NetworkError(networkResponse);
            }
        }
    }
}
基本的流程看我写的注释，重要的看这里的代码，
...
httpResponse = mHttpStack.performRequest(request, headers);
...
还记得HttpStack是什么吗？来回忆一下吧，Volley.newRequestQueue中
...
if (stack == null) {
    if (Build.VERSION.SDK_INT >= 9) {
        stack = new HurlStack();
    } else {
        // Prior to Gingerbread, HttpUrlConnection was unreliable.
        // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
        stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
    }
}
...
通过判断SDK的版本来选择使用HttpUrlConnection还是HttpClient，我们来看看HttpClientStack也就是使用HttpClient怎么实现的，
@Override
public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)
        throws IOException, AuthFailureError {
    // 构造请求方式
    HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);
    // 添加从缓存中获取的header
    addHeaders(httpRequest, additionalHeaders);
    // 添加我们重写getHeaders中自定义的header
    addHeaders(httpRequest, request.getHeaders());
    // nothing
    onPrepareRequest(httpRequest);
    // 获取我们重写的getParams方法中的参数
    HttpParams httpParams = httpRequest.getParams();
    int timeoutMs = request.getTimeoutMs();
    // TODO: Reevaluate this connection timeout based on more wide-scale
    // data collection and possibly different for wifi vs. 3G.
    HttpConnectionParams.setConnectionTimeout(httpParams, 5000);
    HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);
    // 执行网络请求并返回结果
    return mClient.execute(httpRequest);
}
第一行代码createHttpRequest其实就是根据我们使用的请求方式(GET,POST,PUT…)来构造不同的请求类(HttpGet, HttpPost, HttpPut)，接下来是想请求中添加header，添加了两次，第一次是从缓存中获取的header，第二次获取的我们重写getHeaders方法中返回的那个map，接下来onPrepareRequest是一个空方法，继续代码，是调用我们重写getParams获取参数，最后执行HttpClient.execute(HttpUriRequest request)执行网络请求，并返回结果。 
这样我们终于把Volley整个的请求过程走通了，但是还有一个问题？ 我们目前为止看到的RequestQueue和CacheQueue都是空的，并没有往里添加request，那request是什么时候添加的呢？还记得我们怎么往volley添加一个请求吗？
mRequestQueue.add(request);
我们来看看这个add方法，
public Request add(Request request) {
    // Tag the request as belonging to this queue and add it to the set of current requests.
    // 标记这个请求放入了请求队列中
    request.setRequestQueue(this);
    synchronized (mCurrentRequests) {
        mCurrentRequests.add(request);
    }

    // Process requests in the order they are added.
    request.setSequence(getSequenceNumber());
    request.addMarker("add-to-queue");

    // If the request is uncacheable, skip the cache queue and go straight to the network.
    // 如果请求允许缓存，则添加到缓存队列中
    // 并且返回
    if (!request.shouldCache()) {
        mNetworkQueue.add(request);
        return request;
    }

    // Insert request into stage if there's already a request with the same cache key in flight.
    synchronized (mWaitingRequests) {
        String cacheKey = request.getCacheKey();
        // 如果有相同的请求正在等待
        // 将这个请求放到这个具有相同cacheKey的队列中
        // 这个cacheKey其实就是我们访问的url，
        // 也就是具有相同url的请求我们放一块
        if (mWaitingRequests.containsKey(cacheKey)) {
            // There is already a request in flight. Queue up.
            Queue<Request> stagedRequests = mWaitingRequests.get(cacheKey);
            if (stagedRequests == null) {
                stagedRequests = new LinkedList<Request>();
            }
            stagedRequests.add(request);
            mWaitingRequests.put(cacheKey, stagedRequests);
            if (VolleyLog.DEBUG) {
                VolleyLog.v("Request for cacheKey=%s is in flight, putting on hold.", cacheKey);
            }
        } else {
            // Insert 'null' queue for this cacheKey, indicating there is now a request in
            // flight.
            // 如果没有，则添加一个null
            // 并放到cache队列中
            mWaitingRequests.put(cacheKey, null);
            mCacheQueue.add(request);
        }
        return request;
    }
}
为什么要这么麻烦呢？ 好几个队列，有点晕了，我们来看看RequestQueue的finish方法，这个方式是在请求结束后调用的，上面的代码中，很多地方地方都调用了Request.finish(tag)方法，
void finish(final String tag) {
    if (mRequestQueue != null) {
        mRequestQueue.finish(this);
    }
    if (MarkerLog.ENABLED) {
        final long threadId = Thread.currentThread().getId();
        if (Looper.myLooper() != Looper.getMainLooper()) {
            // If we finish marking off of the main thread, we need to
            // actually do it on the main thread to ensure correct ordering.
            Handler mainThread = new Handler(Looper.getMainLooper());
            mainThread.post(new Runnable() {
                @Override
                public void run() {
                    mEventLog.add(tag, threadId);
                    mEventLog.finish(this.toString());
                }
            });
            return;
        }

        mEventLog.add(tag, threadId);
        mEventLog.finish(this.toString());
    } else {
        long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;
        if (requestTime >= SLOW_REQUEST_THRESHOLD_MS) {
            VolleyLog.d("%d ms: %s", requestTime, this.toString());
        }
    }
}
这里面调用了RequestQueue的finish方法，并将当前request对象传递过去，
void finish(Request request) {
    // Remove from the set of requests currently being processed.
    // 从当前将要执行的request队列中移除
    synchronized (mCurrentRequests) {
        mCurrentRequests.remove(request);
    }

    if (request.shouldCache()) {
        synchronized (mWaitingRequests) {
            String cacheKey = request.getCacheKey;
            Queue<Request> waitingRequests = mWaitingRequests.remove(cacheKey);
            if (waitingRequests != null) {
                if (VolleyLog.DEBUG) {
                    VolleyLog.v("Releasing %d waiting requests for cacheKey=%s.",
                            waitingRequests.size(), cacheKey);
                }
                // Process all queued up requests. They won't be considered as in flight, but
                // that's not a problem as the cache has been primed by 'request'.
                mCacheQueue.addAll(waitingRequests);
            }
        }
    }
}
这里面将request从mCurrentRequests中移除，并且判断waitingRequests是否含有该url的请求，如果有，则移除，并且将移除的队列全部放到mCacheQueue,为什么要这么干？还记得我们在CacheDispatcher中那一系列判断吗？如果该请求的url已经缓存很有可能直接将结果回调了。这种做法解决了一个很重要的问题，我们连续访问两次同一个url，真正去访问网络的其实就一个，第二次直接从缓存中获取结果了。 
ok，到目前为止Volley的过程我们就分析完毕了。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

eclipse编译cocos2d-x-3.7.1项目
1.环境配置
在控制台进入D:\Otherlib\cocos2d-x-3.7.1


运行setup.py



确保环境设置正确


2.创建项目

在控制台进入D:\Otherlib\cocos2d-x-3.7.1



创建新工程：cocos new gametest371 -p com.wxh.org -l cpp -d e:/cocostest



参数说明：


gametest：项目名称


 -p：后面接包名


 -l：后面接开发语言类型，有cpp, lua, js三种类型


 -d：后面接项目存放的目录




出现下图说明成功：


        查看e:/cocostest项目路径，你会发现目录中会出现新建的“gametest”项目。依次打开“ gametest/proj.win32 ”文件夹，“ gametest.sln ”解决方案，单击运行项目。
        出现下面的界面则项目创建成功


      (编译完成真的是一个漫长的过程啊！！)

3.生成Android项目文件

记得添加环镜变量
NDK_ROOT 设为你的安装目录




ANDROID_SDK_ROOT 设为你的安装目录


在控制台编译
在新建项目 E:\cocostest\gametest 项目中，执行proj.android下的build_native.py脚本进行编译。
 (接上面的教程)

python build_native.py

(要等好一会儿啊。)


这里编译出来的是
 debug 版

4.导入Android项目

最后便可启动Eclipse然后导入Android项目了。操作步骤如下：

--打开"File"并选择“Import…”
--当出现对话框时，选择“Exsiting
 Android project into workspace”（将现有Android项目导入工作区）。


 点击"finish".
此时项目会报错，因为没有引用Cocos2d-x的库文件

将E:\cocostest\gametest371\cocos2d\cocos\platform\android\java\src目录下文件夹 com，org拷贝到E:\cocostest\gametest371\proj.android\src下
在eclipse工程刷新一下错误消失.



设置为debug模式

打开项目属性
Remove掉报错的库文件路径后

勾选CDT Builder

按照上面的方法导入到Eclipse里面。将您的手机设置成调试模式并用USB线连接到电脑, 在Eclipse中运行test, 然后就能在手机上看到已经运行的gametest了！




﻿﻿
﻿﻿
﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        代理方法- 深入解析
今天结合一个实际的demo 来给大家讲解一下代理方法的运用
首先介绍一下 什么是代理，有什么用

/** 可以提高代买的复用性
 *  代理的作用
    1.封装变化点
    2.解决类与类之间的强耦合性
    3.可以在类之间进行数据传递
 
 什么情况下使用代理好呢
 1.有一系列变化点(比如：UIScrollView 有许多方法，)
    能够让用户清晰的知道到底有哪些变化点被封装起来了
 */
我们在项目开发的过程中会用到很多的代理，block 

两个之间有区别也有联系，代理和block 都可以用来传值
代理实现起来步骤比较多
简单的来说，代理就是委托，比如老板需要做一些事儿，老板不想去做，这时委托员工去做 

那么员工就是老板的代理，员工是被动一方，老板是主动的一方
我们一般会拿协议来规范代理的行为，代理需要遵守协议，当发生委托时，老板就会通知代理去完成
代理可以实现对象之间的相互通信


今天结合UICollectionView 来讲解一下代理的运用 

这个demo是按照mvc 的思想来完成的
我们想生产一个组件来提供给别人使用 

我们需要把自己的组件安装在控制器之中，那么我们需要一个容器来存放这个UICollectionView 

那么我们就提供一个UIVIew 来存放 

新建一个类 继承自UIView 我们将UICollectionView 放在上面 

这里还提供了一个自定义Item(cell) 使用xib 建立的，我们需要将cell 安装在UICollectionView上
自定义Item 有两个小空间 - 一个button 一个Label  

我们想实现 ：当用户点击cell 的button 时 我们把Label 的内容传递给我们 

有两种解决方案：一种是利用用户交互，给cell 绑定事件，我们可以获得cell 的对象 

另一种：设置代理
方法如下：

#import <UIKit/UIKit.h>

@interface QHCollectionView : UIView
+(instancetype)collectionView;
@end

#import "QHCollectionView.h"
#import "QHCollectionCell.h"


@interface QHCollectionView()<UICollectionViewDataSource,UICollectionViewDelegate,UICollectionViewDelegateFlowLayout,QHCollectionCellDelegate>

@property(nonatomic,strong)UICollectionView *collectionView;

@end


@implementation QHCollectionView




+(instancetype)collectionView
{
    return [[self alloc]init];
}

-(instancetype)initWithFrame:(CGRect)frame
{
    if (self = [super initWithFrame:frame]) {
        UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init];
        
        UICollectionView *collectionView  = [[UICollectionView alloc]initWithFrame:CGRectZero collectionViewLayout:layout];
        layout.scrollDirection = UICollectionViewScrollDirectionVertical;
        
        self.collectionView = collectionView;
        
        self.collectionView.delegate = self;
        self.collectionView.dataSource = self;
        
        self.collectionView.pagingEnabled = YES;
        
        self.collectionView.showsHorizontalScrollIndicator = NO;
//        self.collectionView
    }
    return self;
}

#pragma mark UICollectionViewDataSource 协议方法
-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
    return 10;
}
-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView
{
    return 2;
}

-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    //注册机制
    /*
    [collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@"ABC"];
    
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"ABC" forIndexPath:indexPath];
     */
    QHCollectionCell *cell = [QHCollectionCell cellWithCollectionView:collectionView andIndexPath:indexPath];
    
    cell.backgroundColor = [UIColor redColor];
    
    cell.delegate = self;
    return cell;
    
}

- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath
{
    
    NSLog(@"8324823987");
}
-(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
    return CGSizeMake(200, 200);
}

-(void)collectionCellWithBtnClick:(QHCollectionCell *)qhCollection andTextInfo:(NSString *)textInfo
{
     NSLog(@"百度员工号：%@", textInfo);
    NSLog(@"%@",NSStringFromSelector(_cmd));
    
}
-(void)willMoveToSuperview:(UIView *)newSuperview
{
    self.frame = newSuperview.bounds;
    
    self.backgroundColor = [UIColor purpleColor];
    
    self.collectionView.frame = self.frame;
    
    self.collectionView.backgroundColor = [UIColor yellowColor];
    
    
    //建立父子关系 设置frame
    
    [self addSubview:self.collectionView];
    
    //根据父控件设置子控件的frame
}
/*
// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
- (void)drawRect:(CGRect)rect {
    // Drawing code
}
*/

@end

#import <UIKit/UIKit.h>

@class QHCollectionCell;

@protocol QHCollectionCellClickDelegate <NSObject>

-(void)collectionCollectionClellClick:(QHCollectionCell *)qhCollection andCellView:(UIView *)view;

@end

@protocol QHCollectionCellDelegate<NSObject>

-(void)collectionCellWithBtnClick:(QHCollectionCell *)qhCollection andTextInfo:(NSString *)textInfo;

@end

@interface QHCollectionCell : UICollectionViewCell
@property(nonatomic,assign)id <QHCollectionCellDelegate>delegate;
@property(nonatomic,assign)id <QHCollectionCellClickDelegate>delegateC;
+(id)cell;
+(id)cellWithCollectionView:(UICollectionView *)collection andIndexPath:(NSIndexPath *)indexPath;
@end

#import "QHCollectionCell.h"

@interface QHCollectionCell()

@property (weak, nonatomic) IBOutlet UILabel *textLabel;


@end

@implementation QHCollectionCell

+(id)cell
{
    return [[self alloc]init];
}

+(id)cellWithCollectionView:(UICollectionView *)collection andIndexPath:(NSIndexPath *)indexPath
{
    NSString *cellName = NSStringFromClass([self class]);
    
    UINib *nib = [UINib nibWithNibName:cellName bundle:nil];
    
    [collection registerNib:nib forCellWithReuseIdentifier:cellName];
    
    QHCollectionCell * cell = [collection dequeueReusableCellWithReuseIdentifier:cellName forIndexPath:indexPath];
    
   // UITapGestureRecognizer * tgr = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tgrClick:)];
    
   // cell.userInteractionEnabled = YES;
    
   // [cell addGestureRecognizer:tgr];
    
    return cell;
    
}


-(void)tgrClick:(UITapGestureRecognizer *)tgr
{
    NSLog(@"%@",tgr.view);
    
    [_delegateC collectionCollectionClellClick:self andCellView:tgr.view];
    
}

- (IBAction)btnClick:(id)sender {
    
    NSString *textLabelInfo = self.textLabel.text;
    
    //NSLog(@"%@",self.textLabel.text);
    [self.delegate collectionCellWithBtnClick:self andTextInfo:textLabelInfo];
    
    NSLog(@"%@",self.delegate);
    
    NSLog(@"点击");
}

@end








版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 自定义Activity基类
        我们在开发App的时候有时候碰到多个界面有一个共同点的时候，比如，都有相同的TitleBar，并且TitleBar可以设置显示的文字。TitleBar上的点击事件，如果给每一个Activity都写一遍TitleBar是一件非常费事的事情，这个时候我们就可以重写一个Activity基类，让其他有相同点的Activity来继承这个类，从而省去了很多的重复不必要的工作。提高了效率。


如图： 
两个界面拥有共同的特点，有一个我们自己定义的TitleBar，这个TitleBar属于我们自定义的基类BaseActivity，如果我们想让一个类具有这个特性，只需要继承BaseActivity并添加相应的布局即可。事件什么的都写一边就OK了。
  



BaseActivity.java
内部有一个重写的TitleBar控件，封装对应的方法对TitleBar进行操作，该类的事件将会被TitleBa调用，具体调用看TitleBar实现

/**
 * 重写的一个Activity 的基类，在基类中实现了一个TitleBar 用TitleBar来展示一个标题
 * 同时定义一个Back按钮，点击的时候退出当前的Activity
 * 
 * @author mingwei
 * 
 */
public abstract class BaseActivity extends Activity {
	private TitleBar mTitleBar;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		super.onCreate(savedInstanceState);
		setTheme(android.R.style.Theme_Light_NoTitleBar);
	}

	@Override
	public void setContentView(int layoutResID) {
		// TODO Auto-generated method stub
		super.setContentView(layoutResID);
		initBaseView();
	}

	public void initBaseView() {
		mTitleBar = (TitleBar) findViewById(R.id.base_titlebar);
	}

	public void setTitleBarBackText(String text) {
		// mTitleBar.setBackText(text);
	}

	public void setTitleBarTitle(String tite) {
		if (mTitleBar != null) {
			mTitleBar.setTitle(tite);
		}
	}

	public void setTitleBarTitle(int titleId) {
		if (mTitleBar != null) {
			mTitleBar.setTitle(getString(titleId));
		}
	}
	public void setTitleBarTitleDrawable(Drawable drawable){
		if (mTitleBar != null) {
			mTitleBar.setTitleRightDrawable(drawable);
		}
	}
        //返回键事件
	public void finishActivity() {
		finish();
	}

	public void setTitleRTBtnVisiable(int visiable) {
		if (mTitleBar != null) {
			mTitleBar.setRTBtnVisiable(visiable);
		}

	}

	public void setTitleRTBtnText(String text) {
		if (mTitleBar != null) {
			mTitleBar.setRTBtnText(text);
		}
	}

	public void setTitleRTBtnText(int textId) {
		if (mTitleBar != null) {
			mTitleBar.setRTBtnText(getString(textId));
		}
	}

	public void setTitleRTBtnFocusable(boolean focusable) {
		if (mTitleBar != null) {
			mTitleBar.setRTBtnFocusable(focusable);
		}
	}
        //中间的Title点击事件
	public void setCenterClick(boolean bool) {
		mTitleBar.setTitleClick(bool);
	}

	public void onRtBtnClick() {
		// titlebar左上角button的click时间
	}
        
	public void onCenterClick() {
		// titlebar中间的title点击事件

	}

}




我们再来看看TitleBar长啥样子，TitleBar是一个封装的RelativLayout，包括一个返回键，中的Title，右边的按钮
注意：注释1的地方，Activity中的容器或者控件想到调用Activity中的方法或者属性怎么办？
例如，我在点击Back的ImageView时想让Activity finished()掉，只需要我们把容器中得到的Context强转为相应的Activity即可，之后就可以方便的调用Activity的方法了。

/**
 * 基类BaseActivity用到的TitleBar，用来返回页面和展示当前页内容的Title信息
 * 
 * @author mingwei
 * 
 */
public class TitleBar extends RelativeLayout implements OnClickListener {

	private ImageView mBack;
	private TextView mTitle;
	private TextView mRTBtn;
	BaseActivity mContext;

	public TitleBar(Context context) {
		this(context, null);
	}

	public TitleBar(Context context, AttributeSet attrs) {
		super(context, attrs, 0);
	}

	public TitleBar(Context context, AttributeSet attrs, int defStyle) {
		super(context, attrs, defStyle);
		mContext = (BaseActivity) getContext();// <span style="color:#ff0000;">注释1</span>
	}

	/**
	 * 初始化控件
	 */
	@Override
	protected void onFinishInflate() {
		super.onFinishInflate();
		mContext = (BaseActivity) getContext();
		mBack = (ImageView) findViewById(R.id.base_titlebar_back);
		mTitle = (TextView) findViewById(R.id.base_titlebar_title);
		mRTBtn = (TextView) findViewById(R.id.base_titlebar_rtbtn);
		mBack.setOnClickListener(this);
		mTitle.setOnClickListener(this);
		mRTBtn.setOnClickListener(this);
		mTitle.setClickable(false);
	}

	/**
	 * 右边的控件是否可见
	 */
	public void setRTBtnVisiable(int visiable) {
		mRTBtn.setVisibility(visiable);
	}

	/**
	 * 右边控件的文版
	 */
	public void setRTBtnText(String title) {
		mRTBtn.setText(title);
	}

	/**
	 * 右边控件的显示颜色变化
	 */
	public void setRTBtnFocusable(boolean focusable) {
		mRTBtn.setEnabled(focusable);
		if (focusable) {
			mRTBtn.setTextColor(getResources().getColor(R.color.base_rtbtn_clickable_color));
		} else {
			mRTBtn.setTextColor(getResources().getColor(R.color.base_rtbtn_clickunable_color));
		}
	}

	/**
	 * 返回右边控件
	 */
	public TextView getRTBtnTextView() {
		return mRTBtn;
	}

	/**
	 * 中间控件的点击事件
	 */
	public void setTitleClick(boolean bool) {
		mTitle.setClickable(bool);
	}

	/**
	 * 中间控件文本</span>
	 */
	public void setTitle(String title) {
		mTitle.setText(title);
	}

	/**
	 * 中间控件图标</span>
	 */
	public void setCompoundDrawables(Drawable drawable) {
		mTitle.setCompoundDrawables(null, null, drawable, null);
	}

	/**
	 * 中间控件图标</span>
	 */
	public void setTitleRightDrawable(Drawable drawable) {
		mTitle.setCompoundDrawablesWithIntrinsicBounds(null, null, drawable, null);
	}

	/**
	 * 控件的点击情况，分别去调用BaseActivity的方法，
	 * 基类被重写后将在子类中调用这些方法</span>
	 */
	@Override
	public void onClick(View v) {
		switch (v.getId()) {
		case R.id.base_titlebar_back:
			mContext.finishActivity();
			break;
		case R.id.base_titlebar_title:
			mContext.onCenterClick();
			break;
		case R.id.base_titlebar_rtbtn:
			mContext.onRtBtnClick();
			break;
		default:
			break;
		}
	}
}



</pre><p></p><pre>TitleBar用到的布局


<?xml version="1.0" encoding="utf-8"?>
<com.xiaoda.juma001.widget.TitleBar xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="@dimen/base_titlebar_height"
    android:background="@color/base_activity_titlebar_backcolor"
    android:fitsSystemWindows="true" >

    <ImageView
        android:id="@+id/base_titlebar_back"
        android:layout_width="@dimen/base_titlebar_back_width"
        android:layout_height="match_parent"
        android:contentDescription="@string/base_title_back_des"
        android:padding="@dimen/base_activity_titlebar_back_padding"
        android:src="@drawable/base_activity_back_nor" />

    <TextView
        android:id="@+id/base_titlebar_title"
        style="@style/BaseActivityTitlebarTitleStyle"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_alignBaseline="@+id/base_titlebar_back"
        android:layout_alignBottom="@+id/base_titlebar_back"
        android:layout_centerHorizontal="true" />

    <TextView
        android:id="@+id/base_titlebar_rtbtn"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_alignParentRight="true"
        android:layout_centerVertical="true"
        android:layout_marginRight="@dimen/base_titlebar_rtbutton_marginright"
        android:gravity="center"
        android:textColor="@color/base_activity_titlebar_textcolor"
        android:visibility="invisible" />

    <View
        android:layout_width="match_parent"
        android:layout_height="@dimen/base_titlebar_bottom_line_height"
        android:layout_alignParentBottom="true"
        android:background="@color/base_activity_titlebar_bottom_linecolor" />

</com.xiaoda.juma001.widget.TitleBar>




写到这里就写好了，我们来看看如何使用

/**
 * 继承BaseActivity
 * @author mingwei
 *
 */
public class AllPictureActivity extends BaseActivity {
	

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.allpicture_activity);
		setTitleBarTitle(R.string.allpicture_title);
		setTitleRTBtnVisiable(View.VISIBLE);
		setTitleRTBtnText(R.string.allpicture_ok);
		setTitleBarTitleDrawable(getResources().getDrawable(R.drawable.all_picture_more_dropdown));
		setCenterClick(true);
		initView();
	}

	private void initView() {
		
	}

	/**
	 * 中间的TitleBar的点击事件
	 */
	@Override
	public void onCenterClick() {
		super.onCenterClick();
		taggleLayout();
	}

	private void taggleLayout() {
		
	}

	private void changeData(int i) {
		
	}
	/**
	 * 返回按钮点击事件
	 */
	@Override
	public void finishActivity() {
		// TODO Auto-generated method stub
		super.finishActivity();
	}

	/**
	 * 右上角的按钮的点击事件
	 */
	@Override
	public void onRtBtnClick() {
		super.onRtBtnClick();
		
	}

	
	
}



别忘了给Activity布局文件加上TitleBar的文件引用

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <include
        android:id="@id/base_titlebar"
        layout="@layout/base_activity_titlebar" />//TitleBar布局文件

    

        <GridView
            android:id="@+id/allpicture_grid"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:cacheColorHint="@android:color/transparent"
            android:columnWidth="90dip"
            android:gravity="center"
            android:horizontalSpacing="5dip"
            android:listSelector="@android:color/transparent"
            android:numColumns="auto_fit"
            android:stretchMode="columnWidth"
            android:verticalSpacing="5dip" >
        </GridView>

        

</LinearLayout>



ids文件 别忘了把你这些不变的id写到ids文件中去

<?xml version="1.0" encoding="utf-8"?>
<resources>

    <item name="base_titlebar" type="id">base_titlebar</item>

</resources>

实现的界面如下图所示：








版权声明：本文是博主原创文章，你可以在未经博主允许的情况下随便转载。顾明伟 http://blog.csdn.net/u013045971

[置顶]
        Apache 服务器配置
Apache服务器在我们生活中很常用 

今天给大家将一下mac 下apache 服务器的配置
这对程序来说是必备技能之一，如果我们在公司开发都是用的公司的服务器
将自己的代码上传下载 更新以及进行数据请求 和数据访问 

但是当我们回到家中，公司的服务器不能用了，解决方法很简单
那就是我们自己在电脑上配置一个本地的服务器，只要是局域网处在同一个网段的
计算机都可以访问资源，这对办公很有帮助
首先来介绍一下：
apache （Web服务器）

Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。同时Apache音译为阿帕奇，是北美印第安人的一个部落，叫阿帕奇族，在美国的西南部。也是一个基金会的名称、一种武装直升机等等。
详细介绍
       Apache HTTP Server（简称Apache）是Apache软件基金会的一个开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其多平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩展，将Perl/Python等解释器编译到服务器中。[2]
Apache HTTP服务器是一个模块化的服务器，源于NCSAhttpd服务器，经过多次修改，成为世界使用排名第一的Web服务器软件。
它可以运行在几乎所有广泛使用的计算机平台上。
Apache源于NCSAhttpd服务器，经过多次修改，成为世界上最流行的Web服务器软件之一。Apache取自“a patchy server”的读音，意思是充满补丁的服务器，因为它是自由软件，所以不断有人来为它开发新的功能、新的特性、修改原来的缺陷。Apache的特点是简单、速度快、性能稳定，并可做代理服务器来使用。
本来它只用于小型或试验Internet网络，后来逐步扩充到各种Unix系统中，尤其对Linux的支持相当完美。Apache有多种产品，可以支持SSL技术，支持多个虚拟主机。Apache是以进程为基础的结构，进程要比线程消耗更多的系统开支，不太适合于多处理器环境，因此，在一个Apache Web站点扩容时，通常是增加服务器或扩充群集节点而不是增加处理器。到目前为止Apache仍然是世界上用的最多的Web服务器，市场占有率达60%左右。世界上很多著名的网站如Amazon、Yahoo!、W3 Consortium、Financial
 Times等都是Apache的产物，它的成功之处主要在于它的源代码开放、有一支开放的开发队伍、支持跨平台的应用（可以运行在几乎所有的Unix、Windows、Linux系统平台上）以及它的可移植性等方面。
Apache的诞生极富有戏剧性。当NCSAWWW服务器项目停顿后，那些使用NCSAWWW服务器的人们开始交换他们用于该服务器的补丁程序，他们也很快认识到成立管理这些补丁程序的论坛是必要的。就这样，诞生了Apache Group，后来这个团体在NCSA的基础上创建了Apache。
接下来给大家讲解一下配置 

一、我们打开终端 （mac 是源于unix 系统）
我们执行下面命令


二、在浏览器上输入一个ip 地址 127.0.0.1 这个是回环地址 用来测试用的 

可以测试本地网卡是否正常 


大家的电脑上会显示，我的电脑将配置文件中的路径更改了所以看不到 

我们可以思考这个It Works 到底放在哪里呢？
我们可以到这个文件夹里看看 下面有个html 文件 可以打开看一下就在下面

 




三、接下来进入配置文件进行配置
我们进入配置文件
执行下面命令 sudo是以管理员权限运行 

执行这些命令必须获得最高权限

然后运行下面命令：

我们要更改目录：自己新建一个 一般在/Users/ms/ 

自己新建一个目录


四、重启服务器

最后一步：在浏览器再输入127.0.0.1
测试一下
我们可以神奇的发现 




版权声明：本文为博主原创文章，未经博主允许不得转载。

android学习笔记（1）

09：布局
LineaerLayout(线性布局)、RelativeLayout(相对布局)：android:layout_toRightOf,android:layout_alignTop
TableLayout(表格布局)、FrameLayout(帧布局)
常用RelativeLayout(相对布局)、TableLayout(表格布局)
10：测试
在应用配置文件导测试依赖包
<uses-library android:name="android.test.runner" />
<instrumentation android:name="android.test.InstrumentationTestRunner"
  android:targetPackage="cn.itcast.test" android:label="Tests for My App" />
12：文件读写
应用内文件的保存读取
context.openFileOutput(filename, Context.MODE_PRIVATE);//保存
context.openFileInput(filename);//读取
13：文件模式
4种模式
Context.MODE_PRIVATE 覆盖写，私有
Context.MODE_APPEND  追加写，私有
Context.MODE_WORLD_WRITEABLE 可写
Context.MODE_WORLD_READABLE 可读 
Context.MODE_WORLD_READABLE+Context.MODE_WORLD_WRITEABLE 可读写


14：SD卡文件读写
//获取SDCard路径
Environment.getExternalStorageDirectory();
//判断SDCard是否存在，并且可以读写
if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)){}


15：pull解析器解析XML
//读取XML
XmlPullParser pullParser=Xml.newPullParser();
pullParser.setInput(inputStream,"UTF-8");
int event = pullParser.getEventType();
while(event != XmlPullParser.END_DOCUMENT){
switch (event) {
case XmlPullParser.START_DOCUMENT:
persons = new ArrayList<Person>();
break;

case XmlPullParser.START_TAG:
if("person".equals(pullParser.getName())){
int id = new Integer(pullParser.getAttributeValue(0));
person = new Person();
person.setId(id);
}
if("name".equals(pullParser.getName())){
String name = pullParser.nextText();
person.setName(name);
}
if("age".equals(pullParser.getName())){
int age = new Integer(pullParser.nextText());
person.setAge(age);
}
break;

case XmlPullParser.END_TAG:
if("person".equals(pullParser.getName())){
persons.add(person);
person = null;
}
break;
}
event = pullParser.next();
}
//写XML
XmlSerializer serializer = Xml.newSerializer();
serializer.setOutput(out, "UTF-8");
serializer.startDocument("UTF-8", true);
serializer.startTag(null, "persons");
for(Person person : persons){
serializer.startTag(null, "person");
serializer.attribute(null, "id", person.getId().toString());

serializer.startTag(null, "name");
serializer.text(person.getName());
serializer.endTag(null, "name");

serializer.startTag(null, "age");
serializer.text(person.getAge().toString());
serializer.endTag(null, "age");

serializer.endTag(null, "person");
}
serializer.endTag(null, "persons");
serializer.endDocument();
out.flush();
out.close(); 



16.保存用户偏好设置参数
android:numeric="integer"//只能输入整型 
android:onClick="save"//点击事件
save对应activity里的save方法 
public void save(String name, Integer age) {
SharedPreferences preferences = context.getSharedPreferences("itcast", Context.MODE_PRIVATE);
Editor editor = preferences.edit();
editor.putString("name", name);
editor.putInt("age", age);
editor.commit();
}
/**
* 获取各项配置参数
* @return
*/
public Map<String, String> getPreferences(){
Map<String, String> params = new HashMap<String, String>();
SharedPreferences preferences = context.getSharedPreferences("itcast", Context.MODE_PRIVATE);
params.put("name", preferences.getString("name", ""));
params.put("age", String.valueOf(preferences.getInt("age", 0)));
return params;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

【cocos2d-x 3.7 飞机大战】 决战南海I (十一) 关于游戏场景
        这个场景作为弹出场景，主要介绍下游戏。。。还有自己的联系方式(*^__^*) ……
主要使用文本，就一个返回按键的响应函数



//返回按钮
void back(EventKeyboard::KeyCode keyCode, Event* pEvent);



同样要记得在析构函数中移除监听
AboutGame::~AboutGame()
{
	_eventDispatcher->removeEventListenersForTarget(this);
}



文本已在XML文件中生成，直接调用即可

bool AboutGame::init()
{
	if (!Layer::init())
		return false;

	//背景音乐
	CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(true);
	CocosDenshion::SimpleAudioEngine::getInstance()->playBackgroundMusic("sound/BackgroundMusic1.mp3", true);
	
	bool bRect = false;

	do 
	{
		auto size = Director::getInstance()->getWinSize();

		//设置背景图片
		auto m_background = Sprite::createWithSpriteFrameName("backgroundTollgateOne.png");
		m_background->setPosition(Vec2(size.width/2,size.height/2));
		m_background->setAnchorPoint(Vec2(0.5, 0.5));
		this->addChild(m_background);

		//设置监听器
		auto m_listener = EventListenerKeyboard::create();
		m_listener->onKeyReleased = CC_CALLBACK_2(AboutGame::back, this);
		_eventDispatcher->addEventListenerWithSceneGraphPriority(m_listener, this);

		//设置标签 并 获取中文文本
		auto dictionary = Dictionary::createWithContentsOfFile("fonts/AboutMe.xml");

		auto m_label3 = Label::createWithTTF(
			((__String*)(dictionary->objectForKey("Others")))->getCString(),
			"fonts/DFPShaoNvW5-GB.ttf",
			25
			);
		m_label3->setDimensions(size.width / 3 * 2, size.height / 2);
		m_label3->setColor(Color3B(255, 255, 255));
		m_label3->setPosition(Point(size.width / 2, size.height/2));

		this->addChild(m_label3);

		auto m_label1 = Label::createWithTTF(
			((__String*)(dictionary->objectForKey("AboutMe")))->getCString(),
			"fonts/DFPShaoNvW5-GB.ttf",
			35
			);
		m_label1->setColor(Color3B(255, 0, 0));
		m_label1->setPosition(
			Point(size.width/2, size.height-m_label3->getContentSize().height-m_label1->getContentSize().height)
			);
		
		this->addChild(m_label1);

		auto m_label2 = Label::createWithTTF(
			((__String*)(dictionary->objectForKey("QQ")))->getCString(),
			"fonts/DFPShaoNvW5-GB.ttf",
			25
			);
		m_label2->setDimensions(size.width / 3 * 2, size.height / 6);
		m_label2->setColor(Color3B(0, 255, 0));
		m_label2->setPosition(Point(size.width / 2, m_label1->getPositionY() - m_label2->getContentSize().height));

		this->addChild(m_label2);

		bRect = true;
	} while (0);

	return bRect;
}

//返回按钮
void AboutGame::back(EventKeyboard::KeyCode keyCode, Event* pEvent)
{
	if (keyCode == EventKeyboard::KeyCode::KEY_ESCAPE)
	{
		//背景音乐
		CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(true);
		CocosDenshion::SimpleAudioEngine::getInstance()->playBackgroundMusic("sound/game_start.mp3", true);
		Director::getInstance()->popScene();
	}
		
}



版权声明：本文为博主原创文章，未经博主允许不得转载。

Android自定义圆形加载进度条
先看下效果图：






代码有如下，copy进去

资源部分：




如何在布局中显示和隐藏呢？
首先找到你要显示的activity，然后获取要取代的那个view，记得是id形式：

LinearLayout layout= (LinearLayout) findViewById(R.id.splash_relayout);
btn= (Button) findViewById(R.id.btn);
if(layout!=null) {
    mVaryViewHelperController = new VaryViewHelperController(layout);
    toggleShowLoading(true, null);
}else {
    Log.e("yan","22");
}
隐藏：


toggleShowLoading(false,null);


后期会整合到BaseActivity中，方便使用！

版权声明：本文为博主原创文章，未经博主允许不得转载。

CocoaAsyncSocket 文档1：Socket简介
前言

CocoaAsyncSocket是 IOS下广泛应用的Socket三方库，网上相关例子数不胜数，这里我就不直接上代码，本文由B9班的真高兴发表于CSDN博客。另辟一条思路：翻译SocketAsyncSocket的文档 
原文地址：https://github.com/robbiehanson/CocoaAsyncSocket/wiki/Intro
Introduction to Sockets

If you’re a beginner to networking, this is the place to start. Working with a socket can be very different from working with a file, even though the APIs may be similar. A little bit of investment in your knowledge and understanding of networking fundamentals can go a long way. And it can save you a lot of time and frustration in the long run.
We will keep it brief, and will maintain a focus on developers: just what developers need to accomplish their goal, while not skipping important fundamentals that could later cause problems.
介绍套接字

如果你是一个网络方面的新手，这里可以给你做一个入门。使用socket和文件操作有很大的不同，尽管他们的API可能非常相近。对网络原理的知识和理解的一点投入可以在长久的时间内起作用。同时呢在一个很长的时间内可以节省你的时间避免你的挫折。
我们会保证它（介绍）尽量简短，并且焦点主要集中在开发者身上：仅仅是开发者完成他们目标需要的东西，同时不跳过可能导致问题的重要步骤。
Sockets, Ports, and DNS - Oh My!

In networking parlance, a computer is a host for a number of sockets. A socket is one end of a communication channel called a network connection; the other end is another socket. From its own point of view, any socket is the local socket, and the socket at the other end of the connection is the remote socket.
To establish the connection, one of the two sockets must contact the other socket. To make contact the socket must know the other socket’s address. Every socket has an address. The address consists of two parts: the host address and the port number. The host address is the IP address of the computer, and the port number uniquely identifies each socket hosted on the computer.
A computer can have multiple host addresses because it can have multiple networking interfaces. For example, a computer might be equipped with an ethernet card, a modem, a WiFi card, a VPN connection, Bluetooth, etc. And in addition to all this, there is a special interface for connecting to itself (called “loopback” or sometimes “localhost”).
An address such as “google.com” corresponds to a host address, but it is not a host address itself. It is a DNS entry or DNS name, which is converted to a host address by a DNS look-up operation. One can think of DNS like a phone book. If you wanted to call someone, but didn’t know their number, you could lookup their number in the phone book. Their name is matched to a phone number. Similarly, DNS matches a name (such as “google.com”) to an IP address.
套接字，端口，DNS

在网络术语中，计算机可以作为多个套接字的主机。一个Socket是网络连接的通信通道的一端;另一端是另一个Socket。从自己的角度看，任何一个Socket，都是本地Socket，链接另一端的Socket就可以看做远程Socket
要建立连接，两个Socket中必须有一个Socket主动去连接另一个Socket。为了建立连接，Socket必须知道另一个Socket的地址。每个Socket都有一个地址。地址包括两部分：主机地址和端口号。主机地址是计算机的IP地址，端口号唯一的标识了主机上的每个套接字。
一台计算机可以有多个主机地址，因为计算机可以有多个网络接口。例如，计算机可能会配备一个以太网卡，调制解调器，一个WiFi卡，一个VPN连接，蓝牙，等，除此之外，还有连接本身的特殊接口（称为“回环”或“localhost”）。
一个地址像“Google.com”联系到一个主机地址，但是它本身不是一个主机地址。这是一个DNS条目或DNS名称，它是由一个DNS查找操作转换为主机地址。人们可以把DNS想象成一个电话簿。如果你想给某人打电话，又不知道他的电话号码，那么你可以查阅电话薄来找到电话号码。（电话簿中）他们的名字和电话号码相对应。同样，DNS匹配名称（比如：Google.com）和IP地址。
Networking Huh?

The crux of the problem is that the network you’ll be communicating over is unreliable. Perhaps you’re sending data out over the Internet. Maybe it’s going to be sent via WiFi, or some cellular connection. Or maybe it’s going to be sent into space via a satellite. You might not even know.
But let’s assume for a moment that you did know. Let’s assume you knew that all communication was going to take place over regular ethernet, within a closed business network. The communication would be 100% reliable right? Wrong. And I’m not referring to cut wires or power outages either.
All data that gets sent or received gets broken into little packets. These packets then get pumped onto the network, and arrive at routers which have to decide where they go. But during bursts of traffic, a router might get overloaded with packets. Packets are coming in faster than the router can figure out where to route them. What happens? The same thing that happens millions of times a day all over the world: the router starts dropping packets.
In addition to lost packets on the network, the receiving computer might be forced to drop packets too. Perhaps the computer is overloaded, or the receiving application isn’t reading the data from the OS fast enough. There’s also the potential that the packet was corrupted during transmission, perhaps from electrical interference. And all of this is without getting into other issues introduced by things like the WiFi or the Internet.
If you’re new to networking, you might be thinking that it’s a miracle that everything works as well as it does. The fact is, the miracle is derived from the networking protocols that have been perfected over the last several decades, and from the developers that understand them and use them effectively. (That’s you!)
网络 哈哈

关键问题是，你要使用沟通的网络是不可靠的。也许你会通过Internet发送数据。也许会通过WiFi或者蜂窝网络，或者通过卫星发到外太空，你甚至可能不知道。
让我们假定那一刻你知道。让我们假定那一刻所有的通信都发生在一个封闭的以太网。现在通信100%可靠么？当然不是。这里我指的不是剪断电线或着中断电力。
所有发送的数据都被打散成为小的数据包。这些数据包会被注入网络，到达路由器，路由器要决定这些数据包去哪里？在这爆炸性的流量中，数据包可能会让路由器过载。接收数据包的速度要超过路由器分发数据包的速度。会发生什么呢？同样的事情在全世界每天发生数百万次：路由器开始丢包。除了在网络上丢失的数据包，接收计算机可能会被迫弃数据包。也许计算机是超负荷的，或者接收的应用程序，从操作系统中读取数据的速度不够快。在传输过程中，数据包在传输过程中可能会损坏，可能是来自于电气干扰。而这一切都是摒除了诸如WiFi或互联网引入的问题。
如果你是个网络方面的菜鸟，那么你会认为所有事情都正常运行简直是一个奇迹。事实上，奇迹是来自于过去几十年中不断完善的网络协议，和了解它们（网络协议）并有效地使用它们的开发人员。（比如说你）
Bring on the Protocols

You can probably list dozens of protocols that have something to do with computer networking:
HTTP, FTP, XMPP, POP, IMAP, SMTP, DHCP, DNS, VoIP, SIP, RTP, RTCP, …
But every single one of these protocols is layered on top of another protocol that handles the networking for it. These lower level protocols handle the majority of the networking aspect so that the application layer protocol (those listed above) can focus on the application aspect.
The “application layer protocols” listed above are layered on top of a “transport layer protocol”. And of all the protocols listed above, there are only two transport layer protocols that are used: TCP and UDP.
这里是协议

你可能会列出一打和网络有关的协议：HTTP, FTP, XMPP, POP, IMAP, SMTP, DHCP, DNS, VoIP, SIP, RTP, RTCP, … 
但是这些每一个协议都建立在一个为它（这个协议）控制网络的协议之上（每个协议都是上层协议呗）。底层协议解决了大部分网络方面的事情，应用层协议（上面列出的）才可以专注于应用层面。
上面列出的“应用层协议”建立在“传输层协议”之上。以上列出的所有协议，只有两个传输层使用的协议：TCP和UDP。
UDP

The User Datagram Protocol (UDP) is the simpler of the two. You can only put a small amount of data into a UDP packet, and then you send it on its way. And then… that’s it. There is no guarantee that the message will arrive. And if you send multiple packets back-to-back, there is no guarantee that they will arrive in order. Seems pretty unreliable, no? But it’s weakness is also its strength. If you are sending time-sensitive data, such as audio in a VoIP call, then you don’t want your transport protocol wasting time retransmitting lost packets since the lost audio would arrive too late to be played anyway. In fact, streaming audio and video are some of the biggest uses for UDP.
UDP also has an advantage that it doesn’t require a “connection handshake”. Think about it like this: If you were sitting on a train, and you wanted to have a long conversation with the stranger next to you, you would probably start with an introduction. Something like, “Where are you heading? Oh yeah, I’m heading in that direction too. My name’s Robbie, what’s yours?” But if you just wanted to know what the time was, then you could skip the introduction. You wouldn’t be expected to tell the stranger your name. You could just say, “Excuse me, do you have the time?” To which the stranger could quickly respond, and you could both go back to doing whatever you were doing. This is why a protocol like DNS uses UDP. That way your computer can say, “Excuse me, what is the IP of google.com?” And the server can quickly respond.
UDP

用户数据报协议（UDP）是两个协议中简单的。你可以把少量数据放进一个UDP包中，然后把它发送出去。然后……就这样了。你不能保证数据会到达。如果你接连发出多个数据包，你不能保证它们按序到达。这样看起来似乎很不靠谱，不是吗？但是它的缺点同时也是它的优势。如果您发送时间敏感数据，如VoIP呼叫的音频，然后你不想让你的传输协议浪费时间重发丢失的音频帧，因为丢失的音频数据可能远远落后于播放进度。事实上，音频流和视频流大量的使用了UDP。
UDP也有优势，它不需要一个“连接握手”。这样想：如果你坐在火车上，想和邻座的陌生人展开一次长交谈，你可能会以一个自我介绍作为开场。类似于，“你要去哪儿？”哦，太棒了，我也去那个方向。我的名字叫罗宾，你叫啥？但如果你只是想知道时间是什么，那么你可以跳过自我介绍。你不希望陌生人知道你的名字。你可以说：“打扰了，你知道几点了吗？”陌生人可以很快的回答你，然后你就可以做你想做的事去了。这就是为什么DNS使用UDP协议。这就像你的计算机计算机就可以说：“打扰，Google.com的IP是多少？”服务器可以很快的回答你。
TCP

The Transmission Control Protocol (TCP) is probably the protocol you use the most. Whether you’re browsing the web, checking your email, or sending instant messages to friends, you’re probably using TCP.
TCP is designed for “long conversations”. So there is an initial connection handshake, and after that data can flow back and forth for as long as necessary. But the great thing about TCP is that it was designed to make communication reliable in the face of an unreliable network. So it does all kinds of really cool stuff for us. If you send some information over TCP, and part of it gets lost, the protocol will automatically figure out what got lost and resend it. And when you send information, TCP makes sure that information always arrives in the correct order. But wait, there’s more! The protocol will also detect congestion in the network, and automatically scale accordingly so everybody can share.
So there are a lot of great reasons to use TCP, and it fits in nicely with a lot of networking tasks. Plus there is no limit to the amount of data you can send via TCP. It is designed to be an open stream of data flowing in both/either direction. It is simply up to the application layer to determine what that data looks like.
TCP

传输控制协议（TCP）可能是你最经常使用的协议。无论你是浏览网页，查看邮件，或发短信给朋友，你都有可能会使用TCP。
TCP是专为“长对话”设计的。因此，在初始的连接握手之后，只要有必要，就可以相互传输数据。但关于TCP的伟大的，是它设计为在不可靠的网络上实现可靠的通信。所以它对我们来说真的很酷。如果你把一些信息通过TCP发送，信息的一部分丢失了，协议会自动找出丢掉的数据并重新发送。当你发送信息，TCP确保信息总是以正确的顺序到达。等等，不止这些！该协议还将检测网络中的拥塞，并自动缩放，从而使大家可以共享带宽。
所以有很多伟大的原因使用TCP，它适合很多网络任务。再加上可以通过发送TCP的数据没有数量的限制（一种面向流的协议，没有数据边界）。它被设计成双方向传输的数据流。它支持应用层简单的决定数据的样子。
Where do we fit in?

So… UDP and TCP… how do we use them? Is that what the CocoaAsyncSocket libraries provide? Implementations of TCP and UDP? Nope, not quite. As you can imagine, TCP and UDP are used all over the place. So naturally they are provided by the operating system. If you open up your terminal and type “man socket” you can see the low level BSD socket API. The libraries are essentially wrappers that sits on top of low-level socket API’s and provide you, the developer, an easy to use framework in Objective-C.
So CocoaAsyncSocket provides a great API that simplifies networking for you. But networking can still be tricky, so we recommend you read the following before you get started:
General Documentation 
Common Pitfalls 
Another invaluable resource is the CocoaAsyncSocket mailing list.
我们在哪用呢？

所以……TCP和UDP……我们应该怎么使用呢？他们是CocoaAsyncSocket库提供？实现的TCP和UDP？不，确实不是这样。就像你想象的，TCP和UDP可以在所有的地方使用。因此，它们是由操作系统提供的。如果你打开终端输入“man Socket”你可以看到底层的BSD Socket API。库的本质上是封装底层的API，为您（开发者）提供一个易于使用的框架在Objective-C。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
【cocos2d-x 3.7 飞机大战】 决战南海I (十三) 分数场景
        分数场景要用到TableView，这个之前也没用过，主要参考网上的代码。cocos2d-x的功能十分强大，以后还有好多东西要学啊！


分数场景类的.h文件中的内容

class ScoreScene : public Layer, public TableViewDataSource, public TableViewDelegate
{
public:
	ScoreScene();
	~ScoreScene();
public:
	static Scene * createScene();
	bool init();
	CREATE_FUNC(ScoreScene);
public:
	void tableCellTouched(TableView *table, TableViewCell * cell){}; 
	TableViewCell * tableCellAtIndex(TableView * table, ssize_t index);
	Size tableCellSizeForIndex(TableView * table, ssize_t index);
	
	ssize_t numberOfCellsInTableView(TableView * table);
	
	void scrollViewDidScroll(ScrollView *){};
	void scrollViewDidZoom(ScrollView *){};

	//对返回键的响应
	void onKeyReleased(EventKeyboard::KeyCode keyCode, Event * pEvent);
private:
	Size size;


.cpp文件

ScoreScene::ScoreScene()
{
}

ScoreScene::~ScoreScene()
{
	_eventDispatcher->removeEventListenersForTarget(this);
}

Scene * ScoreScene::createScene()
{
	auto scene = Scene::create();
	auto layer = ScoreScene::create();
	scene->addChild(layer);
	return scene;
}

bool ScoreScene::init()
{
	if (!Layer::init())
		return false;

	//背景音乐
	CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(true);
	CocosDenshion::SimpleAudioEngine::getInstance()->playBackgroundMusic("sound/BackgroundMusic2.mp3", true);

	size = Director::getInstance()->getWinSize();

	//添加背景图片
	auto background = Sprite::createWithSpriteFrameName("backgroundTollgateTwo.png");
	background->setPosition(Point(size.width / 2, size.height / 2));
	background->setAnchorPoint(Vec2(0.5, 0.5));
	this->addChild(background);

	//创建tableView并设置一些参数
	auto tableView = TableView::create(this, Size(size.width, size.height*0.8));
	//设置滑动方向
	tableView->setDirection(ScrollView::Direction::VERTICAL);
	//设置TableViewDelegate
	tableView->setDelegate(this);
	//index的大小是从上到下依次增大
	tableView->setVerticalFillOrder(TableView::VerticalFillOrder::TOP_DOWN);
	//用当前的配置刷新cell
	tableView->reloadData();
	this->addChild(tableView);

	//排名
	auto dictionary = Dictionary::createWithContentsOfFile("fonts/AboutMe.xml");

	auto rankNum = Label::createWithTTF(
		((__String*)(dictionary->objectForKey("rankNum")))->getCString(),
		"fonts/DFPShaoNvW5-GB.ttf",
		40);
	rankNum->setColor(Color3B(255, 0, 0));
	rankNum->setPosition(Point(size.width*0.4, size.height*0.9));
	this->addChild(rankNum);

	//得分
	auto rankScore = Label::createWithTTF(
		((__String*)(dictionary->objectForKey("rankScore")))->getCString(),
		"fonts/DFPShaoNvW5-GB.ttf",
		40);
	rankScore->setPosition(Point(size.width*0.8, size.height*0.9));
	rankScore->setColor(Color3B(255, 0, 0));
	this->addChild(rankScore);

	//对返回键的响应
	auto listener = EventListenerKeyboard::create();
	listener->onKeyReleased = CC_CALLBACK_2(ScoreScene::onKeyReleased, this);
	_eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);

	return true;
}

//对返回键的响应
void ScoreScene::onKeyReleased(EventKeyboard::KeyCode keyCode, Event * pEvent)
{
	if (keyCode == EventKeyboard::KeyCode::KEY_ESCAPE)
	{
		//背景音乐
		CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(true);
		CocosDenshion::SimpleAudioEngine::getInstance()->playBackgroundMusic("sound/game_start.mp3", true);

		//场景弹出
		Director::getInstance()->popScene();
	}
		
}

//用来设置每个cell的内容的
TableViewCell * ScoreScene::tableCellAtIndex(TableView * table, ssize_t index)
{
	//设置每条记录前边的文本内容
	auto index_text = __String::createWithFormat("%ld", index + 1);

	TableViewCell * cell = table->dequeueCell();
	if (cell == NULL)
	{
		//创建一个cell
		cell = new TableViewCell();
		cell->autorelease();

		//创建显示排名的文本信息
		auto text = Label::createWithTTF(index_text->getCString(), "fonts/DFPShaoNvW5-GB.ttf", 24);
		text->setTag(1024);
		text->setColor(Color3B(255, 0, 0));
		//文本信息在cell的中间
		text->setPosition(Point(size.width*0.4, size.height*0.025));
		cell->addChild(text);

		//显示用户得分的文本信息
		auto index_score = __String::createWithFormat("%d", index);
		//根据index值获得得分的文本，因为这个时候的score是int型，所以还需要转化一下类型
		int i_score = UserDefault::getInstance()->getIntegerForKey(index_score->getCString());
		auto * str = __String::createWithFormat("%d", i_score);
		auto score = Label::createWithTTF(
			str->getCString(), "fonts/DFPShaoNvW5-GB.ttf", 24);
		score->setTag(2048);
		//设置坐标
		score->setPosition(Point(size.width*0.8, size.height*0.025));
		score->setColor(Color3B(255, 0, 0));
		cell->addChild(score);

	}
	//这里获得的cell是原来的cell，所以原来cell的文本信息等还是原来的，所以要做一些改变
	else
	{
		//通过tag值获得文本，并且改变
		auto text = (Label *)cell->getChildByTag(1024);
		text->setString(index_text->getCString());

		//改变分数
		auto * score = (Label *)cell->getChildByTag(2048);
		auto * index_score = __String::createWithFormat("%d", index);
		
		int i_score = UserDefault::getInstance()->getIntegerForKey(index_score->getCString());
		auto * str = __String::createWithFormat("%d", i_score);
		score->setString(str->getCString());

		if (cell->getChildByTag(100) != NULL)
		{
			Sprite * sprite = (Sprite *)cell->getChildByTag(100);
			sprite->removeFromParentAndCleanup(true);
		}
	}

	if (index == 0 || index == 1 || index == 2)
	{
		Sprite * sprite;
		switch (index)
		{
		case 0:
			sprite = Sprite::createWithSpriteFrameName("gold.png");
			break;
		case 1:
			sprite = Sprite::createWithSpriteFrameName("silvere.png");
			break;
		case 2:
			sprite = Sprite::createWithSpriteFrameName("copper.png");
			break;
		}
		sprite->setPosition(Point(size.width*0.15, size.height*0.025));
		sprite->setTag(100);
		cell->addChild(sprite);
	}

	return cell;
}

//这个函数是用来设置每个cell的大小的
Size ScoreScene::tableCellSizeForIndex(TableView * table, ssize_t index)
{
	return Size(size.width, size.height*0.05);
}

//这个函数是用来设置cell的个数的
ssize_t ScoreScene::numberOfCellsInTableView(TableView * table)
{
	//个数是从XML文件中读取到的，有多少条记录，就设置多少个cell，如果刚开始没有count这个字段，就返回0
	int count = UserDefault::getInstance()->getIntegerForKey("count", 0);

	return count;
}


好了，这个游戏到这里就已经完成啦！再有的就是移植到其它平台了。我是将这个游戏移植到了Android平台。




代码以及资源文件
资源文件




版权声明：本文为博主原创文章，未经博主允许不得转载。

Android基础入门教程——5.1 Fragment基本概述
Android基础入门教程——5.1 Fragment基本概述
标签（空格分隔）： Android基础入门教程

本节引言

好的，在上一章中我们把Android的四大组件Activity，Service，BroadCastReceiver，ContentProvider 
  以及他们之间的纽带：Intent，都撸了一遍，而本章节给大家带来的是一个Fragment(碎片)的东西， 
  本节我们就来介绍这个Fragment的一些基本概念以及用法！ 
  官方文档：Fragment


1.基本概念
1）它是什么鬼，有什么用？

答：Fragment是Android3.0后引入的一个新的API，他出现的初衷是为了适应大屏幕的平板电脑， 
  当然现在他仍然是平板APP UI设计的宠儿，而且我们普通手机开发也会加入这个Fragment， 
  我们可以把他看成一个小型的Activity，又称Activity片段！想想，如果一个很大的界面，我们 
  就一个布局，写起界面来会有多麻烦，而且如果组件多的话是管理起来也很麻烦！而使用Fragment 
  我们可以把屏幕划分成几块，然后进行分组，进行一个模块化的管理！从而可以更加方便的在 
  运行过程中动态地更新Activity的用户界面！另外Fragment并不能单独使用，他需要嵌套在Activity 
  中使用，尽管他拥有自己的生命周期，但是还是会受到宿主Activity的生命周期的影响，比如Activity 
  被destory销毁了，他也会跟着销毁！

下图是文档中给出的一个Fragment分别对应手机与平板间不同情况的处理图：

PS:简单的新闻浏览页面，使用两个Fragment分别显示新闻列表与新闻内容；

2）Fragment的生命周期图


3）核心要点：
下面说下使用Fragment的一些要点：


3.0版本后引入,即minSdk要大于11
Fragment需要嵌套在Activity中使用,当然也可以嵌套到另外一个Fragment中,但这个被嵌套 
  的Fragment也是需要嵌套在Activity中的,间接地说,Fragment还是需要嵌套在Activity中!! 
  受寄主Activity的生命周期影响,当然他也有自己的生命周期!另外不建议在Fragment里面 
  嵌套Fragment因为嵌套在里面的Fragment生命周期不可控!!!
官方文档说创建Fragment时至少需要实现三个方法:onCreate( ),onCreateView( ),OnPause( ); 
  不过貌似只写一个onCreateView也是可以的…
Fragment的生命周期和Activity有点类似:三种状态: 
  Resumed:在允许中的Fragment可见        Paused:所在Activity可见,但是得不到焦点 
  Stoped: 
  ①调用addToBackStack(),Fragment被添加到Bcak栈 
  ②该Activity转向后台,或者该Fragment被替换/删除 
  ps:停止状态的fragment仍然活着(所有状态和成员信息被系统保持着),然而,它对用户 
  不再可见,并且如果activity被干掉,他也会被干掉.



4）Fragment的几个子类：
ps:很多时候我们都是直接重写Fragment,inflate加载布局完成相应业务了,子类用的不多,等需要的 
时候在深入研究!


对话框:DialogFragment 
列表:ListFragment 
选项设置:PreferenceFragment 
WebView界面:WebViewFragment 



5）是用App包下的Fragment还是v4包下的：
问题概述：
相信很多朋友在使用Fragment的时候都会遇到下面这种情况：

那么我们到底是使用android.app下的Fragment还是用的android.support.v4.app包下 
的Fragment呢？

答：其实都可以，前面说过Fragment是Android 3.0(API 11)后引入的，那么如果开发的app需要 
  在3.0以下的版本运行呢?比如还有一点点市场份额的2.3!于是乎,v4包就这样应运而生了, 
  而最低可以兼容到1.6版本！至于使用哪个包看你的需求了,现在3.0下手机市场份额其实已经不多了,随街都是4.0以上的，6.0十月份都出了，你说呢…所以这个时候,你可以直接使用app包下的Fragment 
  然后调用相关的方法，通常都是不会有什么问题的;如果你Fragment用了app包的, 
  FragmentManager和FragmentTransaction都需要是app包的！要么用全部用app,要么全部用v4, 
  不然可是会报错的哦!当然如果你要自己的app对于低版本的手机也兼容的话,那么就可以选择用v4包！

使用v4包下Fragment要注意的地方：


①如果你使用了v4包下的Fragment,那么所在的那个Activity就要继承FragmentActivity哦! 
  案例:今天在xml文件中静态地载入fragment,然后重写了Fragment,但是在加载Activity的时候就报错了， 
  大概的提示就是Fragment错误还是找不到什么的,name属性改了几次还是错!最后才发现是用了 
  v4的包的缘故,只需让自己的Activity改成FragmentActivity即可!
②之前写了下面这段代码，然后报错： 
 
  有点莫名其妙啊,Fragment,FragmentManager,FragmentTransaction都是用的v4包啊, 
  Activity也是继承FragmentActivity的啊?都改成app包就可以了,但是这不和我们用v4包的 
  前提冲突了么?其实也是有解决方法的哈? 
  答:只需要把getFragmentManager( )改成getSupportFragmentManager( )就可以了



2.创建一个Fragment
1）静态加载Fragment
实现流程：

示例代码：
Step 1:定义Fragment的布局，就是fragment显示内容的 
Step 2:自定义一个Fragment类,需要继承Fragment或者他的子类,重写onCreateView()方法 
在该方法中调用:inflater.inflate()方法加载Fragment的布局文件,接着返回加载的view对象
public class Fragmentone extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment1, container,false);
        return view;
    }   
}
Step 3:在需要加载Fragment的Activity对应的布局文件中添加fragment的标签， 
记住，name属性是全限定类名哦，就是要包含Fragment的包名，如:
    <fragment
        android:id="@+id/fragment1"
        android:name="com.jay.example.fragmentdemo.Fragmentone"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />
Step 4: Activity在onCreate( )方法中调用setContentView()加载布局文件即可!

2）动态加载Fragment
实现流程：

示例代码： 
这里演示的是，当横竖屏切换的时候地切换Fragment：

Fragment以及布局代码就不贴出来了，直接贴MainActivity的关键代码：
public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Display dis = getWindowManager().getDefaultDisplay();
        if(dis.getWidth() > dis.getHeight())
        {
            Fragment1 f1 = new Fragment1();
            getFragmentManager().beginTransaction().replace(R.id.LinearLayout1, f1).commit();
        }

        else
        {
            Fragment2 f2 = new Fragment2();
            getFragmentManager().beginTransaction().replace(R.id.LinearLayout1, f2).commit();
        }
    }   
}

3.Fragment管理与Fragment事务


4.Fragment与Activity的交互

可能有的朋友不喜欢看图，接下来用文字介绍下吧：
1）组件获取
Fragment获得Activity中的组件: getActivity().findViewById(R.id.list)； 
Activity获得Fragment中的组件(根据id和tag都可以)：getFragmentManager.findFragmentByid(R.id.fragment1); 

2）数据传递
①Activit传递数据给Fragment: 

在Activity中创建Bundle数据包,调用Fragment实例的setArguments(bundle) 
  从而将Bundle数据包传给Fragment,然后Fragment中调用getArguments获得 
  Bundle对象,然后进行解析就可以了

②Fragment传递数据给Activity

在Fragment中定义一个内部回调接口,再让包含该Fragment的Activity实现该回调接口, 
  Fragment就可以通过回调接口传数据了,回调,相信很多人都知道是什么玩意,但是 
  写不出来啊,网上的一百度”fragment传数据给Activity”,全是李刚老师的那个代码,真心无语 
  算了,这里就写下局部代码吧,相信读者一看就懂的了:

Step 1:定义一个回调接口:(Fragment中)
 /*接口*/  
    public interface CallBack{  
        /*定义一个获取信息的方法*/  
        public void getResult(String result);  
    }  
Step 2：接口回调（Fragment中）
/*接口回调*/  
    public void getData(CallBack callBack){  
        /*获取文本框的信息,当然你也可以传其他类型的参数,看需求咯*/  
        String msg = editText.getText().toString();  
        callBack.getResult(msg);  
    }  
Step 3:使用接口回调方法读数据(Activity中)
/* 使用接口回调的方法获取数据 */  
leftFragment.getData(new CallBack() {  
 @Override  
       public void getResult(String result) {              /*打印信息*/  
            Toast.makeText(MainActivity.this, "-->>" + result, 1).show();  
            }
        });  
总结下方法： 
->在Fragment定义一个接口,接口中定义抽象方法,你要传什么类型的数据参数就设置为什么类型; 
->接着还有写一个调用接口中的抽象方法,把要传递的数据传过去 
->再接着就是Activity了,调用Fragment提供的那个方法,然后重写抽象方法的时候进行数据 
的读取就可以了!!!
③Fragment与Fragment之间的数据互传

其实这很简单,找到要接受数据的fragment对象,直接调用setArguments传数据进去就可以了 
  通常的话是replace时,即fragment跳转的时候传数据的,那么只需要在初始化要跳转的Fragment 
  后调用他的setArguments方法传入数据即可! 
  如果是两个Fragment需要即时传数据,而非跳转的话,就需要先在Activity获得f1传过来的数据, 
  再传到f2了,就是以Activity为媒介~

示例代码如下：
FragmentManager fManager = getSupportFragmentManager( );
FragmentTransaction fTransaction = fManager.beginTransaction();
Fragmentthree t1 = new Fragmentthree();
Fragmenttwo t2 = new Fragmenttwo();
Bundle bundle = new Bundle();
bundle.putString("key",id);
t2.setArguments(bundle); 
fTransaction.add(R.id.fragmentRoot, t2, "~~~");  
fTransaction.addToBackStack(t1);  
fTransaction.commit();  

5.走一次生命周期图：
思前想后还是决定要带大家简单的走一趟生命周期图，加深大家对Fragment生命周期的理解：

①Activity加载Fragment的时候,依次调用下面的方法: 
onAttach ->  onCreate -> onCreateView -> onActivityCreated -> onStart ->onResume
②当我们弄出一个悬浮的对话框风格的Activity,或者其他,就是让Fragment所在的Activity可见,但不获得焦点 
onPause
③当对话框关闭,Activity又获得了焦点: 
onResume
④当我们替换Fragment,并调用addToBackStack()将他添加到Back栈中 
onPause -> onStop -> onDestoryView 
  ！！注意,此时的Fragment还没有被销毁哦!!!
⑤当我们按下键盘的回退键，Fragment会再次显示出来: 
onCreateView -> onActivityCreated -> onStart -> onResume
⑥如果我们替换后,在事务commit之前没有调用addToBackStack()方法将 
  Fragment添加到back栈中的话;又或者退出了Activity的话,那么Fragment将会被完全结束, 
  Fragment会进入销毁状态 
onPause -> onStop -> onDestoryView -> onDestory -> onDetach


本节小结：

本节跟大家讲解了以下Fragment一些基本的概念以及简单的用法，相信大家会慢慢喜欢上 
  Fragment的，因为篇幅的关系，本节就写这么多，下一节我们带大家来写一些关于Fragment 
  的常用实例，敬请期待，谢谢~


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 获取手机设备等的信息
获取手机设备型号等信息：
如图华为P6手机获取是手机设备信息值：


代码如下：
                tvStr = (TextView) findViewById(R.id.tv_titlebar);

		String phoneInfo = "Product: " + android.os.Build.PRODUCT + "\n";
		phoneInfo += "CPU_ABI: " + android.os.Build.CPU_ABI + "\n";
		phoneInfo += "TAGS: " + android.os.Build.TAGS + "\n";
		phoneInfo += "VERSION_CODES.BASE: "
				+ android.os.Build.VERSION_CODES.BASE + "\n";
		phoneInfo += "MODEL: " + android.os.Build.MODEL + "\n";
		phoneInfo += "SDK: " + android.os.Build.VERSION.SDK + "\n";
		phoneInfo += "VERSION.RELEASE: " + android.os.Build.VERSION.RELEASE
				+ "\n";
		phoneInfo += "DEVICE: " + android.os.Build.DEVICE + "\n";
		phoneInfo += "DISPLAY: " + android.os.Build.DISPLAY + "\n";
		phoneInfo += "BRAND: " + android.os.Build.BRAND + "\n";
		phoneInfo += "BOARD: " + android.os.Build.BOARD + "\n";
		phoneInfo += "FINGERPRINT: " + android.os.Build.FINGERPRINT + "\n";
		phoneInfo += "ID: " + android.os.Build.ID + "\n";
		phoneInfo += "MANUFACTURER: " + android.os.Build.MANUFACTURER + "\n";
		phoneInfo += "USER: " + android.os.Build.USER + "\n";

		// 这种方式在service中无法使用，
		DisplayMetrics dm = new DisplayMetrics();
		getWindowManager().getDefaultDisplay().getMetrics(dm);
		int width = dm.widthPixels; // 宽
		int height = dm.heightPixels; // 高

		//在service中也能得到高和宽
		// WindowManager mWindowManager = (WindowManager)
		// getSystemService(Context.WINDOW_SERVICE);
		// width = mWindowManager.getDefaultDisplay().getWidth();
		// height = mWindowManager.getDefaultDisplay().getHeight();

		phoneInfo += "width: " + width + "\n";
		phoneInfo += "height: " + height;
		
		tvStr.setText(phoneInfo);




版权声明：本文为博主原创文章，未经博主允许不得转载。

Core Data 的简单使用
认识cocoa Data在ios开发中的环境情况。





Core Data简单使用的例子，可以使用模板中的master—detail 这样的控制器组合能够轻松完成。

基本的目录框架：



相应的Core Data中的基本对象都会自动生成。


masterController.md的代码：



//
//  MasterViewController.m
//  Tasks
//
//  Created by 朱敏 on 15/8/24.
//  Copyright (c) 2015年 helinyu. All rights reserved.
//

#import "MasterViewController.h"
#import "DetailViewController.h"
#import "TaskEntryViewController.h"

@interface MasterViewController ()

@end

@implementation MasterViewController

- (void)awakeFromNib {
    [super awakeFromNib];
}

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    self.navigationItem.leftBarButtonItem = self.editButtonItem;

    UIBarButtonItem *addButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:self action:@selector(insertNewObject:)];
    self.navigationItem.rightBarButtonItem = addButton;
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

- (void)insertNewObject:(id)sender {
    
    TaskEntryViewController *tevc = [[TaskEntryViewController alloc]init];
    tevc.managedObjectContext = self.managedObjectContext;
    
    [self presentViewController:tevc animated:YES completion:nil];
//    NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
//    NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
//    NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];
//        
//    // If appropriate, configure the new managed object.
//    // Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
//    [newManagedObject setValue:[NSDate date] forKey:@"timeStamp"];
//        
//    // Save the context.
//    NSError *error = nil;
//    if (![context save:&error]) {
//        // Replace this implementation with code to handle the error appropriately.
//        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
//        NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
//        abort();
//    }
}

#pragma mark - Segues

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    if ([[segue identifier] isEqualToString:@"showDetail"]) {
        NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
        NSManagedObject *object = [[self fetchedResultsController] objectAtIndexPath:indexPath];
        [[segue destinationViewController] setDetailItem:object];
    }
}

#pragma mark - Table View

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return [[self.fetchedResultsController sections] count];
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    id <NSFetchedResultsSectionInfo> sectionInfo = [self.fetchedResultsController sections][section];
    return [sectionInfo numberOfObjects];
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"Cell" forIndexPath:indexPath];
    [self configureCell:cell atIndexPath:indexPath];
    return cell;
}

- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {
    // Return NO if you do not want the specified item to be editable.
    return YES;
}

- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
    if (editingStyle == UITableViewCellEditingStyleDelete) {
        NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
        [context deleteObject:[self.fetchedResultsController objectAtIndexPath:indexPath]];
            
        NSError *error = nil;
        if (![context save:&error]) {
            // Replace this implementation with code to handle the error appropriately.
            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
            abort();
        }
    }
}

- (void)configureCell:(UITableViewCell *)cell atIndexPath:(NSIndexPath *)indexPath {
    
    NSManagedObject *object = [self.fetchedResultsController objectAtIndexPath:indexPath];

    cell.textLabel.text = [[object valueForKey:@"taskText"] description];
    cell.detailTextLabel.text = [[object valueForKey:@"timeStamp"] description];
}

#pragma mark - Fetched results controller

- (NSFetchedResultsController *)fetchedResultsController
{
    if (_fetchedResultsController != nil) {
        return _fetchedResultsController;
    }
    
    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
    // Edit the entity name as appropriate.
//    NSEntityDescription *entity = [NSEntityDescription entityForName:@"Event" inManagedObjectContext:self.managedObjectContext];
    
    NSEntityDescription *entity = [NSEntityDescription entityForName:@"Task" inManagedObjectContext:self.managedObjectContext];
    
    [fetchRequest setEntity:entity];
    
    // Set the batch size to a suitable number.
    [fetchRequest setFetchBatchSize:20];
    
    // Edit the sort key as appropriate.
    NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"timeStamp" ascending:NO];
    NSArray *sortDescriptors = @[sortDescriptor];
    
    [fetchRequest setSortDescriptors:sortDescriptors];
    
    // Edit the section name key path and cache name if appropriate.
    // nil for section name key path means "no sections".
    NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:nil cacheName:@"Master"];
    aFetchedResultsController.delegate = self;
    self.fetchedResultsController = aFetchedResultsController;
    
	NSError *error = nil;
	if (![self.fetchedResultsController performFetch:&error]) {
	     // Replace this implementation with code to handle the error appropriately.
	     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
	    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
	    abort();
	}
    
    return _fetchedResultsController;
}    

#pragma mark NSFetchedResultsControllerDelegate

- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller
{
    [self.tableView beginUpdates];
}

- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id <NSFetchedResultsSectionInfo>)sectionInfo
           atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type
{
    switch(type) {
        case NSFetchedResultsChangeInsert:
            [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
            break;
            
        case NSFetchedResultsChangeDelete:
            [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
            break;
            
        default:
            return;
    }
}

- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject
       atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type
      newIndexPath:(NSIndexPath *)newIndexPath
{
    UITableView *tableView = self.tableView;
    
    switch(type) {
        case NSFetchedResultsChangeInsert:
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
            break;
            
        case NSFetchedResultsChangeDelete:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
            break;
            
        case NSFetchedResultsChangeUpdate:
            [self configureCell:[tableView cellForRowAtIndexPath:indexPath] atIndexPath:indexPath];
            break;
            
        case NSFetchedResultsChangeMove:
            [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
            [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
            break;
    }
}

- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
    [self.tableView endUpdates];
}

/*
// Implementing the above methods to update the table view in response to individual changes may have performance implications if a large number of changes are made simultaneously. If this proves to be an issue, you can instead just implement controllerDidChangeContent: which notifies the delegate that all section and object changes have been processed. 
 
 - (void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
    // In the simplest, most efficient, case, reload the table view.
    [self.tableView reloadData];
}
 */

@end

detail中的代码没有什么修改，创建之后就可以生成，这个我们就不管了



TaskEntryViewController.m文件的代码：

//
//  TaskEntryViewController.m
//  Tasks
//
//  Created by 朱敏 on 15/8/24.
//  Copyright (c) 2015年 helinyu. All rights reserved.
//

#import "TaskEntryViewController.h"

@interface TaskEntryViewController ()

@end

@implementation TaskEntryViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    
//    NSSet 
    self.tf = [[UITextField alloc]initWithFrame:CGRectMake(65, 20, 200, 20)];
    [self.tf setBackgroundColor:[UIColor lightGrayColor]];
    [self.tf setDelegate:self ];
    [self.view addSubview:self.tf];
    
    UILabel *lb1 = [[UILabel alloc]initWithFrame:CGRectMake(5, 20, 60, 20)];
    [lb1 setText:@"Task"];
    
    [self.view addSubview:lb1];
}

- (BOOL)textFieldShouldReturn:(UITextField *)textField
{
    NSManagedObjectContext *context = self.managedObjectContext;
    NSEntityDescription *entity = [NSEntityDescription entityForName:@"Task" inManagedObjectContext:context];
    NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];
    
    [newManagedObject setValue:[NSDate date] forKey:@"timeStamp"];
    [newManagedObject setValue:[self.tf text] forKey:@"taskText"];
    
    NSError *error = nil;
    
    if (![context save:&error]) {
        NSLog(@"Unresolved error %@,%@",error,[error userInfo]);
        abort();
    }
    
    [self dismissViewControllerAnimated:YES completion:nil];
    
    return YES;
}

@end

相应的storyBoard的改变的界面：






上面运行就可以成功了。















版权声明：本文为博主原创文章，未经博主允许不得转载。

最老程序员创业开发实训2---采用MVC架构的应用Splash页面实现
在基本所有的应用中，一点应用图标，都会弹出一个Splash页面，显示几秒钟，然后再进入到程序的主页面中（如果是用户第一次使用，会进入一个新手引导系列页面，介绍产品的主要功能）。今天我们就来开发这个页面。
这个页面是几乎所有应用都会用到的页面，所以我们希望在多个应用中重用，怎么来实现呢？在Android中，我们可以将这个页面做成一个工程项目，所有其他应用项目，都引用这个工程项目，就可以直接使用这个Splash页面的实现了。
我们先建立一个普通的Android工程（我们在调通这个功能之后，我们会将其改为Library工程），工程名字叫WkyLib，最低Android SDK版本选为4.0（因为其他版本市场占有率太低了，没必要再支持了），主题Theme选择为None。如下图所示：


新建工程的其他步聚都比较简单，这里就不再列出了。
由于我们还需要每个Activity处理因为模型类数据改变所产生的事件，因此我们需要定义工程中Activity基类WkyActivity，其继承Activity，在该类中主要是获取Handler实例，另外就是将Activity设置为不显示TitleBar，但是保留显示屏幕上方的状态条。代码如下所示：

public class WkyActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE); // 不显示TitleBar
        // 连屏幕上的状态栏也不显示
        //getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
        // 在manifest文件中对每个activity android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
        handler = new Handler();
    }
    
    protected Handler handler = null;
}注意：实现Activity全屏显示的方法有两种，一种是如上面的代码所示，另一种方式是设置Manifest文件中每个Activity的属性android:theme="@android:style/Theme.NoTitleBar.Fullscreen"，两种方法的效果是一样的。

下面来设计Splash屏幕的基类SplashWkyActivity，其用于实现应用启动前先显示几秒钟某个页面，然后再进入程序的主页面。在每个具体的应用程序中，需要引用本库工程并继承此类，实现本功能。
先在res/values/strings.xml文件中定义界面中需要的字符串：

    <!-- Splash页面 -->
    <string name="copy_right">©2014随诊医生</string>
    <string name="splash_image_desc">程序加载图片</string>然后定义界面的布局文件，在上篇文章的我们知道，Android的布局文件大致相当于MVC中的视图（View），具体内容如下：


<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <LinearLayout
        android:layout_centerInParent="true"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" >

        <ImageView
            android:id="@+id/lib_splashImage"
            android:contentDescription="@string/splash_image_desc"
            android:scaleType="fitXY"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:src="@drawable/app_splash" />
    </LinearLayout>
    
     <TextView
        android:visibility="gone"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_centerHorizontal="true"
        android:layout_marginBottom="30dp"
        android:text="@string/copy_right"
        android:textColor="#ff6E6E6E"
        android:textSize="15sp" />

</RelativeLayout>这个界面比较简单，只有一个应用启动图片和在下部的版权信息，整体部局采用相对布局。

下面是SplashWkyActivity类的定义：

public class SplashWkyActivity extends WkyActivity {
	public SplashWkyActivity() {
		startMainActivityTask = new Runnable() {
			@Override
			public void run() {
				Intent intent = new Intent(SplashWkyActivity.this, MainActivity.class);
				startActivity(intent);
				finish();
			}			
		};
	}
	
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_splash);
        getControls();
        setupEventHandlers();
        // 显示指定时间后，转入主页面
        handler.postDelayed(startMainActivityTask, SPLAY_STAY_TIME);
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {        
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();
        if (id == R.id.action_settings) {
            return true;
        }
        return super.onOptionsItemSelected(item);
    }
    
    public final static long SPLAY_STAY_TIME = 1000; // 为1秒钟
    
    
    /**
     * 取出界面中所有可操作的控件，与IOS中的IOutlets定义类似
     * 【闫涛 2015.08.25】初始版本
     */
    protected void getControls() {
    	splashImgv = (ImageView)findViewById(R.id.lib_splashImage);
    }
    
    /**
     * 为界面上控件绑定事件处理函数，与IOS中的IAction设置类似
     * 【闫涛2015.08.25】初始版本
     */
    protected void setupEventHandlers() {
    }
    
    protected Runnable startMainActivityTask = null;
    
    private ImageView splashImgv = null;

}


在上面的代码中，在onCreate里首先调用基类进行初始化，然后调用getControls方法取得界面上所有控件的实例，这样就可以在Activity里操纵各个控件了。在上一篇文章中，当界面产生用户交互事件后，需要通过Activity来处理，在Android中采用的是事件监听者模式，而setupEventHandler方法就是设置界面上产生的各种事件的处理函数。而在后面的课程中，我们可以看到，实际上IOS的处理与此类似。
我们在Manifest文件中加入SplashWkyActivity并设置其为启动Activity，如下所示：

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.weikangyun.wkylib"
    android:versionCode="1"
    android:versionName="1.0" >

    <uses-sdk
        android:minSdkVersion="14"
        android:targetSdkVersion="19" />

    <application
        android:allowBackup="true"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme" >
        <activity
            android:name="com.weikangyun.wkylib.controller.SplashWkyActivity"
            android:screenOrientation="portrait"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <!-- 程序主界面 -->
        <activity
            android:name="com.weikangyun.wkylib.MainActivity"
            android:launchMode="singleTask"
            android:screenOrientation="portrait" >
        </activity>
    </application>

</manifest>完成上述所有工作后，运行该程序，如果顺利的话，会看到一个带有Splash屏幕的应用就这样生成了。

好了，目前这个工程的所有工作已经基本完成，我们选中这个工程，点击右键，选择属性=》Android，将IsLibrary勾选上，这样一个基础的库就形成了，以后再开发具体应用时，我们就可以直接引用这个工程，就拥有了Splash屏幕的功能了。
在下一节中，我们将利用这个库工程，做出一个具体的应用，我们要做的应用叫维康基因，分为基因师版、医生版、大众版，这三个应用中，很多功能是重复的，因此我们可以把重复的功能写到WkyLib库工程中，这样就实现了代码重用。


华丽的分隔线
******************************************************************************************************************************************************************************


希望大家多支持，有大家的支持，我才能走得更远，谢谢！

银行账号：622202 0200 1078 56128 闫涛

我的支付宝：yt7589@hotmail.com











版权声明：本文为博主原创文章，未经博主允许不得转载。

【IOS】高仿网易4.0新UI框架

高仿网易4.0新UI框架
新的抽屉效果，修改于SliderViewController，首页滑动导航菜单随scrollView
 的滑动变化效果。



下载地址：http://www.devstore.cn/code/info/500.html



运行截图：



 





IOS热门源码下载：
模仿手机支付宝界面

高仿网易4.0新UI框架

实现功能比较齐全的 UITextField 











版权声明：本文为博主原创文章，未经博主允许不得转载。

Android studio最新版持续更新中
2015.8.21 谷歌更新了Android studio 到1.3.2 以及1.4预览版sdk更新到6.0，因为谷歌官网国内被墙，楼主在此给那些不同翻墙的提供下载链接。


链接：http://pan.baidu.com/s/1sj1JUHZ 密码：nu3a


版权声明：本文为博主原创文章，未经博主允许不得转载。

ARC之解决对象之间的循环强引用（Swift）


直接上代码，具体看代码中的注释

//
//  ViewController.swift
//  Refrence
//
//  Created by Mac on 8/24/15.
//  Copyright © 2015 fevershen. All rights reserved.
//

import UIKit

class ViewController: UIViewController {
    
    // 解决对象之间的循环强引用造成的内存泄漏
    
    // 1.弱引用， 2.无主引用， 3.无主引用以及显示展开(隐式解析)的可选属性
    override func viewDidLoad() {
        super.viewDidLoad()
        
//        var john: Person
//        var number73: Apartment
//        john = Person(name: "John Appleseed")
//        number73 = Apartment(number: 73)
//        john.apartment = number73
//        number73.tenant = john
//        
        
//        var lina: Customer?
//        lina = Customer(name: "Lina Appleseed")
//        lina!.card = CreditCard(number: 1234_5678_9012_3456, customer: lina!)
        
        let country = Country(name: "Canada", captialName: "Ottawa")
        print("\(country.name)'s capital city is called \(country.capitalCity.name)")

        
        // 可选类型并不会自动初始化为 nil， 因此，使用前必须赋值
        let str: String? = nil
        if (str != nil) {
            print("===" + str!)
        } else {
            print("---")
        }
        
    }
    
    // 1.
    // 人和公寓的关系都是可选的， 这里用 weak 就可以了
    class Person {
        var name: String
        init (name: String) {
            self.name = name
            print("\(name) init")

        }
        var apartment: Apartment?
        deinit {
            print("\(name) deinit")
        }
    }
    
    class Apartment {
        let number: Int
        init (number: Int) {
            self.number = number
            print("Apartment \(number) init")

        }
        
        // 都不加 weak 将形成循环强引用，两个都不能被析构
        weak var tenant: Person?
        deinit {
            print("Apartment \(number) deinit")
        }
    }


    // 2.
    // 客户的信用卡是可选的，但是信用卡必须要有客户（非可选），因此这里要用到 unowner
    class Customer {
        let name: String
        var card: CreditCard?
        init(name: String) {
            self.name = name
            print("Customer \(name) init")
        }
        deinit {
            print("Customer \(name) deinit")
        }
    }
    
    class CreditCard {
        let number: Int
        
        // 卡必须有主人， 无主引用是永远有值的
        unowned let customer: Customer
        init(number: Int, customer: Customer) {
            self.number = number
            self.customer = customer
            print("CreditCard #\(number) init")

        }
        deinit {
            print("CreditCard #\(number) deinit")
        }
    }
    
    // 3.
    class Country {
        let name: String
        
        // 可选类型并不会自动初始化为 nil， 因此，使用前必须赋值
        // 这里的意义在于通过一条语句同时创建两个实例
        var capitalCity: City! = nil
        init(name: String, captialName: String) {
            print("Country is initing")
            self.name = name
            
            // 下面这条语句是将 Country 的实例做为参数传递给 City 来创建 City 的实例，表面上看 Country 本身还没有实例完成，实际上由于该类中 City 的属性为加 ! 的方式，因此，一旦 Country 的实例在构造函数中给 name 属性赋值，整个初始化过程就完成了，下面的打印信息为虚的
            self.capitalCity = City(name: captialName, country: self)
            print("Country is inited")
        }
        deinit {
            print("Country is deinited")
        }
    }
    
    class City {
        let name: String
        unowned let country: Country
        init(name: String, country: Country) {
            print("City is initing")
            self.name = name
            self.country = country
            print("City is inited")
        }
        deinit {
            print("City is deinited")
        }
    }
}


3.打印结果：


Country is initing

City is initing

City is inited

Country is inited

Canada's capital city is called Ottawa

---

Country is deinited

City is deinited





版权声明：本文为博主原创文章，未经博主允许不得转载。

怎么查看eclipse的workspace的路径
下面有几种方法可以更改workspace的目录。  
1、进入 Window > Preferences > General > Startup and Shutdown 选中 Prompt for workspace on startup。 
2、进入Eclipse的安装目录，找到configuration 目录下的 .settings 文件夹，里面有一个 org.eclipse.ui.ide.prefs， 用Ultra Edit等打开，也可以用写字板打开，找到RECENT_WORKSPACES，按照它的格式修改一下。 
3、先打开Eclipse，进入之后，再去打开一次，会提示 Workspace in use or cannot be created, choose a different one 。 这时候就会提示你更改workspace的目录了。 这三种方法都可以更改，选一种适合的就可以。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请标明出处。

微信公共号开发者中心（JAVA）【token失败解决办法】
在开发微信公共平台一些新手通常都会遇到的问题（ps：我就是那个新手）
我这里只讲自己遇到的问题，遇到了token失败的问题，首先查阅资料，详细了解各个字段的具体含义，并验证代码sha1验证是否正确。看看失败的原因，根据文档提示，2个字符串如果不匹配的话，肯定是验证失败了，根据我个人想法，我是来把加密后的字符串，微信发送的字符串（signature），提取出来，来比对判断到底是哪里错了。
我这里用的一个很蠢的办法，就是在H盘里面生成一个，文件，文件名分别是2个字符串。【或者写入txt文档】（如果有更好的方法回复下哦，一起学习）
代码：<span style="white-space:pre">		</span>String path = "h:";
		File f = new File(path);
		if(!f.exists()){
		f.mkdirs();
		} 
		// fileName表示你创建的文件名；为txt类型；
		String fileName = <span style="font-family: Arial, Helvetica, sans-serif; font-size: 12px;">fileName</span><span style="font-size: 12px; font-family: Arial, Helvetica, sans-serif;">;</span>
		File filee = new File(f,fileName);
		if(!filee.exists()){
		try {
		filee.createNewFile();
		} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		}
		}




在2个地方分别 放上这端代码，之后再进行比对即可，我token失败是因为，sha1加密后和微信给的大小写出现错误。从而失败。




sha1算法：	
	private static final int[] abcde = { 0x67452301, 0xefcdab89, 0x98badcfe,
			0x10325476, 0xc3d2e1f0 };
	
	// 摘要数据存储数组
	private static int[] digestInt = new int[5];
	
	// 计算过程中的临时数据存储数组
	private static int[] tmpData = new int[80];

	/**
	 * 计算sha-1摘要
	 * 
	 * @param bytedata
	 * @return
	 */
	private static int process_input_bytes(byte[] bytedata) {
		// 初试化常量
		System.arraycopy(abcde, 0, digestInt, 0, abcde.length);
		// 格式化输入字节数组，补10及长度数据
		byte[] newbyte = byteArrayFormatData(bytedata);
		// 获取数据摘要计算的数据单元个数
		int MCount = newbyte.length / 64;
		// 循环对每个数据单元进行摘要计算
		for (int pos = 0; pos < MCount; pos++) {
			// 将每个单元的数据转换成16个整型数据，并保存到tmpData的前16个数组元素中
			for (int j = 0; j < 16; j++) {
				tmpData[j] = byteArrayToInt(newbyte, (pos * 64) + (j * 4));
			}
			// 摘要计算函数
			encrypt();
		}
		return 20;
	}

	/**
	 * 格式化输入字节数组格式
	 * 
	 * @param bytedata
	 * @return
	 */
	private static byte[] byteArrayFormatData(byte[] bytedata) {
		// 补0数量
		int zeros = 0;
		// 补位后总位数
		int size = 0;
		// 原始数据长度
		int n = bytedata.length;
		// 模64后的剩余位数
		int m = n % 64;
		// 计算添加0的个数以及添加10后的总长度
		if (m < 56) {
			zeros = 55 - m;
			size = n - m + 64;
		} else if (m == 56) {
			zeros = 63;
			size = n + 8 + 64;
		} else {
			zeros = 63 - m + 56;
			size = (n + 64) - m + 64;
		}
		// 补位后生成的新数组内容
		byte[] newbyte = new byte[size];
		// 复制数组的前面部分
		System.arraycopy(bytedata, 0, newbyte, 0, n);
		// 获得数组Append数据元素的位置
		int l = n;
		// 补1操作
		newbyte[l++] = (byte) 0x80;
		// 补0操作
		for (int i = 0; i < zeros; i++) {
			newbyte[l++] = (byte) 0x00;
		}
		// 计算数据长度，补数据长度位共8字节，长整型
		long N = (long) n * 8;
		byte h8 = (byte) (N & 0xFF);
		byte h7 = (byte) ((N >> 8) & 0xFF);
		byte h6 = (byte) ((N >> 16) & 0xFF);
		byte h5 = (byte) ((N >> 24) & 0xFF);
		byte h4 = (byte) ((N >> 32) & 0xFF);
		byte h3 = (byte) ((N >> 40) & 0xFF);
		byte h2 = (byte) ((N >> 48) & 0xFF);
		byte h1 = (byte) (N >> 56);
		newbyte[l++] = h1;
		newbyte[l++] = h2;
		newbyte[l++] = h3;
		newbyte[l++] = h4;
		newbyte[l++] = h5;
		newbyte[l++] = h6;
		newbyte[l++] = h7;
		newbyte[l++] = h8;
		return newbyte;
	}

	private static int f1(int x, int y, int z) {
		return (x & y) | (~x & z);
	}

	private static int f2(int x, int y, int z) {
		return x ^ y ^ z;
	}

	private static int f3(int x, int y, int z) {
		return (x & y) | (x & z) | (y & z);
	}

	private static int f4(int x, int y) {
		return (x << y) | x >>> (32 - y);
	}

	/**
	 * 单元摘要计算函数
	 */
	private static void encrypt() {
		for (int i = 16; i <= 79; i++) {
			tmpData[i] = f4(tmpData[i - 3] ^ tmpData[i - 8] ^ tmpData[i - 14]
					^ tmpData[i - 16], 1);
		}
		int[] tmpabcde = new int[5];
		for (int i1 = 0; i1 < tmpabcde.length; i1++) {
			tmpabcde[i1] = digestInt[i1];
		}
		for (int j = 0; j <= 19; j++) {
			int tmp = f4(tmpabcde[0], 5)
					+ f1(tmpabcde[1], tmpabcde[2], tmpabcde[3]) + tmpabcde[4]
					+ tmpData[j] + 0x5a827999;
			tmpabcde[4] = tmpabcde[3];
			tmpabcde[3] = tmpabcde[2];
			tmpabcde[2] = f4(tmpabcde[1], 30);
			tmpabcde[1] = tmpabcde[0];
			tmpabcde[0] = tmp;
		}
		for (int k = 20; k <= 39; k++) {
			int tmp = f4(tmpabcde[0], 5)
					+ f2(tmpabcde[1], tmpabcde[2], tmpabcde[3]) + tmpabcde[4]
					+ tmpData[k] + 0x6ed9eba1;
			tmpabcde[4] = tmpabcde[3];
			tmpabcde[3] = tmpabcde[2];
			tmpabcde[2] = f4(tmpabcde[1], 30);
			tmpabcde[1] = tmpabcde[0];
			tmpabcde[0] = tmp;
		}
		for (int l = 40; l <= 59; l++) {
			int tmp = f4(tmpabcde[0], 5)
					+ f3(tmpabcde[1], tmpabcde[2], tmpabcde[3]) + tmpabcde[4]
					+ tmpData[l] + 0x8f1bbcdc;
			tmpabcde[4] = tmpabcde[3];
			tmpabcde[3] = tmpabcde[2];
			tmpabcde[2] = f4(tmpabcde[1], 30);
			tmpabcde[1] = tmpabcde[0];
			tmpabcde[0] = tmp;
		}
		for (int m = 60; m <= 79; m++) {
			int tmp = f4(tmpabcde[0], 5)
					+ f2(tmpabcde[1], tmpabcde[2], tmpabcde[3]) + tmpabcde[4]
					+ tmpData[m] + 0xca62c1d6;
			tmpabcde[4] = tmpabcde[3];
			tmpabcde[3] = tmpabcde[2];
			tmpabcde[2] = f4(tmpabcde[1], 30);
			tmpabcde[1] = tmpabcde[0];
			tmpabcde[0] = tmp;
		}
		for (int i2 = 0; i2 < tmpabcde.length; i2++) {
			digestInt[i2] = digestInt[i2] + tmpabcde[i2];
		}
		for (int n = 0; n < tmpData.length; n++) {
			tmpData[n] = 0;
		}
	}

	/**
	 * 4字节数组转换为整数
	 * 
	 * @param bytedata
	 * @param i
	 * @return
	 */
	private static int byteArrayToInt(byte[] bytedata, int i) {
		return ((bytedata[i] & 0xff) << 24) | ((bytedata[i + 1] & 0xff) << 16)
				| ((bytedata[i + 2] & 0xff) << 8) | (bytedata[i + 3] & 0xff);
	}

	// 
	/**
	 * 整数转换为4字节数组
	 * 
	 * @param intValue
	 * @param byteData
	 * @param i
	 */
	private static void intToByteArray(int intValue, byte[] byteData, int i) {
		byteData[i] = (byte) (intValue >>> 24);
		byteData[i + 1] = (byte) (intValue >>> 16);
		byteData[i + 2] = (byte) (intValue >>> 8);
		byteData[i + 3] = (byte) intValue;
	}

	/**
	 * 将字节转换为十六进制字符串
	 * 
	 * @param ib
	 * @return
	 */
	private static String byteToHexString(byte ib) {
		char[] Digit = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',
				'B', 'C', 'D', 'E', 'F' };
		char[] ob = new char[2];
		ob[0] = Digit[(ib >>> 4) & 0X0F];
		ob[1] = Digit[ib & 0X0F];
		String s = new String(ob);
		return s;
	}

	/**
	 * 将字节数组转换为十六进制字符串
	 * 
	 * @param bytearray
	 * @return
	 */
	private static String byteArrayToHexString(byte[] bytearray) {
		String strDigest = "";
		for (int i = 0; i < bytearray.length; i++) {
			strDigest += byteToHexString(bytearray[i]);
		}
		return strDigest;
	}

	/**
	 * 计算sha-1摘要，返回相应的字节数组
	 * 
	 * @param byteData
	 * @return
	 */
	public  static byte[] getDigestOfBytes(byte[] byteData) {
		process_input_bytes(byteData);
		byte[] digest = new byte[20];
		for (int i = 0; i < digestInt.length; i++) {
			intToByteArray(digestInt[i], digest, i * 4);
		}
		return digest;
	}

    /**
     * 计算sha-1摘要，返回相应的十六进制字符串 
     * 
     * @param byteData
     * @return
     */
    public static String getDigestOfString(byte[] byteData) { 
        return byteArrayToHexString(getDigestOfBytes(byteData)); 
    } 
	
    /**
     * @param data
     * @return
     */
    public static String Digest(String data){
    	return getDigestOfString(data.getBytes());
    }

    /**
     * @param data
     * @return
     */
    public static String Digest(String data,String encode){
    	try {
			return getDigestOfString(data.getBytes(encode));
		} catch (UnsupportedEncodingException e) {
			return Digest(data);
		}
    }
    
    /**
     * @param text
     * @return
     */
    public static String SHA1Digest(String text) {
    	String pwd = "";
		try {
			MessageDigest md = MessageDigest.getInstance("SHA1");
			md.update(text.getBytes());
			pwd = new BigInteger(1, md.digest()).toString(16); 
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}
    	return pwd;
    }

版权声明：本文为博主原创文章，未经博主允许不得转载。

java.lang.RuntimeException: Unable to instantiate activity ComponentInfo{com.example.AndroidCaptureC
今天从网上下了一个项目，里面没有.project文件，当我点击File菜单，分别选择Import->General->Existing Projects into Workspace，然后在Select root directory中Browse你想要加入的工程。然而我并没有成功，任我怎么点击Refresh都没有显示可用的Projects文件（你现在就可以试一试）。这是为什么呢？原来这种导入方法只适用于eclipse自己创建的工程，比如说，在别人的电脑上用eclipse创建了一个工程，然后就可以用这个办法导入到你的eclipse中。因为用eclipse创建的工程有一个.project文件，而有时候我们下载来的项目是没有这个文件的。
所以用eclipse无法进行导入。于是我将另一个工程里的.project文件添加到我们要导入的项目中，不过我们要将.project中的<projectDescription> 根节点下的第一个子节点<name>改为你要改的名字即可更改项目名字，这样我们就可以顺利导入项目了。
有时这样导入项目后可能会遇到gen already exists but is not a source folder. Convert to a source folder or rename
 it的错误提示，
解决办法，可以看我的另一篇博客
 关于用eclipse导入项目后提示gen already exists but is not a source folder的错误。
此时，我们的项目算是导入成功了，有时我们会看到我们的项目里的java文件怪怪的，如下图：


而正常项目的.java文件是，如下图


可以看到正常的.java文件有个小三角，点击可以展开查看里面的方法，可我们上面的图却没有。
有的朋友就说了，没有就没有呗，只要不报错就好了。eclipse是没有报错。
不过，我们用eclipse运行我们的项目，会发现我们的应用会报错误，装不成功。错误如下：




报了一个运行时错误，说是找不到这个类，无法进行初始化。有同学就有疑问了，为啥明明有java文件会找不到呢？


遇到这个问题的解决方法:

 1. 右键点击工程，选择 "Properties"

2. 选择左边的 "Java Build Path" 

3. 打开 "Source" 标签面板

4. 点击 "Add Folder..."

5. 勾选 "src" 文件夹，点击OK，点击YES，再点击OK

6. 最后右键点击工程，选择 "Andriod Tools" 里面的 "Fix Project Properties"

问题就解决了。其实原因和上面的gen already exists but is not a source folder. Convert to a source folder or rename it的原因差不多。


版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS小技巧--用runtime 解决UIButton 重复点击问题
iOS小技巧–用runtime 解决UIButton 重复点击问题
什么是这个问题
我们的按钮是点击一次响应一次, 即使频繁的点击也不会出问题, 可是某些场景下还偏偏就是会出问题. 
通常是如何解决
我们通常会在按钮点击的时候设置这个按钮不可点击. 等待0.xS的延时后,在设置回来; 或者在操作结束的时候设置可以点击.
- (IBAction)clickBtn1:(UIbutton *)sender
{
    sender.enabled = NO;
    doSomething
    sender.enabled = YES;
}
如果涉及到按钮不同状态不同样式的时候, 用enabled不见得够用.还得额外加个变量来记录状态.
- (IBAction)clickBtn1:(UIbutton *)sender
{
    if (doingSomeThing) return;

    doingSomeThing = YES;
    doSomething
    doingSomeThing = NO;
}
笔者举的例子是直接在响应事件的周期内直接禁止点击的. 如果想做1秒内禁止重复点击的话,则得用performSelector:withObject:afterDelay:
漂亮的解决是怎样的
有了重复的代码段就是有了一个共性, 就可以抽象出来.
我们可以给按钮添加一个属性重复点击间隔, 通过设置这个属性来控制再次接受点击事件的时间间隔.
@interface UIControl (XY)
@property (nonatomic, assign) NSTimeInterval uxy_acceptEventInterval;   // 可以用这个给重复点击加间隔
@end

static const char *UIControl_acceptEventInterval = "UIControl_acceptEventInterval";
- (NSTimeInterval)uxy_acceptEventInterval
{
    return [objc_getAssociatedObject(self, UIControl_acceptEventInterval) doubleValue];
}

- (void)setUxy_acceptEventInterval:(NSTimeInterval)uxy_acceptEventInterval
{
    objc_setAssociatedObject(self, UIControl_acceptEventInterval, @(uxy_acceptEventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
在app启动的时候,我们hook 所有的按钮的 event
@implementation UIControl (XY)

+ (void)load
{
    Method a = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));
    Method b = class_getInstanceMethod(self, @selector(__uxy_sendAction:to:forEvent:));
    method_exchangeImplementations(a, b);
}

@end
在我们的点击事件里呢,对点击事件做下过滤
- (void)__uxy_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event
{
    if (self.uxy_ignoreEvent) return;

    if (self.uxy_acceptEventInterval > 0)
    {
        self.uxy_ignoreEvent = YES;
        [self performSelector:@selector(setUxy_ignoreEvent:) withObject:@(NO) afterDelay:self.uxy_acceptEventInterval];
    }

    [self __uxy_sendAction:action to:target forEvent:event];
}

实际使用起来就是这个样子
    UIButton *tempBtn = [UIButton buttonWithType:UIButtonTypeCustom];
    [tempBtn addTarget:self action:@selector(clickWithInterval:) forControlEvents:UIControlEventTouchUpInside];
    tempBtn.uxy_acceptEventInterval = 0.5;
文章至此就结束了.虽然不推荐大范围用runtime, 但是小范围内使用还是可以解决不少小问题的.

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【IOS】高仿暴风视频播放器app源码

高仿暴风视频播放器app源码
这是一款仿照暴风影音做的demo，因为项目需要，所以顺便把他完善一点，功能有侧滑，滚动导航栏，tableView
 ，collectionView的高度定制，希望能帮助到有需求的码友。

下载地址：http://www.devstore.cn/code/info/1164.html
运行截图：
  



IOS热门源码下载：

模仿手机支付宝界面


高仿网易4.0新UI框架


实现功能比较齐全的 UITextField 








版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS开发中的NSDateFormatter日期格式解析总结
在工作中,经常遇到将时间解析出来转换成自己对应要求的时间格式,之前也有收集相应的转换格式,现在将自己收集的一部分了做个分享,应该比较完善了,欢迎大家继续补充



年

y 将年份 (0-9) 显示为不带前导零的数字yy 以带前导零的两位数字格式显示年份yyy 以四位数字格式显示年份yyyy 以四位数字格式显示年份

月

M 将月份显示为不带前导零的数字（如一月表示为 1）MM 将月份显示为带前导零的数字（例如 01/12/01）MMM 将月份显示为缩写形式（例如 Jan）MMMM 将月份显示为完整月份名（例如 January）

一月 Jan January二月 Feb February三月 Mar March四月 Apr April五月 May May六月 Jun June七月 Jul July八月 Aug August九月 Sep September十月 Oct October十一月 Nov November十二月 Dec December


日

d 将日显示为不带前导零的数字（如 1）dd 将日显示为带前导零的数字（如 01）
星期

EEE 将日显示为缩写形式（例如 Sun）EEEE 将日显示为全名（例如 Sunday）

星期一 Mon Monday星期二 Tue Tuesday星期三 Wed Wednesday星期四 Thu Thursday星期五 Fri Friday星期六 Sat Saturday星期天 Sun Sunday

小时

h 使用 12 小时制将小时显示为不带前导零的数字（例如 1:15:15 PM）hh 使用 12 小时制将小时显示为带前导零的数字（例如 01:15:15 PM）H 使用 24 小时制将小时显示为不带前导零的数字（例如 1:15:15）HH 使用 24 小时制将小时显示为带前导零的数字（例如 01:15:15）
分钟

m 将分钟显示为不带前导零的数字（例如 12:1:15）mm 将分钟显示为带前导零的数字（例如 12:01:15）
秒

s 将秒显示为不带前导零的数字（例如 12:15:5）ss 将秒显示为带前导零的数字（例如 12:15:05）f 显示秒的小数部分ff 将精确显示到百分之一秒ffff 将精确显示到万分之一秒用户定义格式中最多可使用七个 f 符号
上午&下午

t 使用 12 小时制

中午之前任一小时显示大写的 A中午到 11:59 PM 之间的任一小时显示大写的 P
tt 对于使用 12 小时制的区域设置

中午之前任一小时显示大写的 AM中午到 11:59 PM 之间的任一小时显示大写的 PM
对于使用 24 小时制的区域设置，不显示任何字符
时区

z 显示不带前导零的时区偏移量zz 显示带前导零的时区偏移量（例如 -08）zzz 显示完整的时区偏移量（例如 -0800）
纪元

gg 显示时代/纪元字符串（例如 A.D.）




版权声明：本文为博主原创文章，未经博主允许不得转载。

Genymotion问题集（侧重win10 系统）
根据目录找寻自己的问题。
由于win10发布不久，很多朋友在升级了Win10后Genymotion、vbox各种打不开。但是Google自家的虚拟机实在有点蛋疼，于是各种吐槽，各种回滚就出现了。为了更好的解决这些问题，避免回滚、将这些问题的解决方法分享出来。 
 当然在这里的话也希望遇到类似问题的朋友可以去GenymotionQQ群：79669432或Genymotion吧寻求帮助。

下面三个网盘地址中的文件都是一样的，多个地址避免和谐而已，连接失效可以留言。  
（非win10用户推荐用次安装包） 
  genymotion和vbox二合一安装包：链接: http://pan.baidu.com/s/1o6GdiPG 密码: gix8
（win10用户必须用此安装包，或在官网下载更高版本） 
  genymotion2.53：链接: http://pan.baidu.com/s/1nt5VKVn 密码: jh8n 
  virtualbox5.02：  链接: http://pan.baidu.com/s/1jGInhLs 密码: sfhh

问题一：关于彻底卸载Genymotion和VBOX 和重新安装

这里为什么要先说明Genymotion和VBOX的卸载问题呢，由于不清楚你Genymotion和VBOX的具体情况，为了不影响后续设置，你可以先卸载Genymotion和VBOX然后在重新安装这样就比较靠谱了。当然你也可以根据后面的其他问题集进行处理，如果还搞不定在卸载重装也可以的。





完成后运行Win+E输入RegEdit到注册表中的HKEY_LOCAL_MACHINE\SOFTWARE中将与VBOX和Genymotion相关的内容进行删除。那么OK了。
然后到官网下载VirtualBox5.02（2015-8-13号更新的文件）和最新Genymotion进行安装，安装步骤就不说了。不会可以看看这里的安装教程
问题二： 关于Genymotion的注册问题
如果你在Genymotion注册时无法进入官网那么你可以尝试翻墙一下，或者到找人帮你注册咯。 
 
在你完成安装后如果提示你输入注册的账号和密码一直连接不上，你可以多次点击登录或者重新开启软件再试，再不行就翻墙吧，翻墙都不行就砸一遍电脑看看是不是电脑有问题。
问题三：关于Genymotion和VBOX的兼容性问题
安装VirtualBox5.02，并设置兼容性（win10用户） 
   问题图片 

进行兼容性设置

问题四：关于Genymotion和VBOX网络连接问题
如果出现这样下面图片中的问题，说明你Genymotion虚拟的网络连接有问题，Genymotion和VBOX是通过IP来关联的，但凡错误提示中有英文字段有类似IP、DHCP、start virtualBox之类的都是此类问题。 

或者是这样的 
 
  都可以通过以下的方式来修复   

A、在你的电脑有安全的软件保护的情况下关闭防火墙（谨慎尝试，中毒了不要找我），Win+E输入services.msc在里面找打Windows Firewall和Hyper-V（Hyper-V是win10自动虚拟机，没安装就不用了，找找看就知道了，这里要关闭Hyper-V是因为避免受Hyper-V虚拟机的影响）进行关闭。  

B、找到VBOX安装目录下面的drivers目录，将里面的除USB外的两个文件夹中的.inf格式的文件安装一下。（.inf格式的文件是VBOX的服务） 
 

C、检查VBOX中的虚拟机的网络设置项 
 
  这里注意，在win10情况下要想桥接必须下载VirtualBox5.02，在win10系统中安装VirtualBox5.02以前的版本目测不会给你安装桥接服务，也就是VBoxNetAdp6.inf的这个文件  。 

D、如果在前面使用正常的情况下出现电脑重启后无法连接那么你除了尝试上述方法之外也可以将Genymotion和VBOX中的虚拟机删除并重新安装一个，不是叫你把两个软件删除哈，看清楚，是删除虚拟机并重新安装。  

E、重新安装或者刚刚安装好虚拟机并且可以打开的情况下，你可以开启VBOX打开界面中右上角的备份功能，使用正常的话做一个备份，如果后面出现问题可以恢复以前的备份，这样就可以了。
问题五：关于Genymotion和eclipse、Android studio中连接的问题

（genymotion与eclipse连接插件） 
下载地址
（genymotion与Android studio连接插件）  
下载地址

A、和eclipse连接 
安装教程
B、和Android studio连接 
安装教程
问题六：关于Genymotion与eclipse链接中ADB遇到的一些问题
A、这里先了解一下ADB，ADB是eclipse和虚拟机、手机的链接桥梁，其实我们生活中不做开发也经常会遇到ADB，比如说你用360手机助手、豌豆荚助手这些软件的时候就会有ADB这样一个进程在里面，那么同理咯，我们在使用eclipse时、Google提供的SDK里面也是有ADB的，genymotion同样有自己的ADB，在genymotion软件设置中可以看到关于ADB的选择路径。

B、这里就说明一下我遇到的一些问题，当你先开启eclipse时，如果里面没有adb启动，那么你直接打开genymotion是不会有什么问题的；但是有时候其他软件开启了adb，当你在这样的情况下打开genymotion时，genymotion的adb就可能在eclipse识别adb的时候与其他软件中的adb冲突，这样就启动不了了，那么在这样的情况下你可以在eclipse启动时先关闭其他的ADB，关闭（重启）方式有多种：


方法一：直接将与手机链接有关的软件关闭了或者在任务管理器中关adb



方法二：在eclipse中重启一下adb，如果你eclipse开了，genymotion也开启了，但是就是没连上，你可以试试这样的方法 




方法三：通过命令来关闭，adb kill-server（前提是你已经在环境变量中配置好adb，如果没有配置你就要自己进来adb的目录了） 
看图吧 
 
 



C、其实直接在genymotion中将genymotion自带的adb改成SDK中的adb也可以的，不过我没改成。

问题七：关于Genymotion中部分软件无法安装的问题
下载下面的兼容包，将压缩包名字命名为英文然后直接拖入genymotion虚拟机的手机桌面即可完成安装，注意不要解压压缩包。
下载地址
问题八：关于Genymotion问题的后续补充

上图说明你已经启动了该虚拟机，可以去任务管理器中看看。

最好不要用中文路径

温馨提示
如果博客对解决你的问题有帮助希望你可以顶一下贴并将你的问题反馈并截图到贴吧，我会整理到博客中方便其他人参考使用，没人顶我贴要沉没了。顶帖地址

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

UICollectionView-控件的使用（初步）

<p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; color: rgb(57, 57, 57); font-family: verdana, 'ms song', Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px; background-color: rgb(250, 247, 239);"><span style="margin: 0px; padding: 0px;">
<span style="color: rgb(57, 57, 57); font-family: verdana, 'ms song', Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px; white-space: pre; background-color: rgb(250, 247, 239);">UICollectionView</span>和 UICollectionViewController 类是iOS6 新引进的API，用于展示集合视图，布局更加灵活，可实现多列布局，用法类似于UITableView 和 UITableViewController 类。</span></p><p style="margin: 10px auto; padding-top: 0px; padding-bottom: 0px; color: rgb(57, 57, 57); font-family: verdana, 'ms song', Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px; background-color: rgb(250, 247, 239);"><span style="margin: 0px; padding: 0px;">使用UICollectionView 必须实现UICollectionViewDataSource,UICollectionViewDelegate,UICollectionViewDelegateFlowLayout这三个协议。</span></p>#import "ViewController.h"


/**
 *  1.保证无错运行是开始
    2.足够简单 
 
 */
@interface ViewController ()<UICollectionViewDataSource,UICollectionViewDelegateFlowLayout>

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
}

#pragma mark UICollectionViewDataSource
//有多少组需要显示
-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView
{
    return 1;
}
//每组中有多少数据需要显示
-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
    return 10;
}

-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{

    
    [collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@"A"];
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"A" forIndexPath:indexPath];
    cell.backgroundColor = [UIColor yellowColor];
    return cell;
}

-(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
    return CGSizeMake(200, 200);
}
- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

@end




版权声明：本文为博主原创文章，未经博主允许不得转载。

Tigase开发笔记4：Tigase Component组件开发
使用的Tigase Server版本 7.0.2 最新版，网上的资料很多，但都不能清楚明白的说明，自己整理了一下，其实很简单，希望帮助走绕了路的朋友。


组件开发的快速引导





开发一个组件（Component）需要做如下几件事儿
1. 定义一个组件
2. 配置这个组件
3. 调用这个组件
4. 处理组件收到的消息




1. 定义一个组件

定义一个最简单的消息组件，需要继承 extends AbstractMessageReceiver
 类






public class EchoComponent extends AbstractMessageReceiver {   private static final Logger log = Logger.getLogger(EchoComponent.class.getName());   //~--- methods --------------------------------------------------------------   @Override   public void processPacket(Packet packet) {      log.log(Level.FINEST, "Received: {0}", packet);      Packet result = packet.swapStanzaFromTo();      addOutPacket(result);      log.log(Level.FINEST, "Sent back: {0}", result);   }}







2. 配置这个组件

在init.properties中配置这个组件






--comp-name-8=echo #自定义名称即可,这个名字在客户端发送消息给组件时会用到--comp-class-8=tigase.server.test.EchoComponent







这样这个组件就配置好了，Tigase启动时就会注册加载这个组件，客户端即可调用了
想要将消息发送给这个组件，客户端的to="xxx"需要设置为
to="xxx" -》 to = "组件名称@域名" -》 to="echo@10.5.1.48",否则消息不会传递给名为"echo"这个组件



3. 调用这个组件（我用的Spark 客户端的调试模式中的）






<message from="admin@10.5.1.48/Spark"
  to="echo@10.5.1.48" id="8oHyf-314" xmlns="jabber:client">
  <subject>test message</subject>
  <body>this is a test,hi,word1</body>
</message>










完整调用见截图（我用的是Spark客户端登录界面的调试模式登录，然后使用发送自定义报文的功能）







4. 处理消息





这就是一个最简单的组件开发过程！










更多详细请看下面的介绍


官网开发指导：
http://docs.tigase.org/tigase-server/7.0.0/Development_Guide/html_chunk/cil1.html
http://docs.tigase.org/tigase-server/7.0.0/Development_Guide/webhelp/cil2.html



版权声明：本文为博主原创文章，未经博主允许不得转载。

Vibrator控制手机震动
Vibrator控制手机震动
效果图

源码
下载地址（Android Studio工程）：http://download.csdn.net/detail/q4878802/9049755
添加权限
<!-- 震动的权限 -->
<uses-permission  android:name="android.permission.VIBRATE" />
工具类
package com.kongqw.kqwvibrator.engine;

import android.content.Context;
import android.os.Vibrator;

/**
 * Created by kongqw on 2015/8/26.
 */
public class KqwVibrator {

    private static KqwVibrator mKqwVibrator;
    private Context mContext;
    private Vibrator mVibrator;

    private KqwVibrator(Context context) {
        mContext = context;
        // 初始化振动器对象
        mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    }

    public static KqwVibrator getInstance(Context context) {
        if (null == mKqwVibrator) {
            mKqwVibrator = new KqwVibrator(context);
        }
        return mKqwVibrator;
    }

    /**
     * 开始震动
     *
     * @param time 震动时间 毫秒
     */
    public void vibrate(long time) {
        mVibrator.vibrate(time);
    }


    /**
     * 取消震动
     */
    public void cancle() {
        mVibrator.cancel();
    }


    /**
     * 重复震动
     */
    public void repeatVibrate() {
        //等待1秒，震动2秒，等待1秒，震动3秒
        long[] pattern = {1000, 2000, 1000, 3000};
        //-1表示不重复, 如果不是-1, 比如改成1, 表示从前面这个long数组的下标为1的元素开始重复.
        mVibrator.vibrate(pattern, -1);
    }
}
测试类
package com.kongqw.kqwvibrator;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;

import com.kongqw.kqwvibrator.engine.KqwVibrator;


public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    /**
     * 开始震动500毫秒
     *
     * @param view
     */
    public void button1(View view) {
        KqwVibrator.getInstance(this).vibrate(500);
    }

    /**
     * 重复震动
     *
     * @param view
     */
    public void button2(View view) {
        KqwVibrator.getInstance(this).repeatVibrate();
    }

    /**
     * 停止震动
     *
     * @param view
     */
    public void button3(View view) {
        KqwVibrator.getInstance(this).cancle();
    }
}
页面布局
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context=".MainActivity">

    <Button
        android:id="@+id/button1"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:onClick="button1"
        android:text="开始震动500毫秒" />

    <Button
        android:id="@+id/button2"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@+id/button1"
        android:onClick="button2"
        android:text="重复震动" />

    <Button
        android:id="@+id/button3"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentStart="true"
        android:layout_below="@+id/button2"
        android:onClick="button3"
        android:text="停止震动" />

</RelativeLayout>
说明
mVibrator.vibrate(pattern, -1);

这个是一个间歇性震动的方法，第一个参数是一个long类型的数组（毫秒），单数（双数角标）为等待时间，双数（单数角标）为震动时间。

例：
//等待1秒，震动2秒，等待1秒，震动3秒
long[] pattern = {1000, 2000, 1000, 3000};

第二个参数是循环的参数，是几就表示下次从第几个角标开始循环，-1表示不循环。

父类方法
/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#VIBRATE}.
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 *        you don't want to repeat.
 */
public void vibrate(long[] pattern, int repeat) {
    vibrate(pattern, repeat, null);
}


/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#VIBRATE}.
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 *        you don't want to repeat.
 * @param attributes {@link AudioAttributes} corresponding to the vibration. For example,
 *        specify {@link AudioAttributes#USAGE_ALARM} for alarm vibrations or
 *        {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE} for
 *        vibrations associated with incoming calls.
 */
public void vibrate(long[] pattern, int repeat, AudioAttributes attributes) {
    vibrate(Process.myUid(), mPackageName, pattern, repeat, attributes);
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。所有文章，任何一个技术点，无论是原创还是转载，都是在程序中使用过或者Demo测试过才发表！博主QQ:4878802。

关于android studio几种常见的错误解决
我也是从ec转到as的,没办法,大势所趋嘛,然而,在使用as的过程中遇到了很多匪夷所思的错误,现在就说一下今天我遇到的这个错误.
美工妹子给了我一张图片,用来当做button的背景图,当然,这个图也可以直接放到ImageView添加点击事件的方法也行,这里就不讨论这个了,图片的名字是:eweima.png
此处注意一下,美工给我的图,我丝毫没有改动,那么,就开始大大咧咧的拿着使用了.把图片放置到 mipmap-hdpi目录下面,此时会显示里面除了默认的ic_launcher.png以外多了一张eweima.png的图片,此时,就开始写ImageView了,不多赘述.

这里如果仔细看一下就会发现,eweima下面有个浅色的小波浪线,别急,运行一下.

当时一看,肯定就疯了,什么app:processDebugResources什么的...然后又aapt.exe...这肯定就是没边的惊悚,其实,别急,这时候,因为我已经经历过这个错误了,所以,我这边只需要做的就是把eweima.png改成eweima.jpg
,png与jpg两种样式之间的差别我知道的也不多,不过可以通过在as里面点击图片,打开就能看的出来他们的差别了.此时,再运行一下.

好了,出这种东西代表已经安装成功了.问题完美解决.


版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 使用ORMLite打造万能泛型Dao简化数据持久化层
前面的一篇文章Android ORM系列之ActiveAndroid 介绍了ActiveAndroid的使用方法，但是ActiveAndroid有一个很明显的缺点，就是所有的实体类必须继承Model类才能进行CRUD，这是典型的php中的ActiveRecord方式的数据库操作。这时候我们会想一下，在Java Web中，hibernate或者mybatis就很好，其实在android中也有这么一个框架，但是这个框架是java的，只不过它支持Android而已，它就是ORMLite。这篇文章不会过度介绍ORMlite本身的一些操作。如果感兴趣的话可以阅读下面的几篇翻译的文章. 
 - Android数据库ORMlite框架翻译系列（第一章） 
 - Android数据库ORMlite框架翻译系列（第二章：part 1） 
 - Android数据库ORMlite框架翻译系列（第二章：part 2） 
 - Android数据库ORMlite框架翻译系列（第二章：part 3）
然而ormlite提供给我们的还不够使用，我们能不能打造一个类似java web那样的dao层的完全分离，其实ORMLite已经为我们提供了这么一个类，它就是com.j256.ormlite.dao.BaseDaoImpl，但是这个类在我写这个dao前还没发现，后来发现有这个类，简直想撞豆腐，不过呢，这个类也不是那么完美，我们还是自己来实现一遍。
我们写的这个dao，如果你对事务要求有较高的要求，建议将dao层中的事务操作提取到service层中去。一个很简单的例子见这篇文章 (android)初探ormlite实现仿web那样写dao,service。这里我为了方便起见，将事务操作都扔到了dao中，建议还是单独提到service层中。下面贴出整个dao的代码，代码很简单。具体内容见注释把。
在使用前加入依赖
 compile 'com.j256.ormlite:ormlite-android:4.48'
我们首先要提供一个Helper类。就是完成数据库的初始化或者更新。然后提供一个helper的单例。

/**
 * Helper类，提供单例Helper
 * User:lizhangqu(513163535@qq.com)
 * Date:2015-08-26
 * Time: 12:04
 */
public class DatabaseHelper extends OrmLiteSqliteOpenHelper {

    private static final String DB_NAME = "sc.db";
    //数据库名
    private static final int DB_VERSION = 1;
    //数据库版本
    private static DatabaseHelper instance;

    //Helper单例
    public DatabaseHelper(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase database, ConnectionSource connectionSource) {
        //创建表
        try {
            TableUtils.createTable(connectionSource, Student.class);
            TableUtils.createTable(connectionSource, Course.class);
            TableUtils.createTable(connectionSource, StudentCourse.class);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onUpgrade(SQLiteDatabase database, ConnectionSource connectionSource, int oldVersion, int newVersion) {
        //更新表
        try {
            TableUtils.dropTable(connectionSource, StudentCourse.class, true);
            TableUtils.dropTable(connectionSource, Student.class, true);
            TableUtils.dropTable(connectionSource, Course.class, true);
            onCreate(database, connectionSource);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * 双重加锁检查
     *
     * @param context 上下文
     * @return 单例
     */
    public static synchronized DatabaseHelper getInstance(Context context) {
        if (instance == null) {
            synchronized (DatabaseHelper.class) {
                if (instance == null) {
                    instance = new DatabaseHelper(context);
                }
            }
        }
        return instance;
    }

}

接下来就是这个通用的dao，一个抽象类，抽象方法是getDao，交给子类实现。其实你也可以直接在本类实现，实际差别不会太大。这个dao的主键是Integer类型的，如果你需要其他类型，请自行修改。

/**
 * 数据库CRUD操作的Dao，子类继承实现抽象方法，也提供一个简单的泛型实现类
 * User:lizhangqu(513163535@qq.com)
 * Date:2015-08-26
 * Time: 12:25
 */
public abstract class BaseDao<T, Integer> {
    protected DatabaseHelper mDatabaseHelper;

    //helper
    protected Context mContext;

    //上下文
    public BaseDao(Context context) {
        if (context == null) {
            throw new IllegalArgumentException("Context can't be null!");
            //如果为空，则扔出非法参数异常
        }
        mContext = context.getApplicationContext();
        //避免产生内存泄露，使用getApplicationContext()
        mDatabaseHelper = DatabaseHelper.getInstance(mContext);
        //获得单例helper
    }

    /**
     * 抽象方法，重写提供Dao,在BaseDaoImpl里提供了简单的泛型实现，传递实体类Class即可
     *
     * @return Dao类
     * @throws SQLException SQLException异常
     */
    public abstract Dao<T, Integer> getDao() throws SQLException;

    /**
     * 增，带事务操作
     *
     * @param t 泛型实体类
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int save(T t) throws SQLException {
        Dao<T, Integer> dao = getDao();

        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            int save = dao.create(t);
            dao.commit(databaseConnection);
            return save;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }

    /**
     * 增或更新，带事务操作
     * @param t 泛型实体类
     * @return Dao.CreateOrUpdateStatus
     * @throws SQLException SQLException异常
     */
    public Dao.CreateOrUpdateStatus saveOrUpdate(T t) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            Dao.CreateOrUpdateStatus orUpdate = dao.createOrUpdate(t);
            dao.commit(databaseConnection);
            return orUpdate;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return null;
    }

    /**
     * 增，带事务操作
     * @param t 泛型实体类集合
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int save(List<T> t) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            for (T item : t) {
                dao.create(item);
            }
            dao.commit(databaseConnection);
            return t.size();
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }

    /**
     * 删，带事务操作
     *
     * @param t 泛型实体类
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int delete(T t) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            int delete = dao.delete(t);
            dao.commit(databaseConnection);
            return delete;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }

    /**
     * 删，带事务操作
     *
     * @param list 泛型实体类集合
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int delete(List<T> list) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            int delete = dao.delete(list);
            dao.commit(databaseConnection);
            return delete;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }

    /**
     * 删，带事务操作
     *
     * @param columnNames  列名数组
     * @param columnValues 列名对应值数组
     * @return 影响的行数
     * @throws SQLException              SQLException异常
     * @throws InvalidParameterException InvalidParameterException异常
     */
    public int delete(String[] columnNames, Object[] columnValues) throws SQLException, InvalidParameterException {
        List<T> list = query(columnNames, columnValues);
        if (null != list && !list.isEmpty()) {
            Dao<T, Integer> dao = getDao();
            DatabaseConnection databaseConnection = null;
            try {
                databaseConnection = dao.startThreadConnection();
                dao.setAutoCommit(databaseConnection, false);
                int delete = dao.delete(list);
                dao.commit(databaseConnection);
                return delete;
            } catch (SQLException e) {
                dao.rollBack(databaseConnection);
                e.printStackTrace();
            } finally {
                dao.endThreadConnection(databaseConnection);
            }
        }
        return 0;
    }

    /**
     * 删，带事务操作
     *
     * @param id id值
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int deleteById(Integer id) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            int delete = dao.deleteById(id);
            dao.commit(databaseConnection);
            return delete;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }

    /**
     * 删，带事务操作
     * @param ids id集合
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int deleteByIds(List<Integer> ids) throws SQLException {
        Dao<T, Integer> dao = getDao();

        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            int delete = dao.deleteIds(ids);
            dao.commit(databaseConnection);
            return delete;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }
    /**
     * 删，带事务操作
     *
     * @param preparedDelete PreparedDelete类
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int delete(PreparedDelete<T> preparedDelete) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            int delete = dao.delete(preparedDelete);
            dao.commit(databaseConnection);
            return delete;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }

    /**
     * 改，带事务操作
     *
     * @param t 泛型实体类
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int update(T t) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            int update = dao.update(t);
            dao.commit(databaseConnection);
            return update;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }

    /**
     * 改，带事务操作
     * @param preparedUpdate PreparedUpdate对象
     * @return 影响的行数
     * @throws SQLException SQLException异常
     */
    public int update(PreparedUpdate<T> preparedUpdate) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            int update = dao.update(preparedUpdate);
            dao.commit(databaseConnection);
            return update;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }
    /**
     * 查，带事务操作
     *
     * @return 查询结果集合
     * @throws SQLException SQLException异常
     */
    public List<T> queryAll() throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            List<T> query = dao.queryForAll();
            dao.commit(databaseConnection);
            return query;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return null;
    }

    /**
     * 查，带事务操作
     *
     * @param preparedQuery PreparedQuery对象
     * @return 查询结果集合
     * @throws SQLException SQLException异常
     */
    public List<T> query(PreparedQuery<T> preparedQuery) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            List<T> query = dao.query(preparedQuery);
            dao.commit(databaseConnection);
            return query;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return null;
    }

    /**
     * 查，带事务操作
     *
     * @param columnName  列名
     * @param columnValue 列名对应值
     * @return 查询结果集合
     * @throws SQLException SQLException异常
     */
    public List<T> query(String columnName, String columnValue) throws SQLException {
        QueryBuilder<T, Integer> queryBuilder = getDao().queryBuilder();
        queryBuilder.where().eq(columnName, columnValue);
        PreparedQuery<T> preparedQuery = queryBuilder.prepare();
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            List<T> query = dao.query(preparedQuery);
            //also can use dao.queryForEq(columnName,columnValue);
            dao.commit(databaseConnection);
            return query;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return null;
    }

    /**
     * 查，带事务操作
     *
     * @param columnNames
     * @param columnValues
     * @return 查询结果集合
     * @throws SQLException SQLException异常
     */
    public List<T> query(String[] columnNames, Object[] columnValues) throws SQLException {
        if (columnNames.length != columnNames.length) {
            throw new InvalidParameterException("params size is not equal");
        }
        QueryBuilder<T, Integer> queryBuilder = getDao().queryBuilder();
        Where<T, Integer> wheres = queryBuilder.where();
        for (int i = 0; i < columnNames.length; i++) {
            if (i==0){
                wheres.eq(columnNames[i], columnValues[i]);
            }else{
                wheres.and().eq(columnNames[i], columnValues[i]);
            }

        }
        PreparedQuery<T> preparedQuery = queryBuilder.prepare();

        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            List<T> query = dao.query(preparedQuery);
            dao.commit(databaseConnection);
            return query;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return null;
    }

    /**
     * 查，带事务操作
     *
     * @param map 列名与值组成的map
     * @return 查询结果集合
     * @throws SQLException SQLException异常
     */
    public List<T> query(Map<String, Object> map) throws SQLException {
        QueryBuilder<T, Integer> queryBuilder = getDao().queryBuilder();
        if (!map.isEmpty()) {
            Where<T, Integer> wheres = queryBuilder.where();
            Iterator<Map.Entry<String, Object>> iterator = map.entrySet().iterator();
            String key = null;
            Object value = null;
            for (int i = 0; iterator.hasNext(); i++) {
                Map.Entry<String, Object> next = iterator.next();
                key = next.getKey();
                value = next.getValue();
                if (i == 0) {
                    wheres.eq(key, value);
                } else {
                    wheres.and().eq(key, value);
                }
            }
        }
        PreparedQuery<T> preparedQuery = queryBuilder.prepare();
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            List<T> query = dao.query(preparedQuery);
            dao.commit(databaseConnection);
            return query;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return null;
    }

    /**
     * 查，带事务操作
     *
     * @param id id值
     * @return 查询结果集合
     * @throws SQLException SQLException异常
     */
    public T queryById(Integer id) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            T t = dao.queryForId(id);
            dao.commit(databaseConnection);
            return t;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return null;
    }

    /**
     * 判断表是否存在
     *
     * @return 表是否存在
     * @throws SQLException SQLException异常
     */
    public boolean isTableExists() throws SQLException {
        return getDao().isTableExists();
    }


    /**
     * 获得记录数
     *
     * @return 记录数
     * @throws SQLException SQLException异常
     */
    public long count() throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);
            long count = dao.countOf();
            dao.commit(databaseConnection);
            return count;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }

    /**
     * 获得记录数
     *
     * @param preparedQuery PreparedQuery类
     * @return 记录数
     * @throws SQLException SQLException异常
     */
    public long count(PreparedQuery<T> preparedQuery) throws SQLException {
        Dao<T, Integer> dao = getDao();
        DatabaseConnection databaseConnection = null;
        try {
            databaseConnection = dao.startThreadConnection();
            dao.setAutoCommit(databaseConnection, false);

            long count = dao.countOf(preparedQuery);
            dao.commit(databaseConnection);
            return count;
        } catch (SQLException e) {
            dao.rollBack(databaseConnection);
            e.printStackTrace();
        } finally {
            dao.endThreadConnection(databaseConnection);
        }
        return 0;
    }
}

一个简单的泛型实现类，带缓存。

/**
 * BaseDao泛型实现类
 * User:lizhangqu(513163535@qq.com)
 * Date:2015-08-26
 * Time: 13:51
 */
public class BaseDaoImpl<T,Integer> extends BaseDao<T,Integer> {
    private Class<T> clazz;
    private Map<Class<T>,Dao<T,Integer>> mDaoMap=new HashMap<Class<T>,Dao<T,Integer>>();
    //缓存泛型Dao
    public BaseDaoImpl(Context context,Class<T> clazz) {
        super(context);
        this.clazz=clazz;
    }

    @Override
    public Dao<T, Integer> getDao() throws SQLException {
        Dao<T,Integer> dao=mDaoMap.get(clazz);
        if (null==dao){
            dao=mDatabaseHelper.getDao(clazz);
            mDaoMap.put(clazz,dao);
        }
        return dao;
    }
}

如果你要增加一些操作，直接继承BaseDao实现抽象方法再加入你要增加的操作，或者直接继承BaseDaoImpl再增加操作即可。
整体代码没有什么难度，而怎么使用呢，这里写了几个测试用例。测试用例中涉及到的实体类就不贴了。
public class ApplicationTest extends ApplicationTestCase<Application> {
    private BaseDao<Student,Integer> mStudentDao;
    private BaseDao<Course,Integer> mCourseDao;
    private BaseDao<StudentCourse,Integer> mStudentCourseDao;
    public ApplicationTest() {
        super(Application.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mStudentDao=new BaseDaoImpl<>(getContext(),Student.class);
        mCourseDao=new BaseDaoImpl<>(getContext(),Course.class);
        mStudentCourseDao=new BaseDaoImpl<>(getContext(),StudentCourse.class);
    }

    public void testAddStudent() throws SQLException {
        Student student=new Student();
        student.setStudentName("张三");
        student.setAge(18);
        student.setSex(true);
        student.setAddress("杭州市");
        mStudentDao.save(student);

    }
    public void testAddOrUpdateStudent() throws SQLException {
        Student student=new Student();
        student.setStudentName("张三1111");
        student.setAge(18);
        student.setSex(true);
        student.setAddress("杭州市");
        Dao.CreateOrUpdateStatus createOrUpdateStatus = mStudentDao.saveOrUpdate(student);
        Log.e("TAG", createOrUpdateStatus.isCreated() + "  " + createOrUpdateStatus.isUpdated() + " " + createOrUpdateStatus.getNumLinesChanged());
        student.setAge(19);
        createOrUpdateStatus = mStudentDao.saveOrUpdate(student);
        Log.e("TAG", createOrUpdateStatus.isCreated() + "  " + createOrUpdateStatus.isUpdated() + " " + createOrUpdateStatus.getNumLinesChanged());

    }


    public void testAddStudents() throws SQLException {
        Student student=new Student();
        student.setStudentName("李四");
        student.setAge(19);
        student.setSex(false);
        student.setAddress("温州市");
        Student student1=new Student();
        student1.setStudentName("王五");
        student1.setAge(21);
        student1.setSex(true);
        student1.setAddress("嘉兴市");
        List<Student> list=new ArrayList<Student>();
        list.add(student);
        list.add(student1);
        mStudentDao.save(list);

    }

    public void testDeleteStudent() throws SQLException {
        Student student=new Student();
        student.setStudentName("1111");
        student.setAge(11);
        student.setSex(true);
        student.setAddress("22222");
        mStudentDao.save(student);
        mStudentDao.delete(student);
    }

    public void testDeleteStudents() throws SQLException {
        Student student=new Student();
        student.setStudentName("李四");
        student.setAge(19);
        student.setSex(false);
        student.setAddress("温州市");
        Student student1=new Student();
        student1.setStudentName("王五");
        student1.setAge(21);
        student1.setSex(true);
        student1.setAddress("嘉兴市");
        List<Student> list=new ArrayList<Student>();
        list.add(student);
        list.add(student1);
        mStudentDao.save(list);
        mStudentDao.delete(list);
    }

    public void testDeleteStudentByColumns() throws SQLException {
        Student student=new Student();
        student.setStudentName("李四11");
        student.setAge(19);
        student.setSex(false);
        student.setAddress("温州市");
        mStudentDao.save(student);
        mStudentDao.delete(new String[]{"studentName","studentAge"},new String[]{"李四11","19"});
    }


    public void testDeleteStudentById() throws SQLException {
        Student student=new Student();
        student.setStudentName("李四22");
        student.setAge(19);
        student.setSex(false);
        student.setAddress("温州市");
        mStudentDao.save(student);
        mStudentDao.deleteById(student.getId());
    }


    public void testDeleteStudentByIds() throws SQLException {
        Student student=new Student();
        student.setStudentName("李四22");
        student.setAge(19);
        student.setSex(false);
        student.setAddress("温州市");
        mStudentDao.save(student);
        Student student1=new Student();
        student1.setStudentName("李四333");
        student1.setAge(19);
        student1.setSex(false);
        student1.setAddress("温州市");
        List<Student> list=new ArrayList<Student>();
        mStudentDao.save(list);
        mStudentDao.deleteByIds(Arrays.asList(student.getId(),student1.getId()));

    }


    public void testDeleteStudentByPreparedDelete() throws SQLException {
        Student student=new Student();
        student.setStudentName("李四33");
        student.setAge(19);
        student.setSex(false);
        student.setAddress("温州市");
        mStudentDao.save(student);
        DeleteBuilder<Student, Integer> studentIntegerDeleteBuilder = mStudentDao.getDao().deleteBuilder();
        studentIntegerDeleteBuilder.where().eq("studentName","李四33").and().eq("studentAddress", "温州市");
        PreparedDelete<Student> prepare = studentIntegerDeleteBuilder.prepare();
        mStudentDao.delete(prepare);
    }

    public void testUpdateStudent() throws SQLException {
        Student student=new Student();
        student.setStudentName("赵六");
        student.setAge(19);
        student.setSex(false);
        student.setAddress("温州市");
        mStudentDao.save(student);
        student.setAddress("临安市");
        mStudentDao.update(student);

    }


    public void testUpdateStudentByPreparedUpdate() throws SQLException {
        Student student=new Student();
        student.setStudentName("赵六");
        student.setAge(19);
        student.setSex(false);
        student.setAddress("温州市");
        mStudentDao.save(student);
        student.setAddress("临安市");
        UpdateBuilder<Student, Integer> studentIntegerUpdateBuilder = mStudentDao.getDao().updateBuilder();
        studentIntegerUpdateBuilder.updateColumnValue("studentName","赵六六").where().eq("studentName", "赵六").and().eq("studentAddress", "温州市");
        PreparedUpdate<Student> prepare = studentIntegerUpdateBuilder.prepare();
        mStudentDao.update(prepare);

    }

    public void testQueryStudentAll() throws SQLException {
        List<Student> students = mStudentDao.queryAll();
        Log.e("TAG", students + "");
    }

    public void testQueryStudentByPreparedQuery() throws SQLException {
        QueryBuilder<Student, Integer> studentIntegerQueryBuilder = mStudentDao.getDao().queryBuilder();
        studentIntegerQueryBuilder.where().eq("studentAddress","温州市");
        PreparedQuery<Student> prepare = studentIntegerQueryBuilder.prepare();
        List<Student> students = mStudentDao.query(prepare);
        Log.e("TAG",students+"");
    }

    public void testQueryStudentByColumn() throws SQLException {
        List<Student> students = mStudentDao.query("studentName","赵六六");
        Log.e("TAG",students+"");
    }

    public void testQueryStudentByColumns() throws SQLException {
        List<Student> students = mStudentDao.query(new String[]{"studentName","studentAge","studentSex"},new Object[]{"李四",19,false});
        Log.e("TAG",students+"");
    }

    public void testQueryStudentByMap() throws SQLException {
        Map<String, Object> map=new HashMap<String, Object>();
        map.put("studentName","李四");
        map.put("studentAge",19);
        map.put("studentSex",false);
        List<Student> students = mStudentDao.query(map);
        Log.e("TAG",students+"");
    }

    public void testQueryStudentById() throws SQLException {
        Student student = mStudentDao.queryById(1);
        Log.e("TAG",student+"");
    }

    public void testIsTableExists() throws SQLException {
        Log.e("TAG",mStudentDao.isTableExists()+"");
    }

    public void testCount() throws SQLException {
        Log.e("TAG",mStudentDao.count()+"");
    }

    public void testCountByPreparedQuery() throws SQLException {
        PreparedQuery<Student> prepare = mStudentDao.getDao().queryBuilder().setCountOf(true).where().eq("studentAddress", "温州市").prepare();
        Log.e("TAG",mStudentDao.count(prepare)+"");
    }
最后给出源码下载地址

http://download.csdn.net/detail/sbsujjbcy/9053725


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Decoda编译方法
最近看到 有个很牛逼的lua IDE, decoda,  我就到官网下载来用了
http://unknownworlds.com/decoda/download/

可是安装后打开, 晕,还要注册  !!!




这不是开源的吗? 
我觉得把代码下载下来,自己编译个, 该不用注册了吧 !? 


首先在开源中国里找到

http://www.oschina.net/p/decoda

git 地址是
https://github.com/unknownworlds/decoda



clone 下来后. 就准备编译 了. 
处于懒惰的思想,  先从网上找找有没有编译的教程, 结果看到网上也有很多人问 Decoda 编译方法, 暂还没有找到成功编译的文章. 
决定还是自己试试吧.  其实还是挺简单的


首先要下载 编译工具 Premake
http://premake.github.io/download.html#v4

解压后 放到 你刚才 clone decoda 目录下.
我这里是 F:\git\decoda

然后打开命令行 cmd
进入 decoda 目录
在cmd 输入
F:\git\decoda>premake4.exe vs2010 vcbuild decoda.sln --os=windows --platform=x64
生成vs工程项
Building configurations...
Running action 'vs2010'...
Generating build/Decoda.sln...
Generating build/Frontend.vcxproj...
Generating build/Frontend.vcxproj.user...
Generating build/Frontend.vcxproj.filters...
Generating build/LuaInject.vcxproj...
Generating build/LuaInject.vcxproj.user...
Generating build/LuaInject.vcxproj.filters...
Generating build/Shared.vcxproj...
Generating build/Shared.vcxproj.user...
Generating build/Shared.vcxproj.filters...
Done.



我当时直接生成 vs2010 工程了, 
可是 git 下来的依赖库都是在 vs2013 下编译的,   如果不用vs2013 编译, 那么其他的依赖库, 你也要重新用你当前的vs重新编译, 太麻烦了! 


没关系, vs2010 的工程可以直接用vs2013 工程打开, 打开时候提示某些工程文件要升级, 就升级好 了. 




用vs2013 编译完毕后, (注意,必须编译release 版本哦)


就看到 decoda 了. 
打开decoda.exe,  OK, 不用注册了! 











版权声明：本文为博主原创文章，未经博主允许不得转载。

Mac OS下terminal的快捷键
时隔2年又开始使用Mac OS系统，之前的很多快捷键和常用的命令都忘记了，使用起来确实不方便，效率也低，特别是terminal下，所以对于terminal又找了一下并整理如下，希望对后来的同学也有用：control + a 将光标移到行首control + e 将光标移到行尾control + l 清空屏幕，与clean命令效果相同control + u 清除当前行control + k 清除至当前行尾control + r 查找之前输入过的命令control + z 将当前执行的命令转至后台jobs 查看后台运行的所有命令fg[ n] 将第n（n就是通过jobs看到的编号）个命令转到前台bg[ n] 将第n个命令转到后台

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 开发知识点总结
总结项目开发中的经验，减少类似情况发生，提高开发效率：
示例：
一、布局文件中为TextView设置textColor及background颜色时区别：

background对应selector：


textColor对应的selector：


辨别差异O(∩_∩)O~，避免浪费不必要的开发时间~~


二、RadioGroup+Fragment写底部导航时，RadioGroup中的RadioButton中无法修改drawableTop图片的大小：
如图我觉得边上四个图标的大小不合适，但是又无法改变其大小。




如下setBounds方法可以大致解决该问题，不过可能不是最好的解决方法。

DisplayMetrics dm = new DisplayMetrics();
		this.getWindowManager().getDefaultDisplay().getMetrics(dm);
		int width = dm.widthPixels;
		int height = dm.heightPixels;
		if (width <= 854 && height <= 480) {
			size = 20;
		} else if (width <= 1280 && height <= 720) {
			size = 55;
		} else {
			size = 70;
		}
		radioBtn1 = (RadioButton) radioGroup.getChildAt(0);
		image1 = this.getResources().getDrawable(
				R.drawable.btn_selector_compete);
		image1.setBounds(0, 0, size, size);
		radioBtn1.setCompoundDrawables(null, image1, null, null);

		radioBtn2 = (RadioButton) radioGroup.getChildAt(1);
		image2 = this.getResources().getDrawable(
				R.drawable.btn_selector_message);
		image2.setBounds(0, 0, size, size);
		radioBtn2.setCompoundDrawables(null, image2, null, null);

		radioBtn3 = (RadioButton) radioGroup.getChildAt(2);
		image3 = this.getResources().getDrawable(
				R.drawable.btn_selector_home_unpressed);
		image3.setBounds(0, 0, size, size);
		radioBtn3.setCompoundDrawables(null, image3, null, null);

		radioBtn4 = (RadioButton) radioGroup.getChildAt(3);
		image4 = this.getResources().getDrawable(
				R.drawable.btn_selector_discovery);
		image4.setBounds(0, 0, size, size);
		radioBtn4.setCompoundDrawables(null, image4, null, null);

		radioBtn5 = (RadioButton) radioGroup.getChildAt(4);
		image5 = this.getResources()
				.getDrawable(R.drawable.btn_selector_myself);
		image5.setBounds(0, 0, size, size);
		radioBtn5.setCompoundDrawables(null, image5, null, null);
如有更好的解决方案，欢迎留言噢~







版权声明：本文为博主原创文章，未经博主允许不得转载。

UnityShader实例13:屏幕特效之均值模糊（Box Blur）

均值模糊（Box Blur）





概述





由于公司手游项目需求，需要一个适合手机平台的模糊效果，同时需要开放一个参数便于调节模糊值。我首先想到的就是ps里面的均值模糊。查资料可以知道均值模糊是一种快速的图像模糊技术，相比与传统的卷积模糊（如高斯模糊），均值模糊可以更加有效率的完成对图像模糊。在unity官方自带imageeffect包也有一个blur的屏幕特效，用的就是均值模糊算法，只不过他只采样了离原像素上下左右模糊半径（Blur
 Spread）距离的四个像素进行平均处理。然后做迭代(Iterations)处理，即将模糊后的图像再次采样模糊，迭代次数越高越模糊，同时也会产生更多的drawcall,本文的效果就是从这个例子简化而来，使之适合手游项目，并且傻瓜式方便的调节参数。





原理



均值模糊的原理是通过图形滤波器来把一个像素和周围的像素一起求平均值，比如一个三阶的图像滤波器构造其实就是一个3*3的数组（n阶数组中的元素成为滤波器的系数和滤波器的权重，n称为滤波器的阶），相当于把一个像素和周围8个像素相加在一起再除以9求平均值，等于把一个像素和周围的像素搅拌在一起，自然就模糊了。均值滤波器与高斯模糊的滤波器不同的地方，就是采样的像素权重是相等的，因此效果相对而言要比高斯模糊差，但速度却要快一些。本例其实只采样了四个像素求和做平均，然后通过迭代多次采样，实现比较好的模糊效果。下面是一个三阶的均值滤波器:
      [1,1,1]
1/9 [1,1,1]
[1,1,1]



本例采用的滤波器：
         [0,1,0]
 1/4  [1,0,1]
[0,1,0]












Shader代码实现





shader代码部分相对比较简单，首先需要定义两个内部变量，_MainTex_TexelSize和_BlurOffsets，这两个变量都属于unity的黑魔法，官方文档并没有详细说明，_MainTex_TexelSize的解释可以参考这里，_BlurOffsets这个参数是用来接收从C#脚本里面穿过来的参数，即模糊半径。



		half4 _MainTex_TexelSize;
		half4 _BlurOffsets;



在顶点输入结构体里面定义一个一维四阶数组用来存储uv坐标：




		struct v2f {
			float4 vertex : SV_POSITION;
			half2 texcoord : TEXCOORD0;
			half2 taps[4] : TEXCOORD1; 
		};



在vert函数里面将uv坐标进行偏移获得原像素上下左右偏移_BlurOffsets像素，并存储在taps[]数组里面，传给frag函数






		v2f vert (appdata_t v)
		{
			v2f o;
			o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);
			o.texcoord = v.texcoord - _BlurOffsets.xy * _MainTex_TexelSize.xy;//将C#脚本传过来的图像偏移回原位置
			o.taps[0] = o.texcoord + _MainTex_TexelSize * _BlurOffsets.xy;
			o.taps[1] = o.texcoord - _MainTex_TexelSize * _BlurOffsets.xy;
			o.taps[2] = o.texcoord + _MainTex_TexelSize * _BlurOffsets.xy * half2(1,-1);
			o.taps[3] = o.texcoord - _MainTex_TexelSize * _BlurOffsets.xy * half2(1,-1);
			return o;
			
			
		}



在frag函数使用vert函数传过来的uv坐标数组采样图像然后进行叠加后平均化，以达到模糊效果：





		fixed4 frag (v2f i) : SV_Target
		{
			half4 color = tex2D(_MainTex, i.taps[0]);
			color += tex2D(_MainTex, i.taps[1]);
			color += tex2D(_MainTex, i.taps[2]);
			color += tex2D(_MainTex, i.taps[3]); 
			return color * 0.25;
		}



Shader完整代码


VF版本代码01





Shader "PengLu/ImageEffect/Unlit/BlurBox" {
	Properties {
	_MainTex ("Base (RGB)", 2D) = "white" {}
}

SubShader {	
	Pass {
	  	ZTest Always  	ZWrite Off

		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag
					
		#include "UnityCG.cginc"

		struct appdata_t {
			float4 vertex : POSITION;
			float2 texcoord : TEXCOORD0;
		};

		struct v2f {
			float4 vertex : SV_POSITION;
			half2 texcoord : TEXCOORD0;
			half2 taps[4] : TEXCOORD1; 
		};

		sampler2D _MainTex;
		half4 _MainTex_TexelSize;
		half4 _BlurOffsets;
		
		v2f vert (appdata_t v)
		{
			v2f o;
			o.vertex = mul(UNITY_MATRIX_MVP, v.vertex);
			o.texcoord = v.texcoord - _BlurOffsets.xy * _MainTex_TexelSize.xy;
			o.taps[0] = o.texcoord + _MainTex_TexelSize * _BlurOffsets.xy;
			o.taps[1] = o.texcoord - _MainTex_TexelSize * _BlurOffsets.xy;
			o.taps[2] = o.texcoord + _MainTex_TexelSize * _BlurOffsets.xy * half2(1,-1);
			o.taps[3] = o.texcoord - _MainTex_TexelSize * _BlurOffsets.xy * half2(1,-1);
			return o;
			
			
		}
		
		fixed4 frag (v2f i) : SV_Target
		{
			half4 color = tex2D(_MainTex, i.taps[0]);
			color += tex2D(_MainTex, i.taps[1]);
			color += tex2D(_MainTex, i.taps[2]);
			color += tex2D(_MainTex, i.taps[3]); 
			return color * 0.25;
		}
	ENDCG
	}
}
Fallback off
}






C#脚本代码







C#脚本相对也比较简单，这个脚本主要负责把抓取屏幕并传递参数给shader进行模糊处理，这个脚本是从官方的简化而来，将迭代的次数固定为2，只留下模糊半径一个参数调节。关键的两个函数需要注意下：




            Graphics.BlitMultiTap (source, dest, material,
                                   new Vector2(-off, -off),
                                   new Vector2(-off,  off),
                                   new Vector2( off,  off),
                                   new Vector2( off, -off)
                );




RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);



Graphics.BlitMultiTap函数官方解释在这里 
 ，大概意思是传递多个位图块给shader进行处理，每个位图块有各自的偏移（由vector[]数组决定）。但实际上我测试发现，这个函数传递的位图块是配合固定管线编程使用的，在5.0以下的blur特效shader代码里有以下代码：上面那个函数生成的四个纹理块一次对应下面四个_MainTex,shader代码里面并没有偏移，都是从Graphics.BlitMultiTap传递过来。
SubShader {
        Pass {
            ZTest Always Cull Off ZWrite Off Fog { Mode Off }
            SetTexture [_MainTex] {constantColor (0,0,0,0.25) combine texture * constant alpha}
            SetTexture [_MainTex] {constantColor (0,0,0,0.25) combine texture * constant + previous}
            SetTexture [_MainTex] {constantColor (0,0,0,0.25) combine texture * constant + previous}
            SetTexture [_MainTex] {constantColor (0,0,0,0.25) combine texture * constant + previous}
        }
    }






而在unity5.0的官方blur shader里面已经将固定管线的相关代码删除，而对vert&frag shader编程，它实际上传递了一个uv坐标偏移值为（off，off）的位图块给shader，并将偏移值传给内置变量_BlurOffsets，我们在相关代码里要重新做偏移，才会有偏移效果。因此Graphics.BlitMultiTap我们可以改成：







            Graphics.BlitMultiTap (source, dest, material,new Vector2(off, off) );





RenderTexture.GetTemporary这个函数在这里主要是用来重新设定抓取的屏幕图像的长宽，在本例中我们将长宽设置成原来的8分之1后然后再传递给shader处理，可以是采样计算消耗降低到原来的64分之1，只是因此多消耗一个drawcall。由于还迭代了两次，最后这个屏幕特效需要消耗4个drawcall，当然由于做了个判断，当Blur
 Size为0时，只消耗1个drallcall，不做模糊处理。




完整C#脚本如下：


using UnityEngine;
using System.Collections;
using System;

[ExecuteInEditMode]
[AddComponentMenu ("PengLu/ImageEffect/Blurbox")]
public class ImageEffect_BlurBox : MonoBehaviour {
	#region Variables
	public Shader BlurBoxShader = null;
	private Material BlurBoxMaterial = null;

	[Range(0.0f, 1.0f)]
	public float BlurSize = 0.5f;

	#endregion

	#region Properties

	Material material
	{
		get
		{
			if(BlurBoxMaterial == null)
			{
				BlurBoxMaterial = new Material(BlurBoxShader);
				BlurBoxMaterial.hideFlags = HideFlags.HideAndDontSave;	
			}
			return BlurBoxMaterial;
		}
	}
	#endregion
	// Use this for initialization
	void Start () {

		BlurBoxShader = Shader.Find("PengLu/ImageEffect/Unlit/BlurBox");
		
		// Disable if we don't support image effects
		if (!SystemInfo.supportsImageEffects)
        {
            enabled = false;
            return;
        }

        // Disable the image effect if the shader can't
        // run on the users graphics card
        if (!BlurBoxShader || !BlurBoxShader.isSupported)
            enabled = false;
            return;
	
	}

	public void FourTapCone (RenderTexture source, RenderTexture dest,int iteration)
        {
            float off = BlurSize*iteration+0.5f;
            Graphics.BlitMultiTap (source, dest, material,
                                   new Vector2(-off, -off),
                                   new Vector2(-off,  off),
                                   new Vector2( off,  off),
                                   new Vector2( off, -off)
                );
        }

	private void DownSample4x (RenderTexture source, RenderTexture dest)
        {
            float off = 1.0f;
            // Graphics.Blit(source, dest, material);
            Graphics.BlitMultiTap (source, dest, material,
                                   new Vector2(off, off),
                                   new Vector2(-off,  off),
                                   new Vector2( off,  off),
                                   new Vector2( off, -off)
                );
        }

	void OnRenderImage (RenderTexture sourceTexture, RenderTexture destTexture)
	{	
		if(BlurSize != 0 && BlurBoxShader != null){

			int rtW = sourceTexture.width/8;
	        int rtH = sourceTexture.height/8;
	        RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);

	        DownSample4x (sourceTexture, buffer);

	        for(int i = 0; i < 2; i++)
            {
                RenderTexture buffer2 = RenderTexture.GetTemporary(rtW, rtH, 0);
                FourTapCone (buffer, buffer2,i);
                RenderTexture.ReleaseTemporary(buffer);
                buffer = buffer2;
            }
            Graphics.Blit(buffer, destTexture);

            RenderTexture.ReleaseTemporary(buffer);
		}

		else{
			Graphics.Blit(sourceTexture, destTexture);
			
		}
		
		
	}
	
	// Update is called once per frame
	void Update () {
		#if UNITY_EDITOR
		if (Application.isPlaying!=true)
		{
			BlurBoxShader = Shader.Find("PengLu/ImageEffect/Unlit/BlurBox");

		}
		#endif
	
	}

	 public void OnDisable () {
        if (BlurBoxMaterial)
            DestroyImmediate (BlurBoxMaterial);
    }
}




最终模糊特效效果：









版权声明：本文为博主原创文章，如需转载请指明出处http://blog.csdn.net/u011047171

Android Volley网络通信库学习
Volley
官网
Google IO, Volley: 
Easy, Fast Networking for Android PDF下载地址

设计目的
让网络更快，更简便，更健壮。

适用场景

数据量不大且通信频繁。
ListView显示图片，不必担心OOM。

不适用场景

较大负载数据（large payloads）
流媒体

还需要使用原始的方法，比如Download Manager等。
版本要求
最低SDK版本为Froyo，即至少要设置android:minSdkVersion为8以上。

Get请求
1.下载jar包，导入IDE;或者克隆仓库到本地，然后编译Jar包：
git clone https://android.googlesource.com/platform/frameworks/volley  
2.创建一个请求队列
RequestQueue mQueue = Volley.newRequestQueue(this);
3.创建一个StringRequest：表示将请求的数据转化为字符串返回（Volley自带仅支持String，Image，JsonObject，JsonArray，之后的文章我会介绍自定义请求的实现），然后我们为他设置listener、errorListener：
// (int method, String url, Listener<String> listener, ErrorListener errorListener)

StringRequest stringRequest = new StringRequest(Method.GET,
                "这里输入URL地址", new Listener<String>() {
                    @Override
                    public void onResponse(String response) {
                        // 处理返回请求返回的结果
                    }
                }, new ErrorListener() {
                    @Override
                    public void onErrorResponse(VolleyError error) {
                        // 请求出错，处理出错程序
                    }
                });
将请求加入请求队列中：请求队列允许同时添加多个请求，也就是说，我们一次性可以添加多个请求到请求队列中
mQueue.add(stringRequest);
4.从网络取得JSON对象：
mQueue = Volley.newRequestQueue(getApplicationContext());
mQueue.add(new JsonObjectRequest(Method.GET, url, null,
            new Listener() {
                @Override
                public void onResponse(JSONObject response) {
                    Log.d(TAG, "response : " + response.toString());
                }
            }, null));
mQueue.start();
Post
其他步骤与Get请求一致，在第二步创建Request的时候，我们只要将传入的第一个参数改为 Method.POST； 
如果有Post数据，我们需要重写getParams方法（观察过Volley源码的同学可以看到，源码中getParams函数返回的一个null，所以我们要重写该函数）
StringRequest stringRequest = new StringRequest(Method.POST,
                "这里输入URL地址", new Listener<String>() {
                    @Override
                    public void onResponse(String response) {
                        // 处理返回请求返回的结果
                    }
                }, new ErrorListener() {
                    @Override
                    public void onErrorResponse(VolleyError error) {
                        // 请求出错，处理出错程序
                    }
                }) {
            @Override
            protected Map<String, String> getParams() throws AuthFailureError {
                // 在这里设置需要post的参数
                Map<String, String> params = new HashMap<String, String>();
                params.put("key1", "value1");
                params.put("key2", "value2");
                return params;
            }
        };
图片加载缓存机制
1.创建一个请求队列：
RequestQueue mQueue = Volley.newRequestQueue(this)
图片缓存类：
import android.graphics.Bitmap;
import android.util.LruCache;

import com.android.volley.toolbox.ImageLoader.ImageCache;

class BitmapCache implements ImageCache {
    private LruCache<String, Bitmap> mCache;

    public BitmapCache() {
        // 缓存10M
        int maxSize = 10 * 1024 * 1024;
        mCache = new LruCache<String, Bitmap>(maxSize) {
            @Override
            protected int sizeOf(String key, Bitmap bitmap) {
                return bitmap.getRowBytes() * bitmap.getHeight();
            }
        };
    }

    @Override
    public Bitmap getBitmap(String url) {
        return mCache.get(url);
    }

    @Override
    public void putBitmap(String url, Bitmap bitmap) {
        mCache.put(url, bitmap);
    }
};
创建一个图片加载对象：
ImageLoader imageLoader = new ImageLoader(mQueue, new BitmapCache());
创建图片的监听器
ImageListener listener = ImageLoader.getImageListener(imageView,
                R.drawable.ic_launcher, R.drawable.ic_launcher);
第一个参数表示显示图片的控件，第二个参数表示加载图片时显示的图片，第三个参数表示出错时的图片显示。
加载图片到控件中：
imageLoader.get("http://avatar.csdn.net/A/6/4/1_zhoumushui.jpg",listener);
ImageLoader的方法都需要从主线程里来调用。
NetworkImageView
com.android.volley.NetworkImageView
Volley提供了的一个新控件来代替传统的ImageView：
mImageView.setImageUrl(url, imageLoader)  
这个控件在被从父控件detach的时候，会自动取消网络请求的，即完全不用我们担心相关网络请求的生命周期问题。
示例代码：
mImageLoader = new ImageLoader(mRequestQueue, new BitmapLruCache());  
// ImageLoader构造函数的第二个参数是一个ImageCache的实例（严格来说，是实现ImageCache接口的某具体类的实例）
... ...  

if(holder.imageRequest != null) {  
    holder.imageRequest.cancel();  
}  
holder.imageRequest = mImageLoader.get(BASE_UR + item.image_url, holder.imageView, R.drawable.loading, R.drawable.error);  
架构设计
 
如果在一个Activity里面启动了网络请求，而在这个网络请求还没返回结果的时候，如果Activity被结束了，我们需要做以下处理：
@Override 
public void onPostExecute(Result r) {  
    if (getActivity() == null) {  
        return;  
    }  
    // ...  
} 
Volley里所有的请求结果会返回给主进程，如果在主进程里取消了某些请求，则这些请求将不会被返回给主线程。 
比如，可以针对某些个request做取消操作：
@Override  
public void onStop() {  
    for (Request <?> req : mInFlightRequests) {  
        req.cancel();  
    }  
    ...  
}  

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文原创，转载请注明出处：http://blog.csdn.net/zhoumushui

android button 的clickable 和 enable属性的个人见解
在最近的项目中,需要对一个按钮进行点击和不可点击的状态的切换,偶然发现一个问题,就是button的clickable属性在xml中进行定义为false的话,按钮竟然依然可以触发点击事件,但是在代码中进行设置的话,就不会触发了.表示好奇怪的说, 如果在xml中设置enable属性为false的话,button的click以及longclick就全都不可以响应了,这个倒是正常,这只是一个小问题,不影响正常的使用,写出来记录一下而已

版权声明：本文为博主原创文章，未经博主允许不得转载。

A2DP Sink, AVRCP Controller and HFP Client in Android L
The APIs of A2DP sink, AVRCP controller and HFP client are not published in Android L, but the code which implements the  profiles  is indeed in Android L. You can set the configuration for the car to build the code.
Where is the code?


A2DP sink

/frameworks/base/core/java/android/bluetooth/BluetoothA2dpSink.java
/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkService.java
/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
/packages/apps/Bluetooth/jni/com_android_bluetooth_a2dp_sink.cpp
/hardware/libhardware/include/hardware/bt_av.h

AVRCP controller

/frameworks/base/core/java/android/bluetooth/BluetoothAvrcpController.java
/packages/apps/Bluetooth/src/com/android/bluetooth/avrcp/AvrcpControllerService.java
/packages/apps/Bluetooth/jni/com_android_bluetooth_avrcp_controller.cpp

HFP client

/frameworks/base/core/java/android/bluetooth/BluetoothHeadsetClient.java
/frameworks/base/core/java/android/bluetooth/BluetoothHeadsetClientCall.java
/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientHalConstants.java
/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientService.java
/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java
/packages/apps/Bluetooth/jni/com_android_bluetooth_hfpclient.cpp
/hardware/libhardware/include/hardware/bt_hf_client.h


I does not list the files in bluedroid. You can find the files which are added or modified for A2DP sink, AVRCP controller and HFP client in the layers of BTIF, BTA and BTE(stack directory). An A2DP decoder locates in /external/bluetooth/bluedroid/embdrv/sbc/decoder/.
How to build the code?
Google develops A2DP sink, AVRCP controller and HFP client for Android Auto. car_hammerhead.mk is added in /device/lge/hammerhead/. You must add the product item 'add_lunch_combo car_hammerhead-userdebug' in /device/lge/hammerhead/vendorsetup.sh. Then
 run 'lunch', and select 'car_hammerhead-userdebug'. Now you can build the image of car_hammerhead and flash the image to Nexus 5.
You can used hcitool and sdptool to browse all available services on Nexus 5 with car_hammerhead image.  You should see A2DP sink, AVRCP controller and HFP client in the list of available services. If you want to hear the sound from the speaker of Nexus
 5 with car_hammerhead image, you have to develop the App which uses A2DP sink APIs to trigger the audio routing from from BT stack to speaker. If no App registers a listener to bluedroid, the audio data will be discarded before decoder.

版权声明：本文为博主原创文章，未经博主允许不得转载。

ios真机调试 老是显示输入管理员的用户和密码
这个是因为我们的电脑在使用次操作前的权限设置问题，这样是为了更加高的安全性。


若是觉得麻烦，尤其是在调试的时候，我们可以选择如下操作：
双击苹果发布的验证书，打开“钥匙串访问”，
（图：苹果发布验证书）






在钥匙串中的选择如下：即为修改钥匙串在系统中的权限，




之后进入如下的界面:




即为设置为“允许所有的应用程序访问此项目”即可，然后存储更改就好。



同时也可以参考如下链接：

http://blog.csdn.net/wangtingshuai/article/details/8849995








版权声明：本文为博主原创文章，未经博主允许不得转载。

Android模仿华为长按功能键实现清除内存功能
经常使用华为手机的朋友一定有用到过华为系统，长按右下角菜单键，如果内存可以清除，就会出现一个上拉清除内存的功能界面。之前博客里也提到了，f一直想做出这个效果，琢磨了一段时间，基本做出了雏形，不过做的只是下拉，圆弧从没有到完整闭合的效果，没有融入属性动画（华为系统默认效果有个类似皮球落地反复弹跳的动画），f本身对于动画不感冒，所以没有写进去，如果有人感兴趣，可以在我的基础上添加，同时f也没把具体清除的内存写进去，因为是调用系统的一些简单功能，大家有兴趣可以自己查一下。f旨在学习一下自定义view,viewgroup。这里先膜拜鸿洋大神，他的自定义view我已经连续学习了好多天了，还会一直坚持下去。下面正文开始。

1.简单分析一下，手指必须是触碰最下边的布局，才能实现清除功能，所以我们打算给整个view或者是viewgroup设置onTouchListener，往上拉的时候，圆弧开始出现，当向上滑动的距离，等于圆的直径时，圆弧出现一半，等于两倍直径时，圆弧闭合成为一个完整的圆。超过两倍直径再上拉不会动，松手就清除了内存，如果未超过两倍直径，布局会回去，同时圆弧也消失。 
2.第一步，我们先画圆弧。
public class MyViewOne extends View{

    private int mLastY;
    private int mScreenHeight,mScreenWidth;
    private RectF rectF;
    public static final int mRadius = 50;
    private Paint paint;
    private int startHeight = 50;
    public float sweepAngle = 0;
    private boolean clear;
    private int mStrokenWidth = 2;
    private int viewHeight;


    public MyViewOne(Context context, AttributeSet attrs,float sweepAngle) {
        super(context, attrs);
        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        DisplayMetrics outMetrics = new DisplayMetrics();
        wm.getDefaultDisplay().getMetrics(outMetrics);
        mScreenHeight = outMetrics.heightPixels;
        mScreenWidth = outMetrics.widthPixels;
        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.STROKE);
        paint.setStrokeWidth(mStrokenWidth);//设置画笔末端的宽度
        paint.setStrokeCap(Paint.Cap.ROUND);//设置画笔末端是圆角
        this.sweepAngle = sweepAngle;//圆弧的闭合角度
        Log.i("abc", "sweepAngle:"+sweepAngle);


    }

    public MyViewOne(Context context) {
        this(context, null,0f);

    }

    public MyViewOne(Context context,float sweepAngle){
        this(context,null,sweepAngle);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

    }


    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left,  top,  right,  bottom);
    }

@Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        rectF = new RectF(mScreenWidth/2 - mRadius,startHeight,mScreenWidth/2+mRadius,2*mRadius+startHeight);
        canvas.drawArc(rectF, -90, sweepAngle, false, paint);

    }
这里需要一些自定义view的基础，以及如何画圆弧。需要提醒一下，drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)画圆弧时候，startAngle是圆弧开始的角度，以三点钟为0,六点钟是90，九点钟是180,12点钟是-90，顺时针画弧，sweepAngle是圆弧的角度，也就是开始于结束的角度差，注意是差值，超过360就是圆。

3.分析华为的系统功能，有两段文本提示内存的相关消息，所以我画了一个布局，准备在自定义viewgroup时候，add上去。
public class MyViewGroup extends LinearLayout{

    MyViewOne view;
    private Context context;
    private TextView tvMemory,tvPullToClear;
    private UpdateMemoryListener updateMemoryListener;

    public MyViewGroup(Context context) {
        this(context, null);
    }

    public MyViewGroup(final Context context, AttributeSet attrs) {
        super(context, attrs);
        this.context = context;
        View child = LayoutInflater.from(context).inflate(R.layout.progress , null);
        viewHeight = child.getMeasuredHeight();
        tvMemory = (TextView) child.findViewById(R.id.tv_memory);
        tvPullToClear = (TextView) child.findViewById(R.id.tv_pull_to_clear);
        addView(child);
    }

public void update(float sweepAngle , int dy ){
        if(null != getChildAt(1)){
            removeViewAt(1);
        }//每次加之前，需要把上一个删掉。由于整体是动态add上去的，第一个add的child，下标为0，后面add的MyViewOne下标为1
        //if(updateMemoryListener != null){}需要重写的方法
        view = new MyViewOne(context,null,sweepAngle);
        LinearLayout.LayoutParams lp = new    LayoutParams(LayoutParams.MATCH_PARENT,LayoutParams.WRAP_CONTENT);
        lp.topMargin = 30;
        view.setLayoutParams(lp);
        addView(view);
        scrollTo(0, -dy);//后面做解析
}

public interface UpdateMemoryListener{
        public String updateAvailableMemory();

        public String getTotalMemory();
    }

    public void setUpdateMemoryListener(UpdateMemoryListener updateMemoryListener){
        this.updateMemoryListener = updateMemoryListener;
    }
UpdateMemoryListener这个接口主要是提供内存信息的接口，可以在activity里，给MyViewGroup设置UpdateMemoryListener监听，重写方法，同时要修改一下update方法。我没有用，所以注掉了。 
继承自线性布局，所以需要我们指定布局的排列方法。如果是垂直排列，那么布局就是往下面加，所以后面addview就是加到下面的。 
下面贴progress的布局文件
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent" android:layout_height="match_parent">

    <TextView
        android:layout_marginTop="10dip"
        android:id="@+id/tv_memory"
        android:gravity="center_horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_below="@+id/tv_memory"
        android:id="@+id/tv_pull_to_clear"
        android:layout_marginTop="10dip"
        android:gravity="center_horizontal"
        android:text="向下滑动，清除全部应用"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />


</RelativeLayout>
4.然后怎么用呢？就是写到布局文件，加载到activity中。下面是布局文件
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#e0000000"
    android:id="@+id/rl"
    >

    <com.fjf.pulltoclear.MyViewGroup
        android:orientation="vertical"
        android:id="@+id/my_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"></com.fjf.pulltoclear.MyViewGroup>

</RelativeLayout>
下面是activity
public class MainActivity extends Activity {

    private MyViewGroup view;
    private int mLastY;
    private RelativeLayout rl;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.activity_pulltoclear);
        initViews();
    }

    private void initViews(){
        rl = (RelativeLayout) findViewById(R.id.rl);
        rl.getBackground().setAlpha(100);
        view = (MyViewGroup) findViewById(R.id.my_view);
        view.setUpdateMemoryListener(new UpdateMemoryListener() {

            @Override
            public String updateAvailableMemory() {
                // TODO Auto-generated method stub
                return null;
            }

            @Override
            public String getTotalMemory() {
                // TODO Auto-generated method stub
                return null;
            }
        });

        view.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                int action = event.getAction();
                int y = (int) event.getY();
                switch (action) {
                case MotionEvent.ACTION_DOWN:
                    mLastY = y;
                    return true;
                case MotionEvent.ACTION_MOVE:
                    int dy = y - mLastY;//获得move的距离
                    Log.i("abc", "dy:" + dy);
                    //向下拉
                    if (dy > 0) {
                    //如果下拉的距离未超过两倍直径，即四倍半径
                        if (dy < 4 * MyViewOne.mRadius) {
                            view.update(1.8f * dy, dy);
                        } else {
                    //超过了，就显示一个完整的圆     
                    view.update(360f, 4 * MyViewOne.mRadius);
                        }
//如果往上拉，则不动
                    } else if (dy <= 0) {
                        view.update(0f, 0);
                    }
                    return true;
                case MotionEvent.ACTION_UP:
                //同样判断是下拉
                    if (y - mLastY > 0) {
                    //如果未超过四倍半径，不清理内存，同时布局回到原位，圆弧要消失
                        if (y - mLastY < 4 * MyViewOne.mRadius) {
                            Log.i("abc", "不清除内存");
                            view.update(0f, 0);
                            //否则清除内存，关闭当前界面
                        } else {
                            Log.i("abc", "清除内存");

                            Toast.makeText(MainActivity.this, "内存已经释放", Toast.LENGTH_SHORT).show();
                            finish();
                        }
                    }
                    return true;
                }
                return false;
            }
        });
    }
}   
注意如果要提醒内存，注意UpdateMemoryListener的实现 
touch事件的注解也比较详细，现在解析一下MyViewGroup的update()方法，重点说明滑动和闭合圆弧的角度。
华为系统的实现，滑动距离为直径时候，显示一半圆，滑动距离为两倍直径，显示完整的圆。两种情况，直径与圆弧的比例分别为R:180,2R:360，所以距离：弧度=R：180,我们定了圆的半径为50，所以弧度=180*距离/R，也就是弧度=1.8×距离。至于scroll,更简单了，只调用最基本的api即可，因为是向下滑动，所以scroll传入的值为负即向下滑动，而x轴保持不变，所以调用scrollTo( 0 , -距离);即可，注意，我们向下滑才出发update方法，下滑的距离为正。
基本的解析就是这些，接下来要分享一下f完成这个功能时候遇到的一个问题。
5.问题总结 
f最开始，把事件分发写到了MyViewOne中，而progress布局中的textview是写到mainactivity的布局中，这样的结果是整个界面在滑动的过程中一直抖动，一直抖，当初是用postInvalidate（）方法实现重绘的，f分析认为，可能是由于这些子控件不是一个view或者viewgroup，如果把他们封装到一起，可能就不会抖动。当然现在这种方法和每次根据传入的角度new一个view添加上，我认为这种处理，对于一直抖动的情况可能有效。
而且比较2的是，继承自线性布局，我却没有指定方法，圆弧一直出不来，快郁闷死了，后来去看线性布局的源码才意识到没有指定方向啊。。。
f研究这个控件有一段时间，最开始脑袋有点乱，等f把单独的功能分开以后，有种豁然开朗的感觉，也算是经验吧，对于复杂的内容，分割开，一块块解决，可能更顺利一些。
f也深入学习了鸿洋的自定义view，深入去理解scroller的一些用法，收获真的很多，搞技术还是需要多看多了解啊，见多识广，遇到问题才能分析解决。
博客到这里也算告一段落了吧，有问题可以留言，希望能和大家多多交流~

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Studio 差分升级
下载差分升级包

打开Android Sdudio， Help -> About 查看当前版本, 如下图 
图片里是我升级后的版本号, 所以和TO实际上是一样的. 

点击这里查看最新build版本号, 红线框住部分是最新build的版本好, 如下图 

拼接差分包下载地址格式如下(windows系统) 
https://dl.google.com/android/studio/patches/AI-FROM-TO-patch-win.jar 
其中FROM使用第一步中看到的build版本号(141.2135290)替换, TO使用上一步图片中最新版本号(141.2178183)替换.
使用上步拼接的差分包路径下载差分包.

安装差分包

下载好的差分包一定不要放到Android Studio的安装目录.
Android Studio安装目录下一切内容的修改(包括复制进去的文件), 都要恢复到刚安装时的状态.
关闭Android Studio.
假设Android Studio的安装目录在D:\Software\AndroidStudio.
假设差分包放在D:\Software\ 也就是安装目录的父目录下.
进入CMD并切换目录到差分包所在目录
执行 
java -classpath AI-FROM-TO-patch-win.jar com.intellij.updater.Runner install ./AndroidStudio 
其中./AndroidStudio 是Android Studio的安装目录
打完收功, 重新打开Android Studio 就是升级后的版本了.


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Studio中编码（乱码）问题
﻿﻿
﻿﻿
﻿﻿
解决方案有两种：


① 打开 FIle –> Settings –> Editor –> File Encodings


一般只要设置上方的IDE Encoding和Project Encoding.前者指IDE的编码方式，后者指你的Project的编码。一般都可以设置为UTF-8.但是这样还没有完，这个设置仅仅是在你的Android Studio中显示的编码方式，也就是你在编程过程中看起来的编码。还应该设置编译器的编码方式。


② 在Project 的下面打开Gradle Scripts,然后打开你的Module 的buile.gradle 在其中加入如下代码：
android {
	......

	compileOptions {
		encoding "UTF-8"
	}
}
如果还有其他关于编码的问题，只要对以上的① ②进行GBK等等尝试，肯定可以解决相应问题。

版权声明：本文为博主原创文章，未经博主允许不得转载。

IOS强制屏幕横竖屏相互切换
最近项目要做一个html5电子协议，里面涉及到签名，竖屏签名不够，所以需要把屏幕切换到横屏，签完字后把签字内容返回到竖屏中的方框内，由于项目不上AppStore，只用企业证书打包，所以使用下面方式来实现横竖屏切换功能。bool isPortrait = true;
- (IBAction)changeOri:(id)sender {
    if (isPortrait) {
        if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {
            [[UIDevice currentDevice] performSelector:@selector(setOrientation:) withObject:[NSNumber numberWithInteger:UIInterfaceOrientationLandscapeLeft]];
            isPortrait = false;
        }
    }else{
        if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) {
            SEL selector = NSSelectorFromString(@"setOrientation:");
            NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];
            [invocation setSelector:selector];
            [invocation setTarget:[UIDevice currentDevice]];
            int val = UIDeviceOrientationPortrait;
            //从2开始是因为0 1 两个参数已经被selector和target占用
            [invocation setArgument:&val atIndex:2];
            [invocation invoke];
            isPortrait = true;
        }
    }
}上面那种情况如果没有选中竖屏、横屏左或横屏右的话就会失效，下面方法不会，是通用的方法- (BOOL)shouldAutorotate{
    return NO;
}

bool isPortrait = true;
- (IBAction)changeOri:(id)sender {
    CGFloat duration = [UIApplication sharedApplication].statusBarOrientationAnimationDuration;
    [UIView animateWithDuration:duration animations:^{
        [[UIApplication sharedApplication] setStatusBarOrientation:isPortrait ? UIInterfaceOrientationLandscapeRight : UIInterfaceOrientationPortrait];
        self.navigationController.view.transform = isPortrait ? CGAffineTransformMakeRotation(M_PI_2) : CGAffineTransformIdentity;
        self.navigationController.view.bounds = CGRectMake(self.navigationController.view.bounds.origin.x, self.navigationController.view.bounds.origin.y, self.view.frame.size.height, self.view.frame.size.width);
        isPortrait = !isPortrait;   
    }];
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

opengl es 2.0游戏与图形编程——2.设置图形投影
注意：本文是读书笔记，代码是使用书中sdk的，主要掌握重点知识，别在意小细节
1.两种投影：正交投影（2d，但可使用z，只是透视完全基于当前屏幕比），透视投影（3d）


2.初始设置矩阵
  模型视图矩阵：物体空间 -> （模型）世界空间 ->（视图） 摄像机空间
  拓展：

[视图变换]
  当摄像机的位置和朝向任意时，投影变换及气体类型的变换变得困难。为了简化运算，我们将摄像机变化到世界坐标系原点，并旋转使摄像机的 光轴和世界坐标系z轴正方向一致。
  
  视图变换是从世界坐标系到摄像机坐标系的变换，计算就是将摄像机弄回原点并对齐z轴的变换（也可以是将摄像机从坐标轴原点移动到摄像机当前位置的 逆变换）。

  许多计算都在眼睛坐标系中完成，一个常用的就是光照需要在这个空间中实现，因为眼睛位置决定了光照效果，否则的话，很难实现镜面光。因此我们需要将法线坐标转换到眼睛坐标系中。

  标准向量(Normal vectors)——从对象坐标系(Object coordinates)变换到视觉坐标系(eye coordinates)，它是用来计算光照(lighting calculation)的.注意标准向量(Normal vectors)的变换和顶点的不同。其中视觉矩阵(view matrix)是GL_MODELVIEW逆矩阵的转置矩阵和标准向量（Normal vector是）相乘所得。
  代码：


	GFX_set_matrix_mode( MODELVIEW_MATRIX );
	
	GFX_load_identity();

    vec3 e = {0.0f, -3.0f, 0.0f},
    c = {0.0f, 0.0f, 0.0f},
    u = {0.0f, 0.0f, 1.0f};
    
    GFX_look_at(&e, &c, &u);
    
    static float y = 0.0f;
    y += 0.1f;
    GFX_translate(0.0f, y, 0.0f);
    GFX_rotate(y * 50.0f, 1.0f, 1.0f, 1.0f);
  投影矩阵：摄像机空间 -> 裁减空间（视锥空间）


// 2d
        GFX_set_orthographic((float)height / (float)width, 5.0f, (float)width / (float)height, 1.0f, 100.0f, 0.0f);
        
        // 3d
        GFX_set_perspective(45.0f, (float)width / (float)height, 0.01f, 100.0f, 0.0f);
3.使用着色器
  
program = PROGRAM_init( ( char * )"default" );
	
	program->vertex_shader = SHADER_init( VERTEX_SHADER, GL_VERTEX_SHADER );
   
	program->fragment_shader = SHADER_init( FRAGMENT_SHADER, GL_FRAGMENT_SHADER );	
	
	m = mopen( VERTEX_SHADER, 1 );
	
	if( m ) {
	
		if( !SHADER_compile( program->vertex_shader,
						     ( char * )m->buffer,
							 DEBUG_SHADERS ) ) exit( 1 );
	}
	m = mclose( m );

	m = mopen( FRAGMENT_SHADER, 1 );
	
	if( m ) {
	
		if( !SHADER_compile( program->fragment_shader,
						     ( char * )m->buffer,
						     DEBUG_SHADERS ) ) exit( 2 ); 
	}
	  
	m = mclose( m );

   if( !PROGRAM_link( program, DEBUG_SHADERS ) ) exit( 3 );  上面创建了一个着色器程序，并读取和编译了顶点着色器和片段着色器，然后链接了这个着色器程序。

  下面是绘制时的代码：

if( program->pid ) {
	
		char attribute, uniform;
		
		glUseProgram( program->pid );
	
		uniform = PROGRAM_get_uniform_location( program, ( char * )"MODELVIEWPROJECTIONMATRIX" );
		glUniformMatrix4fv( uniform,
				1 /* How many 4x4 matrix */,
				GL_FALSE /* Transpose the matrix? */, 
			<span style="white-space:pre">	</span>( float * )GFX_get_modelview_projection_matrix() );		

		attribute = PROGRAM_get_vertex_attrib_location( program, ( char * )"POSITION" );
		glEnableVertexAttribArray( attribute );
		glVertexAttribPointer( attribute, 3, GL_FLOAT, GL_FALSE, 0, POSITION );
	
		attribute = PROGRAM_get_vertex_attrib_location( program, ( char * )"COLOR" );
		glEnableVertexAttribArray( attribute );
		glVertexAttribPointer( attribute, 4, GL_FLOAT, GL_FALSE, 0, COLOR );

		glDrawArrays( GL_TRIANGLE_STRIP, 0, 4 );
	}		  先使用来该着色器程序，获取其中定义的全局uniform变量 MODELVIEWPROJECTION 的地址location，并设置其值。

  同理设置了要绘制的顶点多两个属性的值（数组），属性值如下：

	static const float POSITION[ 12 ] = {
	-0.5f, 0.0f, -0.5f, // Down left (pivot point)
	0.5f, 0.0f, -0.5f, // Up left
	-0.5f, 0.0f, 0.5f, // Down right
	0.5f, 0.0f, 0.5f  // Up right
	};
	
	static const float COLOR[ 16 ] = {
	1.0f, 0.0f, 0.0f, 1.0f, // Red
	0.0f, 1.0f, 0.0f, 1.0f, // Green
	0.0f, 0.0f, 1.0f, 1.0f, // Blue
	1.0f, 1.0f, 0.0f, 1.0f  // Yellow
	};	  设置好变量和值后就提交渲染了。



4.着色器代码
  顶点着色器：

uniform mediump mat4 MODELVIEWPROJECTIONMATRIX;

attribute mediump vec4 POSITION;

attribute lowp vec4 COLOR;

varying lowp vec4 color;

void main( void ) {

	gl_Position = MODELVIEWPROJECTIONMATRIX * POSITION;

	color = COLOR;

}  主要就是把cpp里传来的顶点位置属性 左乘了 模型视图 投影矩阵，即被变换到裁剪空间了，并用gl_Position输出。然后给片段着色器传递了一个color变量（varying标记）。

  片段着色器：


varying lowp vec4 color;

void main( void ) {

	gl_FragColor = color;

}  直接输出顶点着色器传来的颜色值。

  最终效果如下：



5.看下cocos2dx
  设置矩阵：

case Projection::_2D:
        {
            loadIdentityMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);

            Mat4 orthoMatrix;
            Mat4::createOrthographicOffCenter(0, size.width, 0, size.height, -1024, 1024, &orthoMatrix);
            multiplyMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, orthoMatrix);
            loadIdentityMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
            break;
        }
            
        case Projection::_3D:
        {
            float zeye = this->getZEye();

            Mat4 matrixPerspective, matrixLookup;

            loadIdentityMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION);

            // issue #1334
            Mat4::createPerspective(60, (GLfloat)size.width/size.height, 10, zeye+size.height/2, &matrixPerspective);

            multiplyMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, matrixPerspective);

            Vec3 eye(size.width/2, size.height/2, zeye), center(size.width/2, size.height/2, 0.0f), up(0.0f, 1.0f, 0.0f);
            Mat4::createLookAt(eye, center, up, &matrixLookup);
            multiplyMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_PROJECTION, matrixLookup);
            
            loadIdentityMatrix(MATRIX_STACK_TYPE::MATRIX_STACK_MODELVIEW);
            break;
        }  默认是3d方式，投影矩阵里已经乘了一个往屏幕中心看的摄像机矩阵了。

  节点的模型视图矩阵：

Mat4 Node::transform(const Mat4& parentTransform)
{
    return parentTransform * this->getNodeToParentTransform();
}  这个会传递给渲染命令RenderCommand使用，比如：


void TrianglesCommand::useMaterial() const
{
    //Set texture
    GL::bindTexture2D(_textureID);
    
    //set blend mode
    GL::blendFunc(_blendType.src, _blendType.dst);
    
    _glProgramState->apply(_mv);
}  被着色器程序状态ProgramState作为内置的全局变量CC_MVMatrix  （还有类似的CC_MVPMatrix）传递给其着色器代码使用。
  着色器代码：


const char* ccPositionColor_vert = STRINGIFY(

attribute vec4 a_position;
attribute vec4 a_color;

\n#ifdef GL_ES\n
varying lowp vec4 v_fragmentColor;
\n#else\n
varying vec4 v_fragmentColor;
\n#endif\n

void main()
{
    gl_Position = CC_MVPMatrix * a_position;
    v_fragmentColor = a_color;
}
);
const char* ccPositionColor_frag = STRINGIFY(

\n#ifdef GL_ES\n
precision lowp float;
\n#endif\n

varying vec4 v_fragmentColor;

void main()
{
    gl_FragColor = v_fragmentColor;
}
);



  

版权声明：本文为博主原创文章，未经博主允许不得转载。

Unity物体上下反复漂浮效果
using UnityEngine;
using System.Collections;
// 主界面的开始按钮使用该脚本，控制上下来回浮动
public class Floating : MonoBehaviour {
	float radian = 0; // 弧度
	float perRadian = 0.03f; // 每次变化的弧度
	float radius = 0.8f; // 半径
	Vector3 oldPos; // 开始时候的坐标
	// Use this for initialization
	void Start () {
		oldPos = transform.position; // 将最初的位置保存到oldPos
	}
	
	// Update is called once per frame
	void Update () {
		radian += perRadian; // 弧度每次加0.03
		float dy = Mathf.Cos(radian) * radius; // dy定义的是针对y轴的变量，也可以使用sin，找到一个适合的值就可以
		transform.position = oldPos + new Vector3 (0, dy, 0);
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS UIApplication功能十分强大的openURL方法

UIApplication *app = [UIApplication shareApplication];
1>.打电话
        [app openURL:[NSURL URLWithString:@"tel://10086"]];
2>.发短信
       [app openURL:[NSURL URLWithString:@"sms://10086"]];
3>.发邮件
     [app openURL:[NSURL URLWithString:@"mailto://****@qq.com"]];
4>.打开一个网页
    [app openURL:[NSURL URLWithString:@"http://www.baidu.com"]];
5>.打开其他app程序
   ……

版权声明：本文为博主原创文章，未经博主允许不得转载。

cocos2dx3.X shader使图片置灰
1 OpenGL ES着色器
opengl es的着色器有.fsh和.vsh两个文件。这两个文件在被编译和链接后就可以产生可执行程序与GPU交互。attribute是从外部传进来的，每一个顶点都会有这两个属性，所以它也叫做vertex attribute（顶点属性）。而varying类型的变量是在vertex shader和fragment shader之间传递数据用的。
.vsh 是 vertex shader，用与顶点计算，可以理解控制顶点的位置，在这个文件中我们通常会传入当前顶点的位置，和纹理的坐标。新建gray.vsh文件。
attribute vec4 a_position;
attribute vec2 a_texCoord;
attribute vec4 a_color;
					
varying vec4 v_fragmentColor;
varying vec2 v_texCoord;
								
void main()	
{							
    gl_Position = CC_PMatrix * a_position;
	v_fragmentColor = a_color;
	v_texCoord = a_texCoord;
}
gray.fsh 是片段shader。在这里面我可以对于每一个像素点进行重新计算。
varying vec4 v_fragmentColor;	
varying vec2 v_texCoord;	
		
void main()			
{
	vec4 v_orColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord);
	float gray = dot(v_orColor.rgb, vec3(0.299, 0.587, 0.114));
	gl_FragColor = vec4(gray, gray, gray, v_orColor.a);
}		
两个文件放在resource文件夹下。

2 使图片置灰
void HelloWorld::sprAddGray(Sprite * sprite)
{
	if (sprite)
	{
		GLProgram * p = new GLProgram();
		p->initWithFilenames("gray.vsh", "gray.fsh");
		p->bindAttribLocation(GLProgram::ATTRIBUTE_NAME_POSITION, GLProgram::VERTEX_ATTRIB_POSITION);
		p->bindAttribLocation(GLProgram::ATTRIBUTE_NAME_COLOR, GLProgram::VERTEX_ATTRIB_COLOR);
		p->bindAttribLocation(GLProgram::ATTRIBUTE_NAME_TEX_COORD, GLProgram::VERTEX_ATTRIB_TEX_COORDS);
		p->link();
		p->updateUniforms();
		sprite->setShaderProgram(p);
	}
}
3 使图片还原
void HelloWorld::sprRemoveGray(CCSprite * sprite)
{
	if (sprite !=NULL)
	{
		std::string str = "ShaderPositionTextureColor_noMVP";
		CCGLProgram * pProgram = CCShaderCache::sharedShaderCache()->programForKey(str);
		sprite ->setShaderProgram(pProgram);
		CHECK_GL_ERROR_DEBUG();
	} 
}

4 运行效果
程序中响应按钮代码如下，形成灰色与彩色图交替显示。
void HelloWorld::onBtnColorChange(Ref* MyRef)
{
	static int idx = 0;
	if (idx % 2 == 0)
	{
		sprAddGray(m_spr);
	}
	else
	{
		sprRemoveGray(m_spr);
	}
	idx++;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

Tigase开发笔记1：深入认识XMPP协议
要学习基于XMPP协议的IM开发，首先要熟悉XMPP协议本身。




XMPP协议的组成

主要的XMPP 协议范本及当今应用很广的XMPP 扩展：

RFC 3920 XMPP：核心。定义了XMPP 协议框架下应用的网络架构，引入了XML Stream（XML 流）与XML
 Stanza（XML 节），并规定XMPP 协议在通信过程中使用的XML 标签。使用XML 标签从根本上说是协议开放性与扩展性的需要。此外，在通信的安全方面，把TLS 安全传输机制与SASL 认证机制引入到内核，与XMPP 进行无缝的连接，为协议的安全性、可靠性奠定了基础。Core 文档还规定了错误的定义及处理、XML 的使用规范、JID（Jabber Identifier，Jabber 标识符）的定义、命名规范等等。所以这是所有基于XMPP 协议的应用都必需支持的文档。

RFC 3921：用户成功登陆到服务器之后，发布更新自己的在线好友管理、发送即时聊天消息等业务。所有的这些业务都是通过三种基本的XML
 节来完成的：IQ Stanza（IQ 节）, Presence Stanza（Presence 节）, Message Stanza（Message 节）。RFC3921 还对阻塞策略进行了定义，定义是多种阻塞方式。可以说，RFC3921 是RFC3920 的充分补充。两个文档结合起来，就形成了一个基本的即时通信协议平台，在这个平台上可以开发出各种各样的应用。

XEP-0030 服务搜索。一个强大的用来测定XMPP 网络中的其它实体所支持特性的协议。

XEP-0115 实体性能。XEP-0030 的一个通过即时出席的定制，可以实时改变交变广告功能。

XEP-0045 多人聊天。一组定义参与和管理多用户聊天室的协议，类似于Internet 的Relay Chat，具有很高的安全性。

XEP-0096 文件传输。定义了从一个XMPP 实体到另一个的文件传输。

XEP-0124 HTTP 绑定。将XMPP 绑定到HTTP 而不是TCP，主要用于不能够持久的维持与服务器TCP 连接的设备。

XEP-0166 Jingle。规定了多媒体通信协商的整体架构。

XEP-0167 Jingle Audio Content Description Format。定义了从一个XMPP 实体到另一个的语音传输过程。

XEP-0176 Jingle ICE（Interactive Connectivity Establishment）Transport。ICE传输机制，文件解决了如何让防火墙或是NAT（Network
 Address Translation）保护下的实体建立连接的问题。

XEP-0177 Jingle Raw UDP Transport。纯UDP 传输机制，文件讲述了如何在没有防火墙且在同一网络下建立连接的。

XEP-0180 Jingle Video Content Description Format。定义了从一个XMPP 实体到另一个的视频传输过程。

XEP-0181 Jingle DTMF（Dual Tone Multi-Frequency）。

XEP-0183 Jingle Telepathy Transport Method。




XMPP协议网络架构

XMPP是一个典型的C/S架构，而不是像大多数即时通讯软件一样，使用P2P客户端到客户端的架构，也就是说在大多数情况下，当两个客户端进行通讯时，他们的消息都是通过服务器传递的(也有例外，例如在两个客户端传输文件时)．采用这种架构，主要是为了简化客户端，将大多数工作放在服务器端进行，这样，客户端的工作就比较简单，而且，当增加功能时，多数是在服务器端进行．XMPP服务的框架结构如下图所示．XMPP中定义了三个角色，XMPP客户端，XMPP服务器、网关．通信能够在这三者的任意两个之间双向发生．服务器同时承担了客户端信息记录、连接管理和信息的路由功能．网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS(短信)、MSN、ICQ等．基本的网络形式是单客户端通过TCP／IP连接到单服务器，然后在之上传输XML，工作原理是：

(1)节点连接到服务器；(2)服务器利用本地目录系统中的证书对其认证；(3)节点指定目标地址，让服务器告知目标状态；(4)服务器查找、连接并进行相互认证；(5)节点之间进行交互．




XMPP客户端

XMPP 系统的一个设计标准是必须支持简单的客户端。事实上，XMPP 系统架构对客户端只有很少的几个限制。一个XMPP 客户端必须支持的功能有：

1. 通过 TCP 套接字与XMPP 服务器进行通信；

2. 解析组织好的 XML 信息包；

3. 理解消息数据类型。

XMPP 将复杂性从客户端转移到服务器端。这使得客户端编写变得非常容易，更新系统功能也同样变得容易。XMPP 客户端与服务端通过XML 在TCP 套接字的5222 端口进行通信，而不需要客户端之间直接进行通信。

基本的XMPP 客户端必须实现以下标准协议（XEP-0211）：

RFC3920 核心协议Core

RFC3921 即时消息和出席协议Instant Messaging and Presence

XEP-0030 服务发现Service Discovery

XEP-0115 实体能力Entity Capabilities

 

XMPP服务器

XMPP 服务器遵循两个主要法则：

l  监听客户端连接，并直接与客户端应用程序通信；

l  与其他 XMPP 服务器通信；

XMPP开源服务器一般被设计成模块化，由各个不同的代码包构成，这些代码包分别处理Session管理、用户和服务器之间的通信、服务器之间的通信、DNS（Domain Name System）转换、存储用户的个人信息和朋友名单、保留用户在下线时收到的信息、用户注册、用户的身份和权限认证、根据用户的要求过滤信息和系统记录等。另外，服务器可以通过附加服务来进行扩展，如完整的安全策略，允许服务器组件的连接或客户端选择，通向其他消息系统的网关。

基本的XMPP 服务器必须实现以下标准协议

RFC3920 核心协议Core

RFC3921 即时消息和出席协议Instant Messaging and Presence

XEP-0030 服务发现Service Discovery

 

 XMPP网关

XMPP 突出的特点是可以和其他即时通信系统交换信息和用户在线状况。由于协议不同，XMPP 和其他系统交换信息必须通过协议的转换来实现，目前几种主流即时通信协议都没有公开，所以XMPP 服务器本身并没有实现和其他协议的转换，但它的架构允许转换的实现。实现这个特殊功能的服务端在XMPP 架构里叫做网关(gateway)。目前，XMPP
 实现了和AIM、ICQ、IRC、MSN Massager、RSS0.9 和Yahoo Massager 的协议转换。由于网关的存在，XMPP 架构事实上兼容所有其他即时通信网络，这无疑大大提高了XMPP 的灵活性和可扩展性。

 

XMPP地址格式

一个实体在XMPP网络结构中被称为一个接点，它有唯一的标示符jabber identifier(JID)，即实体地址，用来表示一个Jabber用户，但是也可以表示其他内容，例如一个聊天室．一个有效的JID包括一系列元素：(1)域名(domain
 identifier)；(2)节点(node identifier)；(3)源(resource identifier)．它的格式是node@domain/resource，node@domain，类似电子邮件的地址格式．domain用来表示接点不同的设备或位置，这个是可选的，例如a在Server1上注册了一个用户，用户名为doom，那么a的JID就是doom@serverl，在发送消息时，指明doom@serverl就可以了，resource可以不用指定，但a在登录到这个Server时，fl的JID可能是doom@serverl、exodus(如果a用Exodus软件登录)，也可能是doom@serverl/psi(如果a用psi软件登录)．资源只用来识别属于用户的位置或设备等，一个用户可以同时以多种资源与同一个XMPP服务器连接。

XMPP消息格式
XMPP中定义了3个顶层XML元素: Message、Presence、IQ，下面针对这三种元素进行介绍。




<Message>

用于在两个jabber用户之间发送信息。Jsm(jabber会话管理器)负责满足所有的消息，不管目标用户的状态如何。如果用户在线jsm立即提交;否则jsm就存储。

To :标识消息的接收方。

from : 指发送方的名字或标示(id)o

Text: 此元素包含了要提交给目标用户的信息。

结构如下所示:

<message to= ‘lily@jabber.org/contact’ type
 =’chat’>

<body> 你好，在忙吗</body>

</message>







 <Presence>

用来表明用户的状态，如：online、away、dnd(请勿打扰)等。当用户离线或改变自己的状态时，就会在stream的上下文中插入一个Presence元素，来表明自身的状态．结构如下所示：

<presence>

From =‘lily @ jabber.com/contact’

To = ‘yaoman @ jabber.com/contact'

<status> Online </status>

</presence>

<presence>元素可以取下面几种值:

Probe :用于向接受消息方法发送特殊的请求

subscribe:当接受方状态改变时，自动向发送方发送presence信息。

 

< IQ >

一种请求／响应机制，从一个实体从发送请求，另外一个实体接受请求，并进行响应．例如，client在stream的上下文中插入一个元素，向Server请求得到自己的好友列表，Server返回一个，里面是请求的结果．

<iq > 主要的属性是type。包括:

Get :获取当前域值。

Set :设置或替换get查询的值。

Result :说明成功的响应了先前的查询。

Error: 查询和响应中出现的错误。

结构如下所示:

<iq from =‘lily @ jabber.com/contact’id=’1364564666’ Type=’result’>


另外协议中还有一些概念需要重复一下，便于理解!


什么是stanza（节）？
消息节点（类似于xml中的节点元素），可以理解为各种各样的消息节点(plugin可以对这些自定义消息进行针对性识别和处理).

RFC 3920 XMPP：核心。定义了XMPP 协议框架下应用的网络架构，引入了XML Stream（XML
 流）与XML Stanza（XML 节），并规定XMPP 协议在通信过程中使用的XML 标签。使用XML 标签从根本上说是协议开放性与扩展性的需要。此外，在通信的安全方面，把TLS 安全传输机制与SASL 认证机制引入到内核，与XMPP 进行无缝的连接，为协议的安全性、可靠性奠定了基础。Core 文档还规定了错误的定义及处理、XML 的使用规范、JID（Jabber Identifier，Jabber
 标识符）的定义、命名规范等等。所以这是所有基于XMPP 协议的应用都必需支持的文档。


RFC 3921：用户成功登陆到服务器之后，发布更新自己的在线好友管理、发送即时聊天消息等业务。所有的这些业务都是通过三种基本的XML 节来完成的：IQ
 Stanza（IQ 节）, Presence Stanza（Presence 节）, Message Stanza（Message 节）。RFC3921 还对阻塞策略进行了定义，定义是多种阻塞方式。可以说，RFC3921 是RFC3920 的充分补充。两个文档结合起来，就形成了一个基本的即时通信协议平台，在这个平台上可以开发出各种各样的应用。




什么是JID？


XMPP的地址叫做JabberID（简写为JID），它用来标示XMPP网络中的各个XMPP实体。JID由三部分组成：domain，node identifier和resource。JID中domain是必不可少的部分。注意：domain和user部分是不分大小写的，但是resource区分大小写。

jid = [ node "@" ] domain [ "/" resource ]  
domain = fqdn / address-literal  
fqdn = (sub-domain 1*("." sub-domain))  
sub-domain = (internationalized domain label)  
address-literal = IPv4address / IPv6address  

domain：通常指网络中的网关或者服务器。
node identifier：通常表示一个向服务器或网关请求和使用网络服务的实体(比如一个客户端),当然它也能够表示其他的实体(比如在多用户聊天系统中的一个房间)。
resource：通常表示一个特定的会话（与某个设备），连接（与某个地址），或者一个附属于某个节点ID实体相关实体的对象（比如多用户聊天室中的一个参加者）。


JID种类有：


bare JID：user@domain.tldfull JID：user@domain.tld/resource
例子：

stpeter@jabber.org：表示服务器jabber.org上的用户stpeter。 

room@service：一个用来提供多用户聊天服务的特定的聊天室。这里 “room“ 是聊天室的名字， ”service“ 是多用户聊天服务的主机名。 

room@service/nick：加入了聊天室的用户nick的地址。这里 “room“ 是聊天室的名字， ”service“ 是多用户聊天服务的主机名，”nick“ 是用户在聊天室的昵称。 



为了标示JID，XMPP也有自己的URI，例如xmpp:stpeter@jabber.org，默认规则是在JID前加 xmpp:。



-------------------------------------------------------------------------------------------------------------------








一个基本的IM具备以下功能

1、用户系统：用户注册、登录、添加好友、删除好友、好友列表、支持上传头像、可以修改个人信息、名称、性别、地区、签名、黑名单功能、拉入黑名单将无法收到对方的信息、查看好友当前地理位置。
2、聊天系统：发送文字、图片、语音、表情。语音聊天可以显示时长、未读状态，自动轮播未读语音；
3、群聊系统：建立房间、加入房间、删除房间、房间列表、群聊、屏蔽群消息功能、邀请、踢出好友(只有房主才有这个功能)。并有操作日志实时显示在房间中
4、附近人功能：根据筛选条件查看附近的人，查看用户时能显示位置
5、朋友圈：支持发送文本、图片、语音、视频或以上混合消息，支持好友进行赞、评论、转发、送礼物等操作，并且可以根据消息显示粉丝贡献值。


版权声明：本文为博主原创文章，未经博主允许不得转载。

嵌入式Linux网络编程 之 多线程聊天
题目要求：编写一个网络聊天程序，要求采用数据流的套接口编程
程序分为服务端与客户端
服务端最大同时连接10个客户端
服务端可以响应多个客户端的请求，每个客户端直接可以相互通信，由服务器实现转发。服务器端显示所有客户端的通信
客户端通过用户名实现不同用户间的通信（发送消息格式：用户名 消息内容）


服务器代码：
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <pthread.h>
#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <errno.h>

#define PORT 8848//为服务端定义一个端口
#define BACKLOG 10//服务端最大的连接数
#define BUFFER 1024
#define MAXUSER 9

int select_user(char name);
void process_cli(int fd, struct sockaddr_in client);
void* creat_conn(void* arg);

struct _tag_arg{
	int fd;
	struct sockaddr_in client;
};

/*全局用户列表*/
struct _tag_user{
	char name;
	int fd;
}user[MAXUSER+1];

static int u_len = 0;

int main(int argc, char *argv[])
{
	int sockfd, listenfd;
	struct sockaddr_in s_addr;
	struct sockaddr_in c_addr;
	int size;
	int opt;//设置socket的状态的参数
	struct _tag_arg *arg;//传入线程的参数（不止一个变量）
	pthread_t thread;
	
	/*创建套接字*/
	if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
	{
		fprintf(stderr, "Sock Error: %s", strerror(errno));
		exit(1);
	}
	printf("socket...\n");
	
	opt = SO_REUSEADDR;
	/*设置套接字允许重用本地地址和端口*/
	setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
	
	bzero(&s_addr, sizeof(s_addr));
	s_addr.sin_family = AF_INET;
	s_addr.sin_port = htons(PORT);
	s_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	
	/*绑定套接字与描述符*/
	if(bind(sockfd, (struct sockaddr*)&s_addr, sizeof(s_addr)) == -1)
	{
		fprintf(stderr, "bind error: %s", strerror(errno));
		exit(1);
	}
	printf("Bind...\n");
	
	/*监听连接*/
	if(listen(sockfd, BACKLOG) < 0)
	{
		fprintf(stderr, "Listen Error: %s", strerror(errno));
		exit(1);
	}
	printf(" listen...\n");
	
	while(1)
	{
		size = sizeof(struct sockaddr);
		
		/*阻塞服务器，获取连接*/
		printf("  accept...\n");
		if((listenfd =  accept(sockfd, (struct sockaddr*)&c_addr, &size)) < 0)
		{
			fprintf(stderr, "accept error: %s", strerror(errno));
			exit(1);
		}
		
		/*填充传入线程的参数*/
		printf("Creat pthread arg\n");
		arg = malloc(sizeof(struct _tag_arg));
		arg->fd = listenfd;
		memcpy((void*)&(arg->client), &c_addr, sizeof(c_addr));
		
		/*创建线程*/
		if(pthread_create(&thread, NULL, creat_conn, (void*)arg))
		{
			fprintf(stderr, "Creat thread failed!: %s", strerror(errno));
			break;		
		}
	}
	close(sockfd);
	exit(0);
}

void* creat_conn(void* arg)
{
	int tid = pthread_self();
	struct _tag_arg *n_arg = arg;
	
	process_cli(n_arg->fd, n_arg->client);
}

void process_cli(int fd, struct sockaddr_in client)
{
	int num, i, ufd;
	char recvbuf[BUFFER], sendbuf[BUFFER];
	char name;
	
	int tid = pthread_self();
	/*打印客户IP*/
	printf("Client Ip: %s\n", inet_ntoa(client.sin_addr));

	/*添加用户到全局用户表中*/
	user[u_len].fd = fd;
	user[u_len].name = 'a' + u_len;
	
	/*打印新增的用户*/
	printf("user: %c, fd: %d\n", user[u_len].name, user[u_len].fd);
	
	if(u_len++ > MAXUSER) u_len = 0;
	
	while(1)
	{
		memset(recvbuf, 0, BUFFER);
		/*等待接收数据*/
		num = recv(fd, recvbuf, BUFFER, 0);
		printf("num = %d\n", num);
		if(num == 0 || num == -1)
		{
			close(fd);
			perror("Client disconnected.\n");
			break;
		}
		
		printf("[%d] INFO:%s\n", tid, recvbuf);
		fflush(stdout);
		
		/*获得客户端的用户名*/
		name = recvbuf[0];
		/*用户名为x, 则进行群发*/
		if(name == 'x')
		{
			for(i=0; i<=MAXUSER; i++)
			{
				if(user[i].fd > 0)
				send(user[i].fd, recvbuf, strlen(recvbuf), 0);
			}
		}
		/*选出要转发到的用户*/
		ufd = select_user(name);
		
		if(ufd > 0)
		{
			send(ufd, recvbuf, strlen(recvbuf), 0);
		}
		
		
	}
}

int select_user(char name)
{
	int i;
	int ret_fd = 0;
	
	for(i=0; i<= MAXUSER; i++)
	{
		if(user[i].name == name)
		ret_fd = user[i].fd;
	}
	
	return ret_fd;
}


客户端代码：
#include <stdio.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <errno.h>
#include <stdlib.h>
#include <pthread.h>

#define PORT 8848//服务端定义的端口
#define BUFFER 1024

void* send_pro(void*);
void* recv_pro(void*);
int get_line(char* msg);

int main(int argc, char* argv[])
{
	int sockfd;
	char* default_ip = "127.0.0.1";
	struct sockaddr_in s_addr;
	struct hostent* he;
	pthread_t th1, th2;
	
	if(argc != 2)
	{
		/*gethostbyname()函数现已被替代*/
		if((he = gethostbyname(default_ip)) == NULL)
		{
			perror("gethostbyname(default_ip) error\n");
			exit(1);
		}
	}
	else
	{
		if((he = gethostbyname(argv[1])) == NULL)
		{
			perror("gethostbyname(argv[1]) error\n");
			exit(1);
		}
	}

	/*创建套接字*/
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	
	if(sockfd < 0)
	{
		fprintf(stderr, "socket() error : %s", strerror(errno));
		exit(1);
	}
	/*填充服务器地址*/
	bzero(&s_addr, sizeof(s_addr));
	s_addr.sin_family = AF_INET;
	s_addr.sin_port = htons(PORT);
	s_addr.sin_addr = *((struct in_addr *)he->h_addr);
	
	/*连接服务器*/
	if(connect(sockfd, (struct sockaddr*)&s_addr, sizeof(s_addr)) == -1)
	{
		fprintf(stderr, "connect() error : %s", strerror(errno));
		exit(1);
	}
	
	/*创建接收线程*/
	if(pthread_create(&th1, NULL, recv_pro, (void*)&sockfd))
	{
		perror("recv pthread_create() error");
		close(sockfd);
		exit(1);
	}
	/*创建发送线程*/
	if(pthread_create(&th2, NULL, send_pro, (void*)&sockfd))
	{
		perror("send pthread_create() error");
		close(sockfd);
		exit(1);
	}
	
	pthread_join(th1, NULL);
	pthread_join(th2, NULL);
	exit(0);
}

void* send_pro(void* arg)
{
	char send_l[BUFFER];
	int n;
	int len;
	int sockfd = *((int *)arg);
	
	printf("send to server\n");
	
	while(1)
	{
		while((len = get_line(send_l)) != 0)
		{
			send(sockfd, send_l, strlen(send_l), 0);
		}
	}
}

void* recv_pro(void* arg)
{
	char recv_l[BUFFER];
	int n;
	int sockfd = *((int *)arg);
	
	printf("recv from server\n");
	
	while(1)
	{
		if((n = recv(sockfd, recv_l, BUFFER, 0)) > 0)
		{
			recv_l[n] = 0;
			printf("\n[recvice] %s\n", recv_l);
			/*清空接收缓冲区*/
			memset(recv_l, 0, strlen(recv_l) - 1);
		}
		else
		{
			printf("revice error\n");
		}
		
		
	}
}

int get_line(char* msg)
{
	int i = 0;
	char temp;
	printf("Please input message:");
	fflush(stdout);
	while(1)
	{
		temp = getchar();
		if(temp == '\r' || temp == '\n')
		{return i;}
		msg[i] = temp;
		/*回车发送*/
		if(msg[i] == 13)
		{
			break;
		}
		fflush(stdout);
		i++;
	}
}





实现效果：
服务器：



客户端a收到客户端b 的信息:
a:



b:





服务器实现细节及遇到的问题：
1> setsockopt : 获取或者设置与某个套接字关联的选项。参看博客：http://blog.csdn.net/l_yangliu/article/details/7086256#reply
2> 线程：创建线程 pthread_creat()
编译代码时，出现错误: undefined reference to pthread_create 产生了连接错误。但是明明包含了该函数所需要的头文件<pthread.h>?
原因: pthread库不是Linux系统默认的库，连接时需要使用静态库libthread.a. 编译时加上参数 -lpthread参数即可解决问题。
3>int fflush(FILE *fp)
强制冲洗一个流。
当一个流涉及到一个终端时，通常使用的是行缓冲，即当在输入或者输出时，遇到换行符才执行IO操作（输入到文件/输出到终端），所以为了强制输出，我们可以冲洗一个流，强制其输出到终端


客户端实现细节及遇到的问题：
1> 等待子线程结束或返回
int pthread_join(pthread_t thread, void **rval_ptr);
调用线程将一直阻塞，直到指定线程调用pthread_exit,从启动例程中返回或者被取消。





版权声明：本文为博主原创文章，未经博主允许不得转载。

最优化程序c++的方法
解决的问题
最优化问题的一般形式 
minf(paras)min \quad f(paras)s.t.paras∈[paras_lower,paras_upper]s.t.  \quad paras\in[paras\_lower,paras\_upper] 
     这个是数学上的一般形式，当求函数的最大值时候只要加上一个负号就可以 
     在程序中我们面对的问题一般是离散的即   f(paras) f(paras)一般情况下是关于XiX_i的一个离散变量的。而此时问题会转化为



       valueType errorfunc(valueType* paras,valueType* X)//误差函数输入要求的参数和具体的X的值因为多个以数组的形式传值。
       {
               sum(f(paras,X_i))//求得函数关于每个X_i的函数和
       }
我们通过调节要求得参数paras来使得errorfunc返回的值最小
  exp=min_value//收敛的最小值
  while(errorfunc( paras, X)>exp)//当误差函数的变化大于最小值时候
  {
        adjust(paras);//调整参数，继续判断其收敛与否
  }
解决的方法
当问题是线性的时候
AX=b 
利用SVD分解就可以求得最后的解，这种方法比较简单，网上也有很多的代码，下次有机会在补上。
当问题非线性的时候
如果不采用函数库的方法的话，就只能具体问题具体分析了。 
在这里我们采用GNU GSL函数库 
 [ 下载地址 ] 
 [ 具体的配置方法 ] 
下面就是我们的函数代码
void my_df (const gsl_vector *params, void *xandcval)//paras是需要传入的数值，可以是Ｘ和一些固定参数，也可以用全局变量的方法，ｐａｒａ是我们最后需要调整的参数
{
  double x, y;
  double *Xandcval = (double *)xandcval;//

  x = gsl_vector_get(params, 0);//将要求得paras读取出来
  y = gsl_vector_get(params, 1);
 return errorfunc(...);

}
void optim1()
{
    size_t np = 30;//paras的大小
    double Xandcval[2] = { 1, 2 };//这里假设只有参数，当有很多X时候需要构造
    const gsl_multimin_fminimizer_type *T_min =
        gsl_multimin_fminimizer_nmsimplex;
    gsl_multimin_fminimizer *s = NULL;
    gsl_vector *ss, *x;
    gsl_multimin_function minex_func;

    size_t iter = 0, i;
    int status;
    double size;

    /* Initial vertex size vector */
    ss = gsl_vector_alloc(np);

    /* Set all step sizes to 1 */
    gsl_vector_set_all(ss, 0.00001);//这里的0.00001指的是exp

    /* Starting point */
    paras = gsl_vector_alloc(np);
//对需要求得参数赋予初始值12 123
    gsl_vector_set(paras , 0,12);//参数表，序号，值
    gsl_vector_set(paras , 1, 123);

    /* Initialize method and iterate */
    minex_func.f = &my_f1;//误差函数的名称
    minex_func.n = np;
    minex_func.params = (void *)&par;
    char szbuffer[1000];
    s = gsl_multimin_fminimizer_alloc(T_min, np);
    gsl_multimin_fminimizer_set(s, &minex_func, x, ss);

    do
    {
        iter++;
        status = gsl_multimin_fminimizer_iterate(s);

        if (status)
            break;

        size = gsl_multimin_fminimizer_size(s);
        status = gsl_multimin_test_size(size, 1e-12);

        if (status == GSL_SUCCESS)//收敛了
        {

            printf("f() = %12.11f size = %.3f\n", s->fval, size);
            ;
        }

        //  printf("%5d ", iter);
        for (i = 0; i < np; i++)
        {
            ;//printf("%10.3e ", gsl_vector_get(s->x, i));
        }
        optim1<<"f() = "<<s->fval<<"size="<<size<<"\n";
        //  sprintf(szbuffer,"f() = %12.11f size = %.3f\n", s->fval, size);
        //MessageBox(NULL,(TCHAR*)szbuffer,TEXT("长度优化"),MB_OK);
        //printf("f() = %12.11f size = %.3f\n", s->fval, size);

    fcf<<"fc[0]="<<fc[0]<<";\t"<<"fc[1]="<<fc[1]<<";\t"<<"cc[0]="<<cc[0]<<";\t"<<"cc[1]="<<cc[1]<<";\n";
    } while (status == GSL_CONTINUE && iter < 15622);//此处设置最大迭代次数，此处为15622


    ///


        x = gsl_vector_get(s->paras, 0);//将函数值传回来
    y = gsl_vector_get(s->paras, 1);//

    gsl_vector_free(x);
    gsl_vector_free(ss);
    gsl_multimin_fminimizer_free(s);
}
上文中可能会有一些细节错误，仓促之作见谅可以看其官方文档的。。。。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

开源 android 文件管理器
我写一个开源的安卓文件器。源代码在github:源代码


# File_Explorer
# Android 文件管理器

包常用ui控件有:        
1.侧滑菜单slidingMenu           
2.兼容actionbar----actionbarsherlock        

#项目结构：        
com.yang.file_explorer     
                ---------------adapter    适配器        
                ---------------apis       文件交互操作api        
                ---------------entity     实体类              
                ---------------interfaces 接口类             
                ---------------ui         Activity类       
                ---------------view       Fragment类        
                ---------------widget     自定义控件      
                ---------------utils      工具类       

#目前app文件功能：         
1.新建文件         
2.删除文件       
3.刷新文件     
4.文件排序     
5.文件分享    
6.文件的复制、剪切        
7.文件重命名


#后续添加app文件操作功能：       

1.文件搜索                 
2.收藏文件并浏览                 
3.ftp文件上传                   
4.文件的压缩           
5.。。。。。。。。。            

#预览动画：            




代码有错误或者疑问的地方，请在下面评论提醒我，我及时回复


版权声明：本文为博主原创文章，未经博主允许不得转载。

你还在苦逼地findViewById吗？使用ButterKnife从此轻松定义控件
前段时间笔者在苦逼地撸代码~最后发现有些复杂的界面在写了一屏幕的findviewbyid~~~还有一堆setOnXXXListener~有没有方便一点的方法让我们简单点不用每次都定义一次，find一次，强转一次，set一次~~
后来笔者在收藏夹里找到同事好久以前发给我的网址（呵呵，果然是一旦加入了收藏夹就再也不会看了）~~打开发现有个叫做butterknife的东东~


那么接下来我们来看看ButterKnife怎样将我们从findviewbyid中解救出来的。




ButterKnife简介
呵呵，butterknife是一个关于基于注解的框架~~然后就没有然后了



ButterKnife的下载与配置

ButterKnife框架是一个jar包，大家可以到官网上下载也可以到文章末尾的附件中下载。
1.把下载到的jar包放在android项目的libs文件夹里面
2.然后单击项目---Alt+enter-----》java Compiler-----》Annotation Procession------》勾一下 钩一下
 Enable project specific settings 
------》Factory
 Path （ 钩一下Enable project specific settings ）----》add jar--->选择刚放进libs的jar包。然后ok~~



ButterKnife的使用


首先上一个布局文件，这个布局文件很简单只有一个button：
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="com.example.mytestproject.MainActivity" >

  <Button 
      android:id="@+id/test"
      android:layout_width="wrap_content"
      android:layout_height="wrap_content"
      android:text="点我一下"
      />

</RelativeLayout>
然后看MainActivity：
package com.example.mytestproject;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import butterknife.Bind;
import butterknife.ButterKnife;
import butterknife.OnClick;


public class MainActivity extends Activity {
	 @Bind(R.id.test)
     Button testBtn;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ButterKnife.bind(this);
    }

    @OnClick(R.id.test)
    public void sayHi(View view) {
    	testBtn.setText("Hello!");
    }
}

最后运行一下程序可以看到button上面的文字从"点我一下"变成了"Hello"
在定义控件的时候只需在所定义的空间上加上@Bind(viewId)就可以啦
然后为控件绑定事件的时候：以onClick事件为例，在方法的上面加入@OnClick(ViewId)就可以了
其中方法名称是随开发者定义的，里面的参数可以有也可以没有，比如上面代码中的：

 @OnClick(R.id.test)
    public void sayHi(View view) {
    	testBtn.setText("Hello!");
    }可以写成：
 @OnClick(R.id.test)
    public void sayHi() {
    	testBtn.setText("Hello!");
    }依然可以的。参数写与不写就看实际应用了。
还有定义控件的时候不能定为私有：
private TextView tv;//这样是不可以的
与传统findViewById比较
（本文基于Eclipse）

看上去是比findViewById更简便一些，但是如果在Android
 Studio上使用这个框架那才爽~~一键生成控件~~

有兴趣的朋友可以去研究一下~~


最后提醒一句使用的时候别忘记调用一下： ButterKnife.bind(this);否则注解是无法生效的




Demo下载
jar包下载










版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS开发 — (UINaVigationController)导航控制器,界面传值
UINavigationController 继承于 UIViewController ， 以栈的方式管理所 控制的视图控制器 ， 
至少要有一个被管理的视图控制器 ，这个控制器我们称作导航控制器的根视图控制器 。 
任何继承自 UIViewController 的类（多态）都可以作为根控制器。 
一: 工作原理: 
UINavigationController 通过 栈 的⽅式管理控制器的切换， 控制⼊栈和出栈 来展⽰示各个视图控制器 。 
UINavigationController 的 ContentView ⾥里始终显⽰栈顶 控制器的 view 。 
viewControllers 属性存储了栈中的所有被管理的控制器 navigationController 属性 ，父类中的属性， 每个在栈中的控制器 ，都能通过此属性，获取⾃己所在的 UINavigationController 对象
常用属性
viewControllers   // 所有处于栈中的控制器
topViewController   // 位于栈顶的控制器
visibleViewController   // 当前正在显⽰示的控制器
navigationBar   // 导航条
navigationBar 是导航条， iOS7 之后默认是透明的， iOS7 之前默认是不透明 的。 
navigationBar 在透明情况，与 contentView 会重合⼀部分区域。 
navigationBar 在不透明情况， contentView 跟在 navigationBar 的下⾯。 
navigationBar 竖屏下默认⾼高度 44 ，横屏下默认⾼度 32

二:<代码展示> 
1:设置根视图控制器
"AppDelegate.m"
//1:创建firstVC
    FirstViewController *firstVC = [[FirstViewController alloc]init];
//2.创建导航视图控制器对象  naVC
    UINavigationController *naVC = [[UINavigationController alloc]initWithRootViewController:firstVC];
//3.将导航视图控制器对象 naVC 指定为window根视图控制器
    self.window.rootViewController = naVC;
//4.释放所有权
    [naVC release];
    [firstVC release];
在这个文件里可以定制 navigationBar
//1.设置barTincolor
   // naVC.navigationBar.barTintColor = [UIColor cyanColor];
    //关闭半透明
    naVC.navigationBar.translucent =  NO; 
//2.设置tinColor
 //   naVC.navigationBar.tintColor = [UIColor yellowColor];
//3.设置风格  默认是0 白色  1是黑色
    naVC.navigationBar.barStyle = 1;
//4.设置背景图片 
    //当我们navigation设置图片的时候  navigation不再透明 
    //图片尺寸: 
    //当小于44或者大于64时候 图片会在navigationBar和satusBar上产生平铺的效果 
    //当尺寸正好等于44时候 图片只会位navigationBar附上图片 
    //当尺寸正好等于64时候,图片会为navigationBar以及statusBar同时附上图片;
 [naVC.navigationBar setBackgroundImage:[UIImage imageNamed:@"32074.png"] forBarMetrics:UIBarMetricsDefault];
//隐藏navigationBar(导航栏)和StatusBar(状态栏) 
    naVC.navigationBarHidden = NO;
在根视图控制器 
1:设置导航栏标题
self.navigationItem.title = @"first";
或者  
 self.title = @"First(主页)";
2:设置右边的Barbutton 
 //方法一  使用的系统的图标
   self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemPlay target:self action:@selector(nextAction:)];
//方法二  通过View自定义创建
  //创建button
    UIButton *BT = [UIButton buttonWithType:UIButtonTypeSystem];
    [BT setTitle:@"下一页" forState:UIControlStateNormal];
    [BT addTarget:self action:@selector(nextAction:) forControlEvents:UIControlEventTouchUpInside];
    BT.frame = CGRectMake(0, 0, 60, 50);
    //通过button 创建barButtonItem
    UIBarButtonItem *rightItem = [[UIBarButtonItem alloc]initWithCustomView:BT];
    //给rightBatButtonItem赋值
    self.navigationItem.rightBarButtonItem = rightItem;
    //释放所有权
    [rightItem release];
3:设置左边的返回按钮  一般使用系统的图标
self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemReply target:self action:@selector(LastAction:)];
pushViewController:animated     // 进⼊入下⼀个视图控制器
popViewControllerAnimated :       // 返回上⼀个视图控制器
popToViewController:animated   // 返回到指定的视图控制器
popToRootViewControllerAnimated    // 返回到根视图控制器
4:触发事件   从根视图推到下一视图push
-(void)nextAction:(UIBarButtonItem *)Bt
{
    //创建下一个视图控制器对象
    SecondViewController *secondVC = [[SecondViewController alloc]init];
    //2. 通过导航视图控制器 push操作
    [self.navigationController pushViewController:secondVC animated:YES];
    [secondVC release];
}
5:从下一视图返回根视图pop
-(void)LastAction:(UIBarButtonItem *)BT{
    [self.navigationController popViewControllerAnimated:YES];
}
注:UIBarButtonItem 属于 MVC 的 M 。定义了 UINavigationItem 上按钮的触 发事件，外观等
initWithBarButtonSystemItem:target:action: 
-initWithTitle:style:target:action: 
-initWithImage:style:target:action: 
界面传值 
场景1 : 从前往后传值  First(根视图) –> Second(第二个视图) 
方法: 属性传值 
步骤:1.在Second中声明对于类型的属性
@property (nonatomic,copy)NSString *tfStr; //用来接收 字符串
2.在First中push的方法中 将值传给Second的属性
secondVC.tfStr = _tf.text;
3.在Second中 使用属性进行操作
_tf.text = _tfStr;    //接收来自第一个视图的textFiled的值
场景2 : 从后往前传值  Second(第二个视图) –> First(根视图) 
方法 :代理传值 
步骤: 1.在Second中声明协议 声明代理
@protocol SecondViewControllerDelegate <NSObject>

- (void)secondViewControllerDidDisAppearWithString:(NSString *)string; // 通知 第一个界面 执行方法 将字符串拿走
@end
@property (nonatomic,assign)id<SecondViewControllerDelegate>delegate; //声明协议的代理
2.在Second将要消失的时候 通知代理执行协议中的方法 将对应的值拿走
-(void)viewDidDisappear:(BOOL)animated{
    [super viewDidDisappear:animated];
    //通知代理执行协议中的方法 把tf上的字符串拿走
    [_delegate secondViewControllerDidDisAppearWithString:_tf.text];
}
3.在First中 找到Second对象 并把First设置为Second 
这里写代码片….
secondVC.delegate = self;  //设置代理
4.在First中 实现协议中的方法  获取对应的值 
实现协议中的方法
-(void)secondViewControllerDidDisAppearWithString:(NSString *)string{
//通过传过来的参数 string 给textFiled 赋值
    _tf.text = string;
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift 属性值监测
大家一定很熟悉Object-c中的观察者模式吧。Swift提供了一种更加简单的实现方式
当我们需要对对象的属性值进行赋值的时候，可以使用willSet和didSet进行对象属性值变化的观察。


我们直接看一个例子吧。创建一个类 Student 对属性 name进行监测
首先是Student类的定义

class Student{
    init(name:String){
        userName=name;
    }
    
    var userName:String=""{
        willSet{
            println("Student name newValue:\(newValue)")
        }
        didSet{
            println("Student name oldValue:\(oldValue)")
        }
        
    }
}



然后我们对Student进行初始化修改他的userName 试试看效果

  var student=Student(name: "张三")//注意，初始化的时候是不调用监测方法的
        student.userName="lisi"
打印结果如下




Student name newValue:lisi
Student name oldValue:张三

很简单吧，有问题可以继续讨论


苹果开发群 ：414319235  欢迎加入  欢迎讨论问题

版权声明：本文为博主原创文章，未经博主允许不得转载。

第三方API使用方案
想当年还是煞笔一样的找各个登陆方式的API各种Auth认证、如今见识到了友盟的强大，
可以说，大神、分分钟集成第三方登陆啊(去除各种KEY的申请时间)
友盟第三方登陆
http://dev.umeng.com/social/android/login-page

版权声明：本文为博主原创文章，未经博主允许不得转载。

数据库(详细步骤)
写一个学生类 .h文件中定义四个属性
原代码:
@property(nonatomic ,copy)NSString *name;
@property(nonatomic ,copy)NSString *sex;
@property(nonatomic ,copy)NSString *hobby;
@property(nonatomic ,assign)NSInteger age;
创建一个数据库工具:继承于NSObject
在这之前要先找到一个框架 libsqlite3.0.dylib 加入到工程中
在这个工具类中引入头文件
(1).引入要存数据的类的头文件
(2).数据库的头文件
#import <sqlite3.h>
#import "Student.h"
在.h文件延展 用来保存数据库的地址
@interface dataBaseTool : NSObject 
{ 
    // 用来保存数据库对象的地址 
    sqlite3 *dbPoint; 
}
为了保证当前数据在工程里是唯一的 ,我们用简单单例的方式创建一个数据库工具对象
(1).在.h文件中写一个方法
+ (dataBaseTool *)sharDataBaseTool;
(2).在.m文件中写实现方法
+ (dataBaseTool *)sharDataBaseTool{
    static dataBaseTool *tool;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        tool =[[dataBaseTool alloc] init];
    });
    return tool;
}
1.打开数据库
(1).在.h文件中创建方法
-(void)openDB;
(2).在.m文件中实现方法
-(void)openDB{
  // 数据库文件也保存在沙盒的documents文件里, 所以先找沙盒路径
  NSArray *sandBox =NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, 1, YES);
  NSString *sandBoxPath =sandBox[0];

  // 拼接文件路径 ,如果系统根据这个文件路径查找的时候有对应文件则直接打开数据库,如果没有则会创建一个相应的数据库   NSString *documentPath =[sandBoxPath stringByAppendingPathComponent:@"Student.sqlite"];   
  int result =sqlite3_open([documentPath UTF8String], &dbPoint);
  if (result == SQLITE_OK) {
        NSLog(@"数据库打开成功");
        NSLog(@"%@",documentPath);
  }else{
        NSLog(@"数据库打开失败");
  }

}
(3).在viewController中调用
引入student类和dateBaseTool数据库的头文件
 #import "dataBaseTool.h"
 #import "Student.h"
 调用:
[[dataBaseTool sharDataBaseTool] openDB];
2 .给数据库创建张表格 ,table
(1).在.h文件中定义方法:
-(void)createTable;
(2).在.m文件中实现方法
-(void)createTable{

 // primary key 是主键的意思 ,主键在当前表格前表里数据是唯一的,不能重复,可以是唯一的标示一条数据,一般是整数
    // zutoincrement自增 ,为了让主键不重复,会让主键采用自增的方式
    // if not exists 如果没有表才会创建,防止重复创建覆盖之前数据
    // 数据库问题%90是sql语句出问题,所以保证语句没问题,再放到工程里使用
    NSString *sqlStr =@"create table if not exists stu(number integer primary key autoincrement, name text, sex text, age integer, hobby text)";
    // 执行这条sql语句
    int result = sqlite3_exec(dbPoint, [sqlStr UTF8String], nil, nil, nil);
    if (result == SQLITE_OK) {
        NSLog(@"表创建成功");
    }else {
        NSLog(@"表创建失败");
    }

}
(3).调用
[[dataBaseTool sharDataBaseTool] createTable];
3.向表里插入一个学生信息
(1).h
-(void)insertStu:(Student *)stu;
(2).m
-(void)insertStu:(Student *)stu{
    // 语句里值的位置要加上单引号
    NSString *sqlStr =[NSString stringWithFormat:@"insert into stu (name, age, sex, hobby) values ('%@', %ld, '%@', '%@')", stu.name, stu.age, stu.sex ,stu.hobby];

// 执行sql语句
    int result =sqlite3_exec(dbPoint, [sqlStr UTF8String], nil, nil, nil);
    if (result == SQLITE_OK) {
        NSLog(@"添加学生成功");
    }else{
        NSLog(@"添加学生失败");
    }
}
(3).调用
创建一个stu  
Student *stu =[[Student alloc] init];
    stu.name =@"zhang";
    stu.age =20;
    stu.sex =@"nan";
    stu.hobby =@"ying";
    // 调用添加的方法
    [[dataBaseTool sharDataBaseTool] insertStu:stu];
4.更新表里的学生数据
(1).h
- (void)updateStu:(Student *)stu;
(2).m
- (void)updateStu:(Student *)stu{
    NSString *sqlStr = [NSString stringWithFormat:@"update stu set name = '%@', sex = '%@', hobby = '%@', age = %ld where name = '%@'",stu.name, stu.sex, stu.hobby ,stu.age,stu.name];
    // 执行sql语句
    int result =sqlite3_exec(dbPoint, [sqlStr UTF8String], nil, nil, nil);
    if (result == SQLITE_OK) {
        NSLog(@"更新成功");
    }else{
        NSLog(@"更新失败");
    }

}
(3).调用
创建一个stu 
 Student *stu =[[Student alloc] init]; 
    stu.name =@"zhang"; 
    stu.sex =@"nan"; 
    stu.hobby =@"xuexi"; 
    stu.age =30; 
 调用 
    [[dataBaseTool sharDataBaseTool] updateStu:stu];
5.删除数据
(1).h
-(void)deleteStu:(Student *)stu;
(2).m
-(void)deleteStu:(Student *)stu{
    NSString *sqlStr =[NSString stringWithFormat:@"delete from stu where name = '%@'",stu.name];
    int result =sqlite3_exec(dbPoint, [sqlStr UTF8String], nil, nil, nil);
    if (result == SQLITE_OK) {
        NSLog(@"删除成功");
    }else{
        NSLog(@"删除失败");
    }
}
(3).调用
删除 学生名字是zhang的学生信息
 Student *stu =[[Student alloc] init];
    stu.name =@"zhang";   
 [[dataBaseTool sharDataBaseTool] deleteStu:stu];
6. 查询数据库中所有学生表里的数据
(1).h
-(NSMutableArray *)selectAllStu;
(2).m
-(NSMutableArray *)selectAllStu{
 // 查询逻辑
    // 1.先从本地的数据库中读取某张表里的所有数据
    // 2.然后逐条进行读取,对model进行赋值
    // 3.把已经赋值好的model放到数组中,并且返回
    NSString *sqlStr =@"select * from stu";
    // 在语句里 * 是通配符的意思 ,通过一个 *相当于代替了表里的所有的字段名
    // 接下来需要定义一个跟随指针,他用来遍历数据库表里中的每行数据
    sqlite3_stmt *stmt =nil;
    // 第三个参数:查询语句字数限制 , -1是没有限制
    int result =sqlite3_prepare_v2(dbPoint, [sqlStr UTF8String], -1, &stmt, nil);
    // 这个方法相当于把数据库和跟随指针相关联,一同完成查询功能
    // 初始化一个用来装学生的数组
    NSMutableArray *stuArr =[NSMutableArray array];
    if (result == SQLITE_OK ){
        NSLog(@"查询成功");
        // 开始便利查询数据库的每一行
       while(sqlite3_step(stmt)== SQLITE_ROW){
 // 让跟随指针进行便利查询, 如果没有行,才会停止循环
// 满足条件,则逐列的读取这一行上的数据
// 第二个参数表示当前这列数据在表中的第几列
           const unsigned char *name =sqlite3_column_text(stmt, 1);
           const unsigned char *sex = sqlite3_column_text(stmt, 2);
           int age =sqlite3_column_int(stmt, 3);
           const unsigned char *hobby  =sqlite3_column_text(stmt, 4);
           // 把列里面的数据在进行类型的转换
           NSInteger stuAge = age;
           NSString *stuName =[NSString stringWithUTF8String:(const char*)name];
           NSString *stuSex =[NSString stringWithUTF8String:(const char*)sex];
           NSString *stuHobby =[NSString stringWithUTF8String:(const char*)hobby];
 // 给对象赋值 ,然后把对象放到数组里
           Student *stu =[[Student alloc] init];
           stu.name =stuName;
           stu.sex =stuSex;
           stu.hobby =stuHobby;
           stu.age =stuAge;
           [stuArr addObject:stu];
        }
    }else{
        NSLog(@"查询失败");
        NSLog(@"%d",result);
    }       
 return stuArr;

}
(3).调用
创建数组接收数据
NSMutableArray *arr =[[dataBaseTool sharDataBaseTool] selectAllStu];
遍历数组    
for (Student *stu in arr) {
        NSLog(@"%@",stu.name);
    }
7.关闭数据库
(1).h
-(void)closeDB;
(2).m
-(void)closeDB{
    int result =sqlite3_close(dbPoint);
    if (result == SQLITE_OK) {
        NSLog(@"数据关闭成功");
    }else{
 NSLog(@"数据关闭失败");
    }    
}
(3).调用
[[dataBaseTool sharDataBaseTool ] closeDB];

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Unity3D NGUI屏幕摇杆
NGUI下增加一个Empty对象，重命名为Joystick。在它本身上加载UIAnchor脚本，设置好它的大小。Joystick的子集中增加俩个新的Empty，命名为Background，Thumb。所有设置如下所示。







Thumb上增加box collier，为后期屏幕射线能够打在Background的区域。然后加上NGUIJoystick脚本。拖拽Thumb产生OnDrag，如下代码所示。
void OnDrag (Vector2 delta) {
		if (enabled && gameObject.activeInHierarchy) {//当前对象被启用且对下在层次视图中处于激活状态
			UICamera.currentTouch.clickNotification = UICamera.ClickNotification.BasedOnDelta;//得到UICamera脚本组件中的BasedDelta变量
			
			Ray ray = UICamera.currentCamera.ScreenPointToRay (UICamera.currentTouch.pos);//得到从UI摄像机发出的到触摸点的一条射线
			float dist = 0f;//定义射线长度变量
			
			if (mPlane.Raycast (ray, out dist)) {//如果射线发生碰撞
				Vector3 currentPos = ray.GetPoint (dist);//得到射线上距离dist远处的一个点
				Vector3 offset = currentPos - mLastPos;//计算当前位置和上一次位置的偏移量
				mLastPos = currentPos;//赋值

				if (offset.x != 0f || offset.y != 0f) {//当偏移量的x或y分量不为零时
					offset = transform.InverseTransformDirection (offset);//对偏移量进行世界坐标系到本地坐标系的转换
					offset.Scale (scale);//对偏移量进行缩放
					offset = transform.TransformDirection (offset);//对偏移量进行本地坐标系到世界坐标系的转换
				}
				
				offset.z = 0;//赋值
				transform.position += offset;//改变对象位置
				
				float length = transform.localPosition.magnitude;//得到当前对象本地位置向量的模
				 
				if (length > radius) {//当长度大于虚拟摇杆的背景半径时
					transform.localPosition = Vector3.ClampMagnitude (transform.localPosition, radius);//计算当前对象的本地位置
				}

				position = new Vector2((transform.localPosition.x-center.x)/radius,(transform.localPosition.y-center.y)/radius);//将二维向量转换成z默认为0的三维向量
			}
		}
	}
主要流程如下所示



下面代码主角控制器调用，得到joystick的位置，计算出移动向量。
if (Input.GetAxis("Horizontal") == 0 && Input.GetAxis("Vertical") == 0)
        {//当不是用键盘控制时（在手机屏幕上通过触控控制时）
            directionVector = new Vector3(joystick.position.x, 0, joystick.position.y);//计算角色通过虚拟操纵杆来控制时的移动方向
        }
        if (directionVector != Vector3.zero)
        {
            float directionLength = directionVector.magnitude;//计算移动方向向量的长度
            directionVector = directionVector / directionLength;//计算单位向量，这两句相当于directionVector.normalized,但这两句计算单位向量比向量的规格化更快

            directionLength = Mathf.Min(0.4f, directionLength);//确保向量长度不超过1
            //使向量到达边界值更敏感，到达中间值时更迟钝，这样使得使用操纵杆时更容易控制减速
            directionLength = directionLength * directionLength;
            //计算移动方向向量
            directionVector = directionVector * directionLength;
        }
        directionVector.y = 0;
        m_charCon.Move(m_trans.TransformDirection(directionVector));//计算移动方向源码下载
明晚上传

版权声明：本文为博主原创文章，未经博主允许不得转载。

SuperSwipeRefreshLayout 一个功能强大的自定义下拉刷新组件
SuperSwipeRefreshLayout
一个功能强大的自定义下拉刷新组件。
Why？
下拉刷新这种控件，想必大家用的太多了，比如使用很多的XListView等。最近，项目中很多列表都是使用ReyclerView实现的，代替了原有的ListView,原有下拉刷新方式遭到挑战。本来Google推出的SwipeRefreshLayout已经能够满足大部分的需求了。然而，由于其定制性较差，下拉刷新的样式无法修改，而且被嵌套的View也无法跟随手指的滑动而滑动。基于以上考虑，定制自己强大的SuperSwipeRefreshLayout。
Feature

非侵入式，对原来的ListView、RecyclerView没有任何影响,用法和SwipeRefreshLayout类似。
可自定义头部View的样式，调用setHeaderView方法即可
支持更多：RecyclerView，ListView，ScrollView，GridView等等。
被包含的View(RecyclerView,ListView etc.)可跟随手指的滑动而滑动
默认是跟随手指的滑动而滑动，也可以设置为不跟随：setTargetScrollWithLayout(false)
回调方法更多
比如：onRefresh() onPullDistance(int distance)和onPullEnable(boolean enable)
开发人员可以根据下拉过程中distance的值做一系列动画。 


How to use
step 1
<net.mobctrl.views.SuperSwipeRefreshLayout
        android:id="@+id/swipe_refresh"
        android:layout_width="match_parent"
        android:layout_height="match_parent" >

        <android.support.v7.widget.RecyclerView
            android:id="@+id/recycler_view"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />
</net.mobctrl.views.SuperSwipeRefreshLayout>
step 2

swipeRefreshLayout = (SuperSwipeRefreshLayout) findViewById(R.id.swipe_refresh);
        swipeRefreshLayout.setHeaderView(createHeaderView());// add headerView
        swipeRefreshLayout
                .setOnPullRefreshListener(new OnPullRefreshListener() {

                    @Override
                    public void onRefresh() {
                        //TODO 开始刷新
                    }

                    @Override
                    public void onPullDistance(int distance) {
                        //TODO 下拉距离
                    }

                    @Override
                    public void onPullEnable(boolean enable) {
                        //TODO 下拉过程中，下拉的距离是否足够出发刷新
                    }
                });

step 3

create your header view

swipeRefreshLayout.setHeaderView(createHeaderView());// add headerView

/**
 * create Header View
 */
private View createHeaderView(){
   //TODO 创建下拉刷新头部的View样式
}
跟手滑动设置

setTargetScrollWithLayout(false/true);//default true

swipeRefreshLayout.setTargetScrollWithLayout(true);
Support View

RecyclerView.
ListView
SrcollView
GridView
etc.

Demo
效果 

后续
如有必要，可以增加上拉加载更多的功能。
源码：
Github https://github.com/nuptboyzhb/SuperSwipeRefreshLayout
源码分析
后续有时间更新

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

【Material Design视觉设计语言】应用动画设计
作者：郭孝星 
微博：郭孝星的新浪微博 
邮箱：allenwells@163.com 
博客：http://blog.csdn.net/allenwells 
Github：https://github.com/AllenWells

动画反应了应用组件在空间中的关系、功能以及在整个系统中的趋势。

一 动画设计原则
1.1 动画真实地反应现实世界
动画应该完整的展现物体的各个真实的特性，譬如优雅、简约和美观等，来获得神奇的无缝的用户体验，
举例
迅速的加速和平滑的减速会感到自然和愉快

线性动作会感到机械，在结束和开始的时候生硬的速度变化意味着物体突然开始运动或停止，这会让用户感到厌倦。

注意
不是所有物体的运动方式都是相同的。

轻的/小的物体可能会更快的加速和减速，因为它们质量比较小，所以较少的力就可以使它们运动。
大的/重的物体可能花需要更多的时间来到达他的最高速度或者回到停止状态。

仔细琢磨如何将物体的动作并把它们应用到我们应用的UI元素中。
1.2 动画积极地响应用户的操作

深思熟虑、有目的、非随机的响应式交互能让用户信任和感到喜悦，这使得用户更加关注我们的应用。响应式交互把一个应用从简单展现用户所请求的信息，提升至能与用户产生更强烈、更具体化交互的工具

响应交互有以下几种
表层响应

触控涟漪是应用接收到输入事件（如点击屏幕）系统立即在交互的触点上绘制的一个可视化的类似于墨水扩散那样的视觉效果形状.。触控涟漪可以及时地让用户感知触摸按钮和语音输入时的变化。

所有输入都有中心点，涟漪效果应从触控点、语音时屏幕上的语音图标、键盘输入时具体的按键点击位置上展开。
这些输入动作产生时都应该在中心点形成一个视觉上的关联，从中心点展开一连串动作产生的涟漪效果。

元素响应
和表层响应的触控涟漪一样，每个元素本身也能做出交互响应，物体可以在触控或点击的时候浮起来，以表示该元素正处于激活状态。用户可以通过点击、拖动来生成、改变元素或者直接对元素进行处理。

1.2 转场动画真实有意义

转场动画用于展现一个元素向另一个元素的转变过程，优秀的转场动画可以在有多步操作的过程中有效地引导用户的注意力；在版面变化或元素重组时避免造成困惑；提高用户体验的整体美感。

动画设计不仅应当优美，更应当服务于功能，那我们应该怎样去设计转场动画呢？
1.2.1 转场动画要保持视觉的连贯性
在两个视觉效果不同的页面之间的转场应该平滑、轻快，更重要的是使用户感觉清晰而非困惑。优秀的转场动画可以让用户清楚地了解他们应该关注哪里。
一个转场动画通常包含3个元素：

新入元素(Incoming elements)：完全新的元素需要有新手引导，从已有场景中转变而来的元素需要重新被识别。
淡出元素(Outgoing elements)：与当前场景不相关的元素应当以恰当的方式被移除。
通用元素(Shared elements)：指那些从转场开始到结束都没有发生变化的元素。可以是细微至单个图标，也可以是显著到占据屏幕的图片展示。

1.2.2 转场动画应该有层次的时序
在建立转场的时候，对于元素移动的顺序和时机都要详加考虑。要确保这个动画能使信息的展示具有层次感。也就是说，它能引导用户的关注力，将最重要的内容传递给用户。然而，这并不是说最重要的东西先动，最不重要的东西就后动。元素转场的时序要平滑并且避免脱节的感觉。
二 动画设计实践

用户的注意力应该被如何引导，什么元素和动画能辅助实现这个目标。新入元素、淡出元素和通用元素在这个转场中应该怎样被强调或弱化。
在设计场景时考虑到转场，并且尽量通过色彩和通用元素在不同场景转化间建立视觉联系，确保元素移动的方向在整个转场过程中都是协调一致的。避免冲突的动作和重叠的运动路径。审慎地添加动画，思考如何移动一个特定的元素，从而使这个转场更明晰并使人愉悦。
除非这个动画是被限制在某一个轴上或者是与其它元素一起从/往某个点协调的移动，否则尽量避免线性路径。
如果所有运动的元素都在屏幕上按路径移动，看起来是否优美整齐，这是否能让用户清楚地知道应该看哪里。
通过新旧元素的连贯性的动画来表现空间上的关系。
通过和谐一致的动画引导用户的注意力。
避免混乱不连贯的动画，元素以随机方向离开或进入等会造成用户的困惑。


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：当我们认真的去做一件事的时候，就能发现其中的无穷乐趣，丰富多彩的技术宛如路上的风景，边走边欣赏。

iOS 添加粘贴板的功能（复制功能）
1.   UIPasteboard *board = [UIPasteboard
generalPasteboard];
    board.string =
@" 需要粘贴的问题字符串";

版权声明：本文为博主原创文章，未经博主允许不得转载。

Dagger2官方CoffeeMaker案例的分解说明
官方例子的场景描述：一个泵压式咖啡机(CoffeeMaker)由两个主要零件组成，泵浦(Pump)和加热器(Heater)，咖啡机有一个功能是煮泡咖啡(brew)，当进行煮泡咖啡时，会按如下几个步骤进行打开加热器进行加热，泵浦加压，萃取出咖啡，然后关闭加热器，一杯咖啡就算制作完毕了。
按照上一篇文章的5个步骤，我们来分解一下这个例子：
Step 1 确定依赖和被依赖对象
依赖对象是CoffeeMaker对象，被依赖对象是Heater类型对象和Pump类型对象。
src/coffee/CoffeeMaker.java
class CoffeeMaker {

 private final Heater heater;

 private final Pump pump;

 

 CoffeeMaker(Heater heater, Pump pump) {

   this.heater = heater;

   this.pump = pump;

  }

 

 public void brew() {

   heater.on();

   pump.pump();

   System.out.println(" [_]P coffee! [_]P ");

   heater.off();

  }

}src/coffee/Heater.javainterface Heater {

 void on();

 void off();

 boolean isHot();

}src/coffee/Pump.javainterface Pump {

 void pump();

}与上一个例子不同的是，这里Heater和Pump都是接口。既然是接口，就意味着必须要有对应的实现类才可以创建出相应的对象。ElectricHeater和Heater接口的实现类，Thermosiphon是Pump接口的实现类：
src/coffee/ElectricHeater.java
class ElectricHeater implements Heater {
  boolean heating;

  @Override public void on() {
    System.out.println("~ ~ ~ heating ~ ~ ~");
    this.heating = true;
  }

  @Override public void off() {
    this.heating = false;
  }

  @Override public boolean isHot() {
    return heating;
  }
}
src/coffee/Thermosiphon.javaclass Thermosiphon implements Pump {

 private final Heater heater;

 

 Thermosiphon(Heater heater) {

   this.heater = heater;

  }

 

  @Overridepublic void pump() {

   if (heater.isHot()) {

     System.out.println("=> => pumping => =>");

    }

  }

}Step 2. 创建@Module类
@Module类的命名惯例是以Module作为类名称的结尾。而@Module类中的@Provides方法名称的命名惯例是以provide作为前缀。
官方案例在这里使用了2个@Module类，一个@Module类作为了另一个@Module类的组成部分。
src/coffee/DripCoffeeModule.java
@Module(includes = PumpModule.class)

class DripCoffeeModule {

 @Provides @Singleton Heater provideHeater() {

   return new ElectricHeater();

  }

}@Module注解使用了一个属性include，将PumpModule作为了自身的一部分。
src/coffee/PumpModule.java
@Module

class PumpModule {

 @Provides Pump providePump(Thermosiphon pump) {

   return pump;

  }

}Step 3. 获得了@Module类之后，对Step1中的需要注入的地方进行相应的注解。class CoffeeMaker {

 private final Lazy<Heater> heater;

 private final Pump pump;

 

  @InjectCoffeeMaker(Lazy<Heater> heater, Pump pump) {

   this.heater = heater;

   this.pump = pump;

  }

 

 public void brew() {

   heater.get().on();

   pump.pump();

   System.out.println(" [_]P coffee! [_]P ");

   heater.get().off();

  }

}这里仍然使用为构造器添加@Inject注解的方式，到时在创建CoffeeMaker对象的时候，Dagger2会自动调用这个带@Inject的构造器，同时根据@Module去获得需要传入构造器的Heater类型对象与Pump类型对象。另外，这里对heater属性采用了“延迟加载”机制，即Heater类型对象的真正实例化是在第一次调用heater.get()方法的时候进行(因为此时heater是Lazy<Heater>类型，因此要先调用get方法来获得Lazy<Heater>中封装的Heater对象，进而才能调用Heater对象的方法)。
@Module类中，provideHeater方法提供Heater类型对象的时候，是直接显示的调用ElectricHeater对象的构造器来进行的，因此不存在什么注入不注入的事情，即ElectricHeater不用进行任何改写。而providePump方法在提供Pump类型对象的时候，是把方法的形参作为返回值返回的，为了保证Dagger2在创建CoffeeMaker对象的时候，可以自动装配pump属性，因此必须要为Thermosiphon类的构造器添加@Inject注解，没有@Inject注解的类，Dagger2是不认识的，更无法自动进行构造器的调用创建实例。
src/coffee/Thermosiphon.java
class Thermosiphon implements Pump {

 private final Heater heater;

 @Inject

 Thermosiphon(Heater heater) {

   this.heater = heater;

  }

 

 @Override public void pump() {

   if (heater.isHot()) {

     System.out.println("=> => pumping => =>");

    }

  }

}Step 4. 创建一个接口，让@Inject和@Module建立起联系
经过Step2和Step3对Step1中创建的类的修改，实际上CoffeeMaker的依赖关系已经描述完毕了，接下来就是要创建一个@Commpoment接口，通过接口中的一个无参数方法来“驱使”Dagger2来创建出一个CoffeeMaker对象，并且随着这个对象的建立，CoffeeMaker中所有依赖对象都装配好。官方例子中这个接口被作为一个内部接口的方式提供：
src/coffee/CoffeeApp$Coffee.java
@Singleton

 @Component(modules = { DripCoffeeModule.class })

 public interface Coffee {

   CoffeeMaker maker();

  }Step 5. 利用Dagger2自动生成的@Commpoment接口实现类创建Coffee类型的实例。
一旦利用Dagger2自动生成的@Commpoment接口实现类创建出Coffee类型的实例，就可以调用maker方法获得CoffeeMaker类型的实例。此时这个CoffeeMaker实例中所有的依赖关系都被装配好了。官方例子中，是这样写的：
src/coffee/CoffeeApp.java
public class CoffeeApp {

 @Singleton

 @Component(modules = { DripCoffeeModule.class })

  publicinterface Coffee {

   CoffeeMaker maker();

  }

 public static void main(String[] args) {

   Coffee coffee = DaggerCoffeeApp_Coffee.builder().build();

   coffee.maker().brew();

  }

}@Component接口作为CoffeeApp的内部接口来呈现。那么此时Dagger2为该接口自动生成的实现类名称就是Dagger外部类名称_接口名称，即DaggerCoffeeApp_Coffee。然后再调用相应的builder方法来创建出Coffee实例。官方的例子在创建Coffee类型的实例时，使用的是DaggerCoffeeApp_Coffee.builder().build()，如果完全按照上一个例子的写法，将该方法写完整DaggerCoffeeApp_Coffee.builder().dripCoffeeModule(newDripCoffeeModule()).build();效果是完全一样的，这一点通过查看一下DaggerCoffeeApp_Coffee的源码即可得知。而且，如果@Module类实例的创建是通过默认无参构造器来创建的，那么可以不使用Build模式，将这简写为DaggerCoffeeApp_Coffee.create()即可。
另外，如果DaggerCoffeeApp_Coffee已经生成，对@Inject或者@Module做出改动不会影响到DaggerCoffeeApp_Coffee，但是对@Commpoment接口或者DaggerCoffeeApp_Coffee调用方法的相关代码做出改动，Eclipse中都会对DaggerCoffeeApp_Coffee类报错。此时要强行对项目进行一次重建(rebuild)。但是Eclipse是没有rebuild这个功能键的。要在Eclipse中对一个项目进行rebuild的方式可以参考“在Eclipse中搭建Dagger和Dagger2使用环境”的做法，先将Annotation
 Processing的Enable projectspecific settings选项对勾去掉，单击“apply”，此时Eclipse会有一个提示，点击yes即可对项目进行一次rebuild，此时rebuild的结果肯定是错误的，然后在重新将Annotation Processing的Enable projectspecific settings选项对勾选中，单击“apply”，此时Eclipse会再次出现一个提示，点击yes对项目再进行一次rebuild，此时就可以得到正确的DaggerCoffeeApp_Coffee类了。
最后，在Step2中，如果不对@Module注解使用includes属性，完全可以将DripCoffeeModule和PumpModule合并成一个@Module类：
src/coffee/NewDripCoffeeModule.java
@Module

public class NewDripCoffeeModule {

         @Provides@Singleton Heater providHeater(){

                  returnnew ElectricHeater();

         }

         @Provides@Singleton Pump providePump(Heater heater){

                  returnnew Thermosiphon(heater);

         }

}在providePump方法中返回Thermosiphon对象的时候，因为构造器需要一个Heater类型的对象，因此把这个Heater类型的对象从方法参数传进去，到时候Dagger2在找这个Heater类型对象的时候，自然会去根据providHeater方法来自动装配一个ElectricHeater实例进去。这一点可以参考DaggerCoffeeApp_Coffee类的源码，看看它是如何处理@Module类中的@Provides方法的。
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android --Toolbar的使用
在布局文件中添加如下代码：
 <android.support.v7.widget.Toolbar
        android:id="@+id/toobar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="?attr/colorPrimary">

 </android.support.v7.widget.Toolbar>

注意：这里使用的是support v7中的Toolbar ，如果直接使用Toolbar，则只用在API level 21 的版本上才有效

然后在主题中添加如下代码：
<!--隐藏Actionbar-->
<item name="windowActionBar">false</item>
<item name="windowNoTitle">true</item>
<!--Toolbar的颜色-->
<item name="colorPrimary">@color/accent_material_light</item>
在Activity文件中添加如下代码：
//使用Toolbar代替Actionbar
Toolbar toolbar = (Toolbar)findViewById(R.id.toobar);
setSupportActionBar(toolbar);
到目前为止Toolbar就已经代替了Actionbar 
效果图如下： 

当然Toolbar中还有很多方法，我在这里列举一部分常用的：
//设置标题
toolbar.setTitle("标题");
//设置子标题
toolbar.setSubtitle("子标题");
//设置Logo
toolbar.setLogo(R.mipmap.ic_launcher);
//设置导航图标
toolbar.setNavigationIcon(R.mipmap.ic_launcher);
效果图： 


说明：由于我是使用AndroidStudio开发的所以我这里使用的是R.mipmap.ic_lanucher使用Eclipse的同学们可以使用R.drawable.ic_lanucher


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

IOS开发—CALayer介绍
CALayer简介
一、简单介绍
CALayer是定义在QuartzCore框架中的；CGContext是定义在CoreGraphics框架中的。UIView之所以能显示，是因为它内部有一个图层属性：
@property(nonatomic,readonly,retain) CALayer *layer; 

UIView在创建的时候，内部会自动创建一个（CALayer对象），通过操作这个layer对象，可以对视图的一些界面属性进行调整：阴影、圆角大小、边框宽度、边框颜色等。
二、layer常规操作
1.设置阴影、圆角大小、边框宽度、边框颜色等
#import "ViewController.h"

@interface ViewController ()
@property (nonatomic ,strong) UIView *myView;
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];

    self.myView = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];
    self.myView.backgroundColor = [UIColor greenColor];
    [self.view addSubview:self.myView];
    //阴影
    self.myView.layer.shadowColor = [UIColor blackColor].CGColor;
    self.myView.layer.shadowOffset = CGSizeMake(10, 5);
    self.myView.layer.shadowOpacity = 0.5;
    //圆角大小
    self.myView.layer.cornerRadius = 10.0;
    //边框宽度
    self.myView.layer.borderWidth = 5.0;
    //边框颜色
    self.myView.layer.borderColor = [UIColor lightGrayColor].CGColor;
}
@end

2.视图形变
1.通过UIView设置(2D)
self.myView.transform = CGAffineTransformMakeTranslation(50, 50);
2.通过layer设置(3D)
self.myView.layer.transform = CATransform3DMakeTranslation(50, 50, 50);

3.边缘裁剪
对于一个UIView对象，可以对其添加subView。
#import "ViewController.h"

@interface ViewController ()
@property (nonatomic ,strong) UIView *myView;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.myView = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];
    self.myView.backgroundColor = [UIColor greenColor];
    [self.view addSubview:self.myView];
    //阴影
    self.myView.layer.shadowColor = [UIColor blackColor].CGColor;
    self.myView.layer.shadowOffset = CGSizeMake(10, 5);
    self.myView.layer.shadowOpacity = 0.5;
    //圆角大小
    self.myView.layer.cornerRadius = 10.0;
    //边框宽度
    self.myView.layer.borderWidth = 5.0;
    //边框颜色
    self.myView.layer.borderColor = [UIColor lightGrayColor].CGColor;

    UIView *otherView = [[UIView alloc]initWithFrame:CGRectMake(-10, -10, 50, 50)];
    otherView.backgroundColor = [UIColor purpleColor];
    [self.myView addSubview:otherView];
}
@end

可以看到部分视图超出了主视图边界，有两种方法裁剪掉超出的部分

self.myView.clipsToBounds = YES; 对view设置
self.myView.layer.masksToBounds = YES; 对layer设置（推荐）

#import "ViewController.h"

@interface ViewController ()
@property (nonatomic ,strong) UIView *myView;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.myView = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];
    self.myView.backgroundColor = [UIColor greenColor];
    [self.view addSubview:self.myView];
    //阴影
    self.myView.layer.shadowColor = [UIColor blackColor].CGColor;
    self.myView.layer.shadowOffset = CGSizeMake(10, 5);
    self.myView.layer.shadowOpacity = 0.5;
    //圆角大小
    self.myView.layer.cornerRadius = 10.0;
    //边框宽度
    self.myView.layer.borderWidth = 5.0;
    //边框颜色
    self.myView.layer.borderColor = [UIColor lightGrayColor].CGColor;

    UIView *otherView = [[UIView alloc]initWithFrame:CGRectMake(-10, -10, 50, 50)];
    otherView.backgroundColor = [UIColor purpleColor];
    [self.myView addSubview:otherView];

    //对view设置
//    self.myView.clipsToBounds = YES;
    //对layer设置（推荐）
    self.myView.layer.masksToBounds = YES;
}
@end

超出部分被裁剪。事实上，layer对象作为视图的主层存在，具有绝对的最高主权。我们可以添加主层以外的层，即子层。可以创建CALayer对象直接添加（将在下面介绍）,也可以添加subview，这个subview的layer是作为主视图的sublayer存在的。凡是不在主层layer范围内的层，都将被裁剪。
注意:裁剪之后layer的阴影将无法显示
隐式动画
CALayer对象存在隐式动画。什么是隐式动画？即修改CALayer对象的某些属性时，会伴随动画过渡。这些属性被称为Animatable property（可动画属性）。如何查看属性是否支持隐式动画，可查看头文件中对该属性的介绍。当然也可以查看官方文档

#import "ViewController.h"

@interface ViewController ()
@property (nonatomic ,strong) UIView *myView;
@property (nonatomic, strong) CALayer *myLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.myView = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 200, 200)];
    self.myView.backgroundColor = [UIColor greenColor];
    [self.view addSubview:self.myView];

    NSLog(@"start--%@",self.myView.layer.sublayers);

    //创建layer对象
    self.myLayer = [CALayer layer];
    //设置颜色
    self.myLayer.backgroundColor = [UIColor orangeColor].CGColor;
    //设置长宽
    self.myLayer.bounds = (CGRect){0,0,100,100};
    //设置位置(锚点相对于view的相对坐标)
    self.myLayer.position = CGPointMake(0,0);
    //设置锚点（即x,y均0~1，默认为(0.5,0.5)，习惯上设置成(0,0),）
    self.myLayer.anchorPoint = CGPointZero;
    //将新创建的layer添加到指定界面上
    [self.myView.layer addSublayer:self.myLayer];

    NSLog(@"end--%@",self.myView.layer.sublayers);
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    self.myLayer.bounds = (CGRect){0,0,50,50};
}
@end


创建图层
图层的创建
创建图层的步骤：

创建layer对象
设置layer的颜色（设置了颜色才能显示）
将layer添加到界面上（最为view的sublayer）

#import "ViewController.h"

@interface ViewController ()
@property (nonatomic ,strong) UIView *myView;
@property (nonatomic, strong) CALayer *myLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.myView = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 200, 200)];
    self.myView.backgroundColor = [UIColor greenColor];
    [self.view addSubview:self.myView];

    //创建layer对象
    self.myLayer = [CALayer layer];
    //设置颜色
    self.myLayer.backgroundColor = [UIColor orangeColor].CGColor;
    //设置长宽
    self.myLayer.bounds = (CGRect){0,0,100,100};
    //设置位置(锚点相对于view的相对坐标)
    self.myLayer.position = CGPointMake(0,0);
    //设置锚点（即x,y均0~1，默认为(0.5,0.5)，习惯上设置成(0,0),）
    self.myLayer.anchorPoint = CGPointZero;
    //将新创建的layer添加到指定界面上
    [self.myView.layer addSublayer:self.myLayer];
}
@end


注意：如果一个控件是另一个控件的子视图，那么这个控件的layer是另一个控件layer的sublayer。
UIView和CALayer的选择
可以看到，CALayer可以实现和UIView同样的目的，达到同样的效果。CALayer属于QuartzCore框架，可以在ios和mac OSX上跨平台使用，而UIView属于UIKit框架，只能在ios上使用。另外一个不同在于，UIView可以处理触摸事件，而CALayer不能处理，因此如果需要处理触摸事件，只能用UIView。不然的话，两个选择都可以考虑。  

UIView可以通过subviews属性访问所有的子视图，类似地，CALayer也可以通过sublayers属性访问所有的子层
UIView可以通过superview属性访问父视图，类似地，CALayer也可以通过superlayer属性访问父层

自定义Layer
方法一、创建自定义Layer类
UIView可以重写DrawRect：方法自定义绘制视图，CALayer也有类似的方法: 
创建一个继承自CALayer的自定义layer类，并在.m文件中重写drawInContext:方法，在该方法中绘制自定义图案。DrawRect：会在view显示出来的时候自动调用一次，而drawInContext:方法不会被自动调用，必需通过对layer发送setNeedsDisplay消息手动调用。
LXXLayer.m
#import "LXXLayer.h"
#import <UIKit/UIKit.h>

@implementation LXXLayer

- (void)drawInContext:(CGContextRef)ctx{
    CGContextMoveToPoint(ctx, 10, 20);
    CGContextAddLineToPoint(ctx, 100, 20);
    CGContextSetStrokeColorWithColor(ctx, [UIColor greenColor].CGColor);
    CGContextSetLineWidth(ctx, 10);
    CGContextSetLineCap(ctx, kCGLineCapRound);
    CGContextStrokePath(ctx);
}

@end
ViewController.m
#import "ViewController.h"
#import "LXXLayer.h"

@interface ViewController ()
@property (nonatomic, strong) LXXLayer *customLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.customLayer = [LXXLayer layer];
    self.customLayer.backgroundColor = [UIColor orangeColor].CGColor;
    self.customLayer.bounds = CGRectMake(0, 0, 200, 200);
    self.customLayer.position = CGPointMake(100, 100);
    self.customLayer.anchorPoint = CGPointZero;
    [self.view.layer addSublayer:self.customLayer];

    //触发.m文件中的displayLayer:绘制自定义图案
    [self.customLayer setNeedsDisplay];
}


说明:在UIView中绘制图形，获取的上下文就是这个view对应的layer的上下文。在渲染的时候，就是把图形渲染到对应的layer上。在执行渲染操作的时候，本质上它的内部相当于执行了 [self.layer drawInContext:ctx];
方法二、通过设置代理
CALayer对象有个属性delegate，设置delegate后让delegate实现drawLayer:inContext:方法，再手动发送setNeedsDisplay消息，就会触发drawLayer:inContext:方法，实现自定义图案的绘制。
#import "ViewController.h"
#import "LXXLayer.h"

@interface ViewController ()
@property (nonatomic, strong) CALayer *myLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.myLayer = [CALayer layer];
    self.myLayer.backgroundColor = [UIColor orangeColor].CGColor;
    self.myLayer.bounds = CGRectMake(0, 0, 200, 200);
    self.myLayer.position = CGPointMake(100, 100);
    self.myLayer.anchorPoint = CGPointZero;
    //设置代理
    self.myLayer.delegate = self;
    [self.view.layer addSublayer:self.myLayer];

    //触发drawLayer:inContext:方法
    [self.myLayer setNeedsDisplay];
}

- (void)viewWillDisappear:(BOOL)animated{
    [super viewWillDisappear:animated];
    self.myLayer.delegate = nil;
}

- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx{
    CGContextMoveToPoint(ctx, 50, 90);
    CGContextAddLineToPoint(ctx, 100, 20);
    CGContextSetStrokeColorWithColor(ctx, [UIColor greenColor].CGColor);
    CGContextSetLineWidth(ctx, 10);
    CGContextSetLineCap(ctx, kCGLineCapRound);
    CGContextStrokePath(ctx);
}
@end

说明:可以看到在设置delegate的时候并没有要求我们遵循协议，说明这个协议方法是定义在NSObject协议中的。  
注意:如果对视图控制器设置代理，在视图控制器disappear之前必需将delegate设置为nil，否则会存在内存释放不正常的问题，甚至导致程序crash。
补充说明
（1）无论采取哪种方法来自定义层，都必须调用layer的setNeedsDisplay方法才能正常绘图。
（2）详细现实过程： 
对于自定义UIView而言，当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView，UIView是自身主layer的隐式代理)的drawLayer:inContext:方法(每个UIView都已隐式实现这个方法)，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法。平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android实战简易教程-第四十六枪（自定义控件体验之罗盘）
前言作为一名有创新意思的开发人员，你迟早会发现内置的控件会满足不了你的想象力。拥有扩展已存在的视图、组建复合的控件以及创建独特的新视图能力，可以创建出最适合自己应用程序工作流的有优美用户界面，让用户得到最优的体验。创建新视图的最佳方法和希望达到的目标有关：1.如果现有控件已经可以满足希望实现的基本功能，那么只需对现有控件的外观或行为进行修改或扩展即可。通过重写事件处理程序和onDraw()方法。2.可以通过组合多个视图来创建不可分割的、可重用的控件，从而使它可以综合使用过个相关联的视图功能，比如一键清空TextView组合控件。3.创建一个全新的控件。下面我们通过一个小实例，创建一个罗盘界面来体验一下如何自定义控件。一.创建自定义控件类Compass，继承View:package com.example.compass;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.util.AttributeSet;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;

public class Compass extends View {
	private Paint makerPaint;
	private Paint textPaint;
	private Paint circlePaint;
	private String north, south, east, west;
	private int textHeight;

	public Compass(Context context) {
		super(context);
		initCompassView();
	}

	public Compass(Context context, AttributeSet attrs) {
		super(context, attrs);
		initCompassView();
	}

	public Compass(Context context, AttributeSet attrs, int defStyleAttr) {
		super(context, attrs, defStyleAttr);
		initCompassView();
	}

	private void initCompassView() {
		setFocusable(true);
		Resources r = this.getResources();
		// 画圆
		circlePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
		circlePaint.setColor(r.getColor(R.color.background_color));
		circlePaint.setStrokeWidth(1);
		circlePaint.setStyle(Paint.Style.FILL_AND_STROKE);

		north = r.getString(R.string.cardinal_north);
		south = r.getString(R.string.cardinal_south);
		east = r.getString(R.string.cardinal_east);
		west = r.getString(R.string.cardinal_west);

		textPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
		textPaint.setColor(r.getColor(R.color.text_color));

		textHeight = (int) textPaint.measureText("yY");

		makerPaint = new Paint(Paint.ANTI_ALIAS_FLAG);//抗锯齿
		makerPaint.setColor(r.getColor(R.color.maker_color));

	}

	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		super.onMeasure(widthMeasureSpec, heightMeasureSpec);
		int measureWidth = measure(widthMeasureSpec);
		int measureHeight = measure(heightMeasureSpec);
		int d = Math.min(measureHeight, measureWidth);
		setMeasuredDimension(d, d);
	}

	private int measure(int measureSpec) {
		int result = 0;
		// 对测量说明进行解码
		int speMode = MeasureSpec.getMode(measureSpec);
		int speSize = MeasureSpec.getSize(measureSpec);

		if (speMode == MeasureSpec.UNSPECIFIED) {
			// 如果没有指定界限，则默认返回大小200
			result = 200;
		} else {
			// 由于你希望填充可以的空间，所有总是返回整个可用的的边界
			result = speSize;
		}
		return result;
	}

	//添加属性
	private float bearing;

	public float getBearing() {
		return bearing;
	}

	public void setBearing(float _bearing) {
		bearing = _bearing;
		sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);//添加可访问性支持，罗盘显示方向
	}

	@Override
	protected void onDraw(Canvas canvas) {
		super.onDraw(canvas);
		int mMeasureWidth = getMeasuredWidth();
		int mMeasureHeight = getMeasuredHeight();
		int px = mMeasureWidth / 2;
		int py = mMeasureHeight / 2;
		int radius = Math.min(px, py);//去最小值作为半径；

		// 绘制背景
		canvas.drawCircle(px, py, radius, circlePaint);

		canvas.save();
		canvas.rotate(-bearing, px, py);// 旋转-bearing度角度；

		// 绘制标记

		int textWidth = (int) textPaint.measureText("W");
		int cardinalX = px - textWidth / 2;
		int cardinalY = py - radius + textHeight;

		// 每15度绘制一个标记，每45度绘制一个文本

		for (int i = 0; i < 24; i++) {
			canvas.drawLine(px, py - radius, px, py - radius + 10, makerPaint);
			canvas.save();
			canvas.translate(0, textHeight);

			// 绘制基本方位
			if (i % 6 == 0) {
				String dirString = "";
				switch (i) {
				case 0:
					dirString = north;
					int arrowY = 2 * textHeight;
					canvas.drawLine(px, arrowY, px - 5, 3 * textHeight, makerPaint);
					canvas.drawLine(px, arrowY, px + 5, 3 * textHeight, makerPaint);
					break;
				case 6:
					dirString = east;
					break;
				case 12:
					dirString = south;
					break;
				case 18:
					dirString = west;
					break;

				default:
					break;
				}
				canvas.drawText(dirString, cardinalX, cardinalY, textPaint);
				// 每45度绘制文本
			} else if (i % 3 == 0) {
				String angle = String.valueOf(i * 15);
				float angleTextWidth = textPaint.measureText(angle);
				int angleTextX = (int) (px - angleTextWidth / 2);
				int angleTextY = py - radius + textHeight;
				canvas.drawText(angle, angleTextX, angleTextY, textPaint);
			}
			canvas.restore();
			canvas.rotate(15, px, py);
		}
		canvas.restore();

	}

	// 将当前方向用作可访问性事件使用的内容
	@Override
	public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
		super.dispatchPopulateAccessibilityEvent(event);
		if (isShown()) {
			String bearingStr = String.valueOf(bearing);
			if (bearingStr.length() > AccessibilityEvent.MAX_TEXT_LENGTH)
				bearingStr = bearingStr.substring(0, AccessibilityEvent.MAX_TEXT_LENGTH);
			event.getText().add(bearingStr);
			return true;
		} else {
			return false;
		}

	}

}
二、配置属性<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">Compass</string>
    <string name="hello_world">Hello world!</string>
    <string name="action_settings">Settings</string>
    <string name="cardinal_north" >N</string>
    <string name="cardinal_east" >E</string>
    <string name="cardinal_south" >S</string>
    <string name="cardinal_west" >W</string>
    

</resources>
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="background_color">#F555</color>
    <color name="maker_color">#AFFF</color>
    <color name="text_color">#AFFF</color>    
</resources>
三、引入自定义控件<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <com.example.compass.Compass
        android:id="@+id/compass"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</RelativeLayout>package com.example.compass;

import android.app.Activity;
import android.os.Bundle;

public class MainActivity extends Activity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		Compass compass=(Compass) this.findViewById(R.id.compass);
		compass.setBearing(0);
	}

	
}
运行实例：喜欢的朋友关注我和我的公众号！谢谢

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android应用开发（二）：Activity生命周期剖析以及如何启动新的Activity或网页

本文讲述组件Activity的相关知识，主要包括如何启动一个Activity、如何打开一个网页，最后解析Activity的生命周期相关知识。


1、如何启动一个Activity



（1）、新建一个Activity
要启动一个新的Activity，就必须先创建一个新的Activity，Android Studio可以直接创建Activity而不需要一行一行的敲代码，这就是前面所说的采用Android Studio平台的好处之一。
具体代码如下：
package edu.fred.hqu.androidactivity;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;

public class AnotherAty extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_another_aty);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_another_aty, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        int id = item.getItemId();

        //noinspection SimplifiableIfStatement
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
}
Android Studio的好处还在于，Android Studio可以在layout和AndroidManifest.xml中将新建的Activity所需要的代码自动生成，如下图所示：








（2）、加入Button
然后，我们在activity_main.xml中加入一个Button，旨在点击该按键可以进入另一个Activity，代码如下：
<Button
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="点击启动一个界面"
    android:id="@+id/btnStartAnotherAty1"
    android:layout_below="@+id/textView"
    android:layout_alignParentLeft="true"
    android:layout_alignParentStart="true" />
（3）、修改MainActivity.java
接着，在MainActivity.java中加入如下代码：
/*启动另一个Activity*/
findViewById(R.id.btnStartAnotherAty1).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        startActivity(new Intent(MainActivity.this, AnotherAty.class));//启动另一个Activity

    }
});
（4）、编译运行
最后编译运行，结果如下图所示：







2、如何打开一个网页



打开网页很简单，直接在MainActivity.java中加入如下代码：
/*启动另一个网页*/
findViewById(R.id.btnStartAnotherAty2).setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://blog.csdn.net/frd2009041510")));//启动另一个网页

    }
});
为了观察效果，可以像之前一样加一个按键，最后给出效果图









3、Activity的生命周期



生命周期示意图如下：




接下来，我们加入代码验证该图，加入的代码如下：
/*Activity生命周期*/

@Override
protected void onStart() {
    super.onStart();
    System.out.println("A onStart");
}

@Override
protected void onResume() {
    super.onResume();
    System.out.println("A onResume");
}

@Override
protected void onPause() {
    super.onPause();
    System.out.println("A onPause");
}

@Override
protected void onStop() {
    super.onStop();
    System.out.println("A onStop");
}

@Override
protected void onDestroy() {
    super.onDestroy();
    System.out.println("A onDestroy");
}

@Override
protected void onRestart() {
    super.onRestart();
    System.out.println("A onRestart");
}
在另一个Activity中加入代码如下：
/*Activity生命周期*/
@Override
protected void onStart() {
    super.onStart();
    System.out.println("B onStart");
}

@Override
protected void onResume() {
    super.onResume();
    System.out.println("B onResume");
}

@Override
protected void onPause() {
    super.onPause();
    System.out.println("B onPause");
}

@Override
protected void onStop() {
    super.onStop();
    System.out.println("B onStop");
}

@Override
protected void onDestroy() {
    super.onDestroy();
    System.out.println("B onDestroy");
}

@Override
protected void onRestart() {
    super.onRestart();
    System.out.println("B onRestart");
}
最后运行，查看运行日志验证结果，下面给出开始运行的一部分结果截图，执行的步骤是进入Activity，点击启动另一个Activity，结果如下图：



实验结果分析：主Activity首先启动，即A onCreate、A onStart、A onResume，点击启动另一个新的Activity后A onPause，接着B onCreate、B onStart、B onResume，最后A onStop，可以看出完全符合Activity周期图。







版权声明：本文为博主原创文章，未经博主允许不得转载。

spring 引用其他bean
applicationContext.xml配置文件为:
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:p="http://www.springframework.org/schema/p"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd">
<!-- 配置bean -->

<bean id="car" class="com.spring.Car">
<constructor-arg value="green"></constructor-arg>
<constructor-arg value="22"></constructor-arg>
</bean>


<bean id="person" class="com.spring.Person">
<property name="name" value="xiao"></property>
<property name="age" value="22"></property>
<property name="car" ref="car"></property>
</bean>
</beans>



package com.spring;


public class Car {
 private String name;
 private String color;
 private int num;
public Car(String color, int num) {
super();
this.color = color;
this.num = num;
}
@Override
public String toString() {
return "Car [name=" + name + ", color=" + color + ", num=" + num + "]";
}


}



package com.spring;


public class Person {
 private String name;
 private  int age;
 private Car car;
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public int getAge() {
return age;
}
public void setAge(int age) {
this.age = age;
}
public Car getCar() {
return car;
}
public void setCar(Car car) {
this.car = car;
}
@Override
public String toString() {
return "Person [name=" + name + ", age=" + age + ", car=" + car + "]";
}
 


}



测试类：
package com.spring;


import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class Test {
public static void main(String[] args) {


//1.创建spring IOC容器
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");



Car car = (Car) ctx.getBean("car");
//System.out.println(car.toString());

Person person = (Person) ctx.getBean("person");
System.out.println(person);
}
}

运行结果为:
Person [name=xiao, age=22, car=Car [name=null, color=green, num=22]]








版权声明：本文为博主原创文章，未经博主允许不得转载。

《AndroidStudio每日一贴》7. 如何将本地变更文件移到其它的changelist？
操作方法:进入Version Control —> Local Changes ，会显示本地变更列表分组.如果你想将某个changelist中的文件转移到其它的changelist, 选中此文件,在弹出的菜单中选择 [Move to Another Changelist].如下图:然后你可以选择已存在的changelist,或自己新建一个.更多实用技巧请查看《AndroidStudio实用指南》博客: http://blog.csdn.net/wirelessqa 作者: 老毕

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Overview Screen -- 概览界面
Android Overview Screen – 概览界面
原文链接:http://developer.android.com/guide/components/recents.html{:target=”_blank”}
概览界面（Overview Screen，通常也被叫做最近屏幕、最近任务列表、最近应用等）是一个系统级的界面，用来展示最近访问的一些活动(Activities)或者任务(Tasks)。用户可以通过上下滑动来浏览这个列表，并且可以选择一个任务来恢复或者通过左右滑动一个任务来把这个任务从这个概览界面里移除。从Android5.0（API等级为21）开始，包含不同文档（Documents）的同一个活动的多个实例可能会作为多个任务出现在概览界面。例如，Google Drive这个应用会为它打开的每一篇文档都分配一个“任务”。这样，每一个文档都会以一个任务的形式在概览界面里显示。


Figure 1. 这个概览界面展现了三篇Google Drive打开的文档，每一个都作为一个独立的任务来显示。

通常，你需要允许系统来定义你的任务和活动如何在概览界面上展现，而你却无需去修改这种行为。不过，你的App可以自己定义其中的活动在何时以何种方式出现在概览界面。你可以通过ActivityManager.AppTask来管理任务，以及通过Intent类中活动的标志位（flags）来定义一个活动是在何时被添加或移除出概览屏幕的（这句话本学渣感觉翻的很别扭，哪位好心的同学可以帮忙留言纠正一下呀，原文如下：The ActivityManager.AppTask class lets you manage tasks, and the activity flags of the Intent class let you specify when an activity is added or removed from the overview screen.）。同样，我们可以配置清单文件中<activity>标签的属性来定义上述行为。
Adding Tasks to the Overview Screen – 往概览屏幕中添加任务
用Intent类的标志位来新增一个任务，可以为一个在概览界面上的文档在何时以及如何被打开或重新打开增加更多的控制。而使用<activity>标签时，你可以决定在打开一个文档时，是使用一个新的任务亦或是重用一个已经存在的任务，而这种清单文件中定义的行为一旦定义则不会改变。

Using the Intent flag to add a task – 使用Intent类的标志位来添加一个任务
启动活动时，你应该把Intent传给ActivityManager.AppTask类的startActivity()方法，来为你的活动创建一个文档。如果要创建一个逻辑上的断点来让系统把你的活动作为一个新的任务显示在概览屏幕上，你应当把FLAG_ACTIVITY_NEW_DOCUMENT标志位传给用来来启动这个活动Intent对象的addFlag()方法。

NOTE: FLAG_ACTIVITY_NEW_DOCUMENT标志位已经取代了FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET，后者已经在Android5.0(API等级21)中过期了。

如果你创建一个新文档时用了FLAG_ACTIVITY_MULTIPLE_TASK标志位，则系统在每次打开这个活动时都会创建一个任务，并把这个活动作为根活动放进去。这种操作允许同样的文档在多个任务中打开。下面代码演示了主活动时如何做的：
DocumentCentricActivity.java
public void createNewDocument(View view) {
      boolean useMultipleTasks = mCheckbox.isChecked();
      final Intent newDocumentIntent = newDocumentIntent();
      if (useMultipleTasks) {
          newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
      }
      startActivity(newDocumentIntent);
  }

  private Intent newDocumentIntent() {
      final Intent newDocumentIntent = new Intent(this, NewDocumentActivity.class);
      newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);
      newDocumentIntent.putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, incrementAndGet());
      return newDocumentIntent;
  }

  private static int incrementAndGet() {
      Log.d(TAG, "incrementAndGet(): " + mDocumentCounter);
      return mDocumentCounter++;
  }
}

NOTE: 被FLAG_ACTIVITY_NEW_DOCUMENT标志位启动的活动，它在清单文件中定义的启动方式必须是默认启动方式：android:launchMode="standard"

当主活动用Intent启动一个新的活动时，系统会搜索所以存在的任务来找到一二任务，即这个任务的Intent符合当前Intent的组件名和数据。如果没找到符合的任务，或者这个Intent携带了一个FLAG_ACTIVITY_MULTIPLE_TASK标志位，一个新的任务会被创建，而这个即将启动的活动会作为这个任务的根活动。而如果找到了对应的任务，系统会把这个任务带回前台，并把新的Intent传递给活动的onNewIntent()方法。这个新的活动获得Intent并在开始概览屏幕上创建一个新的文档，如下面的代码所示：
NewDocumentActivity.java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_new_document);
    // TODO something
}

@Override
protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    /* If FLAG_ACTIVITY_MULTIPLE_TASK has not been used, this activity
    is reused to create a new document.
     */
}
Using the activity attribute to add a task –  用清单文件中“活动”标签的属性来添加一个任务
一个活动可以在清单文件中定义它总是启动到一个新的任务，即在“活动”标签中使用属性：android:documentLaunchMode。当用户打开一个文档时，这个参数有四种类型来产生不同的效果：

intoExisting

活动会重用已存在的任务。这个参数类似于Intent中添加了FLAG_ACTIVITY_NEW_DOCUMENT标志位，却没有添加FLAG_ACTIVITY_MULTIPLE_TASK，可以参考上面Using the Intent flag to add a task – 使用Intent类的标志位来添加一个任务的描述。

always

活动为这个文档创建一个新的任务，即使这个文档已经被打开。这个参数类似于Intent中同时添加了FLAG_ACTIVITY_NEW_DOCUMENT和FLAG_ACTIVITY_MULTIPLE_TASK标志位。

none

活动不为这个文档创建一个新的任务。概览屏幕以默认方式对待这个活动，级：整个应用会作为一个任务在概览界面上显示，而概览屏幕会在用户选择这个应用后唤醒用户最后使用的活动。

never

活动不为这个文档创建一个新的任务。不同于none，设置这个参数会覆盖Intent中的FLAG_ACTIVITY_NEW_DOCUMENT和FLAG_ACTIVITY_MULTIPLE_TASK标志位。即使这些标志位被设置，整个应用还是会作为一个任务在概览界面上显示，而概览屏幕会在用户选择这个应用后唤醒用户最后使用的活动。

NOTE: 当参数不选择none和never时，活动必须被定义为：launchMode="standard"。如果android:documentLaunchMode参数没有被定义，则none参数会作为默认值。

Removing Tasks – 移除任务
默认情况下，一个带文档的任务会在它的活动被结束的时候自动从概览界面上移除。不过，你可以通过ActivityManager.AppTask类、Intent的标志位或者清单文件中“活动”标签的属性来覆盖这种行为。
你可以设置“活动”标签的属性来把一个任务排除在概览屏幕值外，即android:excludeFromRecents="true"。
你可以定义你的应用在概览界面上显示的任务的数量的最大值，即android:maxRecents属性。这个属性是一个整型，默认值是16。当任务的数量到达最大值时，最近最少被使用的任务则会在概览界面上被移除。这个属性的最大值时50（低内存设备上是25），最小值为1.
Using the AppTask class to remove tasks – 用AppTask类来移除任务
在创建了一个新任务到概览屏幕的活动中，你可以定义何时移除这个任务，以及通过调用finishAndRemoveTask()方法来结束所有关联到这个任务上的活动。
NewDocumentActivity.java
public void onRemoveFromRecents(View view) {
    // The document is no longer needed; remove its task.
    finishAndRemoveTask();
}

NOTE: 使用finishAndRemoveTask()方法会覆盖下面提到的FLAG_ACTIVITY_RETAIN_IN_RECENTS标志位。

Retaining finished tasks – 保持已经结束的任务
如果你想在活动结束之后，依然在概览屏幕上显示这个任务，你可以在启动这个活动的Intent中添加FLAG_ACTIVITY_RETAIN_IN_RECENTS标志位。
DocumentCentricActivity.java
private Intent newDocumentIntent() {
    final Intent newDocumentIntent = new Intent(this, NewDocumentActivity.class);
    newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT |
      android.content.Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);
    newDocumentIntent.putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, incrementAndGet());
    return newDocumentIntent;
}
为了达成同样的效果，可以在清单文件的“活动”标签下添加android:autoRemoveFromRecents="false"。这个属性对于一般活动来说默认值为false，而对于设置了文档属性的活动来说，默认值则为true.而这个参数会覆盖上面提到的FLAG_ACTIVITY_RETAIN_IN_RECENTS标志位。
文章里用到的代码源码：点我下载{:target=”_blank”}

就这么多啦，用了两个晚上才搞定。翻的烂的地方请大家多包涵（学渣伤不起呀T.T）。


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
Android-Notification （通知实现）
1.回顾
  上篇学习了 Dialog实现的 6中方式 ：普通对话框，列表对话框，单选对话框，多选对话框，自定义对话框和 activity 实现 对话框；
2.重点
   （1）Notification 实现 通知
   （2）Notification 的权限
   （3）NotificationManager 实现操作通知
3.基本实现
   3.1效果图
      手机 小米4 ，是有声音和震动的，这里没办法展示；
                                                               

   3.2 布局实现
       两个按钮：
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="${relativePackage}.${activityClass}" >

    <TextView
        android:id="@+id/textView1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello_world" />

    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentRight="true"
        android:layout_below="@+id/textView1"
        android:layout_marginTop="16dp"
        android:text="发送通知" />

    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentRight="true"
        android:layout_below="@+id/button1"
        android:text="取消通知" />

</RelativeLayout>


     3.3 代码实现
package com.example.studydemo7;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.Notification;
import android.app.Notification.Builder;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends Activity {

	private Button button1,button2;
	
	
	//通知 是通过 NotificationManager 来管理的
	private NotificationManager manager;
	
	private final int NOTIFICATION_ID=1;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		
		//初始化 得到 通知 系统服务
		manager=(NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
		
		button1=(Button) findViewById(R.id.button1);
		button2=(Button) findViewById(R.id.button2);
		button1.setOnClickListener(new button1ClickListener());
		button2.setOnClickListener(new button2ClickListener());
		
	}
	
	class button1ClickListener implements OnClickListener{

		@Override
		public void onClick(View v) {
			//发送通知
			sendNotification();
		}
		
	}
	class button2ClickListener implements OnClickListener{

		@Override
		public void onClick(View v) {
			//取消通知
			manager.cancel(NOTIFICATION_ID);
		}
		
	}
	
	@SuppressLint("NewApi")
	private void sendNotification(){
		
		//通过 Builder 来创建  Notification 的
		Builder builder=new Notification.Builder(this);
		//设置 通知 图标
		builder.setSmallIcon(R.drawable.ic_launcher);
		//设置 通知 显示标题
		builder.setTicker("Hi");
		//设置 通知栏 标题
		builder.setContentTitle("StudyDemo");
		//设置 通知内容
		builder.setContentText("StudyDemo 需要更新了！");
		//设置 提醒 声音/震动/指示灯
		builder.setDefaults(Notification.DEFAULT_ALL);
		
		//设置 点击后的跳转 通过 pendingIntent 实现
		Intent intent=new Intent(this,MainActivity.class);
		PendingIntent pendingIntent=PendingIntent.getActivity(this,0, intent,0);
		builder.setContentIntent(pendingIntent);
		
		//创建 通知 
		//安卓4.1 及其 以上使用 build()方法 ，以下的使用  builder.getNotification();
		Notification notification=builder.build();
		manager.notify(NOTIFICATION_ID, notification);
	}
	
	
	
	
	
}


4.demo 免积分下载
http://download.csdn.net/detail/lablenet/9048745






版权声明：本文为博主原创文章，未经博主允许不得转载。

class和struct的区别
C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。
struct能包含成员函数吗？ 能！
struct能继承吗？ 能！！
struct能实现多态吗？ 能！！！ 
既然这些它都能实现，那它和class还能有什么区别？
最本质的一个区别就是默认的访问控制： 
默认的继承访问权限
struct是public的，class是private的。
你可以写如下的代码：
struct A
{
  char a;
}；
struct B : A
{
  char b;
}；
这个时候B是public继承A的。
如果都将上面的struct改成class，那么B是private继承A的。这就是默认的继承访问权限。 
所以我们在平时写类继承的时候，通常会这样写：
class B : public A
就是为了指明是public继承，而不是用默认的private继承。
 
当然，到底默认是public继承还是private继承，取决于子类而不是基类。
我的意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。如下：
 
struct A{}；class B : A{}; //private继承
struct C : B{}； //public继承
 
struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的
 
我依旧强调struct是一种数据结构的实现体，虽然它是可以像class一样的用。我依旧将struct里的变量叫数据，class内的变量叫成员，虽然它们并无区别。

到底是用struct还是class，完全看个人的喜好，你可以将程序里所有的class全部替换成struct，它依旧可以很正常的运行。但我给出的最好建议，还是：当你觉得你要做的更像是一种数据结构的话，那么用struct，如果你要做的更像是一种对象的话，那么用class。 
当然，我在这里还要强调一点的就是，对于访问控制，应该在程序里明确的指出，而不是依靠默认，这是一个良好的习惯，也让你的代码更具可读性。 
说到这里，很多了解的人或许都认为这个话题可以结束了，因为他们知道struct和class的“唯一”区别就是访问控制。很多文献上也确实只提到这一个区别。 
但我上面却没有用“唯一”，而是说的“最本质”，那是因为，它们确实还有另一个区别，虽然那个区别我们平时可能很少涉及。
那就是：“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。这一点在Stanley B.Lippman写的Inside the C++ Object Model有过说明。 
问题讨论到这里，基本上应该可以结束了。但有人曾说过，他还发现过其他的“区别”，那么，让我们来看看，这到底是不是又一个区别。还是上面所说的，C++中的struct是对C中的struct的扩充，既然是扩充，那么它就要兼容过去C中struct应有的所有特性。例如你可以这样写： 
struct A //定义一个struct
{
   char c1;
   int n2;
   double db3;
};
A a={'p', 7, 3.1415926}; //定义时直接赋值 
也就是说struct可以在定义的时候用{}赋初值。那么问题来了，class行不行呢？将上面的struct改成class，试试看。报错！噢~于是那人跳出来说，他又找到了一个区别。我们仔细看看，这真的又是一个区别吗？ 
你试着向上面的struct中加入一个构造函数（或虚函数），你会发现什么？
对，struct也不能用{}赋初值了
的确，以{}的方式来赋初值，只是用一个初始化列表来对数据进行按顺序的初始化，如上面如果写成A a={'p',7};则c1,n2被初始化，而db3没有。这样简单的copy操作，只能发生在简单的数据结构上，而不应该放在对象上。加入一个构造函数或是一个虚函数会使struct更体现出一种对象的特性，而使此{}操作不再有效。 
事实上，是因为加入这样的函数，使得类的内部结构发生了变化。而加入一个普通的成员函数呢？你会发现{}依旧可用。其实你可以将普通的函数理解成对数据结构的一种算法，这并不打破它数据结构的特性。 
那么，看到这里，我们发现即使是struct想用{}来赋初值，它也必须满足很多的约束条件，这些条件实际上就是让struct更体现出一种数据机构而不是类的特性。 
那为什么我们在上面仅仅将struct改成class，{}就不能用了呢？
其实问题恰巧是我们之前所讲的——访问控制！你看看，我们忘记了什么？对，将struct改成class的时候，访问控制由public变为private了，那当然就不能用{}来赋初值了。加上一个public，你会发现，class也是能用{}的，和struct毫无区别！！！ 
做个总结，从上面的区别，我们可以看出，struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。
[Android]仿京东手机端类别页
[Android]仿京东手机端类别页
京东手机端的类别标签页, 是一个左侧滑动可选择类别, 右侧一个类别明细的列表联动页面. 当用户选择左侧选项, 可在右侧显示更多选项来选择. 实现方式也不少. 最常见的当然是左侧和右侧各一个Fragment, 左侧Fragment放置ListView, 右侧放显示类别明细的Fragment. 如果觉得页面包含的Fragment太多, 左侧直接给一个ListView就可以了.不影响效果.
效果图:

例子中值得注意的三点:

左侧列表点击某个Item可以自动上下滑动,使所点击的item自动移至列表中间
点击item后保留背景色不变 
右侧布局

针对上面三个点,这里采取如下的解决方法:

计算可见列表的可见首项或末项position值,使用smoothScrollToPosition()方法实现滑动
自定义列表selector按下和松开的背景色,在adapter去更新并控制item的背景色
右侧布局,采用Fragment是最好的. 里面使用ScrollView装载所有数据,可以动态的addView(),removeView(), 网格布局使用GridView.  由于Fragment, 所以更新数据和更新View都非常方便, 所以例子中直接用静态页面模拟数据了.

重在通过简单的例子解释这种实现思路, 当然实现不是唯一的. 
然后,我们先来模拟右侧的Fragment数据,一看就懂的代码:

public class JDFragment extends Fragment{
    String TAG = "JDFragment";
    private View rootView = null;
    private LinearLayout llayout_main = null;
    private TextView tv = null;

    private LinearLayout.LayoutParams lp_gd = null;
    private LinearLayout.LayoutParams lp_tv = null;
    private ArrayList<Category> itemList = null;
    private GDAdapter adapter = null;


    @Override
    public void onAttach(Activity activity)
    {
        Log.e(TAG, "onAttach...");
        super.onAttach(activity);
    }

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        Log.e(TAG, "onCreate...");
        super.onCreate(savedInstanceState);
    }


    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState)
    {
        Log.e(TAG, "onCreateView...");
        rootView = inflater.inflate(R.layout.jd_frg_main, null);
        llayout_main = (LinearLayout) rootView.findViewById(R.id.llayout_jd_frg_main);
        tv = (TextView) rootView.findViewById(R.id.tv_jd_frg_main);

        updateTitle();

        //模拟数据
        for(int i=0; i<2; i++)
        {
            setData();          
        }

        return rootView;
    }

    protected void updateTitle()
    {
        if(getArguments() != null)
        {
            updateTitle(getArguments().getString("name"));
        }
    }

    protected void updateTitle(String title)
    {
        if(tv != null)
        {
            tv.setText(title);
        }
    }

    private void setData()
    {
        if(itemList == null)
        {
            itemList = new ArrayList<Category>();
            for(int i=1; i<11; i++)
            {
                itemList.add(new Category("选项 " + i, ""+i));
            }
        }

        //高度60dp+行距8dp = 68dp
        int heightUnit = (int)TypedValue
                .applyDimension(TypedValue.COMPLEX_UNIT_DIP, 68, getResources().getDisplayMetrics());
        int height;

        //计算Gridview总高度
        if(itemList.size() % 3 == 0)
        {
            height = (itemList.size()/3 + 2)*heightUnit;
        }
        else{
            height = (itemList.size()/3 + 1)*heightUnit;
        }

        if(lp_gd == null)
            lp_gd = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, height);

        if(lp_tv == null)
            lp_tv = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT
                    , (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP
                            , 30, getResources().getDisplayMetrics()));

        TextView tv_title = new TextView(getActivity());
        tv_title.setLayoutParams(lp_tv);
        tv_title.setText("组一");
        llayout_main.addView(tv_title);

        GridView gridView = new GridView(getActivity());
        gridView.setNumColumns(3);
        gridView.setVerticalSpacing(8);
        gridView.setLayoutParams(lp_gd);

        adapter = new GDAdapter(getActivity(), itemList,R.drawable.cate);
        gridView.setAdapter(adapter);
        llayout_main.addView(gridView);
    }


    @Override
    public void onActivityCreated(Bundle savedInstanceState)
    {
        Log.e(TAG, "onActivityCreated...");
        super.onActivityCreated(savedInstanceState);
    }

    @Override
    public void onStart()
    {
        Log.e(TAG, "onStart...");
        super.onStart();
    }

    @Override
    public void onResume()
    {
        Log.e(TAG, "onResume...");
        super.onResume();
    }

    @Override
    public void onPause()
    {
        Log.e(TAG, "onPause...");
        super.onPause();
    }

    @Override
    public void onStop()
    {
        Log.e(TAG, "onStop...");
        super.onStop();
    }

    @Override
    public void onDestroyView()
    {
        Log.e(TAG, "onDestroyView...");
        super.onDestroyView();
    }

    @Override
    public void onDestroy()
    {
        Log.e(TAG, "onDestroy...");
        super.onDestroy();
    }

    @Override
    public void onDetach()
    {
        Log.e(TAG, "onDetach...");
        super.onDetach();
    }

    static class GDAdapter extends BaseAdapter
    {
        Context context;
        List<Category> results;
        int imageId;
        ViewHolder holder = null;

        public GDAdapter(Context context, List<Category> results,int imageId) {
            this.context = context;
            this.results = results;
            this.imageId = imageId;
        }

        @Override
        public int getCount() {
            // TODO Auto-generated method stub
            return results.size();
        }

        @Override
        public Object getItem(int position) {
            // TODO Auto-generated method stub
            return results.get(position);
        }


        @Override
        public long getItemId(int position) {
            // TODO Auto-generated method stub
            return position;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            Category c = (Category)getItem(position);

            if(convertView == null)
            {
                holder = new ViewHolder();
                convertView = LayoutInflater.from(context).inflate(R.layout.jd_item, null);
                holder.tv = (TextView) convertView.findViewById(R.id.tv_jd_item);
                holder.imv = (ImageView) convertView.findViewById(R.id.imv_jd_item);
            }
            else
            {
                holder = (ViewHolder) convertView.getTag();
            }
            convertView.setTag(holder);

            holder.tv.setText(c.getName());
            holder.imv.setImageResource(imageId);

            return convertView;
        }

        class ViewHolder
        {
            TextView tv;
            ImageView imv;
        }
    }

}

JDFragment的布局文件, jd_frg_main.xml:
<?xml version="1.0" encoding="utf-8" ?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#FFFFFF"
    >
    <TextView 
        android:id="@+id/tv_jd_frg_main"
        android:layout_width="match_parent"
        android:layout_height="25dp"
        android:text="Fragment"
        android:textSize="16sp"
        android:background="#EEEEEE"
        />
    <ScrollView 
        android:id="@+id/scrlayout_jd_frg_main"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@+id/tv_jd_frg_main"
        android:overScrollMode="never"
        >
        <LinearLayout 
            android:id="@+id/llayout_jd_frg_main"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            />
    </ScrollView>


</RelativeLayout>
将所有数据放在ScrollView的线性布局中,使用Fragment作为容器, 可以根据需要ADD, Remove和Update数据和View. 到这里右侧页面的简单模拟实现就结束了,都是一目了然的代码. 
然后就是实现左侧列表了,先是列表中简单的自定义Adapter, MyAdapter:
public class MyAdapter extends BaseAdapter
{
    private Context context;
    private List<Category> results;
    private int imageId;
    private ViewHolder holder = null;
    private int selectedId;

    public MyAdapter(Context context, List<Category> results,int imageId) {
        this.context = context;
        this.results = results;
        this.imageId = imageId;
    }

    @Override
    public int getCount() {
        // TODO Auto-generated method stub
        return results.size();
    }

    @Override
    public Object getItem(int position) {
        // TODO Auto-generated method stub
        return results.get(position);
    }


    @Override
    public long getItemId(int position) {
        // TODO Auto-generated method stub
        return position;
    }

    public void setSelected(int position)
    {
        this.selectedId = position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        Category c = (Category)getItem(position);

        if(convertView == null)
        {
            holder = new ViewHolder();
            convertView = LayoutInflater.from(context).inflate(R.layout.jd_item, null);
            holder.tv = (TextView) convertView.findViewById(R.id.tv_jd_item);
            holder.imv = (ImageView) convertView.findViewById(R.id.imv_jd_item);
        }
        else
        {
            holder = (ViewHolder) convertView.getTag();
        }

        if(position == selectedId)
        {
            convertView.setBackgroundResource(R.drawable.sele_true);
        }
        else
        {
            convertView.setBackgroundResource(R.drawable.sele_false);
        }

        holder.tv.setText(c.getName());
        holder.imv.setImageResource(imageId);
        convertView.setTag(holder);

        return convertView;
    }

    class ViewHolder
    {
        TextView tv;
        ImageView imv;
    }
}

然后是主Activity了, 在里面对可见ListView的item位置进行计算, 并进行滑动处理. 当用户点击偏上的item, 列表就往下滑动, 加载顶部更多的item; 当用户点击偏下的item, 列表就往上滑动, 加载底部更多的item. 
同时我们自定义按下和松开时的背景文件放在drawable, 随便一个shape就可以了. 然后点击某个item的position时, 在adapter中判断是否目标item, 是就设置按下背景色 - 白色, 否则就是正常的背景色 - 灰色.
/**
 * 仿京东类别页
 * @author AlexTam
 */
public class JDActivity extends FragmentActivity{
    private ListView lv_main = null;
    private EditText et_search = null;

    private ArrayList<Category> itemList = new ArrayList<Category>(); 
    private MyAdapter adapter = null;
    //可见列表项的数量
    private int visibleCount = 0;
    //上次点击的位置
    private int lastPosition = 0;
    private int ce = 0;
    //实际列表是否超出屏幕
    private boolean isOut = true;
    private JDFragment fragment = null;

    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.jd_main);

        init();
    }


    private void init()
    {
        lv_main = (ListView) findViewById(R.id.lv_main);
        et_search = (EditText) findViewById(R.id.et_search);

        for(int i=1; i<21; i++)
        {
            itemList.add(new Category("选项 " + i, ""+i));
        }

        adapter = new MyAdapter(this, itemList,R.drawable.ic_launcher);
        lv_main.setAdapter(adapter);
        lv_main.setOnItemClickListener(new MyOnItemOnClick());
        lv_main.setSelector(R.color.pink);

        //模拟右侧标签页
        fragment = new JDFragment();
        Bundle bundle = new Bundle();
        bundle.putString("name", "c1");
        fragment.setArguments(bundle);
        FragmentManager fm = getSupportFragmentManager();
        FragmentTransaction ft = fm.beginTransaction();
        ft.replace(R.id.flayout_main, fragment, "c0").commit();

        adapter.setSelected(0);
        adapter.notifyDataSetChanged();
    }

    private class MyOnItemOnClick implements OnItemClickListener
    {
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position,
                long id) 
        {
            //计算滑动
            if(visibleCount == 0)
            {
                visibleCount = lv_main.getChildCount();
                if(visibleCount == itemList.size())
                    isOut = false;
                else
                {
                    ce = visibleCount/2;
                }
            }

            if(position <= (parent.getFirstVisiblePosition() + ce))
            {   //上移
                lv_main.smoothScrollToPosition(position - ce);
            }
            else
            {   //下移
                if((parent.getLastVisiblePosition() + ce + 1) <= parent.getCount())
                {
                    lv_main.smoothScrollToPosition(position + ce);
                }
                else
                {
                    lv_main.smoothScrollToPosition(parent.getCount()-1);
                }

            }

            lastPosition = position;

            adapter.setSelected(position);
            adapter.notifyDataSetChanged();

            //更新右侧标签页的标题
            fragment.updateTitle("c" + (position+1));
        }

    }


    /**
     * 选项对象
     */
    static class Category
    {
        private String name;
        private String id;

        Category(String name,String id)
        {
            this.name = name;
            this.id = id;
        }

        public String getName()
        {
            return this.name;
        }
    }



}
OK, 到此效果就出来了. 好简单吧!

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

如何得到Ubuntu手机上的IP地址
在这篇文章中，我们介绍如何在Ubuntu QML应用中得到手机上的IP地址。


我们在我们的main.cpp中加入一些代码来得到IP地址：


main.cpp


#include <QGuiApplication>
#include <QQmlApplicationEngine>
#include <QQuickView>
#include <QNetworkInterface>
#include <QQmlContext>

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);

    QList<QHostAddress> list = QNetworkInterface::allAddresses();
    QStringList datalist;

    for(int nIter = 0; nIter < list.count(); nIter++) {
        qDebug() << list[ nIter ].toString();
        datalist.append(list[ nIter ].toString());
    }

    QQuickView view;
    view.setSource(QUrl(QStringLiteral("qrc:///Main.qml")));
    view.setResizeMode(QQuickView::SizeRootObjectToView);

    QQmlContext *ctxt = view.rootContext();
    ctxt->setContextProperty("myModel", QVariant::fromValue(datalist));

    view.show();
    return app.exec();
}



Main.qml


import QtQuick 2.0
import Ubuntu.Components 1.1

/*!
    \brief MainView with a Label and Button elements.
*/

MainView {
    // objectName for functional testing purposes (autopilot-qt5)
    objectName: "mainView"

    // Note! applicationName needs to match the "name" field of the click manifest
    applicationName: "ipaddress.liu-xiao-guo"

    /*
     This property enables the application to change orientation
     when the device is rotated. The default is false.
    */
    //automaticOrientation: true

    // Removes the old toolbar and enables new features of the new header.
    useDeprecatedToolbar: false

    width: units.gu(60)
    height: units.gu(85)

    Page {
        title: i18n.tr("ipaddress")

        Column {
            spacing: units.gu(2)
            anchors {
                margins: units.gu(2)
                fill: parent
            }

            Label {
                id: label
                objectName: "label"
                fontSize: "large"

                text: i18n.tr("IP addresses: ")
            }

            ListView {
                width: parent.width
                height: parent.height - label.height
                model: myModel
                delegate: Text {
                    text: modelData
                }
            }

        }
    }
}



运行我们的应用：






这是我们在利用wifi时显示的IP地址。


我们的源码在： git clone https://gitcafe.com/ubuntu/ipaddress.git



版权声明：本文为博主原创文章，未经博主允许不得转载。

C#chart之PieChart
附源下载：http://download.csdn.net/detail/ilipan/9043099


using System.Web.UI.DataVisualization.Charting;
using System.Drawing;

namespace Chart.AJAX
{
    public partial class Export_AJAX : System.Web.UI.Page
    {
        void CreateChart()
        {
            string[] xValues = { "0-20", "20-30", "30-40", "40-50", "50-60", "> 60", "unknow" };
            int[] yValues = {5, 18, 45, 17, 2, 1, 162 };

            //ChartAreas,Series,Legends 基本設定-------------------------------------------------
            Chart Chart1 = new Chart();
            Chart1.ChartAreas.Add("ChartArea1"); //圖表區域集合
            Chart1.Legends.Add("Legends1"); //圖例集合說明
            Chart1.Series.Add("Series1"); //數據序列集合

            //設定 Chart-------------------------------------------------------------------------
            Chart1.Width = 770;
            Chart1.Height = 400;
            Title title = new Title();
            title.Text = titleStr;
            title.Alignment = ContentAlignment.MiddleCenter;
            title.Font = new System.Drawing.Font("Trebuchet MS", 14F, FontStyle.Bold);
            Chart1.Titles.Add(title);

            //設定 ChartArea1--------------------------------------------------------------------
            Chart1.ChartAreas["ChartArea1"].Area3DStyle.Enable3D = is3D;
            Chart1.ChartAreas[0].AxisX.Interval = 1;

            //設定 Legends-------------------------------------------------------------------------                
            //Chart1.Legends["Legends1"].DockedToChartArea = "ChartArea1"; //顯示在圖表內
            //Chart1.Legends["Legends1"].Docking = Docking.Bottom; //自訂顯示位置
            //背景色
            Chart1.Legends["Legends1"].BackColor = Color.FromArgb(235, 235, 235); 
            //斜線背景
            Chart1.Legends["Legends1"].BackHatchStyle = ChartHatchStyle.DarkDownwardDiagonal; 
            Chart1.Legends["Legends1"].BorderWidth = 1;
            Chart1.Legends["Legends1"].BorderColor = Color.FromArgb(200, 200, 200);

            //設定 Series1-----------------------------------------------------------------------
            Chart1.Series["Series1"].ChartType = SeriesChartType.Pie;
            //Chart1.Series["Series1"].ChartType = SeriesChartType.Doughnut;
            Chart1.Series["Series1"].Points.DataBindXY(xValues, yValues);
            Chart1.Series["Series1"].LegendText = "#VALX:    [ #PERCENT{P1} ]"; //X軸 + 百分比
            Chart1.Series["Series1"].Label = "#VALX\n#PERCENT{P1}"; //X軸 + 百分比
            //Chart1.Series["Series1"].LabelForeColor = Color.FromArgb(0, 90, 255); //字體顏色
            //字體設定
            Chart1.Series["Series1"].Font = new System.Drawing.Font("Trebuchet MS", 10, System.Drawing.FontStyle.Bold); 
            Chart1.Series["Series1"].Points.FindMaxByValue().LabelForeColor = Color.Red;
            //Chart1.Series["Series1"].Points.FindMaxByValue().Color = Color.Red;
            //Chart1.Series["Series1"].Points.FindMaxByValue()["Exploded"] = "true";
            Chart1.Series["Series1"].BorderColor = Color.FromArgb(255, 101, 101, 101);
            
            //Chart1.Series["Series1"]["DoughnutRadius"] = "80"; // ChartType為Doughnut時，Set Doughnut hole size
            //Chart1.Series["Series1"]["PieLabelStyle"] = "Inside"; //數值顯示在圓餅內
            Chart1.Series["Series1"]["PieLabelStyle"] = "Outside"; //數值顯示在圓餅外
            //Chart1.Series["Series1"]["PieLabelStyle"] = "Disabled"; //不顯示數值
            //設定圓餅效果，除 Default 外其他效果3D不適用
            Chart1.Series["Series1"]["PieDrawingStyle"] = "Default"; 
            //Chart1.Series["Series1"]["PieDrawingStyle"] = "SoftEdge";
            //Chart1.Series["Series1"]["PieDrawingStyle"] = "Concave";

            //Random rnd = new Random();  //亂數產生區塊顏色
            //foreach (DataPoint point in Chart1.Series["Series1"].Points)
            //{
            //    //pie 顏色
            //    point.Color = Color.FromArgb(150, rnd.Next(0, 255), rnd.Next(0, 255), rnd.Next(0, 255)); 
            //}
            Page.Controls.Add(Chart1);  
        }
    }
}

http://www.dotblogs.com.tw/suehilary/archive/2011/10/24/46163.aspx


版权声明：本文为博主原创文章，未经博主允许不得转载。

Android-基本控件（SeekBar  可拖动 滚动条的使用）
1.回顾
   上篇学习了 Gallery 和 ImageSwitch 的使用
2.重点 
  （1）SeekBar 的使用
  （2）OnSeekBarChangeListener 监听事件
3.SeekBar 
   可拖动 滚动条 ，含有和 ProgressBar 一样的属性 ;
            android:max="100"
            android:progress="50"
   其监听事件： OnSeekBarChangeListener 有三个方法

      onProgressChanged :改变的时候调用
      onStartTrakingTouch ：开始拖动
      onStopTrakingTouch  ：停止拖动
4.实例
 4.1 效果图
       只有 SeekBar和 当前数值 与当前状态改变的属于 SeekBar的内容；环形滚动条和 按钮 和seekBar无关；
                                                    
   4.2 布局实现
    添加两个 textView 来 实现 对 seekBar 的监听 改变 显示； <SeekBar
            android:id="@+id/seekBar1"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_alignParentLeft="true"
            android:layout_below="@+id/textView1"
            android:layout_marginTop="93dp"
            android:max="100"
            android:progress="50" />

        <TextView
            android:id="@+id/textView2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentLeft="true"
            android:layout_below="@+id/textView1"
            android:layout_marginTop="43dp"
            android:text="当前数值：" />

        <TextView
            android:id="@+id/textView1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentLeft="true"
            android:layout_alignParentTop="true"
            android:layout_marginTop="57dp"
            android:text="当前状态：" />

    4.3 设置监听
seekBar1=(SeekBar) findViewById(R.id.seekBar1);
		textview1=(TextView) findViewById(R.id.textView1);
		textview2=(TextView) findViewById(R.id.textView2);
		
		//设置监听
		seekBar1.setOnSeekBarChangeListener(new seeKBarChangeListener());
   4.4 监听事件
/**
	 * seekbar 改变事件
	 * @author yuan
	 *
	 */
	class seeKBarChangeListener implements OnSeekBarChangeListener{

		@Override
		public void onProgressChanged(SeekBar seekBar, int progress,
				boolean fromUser) {
			// 数值改变
			textview2.setText("当前数值："+progress);
		}

		@Override
		public void onStartTrackingTouch(SeekBar seekBar) {
			// 开始拖动
			textview1.setText("当前状态：开始拖动");
		}

		@Override
		public void onStopTrackingTouch(SeekBar seekBar) {
			// 结束拖动
			textview1.setText("当前状态：结束拖动");
		}
		
	}

5.demo 免积分下载
http://download.csdn.net/detail/lablenet/9046135




版权声明：本文为博主原创文章，未经博主允许不得转载。

Android性能优化典例（二）
1、使用 Maven 依赖方案代替使用导入jar包方案
如果项目中需要用到第三方jar包，常用的做法是去网上下载后然后放入libs文件夹，再添加到项目依赖，不过，在Android Studio已经不推荐使用这套做法了，因为如果jar有更新，那么每次都要去下载最新版本然后删除历史依赖再添加新版本的依赖，这样做很繁琐，而在Android Studio中，这个问题使用Maven已经很好的解决了，因为AS中默认的是jcenter中央库，而jcenter默认会同步Maven中央库，所以我们可以使用Gradle来添加依赖来代替之前的做法，例如：
dependencies {
    compile 'com.android.support:appcompat-v7:22.+'
    compile 'com.squareup.okhttp:okhttp:2.0.+'
    compile 'com.android.support:recyclerview-v7:22.+'
    compile 'com.android.support:cardview-v7:22.2.+'
}
我们这样使用，就指定了一个版本范围，当构建项目时候会自动从Maven库中获取指定范围的最新版本的jar包资源
2、避免深层次的布局结构（最多不要超过5层）
复杂的结构可以考虑用相对布局
3、将相同控件的相同属性抽取出来为一个style
例如： 
假如有若干个Button，而Button的样式都是统一的，这时候我们可以将Button的字体大小、颜色、背景色、字体类型等抽取出来放在一个style中，供多个Button复用，如：
<style name="MyButton" parent="Base.Widget.AppCompat.Button">
        <item name="android:textSize">16sp</item>
        <item name="android:textColor">#ffffff</item>
        <item name="android:background">#202020</item>
        <item name="android:typeface">sans</item>
</style>
layout布局：
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">

    <Button
        style="@style/MyButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello_world" />

    <Space
        android:layout_width="match_parent"
        android:layout_height="10dp" />

    <Button
        style="@style/MyButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/action_settings" />

    <Space
        android:layout_width="match_parent"
        android:layout_height="10dp" />

    <Button
        style="@style/MyButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/app_name" />
</LinearLayout>
效果： 

可以看到这三个Button的样式都一样，复用了相同的style
4、慎用AsyncTask，使用网络请求框架（Volley、OkHttp）代替
关于AsyncTask在异步网络请求方面用的非常多，因为它使用起来比较轻量，但是关于AsyncTask也存在内存泄漏和结果丢失等问题，下面一起来看看：
1、内存泄漏
如果在Activity中使用AsyncTask以匿名内部类的方式请求网络，由于AsyncTask的生命周期可以比Activity的长（因为请求网络数据是比较耗时的），AsyncTask内部类持有Activity的引用的话，如果还在请求网络时就关闭了Activity，那么将导致Activity对象将无法回收，进而产生内存泄漏
2、结果丢失
假如Activity的launchMode是默认或者是标准的，那么当AsyncTask在请求网络数据时把屏幕旋转了，那么将会重新创建一个新的Activity，又因为还在运行的AsyncTask持有之前Activity的引用，那么将导致onPostExecute()方法不起任何作用，请求获得的数据不能加载到新的Activity上，而且也将导致内存泄漏
3、串行和并行多版本不一致
AsyncTask在1.6之前为串行，在1.6-2.3为并行，在3.0之后又改为串行，在3.0之后虽然可以通过代码来改变默认的串行为并行，但是又是一个繁琐的操作

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。转载注明出处：http://blog.csdn.net/u010687392

让Android的手机QQ崩溃未响应的指令---亲测有效果-2015年8月24日
 oo0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO0.oo.OOO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.OO00.oo.O00.oo.OOO00.oo.OO00.oo.OO00.oo.OO.OO00.oo.OO00.oo.OO00.oo.OO00.oo





以上字符全部复制从电脑发送到对方QQ，确保对方是Android的手机QQ，最好是新版的（对iOS和wp的无效）。
然后对方的手机QQ就会崩溃了，想恢复就刷屏吧，不然加载到就会手机QQ崩溃。
当然不打开也不会卡死

版权声明：本文为博主原创文章，未经博主允许不得转载。

安卓系统中的文件读写操作
权限
<manifest ...>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    ...
</manifest>

WRITE_EXTERNAL_STORAGE 已经隐含了读取权限

得到当前应用下的路径文件
File file = new File(context.getFilesDir(), filename);
写文件
String filename = "myfile";
String string = "Hello world!";
FileOutputStream outputStream;

try {
  outputStream = openFileOutput(filename, Context.MODE_PRIVATE);
  outputStream.write(string.getBytes());
  outputStream.close();
} catch (Exception e) {
  e.printStackTrace();
}
缓存文件
public File getTempFile(Context context, String url) {
    File file;
    try {
        String fileName = Uri.parse(url).getLastPathSegment();
        file = File.createTempFile(fileName, null, context.getCacheDir());
    catch (IOException e) {
        // Error while creating file
    }
    return file;
}

SD卡是否可用
/* SD卡是否可写 */
public boolean isExternalStorageWritable() {
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state)) {
        return true;
    }
    return false;
}

/* SD卡是否可读 */
public boolean isExternalStorageReadable() {
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state) ||
        Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
        return true;
    }
    return false;
}
创建文件
创建一个公共文件，当程序被卸载时，该文件依然存在
public File getAlbumStorageDir(String albumName) {
    //Environment.DIRECTORY_PICTURES为文件夹名称，这里使用的是系统常量
    File file = new File(Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created");
    }
    return file;
}
创建一个文件，当程序被卸载时，该文件将被删除
public File getAlbumStorageDir(Context context, String albumName) {
    //如果没有适合的子目录名称，可以改为调用 getExternalFilesDir() 并传递 null。这将返回外部存储上该应用的专用目录的根目录。
    File file = new File(context.getExternalFilesDir(
            Environment.DIRECTORY_PICTURES), albumName);
    if (!file.mkdirs()) {
        Log.e(LOG_TAG, "Directory not created");
    }
    return file;
}

诸如 DIRECTORY_PICTURES 的 API 常数提供的目录名称非常重要。 这些目录名称可确保系统正确处理文件。 例如，保存在 DIRECTORY_RINGTONES 中的文件由系统介质扫描程序归类为铃声，而不是音乐。

删除文件
常规方法
myFile.delete();
如果文件保存在内部存储中，还可以请求 Context 通过调用 deleteFile() 来定位和删除文件：
myContext.deleteFile(fileName);
参考文章
保存文件

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android线程和线程Handler基础一览

线程概览

线程是任何多任务系统的基石。可以被认为是一个主进程的多个子进程。这样做的目的就是了增加应用的性能。

应用主线程

当一个Android应用被打开的时候，系统会默认开辟一个线程。这个线程就被叫做是主线程。主线程的主要任务就是处理用户输入，即事件处理和view上的用户交互。任何应用里的其他组件，默认的，都是在主线程中运行的。

一个应用的任何组件，如果在主线程上执行一个耗时的任务的话，都会使整个应用等待这个任务的完成。如果耗时过长的话就会触发系统的“Application is unresponsive”警告。显然，这个是任何应用都不愿意出现的状况。在这种情况下，只能开辟一个单独的线程来执行这个耗时的任务，这样才不会干扰主线程上的其他任务。

线程Handler

所以，应用开发中最关键的一条就是永远不要在主线程上执行耗时过长的任务。另外一个同样重要的规则是另外开辟的单独的线程任何情况下、绝对不可以直接更新用户界面。任何对用户界面的更新都要在主线程中进行。之所以这样的原因是Android的UI不是线程安全的。在多线程环境下调用非线程安全的代码会导致断断续续的问题以及不可预料的应用行为。

要在子线程中更新用户界面就只能通过Handler来实现。

一个简单的Thread例子

这里会提供几个简单的例子来展示线程和Handler是如何使用的。第一步，展示一下耗时任务没有放在另外开辟的线程中，而放在主线程中出现的问题。首先创建一个Android项目叫做“ThreadExample”，包含一个单独的空白的activity：ThreadExampleActivity，layout叫做activity_thread_example。

具体的布局文件如下：

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="fill_parent"
              android:layout_height="fill_parent"
        >
    <TextView
            android:id="@+id/text_view"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:text="Hello World, MyActivity"
            />

    <Button android:id="@+id/thread_button"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Press me"/>

</LinearLayout>


看起来是这样的：



 

保存。接下来，双击ThreadExampleActivity.java进入编辑模式。在这个activity文件中实现button的click方法。这个方法会在用户点击按钮之后被调用。这里主要是展示耗时任务的问题，所以会在主线程中发起一个20秒的延迟，之后更新TextView对象的文字。

代码如下：

package com.example.myapp;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

public class ThreadExampleActivity extends Activity implements View.OnClickListener{
    /**
     * Called when the activity is first created.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_thread_example);

        Button threadButton = (Button)findViewById(R.id.thread_button);
        threadButton.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        long endTime = System.currentTimeMillis() + 20 * 1000;

        // waiting...
        while (System.currentTimeMillis() < endTime) {
            synchronized (this) {
                try{
                    wait(endTime - System.currentTimeMillis());
                }
                catch (Exception e) {

                }
            }
        }

        // update `TextView`, after 20 seconds
        TextView textView = (TextView)findViewById(R.id.text_view);
        textView.setText("Button Pressed");
    }
}


以上代价在运行之后，点击一下按钮，这个时候整个应用就在20秒的等待中。再次或者多次点击这个按钮不会立刻有反应。这时候系统就会弹出一个提醒：应用正在忙：



 

因此，在按钮点击方法中，耗时的操作应该放置在另外一个单独的线程中。

创建一个新的线程

要创建一个新的线程，并让代码在这个线程中执行，需要把这些代码都放在Runnable接口的Run中。然后需要创建一个新的Thread对象。把Runnable接口的实例作为参数传给Thread的构造函数中。最后调用Thread实例的start方法来开辟线程并执行线程中的方法。

修改后的代码如下：

@Override
    public void onClick(View v) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                long endTime = System.currentTimeMillis() + 20 * 1000;

                // waiting...
                while (System.currentTimeMillis() < endTime) {
                    synchronized (this) {
                        try{
                            wait(endTime - System.currentTimeMillis());
                        }
                        catch (Exception e) {

                        }
                    }
                }
            }
        };

        Thread thread = new Thread(runnable);
        thread.start();
    }


当应用再次运行起来之后。点击按钮之后把造成延时的任务都放在了新的线程中运行，主线程可以及时响应用户的任何操作，包括无休止的按钮点击。事实上，每次的点击都会创建一个新的线程，这样任务就可以在多个线程中并发执行。

两外一个需要注意的地方是，点击按钮之后更新TextView的文字的代码被去掉了。就像之前提到的，要更新界面上的内容只能在主线程中进行。要实现这个功能就需要给单独开辟的线程引入Handler实例。

实现一个Thread Handler

线程的Handler的实现是放在主线程中的，主要就是用来响应子线程的message并根据这个message来更新主线程的。

Handler继承自Android的Handler类。用来表明线程的Runnable实例即将执行，或overridehandleMessage方法，这个方法接受和处理子线程发送的message。本例会用Handler来更新用户界面。

修改后的代码如下：

package com.example.myapp;

import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

public class ThreadExampleActivity extends Activity implements View.OnClickListener {

    Handler handler = new Handler() {
        @Override
        public void handleMessage(Message message) {
            TextView textView = (TextView)findViewById(R.id.text_view);
            textView.setText("Button Pressed!");
        }
    };

    //...

}


 

上面的代码中声明了一个handler并实现了handleMessage回调方法。当子线程发出message的时候可以被这个方法处理。在这个实例中，只是简单地在代码中设置了TextView实例的文字。

现在就剩下修改button点击事件中创建的线程了。我们需要在这个线程里发出一个消息告诉handler20秒的延时任务已经执行完成。

修改后的代码如下：

 @Override
    public void onClick(View v) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                long endTime = System.currentTimeMillis() + 20 * 1000;

                // waiting...
                while (System.currentTimeMillis() < endTime) {
                    synchronized (this) {
                        try{
                            wait(endTime - System.currentTimeMillis());
                        }
                        catch (Exception e) {

                        }
                    }
                }

                // waiting is over
                handler.sendEmptyMessage(0);
            }
        };

        Thread thread = new Thread(runnable);
        thread.start();
    }


这段修改中唯一的修改就是增加了的就是handler调用sendEmptyMessage方法。由于handler实例不需要特别发送什么message所以这里只发送空消息。执行代码之后，点击按钮，等待20秒。TextView就会显示新的文本。

给Handler传递消息

之前的代码调用了handleMessage方法。但是这个方法并没有发挥出message可以发送数据给handler的优点。下面就会对现有的代码做出更多的修改来在子线程和handler实例之间传递数据。首先，在创建的子线程中会从系统获取到date和time，并转换成字符串。这些内容会保存在一个bundle实例中。然后调用handler的obtainMessage方法从message池中获取一个message实例。最后，这个保存了系统信息的bundle会被添加到message实例中并被sendMessage方法发送给handle实例。

@Override
    public void onClick(View v) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                Message message = handler.obtainMessage();
                Bundle bundle = new Bundle();
                SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss MM/dd/yyy", Locale.US);
                String dateString = dateFormat.format(new Date());
                bundle.putString("thread_date", dateString);    // key is `thread_date`

                message.setData(bundle);
                handler.sendMessage(message);
            }
        };

        Thread thread = new Thread(runnable);
        thread.start();
    }


接下来更新handleMessage方法。用这个方法把接收到的时间显示在TextView实例中。

Handler handler = new Handler() {
        @Override
        public void handleMessage(Message message) {
            Bundle bundle = message.getData();
            String dateString = bundle.getString("thread_date");

            TextView textView = (TextView)findViewById(R.id.text_view);
            textView.setText(dateString);
        }
    };


最后编译运行代码，点击按钮测试一下我们的修改是否成功。

总结

本教程就是提供一个对于Android应用实现多线程的概览。当一个app运行在一个进程中的时候，系统会给这个app穿件一个主线程。主线程的主要功能就是处理用户输入，所以任何执行时间过长的任务都会导致主线程无法及时响应用户后续的输入。所以，耗时的任务都应该放在另外开辟的子线程中执行。这些都是很基础的。因为Android用户界面的各种元素都是非线程安全的，所以对于界面的修改智能在主线程中进行。在主线程中可以使用Handler实例来接受子线程发出的消息来更新界面元素。

 

版权声明：本文为博主原创文章，未经博主允许不得转载。

IONIC开发入门手册
大体主要分两步：安装cordova和安装ionic:
一、安装cordova

ANT安装（cordova工具生成android项目时，需要的编辑工具）
ANT安装 
到官方主页下载新版，得到的是一个apache-ant-1.9.6-bin.zip的压缩包。将其解压到你的硬盘上，例如：C:\apache-ant-1.9.6。
配置环境变量




配置项
内容



path
C:/ apache-ant-1.8.1/bin


classpath
C:/apache-ant-1.8.1/lib


3. 验证ant 
为了验证ant是否成功安装，可以进行如下操作： 
依次选择：开始->运行->cmd，输入如下命令：ant 
如果出现如下内容，说明安装成功：

Buildfile: build.xml does not exist!  
  Build failed

【说明ant安装成功！因为ant默认运行build.xml文件，这个文件需要我们建立。】
二、安装android sdk(网上方法一大把)
别忘了配环境变量（把%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools加到Path环境变量中，不然会报”Error: An error occurred while listing Android targets”错）
目前比较简单的方式是，安装Android Studio，安装后启动应用，会自动弹出提示安装SDK，选择安装API Level 22的SDK后，退出。

以上这种方式优点就是下载速度快
如果使用SDK manager会使用谷歌的地址下载，如果没有翻墙会导致无法连接

三、安装Node.js (这里主要是要用它的npm命令装东西)
进入Node.js官网，下载安装包安装 
node.js安装成后安装cnpm替代npm，cnpm使用国内的源由淘宝提供，可参考官网 
安装方法： 
windows用管理员权限运行cmd后执行

npm install -g cnpm –registry=https://registry.npm.taobao.org

Linux和Mac OS上命令前面需要加sudo

sudo npm install -g cnpm –registry=https://registry.npm.taobao.org

四、安装cordova
windows用管理员权限运行cmd后执行

cnpm install -g cordova

Linux和Mac OS上执行

sudo cnpm install -g cordova

运行过程中没有报错，执行

cordova -v

看到版本号，就是执行成功了
五、安装ionic
windows用管理员权限运行cmd后执行

cnpm install -g ionic

Linux和Mac OS上执行

sudo cnpm install -g ionic


如果安装失败请多尝试几次，成功概率靠RP，早上安装比较容易成功。（安装命令最后加上-d你就能看见安装的进度）
如果一直无法安装可以尝试翻墙
如果无法翻墙尝试以下方法 
找到npm的路径
补齐npm文件夹下有关于ionic的文件 http://download.csdn.net/detail/superjunjin/8417723
补齐ionic项目下node_modules等文件 http://download.csdn.net/detail/superjunjin/8417731 
具体文件见最后的压缩包

安装成功后，执行

ionic -v

可以看到ionic版本号，就算执行成功了

ionic start myApp sidemenu  //创建带有左侧带有menu栏的示例项目 
  ionic start myApp blank   //创建空白项目 
  ionic serve //浏览器运行（调试很方便）

五、打包构建APP
以下只演示Android端的打包过程
添加平台支持

进入应用目录 
cd myApp
添加安卓平台支持，添加ios平台需要在Mac OS上才能执行成功 
ionic platform add android 
  如果环境配置没有问题，等待一会儿后会提示成功。 
  如果出现错误提示，最有可能就是Android SDK配置不正确，或者没有下载正确版本的SDK工具。

开始打包

开始打包执行 
ionic build android [--debug | --release]


默认不带参数输出为debug版本
配置正确情况下会在myApp/platform/Android/outputs/APK/下面生成，对应的APK文件。
debug模式下会输出2个APK，一个是不带签名的，一个是带debug签名的，带debug签名的APK可以在手机上安装测试
release模式下会输出1个不带数字签名APK，需要自己对该APK进行签名

APK数字签名
进入APK文件所在的目录 
1. 先产生密钥文件 
keytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore 
这个-validity 40000，意思是证书有效期40000天 
2. 再给文件签名 
jarsigner -verbose -keystore demo.keystore -signedjar CoderCalendar.apk android-release-unsigned.apk demo.keystore -digestalg SHA1 -sigalg MD5withRSA 
CoderCalendar.apk 是我们生成的目标文件名 
android-release-unsigned.apk 是需要被签名的APK文件

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Studio编译时间过长问题解决
build.gradle中 
dependencies { 
    //应该是网络不畅造成的，原因大家都懂的 
    //这种导致编译的时候超级慢，我用 mac 竟然编译了 9个小时 
    compile ‘com.android.support:support-v4:20.0.0’ 
   //改完之后就编译了几十秒  
   //改成如下这种就OK了，当然你在你的libs文件夹下 放入android-support-v4.jar 
    compile files(‘libs/android-support-v4.jar’) 
}

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

dalvik解释器阅读笔记

环境：android&nbsp;4.4.3
本人移动安全小菜一枚，最近在研究indroid的源码，发现里面原来是在dalvik里面插桩，所以就先把dalvik是如何解析指令的过程研究了一番。给人的感觉是这块要是研究透了，万能脱壳真的是可以的。因为无论dex怎么隐藏，最终还是要交给dalvik去解释执行。
Smali汇编一共有200多条不同的指令，每条指令对应的操作码对应源码在dalvik/libdex/DexOpcodes.h文件中，操作码用1个字节表示。smali汇编是不定长指令，而且对应的指令是基于“寄存器”的（每个寄存器都是32位）。（详细的dalvik指令大家看非虫大大的那本书，或者看谷歌提供的资料）。
下面主要拿c语言版本的dalvik解释器进行分析。源码的路径在dalvik/vm/mterp/out/InterpC-portable.cpp。


dalvik真正对指令解析是从dvmInterpretPortable(Thread*&nbsp;self)函数开始的。
下面对几个最重要的变量进行说明：
curMethod*:当前执行的方法。对应的结构体源码在dalvik/vm/oo/Object.h。
fp：这就是dalvik用来模拟寄存器的指针。
pc:pc就是用来取dalvik指令的。
inst:当前执行的指令。通过fetch（0）这个宏来获取的，注意它是2个字节大小。如果大于2个字节，就必须再次通过fetch（_offset）来取源操作数或者目的操作数，fetch（_offset）定义为：#define&nbsp;FETCH(_offset)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pc[(_offset)])。每一条指令执行完成之后会通过FINSH(_Offset)这个宏来调节pc，使其指向下一条指令的地址。
retval：与函数返回值有关。
methodClassDex：看赋值过程就能明白。从当前执行的方法找到当前方法所在的类，从所在的类找到它所属的dex。
DEFINE_GOTO_TABLE(handlerTable)；这个宏是非常重要的。这个宏也定义在dalvik/libdex/DexOpcodes.h，
[ATTACH]99647[/ATTACH]
经过宏替换,相当于定义了一个数组名为handlerTable的数组，里面的每一个数据也是宏，宏的定义就在dalvik/vm/mterp/out/InterpC-portable.cpp文件中。




经过宏替换,相当于定义了一个数组名为handlerTable的数组，里面的每一个数据也是宏，宏的定义就在dalvik/vm/mterp/out/InterpC-portable.cpp文件中。
# define H(_op)     &&op_##_op。##就是进行参数连接。最终经过宏展开后，该数组的第一个数据为：&&op_OP_NOP。其余的一样进行替换。为啥里面的数据都是void*类型，实际是因为&& 之后op_OP_NOP是标号。
下面额外说明一个关于标号的用法。因为dalvik解释器每一条指令都是goto 标号去执行的。



这个程序就会输出2222222222222 这一行。
接着对dvmInterpretPortable(Thread* self) 函数继续分析：
 FINISH(0)就是第一条指令进行解析了。
ADJUST_PC(_offset)这个宏的作用实际上就是用来调节pc的位置，使pc每次指向我们要执行指令的位置。FETCH(0)前面已经说过，获得这条指令的前两个字节赋给inst。下面看goto *handlerTable[INST_INST(inst)]这句. INST_INST(inst)也是一个宏。宏定义：#define INST_INST(_inst) ((_inst) & 0xff)  可知，这是用来取操作码的。而操作码的数值实际上跟前面说的handlerTable索引是一一对应的。假设此时操作码值为0，根据前面提到的标号用法，此时goto *handlerTable[INST_INST(inst)]就是goto op_OP_NOP

接着FINISH(0)往下看，下面就是每一条指令如何执行的宏。比如第一条指令为
HANDLE_OPCODE(OP_NOP) 同样也是一个宏。宏定义为：#define HANDLE_OPCODE(_op) op_##_op:进行替换就成了op_OP_NOP:。这就跟前面的goto连上了。当然NOP是什么都不做，直接FINISH(1)调节pc的位置获取下一条指令了。每一条指令执行完成之后都会调用FINISH这个宏。通过前面执行完的指令大小，设置对应的FINISH宏参数,调节pc位置。这个就是一个最简单的指令分析了，可能还有一些细节性的东西没有说清楚，还请见谅。对于其它复杂的指令，大家也可以对着分析，就会发现更细致的东西，比如fp指针是如何模拟寄存器的等等。


版权声明：本文为博主原创文章，未经博主允许不得转载。

swift详解之十-------------异常处理、类型转换 ( Any and AnyObject )
异常处理、类型转换 ( Any and AnyObject )
注：本文为作者倾心整理 ， 希望对大家有所帮助！ 

1、错误处理 （异常处理）
swift 提供第一类错误支持 ，包括在运行时抛出 ，捕获 ， 传送和控制可回收错误。在swift中 ，错误用复合 ErrorType 协议的值表示 。 Swift枚举把一系列相关的错误组合在一起。同时可以把一些相关的值和错误关联在一起 。 因此
编译器会为实现ErrorType协议的Swift枚举类型自动实现相应的合成
这里看个很简单的小例子。
enum WrongName:ErrorType{
    case NoName
}
错误处理  1、抛出 
在方法后面加上throws 关键字
func doSomeThing(name:String) throws ->String {
    if(name.isEmpty){
        throw WrongName.NoName
    }
    print("no error")
    return name
}
当字符位空 ， 我们就 throw  这个异常 。 
在调用一个抛出函数的时候 需要在调用前面加上try
try doSomeThing("eat")    //这里并没有出现异常  会输出 no error
try doSomeThing("")  //会产生运行时错误 error caught in main()
这里抛出了错误但是没有处理 。
2、捕捉和处理错误 do-catch 语句来捕捉和处理错误
语法 ：
do {

}catch parttern{

}

如果一个错误被爆出 ， 这个错误会被传递到外部域 ，直到被catch捕捉处理 ，pattern 是用来匹配错误和相应的执行语句。
swift处理异常和别的语言不同的是swift不会展开调用堆栈 。 那样会带来很大的性能损耗 。 在swift中 throw 语句的性能几乎和return一样
do{
    try doSomeThing("")
}catch WrongName.NoName{
    print("NoName error!")
} //输出NoName error!
通过try!来调用抛出函数或者方法 来禁止错误传输 。并把调用包装在运行时断言，这样就不会抛出错误啦。如果帧抛出错误， 会触发运行时错误
func willThrowIfTru(value:Bool) throws{
    if value {
        throw NotTrue.BeTrue
    }
}

do{
    try willThrowIfTru(true)
}catch {
    print("不能为true呀")
}
//这里会输出 不能为true呀 --没有疑问 
try! willThrowIfTru(false)  //这块禁止了错误传输 意思断言肯定不会有异常 ， 如果有 就会报错
收尾操作 
使用defer 执行的语句 不管有没有出错都回执行到 。相当于其他的finally
defer 语句和的执行顺序和它定义顺序相反 也就是说 ， 第一个difer语句中的代买在第二个后执行 。
    func willThrowIfTru1(value:Bool) throws{

        if value {
            throw NotTrue.BeTrue
        }
    }
  do{
            try willThrowIfTru1(true)
        }catch {
            print("不能为true呀")
        }


        defer{
            print("我后执行")
        }

        defer{
            print("我先执行")
        }
        print("我第一个执行")
        结果：
        不能为true呀
        我第一个执行
        我先执行
        我后执行
2、类型转换
Swift 中使用is 和 as操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型

用类型检查操作符(is)来检查一个实例 是否属于特定子类型

class Person{
    var name:String
    init(name:String){

        self.name=name
    }
}

var  p = Person(name: "wangwu")
if p is Person
{
    print("yes")
}
这里输出yes ， 转换这种明显的没有什么意思 。来看看下面的、 

class Student: Person {

}
class Teacher: Person {

}

let list = [ Student(name: "张三") , Student(name: "李四") , Teacher(name: "王五") ]
这里会推断出是一个[Person] 数组
var stuCount = 0
var teaCount = 0

for item in list {

    if item is Student {
        stuCount++
    }
    if item  is Teacher{
        teaCount++
    }
}
print("stu :\(stuCount) , tea: \(teaCount)")
//stu :2 , tea: 1
这里利用is推断出具体类型 

向下转型 
某类型的一个常量或变量可能在幕后实际上属于一个子类 这时候 你可以尝试向下转型 用as! 或者 as?  向下转型可能会失败 。as? 返回你试图转型的可选值 。 as!  强制转型 ，非常确定的时候再用 否则会运行时错误 。

所以上面的例子还能这么写 
stuCount = 0
teaCount = 0

//这里使用了可选绑定 以前的章节有讲过
for item in list {

    if let s = item as? Student {
        stuCount++
    }
    if let t = item  as? Teacher{
        teaCount++
    }
}
print("stu :\(stuCount) , tea: \(teaCount)")
//stu :2 , tea: 1
结果是一模一样的

Any 和 AnyObject 的类型 
Swift为不确定类型提供了两种特殊类型别名： 
AnyObject可以代表任何class类型的实例。 
Any可以表示任何类型，包括方法类型(function types)。（2.0新特性）

let student:[AnyObject] = [Student(name: "ww"),Student(name: "aa"),Student(name: "dd")]
//这里定义了一个[AnyObject] 类型的数组  ，但是确定是放得student  所以你可以强制转型
let stu = student[0] as! Student
print(stu.name)  //aa
let stus = student as! [Student]
//你可以直接强制转换成一个Student数组
print(stus.count) //3
下面看下 Any类型 
var things = [Any]()

things.append("str")
things.append(0.9)
things.append(stu)
things.append(stus)


for item in things {
    switch item {
    case let val as Double:
        print("\(val)  是个数字类型")
    case let val as String:
         print("\(val)  是个字符串")
    case let val as Student:
        print("\(val)  是Student对象")
    case let val as [Student]:
        print("\(val)  是个[Student]数组")
    default:
        print("啥都不是")
    }
}
结果 ：
str  是个字符串
0.9  是个数字类型
Student  是Student对象
[Student, Student, Student]  是个[Student]数组

再不确定类型的时候才使用这两个 ，确定的时候最好使用确定类型 

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS5 ARC学习笔记：strong、weak等详解

iOS5中加入了新知识，就是ARC,其实我并不是很喜欢它，因为习惯了自己管理内存。但是学习还是很有必要的。

在iOS开发过程中，属性的定义往往与retain, assign, copy有关，我想大家都很熟悉了，在此我也不介绍，网上有很多相关文章。

现在我们看看iOS5中新的关键字strong, weak, unsafe_unretained. 可以与以前的关键字对应学习strong与retain类似，weak与unsafe_unretained功能差不多（有点区别，等下会介绍，这两个新 关键字与assign类似）。在iOS5中用这些新的关键字，就可以不用手动管理内存了，从java等其它语言转过来的程序员非常受用。

strong关键字与retain关似，用了它，引用计数自动＋1，用实例更能说明一切

@property (nonatomic, strong) NSString *string1;   
@property (nonatomic, strong) NSString *string2;
有这样两个属性

@synthesize string1;   
@synthesize string2; 
猜一下下面代码将输出什么结果？

self.string1 = @"String 1";   
[self.string2 = self.string1;   
[self.string1 = nil;  
[NSLog(@"String 2 = %@", self.string2); 
结果是：String 2 = String 1

由于string2是strong定义的属性，所以引用计数＋1，使得它们所指向的值都是@"String 1", 如果你对retain熟悉的话，这理解并不难。

接着我们来看weak关键字：

如果这样声明两个属性：

@property (nonatomic, strong) NSString *string1;   
@property (nonatomic, weak) NSString *string2; 
并定义

@synthesize string1;   
@synthesize string2; 
再来猜一下，下面输出是什么？

    self.string1 = [[NSString alloc] initWithUTF8String:"string 1"];   
elf.string2 = self.string1;   
self.string1 = nil;  
NSLog(@"String 2 = %@", self.string2); 
结果是：String 2 = null

分析一下，由于 self.string1与self.string2指向同一地址，且string2没有retain内存地址，而self.string1=nil释放 了内存，所以string1为nil。声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为nil。这样的好处能有效的防止野指针。在 c/c++开发过程中，为何大牛都说指针的空间释放了后，都要将指针赋为NULL. 在这儿用weak关键字帮我们做了这一步。

接着我们来看unsafe_unretained

从名字可以看出，unretained且unsafe，由于是unretained所以与weak有点类似，但是它是unsafe的，什么是unsafe的呢，下面看实例。

如果这样声明两个属性：

并定义

@property (nonatomic, strong) NSString *string1;   
@property (nonatomic, unsafe_unretained) NSString *string2; 
再来猜一下，下面的代码会有什么结果？

self.string1 = [[NSString alloc] initWithUTF8String:"string 1"];   
self.string2 = self.string1;   
self.string1 = nil;  
NSLog(@"String 2 = %@", self.string2); 
请注意，在此我并没有叫你猜会有什么输出，因为根本不会有输出，你的程序会crash掉。 原因是什么，其实 就是野指针造成的，所以野指针是可怕的。为何会造成野指针呢？同于用unsafe_unretained声明的指针，由于 self.string1=nil已将内存释放掉了，但是string2并不知道已被释放了，所以是野指针。然后访问野指针的内存就造成crash.  所以尽量少用unsafe_unretained关键字。
    
android---自定义左滑右滑菜单
没有使用第三方类库,纯代码定制.主要用到的知识如下,
我们知道，不管是自定义View还是系统提供的TextView这些，它们都必须放置在LinearLayout等一些ViewGroup中，因此理论上我们可以很好的理解onMeasure()，onLayout()，onDraw()这三个函数：1.View本身大小多少，这由onMeasure()决定；2.View在ViewGroup中的位置如何，这由onLayout()决定；3.绘制View，onDraw()定义了如何绘制这个View。
一个MeasureSpec封装了父布局传递给子布局的布局要求，每个MeasureSpec代表了一组宽度和高度的要求。一个MeasureSpec由大小和模式组成。它有三种模式：UNSPECIFIED(未指定),父元素部队自元素施加任何束缚，子元素可以得到任意想要的大小；EXACTLY(完全)，父元素决定自元素的确切大小，子元素将被限定在给定的边界里而忽略它本身大小；AT_MOST(至多)，子元素至多达到指定大小的值。
　　它常用的三个函数：
　　1.static int getMode(int measureSpec):根据提供的测量值(格式)提取模式(上述三个模式之一)
　　2.static int getSize(int measureSpec):根据提供的测量值(格式)提取大小值(这个大小也就是我们通常所说的大小)
　　3.static int makeMeasureSpec(int size,int mode):根据提供的大小值和模式创建一个测量值(格式)
public static final int ACTION_DOWN       = 0;  // 按下事件  
  public static final int ACTION_UP        = 1;  // 抬起事件 
  public static final int ACTION_MOVE       = 2;  // 手势移动事件  
  public static final int ACTION_CANCEL      = 3;  // 取消 
还有触摸事件,滚动的实现等,代码注释很详细
public class MainUI extends RelativeLayout {

    private Context context;
    private FrameLayout middleMenu,leftMenu,rightMenu;
    //设置模版
    private FrameLayout middlemask;
    private Scroller scroller;

    //属于自定义view,这里就需要用到这两个构造函数
    public MainUI(Context context){
        super(context);
        inintView(context);
    }

    public MainUI(Context context, AttributeSet attrs) {
        super(context, attrs);
        inintView(context);
    }
    //初始化各种变量
    public void inintView(Context context){
        this.context = context;
        //然后我们需要三个界面布局,这里用framelayout来承载
        //设置滑动的是当前content和滑动样式
        scroller = new Scroller(context,new DecelerateInterpolator());
        leftMenu = new FrameLayout(context);
        middleMenu = new FrameLayout(context);
        rightMenu = new FrameLayout(context);
        middlemask = new FrameLayout(context);
        //为了区分给每个部分设置颜色
        leftMenu.setBackgroundColor(Color.RED);
        middleMenu.setBackgroundColor(Color.BLUE);
        rightMenu.setBackgroundColor(Color.GREEN);
        middlemask.setBackgroundColor(Color.GRAY);
        middlemask.setAlpha(0);
        //添加到当前布局
        addView(leftMenu);
        addView(middleMenu);
        addView(rightMenu);
        addView(middlemask);

        //接下来要测量宽度,好用来给这三个部分分别设置宽度,放在onmeasure中
    }

    /**这个方法决定view本身的大小
     * 这里的两个参数分别是屏幕的宽和高
     * @param widthMeasureSpec
     * @param heightMeasureSpec
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        //中间的宽度正好是整个屏幕
        middleMenu.measure(widthMeasureSpec, heightMeasureSpec);
        middlemask.measure(widthMeasureSpec, heightMeasureSpec);
        //旁边的则最多为屏幕的80%
        int realWidth = MeasureSpec.getSize(widthMeasureSpec);
        int tempWidthMeasure = MeasureSpec.makeMeasureSpec(
                (int)(realWidth*0.8f),MeasureSpec.EXACTLY);
        leftMenu.measure(tempWidthMeasure, heightMeasureSpec);
        rightMenu.measure(tempWidthMeasure, heightMeasureSpec);
    }

    /**这个方法决定view在layout中的位置
     *四个参数对应屏幕 左上右下
     * @param changed
     */
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        super.onLayout(changed, l, t, r, b);
        //中间菜单是中间的屏幕
        middleMenu.layout(l, t, r, b);
        middlemask.layout(l, t, r, b);
        //左边的菜单则左边界要扩充
        leftMenu.layout(l - leftMenu.getMeasuredWidth(), t, r, b);
        //右边界左右都要设置
        rightMenu.layout(
                l + middleMenu.getMeasuredWidth(),
                t,
                l + middleMenu.getMeasuredWidth()
                        + rightMenu.getMeasuredWidth(), b);
        //接下来添加滑动事件
    }


    private boolean isTsetCompete;
    /**
     * 处理相应的触摸事件
     * @param ev
     * @return
     */
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {

        if (!isTsetCompete){
            getEventType(ev);
            return true;
        }
        //如果是左右滑动
        if (isleftrightmove){
            switch(ev.getActionMasked()){
                case MotionEvent.ACTION_MOVE:
                    //得到滑动距离
                    int currScrollX = getScrollX();
                    //得到移动距离
                    int dis_x = (int)(ev.getX() -point.x);
                    //他俩差值肯定在20之间
                    int expectX = -dis_x +currScrollX;
                    int finalx=0;
                    if (expectX<0){
                        //右滑距离
                        finalx = Math.max(expectX,-leftMenu.getMeasuredWidth());
                    }else{
                        //左滑距离
                        finalx = Math.min(expectX,rightMenu.getMeasuredWidth());
                    }
                    scrollTo(finalx,0);
                    point.x = (int) ev.getX();
                    break;
                //下面判断继续滑动或者手指离开屏幕
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    //判断如果滑动距离大于一半则自动滑动出来,否则滑动回去
                    currScrollX = getScrollX();
                    if (Math.abs(currScrollX) > leftMenu.getMeasuredWidth() >>1) {
                        if (currScrollX < 0) {
                            scroller.startScroll(currScrollX, 0, -leftMenu.getMeasuredWidth() - currScrollX, 0);
                        }else {
                            scroller.startScroll(currScrollX,0,leftMenu.getMeasuredWidth()-currScrollX,0);
                        }
                    }else{
                        scroller.startScroll(currScrollX,0,-currScrollX,0);
                    }
                    //用于屏幕刷新
                    invalidate();
                    isleftrightmove = false;
                    isTsetCompete = false;
                    break;
            }
        }

        return super.dispatchTouchEvent(ev);
    }

    /**
     * 在滑动改变距离的同时改变透明度,这种方式很好,因为会先调用父类的方法,所以不会影响到原来程序的运行
     * @param x
     * @param y
     */
    @Override
    public void scrollTo(int x, int y) {
        super.scrollTo(x, y);
        int cruX = Math.abs(getScrollX());
        float fo = cruX / (float)middleMenu.getMeasuredWidth();
        middlemask.setAlpha(fo);
    }

    /**
     * 滚动条的回调方法
     */
    @Override
    public void computeScroll() {
        super.computeScroll();
        if (!scroller.computeScrollOffset()){
            return;
        }
        int tempX = scroller.getCurrX();
        scrollTo(tempX,0);
    }

    private Point point = new Point();
    private static final int TSET_DIS = 20;
    private boolean isleftrightmove;
    /**
     * 用于判断触摸事件类型的函数
     * @param ev
     */
    private void getEventType(MotionEvent ev) {
        switch(ev.getActionMasked()){
            case MotionEvent.ACTION_DOWN:
                //得到当前坐标
                point.x = (int) ev.getX();
                point.y = (int) ev.getY();
                break;
            case MotionEvent.ACTION_MOVE:
                int dX = Math.abs((int)ev.getX()-point.x);
                int dY = Math.abs((int)ev.getY()-point.y);
                //左右滑动
                if (dX >=TSET_DIS && dX>dY){
                    isleftrightmove = true;
                    isTsetCompete = true;
                    //为了滑动后可以再次滑动
                    point.x = (int) ev.getX();
                    point.y = (int) ev.getY();
                }else if (dY>=TSET_DIS&&dY>dX){
                    isleftrightmove = false;
                    isTsetCompete = false;
                    point.x = (int) ev.getX();
                    point.y = (int) ev.getY();
                }

                break;
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:

                break;
        }
    }
}
 
 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

使用Ant打包Android应用详解——Ant使用解析

  上篇《使用Ant打包Android应用详解》描述了使用Ant打包的流程，但很多步骤并没有说明如此做的原因，本篇将从Ant方面来理解，下一篇从APK生成的流程来说明。
  APK包的生成是一系列操作的结果，而Ant则是将这一系列操作流程化，提供出定制化的接口，以及可配置的参数供修改,而这些都是通过指定的构建文件来实现。我们就从Ant的打包流程来理解Ant的一些基本用法。当在命令行中执行ant，默认会去解析当前目录的build.xml作为构建文件。下面是个删除部分注视的版本：

<project name="工程名" default="help">

 <!-- The local.properties file is created and updated by the 'android' tool.
 It contains the path to the SDK. It should *NOT* be checked into
 Version Control Systems. -->
 <property file="local.properties" />

 <property file="ant.properties" />

 <!--
 Import per project custom build rules if present at the root of the project.
 This is the place to put custom intermediary targets such as:
 -pre-build
 -pre-compile
 -post-compile (This is typically used for code obfuscation.
 Compiled code location: ${out.classes.absolute.dir}
 If this is not done in place, override ${out.dex.input.absolute.dir})
 -post-package
 -post-build
 -pre-clean
 -->
 <import file="custom_rules.xml" optional="true" />

 <!-- Import the actual build file.
 <import file="${sdk.dir}/tools/ant/build.xml" />再跟进到你的SDK目录的tools/ant/build.xml,查看Ant打包的完整过程。
    1.首先理解几个概念，project、target、task。简单来说，你的一个构建工程（project），划分了很多阶段或者子目标（target），而每个阶段目标的实现，你要提供具体的操作，比如文件复制，源码编译，这些封装好的操作就是task（可以理解为为你提供的库函数）。具体看，每个构建文件都有顶层为project的标签，作为标识，而target就是你所要执行的操作序列，target里面可以有很多的task。那么怎么确定操作序列执行的顺序呢？其中project的default指的是默认执行的target,也就是当你在命令行只输入ant不带任何参数时，执行的target。而当你指定了target后，如在命令行中输入ant
 help，会从你的构建文件中找到target help执行。当我们输入ant release时，对应的target如下：
<target name="release"　depends="-set-release-mode, -release-obfuscation-check, -package, -post-package, -release-prompt-for-password, -release-nosign, -release-sign, -post-build"　description="Builds the application in release mode.">
 </target>target的name和description顾名思义，而depends则是该target执行前，需要执行或者说依赖的target，而且是依据从左到右的顺序依次执行。继续跟进-package它的定义：<target name="-package" depends="-dex, -package-resources">，分别是dex文件的生成和资源打包，里面又定义了很多具体的target。整个过程中就有或者说预留了一些空的target，比如-pre-build -pre-compile
 -post-package -post-build，是每个打包编译步骤之前后结束，通过在custom_rules.xml中重写这些target，达到定制化的要求
　　2.解决了执行序列的问题，那么如何进行参数配置呢？
（1）首先在工程下的build.xml中property,可以理解为定义了部分变量或者引入了property 文件，看其部分属性：
name：property的名称，在target或者其它地方可以通过${name}的形式引用
value:具体的值或路径
file：需要加载的property文件，文件中的内容以key=value中出现，如local.properties中定义的sdk.dir=android的sdk路径
refid:引用已经定义的path信息
自己工程的build.xml中property定义的local.properties引入了android sdk/ndk，ant.properties引入了签名时需要的信息；这里有个关键的特性是，一旦定义了property，其值是不能改变的，而且会保留最先定义的值；也就是这个特性，方便了在编译过程中的一些定制化操作。如上篇中调用隐藏api，将自己的framework.jar加入到project.target.class.path中
(2）import标签,属性file：要引入的构建文件，optional:值为true时，即使import的文件不存在，也不停止编译。那么custom_rules.xml是可有可无，而${sdk.dir}/tools/ant/build.xml是定义了真正的编译步骤的文件必须存在
   3.一些用到的其它标签
（1）定义文件目录path，从ant手册中的例子看：


<path id="base.path">
      <pathelement path="${classpath}"/>
      <fileset dir="lib">
        <include name="**/*.jar"/>
      </fileset>
      <pathelement location="classes"/>
 </path>一个可以在其它地方通过refid引用的path，里面包括了具体path路径pathelement和通过include或exclude来筛选文件的fileset
（2）copy task


<copy todir="${source.absolute.dir}">

     <fileset dir="其它源码目录">
        <include name="**/*.java" />
        <include name="**/*.aidl" />
    </fileset>
 </copy>odir:目标目录，源目录在fileset上定义，规则是包括所有.java文件和所有aidl文件；简单的如拷贝单个文件
<copy file="myfile.txt" tofile="mycopy.txt"/>
拷贝一个文件到某个目录
<copy file="myfile.txt" todir="../some/other/dir"/>
这些信息都可以通过查询ant参考手册https://ant.apache.org/manual/来了解，不一一叙述


通过上述描述应该可以理解并跟进整个ant打包android应用的流程，根据自己的需要进行定制化操作





版权声明：本文为博主原创文章，未经博主允许不得转载。

Unity3D——个人游戏Car的游戏中控制
/////////////////////2015/08/25///////////////
////////////////////by XBW/////////////////////
///////////////////环境 unity4.6.1///////////
终于弄完了这个停车游戏，先看一下效果图

这个游戏呢，就是在赛道内收集三枚以上氮气，然后再返回起点，在赛车损坏程度内完成就算胜利，我们只做了安卓版，用陀螺仪控制赛车的前进以及左右，碰撞的检测以及UI我写在了Control.cs中，直接挂在给塞车了，其中赛车的tag为Player，氮气的tag为danqi，下面直接上代码了；
using UnityEngine;
using System.Collections;

public class Control : MonoBehaviour
{

    // Use this for initialization
    private int danqi = 0;
    private float life = 100;
    private int right = 1;
    private int jieshu = 1;
    public GUISkin GUIskin;
    public GUISkin GUIskin2;
    public Texture2D img1;
    public Texture2D img2;
    void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.tag == "danqi")
        {
            Destroy(other.gameObject);
            danqi++;
            
        }
    }
    void Start()
    {
        

    }

    // Update is called once per frame
    void Update()
    {
        if (transform.position.x > 138 && transform.position.x < 139 && transform.position.z > 151 && transform.position.z<154 && danqi >= 3)
        {
            right = 0;
            //Destroy(GameObject.FindGameObjectWithTag("Player"));
            Time.timeScale = 0;
            
        }
        life -=Time.deltaTime * 0.5f;
    }
    void OnGUI()
    {
        GUIStyle go = new GUIStyle();

        go.fontSize = 30;

        go.normal.textColor = new Color(0, 0, 0);

        GUI.skin = GUIskin;
        GUI.DrawTexture(new Rect(Screen.width * 0.01f, Screen.height * 0.02f, Screen.width * 0.1f, Screen.height * 0.15f), img1);
        GUI.DrawTexture(new Rect(Screen.width * 0.72f, Screen.height * 0.02f, Screen.width * 0.1f, Screen.height * 0.15f), img2);
        GUI.Label(new Rect(Screen.width * 0.8f, Screen.height * 0.1f, 100, 100), "氮气  "+ danqi.ToString(), go);
        GUI.Label(new Rect(Screen.width * 0.1f, Screen.height * 0.1f, 100, 100), "损坏  "+ life.ToString(), go);
        GUI.skin = GUIskin2;
        if (GUI.Button(new Rect(Screen.width - Screen.width * 0.3f, Screen.height - Screen.height * 0.15f, Screen.width * 0.3f, Screen.height * 0.15f), "再试一次"))
        {
            Application.LoadLevel(Application.loadedLevelName);
        }
        if (GUI.Button(new Rect(0, Screen.height - Screen.height * 0.15f, Screen.width * 0.3f, Screen.height * 0.15f), "不想玩了"))
        {
            Application.LoadLevel("Menu");
        }
        //if (GUI.Button(new Rect(Screen.width - Screen.width * 0.2f, Screen.height*0.4f, Screen.width * 0.2f, Screen.height * 0.1f), "悬挂 +"))
        //{
        //    GameObject.FindGameObjectWithTag("Player").GetComponent<WheelSuspension_Script>().SpringLength+=0.1f;
        //}
        if(life<=0)
        {
            GUI.skin = GUIskin;
            GUI.Label(new Rect(Screen.width * 0.4f, Screen.height * 0.3f, 100, 100), "YOU LOSE", go);
            Time.timeScale = 0;
            GUI.skin = GUIskin2;
            if (GUI.Button(new Rect(Screen.width * 0.35f, Screen.height * 0.4f, Screen.width * 0.3f, Screen.height * 0.15f), "再试一次"))
            {
                Application.LoadLevel(Application.loadedLevelName);
            }
            if (GUI.Button(new Rect(Screen.width * 0.35f, Screen.height * 0.6f, Screen.width * 0.3f, Screen.height * 0.15f), "返回主菜单"))
            {
                Application.LoadLevel("Menu");
            }
        }
        if (right == 0)
        {
            GUI.skin = GUIskin;
            GUI.Label(new Rect(Screen.width * 0.4f, Screen.height * 0.3f, 100, 100), "YOU WIN", go);
            Time.timeScale = 0;
            GUI.skin = GUIskin2;
            if (GUI.Button(new Rect(Screen.width * 0.35f, Screen.height * 0.4f, Screen.width * 0.3f, Screen.height * 0.15f), "再试一次"))
            {
                Application.LoadLevel(Application.loadedLevelName);
            }
            if (GUI.Button(new Rect(Screen.width * 0.35f, Screen.height * 0.6f, Screen.width * 0.3f, Screen.height * 0.15f), "返回主菜单"))
            {
                Application.LoadLevel("Menu");
            }
        }
    }
}
就这么简单，有不懂的地方或者有错误的地方请留言给我，相互学习一下

版权声明：本文为博主原创文章，未经博主允许不得转载。

【图文】Git学习之十步掌握通过Android Studio整合Git将本地库Push到远程库
前言
之所以写这篇文章是为了自己做备忘录用的，同时希望也能帮助到一些初学者。
图文步骤
第一步
打开Android Studio（以下简称AS）的VersionCotrol-》Git

第二步
切到Github

第三步

第四步
在Select directory for git init中选择初始化你的本地Git库。

然后会在你的本地项目生成.git目录

第五步
打开Git Bash定位到上面的目录

第六步
重点来了，添加一个新的git远程库，形如：
git remote add origin https://[user]@[server_address]/[git_repo_url]
我的地址是：
https://github.com/dengfengdecao/PhotoGallery.git

如果已有目标仓库可能要执行命令： 
  git set-url origin https://github.com/dengfengdecao/PhotoGallery.git

现在添加一个文件到GIT库
git add .gitignore
这么做是因为我们需要添加任何文件到我们的git仓库来开始我们的第一次提交（当你通过AS初始化这个git仓库时，AS会自动创建这个文件）
再提交这个改变到GIT仓库，
git commit -m "Initial Commit"
第七步
push到远程库，使用标记-set-upstream来告诉本地git仓库远程库的目的地
git -push --set-upstream origin master

如果已有目标仓库可能要执行命令： 
git pull origin master

将会输出如下内容：

bash命令到此结束！
第八步
进入AS，右击顶部你的项目名称，选择Git>+Add

这将添加所有项目文件到git库（对应命令git add）
第九步
选择Git>Commit Directory提交目录

在Commit Changes对话框确认你项目的所有改变的文件，并在Commit Message添加说明信息

选择提交到本地Git库.
第十步
右击顶部项目选择Git>Repository>Push…


Push看到以下信息即可。

最后，如果出现错误信息：
fatal: unable to access ‘https://github.com/[user]/[repo].git/‘: Failed connect to github.com:443; No error
则多Push几次，如果还不成功就设置代理（前提你要会FQ）：
git config --global http.proxy [server]:[port]
如果代理设置有问题，具体请看此文：
http://stackoverflow.com/questions/18356502/github-failed-to-connect-to-github-443-windows-failed-to-connect-to-github

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：欢迎转载！请注明出处：http://blog.csdn.net/u011726984

Tigase开发笔记2：Tigase组件详解
本文的目的是深入认识Tigase XMPP Server的特性。
Tigase的组件、插件配置非常灵活,几乎都在tigase root doc path/etc/init.properties文件中进行配置.


1、Tigase HTTP API
实现XMPP和HTTP之间的桥梁，可通过REST调用实现对Tigase安装的管理和维护，可通过脚本API在运行时进行扩展。
使用HTTP API组件，可以：
1）下载Tigase XMPP服务器运行时的统计，它包含了1000种不同的性能度量。可以做到轻松、快速的监控和早期预警等功能。
2）通过REST API管理Tigase XMPP服务器，实现Tigase服务器与第三方维护、管理系统的集成。（需要组件sess-man，默认会加载该组件）
3）灵活的脚本框架（Groovy），可以在运行时添加管理任务，可以在扩展管理和维护功能时无需重启服务。
4）灵活的HTTP API框架，可以添加更多的服务并托管到XMPP引擎上。





#http-api
--comp-name-2=http
--comp-class-2=tigase.http.HttpMessageReceiver
--script-dir=src/main/groovy/tigase/admin
http/http/port[I]=8080
http/api-keys[s]=open_access
http/server-class[S]=tigase.http.jetty.JettyStandaloneHttpServer
#http/rest/rest-scripts-dir[S]=../http-api/src/scripts/groovy/tigase/rest







2、Tigase XMPP Server
全球大约有1亿的设备连接到Tigase服务器上，全球大约有1100台服务器部署运行着Tigase服务器。
业界有很多优秀的开源XMPP服务器，比如eJabberd、Openfire、Jabberd2、Prosody，还有一些优秀的商业XMPP服务器，比如lsode、Jabber XCP等。在XMPP.ORG网站上可以看到完整的列表。
Tigase XMPP服务器是相当独特的，它完全支持最新的规范（如RFC6120-XMPP CORE、RFC6121-XMPP IM和其它扩展）。
1）高度优化的。主二进制文件小于1MB，可运行于10MB内存的设备上。
2）高度模块化。每个部件或组件都可以通过配置加载或替代。
3）非常灵活。集成到系统中很方便，支持开箱即用的集群，无需寻找附加软件或扩展库。
4）为低、中、高档服务器而设计。还在Amazon的EC2云上广泛测试过。
5）良好的测试。有专门的工具来运行自动化测试，还可以手动运行兼容性测试，以及大量的负载测试。所有的测试结果都是公开的，所有测试使用的工具和配置细节都是公开的。
6）支持脚本。支持Groovy、Python、Ruby、Scala等脚本语言编写扩展。
7）易于监控。可以通过HTTP、SNMP、JMX、XMPP等方式监控服务器。
8）支持SSL。Tigase从设计上就保证了安全，保护用户的隐私。API不允许从一用户访问另一用户的数据，在服务器端实现了强隔离。





config-type=--gen-config-def
--admins=admin@10.5.1.48
--virt-hosts=10.5.1.48
--user-db=pgsql
#--user-db-uri=jdbc:postgresql://localhost/tigasedb?user=postgres&password=123456&useUnicode=true&characterEncoding=UTF-8&autoCreateUser=true
--user-db-uri=jdbc:postgresql://10.5.1.12/tigasedb?user=postgres&password=123456&useUnicode=true&characterEncoding=UTF-8&autoCreateUser=true







3、Tigase ACS
Tigase单个安装（One Installation）可以支撑1400万在线用户；单个安装美妙可以处理50万条消息；单个安装可以实现40台服务器集群。即Tigase
 ACS。
Tigase ACS是Tigase XMPP服务器的商业级的集群实现。它专注于某些目标，如联系人列表超过10个，以及大规模XMPP系统工作在集群模式：
1）在安装时解决网络流量的问题
2）允许扩展到上百万的在线用户或设备
3）允许把负载分配到多种机器上
4）实现系统的高可用，预防服务的中断
5）支持超大群聊
6）提供消息推送服务
使用ACS可以达到：
1）降低集群节点间的网络流量10倍以上
2）减少CPU利用率至少5倍
3）在高负载情况下也能提供可靠服务
4）支持大量的连接
在设计上可处理500万以上的在线用户。我们测试过产品状态，支持150万在线用户。
5）支持多服务器
设计上可以在50台以上服务器上有效工作。测试过10个集群节点，产品系统运行在40台机器的情况。
6）部署极其简单
只需修改一点配置，数据库层不变。

4、Tigase发布订阅（PubSub）
Tigase支持完整的发布/订阅（PubSub）扩展规范。可以把消息推送到上百万的频道中，每个频道可以有上百万的订阅用户。集群模式下提供了近乎线性的可扩展性和负载分配。
发布订阅扩展允许你创建频道供用户订阅，你可以把内容推送到频道并发布。然后全部内容或者只是更新的内容会被发送给所有的订阅者。这种基于角色的系统，与群聊类似，但订阅者不必在线，离线也能把消息推送给用户（只要用户一上线就能收到）。
发布订阅功能可以做什么？
1）可以根据兴趣分组内容，如体育、科学、天气、新闻等，并把内容推送给感兴趣的人。
2）可以用于灾害预警，居民可以根据地理位置进行分组。
3）可以提供基于位置的服务。
4）业务流程可以使用此方式来发送警告。
Tigase的发布订阅可以提供：
1）交付近乎实时的通知给订阅频道的用户
2）基于角色的订阅系统，决定哪些用户只能接收/读取内容，哪些用户可以发布内容到频道，以及频道级管理员、全局管理员。
3）自定义内容和通知元数据可以很好地匹配各种需求。
4）灵活的基于用户的交付系统，可以决定是否只把通知交付给在线订阅的用户；是否把通知交付给所有订阅的用户；还可以指定通知的过期时间，以及其他很多选项。
5）支持数百万的发布订阅频道交付通知给订阅者。
6）发布订阅频道支持上百万的订阅者。






--comp-name-3=pubsub
--comp-class-3=tigase.pubsub.PubSubComponent














5、消息归档(Message Archiving)
Tigase提供了对消息归档的完整支持（XEP-0136扩展），支持数据库分片（开箱即用），还能作为外部组建部署到多种服务器上。
用户往往希望保存聊天记录以便以后检索，基本上目前大多数聊天客户端都在本地保存了聊天记录，但是，用户往往不止一个设备，用户希望聊天记录在每个设备上都能查到。那么这些聊天记录如何在各种设备的客户端之间进行同步呢？
最佳的解决方法就是把聊天记录存储在服务器端，并运行用户的所有设备都能访问聊天历史记录。消息归档组件允许把用户的聊天历史记录存储到服务器的单个库中，并能按需搜索。Tigase服务器提供了对消息归档扩展的完整支持。对终端用户而言，他的工作完全透明，自动存储消息。
消息归档提供了聊天文档的大量特征：
1）可以在任意时间打开/关闭聊天记录
2）支持OTR（Off-The-Record，即聊后即焚）聊天
3）自动把群聊分到不同线程以便逻辑区分不同的对话
4）根据不同的条件，可以灵活地检索聊天历史记录
5）管理员可强制查看所有用户的聊天记录，而不管用户的设置
6）支持开箱即用的数据库分配，允许数据和负载进行分配





# message archive
--comp-name-4=message-archive
--comp-class-4 = tigase.archive.MessageArchiveComponent
#message-archive/archive-repo-uri=jdbc:postgresql://localhost/tigasedb?user=postgres&password=123456&useUnicode=true&characterEncoding=UTF-8&autoCreateUser=true
message-archive/archive-repo-uri=jdbc:postgresql://10.5.1.12/tigasedb?user=postgres&password=123456&useUnicode=true&characterEncoding=UTF-8&autoCreateUser=true
message-archive/auto=true
message-archiving/tags-support[B]=true
# message-archive-xep-0136  [message|body]
--sm-plugins=message-archive-xep-0136
sess-man/plugins-conf/message-archive-xep-0136/component-jid=message-archive@10.5.1.48
sess-man/plugins-conf/message-archive-xep-0136/default-store-method=message
sess-man/plugins-conf/message-archive-xep-0136/required-store-method=message
sess-man/plugins-conf/message-archive-xep-0136/store-muc-messages=user








6、JaXMPP库
提供Android移动设备、GWT Web客户端、独立的Java应用程序等库，完全支持XMPP/Jabber规范及其所有主要的扩展。
JaXMPP代表Java XMPP，但它不仅是Java库，它还兼容GWT，因此可以用于开发Web客户端，它还兼容Android Java，因此可以用于开发带XMPP支持的Android移动应用，以及常规的Java应用程序。
此客户端库的功能完整，而且代码开源并免费。
JaXMPP库网站: 
https://projects.tigase.org/projects/jaxmpp2
JaXMPP库文档: 
https://projects.tigase.org/projects/jaxmpp2/wiki

7、Web客户端
全功能的Web客户端，支持基本的聊天、MUC、发布/订阅和许多扩展管理接口，通过CORS，经BOSH或WebSocket连接到任意XMPP服务器实现跨站点支持。
CORS：Cross-Origin Resource Sharing，跨域资源共享
功能非常全，支持：
1）完整的XMPP规范
2）Web优化（更快的重连和聊天状态恢复）
3）消息归档支持（从服务器查看历史聊天记录）
4）良好的MUC群聊协议（访问Web浏览器时可以群聊）
5）发布订阅（直接从Web浏览器发布消息到发布订阅节点）

8、Android Messenger
完全支持XMPP/Jabber的主要规范和大多数扩展，至此文档和照片的分享，好友的地理位置的分享。
Android Messenger是一个全功能的XMPP客户端，而且还注意保护设备的电池电量，减少设备的流量。特征如下：
1）至此XMPP最新的RFC规范和大多数扩展
2）面向移动的优化，减少电池使用率，降低流量
3）可以同时连接到不同的XMPP服务器，不限制账户数量
4）支持MUC群聊
5）与好友分享地理定位
6）文档和照片分享
7）支持发布订阅功能

9、Tigase Socks5 Proxy
实现通过NAT网络地址转换后的用户间的二进制数据和文件的传输，针对大文件和小文件传输做了优化，支持传说的quotas与计费系统的集成。
及时消息和实时通信系统如今不仅是聊天、在线状态，还可以是语音、视频通话。人们分享他们的想法、经验、情感、照片、视频以及文件。尽管文档分享主要是企业和团体协作的主要功能，照片和视频分享才几乎是每个人都需要的。人们拍照、录制视频，并希望与朋友和家人即时分享。因此，当前的IM和RTC部署需要有效的文件共享系统。
理想情况下，你希望人们直接互联并直传文件。但这不可能，因为如果用户位于NAT背后，或者用户希望与多人一起分享文件就做不到。对于后者，用户需要多次传输文件给朋友才能实现群体分享，消耗太大。
使用公网的代理服务器可以轻松解决以上问题。它允许用户通过代理传输文件。在NAT背后的用户都可以连接到公网代理服务器，并通过它传输共享的文件给多个好友，每位好友可以从服务器下载分享的文件。
Tigase Socks5 Proxy提供了很多独特的功能：
1）NAT背后的用户的二进制数据传输，可交换各种类型的文件
2）超高吞吐率，可充分利用带宽，尤其是传输大文件时
3）大量的并行传输，同时传输多个文件
4）全局配额或为每位用户配额或为域配额，以限制传输和防止滥用
5）易于与计费系统相集成，以便为用户提供更好的服务
6）提供积分系统
7）设置多种机器来分担负载
8）虚拟域的支持，允许隔离用户和客户端到不同的计费组
9）很好地与Tigase XMPP服务器集成，在集群模式下部署系统支持数百万在线用户

10、Tigase CLI Management
提供对XMPP服务器的命令行访问，轻松完成管理任务。
此功能很方便，它可以通过一个漂亮的图形界面来管理。但是，对于Tigase集群模式的安装，最好是采用命令行方式管理，尤其是执行那些通过定时器运行的自动化任务。Web控制台和独立应用都干不了这些任务，还是需要可靠的、灵活的命令行工具来完成这些任务。这就是Tigase命令行管理工具。它的特征如下：
1）完全支持XEP-0133规范的管理命令
2）通过API编写脚本做扩展。尽管工具只是一个Java应用程序，但还是可以使用脚本语言（如Groovy、Python、Ruby等）扩展其功能和命令
3）提供大量开箱即用的管理任务，满足常规的管理需求
4）简单、易用，学习成本低

11、Tigase MUC
支持基于角色的群聊，提供API和自定义扩展，可处理数百万的小型聊天室和有数千用户的大型聊天室。
真正的社区需要人们的互动。这可以通过多种方式实现：电邮、Twitter、FaceBook、论坛、网站评论等。但是，这些都比不上实时通信，发送聊天消息，可以立即得到回应，与朋友在线聊天。多个人一起聊可以用群聊。
Tigase的MUC组件可以提供：
1）实时群聊
这意味着很多人可以在虚拟房间聊天，交流想法。
2）基于角色的房间成员
允许设定房间管理员、版主，分配发消息和允许监听/读取消息的权限。
3）密码保护的聊天室
创建私人群聊室，有密码的用户才能进入聊天室。
4）受邀的聊天室
受邀的用户才能进入聊天室。
5）私人的、无形的聊天室或公共聊天室都可以按需求轻松创建
6）聊天历史记录到数据库
7）通过MUC集群模式支持数百万的群聊室，负载可以有效地分布到各服务器上，并提供了几乎无线的可扩展性
8）MUC集群模式支持超大群聊天室，可容纳成千上万的用户，可以把单个聊天室分不到集群中的多台服务器上。
所有提供的MUC功能都是开源软件，只有MUC集群模式是官方额外提供的商业级功能。





# muc
--comp-name-1=muc
--comp-class-1=tigase.muc.MUCComponent
muc/history-db=pgsql
#muc/history-db-uri=jdbc:postgresql://localhost/tigasedb?user=postgres&password=123456&useUnicode=true&characterEncoding=UTF-8&autoCreateUser=true
muc/history-db-uri=jdbc:postgresql://10.5.1.12/tigasedb?user=postgres&password=123456&useUnicode=true&characterEncoding=UTF-8&autoCreateUser=true
muc/muc-lock-new-room[B]=true
muc/muc-allow-chat-states[B]=true
muc/default_room_config/muc#roomconfig_persistentroom=true









12、Tigase Testsuite
针对基本的XMPP和大多数扩展，提供了数百个测试。
Tigase测试包是一个强大的工具，可以运行Tigase服务器的功能和性能测试。它不限于Tigase，还可以测试支持XMPP协议的服务器。但是，此测试包是为Tigase设计的，是为了确保Tigase各模块功能正常。
这里是测试结果： http://build.tigase.org/~tigase/
实际上，Tigase的每日构建版都用此测试包做了测试，以保障代码质量。
详见： http://build.tigase.org/nightlies/tests/
可以基于此测试包设计复杂的测试场景，此测试包最有趣的特点包括：
1）自定义的脚本语言，可使用很少的代码即可设计非常复杂的测试场景。
2）无需添加简单的测试脚本（内容很全了），在大多数场景下只需指定发送到的服务器、预期的返回结果即可。
3）产生HTML格式的测试报告：成功的测试标绿，失败的测试标红。
4）对每个测试案例都有定时器，因此可以清楚知道服务器的响应时间，还可以用它比较各版本之间的性能差异。
5）每个测试案例都有完整的协议交互的输出，可以定位和分析错误。
6）所有的测试案例都是运行在网络并执行了服务器的方方面面，因此测试包是完整的测试，从网络层到上层组件都得到了测试。

13、Tigase ALB
无限制的设备在线数，地理上发布的集群节点，减少97%网络流量。
有几种解决方案，允许你把用户分配到集群节点，并分发到多个服务器上。这些解决方案包括：Round-robin轮询、专业级的硬件路由器（比如Cisco的）、软硬件防火墙、代理服务等。
这些方案都是为用户随机分配机器，分布或许是比较平均的，但不是最佳的，如果你使用了Tigase ALB（Advanced Load Balancer），那么可以做到其它方案做不到的三件事：
1）为1亿或更多在线用户运行安装
2）构建地理上分散的XMPP集群
3）为有非常大的联系人列表的用户运行安装，联系人列表的人数平均有数千个
对Tigase ALB来说是可能的，因为它把用户分配到特定的集群节点或节点组。它会分析所有用户账户的社交网络，把用户分配到特定的机器上，以便减少网络流量。它采用了基于人工智能和遗传算法的高级技术来实现这一点。
ALB很复杂，但他工作的很好。
ALB是非入侵式的，它可以在后台不断地优化用户数据，并逐步提高系统的整体性能。ALB可以在任意时间打开和关闭，而不会影响XMPP的安装。ALB可以与Round-robin轮询或其它负载均衡方案一起工作。一旦你正确地安装并配置ALB到系统中，它会变为不可见，但你可以看到效果，系统的性能每天都在变得更好。

14、Tigase STUN
允许NAT背后的设备直连，减少服务和系统的负载，降低网络流量。
Jabber、XMPP、IM（Instant Messaging）、IC（Instant Communication）服务最初是交换文本信息。消息文本、用户状态文本、联系人信息文本等，都是通过这样的系统进行交换的。
现在，各种类型的文档、招聘、视频、数据库等，这些二进制数据也需要实时交换。XMPP服务器可以搞定这个，它可以作为二进制连接握手代理和实际的P2P连接的代理或中转代理。偶尔还可作为带内传输。这里有多种选择，通常首选萨送大的二进制数据块给直连的用户。这也是最高效和成本最低的方式。
不幸的是，用户之间要实现直连是很困难的，这是因为NAT的原因，用户在NAT背后，所以用户的设备是不可见的，Internet不能直达。如果某个应用从NAT背后的设备连接互联网时，它是没有办法告知服务器它自己的公开/静态IP地址的，因此它也没法提供任何可选项给第三方如何建立P2P连接。这就需要一个中间服务器，STUN服务器可以搞定这个。它允许应用程序发现自己的公开IP地址，并与另一方协商最优的直连。
此方案的优点：
1）位于NAT背后的两个设备可以建立P2P直连
2）消除了网络消耗大的二进制传输，减少了服务器负载；
3）通过减少了负载和网络流量，降低了运营成本
4）如果需要媒体交换作为用户到XMPP服务的连接，那么它是一个理想的解决方案。它可以很好地与Tigase XMPP服务器相集成，可以部署到多台服务器上，无需复杂的配置。

15、Tigase Monitor监控
更早的发现网络瓶颈。
Tigase Monitor是一个独立的桌面应用程序，它可以连接到所有的Tigase服务器，并提供所有Tigase系统的状态概览。它可以展示有意义的图表，包括：CPU利用率、内存使用率、用户的分布、不同类型的流量……
除此以外，它还提供了内部队列尺寸、潜在的评奖、平均处理时间的详细信息。
Tigase Monitor是实时监控，系统有状况，会立即得到通知。
Tigase Monitor特征包括：
1）Tigase测量的实时数据活动图
2）单个应用监控的服务器数量无限制
3）自定义的“第二”窗口：用于显示自定义的测量数据
4）系统性能和瓶颈的详细信息
5）自动产生屏幕截图，并周期性的存储到硬盘

版权声明：本文为博主原创文章，未经博主允许不得转载。

正则表达式在iOS中的运用（附手机密码邮箱等正则判断）

一、什么是正则表达式

　　正则表达式，又称正规表示法，是对字符串操作的一种逻辑公式。正则表达式可以检测给定的字符串是否符合我们定义的逻辑，也可以从字符串中获取我们想要的特定部分。它可以迅速地用极简单的方式达到字符串的复杂控制。



二、正则表达式的语法


　　看几个例子：手机号码，密码（3～30个字符，不允许特殊字符），邮箱判断。
- (BOOL)validatePhoneNumber:(NSString *) textString{    NSString* number=@"^1[3|4|5|7|8][0-9]\\d{8}$";    NSPredicate *numberPre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",number];    return [numberPre evaluateWithObject:textString];}- (BOOL)validatePassword:(NSString *) textString{    NSString* number=@"^[a-zA-Z0-9]{3,30}$";    NSPredicate *numberPre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",number];    return [numberPre evaluateWithObject:textString];}
- (BOOL)validateEmail:(NSString *) textString{    NSString* number=@"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";    NSPredicate *numberPre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",number];    return [numberPre evaluateWithObject:textString];}


　　下述语句就是一个正则表达式
@"^[0-9]+$"

　　它代表了字符串中只能包含>=1个0-9的数字，语法是不是有一些怪异？

　　下面我们先撇开iOS中的正则表达式的语法，用通俗的正则表达式语法来为介绍一下。（iOS语法与通俗的正则表达式语法相同，不同在于对转义字符的处理上(语言类的都相同)）

　　语法：

　　首先，特殊符号’^'和’$'。他们的作用是分别指出一个字符串的开始和结束。eg：

　　“^one”：表示所有以”one”开始的字符串（”one cat”，”one123″，·····）；

　　类似于:- (BOOL)hasPrefix:(NSString *)aString;

　　“a dog$”：表示所以以”a dog”结尾的字符串（”it is a dog”，·····）；

　　类似于:- (BOOL)hasSuffix:(NSString *)aString;

　　“^apple$”：表示开始和结尾都是”apple”的字符串，这个是唯一的~；

　　“banana”：表示任何包含”banana”的字符串。

　　类似于 iOS8的新方法- (BOOL)containsString:(NSString *)aString,搜索子串用的。

　　‘*’，’+'和’?'这三个符号，表示一个或N个字符重复出现的次数。它们分别表示“没有或更多”（[0,+∞]取整），“一次或更多”（[1,+∞]取整），“没有或一次”（[0,1]取整）。下面是几个例子：

　　“ab*”：表示一个字符串有一个a后面跟着零个或若干个b（”a”, “ab”, “abbb”,……）；

　　“ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多（ ”ab”, “abbb”,……）；

　　“ab?”：表示一个字符串有一个a后面跟着零个或者一个b（ ”a”, “ab”）；

　　“a?b+$”：表示在字符串的末尾有零个或一个a跟着一个或几个b（ ”b”, “ab”,”bb”,”abb”,……）。

　　可以用大括号括起来（{}），表示一个重复的具体范围。例如

　　“ab{4}”：表示一个字符串有一个a跟着4个b（”abbbb”）；

　　“ab{1,}”：表示一个字符串有一个a跟着至少1个b（”ab”,”abb”,”abbb”,……)；

　　“ab{3,4}”：表示一个字符串有一个a跟着3到4个b（”abbb”,”abbbb”)。

　　那么，“*”可以用{0，}表示，“+”可以用{1，}表示，“?”可以用{0，1}表示

　　注意：可以没有下限，但是不能没有上限！例如“ab{,5}”是错误的写法

　　“ | ”表示“或”操作：

　　“a|b”：表示一个字符串里有”a”或者”b”；

　　“(a|bcd)ef”：表示”aef”或”bcdef”；

　　“(a|b)*c”：表示一串”a”"b”混合的字符串后面跟一个”c”；

　　方括号”[ ]“表示在括号内的众多字符中，选择1-N个括号内的符合语法的字符作为结果，例如

　　“[ab]“：表示一个字符串有一个”a”或”b”（相当于”a|b”）；

　　“[a-d]“：表示一个字符串包含小写的’a'到’d'中的一个（相当于”a|b|c|d”或者”[abcd]“）；

　　“^[a-zA-Z]“：表示一个以字母开头的字符串；

　　“[0-9]a”：表示a前有一位的数字；

　　“[a-zA-Z0-9]$”：表示一个字符串以一个字母或数字结束。

　　“.”匹配除“\r\n”之外的任何单个字符：

　　“a.[a-z]“：表示一个字符串有一个”a”后面跟着一个任意字符和一个小写字母；

　　“^.{5}$”：表示任意1个长度为5的字符串；

　　“\num” 其中num是一个正整数。表示”\num”之前的字符出现相同的个数，例如

　　“(.)\1″：表示两个连续的相同字符。

　　“10\{1,2\}” : 表示数字1后面跟着1或者2个0 (“10″,”100″)。

　　” 0\{3,\} ” 表示数字为至少3个连续的0 （“000”，“0000”，······）。

　　在方括号里用’^'表示不希望出现的字符，’^'应在方括号里的第一位。

　　“@[^a-zA-Z]4@”表示两个”@”中不应该出现字母）。

　　常用的还有：

　　“ \d ”匹配一个数字字符。等价于[0-9]。

　　“ \D”匹配一个非数字字符。等价于[^0-9]。

　　“ \w ”匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。

　　“ \W ”匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。

　　iOS中书写正则表达式，碰到转义字符，多加一个“\”,例如：

　　全数字字符：@”^\\d\+$”

　三、iOS中正则表达式

　　1.正则表达式与NSPredicate连用，eg：
- (BOOL)validateNumber:(NSString *) textString
{
    NSString* number=@"^[0-9]+$";
    NSPredicate *numberPre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",number];
    return [numberPre evaluateWithObject:textString];
}

　　2.NSString方法

　　- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask;
NSString *searchText = @"rangeOfString";
NSRange range = [searchText rangeOfString:@"^[0-9]+$" options:NSRegularExpressionSearch];
if (range.location != NSNotFound) {
   NSLog(@"range ：%@", [searchText substringWithRange:range]);
}

　　3.正则表达式类（NSRegularExpression）
NSString *searchText = @"you want to match";    
NSError *error = NULL;
NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"^[0-9]+$" options:NSRegularExpressionCaseInsensitive error:&error];
NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];
if (result) {
   NSLog(@"%@", [searchText substringWithRange:result.range]);
}

　四、常用的正则表达式

　　以下红色字符串是常用的正则表达式（以下正则表达式来自百度百科）

　　1.验证用户名和密码：”^[a-zA-Z]\w{5,15}$”

　　2.验证电话号码：（”^(\\d{3,4}-)\\d{7,8}$”）

　　eg：021-68686868  0511-6868686；

　　3.验证手机号码：”^1[3|4|5|7|8][0-9]\\d{8}$”；

　　4.验证身份证号（15位或18位数字）：”\\d{14}[[0-9],0-9xX]”；

　　5.验证Email地址：(“^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\.\\w+([-.]\\w+)*$”)；

　　6.只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”)
 ;

　　7.整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$

　　8.只能输入数字：”^[0-9]*$”。

　　9.只能输入n位的数字：”^\\d{n}$”。

　　10.只能输入至少n位的数字：”^\\d{n,}$”。

　　11.只能输入m~n位的数字：”^\\d{m,n}$”。

　　12.只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。

　　13.只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。

　　14.只能输入有1~3位小数的正实数：”^[0-9]+(\.[0-9]{1,3})?$”。

　　15.只能输入非零的正整数：”^\+?[1-9][0-9]*$”。

　　16.只能输入非零的负整数：”^\-[1-9][]0-9″*$。

　　17.只能输入长度为3的字符：”^.{3}$”。

　　18.只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。

　　19.只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。

　　20.只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。

　　21.验证是否含有^%&’,;=?$\”等字符：”[^%&',;=?$\x22]+”。

　　22.只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。

　　23.验证URL：”^http://([\\w-]+\.)+[\\w-]+(/[\\w-./?%&=]*)?$”。

　　24.验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01″～”09″和”10″～”12″。

　　25.验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01″～”09″、”10″～”29″和“30”~“31”。

　　26.获取日期正则表达式：\\d{4}[年|\-|\.]\\d{\1-\12}[月|\-|\.]\\d{\1-\31}日?

　　评注：可用来匹配大多数年月日信息。

　　27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]

　　评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）

　　28.匹配空白行的正则表达式：\n\s*\r

　　评注：可以用来删除空白行

　　29.匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</>|<.*? />

　　评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力

　　30.匹配首尾空白字符的正则表达式：^\s*|\s*$

　　评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式

　　31.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*

　　评注：网上流传的版本功能很有限，上面这个基本可以满足需求

　　32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

　　评注：表单验证时很实用

　　33.匹配腾讯QQ号：[1-9][0-9]\{4,\}

　　评注：腾讯QQ号从10 000 开始

　　34.匹配中国邮政编码：[1-9]\\d{5}(?!\d)

　　评注：中国邮政编码为6位数字

　　35.匹配ip地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。

　　下面给出正则表达式的元字符（来自百度百科）

　五、正则表达式中的元字符

 




元字符

描述



\

将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。



^

匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。



$

匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。



*

匹配前面的子表达式零次或多次(大于等于0次)。例如，zo*能匹配“z”，“zo”以及“zoo”。*等价于{0,}。



+

匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。



?

匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。



{n}

n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。



{n,}

n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。



{n,m}

m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。



?

当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。



.点

匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。



(pattern)

匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。



(?:pattern)

匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。



(?=pattern)

正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。



(?!pattern)

正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。



(?<=pattern)

反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。



(?<!pattern)

反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。



x|y

匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。



[xyz]

字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。



[^xyz]

负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。



[a-z]

字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.



[^a-z]

负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。



\b

匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。



\B

匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。



\cx

匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。



\d

匹配一个数字字符。等价于[0-9]。



\D

匹配一个非数字字符。等价于[^0-9]。



\f

匹配一个换页符。等价于\x0c和\cL。



\n

匹配一个换行符。等价于\x0a和\cJ。



\r

匹配一个回车符。等价于\x0d和\cM。



\s

匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。



\S

匹配任何非空白字符。等价于[^ \f\n\r\t\v]。



\t

匹配一个制表符。等价于\x09和\cI。



\v

匹配一个垂直制表符。等价于\x0b和\cK。



\w

匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。



\W

匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。



\xn

匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&1”。正则表达式中可以使用ASCII编码。



\num

匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。



\n

标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。



\nm

标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。



\nml

如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。



\un

匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。



\< \>

匹配词（word）的开始（\<）和结束（\>）。例如正则表达式\<the\>能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。



\( \)

将 \( 和 \) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。



|

将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。



+

匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。



?

匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。



{i} {i,j}

匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3} 能够匹配字符”A”后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6} 匹配连续的任意4个、5个或者6个数字






版权声明：本文为博主原创文章，未经博主允许不得转载。

Tigase开发笔记5：如何自定义插件 Plugin
其他博客比较好的介绍推荐：http://my.oschina.net/greki/blog/209726




1. 定义一个插件


四种处理器插件接口：


 第一步 – 预处理 – XMPPPreprocessorIfc：这是预处理器插件需要实现的接口 第二步 –  处理 –    XMPPProcessorIfc：这是处理器插件需要实现的接口 第三步 –  投递 –    XMPPPostProcessorIfc：这是投递处理器插件需要实现的接口 第四步 –  过滤 –    XMPPPacketFilterIfc：这是结果过滤器插件需要实现的接口 

如果要开发一个处理器插件，那么就需要实现XMPPProcessorIfc接口；如果是预处理插件，就需要实现XMPPPreprocessorIfc接口；

当然你也可以实现多个接口，这个取决于你的需求和情况，你也可以继承处理器Helper抽象类(XMPPProcessor.java抽象类)作为基类来实现所有的插件。






public class SpamFilterPlugin extends XMPPProcessor implements XMPPProcessorIfc {/** Field : Plugin ID Setting ,this' very important 定义插件ID */private static final String ID        = "spam-filter-xep-0076";/** Field : Plugin xmlns Setting ,this' very important 定义命名空间 */private static final String    XMLNS    = "jabber:client";
@Override
  public void process(Packet packet, XMPPResourceConnection session, NonAuthUserRepository repo, Queue<Packet> results, Map<String, Object> settings)      throws XMPPException {       // code here...   }
}


要做的第一件事情就是确定插件ID。它是唯一的，需要放到配置文件里面，告诉服务器在启动时加载并使用相对应的插件。

如果这个插件需要只对特定命名空间下特定名称的元素“感兴趣”，那么我们需要定义XMLNS元素来定义命名空间。







    下面用一张图总结一下怎样定义一个插件











2. 重要的处理方法process介绍






/** * 处理消息* @param packet 在PROCESS处理过程中无法修改它 * @param session XMPPResourceConnection用于保存所有用户的数据，它提供权限访问用户的仓库数据，在没有在线用户SESSION的情况下该参数可以为null * @param repo NonAuthUserRepository该参数往往在参数session为NULL的时候被使用，它用于为不在线的用户保存私有或公开的数据信息。 * @param results Queue<Packet>这个为输入数据包的处理结果产生的数据包集合，它总被要求一定要存放一个输入数据包PACKET的备份到里面，其实包含了所有需要处理的PACKET,<strong>包括process生成的结果packet</strong>。
 * @param settings Map<String, Object>  为PLUGIN制定配置信息，一般情况下不需要使用，然而如果需要访问额外的数据库则可以通过配置文件将数据库连接字符串传给plugin * * @throws XMPPException */@Overridepublic void process(Packet packet, XMPPResourceConnection session, NonAuthUserRepository repo, Queue<Packet> results, Map<String, Object> settings)throws XMPPException {if (session == null) {return;   }try {
      //code here ...if (Message.ELEM_NAME == packet.getElemName()) {
      }
  }catch (NotAuthorizedException ex) {log.log(Level.WARNING, "NotAuthorizedException for packet: {0}", packet);   results.offer(Authorization.NOT_AUTHORIZED.getResponseMessage(packet,"You must authorize session first.", true));  }}











3. 在init.properties文件中配置插件

--sm-plugins=spam-filter-xep-0076备注说明#如果需要添加(+,默认为+,可忽略不写)或删除(-)插件规则是使用加减号前缀即可--sm-plugins=+spam-filter-xep-0076,-jabber:iq:register#如果给这个插件还定义了参数，那么我们可以参考这样的规则sess-man/plugins-conf/插件ID/参数key = 参数valueeg.sess-man/plugins-conf/spam-filter-xep-0076/component-jid=message-archive@10.5.1.48sess-man/plugins-conf/spam-filter-xep-0076/default-store-method=message

4. 在客户端发请求进行调用

我使用的是Openfire的Spark客户端进行调试（Spark登陆界面->高级->启用调试模式->登录）



发送报文





<message to="jiangpr@10.5.1.48" id="OHPTO-19" type="chat" xmlns="jabber:client" from="d@10.5.1.48/Spark"><body>sdf（测试内容发送）</body><thread>qcNhnm</thread><x xmlns="jabber:x:event"><offline/><composing/></x></message>



可以看到报文中的命名空间为：xmlns="jabber:client"，我们定义的插件对这个消息就会"感兴趣",这种消息就会被转发到我们定义的插件进行处理。




eg.
<message to="spam-filter@10.5.1.48" id="OHPTO-19" type="chat" xmlns="jabber:client" from="d@10.5.1.48/Spark">
<body>sdf（测试内容发送）packet3</body><thread>qcNhnm</thread>
<x xmlns="jabber:x:event"><offline/><composing/></x>
</message>











5. 常见的一些proccess中的代码处理









public void process(finalPacket packet,

    final XMPPResourceConnection session,

    final NonAuthUserRepository repo,

    final Queue<Packet> results,

    final Map<String, Object> settings)

    throwsXMPPException {

 

  // 出于性能的考虑，最好在打印日志之前现检查一下日志级别

  if(log.isLoggable(Level.FINEST)) {

    log.finest("Processing packet: "+ packet.toString());

  }

 

  // 如果用户不在线，你也许想跳过后面的处理环节

  if(session ==null) {

    return;

  }// end of if (session == null)

 

  // 当插件在第一次处理这个用户的会话信息的时候，还有另外一种方法可以执行必要的操作

  if(session.getSessionData(ID) ==null) {

    session.putSessionData(ID, ID);

    // 你可以把你的代码放到这里

    .....

    // 如果你不希望终止操作，那么就把return语句去掉

    return;

  }

 

  // 如果用户的会话没有授权，那么每一次调用session.getUserId()方法都会抛出异常

  try{

 

    // 在比较JID之前一定记得要去掉resource部分

    // JID的组成：jid = [ node "@" ] domain [ "/" resource ]

    // 比如：chutianxing@gmail.com/home

    String id = JIDUtils.getNodeID(packet.getElemTo());

    // 检查一下这个packet是否是发给会话的拥有者

    if(session.getUserId().equals(id)) {

      // 如果是，那么这个消息的确是要发送给这个客户端的

      Element elem = packet.getElement().clone();

      Packet result =newPacket(elem);

      // 这里就是我们为最终收到消息的用户设置客户端组件地址的地方了

      // 在大多数情况，这可能是一个能够保持于客户端连接的c2s或Bosh组件

      result.setTo(session.getConnectionId(packet.getElemTo()));

      // 在大多数情况，这一步可以跳过，但是当packet的投递过程出现了什么问题，这么做可以为调用者返回一个错误

      result.setFrom(packet.getTo());

      // 最后不要忘记把结果packet放到结果队列里面去，否则结果会丢失

      results.offer(result);

    }// end of else

 

    // 在比较JID之前一定记得要去掉resource部分

    id = JIDUtils.getNodeID(packet.getElemFrom());

    // 检查一下这个packet是否由会话的拥有者发出

    if(session.getUserId().equals(id)) {

      // 这是一个由客户端发出的packet，最简单的处理就是把packet转发到packet的目的地地址：

      // 简单的对XML元素进行克隆，然后……

      Element result = packet.getElement().clone();

      // 把他放到传出packet队列里面就行了

      results.offer(newPacket(result));

      return;

    }

 

    // 程序真的会运行到这里吗？

    // 是的，一些packet即没有from也没有to地址。最容易理解的一个例子是向服务器发送的获取某些数据的IQ请求。这类packet没有任何地址，并且需要对它做很多复杂的处理

    // 下面的代码展示了如何确定这个seesion就是请求发起者的session

    id = packet.getFrom();

    // 下面的处理和检查getElementFrom差不多

    if(session.getConnectionId().equals(id)) {

      // 这里需要针对IQ packet做一些特别处理，但是我们需要处理的是message，所以这里只需要对它进行转发

      Element result = packet.getElement().clone();

      // 如果程序运行到这里说明packet的from地址是没有的，现在对from属性就行设置

      result.setAttribute("from", session.getJID());

      // 最后把传出packet放到结果队列里面就ok乐

      results.offer(newPacket(result));

    }

 

  }catch(NotAuthorizedException e) {

    log.warning("NotAuthorizedException for packet: "  +

      packet.getStringData());

    results.offer(Authorization.NOT_AUTHORIZED.getResponseMessage(packet,

      "You must authorize session first.",true));

  }// end of try-catch

 

}










版权声明：本文为博主原创文章，未经博主允许不得转载。

Android下拉上滑显示与隐藏Toolbar另一种实现
关于介绍就不说了，不使用嵌套滑动情况下，另一种实现，当然还可以用design包下的CoordinatorLayout.Behavior。比较简单直接添代码：
继承RecyclerView.OnScrollListener重写onScrolled方法，同时定义两个抽象方法供我们处理隐藏和显示事件
public abstract class RecyclerViewScrollListener extends RecyclerView.OnScrollListener {
    private static final int SCROLL_DISTANCE = 50;
    private int totalScrollDistance;
    private boolean isShow = true;

    @Override
    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
        super.onScrollStateChanged(recyclerView, newState);
    }

    @Override
    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
        super.onScrolled(recyclerView, dx, dy);
        int firstVisableItem = ((LinearLayoutManager) recyclerView.getLayoutManager()).findFirstVisibleItemPosition();
        //当第一个item存在界面上时就不触发隐藏、显示操作
        if(firstVisableItem==0){
            return;
        }
        if ((dy > 0 && isShow) || (dy < 0 && !isShow)) {
            totalScrollDistance += dy;
        }
        if (totalScrollDistance > SCROLL_DISTANCE && isShow) {
            hide();
            isShow = false;
            totalScrollDistance = 0;
        } else if (totalScrollDistance < -SCROLL_DISTANCE && !isShow) {
            show();
            isShow = true;
            totalScrollDistance = 0;
        }
    }

    public abstract void hide();

    public abstract void show();
}
隐藏和显示事件处理
 mRecyclerView.addOnScrollListener(new RecyclerViewScrollListener() {
            @Override
            public void hide() {
                mToolbar.animate().translationY(-mToolbar.getHeight()).setInterpolator(new AccelerateDecelerateInterpolator());
            }

            @Override
            public void show() {
                mToolbar.animate().translationY(0).setInterpolator(new AccelerateDecelerateInterpolator());
            }
        });
效果： 


xml布局：
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <android.support.v7.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:paddingTop="?attr/actionBarSize"
        android:clipToPadding="false"
        android:layout_height="match_parent"/>
    <android.support.v7.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:background="#8803A9F4"
        android:layout_height="?actionBarSize" />

</RelativeLayout>
其中上面RecyclerView中有用到一个属性：android:clipToPadding，这个属性用的不多，这里说明一下用法，这个属性意思当就是当我们设置了paddingTop等属性时候，用来设置列表的内容是否可以绘制在padding区域， 默认是true，表示不可以绘制在padding区域，false表示可以在padding区域绘制，如上效果图显示，列表区域本来是全屏的，而我设置了paddingTop为actionbar的高度，所以列表的内容会在actionbar下面，当往上滑动时候由于我设置了android:clipToPadding="false"，所以可以绘制在padding区域，下面我如果把它设为true，android:clipToPadding="true",不觉明历，肯定是上面有一块padding的空白区域，来看看效果： 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。转载注明出处：http://blog.csdn.net/u010687392

【Material Design视觉设计语言】应用组件设计（一）：按钮
作者：郭孝星 
微博：郭孝星的新浪微博 
邮箱：allenwells@163.com 
博客：http://blog.csdn.net/allenwells 
Github：https://github.com/AllenWells

按钮由文字和/或图标组成，文字及图标必须能让人轻易地和点击后展示的内容联系起来。

一 按钮的分类
1.1 悬浮响应按钮

悬浮响应按钮(Floating action button)， 点击后会产生墨水扩散效果的 圆形按钮。

悬浮响应按钮是促进动作里的特殊类型。 是一个圆形的漂浮在界面之上的、拥有一系列特殊动作的按钮，这些动作通常和变换、启动、以及它本身的转换锚点相关。

悬浮响应按钮有两种尺寸: 默认尺寸和迷你尺寸。 迷你尺寸仅仅用于配合屏幕上的其他元素制造视觉上的连续性。
 

1.2 浮动按钮

浮动按钮(Raised button)， 常见的方形纸片按钮，点击后会产生墨水扩散效果。

1.2.1 浮动按钮的设计原则
浮动按钮使按钮在比较拥挤的界面上更清晰可见。能给大多数扁平的布局带来层次感。在用动画表现浮动按钮时，浮动按钮看起来像一张放在页面上的纸片，点击后会浮起来并表现出色彩。
一个屏幕只推荐使用一个浮动操作按钮来增加其显著性。它应该只代表最常见的操作（应用的主要操作按钮应该采用圆形按钮，且不要给按钮增加额外的维度）。下面就是一种错误的做法。

浮动按钮通常用来进行积极的操作，如创建、收藏、分享、浏览和探索。

避免用浮动操作按钮进行下面这些轻微破坏性操作

存档或删除
非特异性操作
警报或错误
限制性任务如剪切文本
控制应放在一个工具栏中，如音量控制或改变字体颜色


1.2.2 大屏幕下的浮动按钮摆放
关于在平板等大屏幕设备中浮动按钮的摆放位置。
浮动操作按钮可以附属到一个扩展的App Bar

浮动操作按钮可以被附属到单页中的一个工具栏或者结构化元素

浮动操作按钮可以被附属到一个单页的边缘。

单个屏幕上不要多与一个浮动操作按钮

不要将浮动操作按钮与屏幕上的每个元素都联系起来

1.3 扁平按钮

扁平按钮(Flat button)， 点击后产生墨水扩散效果，和浮动按钮的区别是没有浮起的效果。

扁平按钮一般用于对话框或者工具栏， 可避免页面上过多无意义的层叠。在用动画表现扁平按钮时，应该让扁平按钮一直保持和页面贴合的状态，点击后会填充颜色。

二 按钮的使用方法
按钮的使用规则如下所示：

颜色饱满的图标应当是功能性的，尽量避免把他们作为纯粹装饰用的元素。
按钮类型应该基于主按钮、屏幕上容器的数量以及整体布局来进行选择。
基于放置按钮的容器以及屏幕上层次堆叠的数量来选择使用浮动按钮还是扁平按钮。而且应该避免过多的层叠。
一个容器应该只使用一种类型的按钮。 只在比较特殊的情况下（比如需要强调一个浮起的效果）才应该混合使用多种类型的按钮。
根据特定的布局来选择使用扁平按钮或者浮动按钮。对于扁平按钮，应该在内部四周留出足够的空间（内边距）以使按钮清晰可见。

2.1 对话框中的按钮
对话框中使用扁平按钮作为主要按钮类型以避免过多的层次叠加。

2.2 底部固定按钮
如果需要一个非主要、但是能快速定位到的按钮，则可以使用底部固定按钮。

2.3 图标开关
图标适合用在应用导航条或者工具条上，作为动作按钮或者开关。图标开关可以在它的范围内呈现弹性或者非弹性的墨水扩散涟漪效果。

2.4 下拉菜单按钮
下拉菜单按钮可以用来控制对象状态; 一般会有两个甚至更多的状态。 按钮会显示当前状态以及一个向下的箭头—当按钮触发后， 一个包含所有状态的菜单会在按钮周围弹出（通常都是在下方）。 菜单中的状态通常会以字符、调色板、图标或者其他的形式呈现出来。点击任意一个状态将会改变按钮的状态显示。这展示的是一个常见的带有列表式菜单的下拉菜单按钮。

三 按钮的动画设计
我们通常会用墨水涟漪效果来实现按钮的交互响应，墨水涟漪效果会跟着焦点的改变从一个按钮转换到另一个按钮。聚焦状态的动画会表现出正常状态和点击状态间来回切换的过渡效果。
模拟按钮状态的时候， 可以使用图形轮换来表现动画。注意聚焦状态会一直处于动画的状态
3.1 扁平按钮动画设计
Flat Light/Light color 
最小宽度: 88 dp， 高度: 36 dp 
覆盖状态: 20% #999， 点击状态: 40% #999， 不可用状态: 10% #999

Flat Dark/Dark Color 
最小宽度: 88 dp， 高度: 36 dp 
覆盖状态: 15% #ccc， 点击状态: 25% #ccc， 不可用状态: 10% #ccc

我们来看一下实际的扁平按钮动画表现

3.2 浮动按钮动画设计
浮动操作按钮就像一块扩展的物体在屏幕上活动。在它里面的图标可能是活动的。
Raised Light/Light Color 
最小宽度: 88 dp， 高度: 36 dp

Raised Dark/Dark Color 
最小宽度: 88 dp， 高度: 36 do 
正常状态: Color 500， 覆盖状态: Color 600， 点击状态: Color 700， 不可用状态: 10% #ccc

我们来看一下实际的浮动按钮动画表现

3.2.1 浮动按钮的焦点变化
浮动按钮获取焦点

浮动按钮被选中

3.2.2 浮动按钮的切换
如果在多个旁边的屏幕上有浮动操作按钮（例如选项卡），在进入屏幕时，若在每个屏幕上的操作不同，按钮应该显示和隐藏。若操作相同，按钮应该停留在屏幕上，如果有需要则转换到新的位置上。

对于带有标签的屏幕，浮动操作按钮不应朝着屏幕退出时的同一方向退出屏幕。否则会导致视觉噪音。这也将导致在屏幕上出现一个失灵的浮动操作按钮。此外，它错误地暗示了浮动操作按钮与内容在相同的 Z 水平高度上，而不是在根水平高度中 UI 主元素所在的水平高度的上。


3.2.3 浮动按钮的变形
浮动操作按钮变成一个工具栏

工具栏在滚动时转变成一个浮动操作按钮

一个浮动的操作按钮能够释放相关的操作，按动按钮时保持三个以上的选项，但不要超过六个，包括原来的浮动操作按钮。如果你有两个选项，即，你的浮动操作按钮只弹出了另外一个选项——选择哪个操作是最重要的。如果选项超过六个，用户可能在选择上有困惑。

一个浮动按钮转变为一个 material 单页，浮动操作按钮可以转变为 material 单页，app 结构中的部分。这个神奇的转变突出了按钮可以做的操作。
当浮动操作按钮变形时，在开始和结束位置之间以合理的方式转换。例如，不要穿过其他的 material 单页。
变形动画应该是可逆的，可以将新的 material 单页变回为浮动操作按钮。

浮动动作按钮可以转变成占满整个屏幕的新型物品


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：当我们认真的去做一件事的时候，就能发现其中的无穷乐趣，丰富多彩的技术宛如路上的风景，边走边欣赏。

UIView（包括子类）的几个初始化时执行动作的时机

根据你需要执行的动作, 这里有几个方法:


-(id)initWithFrame:(CGRect)frame -
 UIView的指定初始化方法; 总是发送给UIView去初始化, 除非是从一个nib文件中加载的;
-(id)initWithCoder:(NSCoder
 *)coder - 从nib文件中加载的时候发送此消息给UIView;
-(void)awakeFromNib -
 在所有的nib中的对象初始化和连接后将发送此消息; 只适用于从nib加载对象; 如要重写，其中还必须调用父类的awakeFromNib;
-(void)willMoveToSuperview:(UIView
 *)newSuperview - 在一个子视图将要被添加到另一个视图的时候发送此消息;
-(void)willMoveToWindow:(UIWindow
 *)newWindow - 在一个视图（或者它的超视图）将要被添加到window的时候发送;
-(void)didMoveToSuperview -
 把一个视图插入到视图层级之后发送此消息;
-(void)didMoveToWindow -
 当视图获得它的window属性集的时候发送此消息.
基本上, 你能选择: 在你的视图初始化期间执行的动作 (1 & 2), 在从nib文件中加载的时候 (3), 在插入到视图层级之前 (4 & 5) 和 之后 (6 & 7)


layoutSubviews方便数据计算，drawRect方便视图重绘。


layoutSubviews在以下情况下会被调用：


 

1、init初始化不会触发layoutSubviews。
2、addSubview会触发layoutSubviews。
3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。
4、滚动一个UIScrollView会触发layoutSubviews。
5、旋转Screen会触发父UIView上的layoutSubviews事件。
6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。

7、直接调用setLayoutSubviews。




drawRect在以下情况下会被调用：

 

1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect 掉用是在Controller->loadView, Controller->viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量
 值).
2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。
3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。
4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。
以上1,2推荐；而3,4不提倡




drawRect方法使用注意点：

 

1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或 者 setNeedsDisplayInRect，让系统自动调该方法。
2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法
3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕


版权声明：本文为博主原创文章，未经博主允许不得转载。

静态方法和静态代码块
注意事项：
1.静态代码块不能写this或者对象，因为静态代码块在对象初始化之前执行；
2.静态代码块在构造代码块之前执行；
3.静态代码块用于初始化类，只执行一次；
4.静态方法只能访问静态成员；




执行顺序：静态代码块->构造代码块->构造方法

版权声明：本文为博主原创文章，未经博主允许不得转载。

UITableView的registerClass forCellReuseIdentifier用法详解
转载自:  http://www.zpluz.com/thread-3504-1-1.html

tableView: cellForRowAtIndexPath:方法中有两个获得重用cell的方法

UITableViewCell *cell = [tableView
 dequeueReusableCellWithIdentifier:CellIdentifier];

和

UITableViewCell *cell = [tableView
 dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath]


请问他们有什么区别？
当我用
 UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath]的时候为什么总报错
reason:
 'unable to dequeue a cell with identifier Cell - must register a nib or a class for the identifier or connect a prototype cell in a storyboard'




------解决方案--------------------------------------------------------

- (id)dequeueReusableCellWithIdentifier:(NSString
 *)identifier;

- (id)dequeueReusableCellWithIdentifier:(NSString
 *)identifier forIndexPath:(NSIndexPath *)indexPath



NS_AVAILABLE_IOS(6_0);
 // newer



区别在这儿


------解决方案--------------------------------------------------------

1 这个方法在SDK5.0是运行不起来的。

2 如果需要使用这个方法，你必须使用配套的方法来一起用，下面两个配套方法：
// Beginning in iOS 6, clients can register a nib or class for each cell.
// If all reuse identifiers are registered, use the newer -dequeueReusableCellWithIdentifier:forIndexPath: to guarantee that a cell instance is returned.
// Instances returned from the new dequeue method will also be properly sized when they are returned.
- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);
- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);


注意看上面的注释


3 比如你已经用NIB做了一个Cell，或者自定义了一个Cell。我们在你创建UITableView的时候，就可以顺带

self.tableView.backgroundColor = xxxx;
[self.tableView registerClass:[CustomCell class] forCellReuseIdentifier:@"CustomCell"];


这样你在- (UITableViewCell *)tableView:(UITableView
 *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath这个方法里，你就可以省下这些代码：

    static NSString *CellIdentifier = @"Cell";
    if (cell == nil) {
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];
      //设置你的cell
｝

而只需要


    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"Cell" forIndexPath:indexPath];



这样就够了，这下你明白了吗？

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android中图像变换Matrix的原理、代码验证和应用(二)

注：本篇文章为转载文章，因为原文格式排版较乱，但是内容非常棒，所以整理一下，方便以后查看。 
  查看原文请戳：http://blog.csdn.net/pathuang68/article/details/6991988 
  Matrix介绍文章请戳：http://blog.csdn.net/pathuang68/article/details/6991867

package com.pat.testtransformmatrix;
import android.app.Activity;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.os.Bundle;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.view.View.OnTouchListener;
import android.widget.ImageView;

public class TestTransformMatrixActivity extends Activity implements OnTouchListener
{
    private TransformMatrixView view;
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
      super.onCreate(savedInstanceState);
      requestWindowFeature(Window.FEATURE_NO_TITLE);
      getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
      WindowManager.LayoutParams.FLAG_FULLSCREEN);

        view = new TransformMatrixView(this);
        view.setScaleType(ImageView.ScaleType.MATRIX);
        view.setOnTouchListener(this);

        setContentView(view);
    }

    class TransformMatrixView extends ImageView
    {
        private Bitmap bitmap;
        private Matrix matrix;
        public TransformMatrixView(Context context){
            super(context);
            bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie);
            matrix = new Matrix();
        }

        @Override
        protected void onDraw(Canvas canvas){
            // 画出原图像
            canvas.drawBitmap(bitmap, 0, 0, null);
            // 画出变换后的图像
            canvas.drawBitmap(bitmap, matrix, null);
            super.onDraw(canvas);
        }

        @Override
        public void setImageMatrix(Matrix matrix){
            this.matrix.set(matrix);
            super.setImageMatrix(matrix);
        }

        public Bitmap getImageBitmap(){
            return bitmap;
        }
    }

    public boolean onTouch(View v, MotionEvent e){
        if(e.getAction() == MotionEvent.ACTION_UP){
            Matrix matrix = new Matrix();
            // 输出图像的宽度和高度(162 x 251)
            Log.e("TestTransformMatrixActivity", "image size: width x height = " +  view.getImageBitmap().getWidth() + " x " + view.getImageBitmap().getHeight());
            // 1. 平移
            matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());
            // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight()
            view.setImageMatrix(matrix);

            // 下面的代码是为了查看matrix中的元素
            float[] matrixValues = new float[9];
            matrix.getValues(matrixValues);
            for(int i = 0; i < 3; ++i){
                String temp = new String();
                for(int j = 0; j < 3; ++j){
                    temp += matrixValues[3 * i + j ] + "\t";
                }
                Log.e("TestTransformMatrixActivity", temp);
            }

//          // 2. 旋转(围绕图像的中心点)
//          matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f);
//          view.setImageMatrix(matrix);

//          // 3. 旋转(围绕坐标原点) + 平移(效果同2)
//          matrix.setRotate(45f);
//          matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f);
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f);
//          view.setImageMatrix(matrix);    

//          // 4. 缩放
//          matrix.setScale(2f, 2f);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠
//          matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());
//          view.setImageMatrix(matrix);

//          // 5. 错切 - 水平
//          matrix.setSkew(0.5f, 0f);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠         
//          matrix.postTranslate(view.getImageBitmap().getWidth(), 0f);
//          view.setImageMatrix(matrix);

//          // 6. 错切 - 垂直
//          matrix.setSkew(0f, 0.5f);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠             
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());
//          view.setImageMatrix(matrix);

//          7. 错切 - 水平 + 垂直
//          matrix.setSkew(0.5f, 0.5f);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠             
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());
//          view.setImageMatrix(matrix);

//          // 8. 对称 (水平对称)
//          float matrix_values[] = {1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f};
//          matrix.setValues(matrix_values);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f);
//          view.setImageMatrix(matrix);

//          // 9. 对称 - 垂直
//          float matrix_values[] = {-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f};
//          matrix.setValues(matrix_values);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f);
//          view.setImageMatrix(matrix);

//          // 10. 对称(对称轴为直线y = x)
//          float matrix_values[] = {0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f};
//          matrix.setValues(matrix_values);
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠             
//          matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(), 
//                  view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth());
//          view.setImageMatrix(matrix);

            view.invalidate();
        }
        return true;
    }
}


下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵

平移 
 
输出的结果： 
 
请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。



旋转(围绕图像的中心点) 
 
输出的结果： 
 
它实际上是 
matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); 
matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f); 
这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式， 
matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); 
所产生的转换矩阵就是： 
 
而matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);的意思就是在上述矩阵的左边再乘以下面的矩阵： 
 
关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。

所以它实际上就是： 
 
出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。


旋转(围绕坐标原点旋转，在加上两次平移，效果同2) 
 
根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道： 
matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); 
等价于 
matrix.setRotate(45f); 
matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f); 
matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);

其中matrix.setRotate(45f)对应的矩阵是： 
 
matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight()/ 2f)对应的矩阵是： 
 
由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。
matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f)对应的矩阵是： 
 
这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。
所以综合起来， 
matrix.setRotate(45f); 
matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f); 
matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f); 
对应的矩阵就是： 
 
这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的： 
 
因此，此处变换后的图像和2中变换后的图像时一样的。


缩放变换 
 
程序所输出的两个矩阵分别是： 
 
其中第二个矩阵，其实是下面两个矩阵相乘的结果： 
 
大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。



错切变换(水平错切) 
 
代码所输出的两个矩阵分别是： 
 
其中，第二个矩阵其实是下面两个矩阵相乘的结果： 
 
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。



错切变换(垂直错切) 
 
代码所输出的两个矩阵分别是： 
 
其中，第二个矩阵其实是下面两个矩阵相乘的结果： 
 
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。



错切变换(水平+垂直错切) 
 
代码所输出的两个矩阵分别是： 
 
其中，后者是下面两个矩阵相乘的结果： 
 
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。



对称变换(水平对称) 
 
代码所输出的两个各矩阵分别是： 
 
其中，后者是下面两个矩阵相乘的结果： 
 
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。



对称变换(垂直对称) 
 
代码所输出的两个矩阵分别是： 
 
其中，后者是下面两个矩阵相乘的结果： 
 
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。



对称变换(对称轴为直线) 
 
代码所输出的两个矩阵分别是： 
 
其中，后者是下面两个矩阵相乘的结果： 
 
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。



关于先乘和后乘的问题 
由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例： 
 
越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。

当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate()，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。
所有这些，其实都是很自然的事情。

再次感谢原博主的文章
转载请注明出处：http://blog.csdn.net/zhaokaiqiang1992

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
动画特效十一：侧边栏效果
好久没有进行 "动画特效" 这一系列了。今天和大家继续分享动画特效：“侧边栏效果”。由于侧边栏效果的动画效果各式各样了，所以我大致分为三种进行说明；
样式一：




这个样式的动画效果还是比较容易处理的。主要是通过计算view的宽度或者位置来实现。我这样说，也许有点模糊了。让我们来分析程序的架构模式。








默认情况下是"图一"模式：
1.  "Screen area" 就是移动设备屏幕显示区域。并且它的根控制器就是 "ContainerViewController"。
2.  SliderViewController是 ContainerViewController的子控制器，它的坐标的x，y均为0，高度为屏幕的高度，有自己的宽度。
3. CenterViewController是 ContainerViewController的子控制器，它的坐标的x值就是SliderViewController的View的宽度，y为0，宽高大小等于屏幕的宽高大小。
代码设计思路：
就以点击白色按钮的效果进行说明(注：实际应用中，又将CenterViewController进行导航栏一层的封装，而上面的白色按钮是导航栏的leftBarButtonItem)。
当你点击白色按钮的时候，就来判断当前CenterViewController所在的导航控制器的View的x值。
1. 如果等于0（动画效果就是要从"图二" 变成 "图一"）; 
2. 如果等于侧边栏的宽度（动画效果就是要从"图一" 变成 "图二"）; 
不管动画是从谁执行到谁，均是同时改变两个子控制器的View的x值来实现的。
核心代码如下：
- (void)toggleSideMenu {
    CGFloat ratio = self.centerNavVC.view.x / self.baseWidth;
    BOOL isOpen = ratio == 1.0;
    CGFloat toggleProgress = isOpen ? 0.0 : 1.0;
    [UIView animateWithDuration:0.25 animations:^{
        [self setToPercent:toggleProgress];
    }];
}

- (void)setToPercent:(CGFloat)progress {
    self.slideMenuVC.view.x = (progress - 1) * self.baseWidth;
    self.centerNavVC.view.x = progress * self.baseWidth;
}
注：由于这样的侧边栏效果相对而言比较简单，我并没有用代码进行详细的讲解；后面的两个侧边栏效果我会结合代码进行比较详细的说明。

样式二：




首先，我们来分析程序的架构模式。如下图：




同样的道理，SliderViewController和CenterViewController均是ContainerViewController的子控制器。不同的是先将SliderViewController的View添加到ContainerViewController的View上面，再将CenterViewController的View添加到ContainerViewController的View上面，然后在点击白色按钮或者手势拖拽的时候，SliderViewController的View逐渐变大并且向左移动，直到某个位置的时候，SliderViewController的View
 "满高度"显示(即SliderViewController的View的高度等于屏幕的高度)，而CenterViewController的x进行一定距离的移动。
根控制器ContainerViewController 代码分析：
1. ViewDidLoad进行初始化工作，代码如下：
- (void)viewDidLoad {
    [super viewDidLoad];
    
    CGFloat screenWidth = [UIScreen mainScreen].bounds.size.width;
    CGFloat screenHeight = [UIScreen mainScreen].bounds.size.height;
    
    // Slide VC
    self.slideMenuVC = [[SlideMenuViewController alloc] init];
    self.slideMenuVC.view.frame = CGRectMake(0, 0, kSliderViewWidth, screenHeight);
    self.cover = [[UIView alloc] init];
    self.cover.frame = self.slideMenuVC.view.bounds;
    self.cover.backgroundColor = [UIColor blackColor];
    self.cover.alpha = kDefaultCoverAlpha;
    [self.slideMenuVC.view addSubview:self.cover];
    
    [self addChildViewController:self.slideMenuVC];
    [self.view addSubview:self.slideMenuVC.view];
    self.slideMenuVC.delegate = self;
    self.slideMenuVC.centerNavViewController = self.centerNavVC;
    CGAffineTransform scaleTransform = CGAffineTransformMakeScale(kDefaultScale, kDefaultScale);
    CGAffineTransform translationTransform = CGAffineTransformMakeTranslation(kDefaultTranslation, 0);
    self.slideMenuVC.view.transform = CGAffineTransformConcat(scaleTransform, translationTransform);
    
    // Center VC
    CenterViewController *centerVC = [[CenterViewController alloc] init];
    self.centerNavVC = [[UINavigationController alloc] initWithRootViewController:centerVC];
    self.centerNavVC.view.frame = CGRectMake(0, 0, screenWidth, screenHeight);
    [self addChildViewController:self.centerNavVC];
    [self.view addSubview:self.centerNavVC.view];

    // Gesture
    UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleGesture:)];
    [self.view addGestureRecognizer:panGesture];
}
代码的主要工作
1） 初始化SliderViewController和CenterViewController两个子控制器，并且将各自的View添加到父控制器的View中。
2） 定义手势方法，用来执行滑动手势。
代码中用了很多宏定义，清单如下：
#define kDefaultCoverAlpha 0.9
#define kDefaultScale 0.6
#define kDefaultTranslation 50
#define kSliderViewWidth 120kDefaultCoverAlpha 就是SliderViewController的View的遮罩层View的透明度；因为在手势滑动过程中，遮罩层的透明度会一直改变的，以达到阴影的效果。
kDefaultScale 和 kDefaultTranslation 分别是SliderViewController的View的初始状态下的缩放及平移大小。
下面三句代码就可以让SliderViewController的View初始状态时呈现为 "图三" 的状态：
CGAffineTransform scaleTransform = CGAffineTransformMakeScale(kDefaultScale, kDefaultScale);
CGAffineTransform translationTransform = CGAffineTransformMakeTranslation(kDefaultTranslation, 0);
self.slideMenuVC.view.transform = CGAffineTransformConcat(scaleTransform, translationTransform);kSliderViewWidth 就是SliderViewController的View “满高度” 显示在屏幕上面的时候的宽度。
2. 白色按钮点击事件的处理相关代码：
- (void)toggleSideMenu {
    CGFloat ratio = self.centerNavVC.view.x / kSliderViewWidth;
    BOOL isOpen = ratio == 1.0;
    CGFloat toggleProgress = isOpen ? 0.0 : 1.0;
    [UIView animateWithDuration:1 animations:^{
        [self setToPercent:toggleProgress];
    }];
}

- (void)setToPercent:(CGFloat)progress {
    self.centerNavVC.view.x = progress * kSliderViewWidth;
    
    CGFloat alpha = kDefaultCoverAlpha * (1 - progress);
    self.cover.alpha = alpha;
    CGFloat scale = kDefaultScale + (1 - kDefaultScale) * progress;
    CGAffineTransform scaleTransform = CGAffineTransformMakeScale(scale, scale);
    CGFloat translation = kDefaultTranslation * (1 - progress);
    CGAffineTransform translationTransform = CGAffineTransformMakeTranslation(translation, 0);
    self.slideMenuVC.view.transform = CGAffineTransformConcat(scaleTransform, translationTransform);
}
这里主要的代码就是平移和缩放的处理，由于和在ViewDidload中初始化的操作基本类似，只是最终状态有所不同，我就不加说明了。
3. 手势的相关代码：
- (void)handleGesture:(UIPanGestureRecognizer *)pan {
    
    if(pan.state == UIGestureRecognizerStateCancelled || pan.state == UIGestureRecognizerStateEnded){
        CGFloat formerX = self.centerNavVC.view.x;
        if(formerX > kSliderViewWidth * 0.5 && formerX <= kSliderViewWidth){
            formerX = kSliderViewWidth;
        } else{
            formerX = 0;
        }
        
        CGFloat progress = formerX / kSliderViewWidth;
        [UIView animateWithDuration:1 animations:^{
            [self setToPercent:progress];
        }];
        
        return;
    }
    
    if(pan.state == UIGestureRecognizerStateBegan){
        // 一定要将首次按下的起始点记录下来，作为参考点
        self.relativeX = self.centerNavVC.view.x;
    }
    
    CGPoint translation = [pan translationInView:pan.view];
    CGFloat actualX = self.relativeX + translation.x;
    if (actualX >= kSliderViewWidth) {
        actualX = kSliderViewWidth;
    }
    
    if (actualX <= 0) {
        actualX = 0;
    }
    
    CGFloat progress = actualX / kSliderViewWidth;
    [self setToPercent:progress];
}
1. 手势结束或者终止的时候，判断CenterViewController的View的x值，如果小于 0.5 * kSliderViewWidth，动画执行到x = 0 的位置； 反之，动画执行到x = kSliderViewWidth的位置。
2. 手势刚刚开始的时候，一定要记录下CenterViewController的View的x值, 因为后面的移动的操作都是相对于它的，如果想仔细观察，大家可以打印它的值看看。
3. 代码中actualX的值就是手指当前所在屏幕上面的实时的x值，并且限定了手势动画的范围为0到kSliderViewWidth。


样式三




功能分析：
1. 侧边栏有3D的透视效果。
2. 导航栏上面的白色按钮也会有旋转效果。
3. 点击侧边栏上面的Item，有收起侧边栏的动画。
注意：这里的架构模式为"图二"并不是"图一"。很多人也许会疑惑。看动画效果仿佛就是 "图一" 的设计。下面通过代码一一解释。

一、 侧边栏有3D的透视效果分析
根控制器ContainerViewController 代码分析：
1. ViewDidLoad进行初始化工作，代码如下：
- (void)viewDidLoad {
    [super viewDidLoad];
    
    CGFloat screenWidth = [UIScreen mainScreen].bounds.size.width;
    CGFloat screenHeight = [UIScreen mainScreen].bounds.size.height;
    
    // Center VC
    CenterViewController *centerVC = [[CenterViewController alloc] init];
    self.centerNavVC = [[UINavigationController alloc] initWithRootViewController:centerVC];
    self.centerNavVC.view.frame = CGRectMake(0, 0, screenWidth, screenHeight);
    [self addChildViewController:self.centerNavVC];
    [self.view addSubview:self.centerNavVC.view];
    
    // Slide VC
    self.slideMenuVC = [[SlideMenuViewController alloc] init];
    self.slideMenuVC.view.frame = CGRectMake(-kSliderViewWidth, 0, kSliderViewWidth, screenHeight);
    [self addChildViewController:self.slideMenuVC];
    [self.view addSubview:self.slideMenuVC.view];
    self.slideMenuVC.centerNavViewController = self.centerNavVC;

    UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleGesture:)];
    [self.view addGestureRecognizer:panGesture];
}
看起来和方式二的初始化代码很像，只是注意到SliderViewController的View的层次关系是在CenterViewController的View的前面的，并且它的View的x初始值是 -kSliderViewWidth。
我这里定义的kSliderViewWidth的宏如下面：
#define kSliderViewWidth 1202. 手势的代码直接复用方式二的代码，只是手势中调用的setToPercent: 方法有所改变。
- (void)setToPercent:(CGFloat)progress {
    self.slideMenuVC.view.layer.transform = [self menuTransformForPercent:progress];
    self.coverView.alpha = 1 - progress;
    [self.slideMenuVC.view addSubview:self.coverView];
    self.centerNavVC.view.x = progress * kSliderViewWidth;
}
方法中的最后一句代码依旧是CenterViewController的View的拖拽效果。第2，3句代码是为了调节遮罩的程度。SliderViewController的View显示出来的越多，遮罩程度越轻；显示出来的越少，遮罩程度越重；下面的代码就是coverView的懒加载：
- (UIView *)coverView {
    if (!_coverView) {
        _coverView = [[UIView alloc] init];
        _coverView.userInteractionEnabled = NO;
        _coverView.frame = self.slideMenuVC.view.bounds;
        _coverView.backgroundColor = [UIColor blackColor];
    }
    return _coverView;
}setToPercent: 代码的第一句就是透视动画执行的关键部分。而且这个效果只作用于SliderViewController的View上面，由于是3D动画，所以transform变换是layer的操作。具体调用的menuTransformForPercent: 方法实现如下：
- (CATransform3D)menuTransformForPercent:(CGFloat)percent {
    CATransform3D identity = CATransform3DIdentity;
    identity.m34 = -1.0 / 1000;
    
    CGFloat remainingPercent = 1.0 - percent;
    CGFloat angle = remainingPercent * (-M_PI_2); 
    
    CATransform3D rotationTransform = CATransform3DRotate(identity, angle, 0, 1, 0);
    CATransform3D translationTransform = CATransform3DMakeTranslation(percent * kSliderViewWidth, 0, 0);
    return CATransform3DConcat(rotationTransform, translationTransform);
}
代码中使用了单位矩阵的m34属性，关于这个属性不明白的，请参照《CATransform3D 特效详解》。简言之，透视效果就是依据
 "近大远小" 这一视觉特性，使人感觉空间是3D的呈现效果。而SliderViewController的View不但有旋转动画，也有平移动画。旋转的角度是90°，平移的大小是kSliderViewWidth。而且这两个动画是同时执行的，所以使用CATransform3DConcat将两个动画"合并"起来。注意代码中，旋转角度的初始值是 -M_PI_2, 即它是垂直面向我们的，也就是看不见 (Just Imagine)。
讲解了这么多，我们现在看看手势操作之后的效果。




 但是大家注意到：这里是3D旋转效果，而不是2D平移。3D的旋转必须考虑到旋转轴(就是应该绕着哪里进行旋转)。在执行手势操作的时候，两个View之间会出现间隙，并且间隙距离有时候大，有时候小。导致出现这种现象的原因就是SliderViewController的View所绕的旋转轴不正确。默认情况，View所绕着的旋转轴是正中心的垂直轴，因为他们的锚点是(0.5, 0.5)。 但如果想旋转的时候，想让SliderViewController的View右边一直紧挨着
 CenterViewController的View的左边，应该设置旋转轴是SliderViewController的View的右边，即改变它的锚点为(1, 0.5) 即可。转换效果图如下：


所以在ViewDidload代码中，加入下面一句代码：

self.slideMenuVC.view.layer.anchorPoint = CGPointMake(1, 0.5);我们再看看运行效果：



此时，虽然两者之间有空白的间隙，但是注意到不管怎么移动，两只之间的空隙的距离是保持一致的，也就是说设置锚点值为(1, 0.5) 是起作用的，让其绕着右边进行旋转。而这个空白间隙，我们很容易想象到，是因为没有设置position造成的。所以在ViewDidload代码中加入下面的代码，一切就OK了。
self.slideMenuVC.view.layer.position = CGPointMake(0, screenHeight * 0.5);


3. 消除锯齿现象
注意到，在慢速拖拽的时候，可以看到SliderViewController中的View的各个Item交界处有一些锯齿现象。大图如下：

这个时候，我们可以进行光栅化处理。
Core Animation 在动画过程中，会连续重绘View上面的所有内容并且不停的计算所有移动元素的透视大小等。而光栅化处理，会告诉Core Animation缓存layer的所有内容为一个Image，然后执行的动画效果其实是在处理这个缓存的Image，不需要进行View的重绘工作了。这样处理：1. 提高了动画执行的效率；2. 消除了锯齿现象。
所以我们可以在UIGestureRecognizerStateBegan手势开始的代码中，加入下面两句，防止锯齿现象。
self.slideMenuVC.view.layer.shouldRasterize = YES;
self.slideMenuVC.view.layer.rasterizationScale = [UIScreen mainScreen].scale;当然，缓存成图片也是一个很耗内存的操作，所以，我们应该在动画结束之后，立刻取消光栅化，释放内存。所以在手势Cancel或者End的时候，加入以下代码：
self.slideMenuVC.view.layer.shouldRasterize = NO;
二、 导航栏上面的白色按钮也会有旋转效果
大家注意到：导航控制器上面的白色按钮的动画，有一种旋转的现象，但又不是普通的绕着x或者y轴的旋转。因为它是绕着x，y轴的斜线方向上面的旋转。

旋转完180°之后，这个横条就会变成竖条（Just Imagine）。
但由于这个按钮是导航控制器的leftBarButtonItem，是导航控制器的一部分；当你进行3D旋转的时候，会改变导航控制器上面本来UI元素的层级关系，所以当按钮旋转到导航栏Title的后面的时候，Title显示，当旋转到导航栏Title的前面的时候，Title会被遮挡；因为在旋转过程中，Title会一直闪烁。解决的办法就是旋转button自己内容的imageView而不是button本身。因为button是相对于导航栏的，而button中的imageView是相对于button的，imageView的旋转不会影响到导航栏本身。所以在setToPercent:
 中追加以下代码可以完成旋转工作。
CenterViewController *centerVC = [self.centerNavVC.childViewControllers firstObject];
UIButton *toggleButton = centerVC.flipButton;
// 不能直接旋转Button，因为它是导航条的一部分，会影响title的显示
toggleButton.imageView.layer.transform = CATransform3DMakeRotation(progress * M_PI, 1, 1, 0);最终旋转的流程图如下：



三、 点击侧边栏上面的Item，有收起侧边栏的动画
这个操作就非常简单了，可以使用block或者代理来完成。我是使用代理来实现的。
1. 在SliderViewController中定义代理quickView代理，并且在点击侧边栏每一项的时候调用代理方法。代码如下：
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    NSArray *items = [MenuItemsHelper sharedMenuItems].items;
    MenuItem *item = items[indexPath.row];
    CenterViewController *centerVC = [self.centerNavViewController.childViewControllers firstObject];
    centerVC.item = item;
    if ([self.delegate respondsToSelector:@selector(quickView:)]) {
        [self.delegate quickView:self];
    }
}
2. ContainerViewController成为代理并且实现代理方法。
self.slideMenuVC.delegate = self;- (void)quickView:(SlideMenuViewController *)slideMenuVC {
    [self toggleSideMenu];
}- (void)toggleSideMenu {
    CGFloat ratio = self.centerNavVC.view.x / kSliderViewWidth;
    BOOL isOpen = ratio == 1.0;
    CGFloat toggleProgress = isOpen ? 0.0 : 1.0;
    [UIView animateWithDuration:0.25 animations:^{
        [self setToPercent:toggleProgress];
    } completion:^(BOOL finished) {
        if (isOpen) {
            [self.coverView removeFromSuperview];
        }
    }];
}
至此，整个的侧边栏动画效果就算总结完毕了。

版权声明：本文为博主原创文章，未经博主允许不得转载。

关于 阿里巴巴笔试题 ：投资保险的 建议
/**
 * 
 * @author xy1131975903
 * 1)应该将保险类设计为资源共享，即设计一个同步方法用于控制用户的投资；判断是否投资成功；
 * 2)应将投资者设计为多线程类，即实现Runnable接口，可以竞争投资；
 * 3)需要在投资者中体现，竞争投资资源(保险类)的属性，即可以设计保险类为其成员变量；
 *   这样就可以体现多个用户竞争投资资源的实现。
 *
 */
class Insurance{
	private double yield=0.18;
	private int totalAmount=200000;
	private int minInvestment=1000;
	public int abAmount=0;
	private int count=0;
	public Insurance(){};
	
	public synchronized boolean buySuccess(int funds,String userID){
		boolean isSuccess=false;
		count++;
		System.out.println("投资： "+funds+"  ; 目前剩余：  "+(totalAmount-abAmount));
		if(funds%minInvestment==0 && funds<=totalAmount-abAmount){
			abAmount+=funds;
			System.out.println("第"+count+"个用户 ("+userID+") success!");
			isSuccess=true;
		}else{
			System.out.println("第"+count+"个用户 ("+userID+") failed!");
		}
		System.out.println();
		return isSuccess;
	}
	
}
class User implements Runnable{
	private String userID=null;
	private int funds=0;
	private Insurance mInsurance=null;
	public boolean isSuccess=false;
	
	public boolean isRun=false;
	
	public User(String userID,int funds,Insurance mInsurance){
		this.userID=userID;
		this.mInsurance=mInsurance;
		this.funds=funds;
	}
	@Override
	public void run() {
		// TODO 自动生成的方法存根
		isSuccess=mInsurance.buySuccess(funds,userID);
		isRun=true;
	}
	public String getUserId(){return userID;}
	public int getFunds(){return funds;}
	
}
class TestInsuracne{
	public void test(){
		Insurance mInsurance=new Insurance();
		List<User>mList=new ArrayList<User>();
		User mUser[]=new User[20];
		Thread mt[]=new Thread[20];
		int i=0,sleeptime=0;
		for(i=0;i<mUser.length;i++){
			String str="userID_"+(i+1);
			mUser[i]=new User(str, (i+1)*1000, mInsurance);
			mt[i]=new Thread(mUser[i]);
			sleeptime=(int)Math.random()*5000;
			start(sleeptime, mt[i]);
		}
		
		//boolean exitFlag=false;
		while(true){
			for(i=0;i<mUser.length;i++){
				if(!mUser[i].isRun)break;
			}
			if(i==mUser.length)break;
		}
		System.out.println("详细数据如下:");
		for(i=0;i<mUser.length;i++){
			if(mUser[i].isSuccess){
				mList.add(mUser[i]);
			}
		}
		User tempUser=null;
		for(i=0;i<mList.size();i++){
			tempUser=(User)mList.get(i);
			System.out.println(tempUser.getUserId()+": "+tempUser.getFunds());
		}
	}
	public void start(int sleepTime,Thread mt){
		try {
			Thread.sleep(sleepTime);
			mt.start();
		} catch (InterruptedException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
		}
	}
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Studio 常用快捷键
常用的 Android Studio 快捷键:
Ctrl+N:查找类


Ctrl+Shift+N:查找文件


Ctrl+Alt+L :格式化代码


Ctrl+Alt+O:优化导入的类和包


Ctrl+/:注释代码 格式：//代码块


Ctrl+Shift+/:注释多行代码 格式:/*代码块*/


Ctrl+Alt+Space(空格):自动补全代码


Ctrl+空格:代码感应提示


Ctrl+Alt+Space:类名和接口名提示


Ctrl+Shift+Alt+N:查找类中的方法和变量


Ctrl+Shift+C:对比最近修改的代码


Ctrl+Alt+Left/Right:返回至上次浏览的位置


Ctrl+[或]：可以调到大括号的开头结尾


Ctrl+Shift+Backspace:可以跳转到上次编辑的地方


Ctrl+F12:可以显示当前文件的结构


Ctrl+ALt+V:可以引入变量。例如把括号内的sql赋成一个变量


Ctrl+F7：可以查询当前元素在当前文件中的引用，然后按F3可以选择


Ctrl+Alt+T：可以把代码包在一块内，例如try/catch


Ctrl+J:自动代码


Ctrl+R:替换文本


Ctrl+E:最近打开的文件


Ctrl+H:显示类结构图


Ctrl+F:查找文本


Ctrl+P:提示方法的参数信息


Ctrl+Q:光标选中方法显示该方法的详细参数信息


Ctrl+X:删除行


Ctrl+D:复制行


Shift+F6:类重命名


Shift+Alt+向上箭头：代码往上移


Shift+Alt+向下箭头：代码往下移


Alt+Insert:快速生成构造方法或是GET,SET方法


Alt+Enter:感应代码提示 例如方法转型


Alt+回车：导入包，自动修正


Alt+F1:查找代码所在的位置


Alt+l:快速打开或隐藏工程面板


Alt+Left/Right:切换代码视图


Alt+Up/Down:在方法间快速移动定位


F2或Shift+F2:在高亮错误或警告快速定位


Alt+Shift+K ：注释类说明<这里需自己设置：Settings–>点击Keymap–>在右边右上角搜索Other(fix doc comment)–>看到Fix doc comment 鼠标右键选择第一个，在输入框First Stroke输入ALT+SHIFT+K


创建类注释模板:setting–>Editor–>File and Code Templates –>Includes–>File Header







手动加入v7包:
鼠标放在工程目录右键-OpenModuleSetting-Dependenices点击加号






AndroidStudio Debug模式快捷键:
alt+f8 debug时选中查看值


f8相当于eclipse的f6跳到下一步


shift+f8相当于eclipse的f8跳到下一个断点，也相当于eclipse的f7跳出函数


f7相当于eclipse的f5就是进入到代码


alt+shift+f7这个是强制进入代码


ctrl+shift+f9 debug运行java类


ctrl+shift+f10正常运行java类


command+f2停止运行
﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。

适配iPhone6和6P UITableView分割线会闪动（拖动UITableView的时候，分割线 一会儿变粗一会儿变细）解决办法
出现这种状况发现 是因为 没有加 lanch image的问题，xcode 里没有发现 @3x的启动图，会默认为你没有 适配iphone6，所以给你拉伸了。
解决办法：
Launch Images Source(LIS)和Launch Screen File(LSF)二选一，如果是LIS,那么里面要有@3x这样的命名方式（我测试是Default-i6@2x.png和Default-i6@3x.png，其他图可以不加，保留最高分辨为@2x），完美适配6/6+


版权声明：本文为博主原创文章，未经博主允许不得转载。

(iOS)使用auto layout进行复杂布局时，UILabel的相关trick
本文首发于CSDN：http://blog.csdn.net/madongchunqiu/article/details/47960745。若作者没有回复，请email至：madongchunqiu@gmail.com


给心急的同学先说说结论：（因为我也是一个心急的同学）
1. 对于UILabel，设置number of lines相当于设置了一个纵向的constraint；也即意味着，UILabel设置三个constraint就够了
2. 对于UILabel，横向设置一个"<="的constraint，可以让UILabel自行适配宽度
3. 文章结尾有测试题哦，喜欢挑战的同学请往后看


一。正文：
先来一段情怀。
第一个项目是纯手码的，MRC，且几乎没有使用第三方库。整天乐呵呵的在纸上计算布局的坐标，各种大小都是根据比例实时计算的。缺点显而易见，布局的代码太多，把逻辑部分的代码都挤没了；好处是，我感觉超可控，几乎没有意料外的bug，也不会怕苹果更新版本影响到app的使用。（注：最新的版本使用storyboard进行界面切换，大多数布局还是手码的）
第二个项目过于庞大，我使用了Storyboard+auto layout，ARC，数个4位数Star且维护活跃的第三方库。设计师对UI的控制超精细，auto layout真正让我从界面布局中解放出来了。不过从最开始机械的使用“横向两个constraint+纵向两个constraint”，到现在主要使用“UITableView+FDTemplateLayoutCell”(https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)进行tableviewcell的布局，还是有些值得讨论和学习的地方。




二。讨论对象：
以下均假设场景为使用UITableViewCell进行布局，UITableViewCell内有数个Label/Image/Button等复杂排版。一般而言，Image和Button的大小不变或者和Cell保持比例关系，比较容易处理；而Label则可能由于文字的长短，字体大小的变化，导致宽度和高度上的变化，带来计算上的麻烦。
另外，本文针对实战，对其中的原理部分并未涉及，我觉得下面这篇文章写的不错，若想深入了解可以一读：深入理解Auto Layout 第一弹(http://zhangbuhuai.com/2015/07/16/beginning-auto-layout-part-1/)




三。设置方法
（以下两个方法各有运用场景）


1：基本款
采用“横向两个constraint+纵向两个constraint”的方法，精确到point的控制每个界面元素的位置和大小。如下图：


上图为Label设置了Top, Left, Righ和Height4个属性，即可完全控制Label的大小。


但，若Label中需要显示的内容可能占用多行，则可以将number of lines设置为0（有时标题最多显示两排时，则可设置为2），然后将Height这个constraint牵出来作为IB Outlet，则可以在程序中随时修改，如下图：




由于文字长短和cell的宽度均会影响Label的布局，从而决定cell的高度，因此heightForRowAtIndexPath:的返回值需要通过计算得到。因此此cell会实现两个函数：

+ (CGFloat)cellHeightWithData:(MDDataType*)data withCellWidth:(CGFloat)cellWidth;
- (void)updateWithData:(MDDataType*)data withCellWidth:(CGFloat)cellWidth;

前者class method由heightForRowAtIndexPath:调用，避免实例化cell。其中调用

[data.text boundingRectWithSize:CGSizeMake(cellWidth-margin, MAXFLOAT) 
    options:NSStringDrawingUsesLineFragmentOrigin 
    attributes:@{NSFontAttributeName:label.font} 
    context:nil].size.height

来计算label的高度，然后合成整个cell的高度


后者instance method由cellForRowAtIndexPath:调用，实例化cell中的各个控件参数，然后将上面代码的计算结果赋值给constraint的IB
 Outlet.


优点：计算快捷效率高，控制精准。
缺点：IB中设置的gap，margin等数值需要和cellHeightWithData此函数中使用的hardcode数值保持一致，一个数据两方维护，简直不能忍。另：若Label的字体大小变化，则可能需要重新设置，不方便。




2. 自适应款
利用constraint中的"ratio","multiply",">=","<="等设置，完成auto layout的自动布局。


这个设置是在前面的设置中，删掉了Height这个constraint，这个时候，可以理解为number of lines充当了第四个constraint，从而可以让auto layout进行布局。果不其然，auto layout提示说该布局和运行后不符（运行后被auto layout到正确的位置了）。这个warning一方面告诉我们说auto layout可以正确handle这个label，另一方面告诉我们应该用"Update Frame"这个方法将Label摆放正确。


另一种情况，某些label可能无法占满整个横向区域，其后可能会有别的控件，可以设置"<="constraint，使其进行自动布局，如图：


自适应布局，加上前面提到的“UITableView+FDTemplateLayoutCell”(https://github.com/forkingdog/UITableView-FDTemplateLayoutCell)，所有关于布局之类的margin，gap等等，就只用在IB中搞定了。几乎没必要牵出constraint作为outlet来手动设置了。并且cell所需要实现的函数仅为：

- (void)updateWithData:(MDDataType*)data;
在heightForRowAtIndexPath:和cellForRowAtIndexPath:中均调用此函数即可。【具体请参考UITableView+FDTemplateLayoutCell的文档和源代码】

优点：布局全部在IB中，代码中几乎可以不用管
缺点：由于heightForRowAtIndexPath中需要实例化cell，且进行布局计算，因此效率会稍低（当然，会有些优化方法）


四。使用场景
(以下标题均描述uitableview中各个cell的布局难度)


A. 均一高度
hardcode吧，多好啊


(截图自：网易新闻)


B. 易算高度
比如高度和宽度比例为16:9，使用class method进行计算吧，多好啊。

+ (CGFloat)cellHeightWithData:(MDDataType*)data withCellWidth:(CGFloat)cellWidth;

（截图自：美团）


C. 复杂布局+不需要考虑效率
使用UITableView+FDTemplateLayoutCell吧
（无图）


D. 复杂布局+效率优先
需要特殊情况特殊对待
（无图）




五。习题
i) 习题一：某个列表由tableview实现，每个cell都有很多信息，其中Title可长可短，短的显示一行，长的最多显示两行。标题旁显示Date，有如下四种情况：
情况1：标题占一行，且可以在右侧放置日期，则标题和日期放置在同一行
|---------------------------------------------|
| Title Short                            Date |
|                   (Others)                  |


情况2：标题占一行，但第一行容纳不下日期，日期放在第二行


|---------------------------------------------|
| Title Ratherrrrrrrrrrrrrrrrrrrrrrrrr Long   |
|                                        Date |
|                   (Others)                  |




情况3：标题占两行，第二行可以在右侧防止日期，则日期放置在第二行

|---------------------------------------------|
| Title Verrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr |
| rrrrrrrrrrrrrrrry Long                 Date |
|                    (Others)                 |


情况4：标题占两行，但第二行容纳不下日期，则日期放在第二行，标题Trunk Tail，显示"..."

|---------------------------------------------|
| Title Terrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr |
| rrrrrrrrrrrrrrrrrrrrrrrrrrrriblely ... Date |
|                    (Others)                 |




ii) 习题二：某个列表中的tableviewcell中含有“全占式”大标题，即无论标题是啥，都要横向占满整个屏幕宽度，如下




|-------------------------------------|
|                 II                 |

|                 III                 |
|    IIIIIIIIIIIIIIIIIIIIIIIIIIIIII   |
|               III III               |

|             III     III             |
|           III         III           |
|        III              IIII        |

|      II                   IIIII     |
|    I                         IIIIII |
|              (Others)               |
或者

|-------------------------------------|

|         II                 II       |
|         II                 II       |
|    III  II  III       III  II  III  |
|  III    II   III    III    II   III |
|        VII                VII       |
|             (Others)                |




iii) 更多习题...



版权声明：本文为博主原创文章，未经博主允许不得转载。

NSString [a compare:b]   NSOrderedSame NSOrderedAscending NSOrderedDescending字符串比较
NSString 两个字符串的比较，用 a compare:b 来比，得出的结果分3种  

26个字母比较  越靠后面  越大 
NSString *a = @”qweqwe”; 
NSString *b = @”qweasd”; 
BOOL result = [a compare:b]; 
if (result == NSOrderedSame) {          // NSOrderedSame = 0 完全一样 
    NSLog(@”a = b”); 
}else if(result == NSOrderedAscending)  // NSOrderedAscending = -1 
    NSLog(@”a < b”); 
else{                                   //NSOrderedDescending = +1 
    NSLog(@”a > b”); 
}
2011-07-05 15:04:33.951 Q[5180:207] a > b

2.比较数字或者符号，或者字母 什么都行
NSString *a = @”1.0.30qweqwe”; 
    NSString *b = @”1.0.45qweasd”; 
    BOOL result = [a compare:b]; 
    if (result == NSOrderedSame) {          // NSOrderedSame = 0 完全一样 
        NSLog(@”a = b”); 
    }else if(result == NSOrderedAscending)  // NSOrderedAscending = -1 
        NSLog(@”a < b”); 
    else{                                   //NSOrderedDescending = +1 
        NSLog(@”a > b”); 
    }
2011-07-05 15:05:13.175 Q[5209:207] a < b
3.不考虑大小写比较字符串  
[a caseInsensitiveCompare:b]

(void)viewDidLoad 
{ 
NSString *a = @”i love my boyfriend.”; 
NSString *b = @”I Love My Boyfriend.”; 
NSLog(@” \n a:  %@ \n”,a); 
NSLog(@” \n b:  %@ \n”,a); 
BOOL result = [a caseInsensitiveCompare:b] ==  NSOrderedSame; 
｝ 
// result = (BOOL) YES;

4.不考虑大小写比较字符串  
[a caseInsensitiveCompare:b]

(void)viewDidLoad 
{ 
NSString *a = @”i love my boyfriend.”; 
NSString *b = @”Little baby.”; 
NSLog(@” \n a:  %@ \n”,a); 
NSLog(@” \n b:  %@ \n”,a); 
BOOL result = [a caseInsensitiveCompare:b] ==  NSOrderedAscending; 
} 
//result = (BOOL) YES;
有选择的比较大小   [a compare:b options:NSCaseInsensitiveSearch|NSNumericSearch]
(void)viewDidLoad 
{ 
NSString *a = @”i love my boyfriend.”; 
NSString *b = @”I Love My Boyfriend.”; 
NSLog(@” \n a:  %@ \n”,a); 
NSLog(@” \n b:  %@ \n”,b); 
BOOL result = [a compare:b options:NSCaseInsensitiveSearch|NSNumericSearch] ==  NSOrderedSame; 
} 
//result = (BOOL)YES; 
NSCaseInsensitiveSearch  忽略大小写的比较字符串 
NSNumericSearch       比较字符串的个数 
NSLiteralSearch       区分大小写，进行完全比较


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Studio奇技淫巧一览 大幅度提升工作效率
（1）代码提示不区分大小写 

（2） 常用插件 

（3）Android偏生而非常有用的快捷键（mac版） 
alt＋command ＋m 提取代码块为单独的方法体 
alt＋command＋f 提升变量为类成员变量 
shift＋command＋delete 光标跳转到上一个光标位置 
alt+command＋左／右 光标跳转到上一个或下一个光标位置 
shift＋command＋左／右 选中光标在当前行左右的代码 
shift＋command＋［／］打开视图左右切换 
fn + F3 代码行添加或取消标签 
shift+cmd+上／下 将光标放至方法末尾 上下移动当前整个函数块
（4）大招： 大幅度提升编码效率 command＋j试试 
so cool 还有更cool的 自定义代码块 

（5）使类中的相关方法尽可能的按照深度或广度靠近 

（6）设置生成注释快捷键 

（7）编辑类默认注释模版 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Visual Studio Enterprise 2015 安装中的注意事项
Visual Studio Enterprise 2015 安装中，选择全部安装，会安装部署Android SDK相关工具，但是对于SDK的下载需要从google下载，由于被墙了，所以会有以下报错。解决方式是：如下，选择一个具有android SDK的国内镜像，或翻墙下载。如下图

版权声明：本文为博主原创文章，未经博主允许不得转载。

【cocos2d-x 3.7 飞机大战】 决战南海I (八) 背景移动
        采用双层背景，这样效果更好


.h

class BackgroundMove : public Layer
{
public:
	BackgroundMove();
	~BackgroundMove();
	virtual bool init();
	virtual void onEnterTransitionDidFinish();	//等进入场景之后在进行背景的移动
	CREATE_FUNC(BackgroundMove);

public:
	void move(float dt);
private:
	Sprite* m_background1;
	Sprite* m_background2;
	Sprite* m_background3;
	Sprite* m_background4;

	enum 
	{
		OFFSET = 3
	};
};


背景无限滚动的方式有很多，只要不出现黑边即可
.cpp

BackgroundMove::BackgroundMove() : m_background1(NULL), m_background2(NULL), m_background3(NULL), m_background4(NULL)
{

}
BackgroundMove::~BackgroundMove()
{
	CC_SAFE_DELETE(m_background1);
	CC_SAFE_DELETE(m_background2);
	CC_SAFE_DELETE(m_background3);
	CC_SAFE_DELETE(m_background4);
}
bool BackgroundMove::init()
{
	bool bRect = false;

	do 
	{
		if (!Layer::init())
			return false;

		//加载背景图片
		m_background1 = Sprite::createWithSpriteFrameName("backgroundTollgate2.png");
		m_background1->setPosition(Point(0,0));
		m_background1->setAnchorPoint(Vec2(0, 0));

		this->addChild(m_background1,1);

		m_background2 = Sprite::createWithSpriteFrameName("backgroundTollgate2.png");
		m_background2->setPosition(Point(0, 0));
		m_background2->setAnchorPoint(Vec2(0, 0));
		m_background2->setFlipY(true);

		this->addChild(m_background2,1);

		//加载背景图片
		m_background3 = Sprite::createWithSpriteFrameName("backgroundTollgateThree.png");
		m_background3->setPosition(Point(0, 0));
		m_background3->setAnchorPoint(Vec2(0, 0));

		this->addChild(m_background3, 0);

		m_background4 = Sprite::createWithSpriteFrameName("backgroundTollgateThree.png");
		m_background4->setPosition(Point(0, 0));
		m_background4->setAnchorPoint(Vec2(0, 0));
		m_background4->setFlipY(true);

		this->addChild(m_background4, 0);

		CocosDenshion::SimpleAudioEngine::getInstance()->playBackgroundMusic("sound/BackgroundMusic.mp3", true);

		bRect = true;
	} while (0);

	return bRect;
}
void BackgroundMove::onEnterTransitionDidFinish()
{
	Layer::onEnterTransitionDidFinish();
	this->schedule(SEL_SCHEDULE(&BackgroundMove::move), 0.01f);
}

void BackgroundMove::move(float dt)
{
	Vec2 origin = Director::getInstance()->getVisibleOrigin();

	m_background1->setPositionY(m_background1->getPositionY() - OFFSET);
	m_background2->setPositionY(m_background1->getPositionY() + m_background1->getContentSize().height);
	if (m_background2->getPositionY() <= origin.y)
		m_background1->setPositionY(0);

	m_background3->setPositionY(m_background3->getPositionY() + OFFSET);
	m_background4->setPositionY(m_background3->getPositionY() - m_background3->getContentSize().height);
	if (m_background4->getPositionY() >= origin.y)
		m_background3->setPositionY(0);

}







版权声明：本文为博主原创文章，未经博主允许不得转载。

Eclipse中将一个android项目当做另外一个android项目的library
1.右击将要被当做library的项目—>Properties里面—>Android—>给Is Library前面的checkbox打上勾—>点击Apply—>点击OK

2.右击需要library的项目—>Properties—>Android—>点击Add—>弹出对话框选择library点击OK—>点击Apply—>点击OK
将上一个项目作为library添加进来后，会发现在该项目Android Dependencies这个library下会多出一个jar包，这样就能识别了

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请标明出处。

Android 仿微信联系人Demo

项目结构

activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical" >

    <FrameLayout
        android:layout_width="fill_parent"
        android:layout_height="fill_parent" >

        <ListView
            android:id="@+id/country_lvcountry"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent"
            android:layout_gravity="center"
            android:divider="@null" />

        <TextView
            android:id="@+id/dialog"
            android:layout_width="80.0dip"
            android:layout_height="80.0dip"
            android:layout_gravity="center"
            android:background="@drawable/corner_list_single_pressed"
            android:gravity="center"
            android:textColor="#ffffffff"
            android:textSize="30.0dip"
            android:visibility="invisible" />

        <com.example.contactdemo.SideBar
            android:id="@+id/sidrbar"
            android:layout_width="30.0dip"
            android:layout_height="fill_parent"
            android:layout_gravity="right|center" />
    </FrameLayout>

</LinearLayout>
item.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:gravity="center_vertical"
    android:orientation="vertical" >

    <TextView
        android:id="@+id/catalog"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent"
        android:layout_weight="1.0"
        android:background="#E0E0E0"
        android:paddingBottom="5dip"
        android:paddingLeft="5dip"
        android:paddingTop="5dip"
        android:text="A"
        android:textColor="#454545" />

    <TextView
        android:id="@+id/title"
        android:layout_width="fill_parent"
        android:layout_height="fill_parent"
        android:layout_gravity="center_vertical"
        android:layout_marginLeft="5dip"
        android:layout_weight="1.0"
        android:gravity="center_vertical"
        android:paddingBottom="10dip"
        android:paddingTop="10dip"
        android:text="hhhh"
        android:textColor="#336598" />

</LinearLayout>
SideBar.java
package com.example.contactdemo;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Typeface;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.widget.TextView;

public class SideBar extends View {

    private TextView textDialog;
    private OnSelectChangeListener changeListener;

    // 26个字母
    public static String[] b = { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y",
            "Z", "#" };
    private int choose = -1;// 选中
    private Paint paint = new Paint();

    public SideBar(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public SideBar(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public SideBar(Context context) {
        super(context);
    }

    public void setTextView(TextView textView) {
        this.textDialog = textView;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        int width = getWidth();
        int height = getHeight();
        int singleHeight = height / b.length;
        for (int i = 0; i < b.length; i++) {
            paint.setColor(Color.rgb(33, 65, 98));
            paint.setTypeface(Typeface.DEFAULT_BOLD);
            paint.setAntiAlias(true);
            paint.setTextSize(20);
            // 选中状态
            if (i == choose) {
                paint.setColor(Color.parseColor("#3399ff"));
                paint.setFakeBoldText(true);
            }
            float x = width / 2 - paint.measureText(b[i]) / 2;
            float y = singleHeight * i + singleHeight;
            canvas.drawText(b[i], x, y, paint);
            paint.reset();
        }
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        int action = event.getAction();
        final float y = event.getY();// 点击y坐标
        int c = (int) (y / getHeight() * b.length);
        switch (action) {
        case MotionEvent.ACTION_UP:
            setBackgroundResource(R.color.alph);
            choose = -1;
            invalidate();
            if (textDialog != null)
                textDialog.setVisibility(View.INVISIBLE);
            break;

        default:
            setBackgroundColor(Color.parseColor("#28000000"));
            if (choose != c) {
                if (c >= 0 && c < b.length) {
                    if (changeListener != null)
                        changeListener.onSelectChange(b[c]);
                    if (textDialog != null) {
                        textDialog.setText(b[c]);
                        textDialog.setVisibility(View.VISIBLE);
                    }
                    choose = c;
                    invalidate();
                }
            }
            break;
        }
        return true;
    }

    public void setOnSelectChangeListener(OnSelectChangeListener listener) {
        this.changeListener = listener;
    }

    public interface OnSelectChangeListener {
        void onSelectChange(String letter);
    }
}

MyAdapter.java
package com.example.contactdemo;

import java.util.List;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.TextView;

public class MyAdapter extends BaseAdapter {

    private List<MyModel> list = null;
    private Context mContext;

    public MyAdapter(List<MyModel> list, Context mContext) {
        this.list = list;
        this.mContext = mContext;
    }

    public void updateListView(List<MyModel> list) {
        this.list = list;
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return this.list.size();
    }

    @Override
    public Object getItem(int position) {
        return list.get(position);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View view, ViewGroup parent) {
        ViewHolder viewHolder = null;
        final MyModel mContent = list.get(position);
        if (view == null) {
            viewHolder = new ViewHolder();
            view = LayoutInflater.from(mContext).inflate(R.layout.item, null);
            viewHolder.tvTitle = (TextView) view.findViewById(R.id.title);
            viewHolder.tvLetter = (TextView) view.findViewById(R.id.catalog);
            view.setTag(viewHolder);
        } else {
            viewHolder = (ViewHolder) view.getTag();
        }
        // 根据position获取分类的首字母的Char ASCII值
        int section = getAsciiForPosition(position);

        // 如果当前位置等于该分类首字母的Char的位置 ，则认为是第一次出现
        if (position == getPositionFroAscii(section)) {
            viewHolder.tvLetter.setVisibility(View.VISIBLE);
            viewHolder.tvLetter.setText(mContent.getSortLetters());
        } else {
            viewHolder.tvLetter.setVisibility(View.GONE);
        }
        viewHolder.tvTitle.setText(this.list.get(position).getName());
        return view;
    }

    /**
     * 根据位置转成首字母的ASCII
     * 
     * @param position
     * @return
     */
    public int getAsciiForPosition(int position) {
        int a = list.get(position).getSortLetters().charAt(0);
        return a;
    }

    /**
     * 根据字母的ASCII获取位置
     * 
     * @param ascii
     * @return
     */
    public int getPositionFroAscii(int ascii) {
        for (int i = 0; i < list.size(); i++) {
            String abc = list.get(i).getSortLetters();
            char firstChar = abc.toUpperCase().charAt(0);
            if (firstChar == ascii)
                return i;
        }
        return -1;
    }

    class ViewHolder {
        TextView tvLetter;
        TextView tvTitle;
    }
}

MainActivity.java
package com.example.contactdemo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import com.example.contactdemo.SideBar.OnSelectChangeListener;

import android.app.Activity;
import android.os.Bundle;
import android.widget.ListView;
import android.widget.TextView;

public class MainActivity extends Activity {

    private SideBar sideBar;
    private TextView dialog;
    private ListView sortListView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        sideBar = (SideBar) findViewById(R.id.sidrbar);
        dialog = (TextView) findViewById(R.id.dialog);
        sortListView = (ListView) findViewById(R.id.country_lvcountry);
        sideBar.setTextView(dialog);
        List<MyModel> datas = getDatas(getResources().getStringArray(R.array.data));
        Collections.sort(datas, new Comparator<MyModel>() {

            // -1代表o1里的某一个属性比o2的小 0代表等于 1代表大于
            @Override
            public int compare(MyModel o1, MyModel o2) {
                if (o1.getSortLetters().equals("#"))
                    return 1;
                else if (o2.getSortLetters().equals("#"))
                    return -1;
                else
                    return o1.getSortLetters().compareTo(o2.getSortLetters());
            }
        });
        final MyAdapter adapter = new MyAdapter(datas, this);
        sortListView.setAdapter(adapter);

        sideBar.setOnSelectChangeListener(new OnSelectChangeListener() {

            @Override
            public void onSelectChange(String letter) {
                int ascii = letter.charAt(0);
                int position = adapter.getPositionFroAscii(ascii);
                if(position!=-1)
                    sortListView.setSelection(position);
            }
        });
    }

    private List<MyModel> getDatas(String[] array) {
        List<MyModel> datas = new ArrayList<MyModel>();
        for (int i = 0; i < array.length; i++) {
            MyModel sortModel = new MyModel();
            sortModel.setName(array[i]);
            String abc = CharacterParser.getInstance().getSelling(array[i]);
            String sortString = abc.substring(0, 1).toUpperCase();
            // 正则表达式
            if (sortString.matches("[A-Z]")) {
                sortModel.setSortLetters(sortString);
            } else {
                sortModel.setSortLetters("#");
            }
            datas.add(sortModel);
        }
        return datas;
    }
}

源码下载

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

小米智能家居出生日期选择框的实现源码
运行效果:

源码下载:
点击打开链接


版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift 注释格式使用技巧小结
在之前的Xcode版本中使用注释插件 VVDocumenter 可以快速的根据上下文的环境生成相应的注释格式，但是该插件目前在 Xcode7 bate 版中并不太兼容，这就需要我们了解一下原生的注释格式怎么书写了，现总结以下自己使用的几种格式与大家共同交流。
Swift 中的普通注释与 Objective-C 中的一致，大概分为以下三种


// 单行注释

/ *  多行注释  */

/// 标记注释1 

/** 标记注释2 */

针对于 Swift 中函数的原生注释方法在此列举几个如下，使用好了可以让别人更容易读懂我们的代码功能以及具体的参数意义。

示例1：








示例2：





示例3：






示例4：








最后再补充两个标记注释，可以便利的标记函数列表，已便后续查找对应的函数







版权声明：本文为博主原创文章，未经博主允许不得转载。

IOS瀑布流通过UICollectionView控件实现
有些IOS项目会用的瀑布流功能，我们可以选择使用第三方库，也可以自己写一个，如果自己写此功能，可以使用UICollectionView控件进行展示，设置分为几列等。
具体代码如下：
#define screenHeight [[UIScreen mainScreen]bounds].size.height //屏幕高度
#define screenWidth [[UIScreen mainScreen]bounds].size.width   //屏幕宽度
#define colletionCell 3  //设置具体几列
@interface HomeViewController (){
    UICollectionView *collectionView;
    NSMutableArray  *hArr; //记录每个cell的高度
}

@end

@implementation HomeViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    hArr = [[NSMutableArray alloc] init];
    UICollectionViewFlowLayout *flowLayout=[[UICollectionViewFlowLayout alloc]init];
    [flowLayout setScrollDirection:UICollectionViewScrollDirectionVertical]; //设置横向还是竖向
    collectionView=[[UICollectionView alloc] initWithFrame:CGRectMake(0, 0, screenWidth ,screenHeight) collectionViewLayout:flowLayout];
    collectionView.dataSource=self;
    collectionView.delegate=self;
    [collectionView setBackgroundColor:[UIColor clearColor]];
    [collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@"UICollectionViewCell"];
    [self.view addSubview:collectionView];
}
#pragma mark -- UICollectionViewDataSource

//定义展示的UICollectionViewCell的个数
-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
    return 20; 
}

//定义展示的Section的个数
-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView
{
    return 1;
}

//每个UICollectionView展示的内容
-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString * CellIdentifier = @"UICollectionViewCell";
    UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:CellIdentifier forIndexPath:indexPath];
    
    cell.backgroundColor = [UIColor colorWithRed:((10 * indexPath.row) / 255.0) green:((20 * indexPath.row)/255.0) blue:((30 * indexPath.row)/255.0) alpha:1.0f];
    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 20, 20)];
    label.textColor = [UIColor redColor];
    label.text = [NSString stringWithFormat:@"%d",indexPath.row];
    //移除cell
    for (id subView in cell.contentView.subviews) {
        [subView removeFromSuperview];
    }
    NSInteger remainder=indexPath.row%colletionCell;
    NSInteger currentRow=indexPath.row/colletionCell;
    CGFloat   currentHeight=[hArr[indexPath.row] floatValue];
    
    CGFloat positonX=(screenWidth/colletionCell-8)*remainder+5*(remainder+1);
    CGFloat positionY=(currentRow+1)*5;
    for (NSInteger i=0; i<currentRow; i++) {
        NSInteger position=remainder+i*colletionCell;
        positionY+=[hArr[position] floatValue];
    }
    cell.frame = CGRectMake(positonX, positionY,screenWidth/colletionCell-8,currentHeight) ;//重新定义cell位置、宽高
    
    [cell.contentView addSubview:label];
    return cell;
}

#pragma mark --UICollectionViewDelegateFlowLayout

//定义每个Item 的大小
- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
    CGFloat height=100+(arc4random()%120);
    [hArr addObject:[NSString stringWithFormat:@"%f",height]];
    return  CGSizeMake(screenWidth/colletionCell-8, height);  //设置cell宽高
}

//定义每个UICollectionView 的 margin
-(UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section
{
    return UIEdgeInsetsMake(0,0, 0, 0);
}

#pragma mark --UICollectionViewDelegate

//UICollectionView被选中时调用的方法
-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath
{
    UICollectionViewCell * cell = (UICollectionViewCell *)[collectionView cellForItemAtIndexPath:indexPath];
    cell.backgroundColor = [UIColor greenColor];
}

//返回这个UICollectionView是否可以被选择
-(BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath
{
    return YES;
}



@end
实现结果：



版权声明：本文为博主原创文章，未经博主允许不得转载。

FilterImageView
这个很简单，勿喷！
效果如下： 
 
代码非常简单，但是我相信不是每个人都知道这个小知识点：
package com.helper.view.imageview;

import android.content.Context;
import android.graphics.Color;
import android.graphics.PorterDuff;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.ImageView;

/**
 * Created by deadline on 2015/8/17.
 * 当按下的时候会给ImageView添加一层蒙版
 */
public class FilterImageView extends ImageView {

    private int color;

    public FilterImageView(Context context) {
        this(context, null);
    }

    public FilterImageView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public FilterImageView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        initFilterImageView();

    }

    private void initFilterImageView() {
        color = Color.GRAY;
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                setColorFilter(color, PorterDuff.Mode.MULTIPLY);
                break;

            case MotionEvent.ACTION_UP:
                clearColorFilter();
                break;
        }
        return super.onTouchEvent(event);
    }


    public int getFilterColor() {
        return color;
    }

    public void setFilterColor(int color) {
        this.color = color;
    }

}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android  使用LeakCanary 检测内存泄露
LeakCanary 是 Android 和 Java 内存泄露检测框架，该框架是Square公司的一个开源库，项目地址 leakcanary 。
Android 开发中你是否频频遇到内存泄露而无奈无从解决。说不定哪天你不小心写的一行代码就导致了内存泄露。可以先看看这些问题导致的内存泄露 Android开发编码规范导致的内存泄露问题，而LeakCanary 则很直白得检测出了内存泄露并展示给我们。在使用它之前，我们来写一个例子。
本地广播，在开发中还是有一定的应用的，现在有这么一个需求，要求使用本地广播来实现，就是通过发送一个退出程序的本地广播，所有Activity接收到后就退出，这显然是需要一个基础的Activity，其他Activity继承它。为了方便，这里我们只使用一个Activity。
public class MainActivity extends AppCompatActivity {
    public final static String ACTION_EXIT_APP = "cn.edu.zafu.leakcanary.exit";
    private static LocalBroadcastManager mLocalBroadcatManager;
    private BroadcastReceiver mExitReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (action.equals(ACTION_EXIT_APP)) {
                Log.d("TAG", "exit from broadcast");
                finish();
            }
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        init();
    }

    private void init() {
        IntentFilter filter = new IntentFilter();
        filter.addAction(ACTION_EXIT_APP);
        filter.addCategory(Intent.CATEGORY_DEFAULT);
        getLocalBroadcastManager().registerReceiver(mExitReceiver, filter);
    }

    private  LocalBroadcastManager getLocalBroadcastManager() {
        if (mLocalBroadcatManager == null) {
            mLocalBroadcatManager = LocalBroadcastManager.getInstance(this);
        }
        return mLocalBroadcatManager;
    }

}
乍一看，是不是感觉写的很对啊，那你就不够细心了，这还是少量的代码，对于项目中日积月累的代码，内存泄露或许无处不在。我们使用LeakCanary 对我们的代码进行检测下，看看到底哪里发生了内存泄露，以及该如何解决。
使用方法也很简单，首先加入依赖
debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3.1'
releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'
从依赖中也是可以看出猫腻的。
然后在我们程序的Applictaion中进行安装，当然，不要忘记在清单文件中注册该Application。
public class App extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        LeakCanary.install(this);
    }
}
我说就这么简单你会信，好了，我们安装到手机上看看。安装完成后运行该软件，打开后退出该软件，这时候你发现桌面上多了一个Leaks的图标。

打开它后通知栏会有一个通知，通知你发生了内存泄露

然后在软件里你会看到内存泄露的跟踪信息。

点击下方的delete可以删除此条信息。
仔细一看，原来是我们的mLocalBroadcatManager发生了泄露，注册本地广播的时候，传入了this，系统内部保持了这个引用，当我们退出Activity时，这个引用还是指向我们的Activity，导致Activity回收失败。那么怎么解决了，既然退出的时候还持有引用，那么我们取消注册这个广播这个引用不就没了吗，重写onDestroy方法，进行取消注册。
@Override
protected void onDestroy() {
    super.onDestroy();
    getLocalBroadcastManager().unregisterReceiver(mExitReceiver);
}
重新运行一下，咦，你发现内存不再泄露了。该软件里不再提示内存泄露的跟踪信息了。

就是这么简单，如果想更进一步了解使用方法，比如检测Fragment有没有泄露。可以参考官方给的例子，并且内存泄露的跟踪信息也是可以上传到服务器的，更多内容，参考 leakcanary
源码下载

http://download.csdn.net/detail/sbsujjbcy/9048449


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

多线程GCD
多线程GCD
标签（空格分隔）： 网络多线程

GCD
GCD是苹果公司为多核的并行运算提出的解决方案，全称是Grand Central Dispatch，是牛逼的中枢调度器，GCD提供了非常多强大的函数，GCD会自动利用更多的CPU内核，会自动管理线程的生命周期。
GCD的使用步骤

定制任务：要做得事情
将任务添加到队列中 
GCD会自动将队列中的任务取出，放到对应的线程中执行
任务的取出遵循队列的FIFO原则：先进先出，后进后出

执行任务

同步方式执行任务：只能在当前线程中执行任务，不具备开启新线程的能力

`dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`
queue：队列
block：任务

用异步的方式执行任务：可以在新的线程中执行任务，具备开启新线程的能力

`dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`

其它

`dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);`
在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行,这个queue不能是全局的并发队列
队列类型

GCD的队列可以分为2大类型
并发队列（Concurrent Dispatch Queue） 
可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 
并发功能只有在异步（dispatch_async）函数下才有效
串行队列（Serial Dispatch Queue） 
让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）

并发队列

使用dispatch_queue_create函数创建队列

dispatch_queue_t
dispatch_queue_create(const char *label, // 队列名称 
dispatch_queue_attr_t attr); // 队列的类型

dispatch_queue_t queue = dispatch_queue_create("pjl.queue", DISPATCH_QUEUE_CONCURRENT);

GCD默认已经提供了全局的并发队列，供整个应用使用，可以无需手动创建

dispatch_queue_t dispatch_get_global_queue(
dispatch_queue_priority_t priority, // 队列的优先级
unsigned long flags); // 此参数暂时无用，用0即可

dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 

串行队列

使用dispatch_queue_create函数创建串行队列

dispatch_queue_t queue = dispatch_queue_create("com.520it.queue", DISPATCH_QUEUE_SERIAL); //后面一个参数也可以写NULL

使用主队列（主队列是GCD自带的一种特殊的串行队列，但是放在主队列的任务会放在主线程中执行） 
dispatch_queue_t queue = dispatch_get_main_queue(); 
-各种队列的执行效果 
 
使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列

线程间通信
dispatch_async(
dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行耗时的异步操作...
      dispatch_async(dispatch_get_main_queue(), ^{
        // 回到主线程，执行UI刷新操作
        });
});
延时执行
- 调用NSObject的方法
[self performSelector:@selector(run) withObject:nil afterDelay:2.0];
// 2秒后再调用self的run方法

使用GCD函数
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    // 2秒后执行这里的代码...
});

使用NSTimer
[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:NO];

一次性代码

使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次

static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    // 只执行1次的代码(这里面默认是线程安全的)
});
快速迭代

使用dispatch_apply函数能进行快速迭代遍历

dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index){
    // 执行10次代码，index顺序不确定
});
队列组

有这么1种需求
首先：分别异步执行2个耗时的操作
其次：等2个异步操作都执行完毕后，再回到主线程执行操作
如果想要快速高效地实现上述需求，可以考虑用队列组

dispatch_group_t group =  dispatch_group_create();
dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行1个耗时的异步操作
});
dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行1个耗时的异步操作
});
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    // 等前面的异步操作都执行完毕后，回到主线程...
});
单粒模式

可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问，从而方便地控制了实例个数，并节约系统资源

ARC中，单例模式的实现

在.m中保留一个全局的static的实例 
static id _instance;
重写allocWithZone:方法，在这里创建唯一的实例（注意线程安全）

+ (instancetype)allocWithZone:(struct _NSZone *)zone
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _instance = [super allocWithZone:zone];
    });
    return _instance;
}

提供1个类方法让外界访问唯一的实例

+ (instancetype)sharedInstance
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _instance = [[self alloc] init];
    });
    return _instance;
}

实现copyWithZone:方法

- (id)copyWithZone:(struct _NSZone *)zone
{
    return _instance;
}
单粒宏定义
#define interfaceSingle(name)  + (instancetype)share##name

#if __has_feature(objc_arc)
// 如果是ARC
#define implementationSingle(name)  + (instancetype)share##name \
{ \
    return [[self alloc] init]; \
} \
static id _instance; \
+ (instancetype)allocWithZone:(struct _NSZone *)zone \
{ \
    static dispatch_once_t onceToken; \
    dispatch_once(&onceToken, ^{ \
        _instance = [super allocWithZone:zone]; \
    }); \
    return _instance; \
} \
- (id)copyWithZone:(NSZone *)zone \
{ \
    return _instance; \
} \
- (id)mutableCopyWithZone:(NSZone *)zone \
{ \
    return _instance; \
}
#else
// 如果不是ARC
#define implementationSingle(name)  + (instancetype)share##name \
{ \
return [[self alloc] init]; \
} \
static id _instance; \
+ (instancetype)allocWithZone:(struct _NSZone *)zone \
{ \
static dispatch_once_t onceToken; \
dispatch_once(&onceToken, ^{ \
_instance = [super allocWithZone:zone]; \
}); \
return _instance; \
} \
- (id)copyWithZone:(NSZone *)zone \
{ \
return _instance; \
} \
- (id)mutableCopyWithZone:(NSZone *)zone \
{ \
return _instance; \
}\
- (oneway void)release \
{} \
- (instancetype)retain \
{ \
    return _instance; \
} \
- (NSUInteger)retainCount \
{ \
    return MAXFLOAT; \
}
#endif

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

UIViewController生命周期需要注意的

@property(nonatomic,retain)
UIView *view;
// The getter first invokes [self loadView] if the view hasn't been set yet. Subclasses must call super if they override the setter or getter.

如果没有生成view，那么self.view会先调用[self loadView],然后。。。






 (void)viewDidLoad;
// Called after the view has been loaded. For view controllers created in code, this is after -loadView. For view controllers unarchived from a nib, this is after the view is set.


然后调用viewDidLoad，注意this is after -loadView.




总结，self.view->[self loadView]->[self viewDidLoad]。

版权声明：本文为博主原创文章，未经博主允许不得转载。

【cocos2d-x 3.7 飞机大战】 决战南海I (九) 飘字特效
        之前在一个闯关游戏中第一次接触飘字效果，因为那个游戏没有发教程，所以在这里介绍下飘字效果



class FlowWord :public Node
{
public:
	FlowWord();
	~FlowWord();

	//创建和初始化 飘字
	static FlowWord* create();
	bool init();

	//显示飘字
	void showFlowWord(const char* text, Point pos, ActionInterval* flowWord);

	//显示飘字结束
	void showEnd();

//	ActionInterval* beginFlowWord();

//	ActionInterval* propFlowWord();

	ActionInterval* otherFlowWord();
protected:
private:

	Label* m_textLabel;
};



在这个类中，内置了几种常见的飘字动作和一个飘字函数(需要传入 飘字内容、位置、动作)


其实现如下

bool FlowWord::init()
{
	m_textLabel = Label::createWithTTF("", "fonts/DFPShaoNvW5-GB.ttf", 25);
	m_textLabel->setColor(ccc3(CCRANDOM_0_1() * 255, CCRANDOM_0_1() * 255, CCRANDOM_0_1() * 255));
	m_textLabel->setAnchorPoint(ccp(1, 0));
	m_textLabel->setVisible(false);

	this->addChild(m_textLabel);

	return true;
}

//显示飘字
void FlowWord::showFlowWord(const char* text, Point pos, ActionInterval* flowWord)
{

	m_textLabel->setPosition(pos);
	m_textLabel->setString(text);
	m_textLabel->setVisible(true);

	m_textLabel->runAction(flowWord);
}

//显示飘字结束
void FlowWord::showEnd()
{
	CCLOG("showWord End!");
	m_textLabel->setVisible(false);
	m_textLabel->removeFromParentAndCleanup(true);
}



#if 0
//游戏开始飘字
ActionInterval* FlowWord::beginFlowWord()
{
	//放大缩小
	ActionInterval* m_scaleLarge = ScaleTo::create(2.0f, 2.5, 2.5);
	ActionInterval* m_scaleSmall = ScaleTo::create(2.0f, 0.5, 0.5);

	//倾斜
	ActionInterval* m_skew = SkewTo::create(2.0f, 180, 0);
	ActionInterval* m_skewBack = SkewTo::create(2.0f, 0, 0);

	//组合动作
	ActionInterval* m_action = Spawn::create(m_scaleLarge, m_skew, NULL);
	ActionInterval* m_actionBack = Spawn::create(m_scaleSmall, m_skewBack, NULL);

	CallFunc* callFunc = CallFunc::create(this, callfunc_selector(FlowWord::showEnd));

	ActionInterval* flow = Sequence::create(m_action, m_actionBack, callFunc, NULL);

	return flow;
}

//获得道具飘字
ActionInterval* FlowWord::propFlowWord()
{
	//放大缩小
	ActionInterval* m_scaleLarge = ScaleTo::create(2.0f, 2.5, 2.5);
	ActionInterval* m_scaleSmall = ScaleTo::create(2.0f, 0.5, 0.5);

	CallFunc* callFunc = CallFunc::create(this, callfunc_selector(FlowWord::showEnd));

	ActionInterval* flow = Sequence::create(m_scaleLarge, m_scaleSmall, callFunc, NULL);

	return flow;
}

#endif

//其它飘字
ActionInterval* FlowWord::otherFlowWord()
{
	//移位
	ActionInterval* m_move1 = MoveBy::create(2.0f, ccp(30, 30));
	ActionInterval* m_move2 = MoveBy::create(2.0f, ccp(-30, -30));
	ActionInterval* m_move3 = MoveBy::create(2.0f, ccp(30, -30));
	ActionInterval* m_move4 = MoveBy::create(2.0f, ccp(-30, 30));

	//放大缩小
	ActionInterval* m_scale1 = ScaleTo::create(2.0f, CCRANDOM_0_1() * 4, CCRANDOM_0_1() * 4);
	ActionInterval* m_scale2 = ScaleTo::create(2.0f, CCRANDOM_0_1() * 4, CCRANDOM_0_1() * 4);
	ActionInterval* m_scale3 = ScaleTo::create(2.0f, CCRANDOM_0_1() * 4, CCRANDOM_0_1() * 4);
	ActionInterval* m_scale4 = ScaleTo::create(2.0f, CCRANDOM_0_1() * 4, CCRANDOM_0_1() * 4);

	ActionInterval* m_action1 = Spawn::create(m_move1, m_scale1, NULL);
	ActionInterval* m_action2 = Spawn::create(m_move2, m_scale2, NULL);
	ActionInterval* m_action3 = Spawn::create(m_move3, m_scale3, NULL);
	ActionInterval* m_action4 = Spawn::create(m_move4, m_scale4, NULL);


	CallFunc* callFunc = CallFunc::create(this, callfunc_selector(FlowWord::showEnd));

	ActionInterval* flow = Sequence::create(m_action1, m_action2, m_action3, m_action4, callFunc, NULL);

	return flow;
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

OC基础回顾（十三）代码块和并发性


1.代码块
代码块对象（通常称为代码块）是对C语言中函数的扩展。除了函数中的代码，代码块还包含变量绑定。代码块有时也称为闭包（closure）。
代码块包含两种类型的绑定：自动型和托管型。自动绑定（automatic binding）使用的是栈中的内存，而托管绑定（managed binding）是通过堆创建的。
1.1 代码块定义和实现
代码块借鉴了函数指针的语法。与函数指针相似，代码块具有以下特征：

返回类型可以手动声明，也可以由编译器推导；具有指定类型的参数列表拥有名称
代码：
int (^square_block)( int number ) = ^(int number) {
     return (number * number);
}；
int result = square_block(6);
NSLog(“Result = %d “,result);
说明：
等号前面的内容：int (^square_block)( int number ),是代码块的定义。
等号后面的内容：是代码块的实现内容。
一般我们可以用如下关系来表示它们：
returntype ( ^ blockname) ( list of arguments ) = ^( arguments ) {  body； }；
1.2 使用代码块
可以像函数一样使用代码块。例如：
int result = square_block(6);
说明：代码块在使用的时候不需要^(幂符号)，只有在定义的时候才需要。


使用代码块的时候通常不需要创建一个代码块变量，而是在代码中内联代码块的内容。通常需要将代码块作为参数的方法或函数。例如：
NSArray *array = [NSArray arrayWithObjects:@“a”,@“b”,@“c”,@“d”,nil];
NSArray *sortedArray = [array sortedArrayUsingComparator:^(NSString *object1, NSString *object2){
     return [object1 compare: object2];
}]; 
1.3 使用typedef关键字
像上面那样那么长的变量定义语句，在输入这些代码的时候很容易引起错误。我们可以用typedef关键字。
typedef double (^ MyBlockName)(double a, double b);
这行代码定义了一个名为MyBlockName的代码块变量类型，它包含两个双浮点类型的参数，并且返回一个双浮点类型的数值。


有了typedef，就可以像下面这样使用这个代码块变量：
MyBlockName *myBlock = ^(double a, double b){
     return a * b;
};
NSLog(@“%f, %f”, myBlock (2, 4 ) ,  myBlock (3, 4) );
1.4 代码块和变量
1.4.1 本地变量
     本地变量就是和代码块在同一范围内声明的变量。


代码示例：
typedef double (^ MyBlock)(void);
double a = 10, b = 20;
MyBlock myBlock = ^(void){
     return a * b;
};
a = 30;
b = 20;
NSLog(@“%f”,myBlock());
这段代码最后输出地的是100，而不是600.因为变量是本地变量，代码块会在定义的时候复制并保存它们的状态。
1.4.2 参数变量
代码块中的参数变量和函数中的参数变量具有同样的作用。
typedef double (^ MyBlock)(double c, double d);
MyBlock myBlock = ^(double a, double b){
     return a * b;
};
NSLog:(@“%f, %f”,myBlock(12,2), myBlock(2,4));
1.4.3 __block 变量
本地变量会被代码块作为常量获取到。如果你想要修改他们的值，必须将他们声明为可修改的，否则像下面这个实例，编译时会出现错误：
double c = 3;
MyBlock myBlock = ^(double a, double b){
     c = a * b;
};
编译器会报这个错误：
Variable is not assignable (missing __block type specifier)


想要修复这个编译错误，需要将变量c标记为__block。
__block double c = 3;
MyBlock myBlock = ^(double a, double b){
     c = a * b;
};


有些变量是无法声明为__block类型的。
包括：
1）长度可变的数组
2）包含可变长度数组的结构体
1.4.4 代码块内部的本地变量
这些变量与本地变量具有相同的作用：
void (^MyBlock)(void) = ^(void){
          double a = 3;
          double b = 4;
          NSLog(@“%f”, a * b);
};
MyBlcok();
1.5 代码块与内存管理
在代码块中使用Objective-C变量时必须小心 ,以下规则能帮助你处理内存管理。
1）如果引用了一个Objective-C对象，必须要保留它；
2）如果通过引用访问了一个实例变量，要保留一次self（即执行方法的对象）；
3）如果通过数值访问了一个实例变量，变量需要保留。
解释规则（1）的示例：
NSString *string1 = ^{
          return [_theString stringByAppendingString:_theString];
};
在这个示例中，_theString是声明了代码块的类中的实例变量。因为在代码块中直接访问了实例变量，所以包含它的对象（self）需要保留。
__block NSString *localObject = _theString;
NSString *string2 = ^{
          return [localObject stringByAppendingString:localObject];
};
在这个例子中，我们是间接访问：创建了一个指向实例变量的本地引用，并在代码块中使用。因此要保留的是localObject，而不是self。


因为代码块是对象，所以可以向它发送任何与内存管理有关的消息。在C语言级别中，必须使用Block_copy()和Block_release()函数来适当地管理内存.
MyBlock block1 = ^{
          NSLog(@"Block1”);
};
block1();

MyBlock block2 = ^{
          NSLog(@“Block2”);
};
block2();
Block_release(block2);
 
block2 = Block_copy(block1);
block2(); 
2.并发性
2.1 引入线程的概念
      用来运行Xcode的Mac电脑的处理器至少拥有两个核心，也可能更多。现在最新的iOS设备都是多核的。这意味着你可以在同一时间进行多项任务。苹果公司提供了多种可以利用多核特性的API。能够在同一时间执行多项任务的程序称其为并发的（concurrent）程序。
      利用并发性最基础的方法是使用POSIX线程来处理程序的不同部分使其能够独立执行。POSIX线程拥有支持C语言和Objective-C的API。编写并发程序需要创建多个线程，而编写线程代码是很具有挑战性的。
      线程是级别较低的API，需要手动管理，处理所有的线程是需要技巧的，一旦遇到问题，可能不使用线程会更好一些。
      百度百科线程：http://baike.baidu.com/view/1053.htm
2.2 GCD技术
 苹果公司为了减轻在多核上变成的负担，引入了Grand Central Dispatch，我们称之为GCD。

GCD技术减少了不少线程管理的麻烦，如果要使用GCD，你需要提交代码块或者函数作为线程来运行。GCD是一个系统级别(system-level)的技术，因此你可以在任意级别的代码中使用它。GCD决定需要多少线程来安排他们运行的进度。因为GCD是运行在系统级别的，所以可以平衡应用程序所有内容的加载，这样可以提高计算机或设备的执行效率。
2.2.1 同步
我们如何在由多核组成的通路中管理交通呢？可以使用同步装置，比如在通道入口立一个标记（flag）或者一个互斥（mutex）。
说明：mutex是mutual exclusion 的缩写，它指的是确保两个线程不会在同一时间进入临界区。
  
Objective-C提供了一个语言级别的（language-level）关键字@synchronized。这个关键字拥有一个参数，通常这个对象是可以修改的。
@synchronized(theObject)
{
          //Critical section
}

它可以确保不同的线程会连续地访问临界区的代码。


如果你定义了一个属性，并且没有指定关键字nonatomic作为属性的特性，编译器会生成强制彼此互斥的getter和setter方法，但是这样设置代码和变量，会产生一些消耗，比直接访问慢一些。为了提高性能，可以添加nonatomic特性。


1.选择性能
   NSObject提供方法以供一些代码只在后台执行。这些方法中都有performSelector：，最简单的就是performSelectorInBackground：WithObject：，它能在后台执行一个方法。它通过创建一个线程来运行方法。定义这些方法时必须遵从以下限制：
1）这些方法运行在各自的线程里，因此你必须为这些Cocoa对象创建一个自动释放池，而主自动释放池是与主线程相关的。
2）这些方法不能有返回值，并且要么没有参数，要么只有一个参数对象。换句话说，你只能使用以下代码格式中的一种：
-(void)myMethod;
-(void)myMethod:(id)myObject;


示例：
-(void)myBackgroundMethod
{
          @autoreleasepool
          {
                    NSLog(@“My Background Method”);
          }
}
或：
-(void)myBackgroundMethod:(id)myObject
{
          @autoreleasepool
          {
                    NSLog(@“My Background Method %@”,myObject);
          }
}


在后台执行你的方法：
[self performSelectorInBackground:@selector(myBackgroundMethod) withObject:nil];

或者：
[self performSelectorInBackground:@selector(myBackgroundMethod) withObject：argumentObjectl];

当方法执行结束之后，Objective-C运行时会特地清理并弃掉线程。需要注意：方法执行结束后并不会通知你，这是比较简单的代码。如果想要做一些更复杂的事情，需要学习调度队列。
2 调度队列
GCD可以使用调度队列（dispatch queue），只需写下你的代码，把它指派为一个队列（百度百科“队列”：http://baike.baidu.com/subview/38959/14411740.htm），系统就会执行它了。可以同步或异步执行任意代码。
有三种类型的队列：
1）连续队列：每个连续队列都会根据指派的顺序执行任务。可以按自己的想法创建任意数量的队列，他们会并行操作任务。
2）并发队列：每个并发队列都能并发执行一个或多个任务。任务会根据指派到队列的顺序开始执行。你无法创建连续队列，只能从系统提供的三个队列内选择一个来使用。
3）主队列：它是应用程序中有效的主队列，执行的是应用程序的主线程任务。


死锁（deadlock）：指的是两个或多个任务在等待其他任务执行结束，就像是几辆汽车同时位于一个很拥挤的停车场里。


下面讨论三种队列及其使用：

连续队列
        当有一连串任务需要按照一定顺序执行的时候，可以使用连续队列。任务执行顺序为先进先出（FIFO）：只要任务是异步提交的，队列会确保任务根据预定顺序执行。这些队列都是不会发生死锁的。
使用：
dispatch_queue_t my_serial_queue;
my_serial_queue = dispatch_queue_create(“com.appress.MySerialQueue1”,NULL);
第一个参数是队列的名称，第二个参数负责提供队列的特性（现在用不到，所以必须为NULL）。当队列创建好以后，就可以给他指派任务。



并发队列
        并发调度队列适合那些可以并行执行的任务。并发队列也遵从先进先出（FIFO）的规范，且任务可以在前一个任务结束前就开始执行。每一次运行同一个程序，并发任务的数量可能是不一样的，因为它会根据其它运行的任务在不同时间变化。
        说明：如果需要确保每次运行的任务数量都是一样的，可以通过线程API来手动管理线程。     
        三种并发队列：
          （1）高优先级（high）:优先级选项是DISPATCH_QUEUE_PRIORITY_HIGH
          （2）默认优先级（default）:优先级选项是DISPATCH_QUEUE_PRIORITY_DEFAULT
          （3）低优先级（low）:优先级选项是DISPATCH_QUEUE_PRIORITY_LOW
          如果想要引用他们，可以调用dispatch_get_global_queue方法。
代码：
dispatch_queue_t myQueue;
myQueue = dispatch_get_global_queue (DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

说明：第一个参数是优先级选项，对应不同的优先级。第二个参数暂时都用0。因为它们都是全局的，所以无需为他们管理内存。不需要保留这些队列的引用，在需要的时候使用函数来访问就行了。

主队列
        使用dispatch_get_main_queue可以访问与应用程序主线程相关的连续队列。
        dispatch_queue_t main_queue = dispatch_get_current_queue(void);
        因为这个队列与主线程相关，所以必须小心安排这个队列中的任务顺序，否则它们可能会阻塞主应用程序运行。通常要以同步的方式使用这个队列，提交过个任务并在它们操作完毕后执行一些动作。



获取当前队列
        可以通过dispatch_get_current_queue()来找出当前运行的队列代码块。如果在代码块对象之外调用了这个函数，则它将返回主队列。
 dispatch_queue_t myQueue = dispatch_get_current_queue();
2.2.2 队列的内存管理
     调度队列是引用计数对象。可以使用dispatch_retain()和dispatch_release来修改队列的保留计数值。它们与一般的retain和release语句相似。你只能对你自己创建的队列使用这些函数，而无法用在全局调度队列上。事实上，如果你向全局队列发送这些消息，是会被忽略的。如果你编写了一个使用了垃圾回收机制的OS X应用程序，那么你必须手动管理这些队列。
     1.队列的上下文（context）
     “在软件工程中，上下文是一种属性的有序序列，它们为驻留在环境内的对象定义环境。在对象的激活过程中创建上下文，对象被配置为要求某些自动服务，如同步、事务、实时激活、安全性等等。又比如计算机技术中，相对于进程而言，上下文就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。”


     你可以向调度对象（包括调度队列）指派全局数据上下文，可以在上下文中指派任意类型的数据，比如Objective-C对象或指针。系统只知道上下文包含了于队列相关的数据，上下文数据的内存管理只能由你来做。在为上下文分配内存的时候，可以使用dispatch_set_context()和dispatch_get_context()函数。


代码：
NSMutableDictionary *myContext = [[NSMutableDictionary alloc] initWithCapacity:5];
[myContext setObject:@“My Context” forKey:@“title”];
[myContext setObject:[NSNumber numberWithInt:0] forKey:@“value”];
dispatch_set_context(_serial_queue, (__bridge_retained void *) myContext);
在这个实例中，我们创建一个字典来存储上下文，当然也可以使用其它的指针类型。分配好内存之后就可以使用。
在最后一行代码中，我们必须保证对象是有效的，所以使用了__bridge_retained来给myContext的保留计数器的值加1。




清理函数

     设置完上下文对象的数据之后，不需要真的知道上下文对象在何时何地会被弃用。可以让对象在它弃用的时候调用一个函数，就像类里面的dealloc函数。函数的格式应该如下所示：
     void function_name(void *context);
     
我们将创建一个会在上下文对象弃用时调用的示例函数，通常称为终结器（finalizer）函数。
void myFinalizerFunction(void *context)
{
     NSLog(@“myFinalizerFunction”);
     NSMutableDictionary *theData = (__bridge_transfer NSMutableDictionary *)context;
     [theData removeAllObjects];
}
 __bridge_transfer 关键字：

这个关键字将对象的内存管理由全局释放池变换成了我们的函数。当我们的函数结束后，ARC将会给它的保留计数的值减1，如果保留计数的值被减到了0，对象将会被释放。如果对象没有被释放，myContext将会一直留在内存中。


如何在代码块中访问上下文内容？
NSMutableDictionary *myContext = (__bridge NSMutableDictionary *)dispatch_get_context(dispatch_get_current_queue());
这行代码中添加了__bridge关键字。是用来告诉ARC，我们并不想自己管理上下文的内存，而是想交给系统来管理。


添加任务

有两种方法可以向队列中添加任务：
（1）同步：队列会一直等待前面任务结束。
（2）异步：添加任务后，不必等待任务，函数会立刻返回。推荐优先使用这种方式，因为它不会阻塞其他代码的运行。
可以选择向队列添加代码块或函数。一共有四个调度函数，分别是代码块和函数各自的同步与异步方式。
注意：为了避免出现死锁，不要给运行在同一队列中的任务调用dispatch_sync或dispatch_sync_f函数。


     2.调度程序
(1)通过代码块添加任务
代码块必须是dispatch_block_t这样的类型，要定义为没有参数和返回值才行。
typedef void(^dispatch_block_t)(void);
先添加异步代码块。这个函数拥有两个参数，分别是队列和代码块。
dispatch_async(_serial_queue, ^{
     NSLog(@“Serial Task 1”);
});
如果是同步添加，使用dispatch_sync函数。


（2）通过函数添加任务
函数的标准原型必须要像下面这样：
void fucntion_name(void argument)


示例函数：
void myDispatchFunction(void *argument)
{
     NSLog(@“Serial Task %@”,(__bridge NSNumber *)argument);
     NSMutableDictionary *context = （__bridge NSMutableDictionary *）dispatch_get_context(dispatch_get_current_queue());
     NSNumber *value = [context objectForKey:@“value”];
     NSLog(@“value = %@“,value);  
}

向队列添加这个函数
调用函数拥有三个参数：队列、需要传递的任意上下文以及函数。如果没有信息要发送给函数，也可以只传递一个NULL值。
dispatch_async_f(_serial_queue, (__bridge void *) [NSNumber numberWithInt:3], (dispatch_function_t)myDispatchFunction);
如果想以同步的方式添加到队列中，请调用dispatch_sync_f函数。

暂停队列
如果出于某个原因要暂停队列，请调用dispatch_susend()函数并传递队列名称。
dispatch_suspend(_serial_queue);

重新启用队列
队列暂停之后，可以调用dispatch_resume（）函数来重新启用。
dispatch_resume(_serial_queue);
2.3 操作队列
Objective-C提供一些被称为操作（operation）的API，使队列在Objective-C层级上使用起来更加简单。
如果想要使用操作，首先需要创建一个操作对象，然后将其指派给操作队列，并让队列执行它。一共有三种创建队列的方式。
（1）NSInvocationOperation:
     如果已经有一个可以完成工作的类，并且想要在队列上执行它，可以尝试使用这种方法。

（2）NSBlockOperation:
     类似于包含了需要执行代码块的dispatch_async函数。

（3）自定义操作：
     如果需要更灵活的操作类型，可以创建自己的自定义类型。必须通过NSOperation子类来定义你的操作。


2.3.1 创建调用操作（invocation operation）
NSInvocationOperation会为执行任务的类调用选择器。因此你拥有 一个包含所需方法的类，使用这种方式来创建会非常方便。
@implementation MyCustomClass
-(NSOperation *)operationWithData:(id)data
{
     return [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myWorkerMethod:) object:data];
}

//This is the method that does the actual work
-(void)myWorkerMethod:(id)data
{
     NSLog（@“My Worker Method %@“,data）;
}
@end

一旦向队列中添加了操作，任务即将执行时便会调用类里面的myWorkerMethod：方法。

创建代码块操作 (block operation)
如果你有一个需要执行的代码块，那么可以创建这个操作并让队列执行它。
NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWihBlock:^{
     //Do my work
}];


一旦创建了第一个代码块，你便可以通过addExecutionBlock:方法继续添加更多的代码块。根据队列的类型（连续的还是并发的），代码块会分别以连续或者并发的方式进行。
[blockOperation addExecutionBlock:^{
     //dow some more work
}];

向队列中添加操作
一旦创建了操作，你就需要向队列中添加代码块。NSOperationQueue一般会并发执行。它具有相关性，因此如果某操作是基于其他操作的，它们会相应地执行。
如果要确保你的操作是连续执行的，可以设置最大并发操作数是1，这样任务就会按照先入先出的规范执行。在向队列添加操作之前，需要某个方法来引用到那个队列。可以创建一个新队列或使用之前已经定义过的队列（比如当前运行的队列）。
NSOperationQueue *currentQueue = [NSOperationQueue currentQueue];
或主队列：
NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];

以下就是创建队列的代码：
NSOperationQueue *_operationQueue = [[NSOperationQueue alloc] init];
//添加操作
[_operationQueue addOperation:blockOperation];



也可以添加需要执行的代码块来替代操作对象
[_operationQueue addOperationWithBlock:^{
     NSLog(“My Block”);
}];

一旦队列中添加了操作，它就会被安排进度并执行。




版权声明：本文为博主原创文章，转载请注明出处。

【cocos2d-x 3.7 飞机大战】 决战南海I (六) 保存玩家数据
        玩家要保存的数据可能很多，这里，我们只保存分数
这个类的成员变量和函数如下

//用户数据操作的成员变量
	UserDefault * m_userDefault;
	
	//要用到这种特殊的容器了。。
	ValueVector m_vector;
	//记录玩家的当前分数
	CC_SYNTHESIZE(int, m_score, Score);

	void save();

我们使用cocos2d-x提供的UserDefault类来实现数据保存功能



对于UserDefault类，我也不太熟悉，主要是参考官方文档和网上的例子来做的，不过基本思路还算清晰

bool SaveData::init()
{
	
	m_userDefault = UserDefault::getInstance();
	
	m_vector = ValueVector();
	
	m_score = 0;

	//每玩一次游戏，分数的记录条数就会加一
	m_userDefault->setIntegerForKey("count", (m_userDefault->getIntegerForKey("count", 0)) + 1);

	//首先判断XML文件是否存在，如果不存在的话就会执行if中的语句
	if (m_userDefault->getBoolForKey("isExit", false) == false)
	{
		//玩家初次玩游戏会执行这里
		m_userDefault->setBoolForKey("isExit", true);
	}
	else
	{
		//将分数记录保存在vector集合中
		for (int i = 0; i < m_userDefault->getIntegerForKey("count") - 1; i++)
		{
			__String * index = String::createWithFormat("%d", i);
			//将要放的数据使用Value包装一下
			m_vector.push_back(Value(m_userDefault->getIntegerForKey(index->getCString())));
		}
	}

	return true;
}

void SaveData::save()
{
	/*本函数的整体思路是先对vector中保存的玩家数据进行排序，然后重新写入到xml文件中*/

	//将玩家的分数保存到set集合中，以便排序，分数和原先的分数不同才保存
	int i = 0;
	for (auto tem : m_vector)
	{
		if (tem.asInt() == m_score)
		{
			break;
		}
		i++;
	}
	if (i == m_vector.size())
	{
		m_vector.push_back(Value(m_score));
		//自定义排序函数，对m_vector中的内容进行排序，方便以后对数据的操作
		auto sortData = [](Value value1, Value value2)
		{
			return value1.asInt() > value2.asInt();
		};
		//调用c++模板中的sort函数进行排序，前俩个参数是数组的地址，最后一个参数是使用的排序函数
		std::sort(m_vector.begin(), m_vector.end(), sortData);

		//将玩家的得分保存在文件中
		for (int i = 0; i < m_vector.size(); i++)
		{
			auto value = m_vector.at(i);
			auto index = __String::createWithFormat("%d", i);
			m_userDefault->setIntegerForKey(index->getCString(), value.asInt());
		}
	}

	//单独保存本次游戏的得分
	UserDefault::getInstance()->setIntegerForKey("currentScore", m_score);
	//重新设置一下count
	UserDefault::getInstance()->setIntegerForKey("count", m_vector.size());

	//刷新
	m_userDefault->flush();
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

计算机视觉CV 之 CMT跟踪算法分析四
1 前言在上一部分我们已经分析到了计算特征点的缩放和旋转，这里最后分析去掉不好的特征点的方法。2 最后步骤分析vote的基本思想就是这些特征点相对中心的相对距离在把缩放旋转考虑进去之后是相对不变的，也就是按道理下一帧的特征点相对中心的位置是不变的。但是由于图像本身的变化，不可能得到完全一样的相对位置，这个时候，有一些会离中心近，有一些会偏差很大。那么，作者就采用聚类的方法，选择最大的一类作为最好的特征点。其他的不要。上面这个图应该可以很好的理解这个过程。再看作者自己官网上的图大家应该可以理解。代码上作者找了一个聚类的库来做，具体我没有深入分析了：void Consensus::findConsensus(const vector<Point2f> & points, const vector<int> & classes,
        const float scale, const float rotation,
        Point2f & center, vector<Point2f> & points_inlier, vector<int> & classes_inlier)
{

    //If no points are available, reteurn nan
    if (points.size() == 0)
    {
        center.x = numeric_limits<float>::quiet_NaN();
        center.y = numeric_limits<float>::quiet_NaN();

        return;
    }

    //Compute votes 计算投票：基本方法就是计算点相对于正规化且计算其旋转加缩放后的点的相对位置 保持相对一致
    vector<Point2f> votes(points.size());
    for (size_t i = 0; i < points.size(); i++)
    {
        votes[i] = points[i] - scale * rotate(points_normalized[classes[i]], rotation);
    }

    t_index N = points.size();

    float * D = new float[N*(N-1)/2]; //This is a lot of memory, so we put it on the heap
    cluster_result Z(N-1);

    //Compute pairwise distances between votes
    //计算votes点之间的相对距离
    int index = 0;
    for (size_t i = 0; i < points.size(); i++)
    {
        for (size_t j = i+1; j < points.size(); j++)
        {
            //TODO: This index calculation is correct, but is it a good thing?
            //int index = i * (points.size() - 1) - (i*i + i) / 2 + j - 1;
            // 计算相对距离
            D[index] = norm(votes[i] - votes[j]);
            index++;
        }
    }

    MST_linkage_core(N,D,Z);

    union_find nodes(N);

    //Sort linkage by distance ascending
    std::stable_sort(Z[0], Z[N-1]);

    //S are cluster sizes
    int * S = new int[2*N-1];
    //TODO: Why does this loop go to 2*N-1? Shouldn't it be simply N? Everything > N gets overwritten later
    for(int i = 0; i < 2*N-1; i++)
    {
        S[i] = 1;
    }

    t_index parent = 0; //After the loop ends, parent contains the index of the last cluster
    for (node const * NN=Z[0]; NN!=Z[N-1]; ++NN)
    {
        // Get two data points whose clusters are merged in step i.
        // Find the cluster identifiers for these points.
        t_index node1 = nodes.Find(NN->node1);
        t_index node2 = nodes.Find(NN->node2);

        // Merge the nodes in the union-find data structure by making them
        // children of a new node
        // if the distance is appropriate
        if (NN->dist < thr_cutoff)
        {
            parent = nodes.Union(node1, node2);
            S[parent] = S[node1] + S[node2];
        }
    }

    //Get cluster labels
    int * T = new int[N];
    for (t_index i = 0; i < N; i++)
    {
        T[i] = nodes.Find(i);
    }

    //Find largest cluster
    int S_max = distance(S, max_element(S, S + 2*N-1));

    //Find inliers, compute center of votes
    points_inlier.reserve(S[S_max]);
    classes_inlier.reserve(S[S_max]);
    center.x = center.y = 0;

    for (size_t i = 0; i < points.size(); i++)
    {
        //If point is in consensus cluster
        if (T[i] == S_max)
        {
            points_inlier.push_back(points[i]);
            classes_inlier.push_back(classes[i]);
            center.x += votes[i].x;
            center.y += votes[i].y;
        }

    }

    center.x /= points_inlier.size();
    center.y /= points_inlier.size();

    delete[] D;
	delete[] S;
	delete[] T;

}通过这样的算法得到inlier然后在代码中，作者又做了一次匹配，matchlocal，在我看来和findconsensus的目的是一样的，也是通过相对的点的距离来判定是不是要的特征，然后在对这些特征做一次匹配，是就选进来，最后将inlier的点和matchlocal的点合并，作为最终的特征点。matchlocal的代码如下：void Matcher::matchLocal(const vector<KeyPoint> & keypoints, const Mat descriptors,
        const Point2f center, const float scale, const float rotation,
        vector<Point2f> & points_matched, vector<int> & classes_matched)
{

    if (keypoints.size() == 0) {
        return;
    }

    //Transform initial points
    vector<Point2f> pts_fg_trans;
    pts_fg_trans.reserve(pts_fg_norm.size());
    for (size_t i = 0; i < pts_fg_norm.size(); i++)
    {
        // 同样是计算相对位置
        pts_fg_trans.push_back(scale * rotate(pts_fg_norm[i], -rotation));
    }

    //Perform local matching
    for (size_t i = 0; i < keypoints.size(); i++)
    {
        //Normalize keypoint with respect to center
        Point2f location_rel = keypoints[i].pt - center;

        //Find potential indices for matching
        vector<int> indices_potential;
        for (size_t j = 0; j < pts_fg_trans.size(); j++)
        {
            // 计算位置偏差
            float l2norm = norm(pts_fg_trans[j] - location_rel);

            // 设置一个阈值
            if (l2norm < thr_cutoff) {
                indices_potential.push_back(num_bg_points + j);
            }

        }

        //If there are no potential matches, continue
        if (indices_potential.size() == 0) continue;

        //Build descriptor matrix and classes from potential indices
        Mat database_potential = Mat(indices_potential.size(), database.cols, database.type());
        for (size_t j = 0; j < indices_potential.size(); j++) {
            database.row(indices_potential[j]).copyTo(database_potential.row(j));
        }

        //Find distances between descriptors
        vector<vector<DMatch> > matches;
        // 对选出的特征点进行特征匹配
        bfmatcher->knnMatch(descriptors.row(i), database_potential, matches, 2);

        vector<DMatch> m = matches[0];

        float distance1 = m[0].distance / desc_length;
        float distance2 = m.size() > 1 ? m[1].distance / desc_length : 1;

        if (distance1 > thr_dist) continue;
        if (distance1/distance2 > thr_ratio) continue;

        int matched_class = classes[indices_potential[m[0].trainIdx]];

        points_matched.push_back(keypoints[i].pt);
        classes_matched.push_back(matched_class);
    }

}好了，由于时间关系，CMT算法就分析到这了。有很多不足，可能也分析不到位甚至有错的地方，请批评指正。文章原创，转载麻烦注明出处：blog.csdn.net/songrotek

版权声明：本文为博主原创文章，未经博主允许不得转载。

嵌入式Linux网络编程 之 简单的UDP网络编程
关于用户数据报文协议（UDP）：
UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。而且UDP提供的是不可靠的非连接型的传输层服务，允许在源站点和目的站点之间传送数据，而不必在传送数据之间建立连接，进而开销比较低，主要用于那些不要求TCP协议的非连接型应用程序。例如：网络管理，视频点播、网络会议...


简单的数据报通信的框图





常用的API：（不完善）
函数名称 socket（）
功能，创建一个套接字
原型：int socket(int domain, int type, int protocol)
所属头文件：<sys/socket.h>
成功：返回文件套接字描述符   失败:返回-1
参数说明：
domain：网络协议域 ， 如AF_INET-- IPv4域 AF_INET6--IPv6域
type : 套接字类型 
     如SOCK_DGRAM：固定长度的，无连接的，不可靠的报文传递，默认为UDP
        SOCK_STREAM：有序的，可靠的，双向的，面向连接的字节流，默认为TCP
        SOCK_RAW：IP协议的数据报接口
protocol： 通常为0 ，表示为给定的域和套接字类型选择一个特定的协议
函数名称bind
功能：关联地址和套接字
原型：int bind(int sockfd, const struct sockaddr *addr, socklen_t len);
所属头文件：<sys/socket.h>
成功：返回0 失败：返回-1
参数说明：
sockfd : 绑定的套接字
addr： 绑定的地址，对于因特网域，若指定地址内的IP为INADDR_ANY,则套接字断点可以被绑定到所有的系统网络接口上，这意味着可以接受这个系统所安装的任何一个网卡的数据包
len : 绑定地址的大小。



函数名称：sendto()
功能 : 发送数字，面对无连接的套接字
原型：ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, const struct sockaddr *destaddr, socklen_t destlen)
所属头文件：<sys/socket.h>
成功：返回发送的字节数  失败：返回-1
参数说明：
sockfd : 套接字
buf ：需发送的数据
nbytes： 需发送的数据长度
flags：一般为0
destaddr：目的地址（务必转换类型）
destlen：地址长度
函数名称：recvfrom()
功能 : 接收数据，可以获取数据发送者的源地址
原型 : ssize_t recvfrom（int sockfd, void *restrict buf, size_t len, int flags,  struct sockaddr *restrict addr, socklen_t *restrict addrlen)
所属头文件：<sys/socket.h>
成功：返回接受的字节数 ，无可用数据则返回0 失败：返回-1
参数说明：
sockfd : 套接字
buf ：接收的数据
nbytes： 接收的数据长度
flags：一般为0
addr ：发送数据者的套接字端点地址
addrlen：包含了addr所指向的套接字自缓冲区的字节长度


函数名称colse()
原型： int close(int fd)
功能 : 关闭一个文件，关闭一个套接字
头文件：<unistd.h>
成功：0 失败：-1
函数名称：shutdown()
原型：int shutdown(int sockfd, int how)
功能 :  禁止一个套接字的IO
头文件：<sys/socket.h>
成功：0 失败：-1
参数说明：
sockfd : 套接字
how : 
    SHUT_RD : 将无法从套接字中读取数据
    SHUT_WR：关闭写端，将无法使用套接字发送数据
    SHUT_RDWR:关闭读写端，既无法读，又无法发送



服务器收发基本流程：
1. 创建套接字
2. 初始化套接字（把相应字段转换成网络字节序后填入）
3. 绑定套接字到一个具体的地址端口
4. 收发处理
       4.1 循环收发数据报
       4.2 打印收发的信息 


代码如下：
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>

#define SERVER_PORT 8880
#define BUFFER 1024

void udp_respon(int sockfd);

int main(int argc, char *argv[])
{
 int sockfd;
 struct sockaddr_in addr;
 
 sockfd = socket(AF_INET, SOCK_DGRAM, 0);
 
 bzero(&addr, sizeof(struct sockaddr_in));
 addr.sin_family = AF_INET;
 addr.sin_port = htons(SERVER_PORT);//注意字节序的转换
 
 addr.sin_addr.s_addr = htonl(INADDR_ANY);//设置IP为INADDR_ANY，这可以绑定套接字端口到任意的本地地址上
 
 if(bind(sockfd, (struct sockaddr*)&addr, sizeof(struct sockaddr_in))<0)
 {
  printf("Bind Error!\n");
  exit(1);
 }
 
 udp_respon(sockfd);
 
 close(sockfd);
 
 return 0;
}

void udp_respon(int sockfd)
{
 struct sockaddr_in addr;//用于接收源端口信息，即客户端的信息
 unsigned int addrlen = 16, n;
 char msg[BUFFER]; //用于接收数据的缓冲区
 char echo[] = "[server ehco]";
 
 while(1)
 {
   if(n = recvfrom(sockfd, msg, BUFFER, 0, (struct sockaddr*)&addr, &addrlen) < 0)
   {
   printf("Recive Error!");
   exit(1);
   }
   
   fprintf(stdout, "I have received: %s", msg);
   
   strcat(msg, echo);
   
   printf("msg = %s\n", msg);
   
   printf("client port: %d\n", ntohs(addr.sin_port));
   
   sendto(sockfd, msg, strlen(msg), 0, (struct sockaddr*)&addr, addrlen);
 }
}






客户端收发基本流程：
1. 判断使用客户端是否合理，及用法
2. 创建服务端套接字（从客户端中提取IP和端口号）和客户端套接字（由客户端代码指定），注意格式的转换
3. 绑定客户端套接字
4.接收处理
    4.1 提示输入信息，打印发送数据
    4.2 接收服务器回传的数据


代码如下：
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

#define BUFFER 1024

void udp_respon(int sockfd, const struct sockaddr_in *addr, int len)
{
 char buffer[BUFFER];
 int n;
 while(1)
 {
 
  fgets(buffer, BUFFER, stdin);
 
  sendto(sockfd, buffer, strlen(buffer), 0, (struct sockaddr*)addr, len);
  bzero(buffer, BUFFER);
 
  n = recvfrom(sockfd, buffer, BUFFER, 0, NULL, NULL);
  buffer[n] = 0;
  fprintf(stdout, "I have received: %s", buffer);
 }
}

int main(int argc, char *argv[])
{
 int sockfd, port;
 struct sockaddr_in s_addr;//服务端地址结构
 struct sockaddr_in c_addr;//客户端地址结构
 
 if(argc != 3)
 {
  fprintf(stderr, "usage: %s IP Port", argv[0]);
  exit(1);
 
 }
 
 if((port = atoi(argv[2])) < 0) //注意此处的优先级
 {
  printf("The port is error\n");
  exit(1);
 }
 sockfd = socket(AF_INET, SOCK_DGRAM, 0);
 
 if(sockfd<0)
 {
        fprintf(stderr,"Socket  Error:%s\n",strerror(errno));
        exit(1);
    }  
 
 bzero(&s_addr, sizeof(struct sockaddr_in));

 s_addr.sin_family = AF_INET;
 s_addr.sin_port = htons(port);
 
 if(inet_pton(AF_INET, argv[1], &s_addr.sin_addr) < 0 )
 {
  fprintf(stderr, "Ip errpr %s\n", strerror(errno));
  exit(1);
 }
 
 /*if(inet_aton(argv[1], &s_addr.sin_addr) < 0)
 {
  fprintf(stderr, "Ip error:%s\n", strerror(errno));
  exit(1);
 }*/
 
 bzero(&c_addr, sizeof(struct sockaddr_in));
 
 c_addr.sin_family = AF_INET;
 c_addr.sin_port = htons(8848);
 c_addr.sin_addr.s_addr = htonl(INADDR_ANY);

 if(bind(sockfd, (struct sockaddr *)&c_addr, sizeof(struct sockaddr_in)) < 0)
 {
  fprintf(stderr, "Bind Error: %s\n", strerror(errno));
  exit(1);
 }
 
 udp_respon(sockfd, &s_addr, sizeof(struct sockaddr_in));
 
 close(sockfd);
}




通信演示：
服务端：



客户端：



注：注意赋值符号的优先级比较低。
如：
if(a = fuc(b) < c)... 函数结果先与c作比较，在赋值给a.
if( ( a = fuc(b) ) <c )..与上述表达式有很大不同



版权声明：本文为博主原创文章，未经博主允许不得转载。

tableViewCell自适应高度（QQ聊天室模拟）
先看一看效果吧！
 
 
 

废话不多说直接上代码
代码下载请猛戳这里
先看一看代码结构图： 
 
MessageModel代码：
#import "MessageModel.h"

@implementation MessageModel
/**
 *  类方法创建一个消息模型实例
 *
 *  @param dic 描述模型的字典
 *
 *  @return 消息模型实例
 */
+ (instancetype)messageModelWithDictionary:(NSDictionary *)dic
{
    return [[self alloc] initWithDictionary:dic];
}
/**
 *  自定义初始化方法
 *
 *  @param dic 描述模型的字典
 *
 *  @return 消息模型实例
 */
- (instancetype)initWithDictionary:(NSDictionary *)dic
{
    if (self = [super init]) {
        if (dic) {
            [self setValuesForKeysWithDictionary:dic];
        }
    }

    return self;
}

@end
MessageFrameModel代码：
#import "MessageFrameModel.h"
#import "MainDefine.h"
#import "NSString+Extension.h"

@implementation MessageFrameModel

- (void)setIsHideTime:(BOOL)isHideTime
{
    _isHideTime = isHideTime;

    //设置计算出来的frame数据
    [self settingCalculationData];
}

/**
 *  类方法创建一个带有对应控件frame的消息模型实例
 *
 *  @param dic 描述模型的字典
 *
 *  @return 消息模型实例
 */
+ (instancetype)messageFrameModelWithDescription:(NSDictionary *)dic
{
    return [[self alloc] initWithDescription:dic];
}
/**
 *  自定义初始化方法
 *
 *  @param dic 描述模型的字典
 *
 *  @return 消息模型实例
 */
- (instancetype)initWithDescription:(NSDictionary *)dic
{
    if (self = [super initWithDictionary:dic]) {
        if (dic) {
            //设置计算出来的frame数据
            //[self settingCalculationData:dic];
        }
    }

    return self;
}

/**
 *  根据基础数据计算对应控件的frame
 *
 *  @param dic 基础数据字典
 */
- (void)settingCalculationData
{
    CGFloat spacing = 8.0;
    CGFloat timeX = 0.0;
    CGFloat timeY = 0.0;
    CGFloat timeHeight = 44.0;
    CGFloat iconWith = 50.0;

    if (!self.isHideTime) {
        self.timeFrame = CGRectMake(timeX, timeY, MAINSCREEM_WITH, timeHeight);
    }

    if (self.type == MessageTypeMySend)
    {
        self.iconFrame = CGRectMake(MAINSCREEM_WITH - spacing - iconWith, CGRectGetMaxY(self.timeFrame) + 8, iconWith, iconWith);
    }
    else
    {
        self.iconFrame = CGRectMake(spacing, CGRectGetMaxY(self.timeFrame) + spacing, iconWith, iconWith);
    }

    CGFloat targetWidth = MAINSCREEM_WITH - spacing - self.iconFrame.size.width*2 - TEXTBUTTON_PADDING*2;
    CGSize wordsS = [self.text autoSizeWithTargetWidth:targetWidth andFont:[UIFont systemFontOfSize:MEDIUM_FONT]];

    CGFloat textX = spacing + self.iconFrame.size.width;
    if (self.type == MessageTypeMySend) {
        textX = MAINSCREEM_WITH - textX - wordsS.width - TEXTBUTTON_PADDING*2;
    }
    self.textFrame = CGRectMake(textX, self.iconFrame.origin.y, wordsS.width + TEXTBUTTON_PADDING*2, wordsS.height + TEXTBUTTON_PADDING*2);

    self.cellHeight = MAX(CGRectGetMaxY(self.iconFrame), CGRectGetMaxY(self.textFrame));
}
MessageFrameModelList代码：
#import "MessageFrameModelList.h"
@interface MessageFrameModelList()
@property (strong, nonatomic)NSMutableArray *messageFrameModels;
@end

@implementation MessageFrameModelList
- (NSInteger)count
{
    return self.messageFrameModels.count;
}
/**
 *  类方法创建一个带有对应控件frame的消息模型列表实例
 *
 *  @param dic 描述模型列表的数组
 *
 *  @return 消息模型列表
 */
+ (instancetype)messageFrameModelListWithArray:(NSArray *)arr
{
    return [[self alloc] initWithArray:arr];
}
/**
 *  自定义初始化方法
 *
 *  @param dic 描述模型列表的数组
 *
 *  @return 消息模型列表
 */
- (instancetype)initWithArray:(NSArray *)arr
{
    if (self = [super init])
    {
        if (arr)
        {
            self.messageFrameModels = [NSMutableArray arrayWithCapacity:1];
            NSArray *messageArr = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"messages" ofType:@"plist"]];

            for (int index = 0; index < messageArr.count; index++)
            {
                MessageFrameModel *messageFrameModel = [MessageFrameModel messageFrameModelWithDescription:messageArr[index]];

                MessageFrameModel *lastMessageFrameModel = [self.messageFrameModels lastObject];
                messageFrameModel.isHideTime = [messageFrameModel.time isEqual:lastMessageFrameModel.time];//如果和上一条消息时间相等，就隐藏时间

                [self.messageFrameModels addObject:messageFrameModel];
            }
        }
    }

    return self;
}

/**
 *  根据标号获取模型列表中的一个模型
 *
 *  @param index 标号
 *
 *  @return 带有对应控件frame的消息模型
 */
- (MessageFrameModel *)getMessageFrameModel:(NSInteger)index
{
    return self.messageFrameModels[index];
}

/**
 *  添加一条消息
 *
 *  @param messageDic 消息描述字典
 */
- (void)addMessageWithDictionary:(NSDictionary *)messageDic
{
    MessageFrameModel *messageFrameModel = [MessageFrameModel messageFrameModelWithDescription:messageDic];

    //设置是否隐藏时间
    MessageFrameModel *lastMessageFrameModel = [self.messageFrameModels lastObject];
    messageFrameModel.isHideTime = [messageFrameModel.time isEqualToString:lastMessageFrameModel.time];

    [self.messageFrameModels addObject:messageFrameModel];
}

@end
MessageCell代码：
#import "MessageCell.h"
#import "MainDefine.h"

@interface MessageCell()

/**
 *  时间
 */
@property (strong, nonatomic)UILabel *timeLabel;
/**
 *  头像
 */
@property (strong, nonatomic)UIImageView *iconImageView;
/**
 *  内容
 */
@property (strong, nonatomic)UIButton *textButton;

@end

@implementation MessageCell

/**
 *  类方法返回一个能重用的cell
 *
 *  @param tableView  使用此cell的tableView
 *  @param identifier 此类cell的重用标识符
 *
 *  @return 本cell的一个实例
 */
+ (instancetype)messageCell:(UITableView *)tableView
{
    static NSString *cellIdentifier = @"messageCell";
    MessageCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];
    if (cell == nil) {
        cell = [[MessageCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier];
    }

    return cell;
}

/**
 *  设置cell的内部控件大小
 *
 *  @param messageFrameModel 带对应控件大小的消息模型
 */
- (void)setMessageFrameModel:(MessageFrameModel *)messageFrameModel
{
    if (messageFrameModel) {
        _messageFrameModel = messageFrameModel;
        self.timeLabel.frame = messageFrameModel.timeFrame;
        self.timeLabel.text = messageFrameModel.time;
        self.timeLabel.hidden = messageFrameModel.isHideTime;

        self.iconImageView.frame = messageFrameModel.iconFrame;
        self.iconImageView.layer.cornerRadius = messageFrameModel.iconFrame.size.width/2;
        self.iconImageView.layer.masksToBounds = YES;
        self.iconImageView.image = [UIImage imageNamed:messageFrameModel.type == MessageTypeMySend ? @"me" : @"other"];

        self.textButton.frame = messageFrameModel.textFrame;
        [self.textButton setTitle:messageFrameModel.text forState:UIControlStateNormal];
        if (self.messageFrameModel.type == MessageTypeMySend)
        {
            [self.textButton setBackgroundImage:[self imageWithName:@"chat_send_nor"] forState:UIControlStateNormal];
            [self.textButton setBackgroundImage:[self imageWithName:@"chat_send_press_pic"] forState:UIControlStateHighlighted];
        }
        else
        {
            [self.textButton setBackgroundImage:[self imageWithName:@"chat_recive_nor"] forState:UIControlStateNormal];
            [self.textButton setBackgroundImage:[self imageWithName:@"chat_recive_press_pic"] forState:UIControlStateHighlighted];
        }
    }
}
/**
 *  不变形的拉伸图片
 *
 *  @param name 图片名称
 *
 *  @return 拉伸后的图片
 */
- (UIImage *)imageWithName:(NSString *)name
{
    UIImage *image = [UIImage imageNamed:name];
    CGFloat imageW = image.size.width/2;
    CGFloat imageH = image.size.height/2;
    return [image resizableImageWithCapInsets:UIEdgeInsetsMake(imageH, imageW, imageH, imageW)];
}

- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]) {
        self.timeLabel = [[UILabel alloc] init];
        self.timeLabel.textAlignment = NSTextAlignmentCenter;
        self.timeLabel.font = [UIFont systemFontOfSize:SMOLL_FONT];
        self.timeLabel.textColor = [UIColor grayColor];
        [self.contentView addSubview:self.timeLabel];

        self.iconImageView = [[UIImageView alloc] init];
        [self.contentView addSubview:self.iconImageView];

        self.textButton = [[UIButton alloc] init];
        [self.textButton setTitleEdgeInsets:UIEdgeInsetsMake(TEXTBUTTON_PADDING, TEXTBUTTON_PADDING, TEXTBUTTON_PADDING, TEXTBUTTON_PADDING)];
        self.textButton.titleLabel.font = [UIFont systemFontOfSize:MEDIUM_FONT];
        self.textButton.titleLabel.numberOfLines = 0;
        [self.textButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
        [self.contentView addSubview:self.textButton];

        [self setBackgroundColor:[UIColor clearColor]];
    }

    return self;
}

- (void)awakeFromNib {
    // Initialization code
}

- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];

    // Configure the view for the selected state
}

@end
ViewController代码：
#import "ViewController.h"
#import "MessageFrameModelList.h"
#import "MessageCell.h"

@interface ViewController ()<UITableViewDataSource,UITableViewDelegate,UITextFieldDelegate>
@property (weak, nonatomic) IBOutlet UITableView *tableView;
@property (weak, nonatomic) IBOutlet UITextField *textField;
/**
 *  带frame的消息数据模型表
 */
@property (strong, nonatomic)MessageFrameModelList *messageFrameModelList;

@end

@implementation ViewController
#pragma mark - 属性方法
- (MessageFrameModelList *)messageFrameModelList
{
    if (!_messageFrameModelList) {
        NSArray *arr = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"messages" ofType:@"plist"]];
        _messageFrameModelList = [MessageFrameModelList messageFrameModelListWithArray:arr];

        //消息最开始滚到最后
        [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.messageFrameModelList.count - 1 inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:NO];
    }

    return _messageFrameModelList;
}

#pragma mark - 控制器周期
- (void)viewDidLoad {
    [super viewDidLoad];

    //注册键盘通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillChangeFrame:) name:UIKeyboardWillChangeFrameNotification object:nil];

    //设置文本框左边距
    self.textField.leftView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 4, 0)];
    self.textField.leftViewMode = UITextFieldViewModeAlways;

    //设置文本框代理
    self.textField.delegate = self;
}
- (void)dealloc
{
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

#pragma mark - 按钮手势事件
- (IBAction)didViewCtrClicked:(id)sender {
    [self.view endEditing:YES];
}
- (IBAction)didAddClicked:(UIButton *)sender {
    [self.view endEditing:YES];
}

#pragma 自定义方法
/*
 UIKeyboardAnimationCurveUserInfoKey = 7;  // 动画的执行节奏(速度)
 UIKeyboardAnimationDurationUserInfoKey = "0.25"; // 键盘弹出\隐藏动画所需要的时间
 UIKeyboardBoundsUserInfoKey = "NSRect: {{0, 0}, {320, 216}}";
 UIKeyboardCenterBeginUserInfoKey = "NSPoint: {160, 588}";
 UIKeyboardCenterEndUserInfoKey = "NSPoint: {160, 372}";
 UIKeyboardFrameChangedByUserInteraction = 0;

 // 键盘弹出
 UIKeyboardFrameBeginUserInfoKey = "NSRect: {{0, 480}, {320, 216}}";// 键盘刚出来那一刻的frame
 UIKeyboardFrameEndUserInfoKey = "NSRect: {{0, 264}, {320, 216}}"; //  键盘显示完毕后的frame

 // 键盘隐藏
 UIKeyboardFrameBeginUserInfoKey = "NSRect: {{0, 264}, {320, 216}}";
 UIKeyboardFrameEndUserInfoKey = "NSRect: {{0, 480}, {320, 216}}";
 */
- (void)keyboardWillChangeFrame:(NSNotification *)notification
{
    //NSLog(@"%@",notification.userInfo);
    //self.view.frame = CGRectMake(self.view.frame.origin.x, [[notification.userInfo valueForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y - self.view.frame.size.height, self.view.frame.size.width, self.view.frame.size.height);
    //self.view.transform = CGAffineTransformTranslate(self.view.transform, 0, [[notification.userInfo valueForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y - [[notification.userInfo valueForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue].origin.y);

    //首尾式动画
    [UIView beginAnimations:nil context:nil];
    //设置动画时间
    [UIView setAnimationDuration:[[notification.userInfo valueForKey:UIKeyboardAnimationDurationUserInfoKey] doubleValue]];
    //设置动画节奏
    [UIView setAnimationCurve:[[notification.userInfo valueForKey:UIKeyboardAnimationCurveUserInfoKey] integerValue]];

    self.view.transform = CGAffineTransformMakeTranslation(0, [[notification.userInfo valueForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y - self.view.frame.size.height);

    [UIView commitAnimations];
}

- (void)addMessage:(NSString *)messageStr andType:(MessageType)messageType
{
    //设置时间
    NSDate *nowDate = [NSDate date];
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    dateFormatter.dateFormat = @"yyyy-MM-dd HH:mm:ss";
    NSString *dateStr = [dateFormatter stringFromDate:nowDate];

    NSDictionary *messageDic = @{@"text":messageStr,@"type":[NSNumber numberWithInteger:messageType],@"time":dateStr};
    [self.messageFrameModelList addMessageWithDictionary:messageDic];

    //刷新tableView
    [self.tableView reloadData];
    //tableView滚动到最新消息处
    [self.tableView scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:self.messageFrameModelList.count - 1 inSection:0] atScrollPosition:UITableViewScrollPositionBottom animated:YES];
}

/**
 *  根据自己发的内容取得自动回复的内容
 *
 *  @param text 自己发的内容
 */
- (NSString *)autoReply:(NSString *)textStr
{
    NSDictionary *repelyText = [NSDictionary dictionaryWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"autoreply" ofType:@"plist"]];
    for (NSInteger i = 0; i < textStr.length; i++) {
        NSString *word = [textStr substringWithRange:NSMakeRange(i, 1)];
        if (repelyText[word]) {
            return repelyText[word];
        }
    }

    return @"你妹啊";
}

#pragma mark - UITableView代理
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return self.messageFrameModelList.count;
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    MessageCell *cell = [MessageCell messageCell:tableView];
    cell.messageFrameModel = [self.messageFrameModelList getMessageFrameModel:indexPath.row];

    return cell;
}
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    return [self.messageFrameModelList getMessageFrameModel:indexPath.row].cellHeight;
}
- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView
{
    [self.view endEditing:YES];
}

#pragma mark - UITextField代理
- (BOOL)textFieldShouldReturn:(UITextField *)textField
{
    [self addMessage:self.textField.text andType:MessageTypeMySend];

    //清空输入框
    self.textField.text = nil;

    //模拟回复
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSString *autoReplyText = [self autoReply:[self.messageFrameModelList getMessageFrameModel:self.messageFrameModelList.count - 1].text];
        [self addMessage:autoReplyText andType:MessageTypeOtherSend];
    });

    return YES;
}
@end

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

spring 第一个程序 hello


public class HelloWord {
 private String userName;


public void setUserName(String userName) {
this.userName = userName;
}
public void hello(){
System.out.println("hello:"+userName);
}
 
}



import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class Test {
public static void main(String[] args) {
/**
* 创建对象及为对象赋值交给spring完成
*/
// HelloWord helloWord = new HelloWord();
// helloWord.setUserName("hello");
// helloWord.hello();

//1.创建spring IOC容器
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");


//2从容器中获得Bean
HelloWord helloWord = (HelloWord) ctx.getBean("helloWord");


//3.调用方法
helloWord.hello();
}
}

配置文件为：
applicationContext.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:p="http://www.springframework.org/schema/p"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd">
<!-- 配置bean -->
<bean id="helloWord" class="com.spring.HelloWord">
 <property name="userName" value="springsss"></property>
</bean>


</beans>



输出结果为:
hello:springsss


版权声明：本文为博主原创文章，未经博主允许不得转载。

如何在VS中像MATLAB中一样做矩阵运算

What do we need?


Armadillo 
          Armadillo
 【1】是一个高质量的C++线性代数库，目的是在运算速度与易用性之间取一个折衷。它其实是对底层的矩阵运算库（例如BLAS，LAPACK）的封装，也就是说，这个库本身的计算能力其实不强，但是这个库可以配合开源的底层库来使用。


MinGW
          MinGW【3】是Minimalist GNU for
 Windows的缩写。它是一个可自由使用和自由发布的Windows特定头文件和使用GNU工具集导入库的集合，允许你在 GNU/Linux 和 Windows平台生成本地的Windows程序而不需要第三方C运行时库。我们在Windows上编译OpenBLAS需要用到此工具。


OpenBLAS
          OpenBLAS【2】是由中科院的张先轶开发的一个开源的优化的BLAS库，配合Armadillo使用效果更佳。




How to install?



Armadillo 
         在 Armadillo官网下载喜欢的版本，然后解压到目录%ARMADILLO_HOME%。里边的
 include文件夹以后要用到。此外，example里会包含一个例子。笔者下载的版本包含的例子是基于64位平台开发的。由于电脑系统为32位且后续配置均基于32位，故无法运行此实例。若有读者发现32位机器上也可配置并运行成功，请不吝赐教，谢谢。
          此外，你有可能需要检查一下%ARMADILLO_HOME%\include\armadillo_bits\config.hpp，把   

#define ARMA_USE_LAPACK #define ARMA_USE_BLAS

前的注释符号去掉使这两句话生效，表明要用到LAPACK和BLAS库。






MinGW
          在MinGW官网下载安装工具，之后直接双击即可进行安装。安装过程中最好选择所有组件，不然后续会缺东西。有什么问题看下readme即可。需要处理的一点是搜一下gcc
 、make.exe路径并加入环境变量，如笔者的%MINGW_HOME%\msys\1.0。
           然后cmd用 gcc -v 确认一下gcc版本高于4.7。否则按此更改。



OpenBLAS
          在 OpenBLAS官网下载喜欢的版本，然后解压到目录%OPENBLAS_HOME%。



cmd打开%OPENBLAS_HOME%，make一下（需要很长时间，笔者用了两三个小时）。完事了


make PREFIX=/yourhome/OpenBLAS install  



此时在/yourhome/OpenBLAS中出现include和lib和bin三个目录，我们关注的是lib这个目录（注意lib中包含libopenblas.lb,否则还需要将dll转成lib）。

当然，可能你下载的OpenBLAS根本就不能make，那么恭喜你，你可以直接找到dll把其变为lib即可。同样参照这篇文章。



Can you give a test?


          一切就绪后，我们给个小例子测试一下。新建项目，加入以下源文件，配置项目属性。


          在VC++目录的包含目录中加入%ARMADILLO_HOME%\include，库目录中加入/yourhome/OpenBLAS/lib,链接器的输入附加依赖项添加libopenblas.lib,运气好的话就能使了。不过要注意配置平台与运行平台的匹配。





Where do the above come from?


[1]http://arma.sourceforge.net/
[2]http://www.openblas.net/

[3]http://www.mingw.org/

[4]https://github.com/xianyi/OpenBLAS/wiki/How-to-use-OpenBLAS-in-Microsoft-Visual-Studio

[5]http://blog.csdn.net/ldd530314297/article/details/41328951







版权声明：本文为博主原创文章，未经博主允许不得转载。

Android移动后端服务(BAAS)快速搭建后台服务器之Bmob-android学习之旅(75)
个人移动开发者的最头疼的问题,就是App的网络后台,包含数据库等,国外目前有比较成熟的解决方案,但是限制于墙的问题,推荐国内的解决方案,比较出名的是Bmob和AVOS cloud和Atom等,这一次我们重点介绍Bmob
使用步骤
1.下载android SDK,里卖包括一个简单的demo和Bmob的两个jar包,可能还有一些Okhttp这类的Jar包,只需要把和Bmob相关的jar包复制到app底下的libs下
2.android studio下需要邮件app项目,打开module setting,选中dependency,电击右上角的加号,选择从文件添加,找到libs下面的jar包,依次加入
3.打开快速开发文档,在manifest里面导入需要的权限,注意javaBean需要继承BmobObjext,这个类封装了网络操作像在本地一样执行存贮然后,在activity里面初始化
4.还有不懂的看demo和开发文档,左边栏是导航很清楚
Bmob的数据库和后台推送,以及短信和app网页这些技术很好,我仅仅使用了数据库的功能
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
下面简要介绍我的demo,是一个和手台数据库交互的登陆系统,包括注册和登陆界面,会有各种的输入检查,包括手机号是否重复,密码和再次输入的密码是否一致,是否为空等,注册后的信息存放在数据库,登陆成功后进入一个空的Activity,显示Toast登陆成功
废话不多说,代码如下
登陆类代码
package com.example.euler_kalvinhe.bmobtest;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import java.util.List;

import cn.bmob.v3.Bmob;
import cn.bmob.v3.BmobQuery;
import cn.bmob.v3.listener.FindListener;

/**
 * Created by Euler-KalvinHe on 2015/8/24.
 */
public class LoginActivity extends Activity {
    private EditText userName,password;
    private Button login,regeter;
    String username,pass;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.login);
        initViews();
        Toast.makeText(LoginActivity.this,username+pass,Toast.LENGTH_LONG).show();
        Bmob.initialize(this, "79bda8edfbabc323575348b6d50508e6");
        login.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                username = userName.getText().toString();
                pass = password.getText().toString();
                BmobQuery<User> query = new BmobQuery<User>();
                query.addWhereEqualTo("userName",username);
                query.findObjects(LoginActivity.this,new FindListener<User>() {
                    @Override
                    public void onSuccess(List<User> users) {
                        String str = null;
                        str = users.get(0).getPassword();
                        if (str.equals(pass)){
                            Intent intent = new Intent(LoginActivity.this,OutActivity.class);
                            startActivity(intent);
                        }else{
                            Toast.makeText(LoginActivity.this,"用户名或者密码不正确",Toast.LENGTH_LONG).show();
                        }
                       // Toast.makeText(LoginActivity.this,str,Toast.LENGTH_LONG).show();
                    }

                    @Override
                    public void onError(int i, String s) {
                        Toast.makeText(LoginActivity.this,"登录失败",Toast.LENGTH_LONG).show();
                    }
                });
            }
        });
        regeter.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(LoginActivity.this,RegesterActivity.class);
                startActivity(intent);
                finish();
            }
        });
    }
    private void initViews(){
        userName = (EditText) findViewById(R.id.userName);
        login = (Button) findViewById(R.id.log);
        password = (EditText) findViewById(R.id.password);
        regeter = (Button) findViewById(R.id.regester);
    }
    private void logIn(){
        username = userName.getText().toString();
        pass = password.getText().toString();

    }
    private String queryPass(String username){
        final String[] passTwo = {null};
        if (username == null){
            return null;
        }
        BmobQuery<User> query = new BmobQuery<User>();
        query.addWhereEqualTo("userName",username);
        query.findObjects(LoginActivity.this,new FindListener<User>() {
            @Override
            public void onSuccess(List<User> users) {
                passTwo[0] = users.get(0).getPassword();
                Toast.makeText(LoginActivity.this,passTwo[0],Toast.LENGTH_LONG).show();
            }

            @Override
            public void onError(int i, String s) {
                Toast.makeText(LoginActivity.this,"登录失败",Toast.LENGTH_LONG).show();
            }
        });
        return passTwo[0];
    }
}

注册类代码
package com.example.euler_kalvinhe.bmobtest;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import java.util.List;

import cn.bmob.v3.Bmob;
import cn.bmob.v3.BmobQuery;
import cn.bmob.v3.listener.FindListener;
import cn.bmob.v3.listener.SaveListener;


public class RegesterActivity extends Activity{
    private EditText userName, phoneNumber, password, passwordAgain;
    private Button regester,login;
    private String username,pass,passAgain;
    private String phone;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.regester);
        initViews();
        Bmob.initialize(this, "79bda8edfbabc323575348b6d50508e6");
        regester.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                regesterUser();
            }
        });
        login.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(RegesterActivity.this,LoginActivity.class);
                startActivity(intent);
                finish();
            }
        });
    }

    private void initViews() {
        regester = (Button) findViewById(R.id.regester);
        passwordAgain = (EditText) findViewById(R.id.passwordAgain);
        password = (EditText) findViewById(R.id.password);
        phoneNumber = (EditText) findViewById(R.id.phoneNumber);
        userName = (EditText) findViewById(R.id.userName);
        login = (Button) findViewById(R.id.login);
    }
    private void regesterUser(){
        username = userName.getText().toString();
        pass = password.getText().toString();
        passAgain = passwordAgain.getText().toString();
        phone = phoneNumber.getText().toString();
        if (username != null && pass != null && password != null && phone != null ){
            if ( pass.equals(passAgain)){
            BmobQuery<User> query = new BmobQuery<User>();
            query.findObjects(RegesterActivity.this,new FindListener<User>() {
                @Override
                public void onSuccess(List<User> users) {
                    boolean flag = false;
                    for (User u:users){
                        if (phone.equals(u.getPhoneNumber())){
                            flag = true;
                            break;
                        }
                    }
                    if (flag){
                        phoneNumber.setText("");
                        Toast.makeText(RegesterActivity.this, "手机号已经被注册,请重试", Toast.LENGTH_LONG).show();
                    }else{
                        User user = new User();
                        user.setUserName(username);
                        user.setPassword(pass);
                        user.setPhoneNumber(phone);
                        user.save(RegesterActivity.this,new SaveListener() {
                            @Override
                            public void onSuccess() {
                                Toast.makeText(RegesterActivity.this,"注册成功",Toast.LENGTH_LONG).show();
                                Intent intent = new Intent(RegesterActivity.this,LoginActivity.class);
                                startActivity(intent);
                                finish();
                            }

                            @Override
                            public void onFailure(int i, String s) {
                                Toast.makeText(RegesterActivity.this,"注册失败",Toast.LENGTH_LONG).show();
                            }
                        });
                    }
                }

                @Override
                public void onError(int i, String s) {
                    Toast.makeText(RegesterActivity.this,"请检查网络重试",Toast.LENGTH_LONG).show();
                }
            });}else{
                password.setText("");
                passwordAgain.setText("");
                Toast.makeText(RegesterActivity.this,"密码不一致,请重试",Toast.LENGTH_LONG).show();
            }
        }else {
            userName.setText("");
            password.setText("");
            passwordAgain.setText("");
            phoneNumber.setText("");
            Toast.makeText(RegesterActivity.this,"不能为空",Toast.LENGTH_LONG).show();
        }
    }
}

javaBmob代码
package com.example.euler_kalvinhe.bmobtest;

import cn.bmob.v3.BmobObject;

/**
 * Created by Euler-KalvinHe on 2015/8/24.
 */
public class User extends BmobObject{
    private String userName;
    private String phoneNumber;
    private String password;

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

主类代码
package com.example.euler_kalvinhe.bmobtest;

import android.app.Activity;
import android.os.Bundle;
import android.widget.Toast;

/**
 * Created by Euler-KalvinHe on 2015/8/24.
 */
public class OutActivity extends Activity{
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toast.makeText(this,"登陆成功",Toast.LENGTH_LONG).show();
    }
}

布局代码
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">
    <EditText
        android:id="@+id/userName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="用户名"/>
    <EditText
        android:id="@+id/phoneNumber"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="电话号码"/>
    <EditText
        android:id="@+id/password"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="密码"/>
    <EditText
        android:id="@+id/passwordAgain"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="确认密码"/>
    <Button
    android:id="@+id/regester"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="注册"
    />
    <Button
        android:id="@+id/login"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="返回登录"
        />
</LinearLayout>
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">
    <EditText
        android:id="@+id/userName"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="用户名"/>
    <EditText
        android:id="@+id/password"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="密码"/>
    <Button
        android:id="@+id/log"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="登陆"
        />
    <Button
        android:id="@+id/regester"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="注册"
        />
</LinearLayout>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
github项目地址,大家可以去下载项目源码
https://github.com/fengsehng/BmobTest

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android studio添加jar包，三方源码library，以及so文件步骤
一  添加jar文件。
(1) 当你启动android studio后可能会出现如下两种界面(不包括你项目报错的情况，若报错可自行百度，解决)。当为第一种界面的时候，您需要点击图中箭头标注的地方，               将其切换到Project 目录结构下，也就是如图2所示。


图 1

图 2

(2) 接下来，在图2所示的界面依次找到  app  --->  libs 文件夹 ，然后，复制项目中所需的  .jar 文件，将其复制粘贴到libs文件夹下。会有 图3 提示，直接点击OK 即可。



图3
(3) 待到将所需的jar文件粘贴进去之后，会有如 图4 中的两种情况。图中红色标 1 的表示，虽然粘贴了，但是未给项目添加引用。红色标 2 的，已经给项目引用，可正常使
      用文件。



图 4


(4) 如图4 中的如何给项目添加引用呢，其实也很简单。步骤为    选中未引用jar文件 ---  >   jar文件上依次右键 --- > Add AS Library...（一般是倒数第二个），如图 5 所示



  图 5 


(5)
待选中Add As Library之后，会弹出 图6 所示界面，选择你所要导入的Module (在android studio中相当于Eclipse的Project)，若是当前有很多的modelu的话可在此选
        择需要给那个添加引用，若是只有一个的话，那么直接点击OK 即可 (确定后Android studio会重新编译一次)。



图 6 
(6) 出现如图7 所示界面，即代表添加 .jar 文件成功。接下来就可以愉快的编程了,啦啦啦  啦啦啦 啦啦啦 
。



图 7 


二   添加 .so 文件.
(1) 在android studio中添加so文件，不像eclipse中那么简单，但是也没有那么复杂。找到如 图8 所示的文件夹 ，按图中步骤所示依次选择，出现如 图9 中所示的界面输入
      要新建的文件夹的名称 jniLibs (注意 在这里这个文件夹的名称 必须是jniLibs  不能是其他的).输入名称之后，直接点击OK即可。
 

图 8 

图 9 

(2) 接下来，出现如 图10 所示界面 表明创建成功。咱们再进行下一步。


 
图 10

(3)  我在这里以，已有的视频解码的库为例子，(感兴趣的用户可以多尝试)。将已有的库直接连同CPU的型号标示文件夹一起复制粘贴到该文件夹下,弹出确认框的时候直接                点击OK 确认即可,最终的界面如 图11 所示。这样一个依赖库就添加完成了。


图 11


三   添加第三方源码Library 
1. 添加Eclipse编写的源码工程为引用类库。
(1) .依次选择  file ----> new ----> Import Module 如图  12 所示。



图 12


(2)  
选中之后 出现如 图13 所示界面  点击后面红色箭头 指向的部分  (注:有部分使用者的这块弹出框较小，导致箭头标记位置未能显示，手动拖动编辑框将位置调大点
便可正常显示);

图 13
(2)  接下来会弹出 一个项目选择框  依次找到自己的项目所在位置  然后选择就行 选择完成后点击OK即可，出现如图14所示. 点击next 即可(注意  这里的module名称不
能重复,若是选中的项目名称与已有的module重复，请自行修改 图14 中红色标记2位置的名称）。



图 14
(3)  图 15 所示直接 Finish 即可。接下来便是导入过程...（本界面只是询问是否用android studio的gradle编译器进行编辑，替换jar包，library的引用方式）。



图 15 

(4) 出现 如 图16 所示的界面即为 导入成功。接下来可以在项目中进行引用。图中左边为导入后的界面，右边为导入的一些log提示信息。



图 16
(5)  eclipse编写的项目导入讲解完毕了，下面讲解Android studio编写的项目引用为三方库的方法。


2  导入Android studio 编写的项目为三方库
(1、2)  与eclipse项目导入时的(1)(2)一致。
(3) 上面两步操作完成后，在选择项目的时候，如 图17 所示，选择Android studio 编写的项目下的某个module  而不是整个项目 这点大家切记  切记。(图中的1 相当于
eclipse的workspace  2 相当于eclipse的Project)。

图 17
(4)  当出现如 图18 所示的界面的时候，说明目前导入的module与已有的module名称重复了，修改目前需要导入的module名称即可,我在这里直接修改成了app2，接
下来直接点击 finish  即可。



图  18 



(5) 出现如 图19 所示界面表示导入成功了 。


  
图 19
四   如何在项目中，引用刚才添加的jar 文件 还有第三方源码库呢，也是很简单的。
1. 如图 20所示，将上面的标签栏切换到 Android下，会看到刚才引用的哪些，三方库都显示出来了，现在依据步骤，依次选择   app --- > app右键 ---->  Open Module
                Settings.



图 20
2.如 图21 所示  选择最后一个选项  Dependencies。

图 21


3. 到这步之后，点击如 图22 所示红色圈住的+，然后会弹出三个选项卡，其中 第一个 表示Android SDK中携带的类库  比如常用的V4 V7之类。  第二个 表示 打开项目所在
    的文件  在这里我们可以添加最早引用的libs目录下的 .jar 文件   第三个 表示的是 刚才最后引用的第三方开源库。
    

图 22 

(1) 添加 选项一 SDK类库界面 图23所示，选中后OK即可。

  图 23
(2)  添加 选项卡2 引用jar文件  如 图24 所示。
 
  图 24

(3)  添加选项卡 三  引用的三方开源库的引用  如图25所示。

图 25
4.待上面的引用添加完成之后  如 图26 所示，在这里 直接点击OK即可完成引用。

图 26


五   至此本篇博客就讲解完毕了，希望大家可以多交流，多提宝贵意见，谢谢。







版权声明：本文为博主原创文章，转载请注明出处，http://blog.csdn.net/hxy_blog 。喜欢的朋友可以加群 423939698。

【cocos2d-x 3.7 飞机大战】 决战南海I (七) 控制器的实现
        控制器中的功能并不多，主要是下面这些

//对玩家分数的操作
	CC_SYNTHESIZE_READONLY(SaveData *, m_saveData, SaveData);
	void update(float tm);

	//游戏暂停与恢复
	void menuPauseCallback(cocos2d::Ref* pSender);

	//声音控制
	void menuMusicCallback(cocos2d::Ref* pSender);


下面是这些功能的实现

bool Controller::init()
{
	if (!Layer::init())
	{
		return false;
	}

	bool bRect = false;
	
	do 
	{
		Size winSize = Director::getInstance()->getWinSize();

		//从xml文件中读取中文显示出来
		auto dictionary = Dictionary::createWithContentsOfFile("fonts/AboutMe.xml");
		score_label = Label::createWithTTF(
			((__String *)(dictionary->objectForKey("score")))->getCString(),
			"fonts/DFPShaoNvW5-GB.ttf",
			25);
		score_label->setPosition(score_label->getContentSize().width / 2,
			winSize.height - score_label->getContentSize().height * 2);
		CC_BREAK_IF(!score_label);

		this->addChild(score_label);

		//添加显示分数的标签
		m_saveData = SaveData::create();
		//这里一定要retain一下saveData，在析构函数中release一下
		m_saveData->retain();
		auto str = __String::createWithFormat("%d", m_saveData->getScore());
		m_score = Label::createWithTTF(str->getCString(), "fonts/DFPShaoNvW5-GB.ttf", 25);
		m_score->setPosition(Point(score_label->getContentSize().width + m_score->getContentSize().width / 2 + 30,
			winSize.height - score_label->getContentSize().height * 2));
		CC_BREAK_IF(!m_score);

		this->addChild(m_score);
		//记得更新分数的显示
		this->scheduleUpdate();

		//游戏声音控制按钮
		Sprite *normalMusic = Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_musicPause.png"));
		Sprite *pressedMusic = Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_musicPause.png"));
		pMusicItem = MenuItemSprite::create(
			normalMusic,
			normalMusic,
			NULL,
			CC_CALLBACK_1(Controller::menuMusicCallback, this));


		//游戏暂停按钮
		Sprite *normalPause = Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_resume_nor.png"));
		Sprite *pressedPause = Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_resume_pressed.png"));
		pPauseItem = MenuItemSprite::create(
			normalPause,
			pressedPause,
			NULL,
			CC_CALLBACK_1(Controller::menuPauseCallback, this));

		Menu *menuPause = Menu::create(pMusicItem,pPauseItem, NULL);
		menuPause->alignItemsHorizontallyWithPadding(pPauseItem->getContentSize().width/2);
		menuPause->setPosition(
			Point(winSize.width - pPauseItem->getContentSize().width*2, winSize.height - normalPause->getContentSize().height));
		this->addChild(menuPause);

	} while (0);

	return true;
}

//游戏暂停
void Controller::menuPauseCallback(cocos2d::Ref* pSender)
{
	CocosDenshion::SimpleAudioEngine::getInstance()->playEffect("sound/button.mp3");
	if (!Director::getInstance()->isPaused())
	{
		// 图标状态设置
		pPauseItem->setNormalImage(Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_pause_nor.png")));
		pPauseItem->setSelectedImage(Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_pause_press.png")));
		CocosDenshion::SimpleAudioEngine::getInstance()->pauseBackgroundMusic(); // 停止背景音乐
		CocosDenshion::SimpleAudioEngine::getInstance()->stopAllEffects(); // 停止所有的特效
		Director::getInstance()->pause(); // 停止所有的动作，敌机飞行，子弹前进等
	}
	else
	{
		pPauseItem->setNormalImage(Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_resume_nor.png")));
		pPauseItem->setSelectedImage(Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_resume_pressed.png")));
		CocosDenshion::SimpleAudioEngine::getInstance()->resumeBackgroundMusic();// 恢复
		Director::getInstance()->resume(); // 恢复
	}
}

void Controller::menuMusicCallback(cocos2d::Ref* pSender)
{
	CocosDenshion::SimpleAudioEngine::getInstance()->playEffect("sound/button.mp3");
	if (CocosDenshion::SimpleAudioEngine::getInstance()->isBackgroundMusicPlaying())
	{
		// 图标状态设置
		pMusicItem->setNormalImage(Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_music.png")));
		pMusicItem->setSelectedImage(Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_music.png")));
		CocosDenshion::SimpleAudioEngine::getInstance()->stopBackgroundMusic(); // 停止背景音乐
//		CocosDenshion::SimpleAudioEngine::getInstance()->stopAllEffects(); // 停止所有的特效
	}
	else
	{
		pMusicItem->setNormalImage(Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_musicPause.png")));
		pMusicItem->setSelectedImage(Sprite::createWithSpriteFrame(SpriteFrameCache::getInstance()->getSpriteFrameByName("game_musicPause.png")));
		CocosDenshion::SimpleAudioEngine::getInstance()->playBackgroundMusic("sound/BackgroundMusic.mp3", true);// 恢复
//		CocosDenshion::SimpleAudioEngine::getInstance()->resumeAllEffects();
	}
}


void Controller::update(float tm)
{
	auto str = __String::createWithFormat("%d", m_saveData->getScore());
	//更新分数和坐标
	m_score->setColor(Color3B(255, 0, 0));
	m_score->setString(str->getCString());
	m_score->setPositionX(score_label->getContentSize().width + m_score->getContentSize().width / 2 + 30);
}


要实现游戏的暂停功能，可以直接将当前运行的场景暂停，而要实现声音的暂停，通过简单的停止背景音乐、音效却不行。因为不断有新的子弹在发射、新的敌机在爆炸等。所以，我使用的方法是 将背景音乐与其他音效绑定。


比如下面子弹类中的代码

if (CocosDenshion::SimpleAudioEngine::getInstance()->isBackgroundMusicPlaying())
	{
		CocosDenshion::SimpleAudioEngine::getInstance()->playEffect("sound/bullet.wav");
	}



只有背景音乐处于播放状态，音效才会播放。
虽然功能实现了，不过总感觉方法太水了。。。谁有更好的方式欢迎告知。





版权声明：本文为博主原创文章，未经博主允许不得转载。

Conversion to Dalvik format failed: Unable to execute dex: GC overhead limit exceeded异常解决


在运行工程的时候，Eclipse长时间停留在100%那个进度。 最后报错
Unable to execute dex: GC overhead limit exceeded
Conversion to Dalvik format failed: Unable to execute dex: GC overhead limit exceeded

解决方案： 设置Xms为512 和1024  在eclipse的目录下的eclipse.ini文件中改


openFile
--launcher.XXMaxPermSize
512M
-showsplash
org.eclipse.platform
--launcher.XXMaxPermSize
512m
--launcher.defaultAction
openFile
-vmargs
-Dosgi.requiredJavaVersion=1.5
-Xms512m
-Xmx1024m
要是还是不行，网上 的解决方案

最近做厂商适配，厂商提供了一部分Framework的jar包，把jar包通过Add Jar放到Build Path中， 在生成APK过程中，Eclipse长时间停留在100%那个进度。将厂商的Jar 添加user Library,并把as system Library选上，并引入工程：      建立User Library：Windows->Preference->Java->Build Path->User Library,
 New and Add Jars      添加User Library 到工程：Project->Properties->Java Build Path->Libraries->Add Library->User Library   Build 运行正常了。


版权声明：本文为博主原创文章，未经博主允许不得转载。

NSRegularExpression的使用，获取所有符合条件的结果

开发中用到检索字符串，并获取获取符合条件的字符串数组。
网上找了下，可以利用正则表达式完成，结果是个数组，数组元素是NSTextCheckingResult。
效果不错，小记一下。
 
直接看示例代码

NSString *str = @"ddididd{{{didd}}diid";
NSString *regexStr = @"d[i]+d";
NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:regexStr options:0 error:nil];
NSArray *matches = [regex matchesInString:str options:0 range:NSMakeRange(0, str.length)];
for (NSTextCheckingResult* match in matches)
{
    NSRange range = match.range;
    NSString  *temp = [str substringWithRange:range];
    NSLog(@"RESULT===%@",temp);
}

执行结果


2015-08-24 18:49:32.234 test02[16720:2141808] RESULT===did
2015-08-24 18:49:32.235 test02[16720:2141808] RESULT===did
2015-08-24 18:49:32.235 test02[16720:2141808] RESULT===diid



版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS之弹幕效果

弹幕效果展示：






步骤： 
1. 
在AppDelegate类里面创建一个视图控制器，并把创建的视图控制器放入父视图中。 
其中关于用[self.window addSubview:viewController.view] 
和self.window.rootViewController = viewController;请看我的上一篇文章：http://blog.csdn.net/u012989536/article/details/47979875

2. 
然后的步骤就需要我们好好地思考一下，做任何一件事都要做好计划，首先要确定要在我们创建的视图里面添加label 标签：设置标签的颜色这里不过多说。代码有注释。 

值得注意的是，我们的标签是并不是一个。而是一些标签进行循环的滚动，怎么达到这个效果呢。首先我们不能直接在viewDidLoad里面直接创建，以为这样不利于重复的生成，我们应该把它写在一个函数里面，以有利于我们调用。。于是有了这样一段代码：
//需要改变的三个地方，label :文本颜色，位置，文本的内容。
-(void)initDate
{
    ///只要有肉眼能看到的视图，都是以ui开头的
    //实例化一个标签，（用于现实文字）
    UILabel *label = [[UILabel alloc]init];
    //指定位置和大小。
    label.frame =CGRectMake(480, rand()%290, 250, 30);
    label.text = @“hello world”;
    label.textColor = [UIColor redColor];
    //将label加入本视图中去。
    [self.view addSubview:label];

}
*3. 
然后我们应该调用一个每隔一段时间就会产生一个label标签的方法。这样


- (void)viewDidLoad
{
    [super viewDidLoad];

    //设置一个计时器，每隔一段时间就会产生一个label
    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(initDate) userInfo:nil repeats:YES];

}


4.

做到这个步骤，我们就能够看出一些效果，因为label会不停的增加。那怎么让它滚动起来呢？ 

这时候就需要我们写一个move的方法，来控制label的移动。这时候就会用到UIView 的animateWithDuration 
方法：

（1）：首先我们可以新建一个plist文件，用来存储需要显示的label，plist最好格式为数组类型的。 
（2）：然后定义一个数组。用来存储plist里面的数据，并创建一个NSSstring类型的字符串用来接受。然后label以字符串的形式进行显示到view上面：代码如下：
//需要改变的三个地方，label :文本颜色，位置，文本的内容。
-(void)initDate
{
    NSString *str = [array objectAtIndex:rand()%array.count];
    ///只要有肉眼能看到的视图，都是以ui开头的
    //实例化一个标签，（用于现实文字）
    UILabel *label = [[UILabel alloc]init];
    //指定位置和大小。
    label.frame =CGRectMake(480, rand()%290, 250, 30);
    label.text = str;
    label.textColor = [UIColor randomColor];
    //将label加入本视图中去。
    [self.view addSubview:label];
    //让生成的label传入下面的move函数中去。
    [self move:label];
}

-(void)move:(UILabel*)_label
{
    [UIView animateWithDuration:5 animations:^{
        _label.frame = CGRectMake(-250, _label.frame.origin.y, _label.frame.size.width, _label.frame.size.height);
    } completion:^(BOOL finished) {
        [_label removeFromSuperview];
    }
     ];
}
//从这个方法开始添加（装修）视图已经加载到内存中。
- (void)viewDidLoad
{
    [super viewDidLoad];

    //读取plist文件
    NSString *path = [[NSBundle mainBundle ]pathForResource:@"弹幕" ofType:@"plist"];
    array = [[NSArray alloc]initWithContentsOfFile:path];

    //设置一个计时器，每隔一段时间就会产生一个label
    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(initDate) userInfo:nil repeats:YES];

}


（3）：为了程序的健全性，我们让每一个产生出来的label的文本拥有不同的颜色，方法：新建一个UIColor的分类文件，然后写一个颜色不断改变的方法：

+ (UIColor *)randomColor
{
    /*
     颜色有两种表现形式 RGB RGBA
     RGB 24
     R,G,B每个颜色通道8位
     8的二进制 255
     R,G,B每个颜色取值 0 ~255
     120 / 255.0

     */
    CGFloat r = arc4random_uniform(256) / 255.0;
    CGFloat g = arc4random_uniform(256) / 255.0;
    CGFloat b = arc4random_uniform(256) / 255.0;

    return [UIColor colorWithRed:r green:g blue:b alpha:1];
}


注意：由于没生成一个label都会占用内存空间，所有，一定要生成后的释放工作，不然，长时间运行程序，内存会被占用的越来越多。


版权声明：本文为博主原创文章，未经博主允许不得转载。

智能硬件时代来临，哪款智能手表是你的菜?
　
　　近两年来智能手表、智能手环等智能穿戴产品如雨后春笋般出现，如果说2014是智能手表的元年，那么2015年是会不会是井喷的一年呢?依目前情况趋势看，2015年智能穿戴产品市场用百家争鸣，争奇斗艳来形容一点也不为过。提到智能手表，可能有些人首先想到的就是Apple Watch，自2015年4月上市以来就引发了智能手表爱好的极大关注。但从2588到12万元不等的价钱让我等非土豪之辈望而却步。


　　自智能手表诞生以来，在这个流行“颠覆”概念的年代，它被很多人寄予颠覆传统手表开启智能可穿戴设备时代的厚望。既然提到颠覆，就会出现无数创业者狂热追随的场景，大量厂商忙着布局卡位，智能手表成了科技领域中的“宠儿”，VC们争相追逐的对象……问题是，智能手表真的能撑起智能可穿戴设备的未来吗?市场调研机构Gartner预测,2016年智能手表份额将达到可穿戴设备的40%。全球可穿戴设备销售额将从2012年的97亿美元增长到2018年的336亿美元,年均复合增长率高达22.9%。而在中国，智能可穿戴设备市场规模今年有望突破135亿元，2016年将突破228亿元规模。
　　瑞士商业媒体日前发布的一份名为“全球智能手表业最有创新力企业”榜单上，苹果、谷歌、三星、小米、摩托罗拉/联想、Jawbone、LG、Garmin、Fitbit、inWatch位列全球榜单的前十名。今年以来,苹果、三星、华为、小米等产业巨头，纷纷发布自己的智能手表战略，以期在新兴的智能可穿戴设备市场，抢占市场先机。
　　国内智能手表品牌占有率


　　目前智能手表的功能同质化问题比较严重，大部分智能手表支持的功能如下：
　　1、可以实时收发短信，邮件，支持手机通知、日历、时钟和来电提示。
　　2、支持发微博，聊QQ，聊微信，看新闻等社交及简单阅读功能。
　　3、健康检测功能，如日常活动跟踪、睡眠跟踪、心率监控、计步器、测血压等。
　　4、还提供诸如指南针、秒表、照相控制、音乐播放控制、主题选择等附加功能。
　　5、时间天气实时查询，不仅可以查看天气状况，还可以查看污染指数;
　　现阶段智能手表难以满足消费者的刚性需求。智能手机的出现已经满足了我们对通信、社交与娱乐的需求。反观智能手表，仅凭简单的通知推送、健康监测等功能显然无法解决所有消费者的痛点，从而沦为高档奢侈的耍(zhuang)酷(bi)玩具，而非生活所必需。此外，刚性需求的缺失也使得智能手表与智能手环的市场定位重叠度过高。在功能上，二者几乎都能做到时间显示与健康监测;但在价格上，智能手表和智能手环的价钱相差悬殊，甚至市场中还出现了不足百元的智能手环来搅局，比如小米手环只售79元。那么，对于绝大多数消费者而言，一部几十元，上百元的智能手环就能满足所有需求，又何必动辄几百元，上千元购买智能手表呢?
　　包括智能手表在内，各种智能穿戴产品出现在我们生活中。作为智能穿戴产品开发的核心技术：嵌入式开发，已经被广泛应用开来。华清远见(www.hqyj.com)研发中心技术总监刘洪涛表示：“提升传感器精度、开发新型电池、增加更多智能化服务是智能手表厂商采取下一步战略布局的重中之重。华清远见在2014年底就研发了出了一款智能手表产品，并已将其作为研发案例应用到实际教学中去。可穿戴设备发展至今不足5年，相比于智能手机，智能手表仍有充足的市场空间。”
　　市场上在售的智能手表，大多或强调精密的制造技术，或强调移动互联技术应用，或强调智能服务和云服务等概念。面对各类形形色色，功能不尽相同，不同价格的智能手表，哪一款才是你的最爱?作为一名普通消费者，你对智能手表又有哪些期待呢?各大厂商互相厮杀，谁将笑傲群雄、一统江湖?让我们一起拭目以待。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Alcatraz：管理Xcode插件


简介

Alcatraz是一个帮你管理Xcode插件、模版以及颜色配置的工具。它可以直接集成到Xcode的图形界面中，让你感觉就像在使用Xcode自带的功能一样。

安装和删除

使用如下的命令行来安装Alcatraz：






1
2



mkdir -p ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins;
curl -L http://git.io/lOQWeA | tar xvz -C ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins







如果你不想使用Alcatraz了，可以使用如下命令来删除：






1
2



rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin
rm -rf ~/Library/Application\ Support/Alcatraz







使用

安装成功后重启Xcode，就可以在Xcode的顶部菜单中找到Alcatraz，如下所示：



点击“Package Manager”，即可启动插件列表页面，如下所示：



之后你可以在右上角搜索插件，对于想安装的插件，点击其左边的图标，即可下载安装，如下所示，我正在安装KImageNamed插件：



安装完成后，再次点击插件左边的图标，可以将该插件删除。

插件路径

Xcode所有的插件都安装在目录~/Library/Application
 Support/Developer/Shared/Xcode/Plug-ins/下，你也可以手工切换到这个目录来删除插件。

关于Xcode的插件机制

Alcatraz当前只支持OSX 10.9 and Xcode 5。不要抱怨了，这其实主要是因为苹果并没有开放插件机制，每次升级Alcatraz都都要重新适配。如果你看Alcatraz的Commit Log，你就会发现，Alcatraz花了几个月时间，才适配到Xcode 5，这对于插件开发者来说，是比较难受的。

所以作为一款开源并且免费的插件，只支持最新版的Xcode可以让开源作者节省大量精力。我也希望苹果能早日开放Xcode的插件机制标准，方便广大的插件开发者构建强大的第三方增强工具。

推荐的插件

我个人比较喜欢XCode的vim插件XVim，微博里大家推荐过的还有KImageNamed插件，Alcatraz里面应该好用的插件很多，我还没有时间试用。

这儿有一些朋友整理的插件列表：《那些不能错过的Xcode插件》

如要你发现好用的插件，欢迎在留言处回复告诉我，我可以推荐给大家。谢谢～

插件开发

如果你觉得自己很牛逼，想尝试开发插件，这儿有一些教程：


《Xcode5 Plugins 开发简介》
《Xcode 4 插件制作入门》
《写个自己的Xcode4插件》











最新的安装方法


I want to submit my package!
Fork and edit the Alcatraz package repository to include your package name, description, and URL in the plugins, color schemes, or templates section, and submit a pull request.
{
  "name": "Excellent-Plugin",
  "url": "https://github.com/me/xcode-excellent-plugin",
  "description": "Makes Xcode stop, collaborate and listen."
}
    
Install
Paste this into your terminal:
curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | sh

Alcatraz is available for OSX 10.9+ and Xcode 5+ only.
Uninstall
Delete the plugin:
rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin
Remove all cached data:
rm -rf ~/Library/Application\ Support/Alcatraz
官网地址：http://alcatraz.io/


版权声明：本文为博主原创文章，未经博主允许不得转载。

kvc和kvo的使用情况的了解

了解cocoa：Cocoa是苹果公司为Mac OS X所创建的原生面向对象的API，是Mac OS X上五大API之一（其它四个是Carbon、POSIX、X11和Java）。
苹果的面向对象开发框架，用来生成 Mac OS X 的应用程序。主要的开发语言为 Objective-c, 一个c 的超集。
即为：Coroa 基本面向原生的API抽象，是C的一个超级。


在Cocoa中是以被万物之源NSObject类实现的NSKeyValueCoding（键值编码）/（键值观察）NSKeyValueObserving 非正式协议 的形式被定义为基础框架的一部分。=
NSKeyValueCoding 是一个非正式的协议。（线管的内容可以看西面罗列的方法）

KVC/KVO实现的根本是Objective-C的 动态性和runtime
KVC/KVO机制离不开访问器方法的实现。 

kvc
类似c++中的map类的使用。
它提供了一种使用“字符串”而不是“访问器（方法）”方法去访问一个对象实例变量的机制。
kvo  
提供了一种当其它对象属性被修改的时候能通知当前对象的机制.
KVO机制很适合实现model和controller类之间的通讯。

总结所有的方法几乎可以使用下面的四个方法为代表。

//一般的都是这几个方法
<span style="color:#990000;">- (id)valueForKey:(NSString *)key;
- (void)setValue:(id)value forKey:(NSString *)key;</span>
Key——>键值 ， 就是要访问的属性名称（key）对应的字符串。（用数组（索引）的方式似乎没有什么区别）

<span style="color:#CC0000;">- (id)valueForKeyPath:(NSString *)keyPath;
- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;</span>
后面的KeyPath是一个被点操作符隔开的用于访问对象的指定属性的字符串序列。（keypath 就是大范围到小范围逐渐到具体的地方）
eg：eyPath address.street将会访问消息接收对象所包含的address属性中包含的一个street属性。
其实KeyPath说白了就是我们平时使用点操作访问某个对象的属性时所写的那个字符串。



点语法和kvc之间的差别：
在实现了访问器方法的类中，使用点语法和KVC访问对象其实差别不大，二者可以任意混用。但是没有访问起方法的类中，点语法无法使用，这时KVC就有优势了。（ 原因见第三部分的第一节：KVC如何访问属性值。 ） ？？

一对多的关系：（数据中经常会存在）
 ①间接操作
先通过KVC方法取到集合属性，然后通过集合属性操作集合中的元素。 
 ②直接操作 （基本上是不适用）
 
 4、键值验证（Key-Value Validation）
KVC提供了验证Key对应的Value是否可用的方法：
- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;

该方法默认的实现是调用一个如下格式的方法：
- (BOOL)validate<Key>:error:

比如属性name对应的方法为：
-(BOOL)validateName:(id *)ioValue error:(NSError * __autoreleasing *)outError {
    return ;
}

KVC是不会自动调用键值验证方法的 ，就是说我们需要手动验证。但是有些技术，比如CoreData会自动调用。 

 5、KVC对数值和结构体型属性的支持 

 总结一下，想使用KVO有三种方法：
1)使用了KVC
使用了KVC，如果有访问器方法，则运行时会在访问器方法中调用 will/didChangeValueForKey:方法；
没用访问器方法，运行时会在setValue:forKey方法中调用 will/didChangeValueForKey:方法。
2)有访问器方法
运行时会重写访问器方法调用 will/didChangeValueForKey:方法。
因此，直接调用访问器方法改变属性值时，KVO也能监听到。
3)显示调用will/didChangeValueForKey:方法。
总之，想使用KVO，只要有 will/didChangeValueForKey:方法就可以了。
③ _isKVOA
这个私有方法估计是用来标示该类是一个 KVO 机制声称的类。


优点和缺点
1、优点
①可以再很大程度上简化代码
例子网上很多，这就不举了
②能跟脚本语言很好的配合
才疏学浅，没学过AppleScript等脚本语言，所以没能深刻体会到该优点。
2、缺点
KVC的缺点不明显，主要的kvo的缺点如连接：http://www.mikeash.com/pyblog/key-value-observing-done-right.html
核心思想是说KVO的回调机制，不能传一个selector或者block作为回调，而必须重写-addObserver:forKeyPath:options:context:方法所引发的一系列问题。问了解决这个问题，作者还亲自实现了一个MAKVONotificationCenter类，代码见github:
https://github.com/mikeash/MAKVONotificationCenter
不过个人认为这只是苹果做的KVO不够完美，不能算是缺陷。 


关于NSKeyValueCoding.h这个文件爱你的属性的了解。


#import <Foundation/NSArray.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSOrderedSet.h>
#import <Foundation/NSSet.h>

@class NSError, NSString;

FOUNDATION_EXPORT NSString *const NSUndefinedKeyException;
FOUNDATION_EXPORT NSString *const NSAverageKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSCountKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSDistinctUnionOfArraysKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSDistinctUnionOfObjectsKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSDistinctUnionOfSetsKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSMaximumKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSMinimumKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSSumKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSUnionOfArraysKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSUnionOfObjectsKeyValueOperator;
FOUNDATION_EXPORT NSString *const NSUnionOfSetsKeyValueOperator;

@interface NSObject(NSKeyValueCoding)

+ (BOOL)accessInstanceVariablesDirectly;
- (id)valueForKey:(NSString *)key;
- (void)setValue:(id)value forKey:(NSString *)key;
- (BOOL)validateValue:(inout id *)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;
- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;
- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key NS_AVAILABLE(10_7, 5_0);
- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;

- (id)valueForKeyPath:(NSString *)keyPath; //这个是有关路径的字符串，这个是怎么用的？

- (void)setValue:(id)value forKeyPath:(NSString *)keyPath;
- (BOOL)validateValue:(inout id *)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;

- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;
- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath NS_AVAILABLE(10_7, 5_0);
- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;
- (id)valueForUndefinedKey:(NSString *)key;
- (void)setValue:(id)value forUndefinedKey:(NSString *)key;
- (void)setNilValueForKey:(NSString *)key;
- (NSDictionary *)dictionaryWithValuesForKeys:(NSArray *)keys;
- (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues;
@end

//定的数组
@interface NSArray(NSKeyValueCoding)
- (id)valueForKey:(NSString *)key;
- (void)setValue:(id)value forKey:(NSString *)key;
@end

//字典的两种方式进行组合
@interface NSDictionary(NSKeyValueCoding)
- (id)valueForKey:(NSString *)key;
@end
@interface NSMutableDictionary(NSKeyValueCoding)
- (void)setValue:(id)value forKey:(NSString *)key;
@end

@interface NSOrderedSet(NSKeyValueCoding)
- (id)valueForKey:(NSString *)key;
- (void)setValue:(id)value forKey:(NSString *)key;
@end

@interface NSSet(NSKeyValueCoding)
- (id)valueForKey:(NSString *)key;
- (void)setValue:(id)value forKey:(NSString *)key;
@end

#if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE))
//TARGET_OS_EMBEDDED这个表示是嵌入式的方式
//TARGET_OS_IPHONE iphone 开发
//TARGET_OS_MAC os系统开发

@interface NSObject(NSDeprecatedKeyValueCoding)
+ (BOOL)useStoredAccessor ;
- (id)storedValueForKey:(NSString *)key ;
- (void)takeStoredValue:(id)value forKey:(NSString *)key;
- (void)takeValue:(id)value forKey:(NSString *)key ;
- (void)takeValue:(id)value forKeyPath:(NSString *)keyPath ;
- (id)handleQueryWithUnboundKey:(NSString *)key;
- (void)handleTakeValue:(id)value forUnboundKey:(NSString *)key;
- (void)unableToSetNilForKey:(NSString *)key;
- (NSDictionary *)valuesForKeys:(NSArray *)keys ;
- (void)takeValuesFromDictionary:(NSDictionary *)properties;

@end
#endif










版权声明：本文为博主原创文章，未经博主允许不得转载。

STM32 TIM测 输入信号的 频率
说 不进中断 等等基本功能没实现ok的，查看： 
STM32 外设配置关键步骤 
务必仔细瞅瞅…
TIM输入捕获简介
TIM输入捕获两种模式： 
 1. PWM输入模式 
 2. 输入捕获模式

调试记录
PWM输入模式:
该模式的理解： 
stm32的PWM输入捕获模式
仅适用于通道1、 2 
从输入捕获中断说起… 
从TIM3 CH1输入信号，
..............
  if(TIM_GetITStatus(TIM3,TIM_IT_CC1) == SET) //
  {
    ic1 = TIM_GetCapture1(TIM3)+1;  //周期
    ic2 = TIM_GetCapture2(TIM3)+1; //脉冲宽度
    float pulse = ic2 /(float)ic1; //占空比
    FAN_Frequency = (u32)1000000 /ic1; //频率
  }
  //TIM_SetCounter(TIM3,0);
  TIM_ClearFlag(TIM3,TIM_FLAG_CC1);
  TIM_ClearITPendingBit(TIM3,TIM_IT_CC1);//清楚TIM的中断待处理位
  ..........
注： 
 - 计数器从0计数，需要+1处理； 
 - “FAN_Frequency = (u32)1000000 /ic1;”  的1000000，取自基时钟72分频以后的时钟频率，为1M。如：进行配置，取72M；36分频，取2M；
外设TIM3配置： 
捕获法
void TIM3_Configuration(void)
{
...
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);
  GPIO_PinRemapConfig(GPIO_FullRemap_TIM3,ENABLE);

  TIM_InternalClockConfig(TIM3);
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Prescaler = 72-1; 
  TIM_TimeBaseStructure.TIM_Period = 0xffff;
  TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; 
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

  TIM_ICInitTypeDef TIM_ICInitStructure;
  TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; 
  TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; 
  TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
  TIM_ICInitStructure.TIM_ICFilter = 0x00;
  //TIM_ICInit(TIM3, &TIM_ICInitStructure);
  TIM_PWMIConfig(TIM3, &TIM_ICInitStructure);   

  TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);
  TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);
  TIM_SelectMasterSlaveMode(TIM3, TIM_MasterSlaveMode_Enable); 
  .....
}
注： 
TIM_PWMIConfig(TIM3, &TIM_ICInitStructure);  //TIM_ICInitStructure参数的配置函数 
TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1); 
 TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset); 
 TIM_SelectMasterSlaveMode(TIM3, TIM_MasterSlaveMode_Enable); 
此四行代码为 PWM输入捕获模式标配； 
关于TIM_ICInitStructure参数的配置函数还有： 
TIM_ICInit(TIM3, &TIM_ICInitStructure); 
区别就是是否设置另外一个通道的/* Select the Opposite Input Polarity /和/ Select the Opposite Input */  反向捕获边沿、另一个择TIMx_CCRx的有效输入。这里将TIMx_CCR2有效输入选择至TI1上。 
只是测频率的话，无伤大雅。 
详见：数据手册 + 固件库源码。
输入捕获模式
适用于全部通道。 
TIM设置，代码注释贴上来都是乱码，就直接截图啦。 

这里使用TIM_ICInit(TIM3, &TIM_ICInitStructure);进行配置。
中断代码如下： 

以上仅供参考，多退少补…

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

百度定位Sdk 162错误解决方法之Android Studio
前言
此方法只针对开发环境是Android Studio


 查看百度开发文档 官方对162错误解释是：
162： 请求串密文解析失败。
 只是简单的说了一句， 完全不知道是什么错误
经过百度 大多数开发者的实战经验是so文件加载失败 。
经过验证确实是（我开发过程 遇到的162错误 也是so 文件加载失败，） 
找到原因了，下面介绍解决的办法


解决方法
1.在“src/main”目录中新建名为“jniLibs”的目录。

2.将so文件复制、粘贴到“jniLibs”目录内。



如下图所示





版权声明：本文为博主原创文章，未经博主允许不得转载。

Android布局特效（一）
public class MainActivity extends Activity {
AlphaAnimation animation_alpha;
RotateAnimation animation_rotate;
ScaleAnimation animation_scale;
TranslateAnimation animation_translate;
AnimationSet animationSet;
ImageView image;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		image=(ImageView)findViewById(R.id.imageview);
	//	image.setScaleType(ScaleType.FIT_XY);
		initAnimation();
	}
	private void initAnimation() {
		//透明度控制动画效果 alpha
		animation_alpha=new AlphaAnimation(0.1f,1.0f);
		//第一个参数fromAlpha为 动画开始时候透明度
		//第二个参数toAlpha为 动画结束时候透明度
		animation_alpha.setRepeatCount(-1);//设置循环
		animation_alpha.setDuration(5000);//设置时间持续时间为 5000毫秒
		
		// 旋转效果rotate
		animation_rotate = new RotateAnimation(0, -180,
				RotateAnimation.RELATIVE_TO_SELF, 0.5f,
				RotateAnimation.RELATIVE_TO_SELF, 0.5f);
		  //第一个参数fromDegrees为动画起始时的旋转角度 //第二个参数toDegrees为动画旋转到的角度
		  //第三个参数pivotXType为动画在X轴相对于物件位置类型 //第四个参数pivotXValue为动画相对于物件的X坐标的开始位置
		  //第五个参数pivotXType为动画在Y轴相对于物件位置类型 //第六个参数pivotYValue为动画相对于物件的Y坐标的开始位置
	//	animation_rotate.setRepeatCount(-1);
		animation_rotate.setDuration(3000);//设置时间持续时间为 5000毫秒
		
		//尺寸伸缩动画效果 scale
		animation_scale=new ScaleAnimation(0.1f,3.0f,0.1f,3.0f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
		//第一个参数fromX为动画起始时 X坐标上的伸缩尺寸    
		//第二个参数toX为动画结束时 X坐标上的伸缩尺寸     
		//第三个参数fromY为动画起始时Y坐标上的伸缩尺寸    
		//第四个参数toY为动画结束时Y坐标上的伸缩尺寸  
		/*说明:
		                    以上四种属性值    
		      0.0表示收缩到没有 
		      1.0表示正常无伸缩     
		                   值小于1.0表示收缩  
		                   值大于1.0表示放大
		*/
		//第五个参数pivotXType为动画在X轴相对于物件位置类型  
		//第六个参数pivotXValue为动画相对于物件的X坐标的开始位置
		//第七个参数pivotXType为动画在Y轴相对于物件位置类型   
		//第八个参数pivotYValue为动画相对于物件的Y坐标的开始位置
		animation_scale.setRepeatCount(-1);
		animation_scale.setDuration(5000);//设置时间持续时间为 5000毫秒
		
		//移动动画效果translate
		animation_translate=new TranslateAnimation(0,-300,0,0);
		//第一个参数fromXDelta为动画起始时 X坐标上的移动位置    
		//第二个参数toXDelta为动画结束时 X坐标上的移动位置      
		//第三个参数fromYDelta为动画起始时Y坐标上的移动位置 
		//第三个参数toYDelta为动画结束时Y坐标上的移动位置 
	//	animation_translate.setRepeatCount(-1);//设置动画执行多少次，如果是-1的话就是一直重复
		animation_translate.setDuration(3000);//设置时间持续时间为 5000毫秒
		
		animationSet=new AnimationSet(true);
		
//		animationSet.addAnimation(animation_alpha);//透明度
		animationSet.addAnimation(animation_rotate);//旋转
//		animationSet.addAnimation(animation_scale);//尺寸伸缩
		animationSet.addAnimation(animation_translate);//移动
		image.startAnimation(animationSet);//开始播放
	}
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.main, menu);
		return true;
	}

}

版权声明：本文为博主原创文章，未经博主允许不得转载。

adb获取android手机系统版本，已对应的api版本和硬件相关信息

获取系统版本：adb shell getprop ro.build.version.release


获取系统api版本：adb shell getprop ro.build.version.sdk


获取手机相关制造商信息：adb shell getprop | grep "model\|version.sdk\|manufacture
r\|hardware\|platform\|revision\|serialno\|product.name\|brand"


获取的结果如下图所示：



版权声明：本文为博主原创文章，未经博主允许不得转载。

Android okHttp讲解

原文地址：http://blog.csdn.net/lmj623565791/article/details/47911083

一、概述

最近在群里听到各种讨论okhttp的话题，可见okhttp的口碑相当好了。再加上Google貌似在6.0版本里面删除了HttpClient相关API，对于这个行为不做评价。为了更好的在应对网络访问，学习下okhttp还是蛮必要的，本篇博客首先介绍okhttp的简单使用，主要包含：

一般的get请求一般的post请求基于Http的文件上传文件下载加载图片支持请求回调，直接返回对象、对象集合支持session的保持

最后会对上述几个功能进行封装，完整的封装类的地址见：https://github.com/hongyangAndroid/okhttp-utils

使用前，对于Android Studio的用户，可以选择添加:
<code class="language-xml hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;">compile 'com.squareup.okhttp:okhttp:2.4.0'</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li></ul>

或者Eclipse的用户，可以下载最新的jar okhttp he latest JAR ，添加依赖就可以用了。

注意:okhttp内部依赖okio，别忘了同时导入okio：

gradle: compile 'com.squareup.okio:okio:1.5.0'

最新的jar地址：okio the latest JAR


二、使用教程

（一）Http Get

对了网络加载库，那么最常见的肯定就是http get请求了，比如获取一个网页的内容。
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//创建okHttpClient对象</span>
OkHttpClient mOkHttpClient = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClient();
<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//创建一个Request</span>
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Request request = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
                .url(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"https://github.com/hongyangAndroid"</span>)
                .build();
<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//new call</span>
Call call = mOkHttpClient.newCall(request); 
<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//请求加入调度</span>
call.enqueue(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Callback()
        {
            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onFailure</span>(Request request, IOException e)
            {
            }

            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Response response) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
            {
                    <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//String htmlStr =  response.body().string();</span>
            }
        });             

</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li><li style="box-sizing: border-box; padding: 0px 5px;">23</li><li style="box-sizing: border-box; padding: 0px 5px;">24</li></ul>


以上就是发送一个get请求的步骤，首先构造一个Request对象，参数最起码有个url，当然你可以通过Request.Builder设置更多的参数比如：header、method等。

然后通过request的对象去构造得到一个Call对象，类似于将你的请求封装成了任务，既然是任务，就会有execute()和cancel()等方法。

最后，我们希望以异步的方式去执行请求，所以我们调用的是call.enqueue，将call加入调度队列，然后等待任务执行完成，我们在Callback中即可得到结果。


看到这，你会发现，整体的写法还是比较长的，所以封装肯定是要做的，不然每个请求这么写，得累死。

ok，需要注意几点：


onResponse回调的参数是response，一般情况下，比如我们希望获得返回的字符串，可以通过response.body().string()获取；如果希望获得返回的二进制字节数组，则调用response.body().bytes()；如果你想拿到返回的inputStream，则调用response.body().byteStream()
看到这，你可能会奇怪，竟然还能拿到返回的inputStream，看到这个最起码能意识到一点，这里支持大文件下载，有inputStream我们就可以通过IO的方式写文件。不过也说明一个问题，这个onResponse执行的线程并不是UI线程。的确是的，如果你希望操作控件，还是需要使用handler等，例如：
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Response response) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
{
      <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> String res = response.body().string();
      runOnUiThread(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Runnable()
      {
          <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
          <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>()
          {
            mTv.setText(res);
          }

      });
}</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li></ul>我们这里是异步的方式去执行，当然也支持阻塞的方式，上面我们也说了Call有一个execute()方法，你也可以直接调用call.execute()通过返回一个Response。


(二) Http Post 携带参数

看来上面的简单的get请求，基本上整个的用法也就掌握了，比如post携带参数，也仅仅是Request的构造的不同。
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;">Request request = buildMultipartFormRequest(
        url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> File[]{file}, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> String[]{fileKey}, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>);
FormEncodingBuilder builder = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> FormEncodingBuilder();   
builder.add(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"username"</span>,<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"张鸿洋"</span>);

Request request = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
                   .url(url)
                .post(builder.build())
                .build();
 mOkHttpClient.newCall(request).enqueue(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Callback(){});</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li></ul>

大家都清楚，post的时候，参数是包含在请求体中的；所以我们通过FormEncodingBuilder。添加多个String键值对，然后去构造RequestBody，最后完成我们Request的构造。

后面的就和上面一样了。


（三）基于Http的文件上传

接下来我们在介绍一个可以构造RequestBody的Builder，叫做MultipartBuilder。当我们需要做类似于表单上传的时候，就可以使用它来构造我们的requestBody。
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;">File file = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> File(Environment.getExternalStorageDirectory(), <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"balabala.mp4"</span>);

RequestBody fileBody = RequestBody.create(MediaType.parse(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"application/octet-stream"</span>), file);

RequestBody requestBody = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> MultipartBuilder()
     .type(MultipartBuilder.FORM)
     .addPart(Headers.of(
          <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"Content-Disposition"</span>, 
              <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"form-data; name=\"username\""</span>), 
          RequestBody.create(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>, <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"张鸿洋"</span>))
     .addPart(Headers.of(
         <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"Content-Disposition"</span>, 
         <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"form-data; name=\"mFile\"; 
         filename=\"wjd.mp4\""</span>), fileBody)
     .build();

Request request = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
    .url(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"http://192.168.1.103:8080/okHttpServer/fileUpload"</span>)
    .post(requestBody)
    .build();

Call call = mOkHttpClient.newCall(request);
call.enqueue(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Callback()
{
    <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//...</span>
});</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li><li style="box-sizing: border-box; padding: 0px 5px;">23</li><li style="box-sizing: border-box; padding: 0px 5px;">24</li><li style="box-sizing: border-box; padding: 0px 5px;">25</li><li style="box-sizing: border-box; padding: 0px 5px;">26</li></ul>

上述代码向服务器传递了一个键值对username:张鸿洋和一个文件。我们通过MultipartBuilder的addPart方法可以添加键值对或者文件。

其实类似于我们拼接模拟浏览器行为的方式，如果你对这块不了解，可以参考：从原理角度解析Android （Java） http 文件上传

ok，对于我们最开始的目录还剩下图片下载，文件下载；这两个一个是通过回调的Response拿到byte[]然后decode成图片；文件下载，就是拿到inputStream做写文件操作，我们这里就不赘述了。

关于用法，也可以参考泡网OkHttp使用教程

接下来我们主要看如何封装上述的代码。


三、封装

由于按照上述的代码，写多个请求肯定包含大量的重复代码，所以我希望封装后的代码调用是这样的：

（一）使用


一般的get请求
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"> OkHttpClientManager.getAsyn(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"https://www.baidu.com"</span>, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager.ResultCallback<String>()
        {
            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onError</span>(Request request, Exception e)
            {
                e.printStackTrace();
            }

            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(String u)
            {
                mTv.setText(u);<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//注意这里是UI线程</span>
            }
        });</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li></ul>
对于一般的请求，我们希望给个url，然后CallBack里面直接操作控件。

文件上传且携带参数
我们希望提供一个方法，传入url,params,file,callback即可。
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;">  OkHttpClientManager.postAsyn(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"http://192.168.1.103:8080/okHttpServer/fileUpload"</span>,<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager.ResultCallback<String>()
    {
        <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onError</span>(Request request, IOException e)
        {
            e.printStackTrace();
        }

        <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(String result)
        {

        }
    },<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//</span>
    file,<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//</span>
    <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"mFile"</span>,<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager.Param[]{
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager.Param(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"username"</span>, <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"zhy"</span>),
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager.Param(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"password"</span>, <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"123"</span>)}
        );
</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li></ul>
键值对没什么说的，参数3为file，参数4为file对应的name，这个name不是文件的名字； 
对应于http中的
<input type="file" name="mFile" >
对应的是name后面的值，即mFile.

文件下载
对于文件下载，提供url，目标dir，callback即可。
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;">OkHttpClientManager.downloadAsyn(
    <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"http://192.168.1.103:8080/okHttpServer/files/messenger_01.png"</span>,    
    Environment.getExternalStorageDirectory().getAbsolutePath(), 
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager.ResultCallback<String>()
    {
        <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onError</span>(Request request, IOException e)
        {

        }

        <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(String response)
        {
            <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//文件下载成功，这里回调的reponse为文件的absolutePath</span>
        }
});</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li></ul>
展示图片
展示图片，我们希望提供一个url和一个imageview，如果下载成功，直接帮我们设置上即可。
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"> OkHttpClientManager.displayImage(mImageView, 
     <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"http://images.csdn.net/20150817/1.jpg"</span>);</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li></ul>
内部会自动根据imageview的大小自动对图片进行合适的压缩。虽然，这里可能不适合一次性加载大量图片的场景，但是对于app中偶尔有几个图片的加载，还是可用的。



四、整合Gson

很多人提出项目中使用时，服务端返回的是Json字符串，希望客户端回调可以直接拿到对象，于是整合进入了Gson，完善该功能。

（一）直接回调对象

例如现在有个User实体类：
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">package</span> com.zhy.utils.http.okhttp;

<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-class" style="box-sizing: border-box;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">User</span> {</span>

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> String username ; 
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> String password  ;

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">User</span>() {
        <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">// TODO Auto-generated constructor stub</span>
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">User</span>(String username, String password) {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.username = username;
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.password = password;
    }

    <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> String <span class="hljs-title" style="box-sizing: border-box;">toString</span>()
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"User{"</span> +
                <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"username='"</span> + username + <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">'\''</span> +
                <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">", password='"</span> + password + <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">'\''</span> +
                <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">'}'</span>;
    }
}</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li><li style="box-sizing: border-box; padding: 0px 5px;">23</li><li style="box-sizing: border-box; padding: 0px 5px;">24</li><li style="box-sizing: border-box; padding: 0px 5px;">25</li></ul>

服务端返回：
<code class="language-xml hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;">{"username":"zhy","password":"123"}</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li></ul>

客户端可以如下方式调用：
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"> OkHttpClientManager.getAsyn(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"http://192.168.56.1:8080/okHttpServer/user!getUser"</span>,
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager.ResultCallback<User>()
{
    <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onError</span>(Request request, Exception e)
    {
        e.printStackTrace();
    }

    <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(User user)
    {
        mTv.setText(u.toString());<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//UI线程</span>
    }
});</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li></ul>

我们传入泛型User，在onResponse里面直接回调User对象。 
这里特别要注意的事，如果在json字符串->实体对象过程中发生错误，程序不会崩溃，onError方法会被回调。

注意：这里做了少许的更新，接口命名从StringCallback修改为ResultCallback。接口中的onFailure方法修改为onError。

(二) 回调对象集合

依然是上述的User类，服务端返回
<code class="language-xml hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;">[{"username":"zhy","password":"123"},{"username":"lmj","password":"12345"}]</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li></ul>

则客户端可以如下调用：
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;">OkHttpClientManager.getAsyn(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"http://192.168.56.1:8080/okHttpServer/user!getUsers"</span>,
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager.ResultCallback<List<User>>()
{
    <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onError</span>(Request request, Exception e)
    {
        e.printStackTrace();
    }
    <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(List<User> us)
    {
        Log.e(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"TAG"</span>, us.size() + <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">""</span>);
        mTv.setText(us.get(<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">1</span>).toString());
    }
});</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li></ul>

唯一的区别，就是泛型变为List<User> ，ok ， 如果发现bug或者有任何意见欢迎留言。


源码

ok，基本介绍完了，对于封装的代码其实也很简单，我就直接贴出来了，因为也没什么好介绍的，如果你看完上面的用法，肯定可以看懂：
<code class="language-java hljs  has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">package</span> com.zhy.utils.http.okhttp;

<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> android.graphics.Bitmap;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> android.graphics.BitmapFactory;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> android.os.Handler;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> android.os.Looper;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> android.widget.ImageView;

<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.google.gson.Gson;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.google.gson.internal.$Gson$Types;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.Call;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.Callback;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.FormEncodingBuilder;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.Headers;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.MediaType;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.MultipartBuilder;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.OkHttpClient;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.Request;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.RequestBody;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> com.squareup.okhttp.Response;

<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.io.File;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.io.FileOutputStream;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.io.IOException;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.io.InputStream;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.lang.reflect.ParameterizedType;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.lang.reflect.Type;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.net.CookieManager;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.net.CookiePolicy;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.net.FileNameMap;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.net.URLConnection;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.util.HashMap;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.util.Map;
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">import</span> java.util.Set;

<span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
 * Created by zhy on 15/8/17.
 */</span>
<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-class" style="box-sizing: border-box;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">OkHttpClientManager</span>
{</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> OkHttpClientManager mInstance;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> OkHttpClient mOkHttpClient;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Handler mDelivery;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Gson mGson;


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> String TAG = <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"OkHttpClientManager"</span>;

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-title" style="box-sizing: border-box;">OkHttpClientManager</span>()
    {
        mOkHttpClient = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClient();
        <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//cookie enabled</span>
        mOkHttpClient.setCookieHandler(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> CookieManager(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>, CookiePolicy.ACCEPT_ORIGINAL_SERVER));
        mDelivery = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Handler(Looper.getMainLooper());
        mGson = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Gson();
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> OkHttpClientManager <span class="hljs-title" style="box-sizing: border-box;">getInstance</span>()
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (mInstance == <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>)
        {
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">synchronized</span> (OkHttpClientManager.class)
            {
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (mInstance == <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>)
                {
                    mInstance = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> OkHttpClientManager();
                }
            }
        }
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> mInstance;
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 同步的Get请求
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @return</span> Response
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Response <span class="hljs-title" style="box-sizing: border-box;">_getAsyn</span>(String url) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Request request = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
                .url(url)
                .build();
        Call call = mOkHttpClient.newCall(request);
        Response execute = call.execute();
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> execute;
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 同步的Get请求
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @return</span> 字符串
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> String <span class="hljs-title" style="box-sizing: border-box;">_getAsString</span>(String url) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Response execute = _getAsyn(url);
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> execute.body().string();
    }


    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 异步的get请求
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> callback
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">_getAsyn</span>(String url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback)
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Request request = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
                .url(url)
                .build();
        deliveryResult(callback, request);
    }


    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 同步的Post请求
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> params post的参数
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @return</span>
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Response <span class="hljs-title" style="box-sizing: border-box;">_post</span>(String url, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Request request = buildPostRequest(url, params);
        Response response = mOkHttpClient.newCall(request).execute();
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> response;
    }


    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 同步的Post请求
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> params post的参数
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @return</span> 字符串
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> String <span class="hljs-title" style="box-sizing: border-box;">_postAsString</span>(String url, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Response response = _post(url, params);
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> response.body().string();
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 异步的post请求
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> callback
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> params
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">_postAsyn</span>(String url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback, Param... params)
    {
        Request request = buildPostRequest(url, params);
        deliveryResult(callback, request);
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 异步的post请求
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> callback
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> params
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">_postAsyn</span>(String url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback, Map<String, String> params)
    {
        Param[] paramsArr = map2Params(params);
        Request request = buildPostRequest(url, paramsArr);
        deliveryResult(callback, request);
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 同步基于post的文件上传
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> params
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @return</span>
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Response <span class="hljs-title" style="box-sizing: border-box;">_post</span>(String url, File[] files, String[] fileKeys, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Request request = buildMultipartFormRequest(url, files, fileKeys, params);
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> mOkHttpClient.newCall(request).execute();
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Response <span class="hljs-title" style="box-sizing: border-box;">_post</span>(String url, File file, String fileKey) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Request request = buildMultipartFormRequest(url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> File[]{file}, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> String[]{fileKey}, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>);
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> mOkHttpClient.newCall(request).execute();
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Response <span class="hljs-title" style="box-sizing: border-box;">_post</span>(String url, File file, String fileKey, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Request request = buildMultipartFormRequest(url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> File[]{file}, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> String[]{fileKey}, params);
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> mOkHttpClient.newCall(request).execute();
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 异步基于post的文件上传
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> callback
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> files
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> fileKeys
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @throws</span> IOException
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">_postAsyn</span>(String url, ResultCallback callback, File[] files, String[] fileKeys, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Request request = buildMultipartFormRequest(url, files, fileKeys, params);
        deliveryResult(callback, request);
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 异步基于post的文件上传，单文件不带参数上传
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> callback
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> file
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> fileKey
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @throws</span> IOException
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">_postAsyn</span>(String url, ResultCallback callback, File file, String fileKey) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Request request = buildMultipartFormRequest(url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> File[]{file}, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> String[]{fileKey}, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>);
        deliveryResult(callback, request);
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 异步基于post的文件上传，单文件且携带其他form参数上传
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> callback
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> file
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> fileKey
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> params
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @throws</span> IOException
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">_postAsyn</span>(String url, ResultCallback callback, File file, String fileKey, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        Request request = buildMultipartFormRequest(url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> File[]{file}, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> String[]{fileKey}, params);
        deliveryResult(callback, request);
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 异步下载文件
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> destFileDir 本地文件存储的文件夹
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> callback
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">_downloadAsyn</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> String url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> String destFileDir, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback)
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Request request = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
                .url(url)
                .build();
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Call call = mOkHttpClient.newCall(request);
        call.enqueue(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Callback()
        {
            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onFailure</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Request request, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> IOException e)
            {
                sendFailedStringCallback(request, e, callback);
            }

            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(Response response)
            {
                InputStream is = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>;
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">byte</span>[] buf = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">byte</span>[<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">2048</span>];
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> len = <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>;
                FileOutputStream fos = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>;
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>
                {
                    is = response.body().byteStream();
                    File file = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> File(destFileDir, getFileName(url));
                    fos = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> FileOutputStream(file);
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">while</span> ((len = is.read(buf)) != -<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">1</span>)
                    {
                        fos.write(buf, <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>, len);
                    }
                    fos.flush();
                    <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//如果下载文件成功，第一个参数为文件的绝对路径</span>
                    sendSuccessResultCallback(file.getAbsolutePath(), callback);
                } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span> (IOException e)
                {
                    sendFailedStringCallback(response.request(), e, callback);
                } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">finally</span>
                {
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>
                    {
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (is != <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>) is.close();
                    } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span> (IOException e)
                    {
                    }
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>
                    {
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (fos != <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>) fos.close();
                    } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span> (IOException e)
                    {
                    }
                }

            }
        });
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> String <span class="hljs-title" style="box-sizing: border-box;">getFileName</span>(String path)
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> separatorIndex = path.lastIndexOf(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"/"</span>);
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> (separatorIndex < <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>) ? path : path.substring(separatorIndex + <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">1</span>, path.length());
    }

    <span class="hljs-javadoc" style="color: rgb(136, 0, 0); box-sizing: border-box;">/**
     * 加载图片
     *
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> view
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @param</span> url
     *<span class="hljs-javadoctag" style="color: rgb(102, 0, 102); box-sizing: border-box;"> @throws</span> IOException
     */</span>
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">_displayImage</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ImageView view, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> String url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> errorResId)
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Request request = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
                .url(url)
                .build();
        Call call = mOkHttpClient.newCall(request);
        call.enqueue(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Callback()
        {
            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onFailure</span>(Request request, IOException e)
            {
                setErrorResId(view, errorResId);
            }

            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(Response response)
            {
                InputStream is = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>;
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>
                {
                    is = response.body().byteStream();
                    ImageUtils.ImageSize actualImageSize = ImageUtils.getImageSize(is);
                    ImageUtils.ImageSize imageViewSize = ImageUtils.getImageViewSize(view);
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> inSampleSize = ImageUtils.calculateInSampleSize(actualImageSize, imageViewSize);
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>
                    {
                        is.reset();
                    } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span> (IOException e)
                    {
                        response = _getAsyn(url);
                        is = response.body().byteStream();
                    }

                    BitmapFactory.Options ops = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> BitmapFactory.Options();
                    ops.inJustDecodeBounds = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">false</span>;
                    ops.inSampleSize = inSampleSize;
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Bitmap bm = BitmapFactory.decodeStream(is, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>, ops);
                    mDelivery.post(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Runnable()
                    {
                        <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
                        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>()
                        {
                            view.setImageBitmap(bm);
                        }
                    });
                } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span> (Exception e)
                {
                    setErrorResId(view, errorResId);

                } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">finally</span>
                {
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (is != <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>
                    {
                        is.close();
                    } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span> (IOException e)
                    {
                        e.printStackTrace();
                    }
                }
            }
        });


    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">setErrorResId</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ImageView view, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> errorResId)
    {
        mDelivery.post(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Runnable()
        {
            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>()
            {
                view.setImageResource(errorResId);
            }
        });
    }


    <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//*************对外公布的方法************</span>


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> Response <span class="hljs-title" style="box-sizing: border-box;">getAsyn</span>(String url) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> getInstance()._getAsyn(url);
    }


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> String <span class="hljs-title" style="box-sizing: border-box;">getAsString</span>(String url) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> getInstance()._getAsString(url);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">getAsyn</span>(String url, ResultCallback callback)
    {
        getInstance()._getAsyn(url, callback);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> Response <span class="hljs-title" style="box-sizing: border-box;">post</span>(String url, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> getInstance()._post(url, params);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> String <span class="hljs-title" style="box-sizing: border-box;">postAsString</span>(String url, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> getInstance()._postAsString(url, params);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">postAsyn</span>(String url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback, Param... params)
    {
        getInstance()._postAsyn(url, callback, params);
    }


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">postAsyn</span>(String url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback, Map<String, String> params)
    {
        getInstance()._postAsyn(url, callback, params);
    }


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> Response <span class="hljs-title" style="box-sizing: border-box;">post</span>(String url, File[] files, String[] fileKeys, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> getInstance()._post(url, files, fileKeys, params);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> Response <span class="hljs-title" style="box-sizing: border-box;">post</span>(String url, File file, String fileKey) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> getInstance()._post(url, file, fileKey);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> Response <span class="hljs-title" style="box-sizing: border-box;">post</span>(String url, File file, String fileKey, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> getInstance()._post(url, file, fileKey, params);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">postAsyn</span>(String url, ResultCallback callback, File[] files, String[] fileKeys, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        getInstance()._postAsyn(url, callback, files, fileKeys, params);
    }


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">postAsyn</span>(String url, ResultCallback callback, File file, String fileKey) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        getInstance()._postAsyn(url, callback, file, fileKey);
    }


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">postAsyn</span>(String url, ResultCallback callback, File file, String fileKey, Param... params) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        getInstance()._postAsyn(url, callback, file, fileKey, params);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">displayImage</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ImageView view, String url, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> errorResId) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throws</span> IOException
    {
        getInstance()._displayImage(view, url, errorResId);
    }


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">displayImage</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ImageView view, String url)
    {
        getInstance()._displayImage(view, url, -<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">1</span>);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">downloadAsyn</span>(String url, String destDir, ResultCallback callback)
    {
        getInstance()._downloadAsyn(url, destDir, callback);
    }

    <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//****************************</span>


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Request <span class="hljs-title" style="box-sizing: border-box;">buildMultipartFormRequest</span>(String url, File[] files,
                                              String[] fileKeys, Param[] params)
    {
        params = validateParam(params);

        MultipartBuilder builder = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> MultipartBuilder()
                .type(MultipartBuilder.FORM);

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">for</span> (Param param : params)
        {
            builder.addPart(Headers.of(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"Content-Disposition"</span>, <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"form-data; name=\""</span> + param.key + <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"\""</span>),
                    RequestBody.create(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>, param.value));
        }
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (files != <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>)
        {
            RequestBody fileBody = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>;
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">for</span> (<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> i = <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>; i < files.length; i++)
            {
                File file = files[i];
                String fileName = file.getName();
                fileBody = RequestBody.create(MediaType.parse(guessMimeType(fileName)), file);
                <span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//TODO 根据文件名设置contentType</span>
                builder.addPart(Headers.of(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"Content-Disposition"</span>,
                                <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"form-data; name=\""</span> + fileKeys[i] + <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"\"; filename=\""</span> + fileName + <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"\""</span>),
                        fileBody);
            }
        }

        RequestBody requestBody = builder.build();
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> String <span class="hljs-title" style="box-sizing: border-box;">guessMimeType</span>(String path)
    {
        FileNameMap fileNameMap = URLConnection.getFileNameMap();
        String contentTypeFor = fileNameMap.getContentTypeFor(path);
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (contentTypeFor == <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>)
        {
            contentTypeFor = <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"application/octet-stream"</span>;
        }
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> contentTypeFor;
    }


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Param[] <span class="hljs-title" style="box-sizing: border-box;">validateParam</span>(Param[] params)
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (params == <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>)
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Param[<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>];
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">else</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> params;
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Param[] <span class="hljs-title" style="box-sizing: border-box;">map2Params</span>(Map<String, String> params)
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (params == <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>) <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Param[<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>];
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> size = params.size();
        Param[] res = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Param[size];
        Set<Map.Entry<String, String>> entries = params.entrySet();
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">int</span> i = <span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>;
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">for</span> (Map.Entry<String, String> entry : entries)
        {
            res[i++] = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Param(entry.getKey(), entry.getValue());
        }
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> res;
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> String SESSION_KEY = <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"Set-Cookie"</span>;
    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> String mSessionKey = <span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"JSESSIONID"</span>;

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Map<String, String> mSessions = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> HashMap<String, String>();

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">deliveryResult</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback, Request request)
    {
        mOkHttpClient.newCall(request).enqueue(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Callback()
        {
            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onFailure</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Request request, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> IOException e)
            {
                sendFailedStringCallback(request, e, callback);
            }

            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Response response)
            {
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">try</span>
                {
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> String string = response.body().string();
                    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (callback.mType == String.class)
                    {
                        sendSuccessResultCallback(string, callback);
                    } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">else</span>
                    {
                        Object o = mGson.fromJson(string, callback.mType);
                        sendSuccessResultCallback(o, callback);
                    }


                } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span> (IOException e)
                {
                    sendFailedStringCallback(response.request(), e, callback);
                } <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">catch</span> (com.google.gson.JsonParseException e)<span class="hljs-comment" style="color: rgb(136, 0, 0); box-sizing: border-box;">//Json解析的错误</span>
                {
                    sendFailedStringCallback(response.request(), e, callback);
                }

            }
        });
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">sendFailedStringCallback</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Request request, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Exception e, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback)
    {
        mDelivery.post(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Runnable()
        {
            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>()
            {
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (callback != <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>)
                    callback.onError(request, e);
            }
        });
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">sendSuccessResultCallback</span>(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> Object object, <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">final</span> ResultCallback callback)
    {
        mDelivery.post(<span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Runnable()
        {
            <span class="hljs-annotation" style="color: rgb(155, 133, 157); box-sizing: border-box;">@Override</span>
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">run</span>()
            {
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (callback != <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>)
                {
                    callback.onResponse(object);
                }
            }
        });
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">private</span> Request <span class="hljs-title" style="box-sizing: border-box;">buildPostRequest</span>(String url, Param[] params)
    {
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (params == <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">null</span>)
        {
            params = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Param[<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>];
        }
        FormEncodingBuilder builder = <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> FormEncodingBuilder();
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">for</span> (Param param : params)
        {
            builder.add(param.key, param.value);
        }
        RequestBody requestBody = builder.build();
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
    }


    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">abstract</span> <span class="hljs-class" style="box-sizing: border-box;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">ResultCallback</span><<span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">T</span>>
    {</span>
        Type mType;

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">ResultCallback</span>()
        {
            mType = getSuperclassTypeParameter(getClass());
        }

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> Type getSuperclassTypeParameter(Class<?> subclass)
        {
            Type superclass = subclass.getGenericSuperclass();
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">if</span> (superclass <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">instanceof</span> Class)
            {
                <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">throw</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">new</span> RuntimeException(<span class="hljs-string" style="color: rgb(0, 136, 0); box-sizing: border-box;">"Missing type parameter."</span>);
            }
            ParameterizedType parameterized = (ParameterizedType) superclass;
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">return</span> $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[<span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;">0</span>]);
        }

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">abstract</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onError</span>(Request request, Exception e);

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">abstract</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">void</span> <span class="hljs-title" style="box-sizing: border-box;">onResponse</span>(T response);
    }

    <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">static</span> <span class="hljs-class" style="box-sizing: border-box;"><span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">class</span> <span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);">Param</span>
    {</span>
        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">Param</span>()
        {
        }

        <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">public</span> <span class="hljs-title" style="box-sizing: border-box;">Param</span>(String key, String value)
        {
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.key = key;
            <span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;">this</span>.value = value;
        }

        String key;
        String value;
    }


}

</code><ul class="pre-numbering" style="box-sizing: border-box; position: absolute; width: 50px; top: 0px; left: 0px; margin: 0px; padding: 6px 0px 40px; border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); list-style: none; text-align: right; background-color: rgb(238, 238, 238);"><li style="box-sizing: border-box; padding: 0px 5px;">1</li><li style="box-sizing: border-box; padding: 0px 5px;">2</li><li style="box-sizing: border-box; padding: 0px 5px;">3</li><li style="box-sizing: border-box; padding: 0px 5px;">4</li><li style="box-sizing: border-box; padding: 0px 5px;">5</li><li style="box-sizing: border-box; padding: 0px 5px;">6</li><li style="box-sizing: border-box; padding: 0px 5px;">7</li><li style="box-sizing: border-box; padding: 0px 5px;">8</li><li style="box-sizing: border-box; padding: 0px 5px;">9</li><li style="box-sizing: border-box; padding: 0px 5px;">10</li><li style="box-sizing: border-box; padding: 0px 5px;">11</li><li style="box-sizing: border-box; padding: 0px 5px;">12</li><li style="box-sizing: border-box; padding: 0px 5px;">13</li><li style="box-sizing: border-box; padding: 0px 5px;">14</li><li style="box-sizing: border-box; padding: 0px 5px;">15</li><li style="box-sizing: border-box; padding: 0px 5px;">16</li><li style="box-sizing: border-box; padding: 0px 5px;">17</li><li style="box-sizing: border-box; padding: 0px 5px;">18</li><li style="box-sizing: border-box; padding: 0px 5px;">19</li><li style="box-sizing: border-box; padding: 0px 5px;">20</li><li style="box-sizing: border-box; padding: 0px 5px;">21</li><li style="box-sizing: border-box; padding: 0px 5px;">22</li><li style="box-sizing: border-box; padding: 0px 5px;">23</li><li style="box-sizing: border-box; padding: 0px 5px;">24</li><li style="box-sizing: border-box; padding: 0px 5px;">25</li><li style="box-sizing: border-box; padding: 0px 5px;">26</li><li style="box-sizing: border-box; padding: 0px 5px;">27</li><li style="box-sizing: border-box; padding: 0px 5px;">28</li><li style="box-sizing: border-box; padding: 0px 5px;">29</li><li style="box-sizing: border-box; padding: 0px 5px;">30</li><li style="box-sizing: border-box; padding: 0px 5px;">31</li><li style="box-sizing: border-box; padding: 0px 5px;">32</li><li style="box-sizing: border-box; padding: 0px 5px;">33</li><li style="box-sizing: border-box; padding: 0px 5px;">34</li><li style="box-sizing: border-box; padding: 0px 5px;">35</li><li style="box-sizing: border-box; padding: 0px 5px;">36</li><li style="box-sizing: border-box; padding: 0px 5px;">37</li><li style="box-sizing: border-box; padding: 0px 5px;">38</li><li style="box-sizing: border-box; padding: 0px 5px;">39</li><li style="box-sizing: border-box; padding: 0px 5px;">40</li><li style="box-sizing: border-box; padding: 0px 5px;">41</li><li style="box-sizing: border-box; padding: 0px 5px;">42</li><li style="box-sizing: border-box; padding: 0px 5px;">43</li><li style="box-sizing: border-box; padding: 0px 5px;">44</li><li style="box-sizing: border-box; padding: 0px 5px;">45</li><li style="box-sizing: border-box; padding: 0px 5px;">46</li><li style="box-sizing: border-box; padding: 0px 5px;">47</li><li style="box-sizing: border-box; padding: 0px 5px;">48</li><li style="box-sizing: border-box; padding: 0px 5px;">49</li><li style="box-sizing: border-box; padding: 0px 5px;">50</li><li style="box-sizing: border-box; padding: 0px 5px;">51</li><li style="box-sizing: border-box; padding: 0px 5px;">52</li><li style="box-sizing: border-box; padding: 0px 5px;">53</li><li style="box-sizing: border-box; padding: 0px 5px;">54</li><li style="box-sizing: border-box; padding: 0px 5px;">55</li><li style="box-sizing: border-box; padding: 0px 5px;">56</li><li style="box-sizing: border-box; padding: 0px 5px;">57</li><li style="box-sizing: border-box; padding: 0px 5px;">58</li><li style="box-sizing: border-box; padding: 0px 5px;">59</li><li style="box-sizing: border-box; padding: 0px 5px;">60</li><li style="box-sizing: border-box; padding: 0px 5px;">61</li><li style="box-sizing: border-box; padding: 0px 5px;">62</li><li style="box-sizing: border-box; padding: 0px 5px;">63</li><li style="box-sizing: border-box; padding: 0px 5px;">64</li><li style="box-sizing: border-box; padding: 0px 5px;">65</li><li style="box-sizing: border-box; padding: 0px 5px;">66</li><li style="box-sizing: border-box; padding: 0px 5px;">67</li><li style="box-sizing: border-box; padding: 0px 5px;">68</li><li style="box-sizing: border-box; padding: 0px 5px;">69</li><li style="box-sizing: border-box; padding: 0px 5px;">70</li><li style="box-sizing: border-box; padding: 0px 5px;">71</li><li style="box-sizing: border-box; padding: 0px 5px;">72</li><li style="box-sizing: border-box; padding: 0px 5px;">73</li><li style="box-sizing: border-box; padding: 0px 5px;">74</li><li style="box-sizing: border-box; padding: 0px 5px;">75</li><li style="box-sizing: border-box; padding: 0px 5px;">76</li><li style="box-sizing: border-box; padding: 0px 5px;">77</li><li style="box-sizing: border-box; padding: 0px 5px;">78</li><li style="box-sizing: border-box; padding: 0px 5px;">79</li><li style="box-sizing: border-box; padding: 0px 5px;">80</li><li style="box-sizing: border-box; padding: 0px 5px;">81</li><li style="box-sizing: border-box; padding: 0px 5px;">82</li><li style="box-sizing: border-box; padding: 0px 5px;">83</li><li style="box-sizing: border-box; padding: 0px 5px;">84</li><li style="box-sizing: border-box; padding: 0px 5px;">85</li><li style="box-sizing: border-box; padding: 0px 5px;">86</li><li style="box-sizing: border-box; padding: 0px 5px;">87</li><li style="box-sizing: border-box; padding: 0px 5px;">88</li><li style="box-sizing: border-box; padding: 0px 5px;">89</li><li style="box-sizing: border-box; padding: 0px 5px;">90</li><li style="box-sizing: border-box; padding: 0px 5px;">91</li><li style="box-sizing: border-box; padding: 0px 5px;">92</li><li style="box-sizing: border-box; padding: 0px 5px;">93</li><li style="box-sizing: border-box; padding: 0px 5px;">94</li><li style="box-sizing: border-box; padding: 0px 5px;">95</li><li style="box-sizing: border-box; padding: 0px 5px;">96</li><li style="box-sizing: border-box; padding: 0px 5px;">97</li><li style="box-sizing: border-box; padding: 0px 5px;">98</li><li style="box-sizing: border-box; padding: 0px 5px;">99</li><li style="box-sizing: border-box; padding: 0px 5px;">100</li><li style="box-sizing: border-box; padding: 0px 5px;">101</li><li style="box-sizing: border-box; padding: 0px 5px;">102</li><li style="box-sizing: border-box; padding: 0px 5px;">103</li><li style="box-sizing: border-box; padding: 0px 5px;">104</li><li style="box-sizing: border-box; padding: 0px 5px;">105</li><li style="box-sizing: border-box; padding: 0px 5px;">106</li><li style="box-sizing: border-box; padding: 0px 5px;">107</li><li style="box-sizing: border-box; padding: 0px 5px;">108</li><li style="box-sizing: border-box; padding: 0px 5px;">109</li><li style="box-sizing: border-box; padding: 0px 5px;">110</li><li style="box-sizing: border-box; padding: 0px 5px;">111</li><li style="box-sizing: border-box; padding: 0px 5px;">112</li><li style="box-sizing: border-box; padding: 0px 5px;">113</li><li style="box-sizing: border-box; padding: 0px 5px;">114</li><li style="box-sizing: border-box; padding: 0px 5px;">115</li><li style="box-sizing: border-box; padding: 0px 5px;">116</li><li style="box-sizing: border-box; padding: 0px 5px;">117</li><li style="box-sizing: border-box; padding: 0px 5px;">118</li><li style="box-sizing: border-box; padding: 0px 5px;">119</li><li style="box-sizing: border-box; padding: 0px 5px;">120</li><li style="box-sizing: border-box; padding: 0px 5px;">121</li><li style="box-sizing: border-box; padding: 0px 5px;">122</li><li style="box-sizing: border-box; padding: 0px 5px;">123</li><li style="box-sizing: border-box; padding: 0px 5px;">124</li><li style="box-sizing: border-box; padding: 0px 5px;">125</li><li style="box-sizing: border-box; padding: 0px 5px;">126</li><li style="box-sizing: border-box; padding: 0px 5px;">127</li><li style="box-sizing: border-box; padding: 0px 5px;">128</li><li style="box-sizing: border-box; padding: 0px 5px;">129</li><li style="box-sizing: border-box; padding: 0px 5px;">130</li><li style="box-sizing: border-box; padding: 0px 5px;">131</li><li style="box-sizing: border-box; padding: 0px 5px;">132</li><li style="box-sizing: border-box; padding: 0px 5px;">133</li><li style="box-sizing: border-box; padding: 0px 5px;">134</li><li style="box-sizing: border-box; padding: 0px 5px;">135</li><li style="box-sizing: border-box; padding: 0px 5px;">136</li><li style="box-sizing: border-box; padding: 0px 5px;">137</li><li style="box-sizing: border-box; padding: 0px 5px;">138</li><li style="box-sizing: border-box; padding: 0px 5px;">139</li><li style="box-sizing: border-box; padding: 0px 5px;">140</li><li style="box-sizing: border-box; padding: 0px 5px;">141</li><li style="box-sizing: border-box; padding: 0px 5px;">142</li><li style="box-sizing: border-box; padding: 0px 5px;">143</li><li style="box-sizing: border-box; padding: 0px 5px;">144</li><li style="box-sizing: border-box; padding: 0px 5px;">145</li><li style="box-sizing: border-box; padding: 0px 5px;">146</li><li style="box-sizing: border-box; padding: 0px 5px;">147</li><li style="box-sizing: border-box; padding: 0px 5px;">148</li><li style="box-sizing: border-box; padding: 0px 5px;">149</li><li style="box-sizing: border-box; padding: 0px 5px;">150</li><li style="box-sizing: border-box; padding: 0px 5px;">151</li><li style="box-sizing: border-box; padding: 0px 5px;">152</li><li style="box-sizing: border-box; padding: 0px 5px;">153</li><li style="box-sizing: border-box; padding: 0px 5px;">154</li><li style="box-sizing: border-box; padding: 0px 5px;">155</li><li style="box-sizing: border-box; padding: 0px 5px;">156</li><li style="box-sizing: border-box; padding: 0px 5px;">157</li><li style="box-sizing: border-box; padding: 0px 5px;">158</li><li style="box-sizing: border-box; padding: 0px 5px;">159</li><li style="box-sizing: border-box; padding: 0px 5px;">160</li><li style="box-sizing: border-box; padding: 0px 5px;">161</li><li style="box-sizing: border-box; padding: 0px 5px;">162</li><li style="box-sizing: border-box; padding: 0px 5px;">163</li><li style="box-sizing: border-box; padding: 0px 5px;">164</li><li style="box-sizing: border-box; padding: 0px 5px;">165</li><li style="box-sizing: border-box; padding: 0px 5px;">166</li><li style="box-sizing: border-box; padding: 0px 5px;">167</li><li style="box-sizing: border-box; padding: 0px 5px;">168</li><li style="box-sizing: border-box; padding: 0px 5px;">169</li><li style="box-sizing: border-box; padding: 0px 5px;">170</li><li style="box-sizing: border-box; padding: 0px 5px;">171</li><li style="box-sizing: border-box; padding: 0px 5px;">172</li><li style="box-sizing: border-box; padding: 0px 5px;">173</li><li style="box-sizing: border-box; padding: 0px 5px;">174</li><li style="box-sizing: border-box; padding: 0px 5px;">175</li><li style="box-sizing: border-box; padding: 0px 5px;">176</li><li style="box-sizing: border-box; padding: 0px 5px;">177</li><li style="box-sizing: border-box; padding: 0px 5px;">178</li><li style="box-sizing: border-box; padding: 0px 5px;">179</li><li style="box-sizing: border-box; padding: 0px 5px;">180</li><li style="box-sizing: border-box; padding: 0px 5px;">181</li><li style="box-sizing: border-box; padding: 0px 5px;">182</li><li style="box-sizing: border-box; padding: 0px 5px;">183</li><li style="box-sizing: border-box; padding: 0px 5px;">184</li><li style="box-sizing: border-box; padding: 0px 5px;">185</li><li style="box-sizing: border-box; padding: 0px 5px;">186</li><li style="box-sizing: border-box; padding: 0px 5px;">187</li><li style="box-sizing: border-box; padding: 0px 5px;">188</li><li style="box-sizing: border-box; padding: 0px 5px;">189</li><li style="box-sizing: border-box; padding: 0px 5px;">190</li><li style="box-sizing: border-box; padding: 0px 5px;">191</li><li style="box-sizing: border-box; padding: 0px 5px;">192</li><li style="box-sizing: border-box; padding: 0px 5px;">193</li><li style="box-sizing: border-box; padding: 0px 5px;">194</li><li style="box-sizing: border-box; padding: 0px 5px;">195</li><li style="box-sizing: border-box; padding: 0px 5px;">196</li><li style="box-sizing: border-box; padding: 0px 5px;">197</li><li style="box-sizing: border-box; padding: 0px 5px;">198</li><li style="box-sizing: border-box; padding: 0px 5px;">199</li><li style="box-sizing: border-box; padding: 0px 5px;">200</li><li style="box-sizing: border-box; padding: 0px 5px;">201</li><li style="box-sizing: border-box; padding: 0px 5px;">202</li><li style="box-sizing: border-box; padding: 0px 5px;">203</li><li style="box-sizing: border-box; padding: 0px 5px;">204</li><li style="box-sizing: border-box; padding: 0px 5px;">205</li><li style="box-sizing: border-box; padding: 0px 5px;">206</li><li style="box-sizing: border-box; padding: 0px 5px;">207</li><li style="box-sizing: border-box; padding: 0px 5px;">208</li><li style="box-sizing: border-box; padding: 0px 5px;">209</li><li style="box-sizing: border-box; padding: 0px 5px;">210</li><li style="box-sizing: border-box; padding: 0px 5px;">211</li><li style="box-sizing: border-box; padding: 0px 5px;">212</li><li style="box-sizing: border-box; padding: 0px 5px;">213</li><li style="box-sizing: border-box; padding: 0px 5px;">214</li><li style="box-sizing: border-box; padding: 0px 5px;">215</li><li style="box-sizing: border-box; padding: 0px 5px;">216</li><li style="box-sizing: border-box; padding: 0px 5px;">217</li><li style="box-sizing: border-box; padding: 0px 5px;">218</li><li style="box-sizing: border-box; padding: 0px 5px;">219</li><li style="box-sizing: border-box; padding: 0px 5px;">220</li><li style="box-sizing: border-box; padding: 0px 5px;">221</li><li style="box-sizing: border-box; padding: 0px 5px;">222</li><li style="box-sizing: border-box; padding: 0px 5px;">223</li><li style="box-sizing: border-box; padding: 0px 5px;">224</li><li style="box-sizing: border-box; padding: 0px 5px;">225</li><li style="box-sizing: border-box; padding: 0px 5px;">226</li><li style="box-sizing: border-box; padding: 0px 5px;">227</li><li style="box-sizing: border-box; padding: 0px 5px;">228</li><li style="box-sizing: border-box; padding: 0px 5px;">229</li><li style="box-sizing: border-box; padding: 0px 5px;">230</li><li style="box-sizing: border-box; padding: 0px 5px;">231</li><li style="box-sizing: border-box; padding: 0px 5px;">232</li><li style="box-sizing: border-box; padding: 0px 5px;">233</li><li style="box-sizing: border-box; padding: 0px 5px;">234</li><li style="box-sizing: border-box; padding: 0px 5px;">235</li><li style="box-sizing: border-box; padding: 0px 5px;">236</li><li style="box-sizing: border-box; padding: 0px 5px;">237</li><li style="box-sizing: border-box; padding: 0px 5px;">238</li><li style="box-sizing: border-box; padding: 0px 5px;">239</li><li style="box-sizing: border-box; padding: 0px 5px;">240</li><li style="box-sizing: border-box; padding: 0px 5px;">241</li><li style="box-sizing: border-box; padding: 0px 5px;">242</li><li style="box-sizing: border-box; padding: 0px 5px;">243</li><li style="box-sizing: border-box; padding: 0px 5px;">244</li><li style="box-sizing: border-box; padding: 0px 5px;">245</li><li style="box-sizing: border-box; padding: 0px 5px;">246</li><li style="box-sizing: border-box; padding: 0px 5px;">247</li><li style="box-sizing: border-box; padding: 0px 5px;">248</li><li style="box-sizing: border-box; padding: 0px 5px;">249</li><li style="box-sizing: border-box; padding: 0px 5px;">250</li><li style="box-sizing: border-box; padding: 0px 5px;">251</li><li style="box-sizing: border-box; padding: 0px 5px;">252</li><li style="box-sizing: border-box; padding: 0px 5px;">253</li><li style="box-sizing: border-box; padding: 0px 5px;">254</li><li style="box-sizing: border-box; padding: 0px 5px;">255</li><li style="box-sizing: border-box; padding: 0px 5px;">256</li><li style="box-sizing: border-box; padding: 0px 5px;">257</li><li style="box-sizing: border-box; padding: 0px 5px;">258</li><li style="box-sizing: border-box; padding: 0px 5px;">259</li><li style="box-sizing: border-box; padding: 0px 5px;">260</li><li style="box-sizing: border-box; padding: 0px 5px;">261</li><li style="box-sizing: border-box; padding: 0px 5px;">262</li><li style="box-sizing: border-box; padding: 0px 5px;">263</li><li style="box-sizing: border-box; padding: 0px 5px;">264</li><li style="box-sizing: border-box; padding: 0px 5px;">265</li><li style="box-sizing: border-box; padding: 0px 5px;">266</li><li style="box-sizing: border-box; padding: 0px 5px;">267</li><li style="box-sizing: border-box; padding: 0px 5px;">268</li><li style="box-sizing: border-box; padding: 0px 5px;">269</li><li style="box-sizing: border-box; padding: 0px 5px;">270</li><li style="box-sizing: border-box; padding: 0px 5px;">271</li><li style="box-sizing: border-box; padding: 0px 5px;">272</li><li style="box-sizing: border-box; padding: 0px 5px;">273</li><li style="box-sizing: border-box; padding: 0px 5px;">274</li><li style="box-sizing: border-box; padding: 0px 5px;">275</li><li style="box-sizing: border-box; padding: 0px 5px;">276</li><li style="box-sizing: border-box; padding: 0px 5px;">277</li><li style="box-sizing: border-box; padding: 0px 5px;">278</li><li style="box-sizing: border-box; padding: 0px 5px;">279</li><li style="box-sizing: border-box; padding: 0px 5px;">280</li><li style="box-sizing: border-box; padding: 0px 5px;">281</li><li style="box-sizing: border-box; padding: 0px 5px;">282</li><li style="box-sizing: border-box; padding: 0px 5px;">283</li><li style="box-sizing: border-box; padding: 0px 5px;">284</li><li style="box-sizing: border-box; padding: 0px 5px;">285</li><li style="box-sizing: border-box; padding: 0px 5px;">286</li><li style="box-sizing: border-box; padding: 0px 5px;">287</li><li style="box-sizing: border-box; padding: 0px 5px;">288</li><li style="box-sizing: border-box; padding: 0px 5px;">289</li><li style="box-sizing: border-box; padding: 0px 5px;">290</li><li style="box-sizing: border-box; padding: 0px 5px;">291</li><li style="box-sizing: border-box; padding: 0px 5px;">292</li><li style="box-sizing: border-box; padding: 0px 5px;">293</li><li style="box-sizing: border-box; padding: 0px 5px;">294</li><li style="box-sizing: border-box; padding: 0px 5px;">295</li><li style="box-sizing: border-box; padding: 0px 5px;">296</li><li style="box-sizing: border-box; padding: 0px 5px;">297</li><li style="box-sizing: border-box; padding: 0px 5px;">298</li><li style="box-sizing: border-box; padding: 0px 5px;">299</li><li style="box-sizing: border-box; padding: 0px 5px;">300</li><li style="box-sizing: border-box; padding: 0px 5px;">301</li><li style="box-sizing: border-box; padding: 0px 5px;">302</li><li style="box-sizing: border-box; padding: 0px 5px;">303</li><li style="box-sizing: border-box; padding: 0px 5px;">304</li><li style="box-sizing: border-box; padding: 0px 5px;">305</li><li style="box-sizing: border-box; padding: 0px 5px;">306</li><li style="box-sizing: border-box; padding: 0px 5px;">307</li><li style="box-sizing: border-box; padding: 0px 5px;">308</li><li style="box-sizing: border-box; padding: 0px 5px;">309</li><li style="box-sizing: border-box; padding: 0px 5px;">310</li><li style="box-sizing: border-box; padding: 0px 5px;">311</li><li style="box-sizing: border-box; padding: 0px 5px;">312</li><li style="box-sizing: border-box; padding: 0px 5px;">313</li><li style="box-sizing: border-box; padding: 0px 5px;">314</li><li style="box-sizing: border-box; padding: 0px 5px;">315</li><li style="box-sizing: border-box; padding: 0px 5px;">316</li><li style="box-sizing: border-box; padding: 0px 5px;">317</li><li style="box-sizing: border-box; padding: 0px 5px;">318</li><li style="box-sizing: border-box; padding: 0px 5px;">319</li><li style="box-sizing: border-box; padding: 0px 5px;">320</li><li style="box-sizing: border-box; padding: 0px 5px;">321</li><li style="box-sizing: border-box; padding: 0px 5px;">322</li><li style="box-sizing: border-box; padding: 0px 5px;">323</li><li style="box-sizing: border-box; padding: 0px 5px;">324</li><li style="box-sizing: border-box; padding: 0px 5px;">325</li><li style="box-sizing: border-box; padding: 0px 5px;">326</li><li style="box-sizing: border-box; padding: 0px 5px;">327</li><li style="box-sizing: border-box; padding: 0px 5px;">328</li><li style="box-sizing: border-box; padding: 0px 5px;">329</li><li style="box-sizing: border-box; padding: 0px 5px;">330</li><li style="box-sizing: border-box; padding: 0px 5px;">331</li><li style="box-sizing: border-box; padding: 0px 5px;">332</li><li style="box-sizing: border-box; padding: 0px 5px;">333</li><li style="box-sizing: border-box; padding: 0px 5px;">334</li><li style="box-sizing: border-box; padding: 0px 5px;">335</li><li style="box-sizing: border-box; padding: 0px 5px;">336</li><li style="box-sizing: border-box; padding: 0px 5px;">337</li><li style="box-sizing: border-box; padding: 0px 5px;">338</li><li style="box-sizing: border-box; padding: 0px 5px;">339</li><li style="box-sizing: border-box; padding: 0px 5px;">340</li><li style="box-sizing: border-box; padding: 0px 5px;">341</li><li style="box-sizing: border-box; padding: 0px 5px;">342</li><li style="box-sizing: border-box; padding: 0px 5px;">343</li><li style="box-sizing: border-box; padding: 0px 5px;">344</li><li style="box-sizing: border-box; padding: 0px 5px;">345</li><li style="box-sizing: border-box; padding: 0px 5px;">346</li><li style="box-sizing: border-box; padding: 0px 5px;">347</li><li style="box-sizing: border-box; padding: 0px 5px;">348</li><li style="box-sizing: border-box; padding: 0px 5px;">349</li><li style="box-sizing: border-box; padding: 0px 5px;">350</li><li style="box-sizing: border-box; padding: 0px 5px;">351</li><li style="box-sizing: border-box; padding: 0px 5px;">352</li><li style="box-sizing: border-box; padding: 0px 5px;">353</li><li style="box-sizing: border-box; padding: 0px 5px;">354</li><li style="box-sizing: border-box; padding: 0px 5px;">355</li><li style="box-sizing: border-box; padding: 0px 5px;">356</li><li style="box-sizing: border-box; padding: 0px 5px;">357</li><li style="box-sizing: border-box; padding: 0px 5px;">358</li><li style="box-sizing: border-box; padding: 0px 5px;">359</li><li style="box-sizing: border-box; padding: 0px 5px;">360</li><li style="box-sizing: border-box; padding: 0px 5px;">361</li><li style="box-sizing: border-box; padding: 0px 5px;">362</li><li style="box-sizing: border-box; padding: 0px 5px;">363</li><li style="box-sizing: border-box; padding: 0px 5px;">364</li><li style="box-sizing: border-box; padding: 0px 5px;">365</li><li style="box-sizing: border-box; padding: 0px 5px;">366</li><li style="box-sizing: border-box; padding: 0px 5px;">367</li><li style="box-sizing: border-box; padding: 0px 5px;">368</li><li style="box-sizing: border-box; padding: 0px 5px;">369</li><li style="box-sizing: border-box; padding: 0px 5px;">370</li><li style="box-sizing: border-box; padding: 0px 5px;">371</li><li style="box-sizing: border-box; padding: 0px 5px;">372</li><li style="box-sizing: border-box; padding: 0px 5px;">373</li><li style="box-sizing: border-box; padding: 0px 5px;">374</li><li style="box-sizing: border-OpenGL

OpenGL源码下载

1. LightHouse3D

http://www.lighthouse3d.com/tutorials

点评：opengl，webgl，GLSL等技术讲解和资料下载。该网站一直有人维护更新。

2. codesampler

http://www.codesampler.com/

点评：用的最久，最靠谱的。里面的OpenGL代码偏老了，还有dx的源码下载，OpenGL的shader代码偏少。

3. OpenGL Modern Demo

http://es.g0dsoft.com/?page_id=236

点评：代码都在OpenGL3.0以上，opengl shader居多，打包下载所有demo研究。

4. OpenGL Modern Tutorial

http://ogldev.atspace.co.uk/

点评：课程多，讲解详细，OpenGL3.3以上，适合初学者，有代码下载。

5. OpenGL3.3+的例子

http://www.opengl-tutorial.org/

点评：讲解详细，源码下载。

 

OpenGL优质博客

1. NeHe

http://www.yakergong.net/nehe/

点评：内容详实有源码下载。但是OpenGL的内容和技术偏固定管线，shader的不多。

2. OpenGL

http://www.songho.ca/opengl/index.html

点评：作者是岛国的OpenGL技术大牛，讲解仔细全面。但是OpenGL版本偏旧，对传统的固定管线，矩阵变换，VBO，PBO，FBO等讲解。有代码下载。

3. Paul Project

http://www.paulsprojects.net/index.html

点评：OpenGL界的大牛paul的博客，2002-2007年的，opengl技术偏旧，但是讲解详细，有血有肉。有代码下载。

4. opengl博客

http://www.zwqxin.com/

 

其他途径

1. OpenGL官网，WIKI

https://www.opengl.org/ 获取最新的业界资讯。

https://www.opengl.org/wiki/Main_Page  上面最新的技术讲解，便于查阅。

2. OpenGL技术群，97111013

点评：共享里面有丰富的源码资料下载。

3. webgl版本的动画演示PPT

http://acko.net/files/fullfrontal/fullfrontal/webglmath/online.html

4. http://www.zwqxin.com/
如何新建eclipse的工作空间（workspace）
新建Eclipse的工作空间实际上很简单，但没单独出来这功能所以显得很隐蔽
两种方法解决： 
      1.打开Eclipse后，会有工作空间选择提示，点击【浏览】或者【Browse】找到你想新建工作空间的地方直接新建文件夹就好了，这就是你新的工作空间 
     2.Eclipse界面也可以建，File【文件】- Switch Workspace【切换工作空间】-Other【其他】- Browse【浏览】，然后跟上面步骤一样，新建文件夹就好了

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请标明出处。

Android TV 初步（一）
最近去了一家新公司，其中很多项目是建立在电视上的，但发现开发的大部分项目跟手机上的没什么区别，只是界面布局稍微麻烦点，今天翻墙去了谷歌官网，发现针对不同的设备（手机，手表，眼镜，电视）都有不同的构建过程，既然谷歌API 已经针对不同设备推出了不同的构建过程，为什么不试一试呢，楼主打算从今天起学习 Building TV Apps，每天和大家分享一点学习心得！





版权声明：本文为博主原创文章，未经博主允许不得转载。

UItableView中的一些方法
有关UITableView的知识点相对比较简单，一些简单的常用的方法有时间在写上：
下面的几个方法如果只是展示UITableView是用不到的，需要对相应的区段进行操作的时候才会用到。


方法如下：
// Row insertion/deletion/reloading.

//更行的方法
- (void)beginUpdates;  
//允许多个插入/删除行和部分同时动画。嵌套的
- (void)endUpdates;   
//也就是只有insert/delete/reload calls方法或者改变编辑的状态带一个更新的代码段内，否则是没用的，比如：行


//相对于区段（也就是：行）来讲的。
- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; //插入
- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//删除
- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);//重新加载
- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath NS_AVAILABLE_IOS(5_0);//移动行

//这个相对于段，也就是section来操作的
- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;//插入
- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;//删除
- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation NS_AVAILABLE_IOS(3_0);//重新加载
- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection NS_AVAILABLE_IOS(5_0);//移动





版权声明：本文为博主原创文章，未经博主允许不得转载。

推荐一个比较全的android在线源代码
推荐一个比较全的android在线源代码：
http://grepcode.com/project/repository.grepcode.com/java/ext/com.google.android/android/


版权声明：本文为博主原创文章，未经博主允许不得转载。

安卓代码混淆注意事项
安卓代码混淆时经常会出现各种问题，下面罗列一些注意事项


1.依赖的工程中使用的jar包若和工程自身中的jar包一样的话，直接删除依赖工程中相同的jar包即可

2.native方法要阻止混淆   
 例：
# natvie 方法不混淆
-keepclasseswithmembernames class * { 
    native <methods>;
} 


3.若自定义基类Activity中有根据名称为控件注入值的要采用如下方法阻止字段被混消

如 基类Activity中有如下控件注入方法  


	protected void smartInject() {  
        Class<? extends Activity> clz=getClass();   
        Field[] fs=clz.getDeclaredFields();  
        Resources res = getResources();  
        String packageName = getPackageName();  
        for (Field field : fs) {  
        	if (!View.class.isAssignableFrom(field.getType())) {
				continue;
			}
            int viewId = res.getIdentifier(field.getName(), "id", packageName);  
            if (viewId==0)   
                continue;  
            field.setAccessible(true);  
            try {  
                View v=findViewById(viewId);  
                field.set(this,v);  
                Class<?> c=field.getType();  
                Method m=c.getMethod("setOnClickListener", android.view.View.OnClickListener.class);  
                m.invoke(v, this);  
            } catch (Throwable e) {  
//                e.printStackTrace();  
            }  
            field.setAccessible(false);  
              
        }  
          
    } 



-keep class 应用包名.R$id{*;}
 
 
-keep public class * extends 包名.基类Activity {


      <fields>;
}




3.常见的一些阻止代码混淆的写法

-keep class com.iflytek.**{*;}






-libraryjars libs/BaiduLBS_Android.jar
-libraryjars libs/fastjson-1.1.39.jar 
-libraryjars libs/bcprov-jdk15-143.jar
-libraryjars libs/android-support-v4.jar


 
 




-keep class com.baidu.** { *; } 


-keep class vi.com.gdi.bgl.android.**{*;} 


-keep class okio.** {*;}
-dontwarn  okio.**
-dontwarn  com.alibaba.**
-dontwarn  org.bouncycastle.**



-keepattributes Signature
-keepattributes *Annotation*


版权声明：本文为博主原创文章，未经博主允许不得转载。

Android异步消息处理机制(3)AsyncTask基本使用
本文翻译自android官方文档，结合自己测试，整理如下。
概述
AsyncTask抽象类，翻译过来就是异步任务，能够合理并方便的使用UI线程。该类可以实现将后台操作结果显示在UI线程中，而不需要我们自己实现子线程或者handler（当然它内部也是借助这两者实现的）。
虽然AsyncTask可以提供后台运行并将结果显示在UI上，但是理想情况应该是后台操作最多只能是几秒钟，若要执行长时间的操作强烈建议使用java中的Executor,ThreadPoolExecutor,FutureTask等。
AsyncTask直接继承Object类，位于android.os.AsyncTask。一个AsyncTask实现类接收三个泛型参数：Params，Progress和Result，需要四步完成：onPreExecute()，doInBackground()，onProgressUpdate()，onPostExecute()。
基本用法
通过继承AsyncTask类实现自己的异步任务。
泛型参数
AsyncTask接收三个泛型参数分别为：

Params 
可用于在后台任务中使用。
Progress 
后台任务执行的进度。
Result 
任务执行的结果。

若不用以上参数的话，可以指定为Void类，例如：
private class MyTask extends AsyncTask<Void, Void, Void> { ... }
四个方法
若要执行异步任务通常需要实现以下四个方法：
onPreExecute()
该方法会在后台任务开始之前被调用，通常在这里可以完成一些界面初始化工作。
doInBackground()
在onPreExecute()执行完之后就会调用该方法，此时进入到后台任务（子线程中，因此不能更新UI操作）。若AsyncTask类中的第三个参数不是Void类的话，则该方法需要返回第三个泛型参数类型值。若想显示任务进度的话可以在该方法中调用publishProgress()方法将进度传递给onProgressUpdate()。
onProgressUpdate()
当在doInBackground()中调用publishProgress()方法后，该方法就会在UI线程中被调用，可以用于更新UI。该方法可以在后台任务执行的同时更新UI。
onPostExecute()
当doInBackground()执行完成后，且第三个泛型参数不是Void时，就会在UI线程中调用该方法。后台任务执行结果将以参数的形式传递进来，因此可以在这里执行任务完成后的操作。
终止任务
在后台任务执行时可以通过调用cancel()方法来终止该任务。调用该方法之后，在doInBackground()执行后将调用onCancelled()，而不再会调用onPostExecute()。为了尽可能快的将任务结束，我们应该在doInBackground()中总是时刻检查isCancelled()`的返回值（例如可以使用循环检查）。
线程规则
为了让该类能合理的执行，以下规则需要注意一下：

AsyncTask类必须在UI线程中加载，这个该步骤作为JELLY_BEAN自动完成。
实例必须在UI线程中创建。
必须在UI线程中调用execute()。
不要手动调用onPreExecute()，doInBackground()，onProgressUpdate()，onPostExecute()。
任务只能被执行一次，若执行第二次的话将会抛出异常。

内存可观察性（Memory observability）
按照下列方法，AsynTask保证所有回调方法调用不用加synchronized也是线程安全的：

在构造器或onPreExecute()设置成员变量，在doInBaclground()引用。
在doInBaclground()设置成员变量，在onProgressUpdate()和onPostExecute()引用。

执行顺序
这一部分将在源码分析中介绍请参考：Android异步消息处理机制(4)AsyncTask源码解析

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

真机上测试出现问题：An error occurred while trying to run the script
出现的错误:
在模拟器上面运行Aceshiutomation是没有问题的，但是在真机上运行老是出现问题。
问题：An error occurred while trying to run the script
问题：（图）

1、先测试不同的项目，查看语法是否修改过或者不小心写错。
2、可能是手机上面还没有设置允许Automation选项进行调试；要在手机的选项中 开启 “Enable UI Automation”这个一项。
打开步骤如下:

选项在手机上的setting -- development （这个项在下拉比较下的位置，要仔细找一下）
然后勾选 “Enable UI Automation”这一项即可。
图如下：







版权声明：本文为博主原创文章，未经博主允许不得转载。

android textview 中部分内容 颜色 样式 点击事件的设置
// 文本内容
		SpannableString ss = new SpannableString(remindtitle);
		int stringlength = ss.length();
		// 设置0-2的字符颜色
		ss.setSpan(new ForegroundColorSpan(Color.RED), 0, 2,
				Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
		// 设置2-5的字符链接到电话簿，点击时触发拨号
		ss.setSpan(new URLSpan("tel:7758521"), 2, 5,
				Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
		// 设置9-11的字符为网络链接，点击时打开页面
		ss.setSpan(new URLSpan("http://www.baidu.com"), 9, 11,
				Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
		// 设置13-15的字符点击时，转到写短信的界面，发送对象为10086
		ss.setSpan(new URLSpan("sms:10086"), 13, 15,
				Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
		// 粗体
		ss.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), stringlength - 8,
				stringlength, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
		// 设置0-2的字符颜色
		ss.setSpan(new ForegroundColorSpan(Color.RED), stringlength - 8,
				stringlength, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
		// 斜体
		ss.setSpan(new StyleSpan(android.graphics.Typeface.ITALIC), 7, 10,
				Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
		// 下划线
		ss.setSpan(new UnderlineSpan(), 10, 16,
				Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

		// Spanned.SPAN_EXCLUSIVE_EXCLUSIVEactivity跳转 前四个字符为可以点击的
		ss.setSpan(new ClickableSpan() {
			// 在onClick方法中可以编写单击链接时要执行的动作
			@Override
			public void onClick(View widget) {
				MyApp.showToast("点击了免责声明");
			}
		}, stringlength - 8, stringlength, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
		// 使用SpannableString对象设置TextView控件的内容
		tv_login_remind.setText(ss);
		// 在单击链接时凡是有要执行的动作，都必须设置MovementMethod对象
		tv_login_remind.setMovementMethod(LinkMovementMethod.getInstance());

版权声明：本文为博主原创文章，未经博主允许不得转载。

ios学习博客
点击打开链接

版权声明：本文为博主原创文章，未经博主允许不得转载。

直接topbar奔溃，出现 at java.lang.reflect.Constructor.constructNative(Native Method)

问题是因为适配导致的，在相应的机型上面做了那个属性的处理，而其他的却找不到相应的属性值，所以在基本的dimen里面千万别遗漏了
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

android 赋值或点击事件混乱
百度了一下，没有相应的资料，这是我的解决方式，希望对你有效
在activity中 控件命名尽量不要和控件的id相同，比如
TextView tv01;
tv01=findviewbyid (R.id.tv01);
这样就容易让android搞不清楚，我猜测是这样的原因。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android百度地图SDK：隐藏比例尺，隐藏百度LOGO，隐藏缩放控件
﻿﻿
Android百度地图SDK：隐藏（不显示）比例尺，隐藏（不显示）百度LOGO，隐藏（不显示）缩放控件


在自己的Android应用开发中使用百度地图SDK，百度会自动在MapView上添加百度的LOGO，缩放控制栏，比例尺，如果不想显示百度LOGO，隐藏缩放控制条，隐藏比例尺，那么通过以下代码即可完成：


// 隐藏百度的LOGO
		View child = mMapView.getChildAt(1);
		if (child != null && (child instanceof ImageView || child instanceof ZoomControls)) {
			child.setVisibility(View.INVISIBLE);
		}

		// 不显示地图上比例尺
		mMapView.showScaleControl(false);

		// 不显示地图缩放控件（按钮控制栏）
		mMapView.showZoomControls(false);
其中mMapView是类com.baidu.mapapi.map.MapView的实例。

版权声明：本文为博主原创文章，未经博主允许不得转载。转载请注明出处：http://blog.csdn.net/zhangphil

iOS下OpenGL ES 3.0编程入门（二 ）：画一个简单三角形
       上文我们讲解了如何构建一个hello world开发环境，那么这一篇我们就来画一个简单的三角形出来。
       首先，我要向大家介绍下opengl es的渲染流程，在2.0之前，es的渲染采用的是固定管线，何为固定管线，就是一套固定的模板流程，局部坐标变换 -> 世界坐标变换 ->观察坐标变换->背面消除->光照->裁剪->投影->视口计算->光栅化，程序员只需要调用固定的api修改一些配置参数就可以完成整个渲染流程了。而到了2.0，固定管线改成了可编程管线，我们对整个渲染流程可以再编程，没有固定的api给你调用，一切都依靠shader来完成。那么什么是shader呢：

Shader分为Vertex Shader顶点着色器和Pixel Shader像素着色器两种。其中Vertex
 Shader主要负责顶点的几何关系等的运算，Pixel Shader主要负责片源颜色等的计算。

着色器替代了传统的固定渲染管线，可以实现3D图形学计算中的相关计算，由于其可编辑性，可以实现各种各样的图像效果而不用受显卡的固定渲染管线限制。这极大的提高了图像的画质。

好了，介绍完渲染流程，我们变进入正题，如何在上一篇的基础上完成一个简单三角形的渲染呢？

首先，我们要建立一个三角形的局部坐标系，也就是三角形每个点的顶点坐标。

GLKVector3 vec[3]={
    {0.5,0.5,0.5},
    {-0.5,-0.5,0.5},
    {0.5,-0.5,-0.5}
};        然后，因为我们介绍的是opengl es3.0的编程，所以我们用的是可编程管线，那么我们就应该建立一个vertex shader文件和一个pixel shader文件，分别命名为shader.vsh和shader.fsh。

shader.vsh：

attribute vec3 position;   //入参，主程序会将数值传入
void main()
{
    gl_Position = vec4(position,1);  //顶点经过投影变换变换后的位置
}       shader.fsh：

void main()
{
    gl_FragColor = vec4(0.5,0.5,0.5,1);   //顶点的颜色
}       可以看到，每一个着色器文件都一个类似于c语言的main函数入口，这个就是着色器的入口，所有的代码都从这里开始执行。

编写完着色器后，我们便需要在主程序里加载shader了，加载shader的代码基本上不需要变动什么，直接copy过来就可以了。

- (BOOL)loadShaders
{
    GLuint vertShader, fragShader;
    NSString *vertShaderPathname, *fragShaderPathname;
    
    // Create shader program.
    program = glCreateProgram();
    
    // Create and compile vertex shader.
    vertShaderPathname = [[NSBundle mainBundle] pathForResource:@"Shader" ofType:@"vsh"];
    if (![self compileShader:&vertShader type:GL_VERTEX_SHADER file:vertShaderPathname]) {
        NSLog(@"Failed to compile vertex shader");
        return NO;
    }
    
    // Create and compile fragment shader.
    fragShaderPathname = [[NSBundle mainBundle] pathForResource:@"Shader" ofType:@"fsh"];
    if (![self compileShader:&fragShader type:GL_FRAGMENT_SHADER file:fragShaderPathname]) {
        NSLog(@"Failed to compile fragment shader");
        return NO;
    }
    
    // Attach vertex shader to program.
    glAttachShader(program, vertShader);
    
    // Attach fragment shader to program.
    glAttachShader(program, fragShader);
    
    // Link program.
    if (![self linkProgram:program]) {
        NSLog(@"Failed to link program: %d", program);
        
        if (vertShader) {
            glDeleteShader(vertShader);
            vertShader = 0;
        }
        if (fragShader) {
            glDeleteShader(fragShader);
            fragShader = 0;
        }
        if (program) {
            glDeleteProgram(program);
            program = 0;
        }
        
        return NO;
    }
    // Release vertex and fragment shaders.
    if (vertShader) {
        glDetachShader(program, vertShader);
        glDeleteShader(vertShader);
    }
    if (fragShader) {
        glDetachShader(program, fragShader);
        glDeleteShader(fragShader);
    }
    
    return YES;
}

- (BOOL)compileShader:(GLuint *)shader type:(GLenum)type file:(NSString *)file
{
    GLint status;
    const GLchar *source;
    
    source = (GLchar *)[[NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil] UTF8String];
    if (!source) {
        NSLog(@"Failed to load vertex shader");
        return NO;
    }
    
    *shader = glCreateShader(type);
    glShaderSource(*shader, 1, &source, NULL);
    glCompileShader(*shader);
    
#if defined(DEBUG)
    GLint logLength;
    glGetShaderiv(*shader, GL_INFO_LOG_LENGTH, &logLength);
    if (logLength > 0) {
        GLchar *log = (GLchar *)malloc(logLength);
        glGetShaderInfoLog(*shader, logLength, &logLength, log);
        NSLog(@"Shader compile log:\n%s", log);
        free(log);
    }
#endif
    
    glGetShaderiv(*shader, GL_COMPILE_STATUS, &status);
    if (status == 0) {
        glDeleteShader(*shader);
        return NO;
    }
    
    return YES;
}

- (BOOL)linkProgram:(GLuint)prog
{
    GLint status;
    glLinkProgram(prog);
    
#if defined(DEBUG)
    GLint logLength;
    glGetProgramiv(prog, GL_INFO_LOG_LENGTH, &logLength);
    if (logLength > 0) {
        GLchar *log = (GLchar *)malloc(logLength);
        glGetProgramInfoLog(prog, logLength, &logLength, log);
        NSLog(@"Program link log:\n%s", log);
        free(log);
    }
#endif
    
    glGetProgramiv(prog, GL_LINK_STATUS, &status);
    if (status == 0) {
        return NO;
    }
    
    return YES;
}

- (BOOL)validateProgram:(GLuint)prog
{
    GLint logLength, status;
    
    glValidateProgram(prog);
    glGetProgramiv(prog, GL_INFO_LOG_LENGTH, &logLength);
    if (logLength > 0) {
        GLchar *log = (GLchar *)malloc(logLength);
        glGetProgramInfoLog(prog, logLength, &logLength, log);
        NSLog(@"Program validate log:\n%s", log);
        free(log);
    }
    
    glGetProgramiv(prog, GL_VALIDATE_STATUS, &status);
    if (status == 0) {
        return NO;
    }
    
    return YES;
}
      然后再viewdidload里面添加如下代码：

[self loadShaders];
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.1, 0.2, 0.3, 1);
    glGenVertexArrays(1, &vertexID);//生成一个vao对象
    glBindVertexArray(vertexID); //绑定vao
    GLuint bufferID;
    glGenBuffers(1, &bufferID);  //生成vboglBindBuffer(GL_ARRAY_BUFFER, bufferID);  //绑定
    glBufferData(GL_ARRAY_BUFFER, sizeof(vec), vec, GL_STATIC_DRAW); //填充缓冲对象
    GLuint loc=glGetAttribLocation(program, "position");   //获得shader里position变量的索引
    glEnableVertexAttribArray(loc);     //启用这个索引
    glVertexAttribPointer(loc, 3, GL_FLOAT, GL_FALSE, sizeof(GLKVector3), 0);  //设置这个索引需要填充的内容
    glBindVertexArray(0);   //释放vao
    glBindBuffer(GL_ARRAY_BUFFER, 0);  //释放vbo       这里我们用到了es 3.0里面的新技术vao（vertex array object）以及2.0里面的vbo。关于vao和vbo，我们会专门展开一章来探讨，现在大家知道就行啦。
       接下来便到了渲染阶段，这里的代码需要写在-(void)glkView:(GLKView
 *)view drawInRect:(CGRect)rect方法里。

-(void)glkView:(GLKView *)view drawInRect:(CGRect)rect
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);   //清除颜色缓冲和深度缓冲
    glBindVertexArray(vertexID);    
    glUseProgram(program);      //使用shader
    glDrawArrays(GL_TRIANGLES, 0, 3);     //绘制三角形
    glBindVertexArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}      代码阶段便编写完成啦，保存运行，出现如下界面便大功告成啦。













版权声明：本文为博主原创文章，未经博主允许不得转载。

QT 学习遇到的问题记录1—QT C++ 调用 Java
最近公司移动开发的同学走了，临时起意看了下。
安卓开发的java不会，ios的oc也没真正耍过，以前C++还比较熟，看最近qt连出了两个版本5.4,5.5，好像还不错，就看了下。


qt支持跨平台，就不多说了，本来就看这个特点来玩玩。
先玩Qt for andriod ，一些原生的东西还是依赖安卓自己，那需要java，所以先玩了下 c++调用 java
遇到问题，返回值老是不对。具体问题下面说了。


1.使用JNI技术，使用已封装的QAndroidJniObject很方便，没用传统的JNI ，毕竟已经封装过的简单很多。
    但是也带来个问题，调用失败，没有异常抛出，也没有找到特别的能拿到相应错误信息的方法。原始JNI好像通过 Env可以拿异常信息。有知道的看客知会一声。
2.调用静态方法有  callStaticMethod 和 callStaticObjectMethod，前一个返回值是标准类型，可用模版参数
  第二个用于返回值是对象。 返回标准类型的很容易成功，基本没有机会出错。
3.调用实例方法有 callMethod 和 callObjectMethod，区别类似
4.返回值参数见帮助文档。
  容易出问题的点，
对象定义最后的分号（callStaticMethod 和callMethod 不需要）
[ 用于数组对象，不是数组不要加【就因为这个没注意浪费了一天时间】


Object Types

Type Signature
jobject L<fully-qualified-name>;
jclass
jstring
jobjectArray [L<fully-qualified-name>;
jarray [<type>
jbooleanArray [Z
jbyteArray [B
jcharArray [C
jshortArray [S
jintArray [I
jlongArray [J
jfloatArray [F
jdoubleArray [D
Primitive Types


Type Signature
jboolean Z
jbyte B
jchar C
jshort S
jint I
jlong J
jfloat F
jdouble D
Other


Type Signature
void V



-----
只说问题和要点，简约了点，，主要是给自己记录下。看客见谅

版权声明：本文为博主原创文章，未经博主允许不得转载。

【读书笔记】iOS-简单的数据驱动程序

一，效果图。

 



 

二，，工程文件如下图所示：

 



 

三，DataModel.h



#import <Foundation/Foundation.h>

 

@interface DataModel : NSObject

{

    NSArray *myData;

}

-(NSString *)getNameAtIndex:(int)index;

-(int)getRowCount;

 

@end

 

 



 

 DataModel.m



//数据库文件

#import "DataModel.h"

 

@implementation DataModel

 

-(id)init

{

    if (self=[super init]) {

        

        myData=[[NSArray alloc]initWithObjects:@"first",@"second",@"three",@"four", nil];

     }

    return self;

}

//显示数组中数据

-(NSString *)getNameAtIndex:(int)index

{

    return (NSString *)[myData objectAtIndex:index];

}

//显示行数

-(int)getRowCount

{

    return (int)[myData count];

}

@end

 



 

四，ViewController.h



#import <UIKit/UIKit.h>

#import "DataModel.h"

 

@interface ViewController : UIViewController

<UITableViewDataSource,UITableViewDelegate>

{

    UITableView *myTableView;

    DataModel *model;

}

@end

 



ViewController.m



#import "ViewController.h"

 

@interface ViewController ()

@end

 

@implementation ViewController

 

- (void)viewDidLoad {

    [super viewDidLoad];

    // Do any additional setup after loading the view, typically from a nib.

    //初始化数据

    [self initData];

    //初始化界面

    [self addBackgroundView];

}

#pragma -mark -functions

//初始化数据

-(void)initData

{

     model=[[DataModel alloc]init];

}

//初始化界面

-(void)addBackgroundView

{

    myTableView=[[UITableView alloc]initWithFrame:CGRectMake(0, 100, 320, 300)];

    myTableView.dataSource=self;

    myTableView.delegate=self;

    [self.view addSubview:myTableView];

 

}

#pragma -mark -UITableViewDelegate

-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section

{

    return [model getRowCount];

}

-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath

{

    return 40;

}

-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath

{

    static NSString *CellIdentifier=@"Cell";

    UITableViewCell *cell=[tableView dequeueReusableCellWithIdentifier:CellIdentifier];

    if (cell==nil) {

        cell=[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier];

    }

    cell.textLabel.text=[NSString stringWithFormat:@"%@",[model getNameAtIndex:(int)indexPath.row]];

    return cell;

    

}

- (void)didReceiveMemoryWarning {

    [super didReceiveMemoryWarning];

    // Dispose of any resources that can be recreated.

}

 

@end

 



参考资料：《iOS数据库应用高级编程（第2版）》

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android:学习笔记（一）
在android学习中遇到的一些问题，记录一下。
1、解决edittext感叹号的问题。 
This text field does not specify an inputType or a hint
加入下面代码即可解决：
android:hint="@null"
2、解决android4.0后edittext边框不全显示的问题
android:background="@android:drawable/edit_text"
3、感叹号问题 
android:password is deprecated: Use inputType instead
把
android:password="true"
修改为
android:inputType="textPassword"
4、java.lang.IllegalStateException: Could not execute method of the activity
出现这种问题，就只能恨自己太大意了。 
没有将activity添加到资源文件中

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 获取状态栏标题栏等的高度
开发中有时需要获取到手机状态栏、标题栏的高度。
状态栏：显示手机状态（信号、电量等）信息的那个栏
标题栏：显示应用标题的那个栏
如下图：
手机1280*720获取的信息：


代码如下：

	@Override
	public void onWindowFocusChanged(boolean hasFocus) {
		super.onWindowFocusChanged(hasFocus);

		Rect rect = new Rect();
		getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);
		// 状态栏高度
		int statusBarHeight = rect.top;
		View v = getWindow().findViewById(Window.ID_ANDROID_CONTENT);
		int contentTop = v.getTop();

		// 标题栏高度
		int titleBarHeight = contentTop - statusBarHeight;
		tv_titlebar.setText("标题栏的高度：" + Integer.toString(titleBarHeight) + "\n"
				+ "状态栏高度：" + statusBarHeight + "\n" + "视图的宽度：" + v.getWidth()
				+ "\n" + "视图的高度（不包含状态栏和标题栏）：" + v.getHeight());

	}





版权声明：本文为博主原创文章，未经博主允许不得转载。

Android Studio查看应用数字签名-android学习之旅(76)
Android Studio和Eclispe还是有比较大的区别,在这地方,eclipse可以直接在设置里面,而AS就需要通过Terminal来查看
步骤
1.首先定位到.android 一般都是在C盘的用户名底下cd C:\Users\Euler-KalvinHe.android
Euler-KalvinHe是我的用户名
2.使用java的keytool.exe和.android目录下的的debug.keystore ,如果没有加环境变量,我建议你使用绝对路径”C:\Program Files\Java\jre7\bin\keytool.exe” -list -v -keystore “C:\Users\Euler-KalvinHe.android\debug.keystore”
会让你输入默认的秘钥 android

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

百度地图Android SDK在线开发文档
百度地图针对开发者的在线文档（Android SDK）连接地址：点击此处查看。


﻿﻿

版权声明：本文为博主原创文章，未经博主允许不得转载。转载请注明出处：http://blog.csdn.net/zhangphil

Fragment Commit 异常处理
自从Honeycomb发布后，像下面这个栈信息经常会在StackOverFlow中出现
java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState
at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1327)
at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1338)
at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)
at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)
这篇博客会解释问题出现的原因，并会给出解决这个问题的思路
抛出异常的原因

抛出异常的原因是  
在Activity的状态已经保存后commit一个FragmentTransaction，导致了一个现象叫做Activity state loss。

在我们深入细节之前，让我们先看看在onSaveInstanceState()调用后发生了什么。在我的前一篇 Binders & Death Recipients有讨论到,Android应用程序在Android系统中只有很小的控制权。Android系统为了释放内存可以在任意时刻停止进程，然后处于后台的Activity就会被毫无警告地杀掉。为了保证因此引起的不稳定行为避免用户知道，Android框架为每一个Activity通过调用onSaveInstanceState()来保存自己状态的机会，它会在Activity可能被销毁之前调用。当后面恢复状态的时候，用户不会感觉到Activity已经被系统杀掉了，而会感觉前台和后台的Activity无缝切换。 
当Android框架调用onSaveInstanceState()，并传递一个Bundle对象，以便Activity恢复状态。Activity可以将它的Dialog、fragment以及view的状态保存在Bundle中。当这个方法返回的时候，系统通过Binder打包Bundle对象然后传给系统服务进程。系统服务进程负责保证Bundle对象安全地保存下来。当系统决定重新创建Activity后，会取出这个Bundle对象，以便复原Activity状态。 
所以为什么这个异常会抛出?原因是那些Bundle对象代表Activity在onSaveInstanceState()被调用时的一个快照。这就意味着当你在onSaveInstanceState()之后调用FragmentTransaction#commit()的时候，transation不会被记录，所以之前Activity的状态没有被完整保存。从用户的角度来说，这个transaction就像丢失了，导致UI状态意外的丢失。为了保证用户体验，Android会不计一切代价避免状态丢失，也就是当它发生的时候会简单地抛出一个IllegalStateException。
这个异常什么时候会抛出？
如果你之前已经碰到过这个异常，你可能会注意到异常抛出的时机因不同的Android版本而不同。比如，老版本的设备上，这个异常很少抛出，而当你的程序中使用support library而不是官方框架中的类时却容易触发这个异常。这些轻微的差别让很多人都以为support library有bug，不值得信任。然而，这些假设存在误解。
这些差别是因为在Honeycomb版本中，Activity生命周期有了重要的变化。Honeycomb之前版本，activity在onPause()之前不会被杀掉，这意味着onSaveInstanceState()会在onPause()之前被调用。而从HoneyComb开始，Activity只会在OnStop()后被杀掉，这意味着onSaveInstanceState()会在onStop()之前被调用而不是在onPause()之前。这些变化在下表中总结：



知识点
Honeycomb之前
Honeycomb之后



Activity是否可以在onPause()之前被杀掉?
NO
NO


Activity是否可以在onStop()之前被杀掉?
YES
NO


onSaveInstanceState(Bundle) 保证在…之前被调用
onPause()
onStop()


怎么避免这个异常？

在Activity生命周期方法中commit transation的时候一定要小心。 
很多应用程序只会在onCreate()或者为了响应用户输入的时候调用一次，所以他们不会遇到任何问题。 
然而，当你的transation在其他的生命周期比如onActivityResult()，onStart()，onResume() 中commit的时候，事情就可能变得棘手了。 
比如，你不应该在FragmentActivity#onResume() 方法中commit transation，为了避免这个方法在Activity的状态恢复之前被调用。 
如果你的应用程序需要在处理onCreate()之外的生命周期方法中commit transation，建议在FragmentActivity#onResumeFragments() 或者Activity#onPostResume()中调用。 
这两个方法会被保证在Activity恢复它的状态之后调用，因此会避免可能的状态丢失。（一个关于如何去做的例子，可以查看我在StackOverFlow上回答如何正确地响应Activity#onActivityResult()方法，然后commit FragmentTransactions）
避免是异步调用方法中执行transactions 
这个包括经常被使用的方法比如AsyncTask#onPostExecute() 和 LoaderManager.LoaderCallbacks#onLoadFinished() 。在这些方法中执行transactions会有问题，因为他们当这些方法被回调的时候，他们不知道Activity当前的生命周期。比如，考虑下面的事件序列： 
一个Activity执行一个AsyncTask
用户按下Home键，导致这个Activity的onSaveInstanceState()和onStop() 方法被回调。
AsyncTask完成然后onPostExecute()被调用，而不知道Activity已经处于stopped状态。
在onPostExectute()方法中的FragmentTransaction被committed，导致一个异常被抛出。

总之，在这些案例中避免异常抛出的最优方法就是避免在异步回调方法中commit transactions。Google工程师似乎同意这个见解。根据在Android Develop group上的这篇文章，Android开发团队认为通过commit FragmentTransactions来让UI产生重大的变化对用户体验十分不友好。如果你的应用程序需要在这些回调方法中执行transaction，那么没有什么简单方法可以保证这些回调不会再onSaveInstanceState()后调用，你可能必须使用commitAllowStateLoss()并且处理可能发生的状态丢失。(详见两篇StackOverFlow文章，文章1、文章2)

只使用commitAllowingStateLoss()作为最后的解决方案 
commit()和commitAllowingStateLoss()唯一的区别是后者在状态丢失的时候不会抛出异常。通常你不会想使用这个方法因为它意味着状态丢失可能发生。更好的解决方案当然是修改你的程序以便commit()被保证在activity的状态被保存前调用，因为这样可能会让用户体验更好。除非状态丢失是不可避免的，否则commitAllowingStateLoss()就不应该被使用。

小结
Commit FragmentTransaction   —->  activity onSaveInstanceState(Bundle)（Activity状态保存）   Right
OnResume()  Called           —->  activity restored(Activity被恢复)   —> Commit FragmentTransaction   Right
用图形象表示如下： 


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        
Android异步消息处理机制(4)AsyncTask源码解析
上一章我们学习了抽象类AsyncTask的基本使用（地址：http://blog.csdn.net/wangyongge85/article/details/47988569），下面我将以问答的方法分析AsyncTask源码内容，源码版本为：API22。
1. 为什么必须在UI线程实例化我们的AsyncTask，并且必须在主线程中调用execute(Params... params)？
在分析为什么在UI线程调用之前，我们先看一下实例化AsyncTask并调用execute(Params... params)都完成了哪些工作。
我们知道实例化对象时，首先会调用父类的构造器，那么我们先看一下AsyncTask的构造器以及涉及到的内容相关源码：

// AsyncTask中的内部抽象类，实现接口Callable（没有实现call方法），封装传入的参数数组
private static abstract class WorkerRunnable<Params, Result> implements Callable<Result> {
    Params[] mParams;
}
private final WorkerRunnable<Params, Result> mWorker;
private final FutureTask<Result> mFuture;
// AsyncTask构造器，必须在UI线程中调用
public AsyncTask() {
    mWorker = new WorkerRunnable<Params, Result>() {
        public Result call() throws Exception {
            // 标记任务是否被执行
            mTaskInvoked.set(true);
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            return postResult(doInBackground(mParams));
        }
    };
    mFuture = new FutureTask<Result>(mWorker) {
        @Override
        protected void done() {
            try {
                postResultIfNotInvoked(get());
            } catch (InterruptedException e) {
                android.util.Log.w(LOG_TAG, e);
            } catch (ExecutionException e) {
                throw new RuntimeException("An error occured while executing doInBackground()",
                        e.getCause());
            } catch (CancellationException e) {
                postResultIfNotInvoked(null);
            }
        }
    };
}

我们看到AsyncTask构造器主要是初始化两个对象：mWorker和mFuture。mWorker实际上是Callable对象，并且带有成员变量mParams（第一个泛型参数数组类型），我们知道Callable接口实现的线程有返回值，即call()方法的返回值postResult(doInBackground(mParams))，这里调用了doInBackground(mParams)，注意，目前call()方法还未执行；mFuture是FutureTask对象，使用mWorker进行初始化。FutureTask是Future接口和Runnable接口的实现类，能够控制关联的callable对象即mWorker，同样该对象的任何方法也未开始执行。
在实例化AsyncTask类之后，我们通常调用execute(Params... params)方法，那么自然要看一下`execute(Params... params)相关源码了：

public static final Executor SERIAL_EXECUTOR = new SerialExecutor();

private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;

public final AsyncTask<Params, Progress, Result> execute(Params... params) {
        return executeOnExecutor(sDefaultExecutor, params);
    }

// execute直接调用这个方法
public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,
            Params... params) {
        // 任务还未被执行
        if (mStatus != Status.PENDING) {
            switch (mStatus) {
                // 正在执行的任务不能再次执行
                case RUNNING:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task is already running.");
                // 已经完成的任务不能再次执行，这也是为什么一个对象只能执行一次的原因
                case FINISHED:
                    throw new IllegalStateException("Cannot execute task:"
                            + " the task has already been executed "
                            + "(a task can be executed only once)");
            }
        }
        // 标记任务进入运行状态
        mStatus = Status.RUNNING;
        // 将调用我们覆盖的方法
        onPreExecute();
        // 传递参数
        mWorker.mParams = params;
        // 开始执行mFuture
        exec.execute(mFuture);
        return this;
    }

execute()直接调用executeOnExecutor(Executor exec,Params... params)，该方法第一个参数是SerialExecutor对象sDefaultExecutor，第二个参数是我们定义的Params，那么我们就来详细分析一下该方法。首先判断任务是否第一次执行，若不是第一次就会抛出异常（注意case块没有break语句）；否则就会向下执行。首先标记任务进入执行状态；接着调用我们覆盖的onPreExecute()方法，这也说明了为什么这是第一个开始执行的方法了，同时我们知道onPreExecute()常用来初始化UI，必须在主线程中调用，因此execute()必须在主线程中调用。并且我们观察到目前仍然在主线程中；最后会执行SerialExecutor对象sDefaultExecutor的execute(mFuture)。那么该方法又会做哪些事情呢？我们进入该方法一探究竟：

private static class SerialExecutor implements Executor {
    // 双端队列保存AsyncTask任务
    final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    // 在这里mFuture将会调用mWorker的call()方法
                    r.run();
                } finally {
                    // 在执行完前一个任务时执行下一个任务，实现任务的串行执行
                    scheduleNext();
                }
            }
        });
        // 首次实例化AsyncTask执行该方法，
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}

静态内部类SerialExecutor的execute()方法依次执行的内容是：首先调用mTask的offer()添加Runnable实例，在该实例的run()方法中调用传递过来的参数mFuture的run()方法，同时finally块中执行scheduleNext()，这一步就完成了向队列mTask中添加Runnable实例；接着判断mActive是否为null，第一次当然为null，因此会执行scheduleNext()。scheduleNext()也是SerialExecutor类中的方法，该方法会执行THREAD_POOL_EXECUTOR.execute(mActive)，其中mActive是从队列中取出来的Runnable对象。THREAD_POOL_EXECUTOR是线程池对象，使用线程池中的线程执行mActive。在mActive中就会执行刚才放进去的mFuture的run()方法，该方法的代码如下：

public void run() {
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    // 这里执行call()方法
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            runner = null;
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }

该方法实际上调用Callable对象的call()，那么这个Callable对象又是什么呢？还记得在AsyncTask中实例化的mWorker对象么。。。没错这个执行的就是mWorker对象的call()方法，终于绕过来了！！！！而在call()方法中会执行doInBackground(mParams)，因此该方法是在后台线程执行的方法。
sDefaultExecutor是静态成员变量，每次创建AsyncTask对象都会添加到该变量中的mTasks队列中，而且AsyncTask对象是串行执行（实现原理是通过try/finnally块实现的，代码如上SerialExecutor的execute()）。
到目前为止仍然未解决为什么实例化AsyncTask需要在UI线程中执行。。。而且目前还不知道怎么将doInBackground(mParams)结果返回，那么我们先看看这个问题能不能解决为什么在UI线程中的问题。。
2.如何将doInBackground(mParams)结果返回？
我们知道在AsyncTask中实例化的mWorker对象的call()方法会返回postResult(doInBackground(mParams))，那么我们来看一下postResult()源码以及涉及到的其它源码：

// post()方法
private Result postResult(Result result) {
        @SuppressWarnings("unchecked")
        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
                new AsyncTaskResult<Result>(this, result));
        message.sendToTarget();
        return result;
    }

// getHandler()方法
private static Handler getHandler() {
        synchronized (AsyncTask.class) {
            if (sHandler == null) {
                sHandler = new InternalHandler();
            }
            return sHandler;
        }
    }

// 静态内部类InternalHandler
private static class InternalHandler extends Handler {
        public InternalHandler() {
            super(Looper.getMainLooper());
        }

        @SuppressWarnings({"unchecked", "RawUseOfParameterizedType"})
        @Override
        public void handleMessage(Message msg) {
            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;
            switch (msg.what) {
                case MESSAGE_POST_RESULT:
                    // 返回结果数组中的一个
                    result.mTask.finish(result.mData[0]);
                    break;
                case MESSAGE_POST_PROGRESS:
                    result.mTask.onProgressUpdate(result.mData);
                    break;
            }
        }
    }
// 静态内部类AsyncTaskResult
private static class AsyncTaskResult<Data> {
        final AsyncTask mTask;
        final Data[] mData;

        AsyncTaskResult(AsyncTask task, Data... data) {
            mTask = task;
            mData = data;
        }
    }

上面一共四部分，第一部分是postResult()源码，该方法中首先调用了getHandler()（源码在第二部分），返回一个InternalHandler对象（源码在第三部分）。而InternalHandler对象就是一个Handler对象（若对Handler机制不了解的话建议参考我之前的文章：Android异步消息处理机制(1)Handler基本使用 
和 Android异步消息处理机制(2)源码解析），调用该对象的obtainMessage()返回一个Message对象，然后通过Message对象的sendToTarget()将消息发送到消息队列中。然后会在Handler对象的handleMessage()中处理消息。
第三部分给出了InternalHandler类源码，发送的消息将在该类的handleMessage()中处理。在该方法中首先获得AsyncTaskResult对象（源码在第四部分），AsyncTaskResult对象用于保存当前AsyncTask对象和postResult()传递的对象，而这里传递的正是doInBackground()返回结果，这样我们就将结果添加到Message对象中。
可以看到AsyncTask也是通过Handler机制实现异步处理：在子线程中处理完任务后将执行结果添加到Message中，然后在主线程中通过Looper对象取出该Message，通过对应的Handler对象的handleMessage()进行处理。
因为在postResult()中我们设置的Message的what为MESSAGE_POST_RESULT，因此在handleMessage()将会执行第一个case块：result.mTask.finish(result.mData[0])，在finish()中只接收结果数组中的第一个值。那么我们继续看一下finish()源码：

private void finish(Result result) {
        if (isCancelled()) {
            onCancelled(result);
        } else {
            onPostExecute(result);
        }
        mStatus = Status.FINISHED;
    }

可以看到若任务没有暂停，就会调用我们覆盖的方法onPostExecute(result)。
由于InternalHandler对象的Looper对象是通过Looper.getMainLooper()，即主线程中的Looper对象，因此必须在主线程中实例化我们的AsyncTask。
在handleMessage()还有一个case块，那么这个何时这执行呢？
3.调用publishProgress()如何实现向主线程中发送任务进度？
我们知道在doInBackground()中调用publishProgress()时就会将当前任务进度发送给主线程，那么我们来看一下该方法的源码：

protected final void publishProgress(Progress... values) {
        if (!isCancelled()) {
            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,
                    new AsyncTaskResult<Progress>(this, values)).sendToTarget();
        }
    }

是不是似曾相识？这个方法和postResult()方法一样，都是向消息队列中发送消息，该消息的what属性为MESSAGE_POST_PROGRESS，因此会执行handleMessage()的第二个case块，即执行我们覆盖的onProgressUpdate()，该方法就可以更新UI了。
4.如何并行执行任务？
我们知道通过SerialExecutor对象只能顺序（串行）执行任务，那么如何实现并行执行呢？我们知道调用execute(Params... params)实际上执行的是executeOnExecutor(sDefaultExecutor, params)，该方法第一个参数默认传递的是SerialExecutor对象。因此，我们可以通过调用executeOnExecutor(Executor, params)方法实现并行执行，前提是我们在该方法中的第一个参数传递一个用于并行执行线程的线程池。该线程池我们可以使用AsyncTask类自带的线程池THREAD_POOL_EXECUTOR，源码如下：

private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE = 1;
private static final BlockingQueue<Runnable> sPoolWorkQueue =
            new LinkedBlockingQueue<Runnable>(128);

public static final Executor THREAD_POOL_EXECUTOR
            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,
                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);

该线程池中最大线程个数为128，当然我们也可以使用自定义的线程池。
Android3.0之后，默认情况下，AsyncTask同时只能执行一个任务，我们可以灵活地改变默认配置，使得AsyncTask可以并行执行多任务。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Tigase开发笔记3：Tigase 参数配置说明
sm-plugin说明




参数

说明

参考





jabber:iq:register

注册服务







message-archive-xep-0136

消息归档

？




jabber:iq:auth

简单用户认证







urn:ietf:params:xml:ns:xmpp-sasl

SASL协商

参考



urn:ietf:params:xml:ns:xmpp-bind

资源绑定







urn:ietf:params:xml:ns:xmpp-session

session绑定







jabber:iq:roster

联系人名单管理







presence

xmpp顶级元素，上线广播







jabber:iq:privacy

隐身协议







jabber:iq:version

客户端版本







http://jabber.org/protocol/stats

是否发送统计信息，指向jabber.org发送







startls

tls加密







msgoffline

离线消息







vcard-temp

临时的vCard







http://jabber.org/protocol/commands

管理virtual domains的特别命令

参考



jabber:iq:private

私有数据存储







urn:xmpp:ping

心跳检测







pep

发布订阅插件

参考



domain-filter(basic-filter)

domain拦截器

参考



amp(basic-filter)

高级消息处理

参考1，参考2



zlib(basic-filter)

zlib压缩







message-carbons(basic-filter)

将stanzas投递到用户指定的资源







disco(basic-filter)

服务发现








标准错误代码




代码

说明





302

重定向，尽管HTTP规定中包含八种不同代码来表示重定向，Jabber只用了其中一个（用来代替所有的重定向错误）
。不过Jabber代码302是为以后的功能预留的，目前还没有用到。




400

坏请求，Jabber代码400用来通知Jabber客户端，一个请求因为其糟糕的语法不能被识别
。例如，当一个Jabber客户端发送一个的订阅请求给它自己活发送一条没有包含“to”属性的消息，Jabber代码400就会产生。




401

未授权的，Jabber代码401用来通知Jabber客户端它们提供的是错误的认证信息，如，在登陆一个Jabber服务器时使用一个错误的密码，或未知的用户名
。




402

所需的费用，Jabber代码402为未来使用进行保留，目前还不用到。



403

禁止，Jabber代码403被Jabber服务器用来通知Jabber客户端该客户端的请求可以识别，但服务器拒绝执行。目前只用在注册过程中的密码存储失败。



404

没有找到，Jabber代码404用来表明Jabber服务器找不到任何与JabberID匹配的内容，该JabberID是一个Jabber客户端发送消息的目的地
。如，一个用户打算向一个不存在的JabberID发送一条消息。如果接受者的Jabber服务器无法到达，将发送一个来自500级数的错误代码。




405

不允许的，Jabber代码405用在不允许操作被’from’地址标识的JabberID
。例如，它可能产生在，一个非管理员用户试图在服务器上发送一条管理员级别的消息，或者一个用户试图发送一台Jabber服务器的时间或版本，
或者发送一个不同的JabberID的vCard。




406

不被接受的，Jabber代码406用于服务器因为某些理由不接受一个包。例如，这个可能发生在
，一个Jabber客户端试图使用jabber:iq:private在服务器上存储信息，
但当前的用于存储的名字空间用”jabber:”开头（在Jabber里是一个被存的XML开头）。
另一种可能产生406错误的情况是当一个Jabber客户端试图用一个空密码注册到一台Jabber服务器上。




407

必须注册，Jabber代码407当前不被使用



408

注册超时，当一个Jabber客户端不能在服务器准备好的时间内发起一个请求时，Jabber服务器生成Jabber代码408
。这个代码当前只用于Jabber会话管理器使用的零度认证模式中。




409

冲突



500

服务器内部错误，当一台Jabber服务器遇到一种预期外的条件，该条件阻止服务器处理来自Jabber客户端的包，这是将用到Jabber代码500
。现在，唯一会引发500错误代码的时间是当一个Jabber客户端试图通过服务器认证，而该认证因为某些原因没有被处理（如无法保存密码）。




501

不可执行，当服务器不支持Jabber客户端请求的功能，使用Jabber代码501
。例如，该代码只当Jabber客户端发送一个认证请求，而该认证请求不包含服务器配置中定义的任何一种认证方式时，服务器发送Jabber代码501。
这个代码还被用于，当一个Jabber客户端试图注册一个不允许注册的服务器。




502

远程服务器错误，当因为无法到达远程服务器导致转发一个包失败时，使用Jabber代码502
。该代码发送的特殊例子包括一个远程服务器的连接的失败，无法获取远程服务器的主机名，以及远程服务器错误导致的外部时间过期。




503

服务无法获得，当一个Jabber客户端请求一个服务，而Jabber服务器通常由于一些临时原因无法提供该服务时，使用Jabber代码503
。例如，一个Jabber客户端试图发送一条消息给另一个用户，该用户不在线，但它的服务器不提供离线存储服务，
服务器将返回一个503错误代码给发送消息的JabberID。当为vcard-temp和jabber:iq:private名字空间设置信息时，
出现通过xdb进行数据存储的写入错误，也使用该代码。




504

远程服务器超时，Jabber代码504用于下列情况:试图连接一台服务器发生超时，错误的服务器名。



510

连接失败，Jabber代码510目前还没有使用。




扩展code(XMPPErrorCodeExtension枚举)，如果大家定义了，请加在此处。 ERROR_TH(4031, "cancel", "登陆过于频繁或者流量过大")



MUC相关技术

XEP-0004: 数据表单，用来交换数据。
CS和SM分离

tigase中是可行的，但是目前架构没有这样做。这样做会增加网络开销，目前此方案，不是很好，待尝试。
使用到得XEP

XEP-0184: Message Delivery Receipts，该扩展对server没有任何要求，只要client端支持就行。XEP-0004:表单数据，用来交换数据，form类型[http://xmpp.org/registrar/formtypes.html]XEP-0198:server端的消息确认，tigase中的配置，它的存在的意义在http://op-co.de/blog/posts/XEP-0198中已经描述的非常详细。XEP-199XEP-0114:Jabber组件协议
群聊室的属性

我们设计的群已经不是标准的xmpp群了，下面的属性是对于smack或者标准的xmpp群有意义的。

房间名称|muc#roomconfig_roomname描述|muc#roomconfig_roomdesc允许占有者更改主题|muc#roomconfig_changesubject最大房间占有者人数|muc#roomconfig_maxusers其 Presence 是 Broadcast 的角色|muc#roomconfig_presencebroadcast列出目录中的房间|muc#roomconfig_publicroom房间是持久的|muc#roomconfig_persistentroom房间是适度的|muc#roomconfig_moderatedroom房间仅对成员开放|muc#roomconfig_membersonly允许占有者邀请其他人|muc#roomconfig_allowinvites需要密码才能进入房间|muc#roomconfig_passwordprotectedroom密码|muc#roomconfig_roomsecret能够发现占有者真实 JID 的角色|muc#roomconfig_whois登录房间对话|muc#roomconfig_enablelogging仅允许注册的昵称登录|x-muc#roomconfig_reservednick允许使用者修改昵称|x-muc#roomconfig_canchangenick允许用户注册房间|x-muc#roomconfig_registration房间管理员|muc#roomconfig_roomadmins房间拥有者|muc#roomconfig_roomowners
线上服务器环境配置

tcp调优参考我之前的文章Linux TCP调优





Tigase默认jars包的版本信息（启动的日志文件中可以看到）





Loading component: amp :: componentInfo{Title=Tigase XMPP Server, Version=7.0.2-b3821/563fcf81 (2015-05-15/00:41:16), Class=tigase.server.amp.AmpComponent}
Loading component: bosh :: componentInfo{Title=Tigase XMPP Server, Version=7.0.2-b3821/563fcf81 (2015-05-15/00:41:16), Class=tigase.server.bosh.BoshConnectionManager}
Loading component: c2s :: componentInfo{Title=Tigase XMPP Server, Version=7.0.2-b3821/563fcf81 (2015-05-15/00:41:16), Class=tigase.server.xmppclient.ClientConnectionManager}
Loading component: http :: componentInfo{Title=Tigase HTTP API component: Tigase HTTP API component, Version=1.1.0-b83/d51e1db6, Class=tigase.http.HttpMessageReceiver}
Loading component: message-archive :: componentInfo{Title=Tigase Message Archiving Component, Version=1.1.0-b71/c4003eb3, Class=tigase.archive.MessageArchiveComponent}
Loading component: monitor :: componentInfo{Title=Tigase XMPP Server, Version=7.0.2-b3821/563fcf81 (2015-05-15/00:41:16), Class=tigase.server.monitor.MonitorComponent}
Loading component: muc :: componentInfo{Title=Tigase MUC, Version=2.3.0-b389/879168a9, Class=tigase.muc.MUCComponent}
Loading component: proxy :: componentInfo{Title=Tigase Socks5 Component, Version=1.1.0-b48/f5c8a08c, Class=tigase.socks5.Socks5ProxyComponent}
Loading component: pubsub :: componentInfo{Title=Tigase PubSub, Version=3.1.0-b463/1df4d937, Class=tigase.pubsub.PubSubComponent}
Loading component: s2s :: componentInfo{Title=Tigase XMPP Server, Version=7.0.2-b3821/563fcf81 (2015-05-15/00:41:16), Class=tigase.server.xmppserver.S2SConnectionManager}
Loading plugin: session-close=4:1265 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: session-open=4:1265 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: default-handler=4:1265 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: jabber:iq:register=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: jabber:iq:auth=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: urn:ietf:params:xml:ns:xmpp-sasl=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: urn:ietf:params:xml:ns:xmpp-bind=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: urn:ietf:params:xml:ns:xmpp-session=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: jabber:iq:roster=2:2530 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: jabber:iq:privacy=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: jabber:iq:version=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: http://jabber.org/protocol/stats=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: starttls=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: vcard-temp=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: http://jabber.org/protocol/commands=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: jabber:iq:private=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: urn:xmpp:ping=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: presence=2:2530 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: disco=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: zlib=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: amp=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: message-carbons=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
Loading plugin: message-archive-xep-0136=1:5060 ...  , version: 7.0.2-b3821/563fcf81 (2015-05-15/00:41:16)
MA LOADED = message-archive@10.5.1.12
Loading component: sess-man :: componentInfo{Title=Tigase XMPP Server, Version=7.0.2-b3821/563fcf81 (2015-05-15/00:41:16), Class=tigase.server.xmppsession.SessionManager}
Loading component: ws2s :: componentInfo{Title=Tigase XMPP Server, Version=7.0.2-b3821/563fcf81 (2015-05-15/00:41:16), Class=tigase.server.websocket.WebSocketClientConnectionManager}














版权声明：本文为博主原创文章，未经博主允许不得转载。

PinnedSectionListView（分组+可固定标题的ListView）
最近用定外卖App时发现他们的商品展示页用了固定标题的列表，感觉挺不错的，上网查资料发现开源框架PinnedSectionListView能实现类似功能，于是就写了这个demo，希望对想实现类似功能的小伙伴有所启发。
PinnedSectionListView项目地址：https://github.com/beworker/pinned-section-listview
demo下载地址：http://download.csdn.net/download/shenyuanqing/9048531
效果图：




源码：
MainActivity

package com.example.shen.interfacetest.activity;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.AbsListView;
import android.widget.AdapterView;
import android.widget.ListView;

import com.example.shen.interfacetest.R;
import com.example.shen.interfacetest.adapter.LeftAdapter;
import com.example.shen.interfacetest.adapter.RightAdapter;
import com.example.shen.interfacetest.bean.Left;
import com.hb.views.PinnedSectionListView;

import java.util.ArrayList;


public class MainActivity extends Activity {
    private RightAdapter rightAdapter;
    private LeftAdapter leftAdapter;
    private PinnedSectionListView pslvRight;
    private ListView lvLeft;
    private ArrayList<Left> alLeft;
    private int posi=0;
    private int pos=0;
    private int first=0;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        lvLeft=(ListView) findViewById(R.id.lv_left);
        pslvRight=(PinnedSectionListView)findViewById(R.id.pslv_right);

        alLeft=new ArrayList<>();

        leftAdapter=new LeftAdapter(this,alLeft);
        lvLeft.setAdapter(leftAdapter);
        initData();
        /** 点击左边ListView重定位右边psListView中数据**/
        lvLeft.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                pslvRight.setSelection(Integer.parseInt(alLeft.get(position).info));
                posi = position;
                initData();
            }
        });
        /**得到左边ListView第一列的位置（显示左边ListView被选中但被隐藏的Item时用）**/
        lvLeft.setOnScrollListener(new AbsListView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(AbsListView view, int scrollState) {

            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                first=firstVisibleItem;
            }
        });


        ArrayList<String> alString=new ArrayList<>();
        for (int i=0;i<100;i++){
            alString.add("");
        }
        rightAdapter=new RightAdapter(this,alString);
        pslvRight.setAdapter(rightAdapter);
        /**滚动右边psListView刷新左边ListView选中状态**/
        pslvRight.setOnScrollListener(new AbsListView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(AbsListView view, int scrollState) {
            }

            @Override
            public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
                if(firstVisibleItem!=pos) {
                    posi = firstVisibleItem / 5;
                    initData();
                    pos=firstVisibleItem;
                }

            }
        });
    }

    private void initData(){
        alLeft.clear();
        int j=0;
        for (int i=0;i<100;i++){
            if(i%5==0){
                Left left=new Left();
                left.info=i+"";
                if(posi==j){
                    left.pos=1;
                }else {
                    left.pos = 0;
                }
                alLeft.add(left);
                j++;
            }
        }
        leftAdapter.notifyDataSetChanged();
        changePosition();
    }
    /**显示左边ListView被选中但被隐藏的Item**/
    private void changePosition(){
        if(posi-first>=14){
            lvLeft.setSelection(first+1);
        }
        if(posi<first){
            lvLeft.setSelection(posi);
        }
    }
}activity_main.xml

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal">
    <ListView
        android:id="@+id/lv_left"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_weight="2">
    </ListView>
    <com.hb.views.PinnedSectionListView
        android:id="@+id/pslv_right"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_weight="1"/>

</LinearLayout>
LeftAdapter

package com.example.shen.interfacetest.adapter;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.example.shen.interfacetest.R;
import com.example.shen.interfacetest.bean.Left;

import java.util.ArrayList;

/**
 * Created by shen on 2015/8/24.
 */
public class LeftAdapter extends BaseAdapter {
    private Context context;
    private ArrayList<Left> list;
    private LayoutInflater inflater;
    public LeftAdapter(Context context,ArrayList<Left> list){
        this.context=context;
        this.list=list;
        inflater=LayoutInflater.from(context);
    }
    @Override
    public int getCount() {
        return list.size();
    }

    @Override
    public Object getItem(int position) {
        return list.get(position);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder viewHolder;
        if(convertView==null){
            convertView=inflater.inflate(R.layout.item_left_list,null);
            viewHolder=new ViewHolder();
            viewHolder.tvContent=(TextView) convertView.findViewById(R.id.tv_content);
            viewHolder.llMain=(LinearLayout) convertView.findViewById(R.id.ll_main);
            convertView.setTag(viewHolder);
        }else{
            viewHolder=(ViewHolder) convertView.getTag();
        }
        viewHolder.tvContent.setText(list.get(position).info);
        if(list.get(position).pos==1){
            viewHolder.llMain.setBackgroundResource(R.color.white);
        }else{
            viewHolder.llMain.setBackgroundResource(R.color.linen);
        }

        return convertView;
    }

    static class ViewHolder{
        TextView tvContent;
        LinearLayout llMain;
    }
}
RightAdapter

package com.example.shen.interfacetest.adapter;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.example.shen.interfacetest.R;
import com.hb.views.PinnedSectionListView;

import java.util.ArrayList;

/**
 * Created by shen on 2015/8/22.
 */
public class RightAdapter extends BaseAdapter implements PinnedSectionListView.PinnedSectionListAdapter {
    private Context context;
    private ArrayList<String> list;
    private LayoutInflater inflater;

    public RightAdapter(Context context, ArrayList<String> list) {
        this.context = context;
        this.list = list;
        inflater = LayoutInflater.from(context);
    }

    @Override
    public int getCount() {
        return list.size();
    }

    @Override
    public Object getItem(int position) {
        return list.get(position);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder viewHolder;
        if(convertView==null) {
            convertView = inflater.inflate(R.layout.item_test, null);
            viewHolder=new ViewHolder();
            viewHolder.tvNum = (TextView) convertView.findViewById(R.id.tv_num);
            viewHolder.llMain=(LinearLayout) convertView.findViewById(R.id.ll_main);
            convertView.setTag(viewHolder);
        }else{
            viewHolder=(ViewHolder) convertView.getTag();
        }
        viewHolder.tvNum.setText(position+"");
        if (position%5 == 0) {
            viewHolder.llMain.setBackgroundResource(R.color.linen);
        } else {
            viewHolder.llMain.setBackgroundResource(R.color.white);
        }
        return convertView;
    }

    static class ViewHolder{
        TextView tvNum;
        LinearLayout llMain;
    }

    /**
     * 根据getItemViewType方法返回结果最终确定是否是标题行
     * @param viewType
     * @return true:标题行   false:普通行
     */
    @Override
    public boolean isItemViewTypePinned(int viewType) {
        if (viewType == 1) {
            return true;
        } else
        return false;
    }

    /**
     * 确定psListView中哪一行是标题行
     * @param position
     * @return 1：标题行   0：普通行
     */
    @Override
    public int getItemViewType(int position) {
        // TODO Auto-generated method stub
        if (position%5 == 0) {
            return 1;
        } else {
            return 0;
        }
    }

    @Override
    public int getViewTypeCount() {
        return 2;
    }
}Left

public class Left {
    public String info;
    public int pos;
}




版权声明：本文为博主原创文章，未经博主允许不得转载。

java的初始化研究:android开发中遇到的一个奇怪问题
我有一个Dialog的基类，然后有数个继承于他的子dialog。在基类dialog中写的一个View.OnFocusChangeListener我把它原样复制到子类中，再把其赋值给Edittext引用却发现，无法响应，编译运行都没有出错，就只是单纯的没有响应。经过调试发现并没有运行到其内部代码，但在父类时是可以引用正常的。


经过推敲可能是java的初始化流程的问题。


java初始化流程机制整理如下：
第一步：初始化基类的静态变量，从static代码块开始（如果有），然后根据声明顺序初始化基类的static变量。
第二步：初始化子类的静态变量，也是从static代码块开始（如果有），然后根据声明顺序初始化基类的static变量。
第三步：初始化基类的成员变量，按照声明顺序
第四部：执行基类的构造方法
第五部：初始化子类的成员变量，按照声明顺序
第六不：执行子类的构造方法


First.java

import entity.Entity1;

public class First extends Base {
    static {
        System.out.println("First static");
    }
    private Entity1 e1 = new Entity1();

    public First() {
        System.out.println("First");
    }
}
Base.java
import entity.Entity2;

public class Base {
    static {
        System.out.println("Base static");
    }

    private Entity2 e2 = new Entity2();

    public Base() {
        System.out.println("Base");
    }
}
Entity1.java
package entity;

public class Entity1 {
    public Entity1() {
        System.out.println("Entity1");
    }
}
Entity2.java
package entity;

public class Entity2 {
    public Entity2() {
        System.out.println("Entity2");
    }
}
主程序DefaultMain.java
public class DefaultMain {
    public static void main(String[] args) {
        First f = new First();
    }
}





版权声明：本文为博主原创文章，未经博主允许不得转载。

Eclipse怎么导入已经存在WorkSpace里的工程
步骤如下： 
1、打开Eclipse。 
2、点击菜单上的“File”。 
3、选择弹出窗口的“Import…”。 
4、选择弹出窗口的“General”。 
5、选择“Existing Project into Worksspace”，点击“Next”。 
6、选择要导入的项目文件，点击“Finish”即可。
关于项目的移动 
1.可以直接在workspace里面复制项目文件夹，到其他的workspace 然后导入到工程里 
2.workspace可以加载其他路径下的项目（不与workspace在同一路径）

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，转载请标明出处。

MPMoviePlayerController播放视频时黑屏
解决办法：
把 MPMoviePlayerController 类声明的 属性 定义成 全局变量就行了，为什么要这么做，我也不知道，这要问苹果公司了。
例代码：
#import "ViewController.h"
#import <MediaPlayer/MediaPlayer.h>

@interface ViewController ()

@property (nonatomic, strong) MPMoviePlayerController *player ;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.player = [[MPMoviePlayerController alloc] initWithContentURL:[NSURL URLWithString:@"http://101.200.231.179:2022/videos/2714/video.mp4"]];

    self.player.controlStyle = MPMovieControlStyleNone;
    self.player.shouldAutoplay = YES;
    self.player.repeatMode = MPMovieRepeatModeOne;
    [self.player setFullscreen:YES animated:YES];
    self.player.scalingMode = MPMovieScalingModeAspectFit;

    [self.player prepareToPlay];
    [self.player.view setFrame:CGRectMake(10, 30, 300, 200)];
    [self.view addSubview: self.player.view];

    [self.player play];
}



            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

ESP8266学习笔记7：保存和读取自定义参数
前言
这几天正在使用ESP8266接入机智云，需要保存一些自定义的参数。在笔记6中，做了AP信息的保存，但它是借助特定的API保存特定的AP信息。而自定义的参数还需要我们自己处理，所有的智能硬件都会涉及这种情况，今天把这块也梳理下。
转载请注明：http://blog.csdn.net/sadshen
编程思路
ESP的IOT_DEMO是让ESP连接乐鑫自己的云平台，其中必然涉及以下自定义参数的保存，这就是很好的例子。
1.自定义参数的结构体：    
struct esp_platform_saved_param esp_param;

2.SPI FLASH中的保存位置
/* NOTICE---this is for 512KB spi flash.
 * you can change to other sector if you use other size spi flash. */
#define ESP_PARAM_START_SEC     0x3D

3.初始化，载入自定义参数：
void ICACHE_FLASH_ATTR
user_esp_platform_init(void)
{
    ... 
    system_param_load(ESP_PARAM_START_SEC, 0, &esp_param, sizeof(esp_param));
    ...
}

4.修改自定义参数，这是一个设置token的例子：
void ICACHE_FLASH_ATTR
user_esp_platform_set_token(uint8_t *token)
{
    if (token == NULL) {
        return;
    }

    esp_param.activeflag = 0;
    os_memcpy(esp_param.token, token, os_strlen(token));

    system_param_save_with_protect(ESP_PARAM_START_SEC, &esp_param, sizeof(esp_param));
}

总结
这个内容比较简单,代码我就不贴了。
唯一注意的是FLASH的位置，如果用的是1M以上的FLASH，那记得参考下这帖子How to use 1024+KB flash - 如何使用1024KB 及以上 flash。
先这样吧。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

self.***和_***的区别及隐藏的毛坑 待续
@property(nonatomic,assign) long processingOrderId; 
在单例中的.h头文件中声明的非对象指针，要用_processingOrderId不要用self.processingOrderId，不然可能出现稀奇古怪的情况。 
.h头文件中不声明orderId，在.m文件中有-(void)setOrderId:(long)orderId，在调用initData时会调用setOrderId:(long)orderId，编译器不报错的异常情况。 
-(void)initData 
{
    self.orderId = -1;

}
-(void)setOrderId:(long)orderId 
{ 
    FLDDLogDebug(@”函数”); 
    _processingOrderId = orderId; 
｝

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Compiler compliance level of project HelloSSH should be 5.0 .Your current workspace default csdn
﻿﻿
MyEclipse只是Eclipse的一个插件，所以MyEclipse本身不带JDK，JDK是你事先装好并且配置Environment
 Variable完成后的。Eclipse自动配置完成的。当然Eclipse环境里似乎有一个编译器。在Window--Preferences--Java--Compiler下面选择

你是不是这里选择了6.0了？把它改成与你当前版本相同的版本。或是低级版本。
不用理会，JDK6.0向下支持J2EE1.4，放心大胆的用，只要Application
 Server不报错，你就放心大胆的做。
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

Android帧率测试
Android帧率测试
SurfaceFlinger
SurfaceFlinger 是 Android 的一个服务，运行在 Android 的System 进程中，负责管理系统的帧缓冲区，绘制应用程序的UI。Android应用程序会请求SurfaceFlinger服务创建Surface，在上面绘制自己的UI，然后将这个已经绘制好了UI的Surface渲染到设备显示屏上去
清空缓存
$ adb shell dumpsys SurfaceFlinger --latency-clear
[void android::SurfaceFlinger::setMTKProperties(android::String8&)]
========================================================================
[AOSP part]
   debug.sf.showupdates (mDebugRegion): 0
   debug.sf.ddms (mDebugDDMS): 0
[MTK SF part]
   debug.sf.busyswap (mBusySwap): 0
   debug.sf.log_repaint (mLogRepaint): 0
   debug.sf.log_buffer (mLogBuffer): 0
   debug.sf.line_g3d (mLineG3D): 0
   debug.sf.line_ss (mLineScreenShot): 0
   debug.sf.dump_ss (mDumpScreenShot): 0
   debug.sf.slowmotion (mDelayTime): 0
   debug.sf.contbufsenable (mContBufsDump): 0
[MTK GUI part]
   debug.bq.line: 0
   debug.st.line: 0
[MTK HWC part]
   debug.sf.line_ovl: 0
   debug.sf.debug_oex: 0
========================================================================
获取可视窗口列表
$ adb shell dumpsys SurfaceFlinger --list


[void android::SurfaceFlinger::setMTKProperties(android::String8&)]
========================================================================
[AOSP part]
   debug.sf.showupdates (mDebugRegion): 0
   debug.sf.ddms (mDebugDDMS): 0
[MTK SF part]
   debug.sf.busyswap (mBusySwap): 0
   debug.sf.log_repaint (mLogRepaint): 0
   debug.sf.log_buffer (mLogBuffer): 0
   debug.sf.line_g3d (mLineG3D): 0
   debug.sf.line_ss (mLineScreenShot): 0
   debug.sf.dump_ss (mDumpScreenShot): 0
   debug.sf.slowmotion (mDelayTime): 0
   debug.sf.contbufsenable (mContBufsDump): 0
[MTK GUI part]
   debug.bq.line: 0
   debug.st.line: 0
[MTK HWC part]
   debug.sf.line_ovl: 0
   debug.sf.debug_oex: 0
========================================================================


DimSurface
com.android.systemui.ImageWallpaper
com.tmall.wireless/com.tmall.wireless.maintab.module.TMMainTabActivity
com.tmall.wireless/com.tmall.wireless.module.category.TMNewCategoryActivity
com.tmall.wireless/com.tmall.wireless.module.search.searchResult.TMSearchResultActivity
DimAnimator
StatusBar

越下面的窗口，越在上层。如我要找天猫打开的Activity, 就取得包名为 com.tmall.wireless 的最后一条数据 xxx.TMSearchResultActivity
获取窗口的帧延时数据
$ adb shell dumpsys SurfaceFlinger --latency com.tmall.wireless/com.tmall.wireless.module.search.searchResult.TMSearchResultActivity


[void android::SurfaceFlinger::setMTKProperties(android::String8&)]
========================================================================
[AOSP part]
   debug.sf.showupdates (mDebugRegion): 0
   debug.sf.ddms (mDebugDDMS): 0
[MTK SF part]
   debug.sf.busyswap (mBusySwap): 0
   debug.sf.log_repaint (mLogRepaint): 0
   debug.sf.log_buffer (mLogBuffer): 0
   debug.sf.line_g3d (mLineG3D): 0
   debug.sf.line_ss (mLineScreenShot): 0
   debug.sf.dump_ss (mDumpScreenShot): 0
   debug.sf.slowmotion (mDelayTime): 0
   debug.sf.contbufsenable (mContBufsDump): 0
[MTK GUI part]
   debug.bq.line: 0
   debug.st.line: 0
[MTK HWC part]
   debug.sf.line_ovl: 0
   debug.sf.debug_oex: 0
========================================================================


17340038
1812193316205 1812209665589 1812210614128
1812212222282 1812227121282 1812227918128
1812239753051 1812261917205 1812262521667
1812273201051 1812296490820 1812297217743
...
...
1815880321744 1815896512436 1815897669128
1815897796051 1815913973205 1815915028282
1815915093359 1815931327974 1815932468974
1815933351974 1815948728436 1815949869743

latency 帧率数据说明
说明：
刷新频率：  17340038 
 1        18121933162051812209665589 1812210614128 
 2        18122122222821812227121282 1812227918128 
 3        18122397530511812261917205 1812262521667 
           … 
           … 
127       18159150933591815931327974 1815932468974 
128       18159333519741815948728436 1815949869743
The first line currently contains the refresh period in nanosecond. 
第一行是刷新频率，后面有128行，每行3个时间戳。
Each 128 following line contains 3 timestamps, of respectively the app draw time , the vsync timestamp just prior the call to set and the timestamp of the call to set. 
在 /Users/army/JavaDev/adt_20140702/sdk/sources/android-xx/com/android/uiautomator/platform/SurfaceFlingerHelper.java 中包含 frame rate 的计算方法：
    /**
     * Calculate frame rate
     * @return
     */
    public static double getFrameRate() {
        if (mRefreshPeriod < 0) {
            log("Run command \"" + FRAME_LATENCY_CMD + " \" before calcuating average frame rate");
            return -1.0;
        }
        if (mFrameBufferData.get(0) == null) {
            log("Run command \"" + FRAME_LATENCY_CMD + " \" before retrieving frame buffer data");
            return -1.0;
        }
        long startTime = Long.parseLong(mFrameBufferData.get(0).get(1));
        long endTime =  Long.parseLong(mFrameBufferData.get(mFrameLatencySampleSize - 1).get(1));
        long totalDuration = endTime - startTime;
        return (double)((mFrameLatencySampleSize - 1) * Math.pow(10, 9))/totalDuration;
    }
dumpsys gfxinfo
在开发者选项中有个“ GPU呈现模式分析(Profile GPU rendering，计算adb shell dumpsys gfxinfo中的呈现时间)”功能，在开启这个功能后，系统就会记录保留每个界面最后128帧图像绘制的相关时间信息。在开启这个功能后，重新启动APP，滑动页面然后执行adb命令。
$ adb shell dumpsys gfxinfo com.tmall.wireless


Applications Graphics Acceleration Info:
Uptime: 386315 Realtime: 386308


** Graphics info for pid 4887 [com.tmall.wireless] **


Recent DisplayList operations
             ClipRect
             DrawText
             RestoreToCount
     RestoreToCount
   DrawPatch
 RestoreToCount
DrawRect
DrawPath
DrawBitmap
DrawText
...
multiDraw
 DrawText
DrawPatch
DrawBitmap
DrawBitmapRect
DrawRect
DrawOval
...
multiDraw
 DrawText
DrawPatch


Caches:
Current memory usage / total memory usage (bytes):
 TextureCache         15078192 / 25165824
 LayerCache             311296 / 16777216
 RenderBufferCache           0 /  2097152
 GradientCache            4096 /   524288
 PathCache             1781076 / 10485760
 TextDropShadowCache         0 /  2097152
 FontRenderer 0         524288 /   524288
Other:
 FboCache                    1 /       16
 PatchCache                  3 /      512
Total memory usage:
 17698948 bytes, 16.88 MB

Profile data in ms:

com.tmall.wireless/com.tmall.wireless.module.search.searchResult.TMSearchResultActivity/android.view.ViewRootImpl@42f81df0
Draw Process Execute
1.11 2.49 0.43
1.26 2.89 0.63
1.85 4.62 0.65
1.72 4.16 3.56
1.88 3.15 0.46
2.67 2.68 0.45
1.22 2.67 0.58
1.22 2.81 0.42
1.74 2.25 0.38
102.77 10.32 0.52
2.48 5.48 0.53
2.19 4.99 0.56
2.10 4.77 0.50
1.10 2.55 0.40
2.26 4.04 0.47
...


View hierarchy:

com.tmall.wireless/com.tmall.wireless.maintab.module.TMMainTabActivity/android.view.ViewRootImpl@42d08ee8
 138 views, 62.20 kB of display lists, 1637 frames rendered

com.tmall.wireless/com.tmall.wireless.module.search.searchResult.TMSearchResultActivity/android.view.ViewRootImpl@42f81df0
 420 views, 82.98 kB of display lists, 862 frames rendered

Total ViewRootImpl: 2
Total Views:        558
Total DisplayList:  145.18 kB
注意 Profile data in ms: 下面的数据 
Draw:表示在Java中创建显示列表部分中，OnDraw()方法占用的时间。 
Process：表示渲染引擎执行显示列表所花的时间，view越多，时间就越长 
Execute：表示把一帧数据发送到屏幕上排版显示实际花费的时间。其实是实际显示帧数据的后台缓存区与前台缓冲区交换后并将前台缓冲区的内容显示到屏幕上的时间。 
Draw + Process + Execute = 完整显示一帧 ，这个时间要小于16ms才能保证每秒60帧。   
取得数据后，复制到excel中生成堆积柱状图.   
图中可以清晰的看出在滑动时,耗时明显有很多帧超过16ms。这些都是需要结合操作进行优化的。


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 高仿QQ5.2双向侧滑菜单DrawerLayout实现源码
Android 高仿QQ5.2双向侧滑菜单DrawerLayout实现源码

左右侧滑效果图




1.主页的实现

直接将DrawerLayout作为根布局，然后其内部第一个View为内容区域，第二个View为左侧菜单，第三个View为右侧侧滑菜单，当前第三个是可选的。
布局：


<android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/id_drawerLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/img_frame_background" >

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="@drawable/qq" >

        <Button
            android:layout_width="40dp"
            android:layout_height="30dp"
             android:layout_marginTop="10dp"
            android:layout_alignParentRight="true"
            android:layout_alignParentEnd="true" 
            android:background="@drawable/youce"
            android:onClick="OpenRightMenu" />
    </RelativeLayout>

    <fragment
        android:id="@+id/id_left_menu"
        android:name="com.pcachy.drawerlayout.MenuLeftFragment"
        android:layout_width="200dp"
        android:layout_height="match_parent"
        android:layout_gravity="start"
        android:tag="LEFT" />

    <fragment
        android:id="@+id/id_right_menu"
        android:name="com.pcachy.drawerlayout.MenuRightFragment"
        android:layout_width="100dp"
        android:layout_height="match_parent"
        android:layout_gravity="end"
        android:tag="RIGHT" />

</android.support.v4.widget.DrawerLayout>

代码

package com.pcachy.drawerlayout;

import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.support.v4.widget.DrawerLayout;
import android.view.Gravity;
import android.view.View;
import android.view.Window;

import com.nineoldandroids.view.ViewHelper;

public class MainActivity extends FragmentActivity {

	private DrawerLayout mDrawerLayout;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		
		//
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setContentView(R.layout.activity_main);
		
		initView();
		initEvents();
	}
	
	private void initView()
	{
		mDrawerLayout = (DrawerLayout) findViewById(R.id.id_drawerLayout);
		mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED, Gravity.END);
	}
	
	private void initEvents()
	{
		mDrawerLayout.setDrawerListener(new DrawerLayout.DrawerListener() {

			@Override
			public void onDrawerSlide(View drawerView, float slideOffset) {
				// TODO Auto-generated method stub
				View mContent = mDrawerLayout.getChildAt(0);
				View mMenu = drawerView;
				float scale = 1 - slideOffset;
				float rightScale = 0.8f + scale * 0.2f;

				if (drawerView.getTag().equals("LEFT"))
				{

					float leftScale = 1 - 0.3f * scale;

					ViewHelper.setScaleX(mMenu, leftScale);
					ViewHelper.setScaleY(mMenu, leftScale);
					ViewHelper.setAlpha(mMenu, 0.6f + 0.4f * (1 - scale));
					ViewHelper.setTranslationX(mContent,
							mMenu.getMeasuredWidth() * (1 - scale));
					ViewHelper.setPivotX(mContent, 0);
					ViewHelper.setPivotY(mContent,
							mContent.getMeasuredHeight() / 2);
					mContent.invalidate();
					ViewHelper.setScaleX(mContent, rightScale);
					ViewHelper.setScaleY(mContent, rightScale);
				} else
				{
					ViewHelper.setTranslationX(mContent,
							-mMenu.getMeasuredWidth() * slideOffset);
					ViewHelper.setPivotX(mContent, mContent.getMeasuredWidth());
					ViewHelper.setPivotY(mContent,
							mContent.getMeasuredHeight() / 2);
					mContent.invalidate();
					ViewHelper.setScaleX(mContent, rightScale);
					ViewHelper.setScaleY(mContent, rightScale);
				}
			}

			@Override
			public void onDrawerOpened(View drawerView) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void onDrawerClosed(View drawerView) {
				// TODO Auto-generated method stub
				mDrawerLayout.setDrawerLockMode(
						DrawerLayout.LOCK_MODE_LOCKED_CLOSED, Gravity.RIGHT);
			}

			@Override
			public void onDrawerStateChanged(int newState) {
				// TODO Auto-generated method stub
				
			}
			
		});
	}
	
	public void OpenRightMenu(View view)
	{
		mDrawerLayout.openDrawer(Gravity.RIGHT);
		mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED, Gravity.RIGHT);
	}
	
}

2.左菜单和右菜单布局(左菜单和右菜单的布局和代码随便你怎么写，这里是左菜单的例子)


<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#00000000" >

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_centerVertical="true"
        android:orientation="vertical" >

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content" >

            <ImageView
                android:id="@+id/one"
                android:layout_width="50dp"
                android:layout_height="50dp"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_marginTop="20dp"
                android:src="@drawable/img_1" />

            <TextView
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_toRightOf="@id/one"
                android:text="第1个Item"
                android:textColor="#f0f0f0"
                android:textSize="20sp" />
        </RelativeLayout>

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content" >

            <ImageView
                android:id="@+id/two"
                android:layout_width="50dp"
                android:layout_height="50dp"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_marginTop="20dp"
                android:src="@drawable/img_2" />

            <TextView
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_toRightOf="@id/two"
                android:text="第2个Item"
                android:textColor="#f0f0f0"
                android:textSize="20sp" />
        </RelativeLayout>

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content" >

            <ImageView
                android:id="@+id/three"
                android:layout_width="50dp"
                android:layout_height="50dp"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_marginTop="20dp"
                android:src="@drawable/img_3" />

            <TextView
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_toRightOf="@id/three"
                android:text="第3个Item"
                android:textColor="#f0f0f0"
                android:textSize="20sp" />
        </RelativeLayout>

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content" >

            <ImageView
                android:id="@+id/four"
                android:layout_width="50dp"
                android:layout_height="50dp"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_marginTop="20dp"
                android:src="@drawable/img_4" />

            <TextView
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_toRightOf="@id/four"
                android:text="第4个Item"
                android:textColor="#f0f0f0"
                android:textSize="20sp" />
        </RelativeLayout>

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content" >

            <ImageView
                android:id="@+id/five"
                android:layout_width="50dp"
                android:layout_height="50dp"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_marginTop="20dp"
                android:src="@drawable/img_5" />

            <TextView
                android:layout_width="fill_parent"
                android:layout_height="wrap_content"
                android:layout_centerVertical="true"
                android:layout_marginLeft="20dp"
                android:layout_toRightOf="@id/five"
                android:text="第5个Item"
                android:textColor="#f0f0f0"
                android:textSize="20sp" />
        </RelativeLayout>
    </LinearLayout>

</RelativeLayout>

1、为了模拟QQ的右侧菜单需要点击才能出现，所以在初始化DrawerLayout的时候，使用了mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED,Gravity.RIGHT);意思是只有编程才能将其弹出。然后在弹出以后，需要让手势可以滑动回去，所以在OpenRightMenu中又编写了：mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED,Gravity.RIGHT);
 UNLOCK了一下。最后在onDrawerClosed回调中，继续设置mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED,Gravity.RIGHT)；

2、动画效果动画用了nineoldandroids，

3、setDrawerListener
通过代码也能看出来，可以使用setDrawerListener监听菜单的打开与关闭等等。这里对于当前操作是哪个菜单的判断是通过TAG判断的，我觉得使用gravity应该也能判断出来



源码下载地址：http://download.csdn.net/detail/pcaxb/9042309



版权声明：本文为博主原创文章，未经博主允许不得转载。

【cocos2d-x 3.7 飞机大战】 决战南海I (十) 游戏主场景
        主场景要包含其他类的头文件

#include "cocos2d.h"
#include "MyPlane.h"
#include "Bullet.h"
#include "EnemyManager.h"
#include "Controller.h"
#include "BackgroundMove.h"
#include "FlowWord.h"
在这个游戏中，我将各种碰撞检测也放到主场景中进行


void gameUpdate(float dt);     // 碰撞检测
bool bulletCollisionEnemy(Sprite* pBullet);   // 子弹和敌机碰撞
void enemyCollisionPlane();    // 我机和敌机、敌机子弹碰撞
virtual void onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event);


当然，主场景要有各个类的实例做变量

MyPlane *planeLayer;
Bullet *bulletLayer;
EnemyManager *enemyLayer;
Controller *controlLayer;


主场景的实现

TollgateOne::TollgateOne() : planeLayer(NULL), bulletLayer(NULL), enemyLayer(NULL), controlLayer(NULL)
{

}
TollgateOne::~TollgateOne()
{
	_eventDispatcher->removeEventListenersForTarget(this);
}

cocos2d::Scene* TollgateOne::createScene()
{
	auto scene = Scene::create();

	auto layer = TollgateOne::create();

	scene->addChild(layer);

	return scene;
}

bool TollgateOne::init()
{
	if (!Layer::init())
	{
		return false;
	}

	// 启动触摸机制
	this->setTouchEnabled(true);

	// 背景无限滚动
	auto m_back = BackgroundMove::create();
	this->addChild(m_back,0);

	//游戏开始 飘字效果
	auto dictionary = Dictionary::createWithContentsOfFile("fonts/AboutMe.xml");
	auto m_flow = FlowWord::create();
	m_flow->showFlowWord(
		((__String *)(dictionary->objectForKey("play")))->getCString(),
		Point(Director::getInstance()->getVisibleSize().width / 2+60, Director::getInstance()->getVisibleSize().height/2), 
		m_flow->otherFlowWord()
		);
	this->addChild(m_flow);

	//游戏更新
	this->schedule(schedule_selector(TollgateOne::gameUpdate));

	// 加入控制层
	controlLayer = Controller::create();
	this->addChild(controlLayer);

	// 加入飞机
	planeLayer = MyPlane::create();
	this->addChild(planeLayer,1);

	// 加入敌机和分数显示
	enemyLayer = EnemyManager::create();
	enemyLayer->bindController(controlLayer);
	this->addChild(enemyLayer,1);

	// 开启子弹
	bulletLayer = Bullet::create();
	bulletLayer->bindEnemyManager(enemyLayer);
	this->addChild(bulletLayer,1);

	//对返回键的响应
	auto m_listener = EventListenerKeyboard::create();
	m_listener->onKeyReleased = CC_CALLBACK_2(TollgateOne::onKeyReleased, this);
	_eventDispatcher->addEventListenerWithSceneGraphPriority(m_listener, this);

	return true;
}

void TollgateOne::gameUpdate(float dt)
{
	bool bMoveButt = false;

	//子弹和敌机对碰
	for (auto& eButtle : bulletLayer->vecBullet)
	{
		Sprite* pBullet = (Sprite*)eButtle; // 获取子弹精灵
		bMoveButt = bulletCollisionEnemy(pBullet);
		if (bMoveButt)
		{
			// 子弹删除了，无需再遍历
			return;
		}
	}

	// 敌机、敌机子弹与我方飞机碰撞
	enemyCollisionPlane();
}

bool TollgateOne::bulletCollisionEnemy(Sprite* pBullet)
{
	for (auto& eEnemy : enemyLayer->vecEnemy)
	{
		Enemy* pEnemySprite = (Enemy*)eEnemy;

		// 是否发生碰撞
		if (pBullet->boundingBox().intersectsRect(pEnemySprite->getBoundingBox()))
		{

			// 飞机只剩下一格生命值
			if (1 == pEnemySprite->getLife())
			{
				pEnemySprite->loseLife(); // 知道为什么这里也要loselife吗？你可以试着注释掉看看
				enemyLayer->blowupEnemy(pEnemySprite);
			}
			else
			{
				pEnemySprite->loseLife();
			}

			//删除子弹
			bulletLayer->removeBullet(pBullet);
			return true;
		}
	}

	return false;
}

void TollgateOne::enemyCollisionPlane()
{
	Sprite* pPlane = (Sprite*)planeLayer->getChildByTag(AIRPLANE);
	for (auto& eEnemy : enemyLayer->vecEnemy)
	{
		Enemy* pEnemySprite = (Enemy*)eEnemy;

		// 是否发生碰撞
		if (pPlane->boundingBox().intersectsRect(pEnemySprite->getBoundingBox()) && pEnemySprite->getLife() > 0)
		{
			if (1 == planeLayer->getAlive())
			{
				planeLayer->loseAlive();
				controlLayer->getSaveData()->save();
				this->unscheduleAllSelectors();
				this->bulletLayer->StopBulletShoot();
				this->planeLayer->blowUp();
				Director::getInstance()->replaceScene(
					TransitionMoveInT::create(0.8f, GameOver::createScene())); // 替换场景
			}
			else
				planeLayer->loseAlive();
		}
	}

	for (auto& eEnemyBullet : bulletLayer->vecEnemyBullet)
	{
		Sprite* pEnemyBullet = (Sprite*)eEnemyBullet; // 获取子弹精灵

		// 是否发生碰撞
		if (pPlane->boundingBox().intersectsRect(pEnemyBullet->getBoundingBox()))
		{
			if (1 == planeLayer->getAlive())
			{
				planeLayer->loseAlive();
				controlLayer->getSaveData()->save();
				this->unscheduleAllSelectors();
				this->bulletLayer->StopBulletShoot();
				this->planeLayer->blowUp();
				Director::getInstance()->replaceScene(
					TransitionMoveInT::create(0.8f, GameOver::createScene())); // 替换场景
			}
			else
				planeLayer->loseAlive();

			bulletLayer->removeEnemyBullet(pEnemyBullet);

			return;
		}
	}
}

void TollgateOne::onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event)
{
	if (keyCode == EventKeyboard::KeyCode::KEY_ESCAPE)
	{
		Director::getInstance()->replaceScene(HelloWorld::createScene());
	}
}


主场景就是将其它类融合在一起，碰撞检测也是在这里进行。


注意一下这里的事件监听，和开始界面的不太一样，但都要在析构函数中移除。

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        Android官方文档系列（翻译）
下面一些内容是我翻译Android官方文档相关文章。
菜鸟上路，一边学习一边整理，若您发现有错误的地方还请不吝赐教。
Activity
解读Android之Activity基础知识 
解读Android之任务和Back栈
Service
解读Android之Service（1）基础知识 
解读Android之Service(2)Bound Service 
解读Android之Service(3)AIDL
ContentProvider
解读Android之ContentProvider(1)CRUD操作 
解读Android之ContentProvider(2)创建自己的Provider
Android数据存储方案
http://blog.csdn.net/wangyongge85/article/details/47293501
异步消息处理
Android异步消息处理机制(1)Handler基本使用 
Android异步消息处理机制(3)asyncTask基本使用

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

检测版本更新

@interface
ViewController ()<UIAlertViewDelegate>
{
   
NSString *updateURL;
}

@end



@implementation ViewController



- (void)viewDidLoad
{

    [super
viewDidLoad];

    

    [self
isNewestVersion];

    [self
performSelector:@selector(donghua)
withObject:self
afterDelay:0.1];

    
}
- (void)isNewestVersion
{

    

    updateURL =
@"";

    
    [NSURLConnection
sendAsynchronousRequest:[NSURLRequest
requestWithURL:[NSURL
URLWithString:@“”]]
queue:[NSOperationQueue
currentQueue]
completionHandler:^(NSURLResponse *response,
NSData *data,
NSError *connectionError) {

        
       
if (data) {

            
           
NSArray *result= [NSJSONSerialization
JSONObjectWithData:data 
options:0 error:nil];

            

            //            NSLog(@"result = %@", result);  
           
//对比版本

            //          NSString * version=result[@"version"]; 

    //对应 CFBundleVersion,
对应Xcode项目配置"General"中的 Build

            //            NSString * versionShort=result[@"versionShort"]; 

    //对应 CFBundleShortVersionString,
对应Xcode项目配置"General"中的 Version

            
           
NSString *versionShort = [result[0]
objectForKey:@"versionShort"];

            

            

            // NSString * localVersion=[[NSBundle mainBundle] infoDictionary][@"CFBundleVersion"];
           
NSString * localVersionShort=[[NSBundle
mainBundle] infoDictionary][@"CFBundleShortVersionString"];

            

            

            //                NSString *url=result[@"update_url"]; //如果有更新
需要用Safari打开的地址

            //                NSString *changelog=result[@"changelog"]; //如果有更新
需要用Safari打开的地址

            

            

            

            //这里放对比版本的逻辑 
每个 app 对版本更新的理解都不同

            //有的对比 version,
有的对比 build[version isEqualToString:localVersion]
           
if ([versionShort 
isEqualToString:localVersionShort]) {
               
return ;
            }
else {

                

                //                    
去更新

                UIAlertView *alView = [[UIAlertView
alloc]initWithTitle:@"提示"
message:@"检测到新版本,去更新么?"
delegate:self
cancelButtonTitle:@"取消"
otherButtonTitles:@"更新",
nil];
                alView.delegate =
self;
                [alView
show];

                
            }

            
        }

        
    }];

    
}
- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
   
if (buttonIndex == alertView.cancelButtonIndex) {
       
return;
    }
else {

        [self
gotoDownLoadNeWVersion];
    }

    
}
- (void)gotoDownLoadNeWVersion
{
   
NSURL* url = [[NSURL
alloc] initWithString:updateURL];

    [[ UIApplication
sharedApplication]openURL:url];
}



@end



版权声明：本文为博主原创文章，未经博主允许不得转载。

NSFetchedResultController讲解
有关于coreData 中可以说为在外界的代码和Core Data进行打交道最为主要的类就是NSFetchedResultController，可以说是“中枢”，
起到了承上启下的作用。
它的一些相应的方法常用到的写如下，可供参考：
#import <Foundation/Foundation.h>

//接口
@protocol NSFetchedResultsControllerDelegate;

//所需要的底层的两个对象
@class NSFetchRequest;  //发送请求
@class NSManagedObjectContext; //上下文（通过请求上下文）

//UItableView中相关联

NSFetchedResultsController
//讲解：它工作在高层中的视图的原理：将一个“请求”和一个“上下文”作为其输入；
//并在请求中的数据改变的时候调用相应的代理方法。

NSFetchRequest + NSManagedObjectContext —— NSFetchedResultsController ——> (获取的结果控制器委托（NSFetchedResultsControllerDelegate方法）)（获取结果）——————>UItableView

//这个获取结的果控制器对象私有属性
@interface NSFetchedResultsController : NSObject {
@private
	NSFetchRequest *_fetchRequest;
	NSManagedObjectContext *_managedObjectContext;
	NSString *_sectionNameKeyPath;
	NSString *_sectionNameKey;
	NSString *_cacheName;
	void	  *_cache;
	struct _fetchResultsControllerFlags {
	  unsigned int _sendObjectChangeNotifications:1;
	  unsigned int _sendSectionChangeNotifications:1;
	  unsigned int _sendDidChangeContentNotifications:1;
	  unsigned int _sendWillChangeContentNotifications:1;
	  unsigned int _sendSectionIndexTitleForSectionName:1;
	  unsigned int _changedResultsSinceLastSave:1;
	  unsigned int _hasMutableFetchedResults:1;
	  unsigned int _hasBatchedArrayResults:1;
	  unsigned int _hasSections:1;
	  unsigned int _usesNonpersistedProperties:1;
	  unsigned int _includesSubentities:1;
	  unsigned int _reservedFlags:21;
	} _flags;
	id _delegate;
	id _sortKeys;
	id _fetchedObjects;
	id _sections;
	id _sectionsByName;
	id _sectionIndexTitles;
	id _sectionIndexTitlesSections;
	
}

//获取结果改变的类型
typedef NS_ENUM(NSUInteger, NSFetchedResultsChangeType) {
	NSFetchedResultsChangeInsert = 1,  //插入
	NSFetchedResultsChangeDelete = 2,  //删除
	NSFetchedResultsChangeMove = 3,    //移动
	NSFetchedResultsChangeUpdate = 4   //更新
} NS_ENUM_AVAILABLE(NA,3_0);


- (id)initWithFetchRequest:(NSFetchRequest *)fetchRequest managedObjectContext: (NSManagedObjectContext *)context sectionNameKeyPath:(NSString *)sectionNameKeyPath cacheName:(NSString *)name;

##################下面是相应的代理方法
#pragra mark  NSFetchedResultsControllerDelegate 
@protocol NSFetchedResultsControllerDelegate
@optional
- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller;
//就是这个更新，将会通过tableView中的的-beginUpdates方法来更行表图的显示。


@optional
- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller;
//已经改变了之后

//这个事相对于 “行” 来操作的
@optional
- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath;

 //这个方法是相对于 “段” 为单位来操作的
@optional
- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id <NSFetchedResultsSectionInfo>)sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type;
//


@optional
- (NSString *)controller:(NSFetchedResultsController *)controller sectionIndexTitleForSectionName:(NSString *)sectionName ;
//设置段的美国名字

//这个就是发送请求的方法
- (BOOL)performFetch:(NSError **)error;

//这个属性，可见一个实例中的属性实体的排序方式，可以是几个不同的属性字段综合排序
@property (nonatomic, strong) NSArray *sortDescriptors;

timeStamp




版权声明：本文为博主原创文章，未经博主允许不得转载。

单例模式
饿汉式（常用）
public class EagerSingleton {
    private static EagerSingleton instance = new EagerSingleton();
    /**
     * 私有默认构造子
     */
    private EagerSingleton(){}
    /**
     * 静态工厂方法
     */
    public static EagerSingleton getInstance(){
        return instance;
    }
}

懒汉式
public class LazySingleton {
    private static LazySingleton instance = null;
    /**
     * 私有默认构造子
     */
    private LazySingleton(){}
    /**
     * 静态工厂方法
     */
    public static synchronized LazySingleton getInstance(){
        if(instance == null){
            instance = new LazySingleton();
        }
        return instance;
    }
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

ImageView实现图片适屏与裁剪

<ImageView
    android:id="@+id/homeservice_list_item_iv"
    android:layout_width="90dp"
    android:layout_height="90dp"
    android:scaleType="centerCrop"
    android:src="@drawable/service_default_180" />


详细的scaleType说明：

android:scaleType是控制图片如何resized/moved来匹对ImageView的size。

ImageView.ScaleType / android:scaleType值的意义区别：

CENTER /center  按图片的原来size居中显示，当图片长/宽超过View的长/宽，则截取图片的居中部分显示

CENTER_CROP / centerCrop  按比例扩大图片的size居中显示，使得图片长(宽)等于或大于View的长(宽)

CENTER_INSIDE / centerInside  将图片的内容完整居中显示，通过按比例缩小或原来的size使得图片长/宽等于或小于View的长/宽

FIT_CENTER / fitCenter  把图片按比例扩大/缩小到View的宽度，居中显示

FIT_END / fitEnd   把图片按比例扩大/缩小到View的宽度，显示在View的下部分位置

FIT_START / fitStart  把图片按比例扩大/缩小到View的宽度，显示在View的上部分位置

FIT_XY / fitXY  把图片不按比例扩大/缩小到View的大小显示

MATRIX / matrix 用矩阵来绘制，动态缩小放大图片来显示。

版权声明：本文为博主原创文章，未经博主允许不得转载。

适配iPhone6基本原则
1、固定比例不变；
2、与主视图相对位置不变；
3、与主视图宽度比例不变；

版权声明：本文为博主原创文章，未经博主允许不得转载。

底边栏Tab切换Fragment，带角标显示效果
类似于手机版qq的底边栏Tab效果有很多种实现方法，比如TabActivity、自定义RadioGroup等。由于高版本下TabActivity已经被废弃，而且Activity比较重量级，所以一般不使用TabActivity。这里分享一种我写的自定义底部Tab的方法，顺带加上底部标签的角标显示效果。效果如下：

关于Demo需要交代几点：
1.这个Demo中并没有对尺寸做适配，在不同机型的手机上运行需要调整代码中的尺寸相关代码。
2.角标效果只是个演示效果，逻辑可能并不合理，具体显示或者改变、隐藏逻辑可以在实际应用中进行设置。
下面从代码的角度来展开说明：
首先看最主要的FragmentIndicator类，这个类继承自LinearLayout实现了OnClickListener接口：
/**
 * @Instruction: 
 * @FragmentIndicator.java
 * @com.example.tabindicator.views
 * @Tab&Indicator
 * @author donz 2015年8月26日  上午11:40:46 
 * @qq 457901706
 */
public class FragmentIndicator extends LinearLayout implements OnClickListener {
	private int mDefaultIndicator = 0;
	private static int mCurIndicator;
	private Context context;
	private static View[] mIndicators;
	private OnIndicateListener mOnIndicateListener;
	public static int[] imageResources = new int[]{R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher,R.drawable.ic_launcher}; 
	public static String[] nameResources = new String[]{"Fragment_A","Fragment_B","Fragment_C","Fragment_D"};
	
	private FragmentIndicator(Context context) {
		super(context);
		this.context = context;
	}

	public FragmentIndicator(Context context, AttributeSet attrs) {
		super(context, attrs);
		this.context = context;
		mCurIndicator = mDefaultIndicator;
		setOrientation(LinearLayout.HORIZONTAL);
		setBackgroundColor(0xfff3f6ed);
		init(imageResources,nameResources);
	}
重写的构造方法中完成一系列初始化操作，其中核心的操作是init(imageResources,nameResources)方法，在这个方法中完成了对要显示的底部Tab栏的图标和显示文字的初始化。来看这个方法都做了什么：

private void init(int[] imageResources, String[] nameResources) {
		int length = 0;
		length = Math.max(imageResources.length, nameResources.length);
		mIndicators = new View[length];
		for(int i = 0;i<length;i++){
			mIndicators[i] = createIndicator(imageResources[i], nameResources[i], themeColor, "TAG_ICON_"+i, "TAG_TEXT_"+i);
			mIndicators[i].setTag(i);
			mIndicators[i].setOnClickListener(this);
			addView(mIndicators[i]);
		}
	}
很简单，在FragmentIndicator中有一个存储底部每一个标签和对应文字的View数组叫做mIndicators，这里就是初始化了mIndicators为其赋值，由上面代码可以看到又涉及到一个核心方法createIndicator(int
 iconResID, String name, int stringColor, String iconTag, String textTag)，这个方法是真正初始化每一个底部栏标签和文字的方法，来看他内部的实现：
	private View createIndicator(int iconResID, String stringResID, int stringColor, 
			String iconTag, String textTag) {
		LinearLayout view = new LinearLayout(getContext());
		view.setPadding(0, 12, 0, 12);
		view.setOrientation(LinearLayout.VERTICAL);
		view.setLayoutParams(new LinearLayout.LayoutParams(
				LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, 1));
		view.setGravity(Gravity.CENTER);
		
		ImageView iconView = new ImageView(getContext());
		iconView.setTag(iconTag);
		LinearLayout.LayoutParams iconParams = new LinearLayout.LayoutParams(
				LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
		iconView.setColorFilter(themeColor);
		iconView.setLayoutParams(iconParams);
		iconView.setImageResource(iconResID);
		
		TextView textView = new TextView(getContext());
		textView.setFocusable(true);
		textView.setGravity(Gravity.CENTER);
		textView.setTag(textTag);
		textView.setLayoutParams(new LinearLayout.LayoutParams(
				LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
		textView.setTextColor(stringColor);
		textView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 11);
		textView.setText(stringResID);
		view.addView(iconView);
		view.addView(textView);
		return view;
	}
一目了然，每一个底部栏标签其实是一个线性布局LinearLayout，然后根据传递进来的图标和文字分别构造ImageView和TextView及其一系列属性信息，最后通过addView(View view)方法将他们添加到这个线性布局中，返回这个线性布局。这就回到了init()方法中，init()中的循环里又调用了FragmentIndicator的addView方法将每个底部页签的线性布局添加到底部栏最外层的线性布局中，至此底部栏雏形完成了。
但是到这里还没有完，视图效果虽然出现了但是试着去点击底部页签是没有反应的，因为我们还没有为其绑定点击事件，下面代码：
	public interface OnIndicateListener {
		public void onIndicate(View v, int which);
	}

	public void setOnIndicateListener(OnIndicateListener listener) {
		mOnIndicateListener = listener;
	}

	@Override
	public void onClick(View v) {
		if (mOnIndicateListener != null) {
			int tag = (Integer) v.getTag();
			if(mCurIndicator!=tag){
				mOnIndicateListener.onIndicate(v, tag);
				setIndicator(tag);
				
//				 演示效果
				if(null!=badgeView)
					badgeView.toggle();
			}
		}
	}
由于FragmentIndicator实现了OnClickListner所以需要实现onClick方法，在这个点击方法里我们需要调用一个自定义接口回调方法来实现我们的业务逻辑和视图效果。其中业务逻辑是由mOnIndicateListener.onIndicate(v, tag)实现的，切换标签视图效果(字体加粗，图标颜色加重)是由setIndicator(int index)来实现的。来看setIndicator(int
 index)的逻辑：
	public static void setIndicator(int which) {
		// clear previous status.
		ImageView prevIcon;
		TextView prevText;
		prevIcon =(ImageView) mIndicators[mCurIndicator].findViewWithTag("TAG_ICON_"+mCurIndicator);
		prevIcon.setImageResource(FragmentIndicator.imageResources[mCurIndicator]);
		prevIcon.setColorFilter(themeColor);
		prevText = (TextView) mIndicators[mCurIndicator].findViewWithTag("TAG_TEXT_"+mCurIndicator);
		prevText.setTextColor(themeColor);
		TextPaint tpaint0 = prevText.getPaint();
        tpaint0 .setFakeBoldText(false);
		
		// update current status.
		ImageView currIcon;
		TextView currText;
		currIcon =(ImageView) mIndicators[which].findViewWithTag("TAG_ICON_"+which);
		currIcon.setImageResource(FragmentIndicator.imageResources[which]);
		currIcon.setColorFilter(themeColorDarker);
		currText = (TextView) mIndicators[which].findViewWithTag("TAG_TEXT_"+which);
		currText.setTextColor(themeColorDarker);
		TextPaint tpaint = currText.getPaint();
        tpaint.setFakeBoldText(true);
		
		mCurIndicator = which;
	}
这个方法里对前一个底部栏页签的图标和文字效果进行了还原，还原成默认效果，对切换到的当前页签的图标和文字效果进行了选中效果的渲染，并对当前选中的页签下标mCurIndicator进行了重新赋值。而OnIndicateListener接口的方法具体实现在MainActivity中：
public class MainActivity extends FragmentActivity {
	private Fragment[] mFragments;
	private FragmentIndicator mIndicator;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		setFragmentIndicator(0);
		mIndicator.showBadge(2, "4");
	}

	
	private void setFragmentIndicator(int whichIsDefault) {
		final FragmentManager manager = getSupportFragmentManager();
		mFragments = new Fragment[]{manager.findFragmentById(
				R.id.fragment_A),manager.findFragmentById(
						R.id.fragment_B),manager.findFragmentById(
								R.id.fragment_C),manager.findFragmentById(
										R.id.fragment_D)};
		for(int i  = 0;i<mFragments.length;i++){
			FragmentTransaction transaction = manager.beginTransaction();
			transaction.hide(mFragments[i]).commit();
		}
		manager.beginTransaction().show(mFragments[0]).commit();
		mIndicator = (FragmentIndicator) findViewById(R.id.indicator_main);
		FragmentIndicator.setIndicator(whichIsDefault);
		// 初始化
		mIndicator.setOnIndicateListener(new OnIndicateListener() {
			@Override
			public void onIndicate(View v, int which) {
				for(int i  = 0;i<mFragments.length;i++){
					FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
					transaction.hide(mFragments[i]).commit();
				}
				manager.beginTransaction().show(mFragments[which]).commit();
			}
		});
	}
这里的业务逻辑仅仅是切换Fragment，MainActivity里初始化了四个Fragment，主要的逻辑是相应底部标签栏的点击事件而对这四个Fragment进行切换。红色角标的显示来自于GitHub的开源代码，其实逻辑也很简单，这里只看一下关键代码把：
BadgeView类中：
	private void applyTo(View target) {
		
		LayoutParams lp = target.getLayoutParams();
		ViewParent parent = target.getParent();
		FrameLayout container = new FrameLayout(context);
		
		if (target instanceof TabWidget) {
			
			// set target to the relevant tab child container
			target = ((TabWidget) target).getChildTabViewAt(targetTabIndex);
			this.target = target;
			
			((ViewGroup) target).addView(container, 
					new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
			
			this.setVisibility(View.GONE);
			container.addView(this);
			
		} else {
			
			// TODO verify that parent is indeed a ViewGroup
			ViewGroup group = (ViewGroup) parent; 
			int index = group.indexOfChild(target);
			
			group.removeView(target);
			group.addView(container, index, lp);
			
			container.addView(target);
	
			this.setVisibility(View.GONE);
			container.addView(this);
			
			group.invalidate();
			
		}
		
	}
其实角标是先把原视图remove然后add进去一个FrameLayout，然后再依次把原始图和角标add进去。至于其他的一些诸如设置角标位置的方法看代码即可。我在FragmentIndicator中定义了两个方法：
	public void showBadge(int index,String content){
		badgeView = new BadgeView(context, mIndicators[index].findViewWithTag("TAG_ICON_"+index));
		badgeView.setBadgePosition(BadgeView.POSITION_TOP_RIGHT);
		badgeView.setText(content);
		badgeView.show();
	}
	public void hideBadge(){
		if(null!=badgeView)
			badgeView.hide();
	}<span style="white-space:pre">	</span>showBadge(int index,String content)方法根据传递进来的两个参数index(角标所对应的标签下标)，content(角标显示内容)来在特定页签的位置显示出角标，而<span style="font-family: Arial, Helvetica, sans-serif;">hideBadge()则是隐藏角标。MainActivity的初始化代码中的</span><span style="font-family: Arial, Helvetica, sans-serif;">mIndicator.showBadge(2, "4")就是在第三个页签显示内容为4的角标。</span>
至此一个自定义带角标功能的Tab+Fragment功能就完成了，下面是代码Demo：
底部Tab+Fragment切换+标签角标显示效果
如果内容对您有帮助就请不吝点个赞吧～！





版权声明：本文为博主原创文章，未经博主允许不得转载。

【iOS开发系列】将阿拉伯数字转换为中文数字
/**
 *  将阿拉伯数字转换为中文数字
 */
+(NSString *)translationArabicNum:(NSInteger)arabicNum
{
    NSString *arabicNumStr = [NSString stringWithFormat:@"%ld",(long)arabicNum];
    NSArray *arabicNumeralsArray = @[@"1",@"2",@"3",@"4",@"5",@"6",@"7",@"8",@"9",@"0"];
    NSArray *chineseNumeralsArray = @[@"一",@"二",@"三",@"四",@"五",@"六",@"七",@"八",@"九",@"零"];
    NSArray *digits = @[@"个",@"十",@"百",@"千",@"万",@"十",@"百",@"千",@"亿",@"十",@"百",@"千",@"兆"];
    NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chineseNumeralsArray forKeys:arabicNumeralsArray];
    
    if (arabicNum < 20 && arabicNum > 9) {
        if (arabicNum == 10) {
            return @"十";
        }else{
            NSString *subStr1 = [arabicNumStr substringWithRange:NSMakeRange(1, 1)];
            NSString *a1 = [dictionary objectForKey:subStr1];
            NSString *chinese1 = [NSString stringWithFormat:@"十%@",a1];
            return chinese1;
        }
    }else{
        NSMutableArray *sums = [NSMutableArray array];
        for (int i = 0; i < arabicNumStr.length; i ++)
        {
            NSString *substr = [arabicNumStr substringWithRange:NSMakeRange(i, 1)];
            NSString *a = [dictionary objectForKey:substr];
            NSString *b = digits[arabicNumStr.length -i-1];
            NSString *sum = [a stringByAppendingString:b];
            if ([a isEqualToString:chineseNumeralsArray[9]])
            {
                if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]])
                {
                    sum = b;
                    if ([[sums lastObject] isEqualToString:chineseNumeralsArray[9]])
                    {
                        [sums removeLastObject];
                    }
                }else
                {
                    sum = chineseNumeralsArray[9];
                }
                
                if ([[sums lastObject] isEqualToString:sum])
                {
                    continue;
                }
            }
            
            [sums addObject:sum];
        }
        NSString *sumStr = [sums  componentsJoinedByString:@""];
        NSString *chinese = [sumStr substringToIndex:sumStr.length-1];
        return chinese;
    }
}


版权声明：本文为博主原创文章，未经博主允许不得转载。

lua中函数为什么有时候可以省略”()”?
lua中函数为什么有时候可以省略”()”?
DionysosLai(906391500@qq.com)
20150825
        首先，看两个问题背景：
        1. 简单的print函数

    print "hello"      ---> print hello,通常写法是print(“hello”)
    print 42          ---> not work，正确写法是print(42)
        2. 一个自定义函数，注意黑体字部分；
Set = {};
function Set.new (t)
	local set = {};
	setmetatable(set, Set.mt);
	for i, _v in ipairs(t) do
		set[_v] = true;
	end
	return set;
end

function Set.union (a, b)
	<strong>local res = Set.new{};</strong>
	for k in pairs(a) do res[k] = true end
	for k in pairs(b) do res[k] = true end
	return res;
end
        一般来讲，对于local res = Set.new{};，一般写法是local res = Set.new();
        这里，是由于lua函数在两种情况下，可以省略’()’：函数中参数是一个单独的字符串或者表。因此，myfunc{a = 1, b = 2}，是可以正常运行。所以，有时看到一个函数省略了’()’，就应该反应，传递的参数是单个字符串或者单个表。
        在lua中，这些美妙语法特性（syntacic sugar），根本原因是由于lua本身是一个数据描述语言。
 
        延伸阅读：http://www.luafaq.org/ 中 1.16问题。


版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift 枚举
结构体和枚举比较类似可以比较学习：http://blog.csdn.net/lwjok2007/article/details/47981409




枚举是一种常见的数据类型，他的主要功能就是将某一种有固定数量可能性的变量的值，以一组命名过的常数来指代。比如正常情况下方向有四种可能，东，南，西，北。我们就可以声明一组常量来指代方向的四种可能。使用枚举可以防止用户使用无效值，同时该变量可以使代码更加清晰。



//1 枚举的声明




//我们直接看示例，一般有两种方式，一个一个写，还有可以写一行


enum Orientation{
    case East
    case South
    case West
    case North
}


enum Orientation1{
    case East,South,West,North
}





//2 枚举的值

//枚举元素的值，也叫原始值。只有在指定了数据类型之后才可能有原始值。例如刚才新建的枚举 Orientation我们如果取他的原始值就会报错的。
println(Orientation.East.rawValue) //报错 没有指定类型


enum Orientation3:Int{
    case East
    case South
    case West
    case North
}
println(Orientation3.East.rawValue)//当我们指定了数据类型之后就可以取到原始值了



//枚举类型的值如果没有赋值，他就按照默认的走，可以赋予我们自己想要的值


enum Orientation5:Int{
    case East=2
    case South
    case West=5
    case North
}


println(Orientation5.East.rawValue)
println(Orientation5.South.rawValue)
println(Orientation5.West.rawValue)
println(Orientation5.North.rawValue)

//通过上边的赋值 我们可以看出来 我们可以对枚举的一部分赋值，没有赋值的部分就按照前面最近的被赋值枚举依次递增赋值。
//同时，Swift的枚举值 不仅可以赋值为int类型的，还可以有其他类型（比如String等）但是，不管什么类型的枚举 赋值是不能重复的

enum Orientation6:String{
    case East="E"
    case South="S"
    case West="W"
    case North="N"
}

println(Orientation6.North.rawValue)


//3 枚举的使用方法




//关于枚举的使用 
我们举个例子吧。假设小明开车出门，当他超不同方向行驶的时候都要给小红发条微信。


//我们定义一个枚举类型的变量来监控小明的走向
var toward:Orientation6

toward=Orientation6.West

switch toward{
case .East:
    println("告诉小红向东走")
case .South:
    println("告诉小红向南走")
case .West:
    println("告诉小红向西走")
case .North:
    println("告诉小红向北走")
}


//需要注意的是，像上边这种用法 switch-case 必须要覆盖所有枚举的情况，如果没有覆盖全一定记得加上default
switch toward{
case .East:
    println("告诉小红向东走")
case .South:
    println("告诉小红向南走")
default:
    println("没有向东和南走")
}




苹果开发群 ：414319235  欢迎加入  欢迎讨论问题














版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS多线程（二）GCD

GCD


全称是Grand Central Dispatch，“伟大的中枢调度器”GCD是苹果公司为多核的并行运算提出的解决方案纯C语言，提供了非常多强大的函数


优势

GCD会自动利用更多的CPU内核（比如双核、四核）GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码


基本概念

任务和队列

GCD中有2个核心概念
1.任务：执行什么操作
2.队列：用来存放任务
// 1.定制任务:确定想做的事情
// 2.将任务添加到队列中:GCD会自动将队列中的任务取出，放到对应的线程中执行。
Tips：任务的取出遵循队列的FIFO原则：先进先出，后进后出

任务

一、执行任务
 - queue：队列
 - block：任务
// 1.用同步的方式执行任务
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);

// 2.用异步的方式执行任务
dispatch_async(dispatch_queue_t queue, dispatch_block_t block);

// 3.GCD中还有个用来执行任务的函数
// 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行
dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);

注意:
同步：只能在当前线程中执行任务，不具备开启新线程的能力
异步：可以在新的线程中执行任务，具备开启新线程的能力

队列

一、并发队列（Concurrent Dispatch Queue）

可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）并发功能只有在异步（dispatch_async）函数下才有效
// 1.使用dispatch_queue_create函数创建队列
dispatch_queue_t
dispatch_queue_create(const char *label, // 队列名称 
dispatch_queue_attr_t attr); // 队列的类型

// 2.创建并发队列
dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_CONCURRENT);

// 3.使用dispatch_get_global_queue函数获得全局的并发队列
dispatch_queue_t dispatch_get_global_queue(dispatch_queue_priority_t priority, unsigned long flags);
// dispatch_queue_priority_t priority(队列的优先级 )
// unsigned long flags( 此参数暂时无用，用0即可 )

// 4.获得全局并发队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

// 5.全局并发队列的优先级
#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高
#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）
#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低
#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台

二、串行队列（Serial Dispatch Queue）

让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）
// 1.使用dispatch_queue_create函数创建串行队列
// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）
dispatch_queue_t queue = dispatch_queue_create("queue", NULL);

// 2.使用dispatch_get_main_queue()获得主队列
dispatch_queue_t queue = dispatch_get_main_queue();
注意：主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务，都会放到主线程中执行。

三、各种队列的执行效果




特别注意：使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列 (线程卡死)


新手易混淆


有4个术语比较容易混淆：同步、异步、并发、串行


1.同步和异步主要影响：能不能开启新的线程

同步：只是在当前线程中执行任务，不具备开启新线程的能力异步：可以在新的线程中执行任务，具备开启新线程的能力

2.并发和串行主要影响：任务的执行方式

并发：多个任务并发（同时）执行串行：一个任务执行完毕后，再执行下一个任务


GCD运用

一、线程间通信
从子线程回到主线程
dispatch_async(
dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行耗时的异步操作...
      dispatch_async(dispatch_get_main_queue(), ^{
        // 回到主线程，执行UI刷新操作
        });
});

二、延时执行
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    // 2秒后异步执行这里的代码...
});

三、一次性代码
// 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次
static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    // 只执行1次的代码(这里面默认是线程安全的)
});

四、快速迭代
// 使用dispatch_apply函数能进行快速迭代遍历
dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index){
    // 执行10次代码，index顺序不确定
});

五、队列组
// 分别异步执行2个耗时的操作、2个异步操作都执行完毕后，再回到主线程执行操作
dispatch_group_t group =  dispatch_group_create();
dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行1个耗时的异步操作
});
dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行1个耗时的异步操作
});
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    // 等前面的异步操作都执行完毕后，回到主线程...
});


单例模式


作用：

可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问。从而方便地控制了实例个数，并节约系统资源

使用场合

在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）


实现过程：

1.重写实现：

创建一个需要单例模式的文件
// 1.在.m中保留一个全局的static的实例
static id _instance;

// 2.重写allocWithZone:方法，在这里创建唯一的实例（注意线程安全）
+ (instancetype)allocWithZone:(struct _NSZone *)zone
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _instance = [super allocWithZone:zone];
    });
    return _instance;
}

// 3.提供1个类方法让外界访问唯一的实例
+ (instancetype)sharedInstance
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _instance = [[self alloc] init];
    });
    return _instance;
}

// 4.实现copyWithZone:方法
- (id)copyWithZone:(struct _NSZone *)zone
{
    return _instance;
}

2.宏实现：
// .h文件
#define SingletonH(name) + (instancetype)shared##name;

// .m文件
#define SingletonM(name) \
static id _instance; \
 \
+ (instancetype)allocWithZone:(struct _NSZone *)zone \
{ \
    static dispatch_once_t onceToken; \
    dispatch_once(&onceToken, ^{ \
        _instance = [super allocWithZone:zone]; \
    }); \
    return _instance; \
} \
 \
+ (instancetype)shared##name \
{ \
    static dispatch_once_t onceToken; \
    dispatch_once(&onceToken, ^{ \
        _instance = [[self alloc] init]; \
    }); \
    return _instance; \
} \
 \
- (id)copyWithZone:(NSZone *)zone \
{ \
    return _instance; \
}


单例模式

致谢

感谢您花时间阅读，期待与您的交流。

版权声明：本文为博主原创文章，未经博主允许不得转载。

RecyclerView添加Header和Footer
使用过RecyclerView的同学就知道它并没有添加header和footer的方法，而ListView和GirdView都有，但是开发过程中难免有需求需要添加一个自定义的header或者footer，或者不同布局的Item。
好了，我们知道如果在ListView中要添加不同的布局的item，都是通过重写getItemViewType()和getViewTypeCount()这两个方法来控制的，OK，对于RecyclerView，还是用这个方法来做，分别对不同的Item用不同的flag标记，然后在创建和绑定数据时候分别对不同的flag对应不同的处理，直接上代码（这里我添加了header和footer）：
先来看看效果： 


代码：
RecyclerView.Adapter
public class RecyclerViewAdapter extends RecyclerView.Adapter<RecyclerViewAdapter.RecyclerViewHolder> {
    private List<String> datas;
    private static final int IS_HEADER = 2;
    private static final int IS_FOOTER = 3;
    private static final int IS_NORMAL = 1;
    public RecyclerViewAdapter(List<String> datas) {
        this.datas = datas;
    }

    @Override
    public RecyclerViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        RecyclerViewHolder holder;
        //对不同的flag创建不同的Holder
        if (viewType == IS_HEADER) {
            View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.layout_header, viewGroup, false);
            holder = new RecyclerViewHolder(view,IS_HEADER);
            return holder;
        } else if (viewType == IS_FOOTER) {
            View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.layout_footer, viewGroup, false);
            holder = new RecyclerViewHolder(view,IS_FOOTER);
            return holder;
        }else if(viewType==IS_NORMAL){
            View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.layout_item, viewGroup, false);
            holder = new RecyclerViewHolder(view,IS_NORMAL);
            return holder;
        }
        return null;
    }

    @Override
    public void onBindViewHolder(final RecyclerViewHolder recyclerViewHolder, int position) {
        //对不同的Item相应不同的操作
        if(position!=0&&position!=datas.size()+1&&recyclerViewHolder.viewType==IS_NORMAL){
            recyclerViewHolder.mTextView.setText(datas.get(position - 1));
        }
        if(position==0&&recyclerViewHolder.viewType==IS_HEADER){
            //header
            recyclerViewHolder.mButton.setOnClickListener(new View.OnClickListener() {
                int i=0;
                @Override
                public void onClick(View v) {
                    recyclerViewHolder.mButton.setText(++i+"");
                }
            });
        }
        if(position==datas.size()+1&&recyclerViewHolder.viewType==IS_FOOTER){
            //footer
        }

    }

    @Override
    public int getItemCount() {
        return datas.size() + 2;

    }

    @Override
    public int getItemViewType(int position) {
        if (position == 0) {
            return IS_HEADER;
        } else if(position==datas.size()+1){
           return IS_FOOTER;
        }else {
            return IS_NORMAL;
        }
    }

    class RecyclerViewHolder extends RecyclerView.ViewHolder {
        public TextView mTextView;
        public Button mButton;
        public int viewType;
        public RecyclerViewHolder(View itemView,int viewType) {
            super(itemView);
            this.viewType = viewType;
            if(viewType==IS_HEADER){
                mButton = (Button) itemView.findViewById(R.id.button);
            }
            if(viewType==IS_FOOTER){
                //do some sthing
            }
            if(viewType==IS_NORMAL){
                mTextView = (TextView) itemView.findViewById(R.id.tv_content);
            }
        }
    }
}
RecyclerView.ViewHolder
class RecyclerViewHolder extends RecyclerView.ViewHolder {
        public TextView mTextView;
        public Button mButton;
        public int viewType;
        public RecyclerViewHolder(View itemView,int viewType) {
            super(itemView);
            this.viewType = viewType;
            if(viewType==IS_HEADER){
                mButton = (Button) itemView.findViewById(R.id.button);
            }
            if(viewType==IS_FOOTER){
                //do some sthing
            }
            if(viewType==IS_NORMAL){
                mTextView = (TextView) itemView.findViewById(R.id.tv_content);
            }
        }
    }
这里我把ViewHolder单独拿出来看就是为了看不同之处。
源码请戳

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。转载注明出处：http://blog.csdn.net/u010687392

知乎（高逼格）android开发offer——get
首先介绍一下自己

楼主马上大四，计算机水本，考研与我无缘
现在在帝都某公司算法部实习，公司算大公司吧，然而个人爱好偏开发
大二的时候写个一个app，主要是用各种框架

上干货

session1：偶然看到知乎的内推帖，投了个简历，下午hr姐姐call我，安排面试选在3天后，然而又要笔试阿里，所以没怎么复习
session2：8点起床，9点过比较紧张的去了创业园，感觉知乎氛围很好，在那等了一小会，有前台大叔给你倒水

一面开始

session3：应该是个参加工作不久的研究僧师兄，出了一道算法题，主要考字符转int，然后分析了时间复杂度和空间复杂度，之后聊了android listView的性能优化，还问我recycalView的特点，进程通信的方式，我主要说了aidl和共享文件，广播，本来还想用java装B，还在精通java，然而师兄并没有问，说叫等一下

二面：

二面明显难度提升，而且面试管应该是组长吧，比较喜欢听吹架构，正好之前自己从web后台，客户端，硬件等方面做了一个智能家居项目，就吹了下硬件那边的逻辑，包括蓝牙，wifi的HTTP/IP协议，透传等，红外等传感器，然后web后台我说我用sevlet，因为本身客户端主要需要接口，数据库用mysql，也没问rollback（嘿嘿），然后把客户端展示给他看看，实在太丑没有美工（这不是重点），由于我的项目中有一个很重要的point就是在硬件触发时唤醒服务器后台推送，首先硬件识别后，串口读写数据到单片机，单片机写入wifi缓冲区，wifi通过HTTP透传数据到我服务器（可以用TCP和IP），服务器获取mac标识，推送至TAG（家庭ID）或者用户（Alias）
说到推送，好好吹吹实现原理。 
1：pull方式，http长连接或是socket，轮询间隔设好即可，缺点及时性差
2：push方式，实时性好，方法1，google自带推送平台（网太差），方法二，xmpp协议（基于XML）。其实封装的比较好了，有个开源包叫asmark，其中有XmppConnection这个推送库，话说好多公司都是用它自己封装库，不过开源的demo只管推，没有延时推送，消息暂存功能，方式3，用三方的
算法：是2个有序数组合并问题，用2个指针每次比较能够O（n）解决问题，算法pass 
LruCache：先装装B，说一下我写的和google V4包有什么不同，主要是没有trimToSize方法，没有sizeof（）计算内存耗费大小，我主要是重写LinkedHashMap,讲了下LinkHashMap源码，其实我也是看别人写的源码解析，（嘿嘿，毕竟年轻，多像别人学）

总结：

公司重视基础，每次面试都有算法，虽说不难，估计就是看看写代码的规范
安卓岗位多问安卓问题，而且偏向于性能调优，并没有像社招那样要求各种框架的熟悉度，而是看你用过的框架的源码解析度
吐槽环节，就好好吐槽吧，嘿嘿
祝大家都能收获offer。


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

A010-menu资源
本节课讲Android中的菜单（menu）资源，这个也是我们在开发中可能经常用到的资源，它可以分为以下几种类型： 
- option menu（选项菜单） 
    - sub menu（子菜单） 
- context menu （上下文菜单） 
- popup menu（弹出菜单）
菜单在Android具有特殊性，几乎所有应用都离不开它，随着Android的发展，菜单也展示方式也跟着变化，我们初学它的时候先理解这个东西具体用来的干嘛的，然后才跟着细节去学习实现，总而言之，一节课可以讲的内容很有限，把所有东西全都列全在这里效果也不明显，我们先了解它的基本用法，然后再学习过程中遇到特殊的需求再来丰富它的实现。
option menu（选项菜单）
这个是Android中最常规的菜单，在我们的Activity中它只包含一个菜单，一个菜单可以包含多个菜单项和多个子菜单。
在Android 2.3 或者更低版本的SDK提供了以下的菜单效果： 
 
以上旧的菜单展现形式现在应用基本上很少见了，就算有也不会用菜单来实现，更多的可能使用以下这种形式，以actionbar来给用户一些常用操作，使用溢出菜单来隐藏更多不常用功能： 

我们实际开发中可以有两种实现菜单的方式： 
- 硬编码 
- xml文件
硬编码
可以看一下直接使用代码来添加菜单如何操作： 

我们在Activity中复写onCreateOptionMenu方法，然后通过menu对象调用其的重载方法来添加菜单项或者子菜单。
这里解释一些重载方法四个参数： 
- groupId : 组别id 
- itemId：菜单项id 
- order：排序 
- titleRes：标题（可以是字符串资源，也可以是int引用资源）
我们设置参数的时候，设置同样的groupId说明归为同一组。
eg:
  // 定义菜单项id
    private static final int ITEM1 = Menu.FIRST;
    private static final int ITEM2 = Menu.FIRST + 1;
    private static final int ITEM3 = Menu.FIRST + 2;
    private static final int ITEM4 = Menu.FIRST + 3;
    private static final int ITEM5 = Menu.FIRST + 4;
    private static final int ITEM6 = Menu.FIRST + 5;
    private static final int ITEM7 = Menu.FIRST + 6;
    private static final int ITEM8 = Menu.FIRST + 7;
    private static final int ITEM9 = Menu.FIRST + 8;

 @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // 采用硬编码的形式实现菜单
        // 直接设置标题
//        menu.add("菜单项1");
//        menu.add("菜单项2");
        menu.add(1, ITEM1, 1, "菜单项1");
        menu.add(1, ITEM2, 2, "菜单项2");
        menu.add(2, ITEM3, 3, "菜单项3");
        menu.add(2, ITEM4, 4, "菜单项4");


        // 添加子菜单
        SubMenu subMenu = menu.addSubMenu(1, ITEM5, 5, "子菜单1");
        subMenu.add(1, ITEM7, 1, "子菜单项1");
        subMenu.add(1, ITEM8, 2, "子菜单项2");
        subMenu.add(1, ITEM9, 3, "子菜单项3");

        menu.addSubMenu(1, ITEM6, 6, "子菜单2");



        // Inflate the menu; this adds items to the action bar if it is present.
//        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }


如何响应菜单点击事件？
 @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case ITEM1:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
            case ITEM2:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
            case ITEM3:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
            case ITEM4:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
            case ITEM5:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
            case ITEM6:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
            case ITEM7:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
            case ITEM8:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
            case ITEM9:
                Toast.makeText(this,"你点击了" + item.getTitle(), Toast.LENGTH_SHORT).show();

                break;
        }

        return true;
    }
效果如下： 

xml文件
这种方式可以让我们开发者更方便得指定菜单，这样我们就不用去设定指定的itemId，而是由Android为我们随意生成指定id，这样的话我们在响应的时候，根据在xml指定id来判断即可。
eg: 
    <menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    tools:context=".MainActivity">
    <!-- group1 -->
    <group android:id="@+id/group1">
        <item
            android:id="@+id/mi1"
            android:title="item1" />
        <item
            android:id="@+id/mi2"
            android:title="item2" />
    </group>
    <!-- group 2 -->
    <group android:id="@+id/group2">
        <item
            android:id="@+id/mi3"
            android:title="item3" />
        <item
            android:id="@+id/mi4"
            android:title="item4" />
    </group>
</menu>

然后再onCreateOptionMenu中这样加载：
 getMenuInflater().inflate(R.menu.menu_main, menu);
响应事件就不说了，跟硬编码的响应方式一样。
Context Menu（上下文菜单）
上下文菜单跟选项菜单有点区别，后者是响应Activity的操作，而前者是响应View的操作。
如何使用？
注册上下文菜单
 private Button contextMenuButton;

    @Override
    protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        contextMenuButton = (Button) findViewById(R.id.button);
        registerForContextMenu(contextMenuButton);
    }
生成上下文菜单
 @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
        // set context menu title
        menu.setHeaderTitle("文件操作");
        // add context menu item
        menu.add(0, 1, Menu.NONE, "发送");
        menu.add(0, 2, Menu.NONE, "标记为重要");
        menu.add(0, 3, Menu.NONE, "重命名");
        menu.add(0, 4, Menu.NONE, "删除");
        super.onCreateContextMenu(menu, v, menuInfo);
    }
响应上下文
@Override
    public boolean onContextItemSelected(MenuItem item) {
        // 得到当前被选中的item信息
        AdapterView.AdapterContextMenuInfo menuInfo = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        Log.v(TAG, "context item seleted ID=" + menuInfo.id);

        switch (item.getItemId()) {
            case 1:
                // do something
                break;
            case 2:
                // do something
                break;
            case 3:
                // do something
                break;
            case 4:
                // do something
                break;
            default:
                return super.onContextItemSelected(item);
        }
        return true;
    }
ok，当我们长按指定上下文的view，就会弹出上下文菜单：

Popup Menu （弹出菜单）
这个菜单跟Context Menu类似，也是响应View的操作的，比如我们响应一个按钮，点击按钮就弹出菜单项，它的操作上就不用像上下文菜单那样要长按。
eg:
public void showPopupMenu(View view) {
        PopupMenu popupMenu = new PopupMenu(this, view);
        MenuInflater inflater = popupMenu.getMenuInflater();
        inflater.inflate(R.menu.menu_main, popupMenu.getMenu());

        popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
            @Override
            public boolean onMenuItemClick(MenuItem item) {
                switch (item.getItemId()) {
                    case R.id.mi1:
                        // do something
                        break;
                    case R.id.mi2:
                        // do something
                        break;
                    case R.id.mi3:
                        // do something
                        break;
                    case R.id.mi4:
                        // do something
                        break;
                }
                return false;
            }
        });

        popupMenu.show();

    }
效果： 

最后
关于Android的几种类型的菜单已经介绍完，基本用法就如本篇博客所说，相信大家学完本节课就比较清楚如何对菜单进行操作，如果想获得更多关于menu资源的知识，可以到官网查询，这里我就不多说了。我们可以看到Android的版本迭代更新很快，每一个版本都会有新的改进，从以往的option menu到actionbar再到toolbar，android给我们的体验也不断改进，这意味着技术在变更，很多东西都在以一种新的面貌出现，我们需要不断更新自己的知识体系才能更好的跟上时代的步伐，本节课就到这里，谢谢大家。

小巫的博文会同步更新到我的微信公众号，欢迎大家关注：


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

UIScrollView添加控件，控件距离顶部始终有间距的问题
今天，特别郁闷，自定义了一个UIScrollView,然后在它里面添加控件，如UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(0,0,100,100)];
按理来说，这个button应该在scrollView的顶部，但是却不是，他与顶部相距一个statusbar+navagation高度，搞了半天也没发现这一点。。。。。
我一直以为是自己的contentsize设置的问题，所以一直围绕这个来想解决方案，浪费了较多时间。。。
现总结如下：
如果在UINavigationController内设置一个UIViewControlller，而UIViewController的第一个子视图是UIScrollView的话，UIScrollview里面所有的subView都会发生下移。在navigationBar，以及statusBar都显示的情况下，Navigation的当前VC，他的VC的view的子视图树的根部的第一个子视图，如果是Scrollview的话，这个scrollview的所有子视图都会被下移64个像素。



解决方案
1、把scrollview的所有子视图上移64个像素。

2、把scrollView更改地位，是它不是子视图树的根部第一个子视图。即在添加scrollview到父视图之前，先添加其他控件

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android-ViewFlipper（图片轮播 和 手势控制 实例）
1.回顾
   上篇 学习了 ViewPager 的 使用的三种方式，分别通过 PagerAdapter , FragmentPagerAdapter 和 FragmentStatePagerAdapter


2. 重点
    （1）ViewFlipper
    （2）图片轮播 （自动）
    （3）手势控制
    （4）OnTouchListener


3.ViewFliper
    3.1 介绍
           多页面管理控件，实现子页面自动切换
    3.2 添加View
        给ViewFliper加入View的两种方式：
              静态导入：将图片写死的，不灵活
              动态导入：动态生成 ImageView ，通过 addView() 方法加入到ViewFliper中
    3.3 控制
        （1）设置时间间隔，自动切换 ，可以添加 切换效果
        （2）手势控制 通过 OnTouchListener事件


4.图片轮播 自动切换
    4.1 布局实现
           添加 id ，后 通过 findViewById 初始化 控件；

  <ViewFlipper
      android:id="@+id/flipper"
      android:layout_width="match_parent"
      android:layout_height="300dp" >
</ViewFlipper>


    4.2 业务实现

                                                    
（1）初始化控件和准备数据

        在Drawable 文件夹下 准备 4 张图片 ，声明数组 将 id 添加到数组中；
private ViewFlipper flipper;
	
	private int [] ids={R.drawable.pic1,R.drawable.pic2,R.drawable.pic3,R.drawable.pic4};

    （2）代码实现
           注意：图片尽量控制在200k以内，否则 报 内存溢出 错误；

		flipper=(ViewFlipper) findViewById(R.id.flipper);
		
		//动态倒入 ：设置资源
		for (int i : ids) {
			ImageView imageView=new ImageView(this);
			//imageView.setBackgroundResource(i);
			imageView.setImageResource(i);
			flipper.addView(imageView);
		}

		//设置切换时间间隔
		flipper.setFlipInterval(3000);
		//启动
		flipper.startFlipping();


5.手势控制
   实现 OnTouchListener 事件；
    开始的时候，在ACTION_MOVE里判断 ，这样是不好的，切换太频繁了，看不到效果；
    最后的实现是，当手指离开的时候，判断切换，故在ACTION_UP里 进行判断；

class flipperOnTouchListener implements OnTouchListener{

		@Override
		public boolean onTouch(View v, MotionEvent event) {
			// 手势判断
			switch (event.getAction()) {
			   
			//手势按下
			case MotionEvent.ACTION_DOWN:
				//获取手指按下的点
				start=(int) event.getX();
				break;
		    //手势移动
            case MotionEvent.ACTION_MOVE:
				//移动判断
            	
				break;
		    //手离开
            case MotionEvent.ACTION_UP:

            	//按下的点 和结束的点 的插 大于100 为 向右
            	if(start - event.getX()>1000){
            		//可以添加过度效果
            		//下一张
            		flipper.showPrevious();
            	}
            	
            	
            	//按下的点 和结束的点 的插 小于100 为 向左
            	if(start - event.getX()<1000){
            		//上一张
            		flipper.showNext();
            	}
            	
      				break;
			}
			return true;
		}
		
	}
    给Flipper 添加事件 ：


flipper.setOnTouchListener(new flipperOnTouchListener());

6.demo 下载

http://download.csdn.net/detail/lablenet/9044777






版权声明：本文为博主原创文章，未经博主允许不得转载。

quick-cocos2d-x 3.3打包apk,编译时候报错：系统找不到指定路径

如图所示，我运行项目frameworks/runtime-src/proj.android/build_native.bat的时候报错，找了半天不知道错误在哪里，看官方的Readme里面说要是这时候编译出错让看sdk、ndk的版本和路径，于是把精力集中在这里，sdk版本换了好几个，也没找出来是啥原因，最后，把我的项目存放路径，Quick-cocos2d-x-Project这个路径名称改为Quick-Project重新编译的时候，OK了，所以判定应该是文件名称的问题，有可能是文件名称里面的-太多了。







版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        iOS－设置视图的边框
iOS－设置视图的边框
效果图：






具体代码：


//创建视图
   
UIView * view=[[[UIView
alloc]init]autorelease];
    view.frame=CGRectMake(0,
0, 270, 
250);

    view.backgroundColor=[UIColor
whiteColor];

    view.center=self.view.center;
    [self.view
addSubview:view];

    

    //view的边框
   
CALayer * layer=[view
layer];
    [layer
setMasksToBounds:YES];    
//是否设置边框以及是否可见
    [layer
setBorderWidth:1.5];      
//设置边框线的宽

    [layer setBorderColor:[[UIColor
blackColor] CGColor]];  
//设置边框线的颜色

    

    
   
UIButton * button=[[UIButton
alloc]init];
    button.frame=CGRectMake(20,
180, 230, 
50);

    button.backgroundColor=[UIColor
grayColor];
    [view
addSubview:button];

    

    //按钮的边框
   
CALayer * layer1=[button
layer];
    [layer1
setMasksToBounds:YES];    
//是否设置边框以及是否可见
    [layer1
setBorderWidth:1.5];      
//设置边框线的宽

    [layer1 setBorderColor:[[UIColor
blackColor] CGColor]];  
//设置边框线的颜色



ps：大写的view和button可以替换成各种控件～






版权声明：本文为博主原创文章，未经博主允许不得转载。

IOS-7-纪念一下刚刚接到的第一份offer（以下是面试遇到的问题）
1.多线程技术
有四种开启线程的方式，主要的为：NSThread、NSOperation、GCD；另一种已经老掉牙了，基于C语言，就不写了，基本不用。
例子：家在网络图片显示在手机界面上
第一步：代码块开启异步子线程加载网络数据：

[NSURLConnection 
sendAsynchronousRequest:request queue:[NSOperationQueuenew] 
第二步：加载完成之后，开启主线程，将数据放到主线程中进行处理：


dispatch_async(dispatch_get_main_queue(), ^{
    });


2.数据格式及解析方式：
一般用JSON进行数据封装，手机端进行JSON解析；---------广泛应用。
另一种就是XML数据格式，可以用DOM、SAX。。。、、、、--------用的较少，解析速度慢，消耗内存大。
3.整个网络架构
3年大学实验室经历，从底层传感器----单片机-----无线通信网络----服务器-----数据库-------移动端和PC端均会，可独立搭建一套系统。

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android 语言切换实现（就是这么简单）
近期因为项目需要，点击系统设置-》语言和输入法-》选择语言-》应用内语言跟着切换的实现，废话不多说，直接接入主题
以我的为例：我的需求是实现简体中文，和繁体字的切换
1.你需要在项目的res目录下新建两个文件夹如图： values-zh-rCN,values-zh-rTW(zh-rCN,zh-rTW 分别代表中文简体，中文繁体，其他语言也都类似)


分别在两个目录下新建一个String.xml文件
例如 values-zh-rCN：





values-zh-rTW



然后点击系统设置-》语言和输入法-》选择语言-》应用内语言就会跟着切换啦，是不是很简单！

版权声明：本文为博主原创文章，未经博主允许不得转载。

[Android]GreenDao（2）——使用
上一篇讲了GreenDao的配置，本篇着重于API的各种使用，并附上Demo。
类的关系
大家还记得上一篇讲到的代码自动生成的四个类,DaoMaster,DaoSession,Dao,User,排除最后一个User实体类不说，其他三个的关系应该是非常明确的。

从图上看出，得到User对象的步骤。其中还有些细节需要说明。
获取DaoMaster
用过数据库的程序圆都清楚，我们需要DaoSession对象来进行对数据库的增删改查。
从DaoMaster中有newSession()的方法可以帮我们实现。
所以我们应该先实例化DaoMaster，具体代码是
public DaoMaster(SQLiteDatabase db) {
    super(db, SCHEMA_VERSION);
    registerDaoClass(UserDao.class);
}

噢，需要一个SQLiteDatabase实例，请拼命想一想怎么获取一个SQLiteDatabase实例？
没错，通过SQLiteOpenHelper，再仔细看一下DaoMaster,好像已经提供了抽象类OpenHelper继承了SQLiteOpenHelper。
Cool!
可以获取DevOpenHelper,具体代码是
     /**
     * WARNING: Drops all table on Upgrade! Use only during development.
     */
    public static class DevOpenHelper extends OpenHelper {
        public DevOpenHelper(Context context, String name, CursorFactory factory) {
            super(context, name, factory);
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
            dropAllTables(db, true);
            onCreate(db);
        }
    }

先不管警告的注释（当数据库升级的时候会删除所有表，仅限于开发时使用）。
只要简单两行代码。
DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(context, DB_NAME, null);
DaoMaster daoMaster = new DaoMaster(mHelper.getReadableDatabase());
//也可以使用mHelper.getWritableDatabase();

注意:getReadabledatabase()与getWritableDatabase()其实返回的实例都是一样的，只是当内存空间不足的时候，就不能继续写入数据，更为重要的是，它们都是耗时耗时耗时操作！更为详细的解释
获取DaoSession
接着，我们来获取DaoSession。
DaoSession daoSession = daoMaster.newSession();
//异步查询，异步查询，异步查询
AsyncSession asyncSession = daoSession.startAsyncSession();

够简单吗？获得DaoSession后可以干什么？其实增删改查的基本功能已经齐全。 
只是有三个缺点：

颗粒度太大
API不是很方便
官网注释说只是用于快捷操作

所以UserDao登场吧
获取UserDao
UserDao userDao = daoSession.getUserDao();

好了，下面就可以随心所欲地操作数据库了。
操作数据库
增
/**
 * 插入一个User对象
 *
 * @param user
 * @return 插入对象的列id
 */
public long insert(User user) {
    UserDao userDao = getUserDao();
    return userDao.insert(user);
}

查查查*重点
具体方法有

queryXXX(...),指明各种条件
使用QueryBuilder（单次查询），Query（多次查询） 
其他等

这里着重讲QueryBuilder和Query，个人用得非常顺手，因为自己对SQL语句并不喜欢，so…
看一个简单例子
/**
 * 通过id取得用户。此处使用QueryBuider，并没有构造Query
 *
 * @param id
 * @return
 */
public User getUserById(long id) {
    UserDao userDao = getUserDao();
    //获取QueryBuilder
    QueryBuilder qb = userDao.queryBuilder();
    //声明条件，属性在UserDao中已经存在
    qb.where(UserDao.Properties.Id.eq(id));
    //返回唯一数据
    return (User) qb.unique();
}

而QueryBuilder只是用来创建Query而已，Query更使用于相同的查询，所以QueryBuilder就不要随便用了。

Query通过QueryBuilder.build()获取，它是使用Builder模式设计的，支持多次查询，多线程查询
//实际按照要求具体操作
Query<User> query = userDao.queryBuilder().orderDesc().where().count().build();
//返回单一结果
query.unique()
//返回一个非null的实体。否则就会抛出一个DaoException。
query.uniqueOrThrow()
//所有查询都加载到内存
query.list();
//实体按照需求加载进入内存。一旦列表中的一个元素被第一次访问，它将被加载同时缓存以便以后使用。必须close。
query.listLazy();
//多线程查询，为当前线程获取一个Query实例
query.forCurrentThread();

支持equal,in,between等等一系列比较符
Query可重用

先创建如下Query,根据id = 123和age = 10进行查找（示例）
    UserDao userDao = getUserDao();
    QueryBuilder<User> queryBuilder = userDao.queryBuilder().where(UserDao.Properties.Id.eq(123));
    queryBuilder.where(UserDao.Properties.Age.eq(10)).unique();
    Query query = queryBuilder.build();
    query.unique();

下一次同样需要根据id = 321和age = 100来进行查找，就可以
//设置id和age的值
query.setParameter(321, 100);
//返回唯一结果
//query.unique()
//设置多个查找目标
query.setParameter(111, 180);
//返回list
query.list();

注意:当Query没有返回语气结果，故障排查可以设置QueryBuilder.LOG_SQL = true;和QueryBuilder.LOG_VALUES = true;，打印出SQL语句
更多高级用法请查看官方API文档。
改
基本原则是根据主键来修改，比较简单的两种情况是

已知主键

直接能用API的都基本上已知主键的
    /**
     * 更新user信息
     *
     * @param newUser 新User,主键必须存在
     */
    public void update(User newUser) {
        UserDao userDao = getUserDao();
        userDao.update(newUser);
    }

* 未知主键，知道其他值
先根据主键查找（复习查找的知识），再重复情况一
删
同理，跟改操作基本一致。
   /**
     * 根据主键删除User
     *
     * @param id User的主键Id
     */
    public void deleteUserById(long id) {
        UserDao userDao = getUserDao();
        userDao.deleteByKey(id);
    }

总结
GreenDao给我们简化了编写大量重复代码的步骤，作为轻量级的ORM框架速度飞快，值得深入学习。
GreenDao底层并不保证线程安全，这意味着多线程环境下还需要我们程序圆来控制 ;)
源码链接

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

利用runtime动态生成对象？
利用runtime我们可以动态生成对象、属性、方法这特性
假定我们要动态生成DYViewController，并为它创建属性propertyName
1）对象名

    NSString *class =
@"DYViewController";
    const
char *className = [class cStringUsingEncoding:NSASCIIStringEncoding];
2）从一个字符串返回一个Class

    Class newClass = objc_getClass(className);
3）创建类

        Class superClass = [UIViewController
class];
        newClass = objc_allocateClassPair(superClass, className,
0);
4) 注册

注册你创建的这个类
        objc_registerClassPair(newClass);
5）创建DYViewController对象

    id instance = [[newClass
alloc] init];
6）给类增加属性propertyName，值为propertyValue


            利用kvc赋值
            [instance setValue:propertyValue forKey:propertyName];


版权声明：本文为博主原创文章，未经博主允许不得转载。

通过非常简单的方式进行生成应用的ipa文件
首先前提条件是：具有开发者应用的的账号，这里介绍的只是有证书的情况。
生成ipa文件的基本步骤：
1、打开itunes之后，然后就是勾选商店里面的应用程序，默认是不勾选的，或者在通用里面（反正勾选“应用程序”就好了）
2、然后点击应用程序，如果连上了ios设备，将会显示ios设备上面的应用程序。也就是显示已经有的应用程序。
可以看看这个界面：（图）




3、打开我们要制作ipa的应用程序的二进制包（~/Library/Developer/Xcode/DerivedData/(项目名称)/Build/Products
这个目录是关于我们将会运行的时候编译产生的模拟器以及真机的编译文件。），
然后将其拉到iTunes上面，我们就可以然后拉出来，就会变成了ipa包，因为iTunes会帮我们打包好了。




版权声明：本文为博主原创文章，未经博主允许不得转载。

使用Picasso加载图片的内存优化实践
0 说明
现在Android开源库中有许多图片加载框架，本文以picasso为例，总结下开发过程中的一些优化经验，使用的picasso版本如下
compile 'com.squareup.picasso:picasso:2.5.2'
1 图片裁剪
在列表页尽量使用裁剪后的图片，在查看大图模式下才加载完整的图片。
图片裁剪示例
Picasso.with( imageView.getContext() )
.load(url)
.resize(dp2px(250),dp2px(250))
.centerCrop()
.into(imageView);
picasso默认情况下会使用全局的ApplicationContext，即开发者传进去Activity，picasso也会通过activity获取ApplicationContext。
2 查看大图放弃memory cache
Picasso默认会使用设备的15%的内存作为内存图片缓存，且现有的api无法清空内存缓存。我们可以在查看大图时放弃使用内存缓存，图片从网络下载完成后会缓存到磁盘中，加载会从磁盘中加载，这样可以加速内存的回收。
Picasso.with(getApplication())
.load(mURL)
.memoryPolicy(NO_CACHE, NO_STORE)
.into(imageView);
其中memoryPolicy的NO_CACHE是指图片加载时放弃在内存缓存中查找，NO_STORE是指图片加载完不缓存在内存中。
3 RecyclableImageView
重写ImageView的onDetachedFromWindow方法，在它从屏幕中消失时回调，去掉drawable引用，能加快内存的回收。
public class RecyclerImageView extends ImageView
{ 
    ...

    @Override    
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        setImageDrawable(null);   
    }
}
实验环境：加载大图不使用内存缓存。 
实验场景：从图片列表页切换到详情页看大图，然后返回，不停重复。


可以看到使用了RecyclableImageView的实验在切换过程中产生的内存谷值明显优于ImageView，说明drawable更容易被回收。
4 新进程中查看大图
列表页的内存已经非常稳定，但是查看大图时，大图往往占用了20+m内存，加上现有进程中的内存，非常容易oom，在新进程中打开Activity成为比较取巧的避免oom的方式。
<activity android:name=".DetailActivity" android:process=":picture"/>
只要在AndroidManifest.xml中定义Activity时加入process属性，即可在新进程中打开此Activity。由此，picasso也将在新进程中创建基于新ApplicationContext的单例。
5 列表页滑动优化
picasso可以对多个加载请求设置相同的tag，即
Object tag = new Object();
Picasso.with( imageView.getContext() )
.load(url)
.resize(dp2px(250),dp2px(250))
.centerCrop()
.tag(tag)
.into(imageView);
例如在RecyclerView滑动时监听，处理不同的表现：
mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override
    public void onScrollStateChanged(RecyclerView recyclerView, int newState)
    {
        if (newState == RecyclerView.SCROLL_STATE_IDLE)
        {
            Picasso.with(context).resumeTag(tag);
        }
        else
        {
            Picasso.with(context).pauseTag(tag);
        }
    }
});
6 RGB_565
对于不透明的图片可以使用RGB_565来优化内存。
Picasso.with( imageView.getContext() )
.load(url)
.config(Bitmap.Config.RGB_565)
.into(imageView);
默认情况下，Android使用ARGB_8888
Android中有四种，分别是：
ALPHA_8：每个像素占用1byte内存
ARGB_4444:每个像素占用2byte内存
ARGB_8888:每个像素占用4byte内存
RGB_565:每个像素占用2byte内存
RGB_565呈现结果与ARGB_8888接近，内存对比如下图


7 reference
Picasso and Context 
JakeWharton的避免OOM建议 
Clear Cache memory of Picasso

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

[iOS]把16进制颜色转换UIColor
- (void)viewDidLoad {
    [super
viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    


    UIColor *color = [self
colorWithHexString:@"#81c52b"];
    [self.view
setBackgroundColor:color];
}


- (UIColor *) colorWithHexString: (NSString *) stringToConvert
{
    NSString *cString = [[stringToConvert
stringByTrimmingCharactersInSet:[NSCharacterSet
whitespaceAndNewlineCharacterSet]]
uppercaseString];//字符串处理
    //例子，stringToConvert #ffffff
    if ([cString
length] < 6)
        return [UIColor
redColor];//如果非十六进制，返回白色
    if ([cString
hasPrefix:@"#"])
        cString = [cString substringFromIndex:1];//去掉头
    if ([cString
length] != 6)//去头非十六进制，返回白色
        return [UIColor
greenColor];
    //分别取RGB的值
    NSRange range;
    range.location =
0;
    range.length =
2;
    NSString *rString = [cString
substringWithRange:range];
    
    range.location =
2;
    NSString *gString = [cString
substringWithRange:range];
    
    range.location =
4;
    NSString *bString = [cString
substringWithRange:range];
    
    unsigned
int r, g, b;
    //NSScanner把扫描出的制定的字符串转换成Int类型
    [[NSScanner scannerWithString:rString] scanHexInt:&r];
    [[NSScanner scannerWithString:gString] scanHexInt:&g];
    [[NSScanner scannerWithString:bString] scanHexInt:&b];
    //转换为UIColor
    return [UIColor colorWithRed:((float) r /
255.0f)
                           green:((float) g /
255.0f)
                            blue:((float) b /
255.0f)
                           alpha:1.0f];
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

android---护眼灯和兼容性高的手电筒实现
程序主要有两个功能,一是护眼灯,二是手电筒,然而手电筒兼容性解决办法就是加入异常控制,避免各种异常占用启动不了手电筒. 
程序主界面,没有美化,只实现基本功能. 

部分代码: 
护眼蒙板主要代码
    private void CreateView() {
        mWindowManager = (WindowManager) getApplication()
                .getSystemService(Context.WINDOW_SERVICE);
        wmParams = new WindowManager.LayoutParams();
        // 电话窗口。它用于电话交互（特别是呼入）。它置于所有应用程序之上，状态栏之下。
        wmParams.type = WindowManager.LayoutParams.TYPE_PHONE;
        //设置图片格式,效果为背景透明
        wmParams.format = PixelFormat.RGBA_8888;
        // 设置浮动窗口不可聚焦（实现操作除浮动窗口外的其他可见窗口的操作）
        wmParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
        //调整悬浮窗显示的停靠位置为左侧置顶
        wmParams.gravity = Gravity.LEFT | Gravity.TOP;
        wmParams.x = 0;
        wmParams.y = 0;
        //设置悬浮窗口长宽数据
        wmParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        wmParams.height = WindowManager.LayoutParams.MATCH_PARENT;
        v = new MyView(getApplicationContext());
        mWindowManager.addView(v, wmParams);
    }
手电筒主要代码
    /**
     * 打开或者关闭手电筒
     */
    private View.OnClickListener flash = new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            // 先判断是否有闪光灯
            if (!getPackageManager().hasSystemFeature(
                    PackageManager.FEATURE_CAMERA_FLASH)) {
                Toast.makeText(MainActivity.this, "当前设备没有闪关灯", Toast.LENGTH_LONG).show();
                return;
            }
            if (flashstate){
                close();
                btnstartflash.setText("开启手电筒");
            }else if (!flashstate){
                open();
                btnstartflash.setText("关闭手电筒");
            }

        }
    };


        private void initflashmode() {
            try {
                camera = Camera.open();
                camera.setPreviewTexture(new SurfaceTexture(0));
            } catch (IOException e) {
                close();
            }
            if (camera != null) {
                parameters = camera.getParameters();
                previousflashmode = parameters.getFlashMode();
            }
            if (previousflashmode == null) {
                previousflashmode = Camera.Parameters.FLASH_MODE_OFF;
            }
        }

        //关闭相机
        private void close() {
            if (camera!=null){
                parameters.setFlashMode(previousflashmode);
                camera.setParameters(parameters);
                camera.release();
                camera = null;
                flashstate = false;
            }
        }
        //打开相机
        private void open(){

            if (camera==null) {
                initflashmode();
            }
            if (camera!=null){
                parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
                camera.setParameters(parameters);
                camera.startPreview();
                flashstate = true;
            }

        }
完整代码可以联系我1015315668@qq.com

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

android 首页fragment切换
方法一：
布局文件：
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >
    <FrameLayout
        android:id="@+id/content_frame_main"
        android:layout_width="match_parent"
        android:layout_weight="1"
        android:layout_height="0dp" >
    </FrameLayout>
    <FrameLayout
        android:id="@+id/content_frame_list"
        android:layout_width="match_parent"
        android:layout_weight="1"
        android:layout_height="0dp"  >
    </FrameLayout>
    <FrameLayout
        android:id="@+id/content_frame_personal"
        android:layout_width="match_parent"
        android:layout_weight="1"
        android:layout_height="0dp"  >
    </FrameLayout>
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="@dimen/common_tabbar_height"
        android:background="@drawable/common_border_top_selector"
        android:layout_gravity="bottom"
        android:clickable="true"
        android:weightSum="3.0" >
        <include layout="@layout/bottom_view" />
     </LinearLayout>


</LinearLayout>
java文件：
BottomUtil buttom = new BottomUtil(this, 0); //初始化bottom_view.xml文件
View 
mMainContainerView = findViewById(R.id.content_frame_main);
View mListContainerView = findViewById(R.id.content_frame_list);
View mPersonalContainerView = findViewById(R.id.content_frame_personal);

点击切换时调用setShowMode方法：
public void setShowMode(int index) {
mListContainerView.setVisibility(View.GONE);
mMainContainerView.setVisibility(View.GONE);
mPersonalContainerView.setVisibility(View.GONE);
switch (index) {
case BottomUtil.MAIN_FRAGMENT:
if (mMainFragment == null) {
mMainFragment = new MainFragment();
//FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
t.replace(R.id.content_frame_main, mMainFragment);
t.commit();
} else {
mMainFragment = (MainFragment) this.getSupportFragmentManager()
.findFragmentById(R.id.content_frame_main);
}
mMainContainerView.setVisibility(View.VISIBLE);
getSupply();
break;
case BottomUtil.JOBLIST_FRAGMENT:
if (mListFragment == null) {
mListFragment = new ListFragment();


FragmentTransaction t = this.getSupportFragmentManager()
.beginTransaction();
t.replace(R.id.content_frame_list, mListFragment);
t.commit();
} else {
mListFragment = (ListFragment)this.getSupportFragmentManager()
.findFragmentById(R.id.content_frame_list);
}
mListContainerView.setVisibility(View.VISIBLE);
break;
case BottomUtil.PERSONAL_FRAGMENT:
if (mPersonalFragment == null) {
mPersonalFragment = new PersonalFragment();


FragmentTransaction t = this.getSupportFragmentManager()
.beginTransaction();
t.replace(R.id.content_frame_personal, mPersonalFragment);
t.commit();
} else {
mPersonalFragment = (PersonalFragment) this
.getSupportFragmentManager().findFragmentById(
R.id.content_frame_personal);
}
mPersonalContainerView.setVisibility(View.VISIBLE);
break;
}
}





BottomUtil .java文件（加载初始化底部切换按钮）：

public class BottomUtil implements OnClickListener {
public static final int MAIN_FRAGMENT = 1;
public static final int JOBLIST_FRAGMENT = 2;
public static final int PERSONAL_FRAGMENT = 3;

MainActivity mContext;
/**
* 当前页面焦点,即显示的页面索引
*/
int mCurrentFocus = -1;
/**
* 底部菜单栏初始化所有控件类的一个实例
*/
BottomViewItem item;


public BottomUtil(MainActivity context, int index) {
mContext = context;
item = BottomViewItem.getInstance();
initTab(index);
}


/**
* 控件初始化
*/
private void initTab(int index) {
for (int i = 0; i < item.viewNum; i++) {
item.linears[i] = (LinearLayout) mContext
.findViewById(item.linears_id[i]);
item.linears[i].setOnClickListener(this);
item.images[i] = (ImageView) mContext
.findViewById(item.images_id[i]);
item.texts[i] = (TextView) mContext.findViewById(item.texts_id[i]);
}


setViewTab(index);
}


/**
* @param index
*            根据索引值切换背景
*/
private void setViewTab(int index) {
if (index == mCurrentFocus)
return;
mCurrentFocus = index;
for (int i = 0; i < item.viewNum; i++) {
item.images[i]
.setBackgroundResource(i == index ? item.images_selected[i]
: item.images_unselected[i]);
item.texts[i]
.setTextColor(i == index ? mContext.getResources().getColor(R.color.common_btn_main_pressed_color)
: mContext.getResources().getColor(R.color.common_textcolor_third));
}
}


@Override
public void onClick(View v) {
for (int i = 0; i < item.viewNum; i++) {
if (v.getId() == item.linears_id[i] && (i != mCurrentFocus)) {
/*if(i==2&&(!Preferences.isLogin())){
ToastUtil.make(mContext).show("您还没有登录");
return;
}*/
setViewTab(i);
// mContext.startActivity(new Intent(mContext,item.intents[i]));
mContext.setShowMode(i + 1);
}
}
}


}

方法二：
布局文件

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <FrameLayout
        android:id="@+id/fl_page"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

    </FrameLayout>

    <LinearLayout
        android:id="@+id/ll_main_tabbar"
        android:layout_width="match_parent"
        android:layout_height="@dimen/common_tabbar_height"
        android:background="@drawable/common_tabbar_bg"
        android:gravity="center"
        android:orientation="horizontal"
        android:paddingBottom="3dp"
        android:paddingTop="5dp">


        <RelativeLayout
            android:id="@+id/ll_main_tabitem_service"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:clickable="true"
            android:gravity="center"
            android:onClick="onTabItemClick"
            android:orientation="vertical">

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_above="@+id/iv_main_tabitem_service"
                android:layout_centerHorizontal="true"
                android:scaleType="fitCenter"
                android:src="@drawable/main_tabbar_service_selector" />

            <TextView
                android:id="@+id/iv_main_tabitem_service"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_alignParentBottom="true"
                android:layout_centerHorizontal="true"
                android:text="@string/common_tabbar_label_service"
                android:textColor="@drawable/common_tabbar_text_selector"
                android:textSize="@dimen/common_tabbar_textsize" />
        </RelativeLayout>

        <RelativeLayout
            android:id="@+id/ll_main_tabitem_bbs"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:clickable="true"
            android:gravity="center"
            android:onClick="onTabItemClick"
            android:orientation="vertical">

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_above="@+id/iv_main_tabitem_bbs"
                android:layout_centerHorizontal="true"
                android:scaleType="fitCenter"
                android:src="@drawable/main_tabbar_bbs_selector" />

            <TextView
                android:id="@+id/iv_main_tabitem_bbs"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_alignParentBottom="true"
                android:layout_centerHorizontal="true"
                android:text="@string/common_tabbar_label_bbs"
                android:textColor="@drawable/common_tabbar_text_selector"
                android:textSize="@dimen/common_tabbar_textsize" />
        </RelativeLayout>

        <RelativeLayout
            android:id="@+id/ll_main_tabitem_news"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:clickable="true"
            android:gravity="center"
            android:onClick="onTabItemClick"
            android:orientation="vertical">

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_above="@+id/iv_main_tabitem_news"
                android:layout_centerHorizontal="true"
                android:scaleType="fitCenter"
                android:src="@drawable/main_tabbar_news_selector" />

            <TextView
                android:id="@+id/iv_main_tabitem_news"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_alignParentBottom="true"
                android:layout_centerHorizontal="true"
                android:text="@string/common_tabbar_label_news"
                android:textColor="@drawable/common_tabbar_text_selector"
                android:textSize="@dimen/common_tabbar_textsize" />
        </RelativeLayout>


        <RelativeLayout
            android:id="@+id/ll_main_tabitem_profile"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:clickable="true"
            android:gravity="center"
            android:onClick="onTabItemClick"
            android:orientation="vertical">

            <ImageView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_above="@+id/iv_main_tabitem_profile"
                android:layout_centerHorizontal="true"
                android:scaleType="fitCenter"
                android:src="@drawable/main_tabbar_profile_selector" />

            <TextView
                android:id="@+id/iv_main_tabitem_profile"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_alignParentBottom="true"
                android:layout_centerHorizontal="true"
                android:text="@string/common_tabbar_label_profile"
                android:textColor="@drawable/common_tabbar_text_selector"
                android:textSize="@dimen/common_tabbar_textsize" />
        </RelativeLayout>


    </LinearLayout>

</LinearLayout>



java文件：


public class MainActivity extends BaseActivity {
    private static final String FRAGMENT_TAG_SERVICE = "service";
    private static final String FRAGMENT_TAG_BBS = "bbs";
    private static final String FRAGMENT_TAG_NEWS = "news";
    private static final String FRAGMENT_TAG_PROFILE = "profile";

    private ServiceFragment mServiceFragment;
    private BbsFragment mBbsFragment;
    private NewsFragment mNewsFragment;
    private ProfileFragment mProfileFragment;
    private FragmentManager mFragmentManager;
    private View mCurTabItemView;
    private Fragment mFragment;//当前的Fragment


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mFragmentManager = getFragmentManager();
        if (savedInstanceState != null) {
            //复活Fragment
            mServiceFragment = (ServiceFragment) mFragmentManager.findFragmentByTag(FRAGMENT_TAG_SERVICE);
            mBbsFragment = (BbsFragment) mFragmentManager.findFragmentByTag(FRAGMENT_TAG_BBS);
            mNewsFragment = (NewsFragment) mFragmentManager.findFragmentByTag(FRAGMENT_TAG_NEWS);
            mProfileFragment = (ProfileFragment) mFragmentManager.findFragmentByTag(FRAGMENT_TAG_PROFILE);
            FragmentTransaction fg = mFragmentManager.beginTransaction();
            if (mProfileFragment != null) {
                if (mProfileFragment.isAdded()) {
                    fg.hide(mProfileFragment);
                }
            }
            if (mNewsFragment != null) {
                if (mNewsFragment.isAdded()) {
                    fg.hide(mNewsFragment);
                }
            }

            if (mBbsFragment != null) {
                if (mBbsFragment.isAdded()) {
                    fg.hide(mBbsFragment);
                }
            }

            if (mServiceFragment != null) {
                if (mServiceFragment.isAdded()) {
                    fg.hide(mServiceFragment);
                }
            }
            fg.commit();
            Log.d("main", "fragment 被回收了，现在又复活了");
        }
        onTabItemClick(findViewById(R.id.ll_main_tabitem_service));
    }

    public void onTabItemClick(View v) {
        //TODO tab change
        if (mCurTabItemView == v) {
            return;
        }
        if (mCurTabItemView != null) {
            mCurTabItemView.setSelected(false);
        }
        mCurTabItemView = v;
        mCurTabItemView.setSelected(true);
        Fragment toFragment;//即将被显示的Fragment
        String tag;
        switch (v.getId()) {
            case R.id.ll_main_tabitem_service:
                if (mServiceFragment == null) {
                    mServiceFragment = new ServiceFragment();
                }
                tag = FRAGMENT_TAG_SERVICE;
                toFragment = mServiceFragment;
                break;
            case R.id.ll_main_tabitem_bbs:
                if (mBbsFragment == null) {
                    mBbsFragment = new BbsFragment();
                }
                tag = FRAGMENT_TAG_BBS;
                toFragment = mBbsFragment;
                break;
            case R.id.ll_main_tabitem_news:
                if (mNewsFragment == null) {
                    mNewsFragment = new NewsFragment();
                }
                tag = FRAGMENT_TAG_NEWS;
                toFragment = mNewsFragment;
                break;
            case R.id.ll_main_tabitem_profile:
                if (mProfileFragment == null) {
                    mProfileFragment = new ProfileFragment();
                }
                tag = FRAGMENT_TAG_PROFILE;
                toFragment = mProfileFragment;
                break;
            default:
                return;
        }
        if (mFragment == toFragment) {
            return;
        }

        FragmentTransaction fg = mFragmentManager.beginTransaction();
        //交换Fragment
        if (toFragment.isAdded()) {
            //已经被添加了
            if (mFragment != null) {
                fg.hide(mFragment);
            }
            fg.show(toFragment);
        } else {
            //没有被添加
            if (mFragment != null) {
                fg.hide(mFragment);
            }
            fg.add(R.id.fl_page, toFragment, tag);
        }
        fg.commit();
        mFragment = toFragment;
    }

}





版权声明：本文为博主原创文章，未经博主允许不得转载。

ARC之解决闭包引起的循环强引用


copy自：swift2.0官方教程中文版---极客学院版
1.产生闭包之间的循环强引用


直接代码和上图：

class HTMLElement {
	let name: String
	let text: String?
	lazy var asHTML: Void -> String = {
		if let text = self.text {
			return "<\(self.name)>\(text)</\(self.name)>"
		} else {
			return "<\(self.name) />"
		}
	}
	init(name: String, text: String? = nil) {
		self.name = name
		self.text = text
	}
	deinit {
		print("\(name) is being deinitialized")
	}
}var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
print(paragraph!.asHTML())
// prints"hello, world"注意: 上面的 paragraph
 变量定义为 可选HTMLElement ，因此我们可以赋值 nil 给它来演示循环强引用。





2.解决闭包之间的循环强引用




class HTMLElement {
	let name: String
	let text: String?
	lazy var asHTML: Void -> String = {
		[unowned self] in // 这里加上占有列表
		if let text = self.text {
			return "<\(self.name)>\(text)</\(self.name)>"
		} else {
			return "<\(self.name) />"
		}
	}
	init(name: String, text: String? = nil) {
		self.name = name
		self.text = text
	}
	deinit {
		print("\(name) is being deinitialized")
	}
}

闭包内的捕获定义:
1.无主引用，在闭包和捕获的实例总是互相引用时并且总是同时销毁时
2.弱引用，在被捕获的引用可能会变为 nil 时

定义捕获列表
捕获列表中的每一项都由一对元素组成，一个元素是 weak 或 unowned 关键字，另一个元素是类实例的引用（如 self ）或初始化过的变量（如 delegate = self.delegate! ）。这些项在方括号中用逗号分开。


如果闭包有参数列表和返回类型，把捕获列表放在它们前面：
lazy var someClosure: (Int, String) -> String = {
[unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in
// closure body goes here
}
如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字 in 放在闭包最开始的地方：
lazy var someClosure: Void -> String = {
[unowned self, weak delegate = self.delegate!] in
// closure body goes here
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift开发教程--如何在别的类中调用AppDelegate中的方法
((UIApplication.sharedApplication().delegate)
as! AppDelegate).xxxmethod();

版权声明：本文为博主原创文章，未经博主允许不得转载。

Imageview.setAdjustViewBounds用法
public void setAdjustViewBounds (boolean adjustViewBounds)
当你需要在 ImageView调整边框时保持可绘制对象的比例时，将该值设为真。
参数 
adjustViewBounds         是否调整边框，以保持可绘制对象的原始比例。
相关 XML
属性              android:adjustViewBounds
 
android:adjustViewBounds
是否保持宽高比。需要与maxWidth、MaxHeight一起使用，否则单独使用没有效果。  
  
设置View的最大高度，单独使用无效，需要与setAdjustViewBounds一起使用。如果想设置图片固定大小，又想保持图片宽高比，需要如下设置：
1） 设置setAdjustViewBounds为true；
2） 设置maxWidth、MaxHeight；
3） 设置设置layout_width和layout_height为wrap_content。
 

版权声明：本文为博主原创文章，未经博主允许不得转载。

再探cocos2d-x-----(1)
        cocos2d-x 的入口函数mian函数，用了win32的API的APIENTRY _tWinMain()，作为入口函数，感觉像是利用API的窗体进行构造出游戏界面窗体。在cocos编写游戏时，我们可以用AllocConsole();函数为调用进程分配一个新的控制台。
      一个进程只可以拥有一个控制台的关联，如果调用该函数的进程已经拥有一个控制台的关联，则AllocConsole函数失败。如果想创建一个新的控制台关联，则进程可以使用FreeConsole函数释放（解除）一个控制台的关联，然后进程可以重新调用AllocConsole来创建一个新的控制台或AttachConsole附加到另一台主机。
      注意：在使用完控制台程序之后一定要记得调用FreeConsole函数释放该控制台，否则会造成内存泄露。
      所谓的控制台，就是，在cocos中，你可以一边看你的主游戏窗体，一边看黑框框来进行打日志帮助调试，查看游戏运行过程。写法如下： 
  
	int res = 0;
	cocostudio::TransformHelp::allocHelpParentNode();
	{
		AllocConsole();
		freopen("CONIN$", "r", stdin);
		freopen("CONOUT$", "w", stdout);
		freopen("CONOUT$", "w", stderr); AppDelegate app;		res = Application::getInstance()->run();	   FreeConsole();
	}return res;      其中，freopen("CONIN$", "r", stdin);
     freopen("CONOUT$", "w", stdout);
     freopen("CONOUT$", "w", stderr);
详细见：http://www.cnblogs.com/cbscan/archive/2011/07/20/2111589.html


（仅是个人想法，如有不对还请指正。）

版权声明：本文为博主原创文章，未经博主允许不得转载。

Core Data容易出现的错误

1、2015-08-24 15:52:17.674 Tasks[3189:144763] CoreData: error: -addPersistentStoreWithType:SQLite configuration:(null) URL:file:///Users/zhumin/Library/Developer/CoreSimulator/Devices/09E156EA-B44B-4CCA-9E32-9286D332DDF0/data/Containers/Data/Application/4E9E83E8-DA35-4AE8-81FD-EBD9C09D17D6/Documents/Tasks.sqlite
 options:(null) ... returned error Error Domain=NSCocoaErrorDomain Code=134100 "The operation couldn’t be completed. (Cocoa error 134100.)" UserInfo=0x7fc84366ed60 {metadata={
    NSPersistenceFrameworkVersion = 519;
    NSStoreModelVersionHashes =     {
        Event = <5431c046 d30e7f32 c2cc8099 58add1e7 579ad104 a3aa8fc4 846e97d7 af01cc79>;
    };
    NSStoreModelVersionHashesVersion = 3;
    NSStoreModelVersionIdentifiers =     (
        ""
    );
    NSStoreType = SQLite;
    NSStoreUUID = "4EE0C579-E3F8-48CC-ACFF-26CBCB386C37";
    "_NSAutoVacuumLevel" = 2;
}, reason=The model used to open the store is incompatible with the one used to create the store} with userInfo dictionary {
    metadata =     {
        NSPersistenceFrameworkVersion = 519;
        NSStoreModelVersionHashes =         {
            Event = <5431c046 d30e7f32 c2cc8099 58add1e7 579ad104 a3aa8fc4 846e97d7 af01cc79>;
        };
        NSStoreModelVersionHashesVersion = 3;
        NSStoreModelVersionIdentifiers =         (
            ""
        );
        NSStoreType = SQLite;
        NSStoreUUID = "4EE0C579-E3F8-48CC-ACFF-26CBCB386C37";
        "_NSAutoVacuumLevel" = 2;
    };
    reason = "The model used to open the store is incompatible with the one used to create the store";
}
1、ps:上面的错误方法是相应的数据库没有创建成功。这个要注意我们在写属性指的设置的时候要对应。


2015-08-24 15:52:17.675 Tasks[3189:144763] Unresolved error Error Domain=YOUR_ERROR_DOMAIN Code=9999 "Failed to initialize the application's saved data" UserInfo=0x7fc843712020 {NSLocalizedFailureReason=There was an error creating or loading the application's
 saved data., NSLocalizedDescription=Failed to initialize the application's saved data, NSUnderlyingError=0x7fc84366ede0 "The operation couldn’t be completed. (Cocoa error 134100.)"}, {
    NSLocalizedDescription = "Failed to initialize the application's saved data";
    NSLocalizedFailureReason = "There was an error creating or loading the application's saved data.";
    NSUnderlyingError = "Error Domain=NSCocoaErrorDomain Code=134100 \"The operation couldn\U2019t be completed. (Cocoa error 134100.)\" UserInfo=0x7fc84366ed60 {metadata={\n    NSPersistenceFrameworkVersion = 519;\n    NSStoreModelVersionHashes =     {\n       
 Event = <5431c046 d30e7f32 c2cc8099 58add1e7 579ad104 a3aa8fc4 846e97d7 af01cc79>;\n    };\n    NSStoreModelVersionHashesVersion = 3;\n    NSStoreModelVersionIdentifiers =     (\n        \"\"\n    );\n    NSStoreType = SQLite;\n    NSStoreUUID = \"4EE0C579-E3F8-48CC-ACFF-26CBCB386C37\";\n   
 \"_NSAutoVacuumLevel\" = 2;\n}, reason=The model used to open the store is incompatible with the one used to create the store}";
}
(lldb)


2、这个出现错误的程度最高的就是：“用于打开存储的模型和用于创建存储的模型不兼容”
ps：需要使用Core Data迁移将数据从一个数据模型迁移到另外一个模型。（这个还没有学到）
现在解决方式：听过删除模拟器生成的app，然后再一次运行，
强制Core Data创建兼容当前数据模型的新的数据存储。






版权声明：本文为博主原创文章，未经博主允许不得转载。

针对不遵守GPL行为的正确做法
本文的目的是希望能给某些no sharing的同志一些反省，同时为gpl的发展贡献一份微薄之力！
    一些制造商发布一个基于Linux的二进制固件，不提供任何源码。怎样给制造商施压取得源码呢？下面介绍下一种正确的做法。
    在做任何事之前，第一步是阅读来自设备的许可，然后像制造商回复关于设备缺乏开放源代码。如果制造商回答你他们没有释放一个包含开源的SDK软件，那么建议您与gpl-violations.org社区取得联系。您会发现下面一个样本的信，这封信可以向制造商发送：

Miss, hemaomao(or xxx),
I am using a <device name>, and I cannot find neither on your website nor on the CD-ROM the open source software used to build or modify the firmware.
In conformance to the GPL license, you have to release the following sources:
    • complete toolchain that made the kernel and applications be compiled (gcc, binutils, libc)
    • tools to build a custom firmware (mksquashfs, mkcramfs ...)
    • kernel sources with patches to make it run on this specific hardware, this does not include binary drivers
Thank you very much in advance for your answer.
Best regards, dingyuanzhou(or xxx)支持开源社区的长久发展！





版权声明：本文为博主原创文章，未经博主允许不得转载。

[iOS]时间筛选之<本周、上周、更早>
1、可以实现时间筛选，目测应该还有更简单的方法。
思路： 获取当天时间，和目标时间进行比对操作。
注意点：时区 时区 时区 重要的时区说三遍。
- (void)viewDidLoad {
    [super viewDidLoad];
    NSDate * today = [NSDate date];
    
    //定义当前时区时间
    NSString * time =@"2015-08-16 00:00:00";
    NSDate* xmlData = [self dateFromString:time];
    
    xmlData = [self getNowDateFromatAnDate:xmlData];
    
    if([self intervalSinceNow:xmlData]>=[self getTodayisWeek:today]+7)
    {
        NSLog(@"这个日期是很早以前");
    }
    if([self intervalSinceNow:xmlData]>=[self getTodayisWeek:today]&&[self intervalSinceNow:xmlData]<[self getTodayisWeek:today]+7)
    {
        NSLog(@"这个日期是上周");
    }
    if([self intervalSinceNow:xmlData]<7&&[self intervalSinceNow:xmlData]<[self getTodayisWeek:today])
    {
        NSLog(@"这个日期是本周");
    }
    
    
}

- (int)intervalSinceNow: (NSDate *) theDate
{
    NSTimeInterval late=[theDate timeIntervalSince1970]*1;
    
    NSDate* dat = [NSDate dateWithTimeIntervalSinceNow:0];
    dat=  [self getNowDateFromatAnDate:dat];
    NSTimeInterval now=[dat timeIntervalSince1970]*1;
    NSString *timeString=@"";
    
    NSTimeInterval cha=now-late;
    
    if (cha/86400>1)
    {
        timeString = [NSString stringWithFormat:@"%f", cha/86400];
        timeString = [timeString substringToIndex:timeString.length-7];
        return [timeString intValue];
    }
    return -1;
   
}

- (NSDate *)getNowDateFromatAnDate:(NSDate *)anyDate
{
    //设置源日期时区
    NSTimeZone* sourceTimeZone = [NSTimeZone timeZoneWithAbbreviation:@"UTC"];//或GMT
    //设置转换后的目标日期时区
    NSTimeZone* destinationTimeZone = [NSTimeZone localTimeZone];
    //得到源日期与世界标准时间的偏移量
    NSInteger sourceGMTOffset = [sourceTimeZone secondsFromGMTForDate:anyDate];
    //目标日期与本地时区的偏移量
    NSInteger destinationGMTOffset = [destinationTimeZone secondsFromGMTForDate:anyDate];
    //得到时间偏移量的差值
    NSTimeInterval interval = destinationGMTOffset - sourceGMTOffset;
    //转为现在时间
    NSDate* destinationDateNow = [[NSDate alloc] initWithTimeInterval:interval sinceDate:anyDate];
    return destinationDateNow;
}
- (NSDate *)dateFromString:(NSString *)dateString{
    
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    
    [dateFormatter setDateFormat: @"yyyy-MM-dd HH:mm:ss"];
    
     NSDate *destDate= [dateFormatter dateFromString:dateString];
    
     return destDate;
    
}

//获得某日是周几
-(int)getTodayisWeek:(NSDate *)today
{
    today = [self getNowDateFromatAnDate:today];
    NSCalendar*calendar = [NSCalendar currentCalendar];
    NSDateComponents*comps;
    [comps setWeekday:0];
    comps =[calendar components:(NSCalendarUnitWeekday)fromDate:today];
    NSInteger weekday = [comps weekday]; // 星期几（注意，周日是“1”，周一是“2”。。。。）
    int  factWeekDay;
    //默认是周日开始
    switch (weekday) {
        case 1:
            factWeekDay = 7  ;
            break;
        case 2:
            factWeekDay = 1  ;
            break;
        case 3:
            factWeekDay = 2  ;
            break;
        case 4:
            factWeekDay = 3  ;
            break;
        case 5:
            factWeekDay = 4  ;
            break;
        case 6:
            factWeekDay = 5  ;
            break;
        case 7:
            factWeekDay = 6  ;
            break;
        default:
            break;
    }
    
    return  factWeekDay;
}











版权声明：本文为博主原创文章，未经博主允许不得转载。

mac svn 访问 windows svn server 证书问题解决方法
在mac上打开 终端 ，输入svn ls  +svn地址后回车，例如：svn ls https://192.168.0.105/svn/toge

Error validating server certificate for 'https://192.168.0.105:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
 - The certificate hostname does not match.
Certificate information:
 - Hostname: toge001-PC
 - Valid: from Mon, 27 Jul 2015 10:18:07 GMT until Thu, 24 Jul 2025 10:18:07 GMT
 - Issuer: toge001-PC
 - Fingerprint: 9b:ef:41:e2:1e:3d:6b:4c:84:4c:0f:d9:c3:22:56:bc:b9:92:5b:b0
(R)eject, accept (t)emporarily or accept (p)ermanently?


然后，输入p 回车。即可


另一个问题：
更改svn服务器URL
android studio -> vcs -> Subversion ->Relocate 
可以更改项目地址，如图下所示：



 







版权声明：本文为博主原创文章，未经博主允许不得转载。

【读书笔记】iOS-读取文本文件

一，文本文件的内容。



 

二，工程目录

 



 

三，ViewController.m


- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.
    //读取文本文件
    [self readFromText];
}
#pragma -mark -functions
//读取文本文件
-(void)readFromText
{
    NSError *error;
    NSString *textFieldContents=[NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"chenlihua" ofType:@"txt"] encoding:NSUTF8StringEncoding error:&error];
    NSLog(@"--textFieldContents---%@-----",textFieldContents);
    if (textFieldContents==nil) {
        NSLog(@"---error--%@",[error localizedDescription]);
    }
    NSArray *lines=[textFieldContents componentsSeparatedByString:@"\n"];
    NSLog(@"number of lines in the file:%ld",[lines count]);
}



 

四，输出如下图所示：

 


2015-07-29 22:12:32.692 读取文本文件[1362:70871] --textFieldContents---1
2
3
4
5
6
7
8
9
-----
2015-07-29 22:12:32.692 读取文本文件[1362:70871] number of lines in the file:10
2015-07-29 22:16:09.573 读取文本文件[1362:73057] Terminating since there is no system app.



 

参考资料：《iOS数据库应用高级编程（第2版）》



版权声明：本文为博主原创文章，未经博主允许不得转载。

Android批量上传文件


版权声明：本文为博主原创文章，未经博主允许不得转载。

Android基础入门教程——2.3.12 Date & Time组件(下)
Android基础入门教程——2.3.12 Date & Time组件(下)
标签（空格分隔）： Android基础入门教程

本节引言：

本节我们来继续学习Android系统给我们提供的几个原生的Date & Time组件，他们分别是： 
  DatePicker(日期选择器)，TimePicker(时间选择器)，CalendarView(日期视图)，好吧， 
  其实一开始让我扣这几个玩意我是拒绝的，因为在我的印象里，他们是这样的：

简直把我丑哭了，有木有，终于知道为什么那么多人喜欢自定义这种类型的控件了！但是毕竟 
  提纲上写了，自己写的提纲，含着泪也要把他写完…当我把DatePicker写到布局中，然后看下 
  预览图，哟：

原来，看起来还不错，心情大好，哈哈，那么开始本节内容！


1.DatePicker(日期选择器)
可供我们使用的属性如下：


android:calendarTextColor ： 日历列表的文本的颜色
android:calendarViewShown：是否显示日历视图
android:datePickerMode：组件外观，可选值:spinner，calendar 
  前者效果如下，默认效果是后者 

android:dayOfWeekBackground：顶部星期几的背景颜色
android:dayOfWeekTextAppearance：顶部星期几的文字颜色
android:endYear：去年(内容)比如2010
android:firstDayOfWeek：设置日历列表以星期几开头
android:headerBackground：整个头部的背景颜色
android:headerDayOfMonthTextAppearance：头部日期字体的颜色
android:headerMonthTextAppearance：头部月份的字体颜色
android:headerYearTextAppearance：头部年的字体颜色
android:maxDate：最大日期显示在这个日历视图mm / dd / yyyy格式
android:maxDate：最小日期显示在这个日历视图mm / dd / yyyy格式
android:spinnersShown：是否显示spinner
android:startYear：设置第一年(内容)，比如19940年
android:yearListItemTextAppearance：列表的文本出现在列表中。
android:yearListSelectorColor：年列表选择的颜色


属性就是上面这些，你想怎么玩就怎么玩，接下来我们说下他的DatePicker的事件： 
DatePicker.OnDateChangedListener 
另外，奇怪的是，如果是上面这种mode为calendar的设置了事件并没有响应，看来上面这种 
只能选择完后获取对应的值了，如果你的mode未spinner的话，使用下述代码就可以完成事件监听：
实现代码如下:
public class MainActivity extends AppCompatActivity implements DatePicker.OnDateChangedListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        DatePicker dp_test = (DatePicker) findViewById(R.id.dp_test);
        Calendar calendar = Calendar.getInstance();
        int year=calendar.get(Calendar.YEAR);
        int monthOfYear=calendar.get(Calendar.MONTH);
        int dayOfMonth=calendar.get(Calendar.DAY_OF_MONTH);
        dp_test.init(year,monthOfYear,dayOfMonth,this);
    }

    @Override
    public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) {
        Toast.makeText(MainActivity.this,"您选择的日期是："+year+"年"+(monthOfYear+1)+"月"+dayOfMonth+"日!",Toast.LENGTH_SHORT).show();
    }
}
运行效果图：


2.TimePicker(时间选择器)

先来看看5.0的TimePicker长什么样：

样子还是蛮标致的哈，我们发现官方给我们提供的属性只有一个： 
android:timePickerMode：组件外观，同样可选值为:spinner和clock(默认) 
  前者是旧版本的TimePicker~ 
  而他对应的监听事件是：TimePicker.OnTimeChangedListener

下面来个代码示例：
public class MainActivity extends AppCompatActivity{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        TimePicker tp_test = (TimePicker) findViewById(R.id.tp_test);
        tp_test.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() {
            @Override
            public void onTimeChanged(TimePicker view, int hourOfDay, int minute) {
                Toast.makeText(MainActivity.this,"您选择的时间是："+hourOfDay+"时"+minute+"分!",Toast.LENGTH_SHORT).show();
            }
        });
    }

}
运行效果图： 
可惜的是，同样需要旧版本的TimePicker才会触发这个事件！


3.CalendarView(日历视图)

好的，一样是看看样子先：

嗯，好像变化不大，接下来我们简单的看下文档中给我们提供的属性：


android:firstDayOfWeek：设置一个星期的第一天
android:maxDate ：最大的日期显示在这个日历视图mm / dd / yyyy格式
android:minDate：最小的日期显示在这个日历视图mm / dd / yyyy格式
android:weekDayTextAppearance：工作日的文本出现在日历标题缩写

处理上面的还有其他，但是都是被弃用的… 
对应的日期改变事件是：CalendarView.OnDateChangeListener
示例代码：
public class MainActivity extends AppCompatActivity{
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        CalendarView cv_test = (CalendarView) findViewById(R.id.cv_test);
        cv_test.setOnDateChangeListener(new CalendarView.OnDateChangeListener() {
            @Override
            public void onSelectedDayChange(CalendarView view, int year, int month, int dayOfMonth) {
                Toast.makeText(MainActivity.this,"您选择的时间是："+ year + "年" + month + "月" + dayOfMonth + "日",Toast.LENGTH_SHORT).show();
            }
        });
    }
}
运行效果图：


本节小结：

好的，关于这三个控件的介绍就到这里，实际开发中这些控件我们一般都是自定义的， 
  在进阶系列我们会来自己写控件，敬请期待，谢谢~


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

迅为4412开发板Android4.0.3中串口应用程序的测试


精英版的测试方法
1）将Android串口应用的压缩包“serialtest.zip”解压后，得到文件夹“serialtest”，如下图：
 
2）进入解压出来的文件夹“serialtest\bin”，有已经编译好的串口的应用软件“serialtest.apk”。将这个应用软件安装到开发板，安装方法和手机应用的安装方法一模一样。



3）如下图，红色框中是后面要测试的串口CON2，将CON2和上位机的串口相连。



4）如下图，打开上位机的超级终端，设置对应的参数，如果有不清楚的地方，可以参考使用手册的附录一，在附录一中有详细的参数设置方法及其对应的参数值。



5）启动开发板，串口如上图所示，并没有数据输出。打开Android的串口应用软件后，出现如下图所示的操作界面。红色框中是输入输出命令，红色箭头所指的对话框可以显示输入输出的数据。
 
6）如下图，在串口应用中输入“12345678”，然后单击按钮“SEND”。
 
7）如下图，执行上一步的发送操作后，上位机收到了开发板发送过来的数据“12345678”。



8）然后，超级终端中输入数据“abcd”。如下图，因为超级终端并没有显示输入的功能，所以没有显示要发送的数据“abcd”，但是在发送数据的前，一定要确保有箭头所指的小图标。



9）然后，在Android的串口应用软件中，单击按钮“RECV”，如下图，接收成功。

 
全能版的测试方法
这里要测试的串口是CON2，CON2对应的串口是/dev/ttySAC3，它和GPS复用，如果使用CON2，需要把电阻R161和R162去掉，把电阻R20和R21焊上（0欧的），电阻R50也要焊上（0欧的）。
1）将Android的串口应用压缩包“serialtest.zip”解压后，得到文件夹“serialtest”，如下图：


 
2）进入解压出来的文件夹“serialtest\bin”，里面有文件串口的应用软件“serialtest.apk”
将这个应用软件安装到开发板。安装方法和手机安装应用一模一样。



3）如下图，红色框中是后面要测试的串口CON2，将CON2和上位机的串口相连。



4）如下图，打开上位机的超级终端，设置对应的参数，如果有不清楚的地方，可以参考使用手册的附录一，在附录一中有详细的参数设置方法及其对应的参数值。



5）启动开发板，串口如上图所示，并没有数据输出。打开Android的串口应用软件后，出现如下图所示的操作界面。红色框中是输入输出命令，红色箭头所指的对话框可以显示输入输出的数据。
 
6）如下图，在串口应用中输入“12345678”，然后单击按钮“SEND”。
 
7）如下图，执行上一步的发送操作后，上位机收到了开发板发送过来的数据“12345678”。



8）然后，超级终端中输入数据“abcd”。如下图，因为超级终端并没有显示输入的功能，所以没有显示要发送的数据“abcd”，但是在发送数据的前，一定要确保有箭头所指的小图标。



9）然后，在Android的串口应用软件中，单击按钮“RECV”，如下图，接收成功。



串口应用移植需要注意
下面给大家介绍一下在Android操作系统中串口的移植需要注意的几个方面：
1）系统启动后，在超级终端中输入命令"#ls dev/tty*",如下图，红色方框中就是开发板的四个串口设备节点，这个测试程序中使用的是“/dev/ttySAC2”。



2）如果想使用别的串口，则需要修改Android串口应用的源码。打开应用的源码文件夹“serialtest\src\com\topeet\serialtest”的文件“MainActivity.java”，搜索“com3.Open”，这里使用的串口设备节点是“/dev/ttySAC3”，对应的是CON2接口。如果需要使用别的串口，则需要根据实际情况，修改代码。



3）打开文件夹“serialtest\jni”中的文件“com_topeet_serialtest_serial.c”，如下图，找到函数“JNIEXPORT jint JNICALL Java_com_topeet_serialtest_serial_Open”。在“#if 1”
到“#endif”中的代码，有需要设置的参数，这些参数都是通用的，可以直接根据需要设置。不过在这个例程中，除了波特率，其它都是缺省状态。

 





版权声明：本文为博主原创文章，未经博主允许不得转载。

Android大图加载优化--基于LRU算法的本地文件缓存
前言
在博客：Android大图加载内存优化（如何防止OutOfMemmory）中讲解了在加载图片的时候内存不完全加载原图或预估图片的大小，加载合适的尺寸的图片防止OOM。接下来讲解图片文件的本地缓存，网络图片必须经过本地缓存，才能提高资源的访问速度，内存的缓存必须配合SDCard的缓存，才能发挥它的优势。本文采用的是LRU本地缓存策略，由于本文侧重的是文件的缓存，所以没有引入内存的缓存，也没有发挥出前一篇博客降到的图片加载优势，不过在后续的博客中我将不断完善整个项目，带领大家一起揭秘第三方图片加载库。
LRU算法
在图片的加载中，还有一个重要的步骤，是网络图片的本地缓存，很多时候不知道缓存的图片不知道何时删除，这时候需要一个合理的本地图片缓存策略，保证图片文件不会无限制的占用存储空间导致存储空间不足，造成资源的浪费。在计算机操作系统里边对任务的调度引入了LRU算法 。通俗的讲就是把就是把最长时间内未使用的资源优先级放到最低，优先保证使用频率高的资源。
图片本地缓存核心代码
增加一个配置类，可以根据这个类配置图片文件的缓存位置，大小等参数，后续可能需要的配置都要在这个里边扩展。
/**
 * Created by CJstar on 15/8/24.
 */
public final class FileCacheOptions {
    /**
     * the file cache root path
     */
    private String cacheRootPath;
    /**
     * file cache count
     */
    private int maxFileCount;
    /**
     * file cache max size: byte
     */
    private int maxCacheSize;
    /**
     * if it is false, will not cache files
     */
    private boolean isUseFileCache = true;

    public String getCacheRootPath() {
        return cacheRootPath;
    }

    public void setCacheRootPath(String cacheRootPath) {
        this.cacheRootPath = cacheRootPath;
    }

    public int getMaxFileCount() {
        return maxFileCount;
    }

    public void setMaxFileCount(int maxFileCount) {
        this.maxFileCount = maxFileCount;
    }

    /**
     * cache size in bytes
     * @return
     */
    public int getMaxCacheSize() {
        return maxCacheSize;
    }

    public void setMaxCacheSize(int maxCacheSize) {
        this.maxCacheSize = maxCacheSize;
    }

    public boolean isUseFileCache() {
        return isUseFileCache;
    }

    public void setIsUseFileCache(boolean isUseFileCache) {
        this.isUseFileCache = isUseFileCache;
    }

    private FileCacheOptions(Builder builder){
        setCacheRootPath(builder.getCacheRootPath());
        setIsUseFileCache(builder.isUseFileCache());
        setMaxCacheSize(builder.getMaxCacheSize());
        setMaxFileCount(builder.getMaxFileCount());
    }

    /**
     * This is the options set builder, we can create the options by this method
     */
    public static class Builder{
        private String cacheRootPath;
        private int maxFileCount;
        private int maxCacheSize;
        private boolean isUseFileCache;

        public Builder(){
        }

        public String getCacheRootPath() {
            return cacheRootPath;
        }

        public Builder setCacheRootPath(String cacheRootPath) {
            this.cacheRootPath = cacheRootPath;
            return this;
        }

        public int getMaxFileCount() {
            return maxFileCount;
        }

        public Builder setMaxFileCount(int maxFileCount) {
            this.maxFileCount = maxFileCount;
            return this;
        }

        public int getMaxCacheSize() {
            return maxCacheSize;
        }

        public Builder setMaxCacheSize(int maxCacheSize) {
            this.maxCacheSize = maxCacheSize;
            return this;
        }

        public boolean isUseFileCache() {
            return isUseFileCache;
        }

        public Builder setIsUseFileCache(boolean isUseFileCache) {
            this.isUseFileCache = isUseFileCache;
            return this;
        }

        public FileCacheOptions builder(){
            return new FileCacheOptions(this);
        }
    }
}
接着就是核心的处理类：
/**
 * Created by CJstar on 15/8/24.
 */
public class LRUFileCache implements FileCache {

    /**
     * cache config
     */
    private FileCacheOptions options;
    /**
     * cache file suffix
     */
    private static final String WHOLESALE_CONV = ".cach";
    /**
     * mini free space on SDCard
     */
    private static final int FREE_SD_SPACE_NEEDED_TO_CACHE = 10*1024*1024;

    private static LRUFileCache mLRUFileCache;

    public static LRUFileCache getInstance(){
        if(mLRUFileCache==null){
            synchronized (LRUFileCache.class){
                if(mLRUFileCache==null){
                    mLRUFileCache = new LRUFileCache();
                }
            }
        }

        return mLRUFileCache;
    }

    public void setFileLoadOptions(FileCacheOptions options) {
        this.options = options;
    }

    /**
     * use default options
     */
    private LRUFileCache() {
        this.options = new FileCacheOptions.Builder()
                .setCacheRootPath("FileCache")
                .setIsUseFileCache(true)
                .setMaxCacheSize(10 * 1024 * 1024)//10MB
                .setMaxFileCount(100)
                .builder();
    }

    @Override
    public void addDiskFile(String key, InputStream inputStream) {
        if (TextUtils.isEmpty(key) || inputStream == null) {
            return;
        }

        String filename = convertUrlToFileName(key);
        String dir = options.getCacheRootPath();
        File dirFile = new File(dir);
        if (!dirFile.exists())
            dirFile.mkdirs();
        File file = new File(dir + "/" + filename);
        OutputStream outStream;
        try {
            if(file.exists()){
                file.delete();
            }
            
            file.createNewFile();
            outStream = new FileOutputStream(file);
            while (inputStream.available()!=0){
                outStream.write(inputStream.read());
            }
            outStream.flush();
            outStream.close();
            inputStream.close();
        } catch (Throwable e) {
            Log.w("LRUFileCache", e.getMessage());
        }

        // free the space at every time to add a new file
        freeSpaceIfNeeded();
    }

    @Override
    public File getDiskFile(String key) {
        File file = new File(getFilePathByKey(key));

        if(file!=null&&file.exists()){
            updateFileTime(file);

        }else{
            file = null;
        }

        return file;
    }

    @Override
    public boolean isExist(String key) {
        if (URLUtil.isNetworkUrl(key)) {
            return new File(options.getCacheRootPath() + "/" + convertUrlToFileName(key)).exists();

        } else if (URLUtil.isFileUrl(key)) {
            return new File(key).exists();

        } else {
            return false;
        }
    }

    @Override
    public void removeDiskFile(String key) {
        File file = getDiskFile(key);
        if (file != null &&file.exists()) {
            file.delete();
        }
    }

    @Override
    public void removeAllDiskFiles() {
        new File(options.getCacheRootPath()).delete();
    }

    /**
     * This method will free the files which had not been used at a long time
     */
    private void freeSpaceIfNeeded(){
        File dir = new File(options.getCacheRootPath());
        File[] files = dir.listFiles();
        if(files==null){
            return;
        }

        int dirSize = 0;
        for (int i = 0; i < files.length; i++) {
            if (files[i].getName().contains(WHOLESALE_CONV)) {
                dirSize += files[i].length();
            }
        }
        // if the dir size larger than max size or the free space on SDCard is less than 10MB
        //free 40% space for system
        if (dirSize > options.getMaxCacheSize()
                || FREE_SD_SPACE_NEEDED_TO_CACHE > freeSpaceOnSd()) {
            // delete 40% files by LRU
            int removeFactor = (int) ((0.4 * files.length) + 1);
            // sort the files by modify time
            Arrays.sort(files, new FileLastModifSort());
            // delete files
            for (int i = 0; i < removeFactor; i++) {
                if (files[i].getName().contains(WHOLESALE_CONV)) {
                    files[i].delete();
                }
            }
        }

        //if file count is larger than max count, delete the last
        if(files.length>options.getMaxFileCount()){
            Arrays.sort(files, new FileLastModifSort());
            // delete files
            for (int i = options.getMaxFileCount(); i < files.length; i++) {
                if (files[i].getName().contains(WHOLESALE_CONV)) {
                    files[i].delete();
                }
            }
        }
    }

    /**
     * Modify the file time
     *
     * @param file the file which need to update time
     */
    public void updateFileTime(File file) {
        if(file!=null&&file.exists()){
            long newModifiedTime = System.currentTimeMillis();
            file.setLastModified(newModifiedTime);
        }
    }

    /**
     * get the free space on SDCard
     *
     * @return free size in MB
     */
    private int freeSpaceOnSd() {
        StatFs stat = new StatFs(Environment.getExternalStorageDirectory()
                .getPath());
        double sdFreeMB = ((double) stat.getAvailableBlocks() * (double) stat
                .getBlockSize());
        return (int) sdFreeMB;
    }

    /**
     * Get the file name by file url
     *
     * @param url
     * @return file name
     */
    private String convertUrlToFileName(String url) {
        String[] strs = url.split("/");
        return strs[strs.length - 1] + WHOLESALE_CONV;
    }

    public String getFilePathByKey(String key){
        if(URLUtil.isFileUrl(key)){
            return key;

        }else if(URLUtil.isNetworkUrl(key)){
            return options.getCacheRootPath()+"/"+convertUrlToFileName(key);

        }else {
            return null;
        }
    }

    /**
     * The comparator for the file modify, sort the files by modify time.
     */
    private class FileLastModifSort implements Comparator<File> {
        public int compare(File arg0, File arg1) {
            if (arg0.lastModified() > arg1.lastModified()) {
                return 1;
            } else if (arg0.lastModified() == arg1.lastModified()) {
                return 0;
            } else {
                return -1;
            }
        }
    }
}
完整的代码地址是:https://github.com/CJstar/Android-ImageFileCache


接下来将讲解MemmoryCache，也是采用LRU算法实现的缓存，不过它比文件缓存复杂一点。

版权声明：本文为博主原创文章，未经博主允许不得转载。

软工文档（GB8567--88）
一.简介

软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。

软工中主要的六阶段：制定计划，需求分析和定义，软件设计，软件程序编写，软件测试，运行和维护。这也就是软件开发所要经历的一个过程。文档在这六个阶段中起着连线的作用。这些文档记录了开发过程中的开发轨迹，是开发人员工作的依据，也是用户运行新系统，维护新系统的依据。在这中需要注意的是有些文档不是在一个阶段完成的，而是分布在好几个阶段进行分步完善的。

我们使用的都是软件设计文档国家标准版（GB8567--88），其中分有：01可行性研究报告，02项目开发计划，03软件需求说明书，04概要设计说明书，05详细设计说明书，06数据库设计说明书，07数据要求说明书，08测试计划，09测试分析报告，10项目开发总结报告，11操作手册，12用户手册，13开发进度月报。共13个。
二.各个文档的作用


1.可行性研究报告：说明该软件开发项目的实现在技术上、经济上和社会因素上的可行性，评述为了合理地达到开发目标可供选择的各种可能实施的方案，说明并论证所选定实施方案的理由。

2.项目开发计划：为软件项目实施方案制定出具体计划，应该包括各部分工作的负责人员、开发的进度、开发经费的预算、所需的硬件及软件资源等。项目开发计划应提供给管理部门，并作
为开发阶段评审的参考。

3.软件需求说明书：也称软件规格说明书，其中对所开发软件的功能、性能、用户界面及运行环境等作出详细的说明。它是用户与开发人员双方对软件需求取得共同理解基础上达成的协议，也是实施开发工作的基础。

4.
数据要求说明书：该说明书应给出数据逻辑描述和数据采
集的各项要求，为生成和维护
系统数据文卷作好准备。
5.数据库设计说明书是对于设计中的数据库的所有标识．逻辑结构和物理结构做出具体的设计规定。

6.概要设计说明书：该说明书是概要设计阶段的工作成果，它应说明功能分配、模块划分、程序的总体结构、输入输出以及接口设计、运行设计、数据结构设计和出错处理设计等，为详细设计奠定基础。

7.详细设计说明书：着重描述每一模块是怎样实现的，包括实现算法、逻辑流程等。

8.测试计划：为做好组装测试和确认测试，需为如何组织测试制定实施计划。计划应包括测试的内容、进度、条件、人员、测试用例的选取原则、测试结果允许的偏差范围等。

9.测试分析报告：测试工作完成以后，应提交测试计划执行
情况的说明。对测试结果加以分析，并提出测试的结论意见。

10.开发进度月报：该月报系软件人员按月向管理部门提交的
项目进展情况报告。报告应包括进度计划与实际执行情况的比较、阶段成果、遇到的问题和解决的办法以及下个月的打算等。

11.项目开发总结报告：软件项目开发完成以后，应与项目实
施计划对照，总结实际执行的情况，如进度、成果、资源利用、成本和投入的人力。此外还需对开发工作作出评价，总结出经验和教训。

12.用户手册：本手册详细
描述软件的功能、性能和用户
界面，使用户了解如何使用该软件。

13.操作手册：本手册为操作人员提供该软件各种运行情况的有关知识，特别是操作方法的具体细节。



三.六阶段中的文档
接下来，我通过软工的六个阶段来分别介绍一下，这些文档是什么时候写的，是谁写的，是写给谁看的。
1.制定计划


2.需求分析和定义

3.软件设计



4.软件程序编写

5.软件测试

6.运行和维护

四.总体文档
分类的思路

总体的（单机可放大）





版权声明：本文为博主原创文章，未经博主允许不得转载。 如有不对，还请指教。

优秀博客1

http://blog.csdn.net/u013357243?viewmode=contents
    
iOS开发_UIWebView UIActivityIndicatorView


一UIWebView
使用UIWebView的步骤
UIWebView的三种加载方式
UIWebViewDelegate


二UIActivityIndicatorView
三简单浏览器功能的实现



一、UIWebView
UIWebView是可以在应用中嵌入网页内容的类。我们可以使用它来实现网页浏览、超链接、加载本地HTML文件等功能。本博文最后将使用UIWebView实现简单的浏览器功能。
Class：UIWebView
Inheritance: NSObject -> UIResponder -> UIView -> UIWebView
Delegate：UIWebViewDelegate

API中UIWebView的原文描述 
  You use the UIWebView class to embed web content in your application. To do so, you simply create a UIWebView object, attach it to a window, and send it a request to load web content. You can also use this class to move back and forward in the history of webpages, and you can even set some web content properties programmatically.

使用UIWebView的步骤
1.创建UIWebView对象
// 创建UIWebView
    UIWebView *webView = [[UIWebView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
2.设置相关属性
// 自动对页面进行缩放以适应屏幕
    webView.scalesPageToFit = YES;
3.将UIWebView对象添加至视图
    [self.view addSubview:webView];
4.加载内容
    // 创建URL
    NSURL *url = [NSURL URLWithString:@"http://www.baidu.com"];
    // 创建URL请求
    NSURLRequest *urlRequest = [NSURLRequest requestWithURL:url];
    // 开始连接到给定的URL地址
    [webView loadRequest:urlRequest];
UIWebView的三种加载方式

API 提供了UIWebView三种加载方式 
  1. - (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)encodingName baseURL:(NSURL *)baseURL 
  2. - (void)loadHTMLString:(NSString *)string baseURL:(NSURL *)baseURL 
  3. - (void)loadRequest:(NSURLRequest *)request

1、直接给出URL地址加载网页
    NSString *path = @"http://www.baidu.com";
    NSURL *url = [[NSURL alloc] initWithString:path];
    [webView loadRequest:[NSURLRequest requestWithURL:url]];
2、将本地html文件内容嵌入web页面
    NSString *resourcePath = [[NSBundle mainBundle] resourcePath];
    NSString *filePath  = [resourcePath stringByAppendingPathComponent:@"test.html"];
    NSString *htmlstring =[[NSString alloc] initWithContentsOfFile:filePath
                                                          encoding:NSUTF8StringEncoding error:nil];
    [webView loadHTMLString:htmlstring
                    baseURL:[NSURL fileURLWithPath: [[NSBundle mainBundle]  bundlePath]]];
如果不通过html文件载入，也可以给定html代码字符串载入页面
    NSString *HTMLData = @"<img src=\"test2.png\" />图片";
    [webView loadHTMLString:HTMLData
                    baseURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] bundlePath]]];
3.与第二种类似，只是更详细的给出了网页的编码方式。
UIWebViewDelegate
UIWebViewDelegate定义了一些方法，可以在网页被加载的特定时候进行干预。如要使用这些方法必须签订协议，指定代理人，才可以实代理方法。
/* 网页视图请求加载失败时调用。提供NSSError对象，标识所发生错误类型。*/
-(void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error

/* 网页视图加载结束调用 */
- (void)webViewDidFinishLoad:(UIWebView *)webView

/* 网页视图开始加载调用 */
- (void)webViewDidStartLoad:(UIWebView *)webView

二、UIActivityIndicatorView
活动指示器（俗称：小菊花）用来显示一个任务正在进行中，外观是一个要么正在旋转，要么停止的齿轮。主要应用是耗时操作的提示，比如网络请求。
Class：UIActivityIndicatorView
Inheritance: NSObject -> UIResponder -> UIView -> UIActivityIndicatorView
该类使用简单，在此仅给出其SDK中的声明供参考。
NS_CLASS_AVAILABLE_IOS(2_0) @interface UIActivityIndicatorView : UIView <NSCoding>
{ 
  @package
    CFTimeInterval               _duration;
    BOOL                         _animating;
    UIActivityIndicatorViewStyle _activityIndicatorViewStyle;
    UIActivityIndicatorViewStyle _actualActivityIndicatorViewStyle;
    BOOL                         _hidesWhenStopped;
}

- (instancetype)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style;     // sizes the view according to the style

@property(nonatomic) UIActivityIndicatorViewStyle activityIndicatorViewStyle; // default is UIActivityIndicatorViewStyleWhite
@property(nonatomic) BOOL                         hidesWhenStopped;           // default is YES. calls -setHidden when animating gets set to NO

@property (readwrite, nonatomic, retain) UIColor *color NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;

- (void)startAnimating;
- (void)stopAnimating;
- (BOOL)isAnimating;
@end
需要注意的属性：hidesWhenStopped，小齿轮停止后是否隐藏，为了与用户保持良好的交互，一般保持默认值YES，即齿轮停止的时候隐藏。

三、简单浏览器功能的实现
使用UIWebView和UIActivityIndicatorView可以实现简单的浏览器功能，即在窗口最上部使用文本框接受输入的URL地址，点击按钮跳转到指定的网页。下面的示例提供了实现此功能的核心代码，并且进行了简单的封装。
解决思路：UITextField对象接受URL地址，点击UIButton对象触发事件，在该事件中通过tag值找到UITextField对象，同时辞去第一响应者，调用封装后的加载网页方法。为提高交互效果，需要使用UITextFieldDelegate和UIWebViewDelegate两个协议，使用UIActivityIndicatorView进行耗时的提示。

具体实现的核心代码如下：
// 加载网页视图的方法
- (void)loadWebPageWithString:(NSString *)urlString
{
    urlString = [NSString stringWithFormat:@"http://%@", urlString];
    NSLog(@"%@", urlString);
    NSURL *url = [NSURL URLWithString:urlString];
    NSURLRequest *request = [NSURLRequest requestWithURL:url];
    [_webView loadRequest:request];
}
// 使用的协议
- (void)webViewDidStartLoad:(UIWebView *)webView
{
    NSLog(@"开始加载");

    UIView *backgroundView = [[UIView alloc] initWithFrame:CGRectMake(_webView.frame.origin.x, _webView.frame.origin.y, _webView.frame.size.width, _webView.frame.size.height)];
    backgroundView.tag = 1004;
    backgroundView.backgroundColor = [UIColor blackColor];
    backgroundView.alpha = 0.3;
    [self.view addSubview:backgroundView];

    _activityIndicator = [[UIActivityIndicatorView alloc] initWithFrame:CGRectMake(_webView.frame.origin.x, _webView.frame.origin.y, _webView.frame.size.width, _webView.frame.size.height)];
    _activityIndicator.center = CGPointMake(_webView.frame.size.width / 2, _webView.frame.size.height / 2);
    _activityIndicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyleWhiteLarge;
    [backgroundView addSubview:_activityIndicator];

    [_activityIndicator startAnimating];
}

- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    NSLog(@"结束加载");

    [_activityIndicator stopAnimating];
    UIView *backgroundView = (UIView *)[self.view viewWithTag:1004];
    [backgroundView removeFromSuperview];
}

- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error
{
    NSLog(@"加载错误");

    [_activityIndicator stopAnimating];
    UIView *backgroundView = (UIView *)[self.view viewWithTag:1004];
    [backgroundView removeFromSuperview];

    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"通知" message:@"加载失败" delegate:self cancelButtonTitle:@"取消" otherButtonTitles:nil, nil];
    alertView.frame = CGRectMake(30, 150, self.view.frame.size.width - 60, 150);
    [alertView show];
    [alertView release];
}


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

XML的解析
 

XML的解析


分类： JavaWeb Java Android2014-02-17
 18:22 1703人阅读 评论(3) 收藏 举报


上一篇说到了xml的约束，这一篇就来说一下xml的解析吧，其实xml的解析很简单的，因为人家都为我们写好了接口，我只需简单的调用就行了，所以这里没有什么难点，首先来了解一下现在的xml的解析方式吧：




解析XML的方法越来越多，但主流的方法也就四种，即：DOM、SAX、JDOM、DOM4J和PULL

下面首先给出这四种方法的jar包下载地址

DOM：在现在的Java JDK里都自带了，在xml-apis.jar包里

SAX：http://sourceforge.net/projects/sax/

JDOM：http://jdom.org/downloads/index.html

DOM4J：http://sourceforge.net/projects/dom4j/

PULL：http://download.csdn.net/detail/hjw541988478/6808313


 

一、介绍及优缺点分析
1. DOM（Document Object Model)
      DOM是用与平台和语言无关的方式表示XML文档的官方W3C标准。DOM是以层次结构组织的节点或信息片断的集合。这个层次结构允许开发人员在树中寻找特定信息。分析该结构通常需要加载整个文档和构造层次结构，然后才能做任何工作。由于它是基于信息层次的，因而DOM被认为是基于树或基于对象的。
【优点】
      ①允许应用程序对数据和结构做出更改。
      ②访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的数据（增删改查的操作比较容易）。
【缺点】
      ①通常需要加载整个XML文档来构造层次结构，需要将整个xml文档先拷贝到内存中，如果xml文件较大的话，消耗资源是很大
        的，这个对于Android来说真是个噩梦呀，因为有OOM的恐惧！。
    
2. SAX（Simple API for XML)
     SAX处理的优点非常类似于流媒体的优点。分析能够立即开始，而不是等待所有的数据被处理。而且，由于应用程序只是在读取数据时检查数据，因此不需要将数据存储在内存中。这对于大型文档来说是个巨大的优点。事实上，应用程序甚至不必解析整个文档；它可以在某个条件得到满足时停止解析。一般来说，SAX还比它的替代者DOM快许多。
     选择DOM还是选择SAX？ 对于需要自己编写代码来处理XML文档的开发人员来说， 选择DOM还是SAX解析模型是一个非常重要的设计决策。 DOM采用建立树形结构的方式访问XML文档，而SAX采用的是事件模型。
     DOM解析器把XML文档转化为一个包含其内容的树，并可以对树进行遍历。用DOM解析模型的优点是编程容易，开发人员只需要调用建树的指令，然后利用navigation APIs访问所需的树节点来完成任务。可以很容易的添加和修改树中的元素。然而由于使用DOM解析器的时候需要处理整个XML文档，所以对性能和内存的要求比较高，尤其是遇到很大的XML文件的时候。由于它的遍历能力，DOM解析器常用于XML文档需要频繁的改变的服务中。
     SAX解析器采用了基于事件的模型，它在解析XML文档的时候可以触发一系列的事件，当发现给定的tag的时候，它可以激活一个回调方法，告诉该方法制定的标签已经找到。SAX对内存的要求通常会比较低，因为它让开发人员自己来决定所要处理的tag.特别是当开发人员只需要处理文档中所包含的部分数据时，SAX这种扩展能力得到了更好的体现。但用SAX解析器的时候编码工作会比较困难，而且很难同时访问同一个文档中的多处不同数据。
【优势】
     ①不需要等待所有数据都被处理，分析就能立即开始。
     ②只在读取数据时检查数据，不需要保存在内存中。
     ③可以在某个条件得到满足时停止解析，不必解析整个文档。
     ④效率和性能较高，能解析大于系统内存的文档。
【缺点】
     ①需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等），文档越复杂程序就越复杂。
     ②单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，不支持XPath。
  
 3. JDOM(Java-based Document Object Model)
     JDOM的目的是成为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。由于是第一个Java特定模型，JDOM一直得到大力推广和促进。正在考虑通过“Java规范请求JSR-102”将它最终用作“Java标准扩展”。从2000年初就已经开始了JDOM开发。
     JDOM与DOM主要有两方面不同。首先，JDOM仅使用具体类而不使用接口。这在某些方面简化了API，但是也限制了灵活性。第二，API大量使用了Collections类，简化了那些已经熟悉这些类的Java开发者的使用。
     JDOM文档声明其目的是“使用20%（或更少）的精力解决80%（或更多）Java/XML问题”（根据学习曲线假定为20%）。JDOM对于大多数Java/XML应用程序来说当然是有用的，并且大多数开发者发现API比DOM容易理解得多。JDOM还包括对程序行为的相当广泛检查以防止用户做任何在XML中无意义的事。然而，它仍需要您充分理解XML以便做一些超出基本的工作（或者甚至理解某些情况下的错误）。这也许是比学习DOM或JDOM接口都更有意义的工作。
     JDOM自身不包含解析器。它通常使用SAX2解析器来解析和验证输入XML文档（尽管它还可以将以前构造的DOM表示作为输入）。它包含一些转换器以将JDOM表示输出成SAX2事件流、DOM模型或XML文本文档。JDOM是在Apache许可证变体下发布的开放源码。
【优点】
     ①使用具体类而不是接口，简化了DOM的API。
     ②大量使用了Java集合类，方便了Java开发人员。
【缺点】
     ①没有较好的灵活性。
     ②性能较差。
4. DOM4J(Document Object Model for Java)
      虽然DOM4J代表了完全独立的开发结果，但最初，它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项，它通过DOM4J API和标准DOM接口具有并行访问功能。从2000下半年开始，它就一直处于开发之中。
      为支持所有这些功能，DOM4J使用接口和抽象基本类方法。DOM4J大量使用了API中的Collections类，但是在许多情况下，它还提供一些替代方法以允许更好的性能或更直接的编码方法。直接好处是，虽然DOM4J付出了更复杂的API的代价，但是它提供了比JDOM大得多的灵活性。
      在添加灵活性、XPath集成和对大文档处理的目标时，DOM4J的目标与JDOM是一样的：针对Java开发者的易用性和直观操作。它还致力于成为比JDOM更完整的解决方案，实现在本质上处理所有Java/XML问题的目标。在完成该目标时，它比JDOM更少强调防止不正确的应用程序行为。
      DOM4J是一个非常非常优秀的Java XML API，具有性能优异、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读写XML，特别值得一提的是连Sun的JAXM也在用DOM4J.
【优点】
     ①大量使用了Java集合类，方便Java开发人员，同时提供一些提高性能的替代方法。
     ②支持XPath。
     ③有很好的性能。
【缺点】
     ①大量使用了接口，API较为复杂。


5. PULL

PULL解析XML是在Android中用到的比较多，而且Android已经将PULL技术集成到了系统中，所以在使用PULL的时候不需要额外的引入到jar,Android中要是使用上述的四种方式，需要引入额外的jar,当然JavaEE中使用PULL技术进行解析的话，就需要引入PULL所需的jar了，其实PULL技术和SAX技术差不多，Pull解析器和SAX解析器虽有区别但也有相似性。他们的区别为：SAX解析器的工作方式是自动将事件推入注册的事件处理器进行处理，因此你不能控制事件的处理主动结束；而Pull解析器的工作方式为允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。这是他们主要的区别。
而他们的相似性在运行方式上，Pull解析器也提供了类似SAX的事件，开始文档START_DOCUMENT和结束文档END_DOCUMENT，开始元素START_TAG和结束元素END_TAG，遇到元素内容TEXT等，但需要调用next() 方法提取它们（主动提取事件）。
Android系统中和Pull方式相关的包为org.xmlpull.v1，在这个包中提供了Pull解析器的工厂类XmlPullParserFactory和Pull解析器XmlPullParser，XmlPullParserFactory实例调用newPullParser方法创建XmlPullParser解析器实例，接着XmlPullParser实例就可以调用getEventType()和next()等方法依次主动提取事件，并根据提取的事件类型进行相应的逻辑处理。
 
二、比较
     1. DOM4J性能最好，连Sun的JAXM也在用DOM4J。目前许多开源项目中大量采用DOM4J，例如大名鼎鼎的Hibernate也用DOM4J来读取XML配置文件。如果不考虑可移植性，那就采用DOM4J.
     2. JDOM和DOM在性能测试时表现不佳，在测试10M文档时内存溢出，但可移植。在小文档情况下还值得考虑使用DOM和JDOM.虽然JDOM的开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来看，它确实没有值得推荐之处。另外，DOM仍是一个非常好的选择。DOM实现广泛应用于多种编程语言。它还是许多其它与XML相关的标准的基础，因为它正式获得W3C推荐（与基于非标准的Java模型相对），所以在某些类型的项目中可能也需要它（如在JavaScript中使用DOM）。
     3. SAX表现较好，这要依赖于它特定的解析方式－事件驱动。一个SAX检测即将到来的XML流，但并没有载入到内存（当然当XML流被读入时，会有部分文档暂时隐藏在内存中）。
     我的看法：如果XML文档较大且不考虑移植性问题建议采用DOM4J；如果XML文档较小则建议采用JDOM；如果需要及时处理而不需要保存数据则考虑SAX。但无论如何，还是那句话：适合自己的才是最好的，如果时间允许，建议大家讲这四种方法都尝试一遍然后选择一种适合自己的即可。


三、示例
为了节约篇幅，这里暂时不给出这四种建立XML文档的方法与差异，仅给出解析XML文档的代码，如果需要完整工程（建立XML文档+解析XML+测试比较），可去我的CSDN下载。
这里以下面的XML内容为例进行解析：
 



[html] view
 plaincopy






<?xml version="1.0" encoding="UTF-8"?>  
<users>  
    <user id="0">  
        <name>Alexia</name>  
        <age>23</age>  
        <sex>Female</sex>  
    </user>  
    <user id="1">  
        <name>Edward</name>  
        <age>24</age>  
        <sex>Male</sex>  
    </user>  
    <user id="2">  
        <name>wjm</name>  
        <age>23</age>  
        <sex>Female</sex>  
    </user>  
    <user id="3">  
        <name>wh</name>  
        <age>24</age>  
        <sex>Male</sex>  
    </user>  
</users>  



 
首先定义XML文档解析的接口：




[java] view
 plaincopy






/** 
 2  * @author Alexia 
 3  * 
 4  * 定义XML文档解析的接口 
 5  */  
 6 public interface XmlDocument {  
 7       
 8     /** 
 9      * 解析XML文档 
10      *  
11      * @param fileName 
12      *            文件全路径名称 
13      */  
14     public void parserXml(String fileName);  
15 }  



 
1. DOM示例




[java] view
 plaincopy






package com.xml;  
  
import java.io.FileNotFoundException;  
import java.io.FileOutputStream;  
import java.io.IOException;  
import java.io.PrintWriter;  
import javax.xml.parsers.DocumentBuilder;  
import javax.xml.parsers.DocumentBuilderFactory;  
import javax.xml.parsers.ParserConfigurationException;  
import javax.xml.transform.OutputKeys;  
import javax.xml.transform.Transformer;  
import javax.xml.transform.TransformerConfigurationException;  
import javax.xml.transform.TransformerException;  
import javax.xml.transform.TransformerFactory;  
import javax.xml.transform.dom.DOMSource;  
import javax.xml.transform.stream.StreamResult;  
import org.w3c.dom.Document;  
import org.w3c.dom.Element;  
import org.w3c.dom.Node;  
import org.w3c.dom.NodeList;  
import org.xml.sax.SAXException;  
  
/** 
 * @author Alexia 
 *  
 * DOM 解析XML文档 
 */  
public class DomDemo implements XmlDocument {  
    private Document document;  
  
    public void parserXml(String fileName) {  
        try {  
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();  
            DocumentBuilder db = dbf.newDocumentBuilder();  
            Document document = db.parse(fileName);  
            NodeList users = document.getChildNodes();  
              
            for (int i = 0; i < users.getLength(); i++) {  
                Node user = users.item(i);  
                NodeList userInfo = user.getChildNodes();  
                  
                for (int j = 0; j < userInfo.getLength(); j++) {  
                    Node node = userInfo.item(j);  
                    NodeList userMeta = node.getChildNodes();  
                      
                    for (int k = 0; k < userMeta.getLength(); k++) {  
                        if(userMeta.item(k).getNodeName() != "#text")  
                            System.out.println(userMeta.item(k).getNodeName()  
                                    + ":" + userMeta.item(k).getTextContent());  
                    }  
                      
                    System.out.println();  
                }  
            }  
              
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        } catch (ParserConfigurationException e) {  
            e.printStackTrace();  
        } catch (SAXException e) {  
            e.printStackTrace();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}  



 
2. SAX示例




[java] view
 plaincopy






package com.xml;  
  
import java.io.FileInputStream;  
import java.io.FileNotFoundException;  
import java.io.FileOutputStream;  
import java.io.IOException;  
import java.io.InputStream;  
import java.io.OutputStream;  
import java.io.StringWriter;  
  
import javax.xml.parsers.ParserConfigurationException;  
import javax.xml.parsers.SAXParser;  
import javax.xml.parsers.SAXParserFactory;  
import javax.xml.transform.OutputKeys;  
import javax.xml.transform.Result;  
import javax.xml.transform.Transformer;  
import javax.xml.transform.TransformerConfigurationException;  
import javax.xml.transform.sax.SAXTransformerFactory;  
import javax.xml.transform.sax.TransformerHandler;  
import javax.xml.transform.stream.StreamResult;  
  
import org.xml.sax.Attributes;  
import org.xml.sax.SAXException;  
import org.xml.sax.helpers.AttributesImpl;  
import org.xml.sax.helpers.DefaultHandler;  
  
/** 
 * @author Alexia 
 *  
 * SAX 解析XML文档 
 */  
public class SaxDemo implements XmlDocument {  
  
    public void parserXml(String fileName) {  
        SAXParserFactory saxfac = SAXParserFactory.newInstance();  
  
        try {  
            SAXParser saxparser = saxfac.newSAXParser();  
            InputStream is = new FileInputStream(fileName);  
            saxparser.parse(is, new MySAXHandler());  
        } catch (ParserConfigurationException e) {  
            e.printStackTrace();  
        } catch (SAXException e) {  
            e.printStackTrace();  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}  
  
class MySAXHandler extends DefaultHandler {  
    boolean hasAttribute = false;  
    Attributes attributes = null;  
  
    public void startDocument() throws SAXException {  
        // System.out.println("文档开始打印了");  
    }  
  
    public void endDocument() throws SAXException {  
        // System.out.println("文档打印结束了");  
    }  
  
    public void startElement(String uri, String localName, String qName,  
            Attributes attributes) throws SAXException {  
        if (qName.equals("users")) {  
            return;  
        }  
        if (qName.equals("user")) {  
            return;  
        }  
        if (attributes.getLength() > 0) {  
            this.attributes = attributes;  
            this.hasAttribute = true;  
        }  
    }  
  
    public void endElement(String uri, String localName, String qName)  
            throws SAXException {  
        ifiOS 多线程（三）NSOperation

NSOperation


NSOperation是苹果封装的一套多线程的东西，不像GCD是纯C语言的，这个是OC的。但相比较之下GCD会更快一些，但本质上NSOPeration是多GDC的封装。


NSOperation相对于GCD：

NSOperation拥有更多的函数可用NSOperationQueue中，可以建立各个NSOperation之间的依赖关系。NSOperationQueue支持KVO。可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）GCD 只支持FIFO 的队列，而NSOperationQueue可以调整队列的执行顺序


NSOperation剖析


NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类


使用NSOperation子类的方式有3种

NSInvocationOperationNSBlockOperation自定义子类继承NSOperation，实现内部相应的方法

NSOperationQueue


1.NSOperation可以调用start方法来执行任务，但默认是同步执行的
2.如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作
// 添加操作到NSOperationQueue中
- (void)addOperation:(NSOperation *)op;
- (void)addOperationWithBlock:(void (^)(void))block;



NSOperation的使用


配合使用NSOperation和NSOperationQueue就能实现多线程编程
具体步骤：
1.将需要执行的操作封装到一个NSOperation对象中
2.将NSOperation对象添加到NSOperationQueue中
3.系统会自动将NSOperationQueue中的NSOperation取出来放到一条新线程中执行


NSInvocationOperation子类
// 1.创建NSInvocationOperation对象
- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;

// 2.调用start方法开始执行操作
- (void)start;
// 一旦执行操作，就会调用target的sel方法

注意：

默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作

NSBlockOperation子类
// 1.创建NSBlockOperation对象
+ (id)blockOperationWithBlock:(void (^)(void))block;

// 2.通过addExecutionBlock:方法添加更多的操作
- (void)addExecutionBlock:(void (^)(void))block;

注意：

只要NSBlockOperation封装的操作数 > 1，就会异步执行操作

自定义NSOperation
// 1.创建对象继承NSOperation，重写
- (void)main；
// 在里面实现想执行的任务

注意：

自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过
- (BOOL)isCancelled

方法检测操作是否被取消，对取消做出响应。


NSOperation方法

一、最大并发数


可以通过对最大并发数设置，控制程序中线程的数量

// 1.最大并发数的相关方法
- (NSInteger)maxConcurrentOperationCount;
- (void)setMaxConcurrentOperationCount:(NSInteger)cnt;

二、取消、暂停、恢复
// 1.取消队列的所有操作
- (void)cancelAllOperations;
// 2.取消单个操作
- (void)cancel

// 暂停
- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列
// 恢复队列
- (BOOL)isSuspended;

三、依赖


NSOperation之间可以设置依赖来保证执行顺序

// 1.比如一定要让操作A执行完后，才能执行操作B，可以这么写
[operationB addDependency:operationA]; // 操作B依赖于操作A

注意：可以在不同queue的NSOperation之间创建依赖关系

四、操作的监听
// 1.可以监听一个操作的执行完毕
- (void (^)(void))completionBlock;
- (void)setCompletionBlock:(void (^)(void))block;


致谢

感谢您花时间阅读，期待与您的交流。

版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS的isnan函数
如果一个数是一个确定的数，那它就不是nan值
如果一个数是无穷大，无穷小，那它就是nan值
我试着打印了以下的值是不是nan值

if (isnan(1)) {
        DLog(@"1是NAN");
    }
    else {
        DLog(@"1不是NAN");
    }
    
    if (isnan(YES)) {
        DLog(@"yes是nan值");
    }
    else {
        DLog(@"yes不是NAN");
    }
    
    if (isnan(-1)) {
        DLog(@"-1是nan值");
    }
    else {
        DLog(@"-1不是NAN");
    }
    if (isnan(M_PI)) {
        DLog(@"M_PI是nan值");
    }
    else {
        DLog(@"M_PI不是NAN");
    }
打印结果：

2015-08-26 20:19:23.082 jimustock[2276:919998] [Line 47] 1不是NAN
2015-08-26 20:19:23.083 jimustock[2276:919998]  [Line 54] yes不是NAN
2015-08-26 20:19:23.083 jimustock[2276:919998]  [Line 61] -1不是NAN
2015-08-26 20:19:23.083 jimustock[2276:919998]  [Line 67] M_PI不是NAN


欢迎指正！！！

版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift 结构体







结构体和枚举比较类似可以比较学习：http://blog.csdn.net/lwjok2007/article/details/47975415




结构体是类似于枚举但又和枚举不同的一种自定义类型。简单理解一下可以认为结构体就是一个只有属性没有方法的特殊类。结构体里的属性，是一个对象都得有的。比如我们定义一个学生的结构体，包含学号，姓名，班级。那么一个学生类型的对象就包含了学号，姓名，班级所有的信息。某个变量如果被声明为一个枚举类型后，那么他只能是枚举中的某一个值。









//1 结构体的声明

//声明结构体一般用关键字struct。我们看例子，声明一个学生结构体

struct Student {
    var studentID:Int;//学号
    var studentName:String;//姓名
    var studentClass:String;//班级
}

//以上声明方式 我们可以看到 直接指定了 每一个属性的数据类型。还有一种方式就是不指定数据类型，而是直接赋值，系统自动根据赋值判断数据类型

struct Student1 {
    var studentID=2007001
    var studentName=""
    var studentClass=""
}


//2 结构体的构造方法

//2.1 空参构造方法

var zhangsan=Student1();
 //由于结构体必须有初始值，所以空参构造方法只适用于带默认值的结构体。

//2.2 全参构造方法

var zhangsan1=Student(studentID: 2001, studentName: "张三", studentClass: "三年级")

//3 结构体的取值和赋值

//结构体的取值和赋值很简单，直接使用 . 语法

println(zhangsan1.studentName)
zhangsan1.studentName="李四"

println(zhangsan1.studentName)


// 4 最后我们简单说下 结构体是可以嵌套的。

//比如学生信息里面可能会有班主任的信息，我们可以直接把班主任直接设置成一个结构体，那么学生结构体里面就会有一个结构体

struct Teacher {
    var teacherName="王老师"
    var teacherSex="女"
}

struct Student2 {
    var studentID:Int;//学号
    var studentName:String;//姓名
    var studentClass:String;//班级
    var teacherInfo:Teacher;//班主任信息
}

苹果开发群 ：414319235  欢迎加入  欢迎讨论问题


版权声明：本文为博主原创文章，未经博主允许不得转载。

Unity3D汽车物理引擎的安卓重力感应适配
////////////////2015/08/24///////////////////
///////////////by  XBW///////////////////////
//////////////环境 unity4.6.1//////////////
试一下这个汽车的物理引擎的插件，在PC上测试完全没有问题，但是选择平台到安卓版的时候会出现一些问题，首先就是这个SmoothFollow.js脚本的问题，话说这是unity自带的脚本，是官方的脚本，不应该有问题，但是选择安卓平台出错了，是一些变量没有定义，不是没有定义吗，索性自己定义吧，修改后的SmoothFollow.js脚本如下
/*
This camera smoothes out rotation around the y-axis and height.
Horizontal Distance to the target is always fixed.

There are many different ways to smooth the rotation but doing it this way gives you a lot of control over how the camera behaves.

For every of those smoothed values we calculate the wanted value and the current value.
Then we smooth it using the Lerp function.
Then we apply the smoothed values to the transform's position.
*/

// The target we are following
var target : Transform;
// The distance in the x-z plane to the target
var distance = 10.0;
// the height we want the camera to be above the target
var height = 5.0;
// How much we 
var heightDamping = 2.0;
var rotationDamping = 3.0;
var wantedHeight : float;
var currentHeight : float;
var wantedRotationAngle : float;
var currentRotationAngle : float;
var currentRotation : Quaternion;

// Place the script in the Camera-Control group in the component menu
@script AddComponentMenu("Camera-Control/Smooth Follow")


function LateUpdate () {
	// Early out if we don't have a target
	if (!target)
		return;
	
	// Calculate the current rotation angles
	wantedRotationAngle = target.eulerAngles.y;
	wantedHeight = target.position.y + height;
		
	currentRotationAngle = transform.eulerAngles.y;
	currentHeight = transform.position.y;
	
	// Damp the rotation around the y-axis
	currentRotationAngle = Mathf.LerpAngle (currentRotationAngle, wantedRotationAngle, rotationDamping * Time.deltaTime);

	// Damp the height
	currentHeight = Mathf.Lerp (currentHeight, wantedHeight, heightDamping * Time.deltaTime);

	// Convert the angle into a rotation
	currentRotation = Quaternion.Euler (0, currentRotationAngle, 0);
	
	// Set the position of the camera on the x-z plane to:
	// distance meters behind the target
	transform.position = target.position;
	transform.position -= currentRotation * Vector3.forward * distance;

	// Set the height of the camera
	transform.position.y = currentHeight;
	
	// Always look at the target
	transform.LookAt (target);
}
这样就好了，但是仍然会有错误，是position不是object的成员，这个错误发生在AICar，就是这个汽车插件的智能脚本中，这样呢，具体原因我是真不清楚，索性就把一些代码注释了，这样经过测试也是没问题的，报错也没有了，看一下修改后的AICar脚本
// ----------- CAR TUTORIAL SAMPLE PROJECT, ? Andrew Gotow 2009 -----------------

// Here's the basic AI driven car script described in my tutorial at www.gotow.net/andrew/blog.
// A Complete explaination of how this script works can be found at the link above, along
// with detailed instructions on how to write one of your own, and tips on what values to 
// assign to the script variables for it to work well for your application.

// Contact me at Maxwelldoggums@Gmail.com for more information.




// These variables allow the script to power the wheels of the car.
var FrontLeftWheel : WheelCollider;
var FrontRightWheel : WheelCollider;
var BackLeftWheel : WheelCollider;
var BackRightWheel : WheelCollider;

// These variables are for the gears, the array is the list of ratios. The script
// uses the defined gear ratios to determine how much torque to apply to the wheels.
var GearRatio : float[];
var DifferentialRatio : float = 3.1;
var CurrentGear : int = 0;

// These variables are just for applying torque to the wheels and shifting gears.
// using the defined Max and Min Engine RPM, the script can determine what gear the
// car needs to be in.
var EngineTorque : float = 600.0;
var MaxEngineRPM : float = 3000.0;
var MinEngineRPM : float = 1000.0;
private var EngineRPM : float = 0.0;

// Here's all the variables for the AI, the waypoints are determined in the "GetWaypoints" function.
// the waypoint container is used to search for all the waypoints in the scene, and the current
// waypoint is used to determine which waypoint in the array the car is aiming for.
var waypointContainer : GameObject;
private var waypoints : Array;
private var currentWaypoint : int = 0;

// input steer and input torque are the values substituted out for the player input. The 
// "NavigateTowardsWaypoint" function determines values to use for these variables to move the car
// in the desired direction.
private var inputSteer : float = 0.0;
private var inputTorque : float = 0.0;

function Start () {
	// I usually alter the center of mass to make the car more stable. I'ts less likely to flip this way.
	rigidbody.centerOfMass.y = -.45;
	rigidbody.centerOfMass.z = -0.15;
	
	// Call the function to determine the array of waypoints. This sets up the array of points by finding
	// transform components inside of a source container.
	GetWaypoints();
}

function Update () {
	
	// This is to limith the maximum speed of the car, adjusting the drag probably isn't the best way of doing it,
	// but it's easy, and it doesn't interfere with the physics processing.
	rigidbody.drag = rigidbody.velocity.magnitude / 250;
	
	// Call the funtion to determine the desired input values for the car. This essentially steers and
	// applies gas to the engine.
	NavigateTowardsWaypoint();
	
	// Compute the engine RPM based on the average RPM of the two wheels, then call the shift gear function
	EngineRPM = (BackLeftWheel.rpm + BackRightWheel.rpm)/2 * GearRatio[CurrentGear]*DifferentialRatio;
	ShiftGears();

	// set the audio pitch to the percentage of RPM to the maximum RPM plus one, this makes the sound play
	// up to twice it's pitch, where it will suddenly drop when it switches gears.
	audio.pitch = Mathf.Abs(EngineRPM / MaxEngineRPM) + 0.5 ;
	// this line is just to ensure that the pitch does not reach a value higher than is desired.
	if ( audio.pitch > 1.5 ) {
		audio.pitch = 1.5;
	}
	
	// finally, apply the values to the wheels.	The torque applied is divided by the current gear, and
	// multiplied by the calculated AI input variable.
	//FrontLeftWheel.motorTorque = EngineTorque / GearRatio[CurrentGear]*DifferentialRatio * inputTorque;
	//FrontRightWheel.motorTorque = EngineTorque / GearRatio[CurrentGear]*DifferentialRatio * inputTorque;
	BackLeftWheel.motorTorque = -EngineTorque / GearRatio[CurrentGear]*DifferentialRatio * inputTorque;
	BackRightWheel.motorTorque = -EngineTorque / GearRatio[CurrentGear]*DifferentialRatio * inputTorque;
	
	// the steer angle is an arbitrary value multiplied by the calculated AI input.
	FrontLeftWheel.steerAngle = 35 * inputSteer;
	FrontRightWheel.steerAngle = 35 * inputSteer;
}

function ShiftGears() {
	// this funciton shifts the gears of the vehcile, it loops through all the gears, checking which will make
	// the engine RPM fall within the desired range. The gear is then set to this "appropriate" value.
	if ( EngineRPM >= MaxEngineRPM ) {
		var AppropriateGear : int = CurrentGear;
		
		for ( var i = 0; i < GearRatio.length; i ++ ) {
			if ( BackLeftWheel.rpm * GearRatio[i]*DifferentialRatio < MaxEngineRPM ) {
				AppropriateGear = i;
				break;
			}
		}
		
		CurrentGear = AppropriateGear;
	}
	
	if ( EngineRPM <= MinEngineRPM ) {
		AppropriateGear = CurrentGear;
		
		for ( var j = GearRatio.length-1; j >= 0; j -- ) {
			if ( BackLeftWheel.rpm * GearRatio[j]*DifferentialRatio > MinEngineRPM ) {
				AppropriateGear = j;
				break;
			}
		}
		
		CurrentGear = AppropriateGear;
	}
}

function GetWaypoints () {
	// Now, this function basically takes the container object for the waypoints, then finds all of the transforms in it,
	// once it has the transforms, it checks to make sure it's not the container, and adds them to the array of waypoints.
	var potentialWaypoints : Array = waypointContainer.GetComponentsInChildren( Transform );
	waypoints = new Array();
	
	for ( var potentialWaypoint : Transform in potentialWaypoints ) {
		if ( potentialWaypoint != waypointContainer.transform ) {
			waypoints[ waypoints.length ] = potentialWaypoint;
		}
	}
}

function NavigateTowardsWaypoint () {
	// now we just find the relative position of the waypoint from the car transform,
	// that way we can determine how far to the left and right the waypoint is.
	//var RelativeWaypointPosition : Vector3 = transform.InverseTransformPoint( Vector3( 
	//											waypoints[currentWaypoint].position.x, 
		//										transform.position.y, 
			//									waypoints[currentWaypoint].position.z ) );
																				
																				
	// by dividing the horizontal position by the magnitude, we get a decimal percentage of the turn angle that we can use to drive the wheels
	//inputSteer = RelativeWaypointPosition.x / RelativeWaypointPosition.magnitude;
	
	// now we do the same for torque, but make sure that it doesn't apply any engine torque when going around a sharp turn...
	//if ( Mathf.Abs( inputSteer ) < 1.0 ) {
		//inputTorque = RelativeWaypointPosition.z / RelativeWaypointPosition.magnitude - Mathf.Abs( inputSteer );
	//}else{
		//inputTorque = 0.0;
	//}
	
	// this just checks if the car's position is near enough to a waypoint to count as passing it, if it is, then change the target waypoint to the
	// next in the list.
	//if ( RelativeWaypointPosition.magnitude < 30 ) {
		//currentWaypoint ++;
		
		//if ( currentWaypoint >= waypoints.length ) {
			//currentWaypoint = 0;
		//}
	//}
	
}
这样就好了，安卓的平台的错误消失了，可以运行了，但是我们的目的是重力感应控制汽车的移动，这样呢，我们找到控制汽车移动的脚本PlayerCar脚本
我们把用PC方向键控制的部分改为重力感应的输入控制，
//BackLeftWheel.motorTorque = -EngineTorque * GearRatio[CurrentGear] * DifferentialRatio * Input.GetAxis("Vertical") *100;
		//BackRightWheel.motorTorque = -EngineTorque * GearRatio[CurrentGear] * DifferentialRatio * Input.GetAxis("Vertical") *100;
		BackLeftWheel.motorTorque = -EngineTorque * GearRatio[CurrentGear] * DifferentialRatio * Input.acceleration.y *100;
		BackRightWheel.motorTorque = -EngineTorque * GearRatio[CurrentGear] * DifferentialRatio * Input.acceleration.y *100;
	//}

	// the steer angle is an arbitrary value multiplied by the user input.
	//FrontLeftWheel.steerAngle = 35 * Input.GetAxis("Horizontal");
	//FrontRightWheel.steerAngle = 35 * Input.GetAxis("Horizontal");
	FrontLeftWheel.steerAngle = 35 * Input.acceleration.x;
	FrontRightWheel.steerAngle = 35 *Input.acceleration.x;


这样就好了，赶紧到安卓真机测试一下吧，是不是很好玩呢，对于那个注释掉的部分如果有明白的专家批评指正。
那个Car Phasic插件百度云链接在这
链接：http://pan.baidu.com/s/1jGEPwai 密码：9wnj


版权声明：本文为博主原创文章，未经博主允许不得转载。

嵌入式Linux网络编程 之 简单的TCP网络编程
 关于TCP：TCP提供的是一种面向连接的、可靠的字节流服务。                       
                       
                        TCP网络通信流程图





补充的API

函数名称：listen()
原型：int listen(int sockfd, int backlog)
功能 :  宣告服务器能够接收的连接请求数
头文件：<sys/socket.h>
成功：0 失败：-1
参数说明：
sockfd : 套接字
backlog：请求队列允许的最大请求数，大多数系统默认为20


函数名称：accept()
原型：int accept(sockfd, struct sockaddr *restrict addr, socklen_t *restrict len)
功能 :  阻塞服务器，获得连接请求并建立连接
头文件：<sys/socket.h>
成功：返回新的关于该连接的套接字  失败：-1
参数说明：
sockfd : 套接字
addr：客户端地址信息
len：客户端地址长度


函数名称：send()
原型：int send(int sockfd, const void *buf , size_t n， int flags)
功能 :  发送数据（此时套接字必须已连接）
头文件：<sys/socket.h>
成功：返回发送的字节数  失败：-1
参数说明：
sockfd : 套接字
buf：待发送的数据
n：发送数据长度
flags：通常为0




函数名称：connect() --->可以看出通常是由客户端发送连接请求
原型：int connect(int sockfd, const struct sockaddr *addr, socklen_t len)
功能 :  在客户端与服务端建立连接
头文件：<sys/socket.h>
成功：0 失败：-1
参数说明：
sockfd : 套接字
addr：与之通信的服务器地址，如果sockfd没有绑定到一个地址，则，connect会给调用者绑定一个默认地址
len：地址长度




函数名称：recv()
原型：int recv(int sockfd, void *buf , size_t n， int flags)
功能 :  接收数据（此时套接字必须已连接）
头文件：<sys/socket.h>
成功：返回接收的字节数   无可用数据则返回0 失败：返回-1
参数说明：
sockfd : 套接字
buf：存放接收数据的缓冲区
n：缓冲区长度
flags：通常为0



服务器工作流程：


1. 创建、初始化服务器套接字，创建初始化服务器/客户端地址结构
2. 绑定服务器套接字（bind）
3. 监听sockfd描述符( listen )
4. 服务器阻塞，直到获得连接请求并建立连接（accept）
5. 接收客户端发送的数据，这里以读取客户端的IP作为示例
6. 发送数据到客户端，通过新的套接字。


代码如下：
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
 int sockfd, port, new_fd;
 struct sockaddr_in s_addr;
 struct sockaddr_in c_addr;
 char hello[] = "hello";
 int size;
 
 
 /*判断用法是否正确*/
 if(argc != 2)
 {
  fprintf(stderr, "usage: %s port", strerror(errno));
  exit(1);
 }
 /*获取端口号*/
 if((port = atoi(argv[1])) < 0)
 {
  fprintf(stderr, "Port Error: %s", strerror(errno));
  exit(1);
 }
 
 if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 {
  fprintf(stderr, "socket error: %s", strerror(errno));
  exit(1);
 }
 /*填充sockaddr结构*/
 bzero(&s_addr, sizeof(s_addr));
 s_addr.sin_family = AF_INET;
 s_addr.sin_port = htons(port);
 s_addr.sin_addr.s_addr = htonl(INADDR_ANY);
 
 /*绑定套接字与描述符*/
 if(bind(sockfd, (struct sockaddr*)&s_addr, sizeof(s_addr)) == -1)
 {
  fprintf(stderr, "bind error: %s", strerror(errno));
  exit(1);
 }
 printf("socket...\n");
 
 /*监听sockfd描述符*/
 if(listen(sockfd, 10) == -1)
 {
  fprintf(stderr, "listen error: %s", strerror(errno));
  exit(1);
 }
 printf(" listen...\n");
 while(1)
 {
  size = sizeof(struct sockaddr);
 
  /*阻塞服务器，获取连接*/
  printf(" accept...\n");
  if((new_fd = accept(sockfd, (struct sockaddr*)&c_addr, &size)) < 0)
  {
   fprintf(stderr, "accept error: %s", strerror(errno));
   exit(1);
  }
 
 
  fprintf(stderr, "new_fd = %d\n", new_fd);
 
  /*向连接的新套接字字符发送数据*/
  if((send(new_fd, hello, strlen(hello), 0)) < 0)
  {
   fprintf(stderr, "send error: %s", strerror(errno));
   exit(1);
  }
 
 }
 
 close(sockfd);
 exit(0);
 
}


客户端工作流程：
1. 判断使用方法，提取端口号
2. 创建套接字（面向字节流），初始化套接字
3. 在请求服务的进程套接字（客户端）和提供服务的进程套接字（服务端）建立连接
4. 接收数据，打印


通信演示：
服务端：



客户端：









版权声明：本文为博主原创文章，未经博主允许不得转载。

Swift集成第三方QQ分享错误总结
现在开发iOS程序，基本都用swift来编写代码。但是很多第三方库都是oc构建的，因此集成第三方SDK的时候，多多少少会遇到一些问题。下面是我集成QQ分享遇到的问题总结。 
iOS_SDK的环境搭建这里介绍的还算详细。因为Xcode版本的升级。配置还是有一点不同。 
1、在工程配置中的“Build Settings”一栏中找到“Linking”配置区，给“Other Linker Flags”配置项添加属性值“-fobjc-arc”。这是以前的Xcode版本。 

Xcode6是这样的。

2、新建的swift工程中并没有Frameworks文件夹。所以我们新建一个文件夹Frameworks。

3、在xxx(你的项目名)-Bridging-Header.h中添加以下头文件。路径一定要对，否则是没有效果的。我一开时就犯路径错误。这样swift才能轻松调用QQ的接口。
//TencentOpenapi
#import <TencentOpenAPI/TencentOAuth.h>
#import <TencentOpenAPI/QQApiInterface.h>
#import <TencentOpenAPI/QQApiInterfaceObject.h>
#import <TencentOpenAPI/sdkdef.h>
#import <TencentOpenAPI/TencentMessageObject.h>
#import <TencentOpenAPI/TencentOAuthObject.h>
#import <TencentOpenAPI/WeiBoAPI.h>
#import <TencentOpenAPI/WeiyunAPI.h>


4、重写AppDelegate.swift的两个方法，用swift写。
    func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject?) -> Bool {
        return TencentOAuth.HandleOpenURL(url)
    }

    func application(application: UIApplication, handleOpenURL url: NSURL) -> Bool {
        return TencentOAuth.HandleOpenURL(url)
    }
5、测试分享代码。
let title = deal["title"] as! String
            let previewImageUrl = deal["image"] as! String
            var newObj = QQApiNewsObject(URL: NSURL(string:"http://www.baidu.com")!, title: title, description: title, previewImageURL: NSURL(string: previewImageUrl)!, targetContentType:QQApiURLTargetTypeNews)
            var req = SendMessageToQQReq(content: newObj)
            QQApiInterface.sendReq(req)
基本上第三方的调用方法都差不多。对于初学者来讲，还是有点作用的。

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

static作用（修饰函数、局部变量、全局变量）

在C语言中，static的字面意思很容易把我们导入歧途，其实它的作用有三条。

（1）先来介绍它的第一条也是最重要的一条：隐藏。

当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。为理解这句话，我举例来说明。我们要同时编译两个源文件，一个是a.c，另一个是main.c。

下面是a.c的内容

char a = 'A'; // global variable
void msg() 
{
    printf("Hello\n"); 
}
 下面是main.c的内容

int main(void)
{    
    extern char a;    // extern variable must be declared before use
    printf("%c ", a);
    (void)msg();
    return 0;
}
程序的运行结果是：

A Hello

你可能会问：为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。

如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。Static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。

（2）static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见，但我还是举一个例子。

#include <stdio.h>

int fun(void){
    static int count = 10;    // 事实上此赋值语句从来没有执行过
    return count--;
}

int count = 1;

int main(void)
{    
    printf("global\t\tlocal static\n");
    for(; count <= 10; ++count)
        printf("%d\t\t%d\n", count, fun());    
    
    return 0;
}
 程序的运行结果是：

global          local static

1               10

2               9

3               8

4               7

5               6

6               5

7               4

8               3

9               2

10              1

（3）static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。不妨做个小实验验证一下。

#include <stdio.h>

int a;

int main(void)
{
    int i;
    static char str[10];

    printf("integer: %d;  string: (begin)%s(end)", a, str);

    return 0;
}
程序的运行结果如下

integer: 0; string: (begin)(end)

最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。

以上内容出自博客园Mr. Write之手，写的相当清晰易懂，存档方便复习。原文地址：http://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html

下面是中兴通讯2012校招笔试题的一道问答题：

1. static全局变量与普通的全局变量有什么区别 ?

　　全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。

　　全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。

　　这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。


　　static全局变量只初使化一次，防止在其他文件单元中被引用; 　 

2.  static局部变量和普通局部变量有什么区别 ？

 　　把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。  

　　static局部变量只被初始化一次，下一次依据上一次结果值； 　 

3.  static函数与普通函数有什么区别？

　　 static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.

　　static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
    
安卓自定义控件 - 进度条
效果图：




素材：







package com.example.progressbar;

import android.app.Activity;
import android.os.Bundle;


public class MainActivity extends Activity
{
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		
		// 创建进度条
		progressView progress = new progressView(this, R.drawable.progress1, R.drawable.progress2);
		progress.setProgress(77.1f);
		
		// 添加进度条到界面显示
		setContentView(progress);
	}
}

/**
 * 2015-8-25上午11:04:08
 * wangzhongyuan
 */

package com.example.progressbar;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.widget.RelativeLayout;
import android.widget.TextView;


/**
 * progressView 创建自定义进度条控件，只需为进度条提供两张纹理图像（一张为背景，一张用于显示进度）
 * -----
 * 2015-8-25 上午11:04:08 
 * wangzhongyuan
 */
public class progressView extends RelativeLayout
{
	// 界面需要的图片
	private Bitmap progressBack;	// 背景
	private Bitmap progressfront;	// 进度
	
	public float progress = 63;		// 进度值
	private TextView textView;		// 用于显示进度信息
	
	/**
	 * 设置进度条的显示进度
	 */
	public void setProgress(float progress)
	{
		if (progress > 100)
			this.progress = 100;
		else if (progress < 0)
			this.progress = 0;
		else
			this.progress = progress;
		
		textView.setText(this.progress + " %");	// 更新显示信息
	}
	
	/**
	 * 使用默认资源图像创建进度条
	 */
	public progressView(Context context)
	{
		super(context);
		ViewInit(context, R.drawable.progress1, R.drawable.progress2);
	}
	
	/**
	 * 使用默认资源图像创建进度条， -XML布局创建控件时，会调用该函数
	 */
	public progressView(Context context, AttributeSet attrs)
	{
		super(context, attrs);
		ViewInit(context, R.drawable.progress1, R.drawable.progress2);
	}
	
	/**
	 * 创建进度条，progress1和progress2为尺寸相同的图像
	 * @param context
	 * @param drawableID1	进度条背景图		R.drawable.progress1
	 * @param drawableID2	进度条进度填充图	R.drawable.progress2
	 */
	public progressView(Context context, int drawableID1, int drawableID2)
	{
		super(context);
		ViewInit(context, drawableID1, drawableID2);
	}
	
	// 进度条控件初始化
	private void ViewInit(Context context, int progress1, int progress2)
	{
		// 创建InnerView控件
		InnerView innerView = new InnerView(context, progress1, progress2);
		
		// 创建进度条进度信息
		textView = new TextView(context);
		textView.setTextSize(innerView.height / 3);	// 设置字体大小
		textView.setGravity(Gravity.CENTER);		// 居中于TextView
		textView.setText(progress + " %");			// 设置进度信息
		textView.setTextColor(Color.WHITE);			// 设置字体颜色
		
		// 控件主体部分为
		RelativeLayout body = new RelativeLayout(context);
		this.addView(body, centerLayout(innerView.width, innerView.height));
		
		// 添加进度条图像控件 和 进度信息到控件上
		body.addView(innerView);
		body.addView(textView, centerLayout(innerView.width, innerView.height));	// 居中于当前控件，显示进度信息
	}
	
	// 获取居中布局参数
	private RelativeLayout.LayoutParams centerLayout(int width, int height)
	{
		RelativeLayout.LayoutParams params1 = new RelativeLayout.LayoutParams(width, height);
		params1.addRule(RelativeLayout.CENTER_IN_PARENT, RelativeLayout.TRUE);
		
		return params1;
	}
	
	// 内部类，重写View的onDraw函数，实现进度条的绘制
	private class InnerView extends View
	{
		public int width = 0, height = 0;	// 进度条的尺寸
				
		/**
		 * 创建进度条，progress1和progress2为尺寸相同的图像
		 * @param context
		 * @param progress1	进度条背景图		R.drawable.progress1
		 * @param progress2	进度条进度填充图	R.drawable.progress2
		 */
		public InnerView(Context context, int progress1, int progress2)
		{
			super(context);
			ViewInit(context, progress1, progress2);
		}
		
		// 转盘控件自身的初始化
		private void ViewInit(Context context, int progress1, int progress2)
		{
			Resources r = context.getResources();
			
			// 从内部资源文件获取进度条图像
			progressBack = BitmapFactory.decodeStream(r.openRawResource(progress1));
			progressfront = BitmapFactory.decodeStream(r.openRawResource(progress2));
			
			width = progressBack.getWidth();
			height = progressBack.getHeight();
		}
		
		// 重写View类的onDraw()函数
		protected void onDraw(Canvas canvas)
		{
			// 绘制进度条背景图
			canvas.drawBitmap(progressBack, 0, 0, null);
			
			// 绘制进度条进度图
			int w = (int) (width * progress / 100);
			Rect rect = new Rect(0, 0, w, height);
			canvas.drawBitmap(progressfront, rect, rect, null);
		}
	}
}



打包下载： http://download.csdn.net/detail/scimence/9046317



版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS开发之构建Widget




伴随这iOS 8 系统多达4000项API更新而来同样还有Today Extension.而对iOS而言，有了Today Extension 开发者可以很好借助系统提供的接入点为系统定制的服务,提供自定义的附加功能.这意味着什么呢？从iOS 7版本尝试开路到现在iOS 8更新的到来终于向开发者开放Widget接入,这意味着系统应用和第三方应用都可以通知中心(Notification Center)里面实现交互.



Notification Center Widget [Via Apple]


其实相对于Android，因其特有开放性Widget插件已经发展了很多年，拥有极高自由定制性，在新版本的Android系统中甚至可以将部分插件摆在锁屏页.而Google和各大软件厂商制作的Widget插件也能很好与系统的整体风格进行无缝的融合，而直到目前iOS 8版本中，Widget也就只是能摆在通知中心(Notification Center)今天通知栏中而已，相对于Android也听到很多人把这个作为"iOS不够开放"一个有力的依据.针对这个问题其实Apple也在iOS
 Human Interface Guidelines中提到：


iOS 8 中开发者的中心并不应该发生改变，依然应该是围绕 app.在 app 中提供优秀交互和有用的功能，现在是，将来也会是 iOS 应用开发的核心任务。而Widget在 iOS 中是不能以单独的形式存在的,一定是随着一个应用一起打包提供的。



从这个侧面可见，Apple对开放一直持有审慎的态度，开放的目的是力求保证整体体验完整性，虽然iOS的Widget相比Android自定义性太低，但基于Apple目前的开放程度而言是能够很有效控制Widget与系统的更好的融合.虽似戴着镣铐起舞，但却能捕获人心.

而从用户角度来看，在无需打开应用前提下就可以对消息进行处理的交互特性,使它在很多场景里有效提升了用户操作效率.例如在Widget中快速回复email，即时完成Todo日程等.这种交互更多从更宏观角度重新定义了消息,通知中心(Notification Center)通过获取用户上一行为，还可以起到承接下一行为的作用(虽然目前开放API只能做到系统级的行为).点虽小，但这对用户使用习惯改变却是巨大的.



Widget on hands [Via Yalantis]


有人看到这肯定一定会问为何没有提到Windows Phone平台?因为无论从通知中心快捷入口数量还是谈到可以交互的点一句话而概之WP的现状是“一穷二白”，你想作为曾经走过WP7时代用户根本不知道通知中心为何物的，而是用了足足两年时间WP8上才有体现，而那些被其他平台玩腻的希望习以为常通知中心交互，就像这样：



WP 通知中心[Via PCGGroup]


你就像看这张静态图片一样也就是停留只是看看程度而已（除了删除操作之外）,MS针对通知中心现在最新消息是未来会支持类似可以通知中心直接回复短信等交互，至于什么时候能够等到，谁知道呢.


说了这么多，回归正题.

1.交互

在开始构建Widget之前，如果想对Widget实现技术细节和交互特点有一个完整概览，我觉得没有什么文档比官方App
 Extension Programming Guide更值得一读了.刚开始接触iOS通知中心，一直很疑惑为何通知中心采用两个不同Tab“今日”和“通知”来对消息进行分离.其实这和Widget工作机制有关.

Widget是放在“今日”Tab之中，而它工作机制是只有用户下拉通知中心时才会去刷新获取最新数据，这种做法和Android不同在于，Android更偏向于把整个Widget一直放在后台实时持续的更新.设想一下，如果我们看同样天气信息，Android会持续消耗资源去做一件用户不会实时预览信息,这也就能解释为何经常看到Android用户抱怨耗电问题.而对于即时消息，iOS做法是直接把这些消息实时归类到”通知“Tab中.其实这种做法很好解决采用消耗最少资源前提下保证其操作的灵活性.

因为现有Widget一般来说是展现在系统级别的 UI上，所以在App Extension
 Programming Guide中Apple对Widget交互提出如下明确的要求:


扩展应该保持轻巧迅速，并且专注功能单一，在不打扰或者中断用户使用当前应用的前提下完成自己的功能点.



类似一直挚爱Todo应用Clear则交互上堪称上典范:



Clear's Widget


当然如果动点脑子会发现，Widget开放iOS上实现应用之间Launcher成为了可能，类似早期一直很魔性应用"Launcher"：



Launcher's Widget


可以让用在 iOS 的通知中心里，以类似应用程序捷径的方式直接快速切换 App 的小工具，其实当初在推出没多久后，便被 Apple 以"误用 / 滥用"Widgets 为理由下架，但有意思的就在几天前3月20日又重新上架.


2.构建

在Widget技术实现细节上，并不打算在本篇把所有技术细节通览一遍，我只会写我个人(其实就是初学者)认为值得写的容易出错的点或者耗费一些时间找到一些问题的解决方案.

2.1 纯代码构建

Xcode 6中已经支持Today Extension创建Widget的模板，该模板会默认创建MainInterface.storyboard文件来构建UI:



StoryBoard UI


当然对于一个纯代码的拥趸而言，肯定直接删除storyboard文件采用纯代码方式来进行构建，删除完后之后注意需要找到Supporting Files下面的Info.plist中NSExtension字段做如下两个操作:


A：直接删除NSExtensionMainStoryboard字段

B：添加NSExtensionPrincipalClass字段 并设为TodayViewController


如下:



修改后


注意当采用Xcode默认模板创建Widget时会自动把ViewController文件命名设置为“TodayViewController”.当然这个ViewController命名其实是可以修改的，唯一值得注意的修改该ViewController文件命名后还需要设置NSExtensionPrincipalClass的值与其保持一致即可.不然Widget编译时会报找不到对应入口.

2.2 左侧间隔

当第一次添加UI元素采用真机来运行Widget会发现，Widget左侧到屏幕之间始终会有一段距离的间隔，导致调整布局和效果图差距甚远，类似这样:



左侧间隔


其实这个问题主要是因为Widget里面的视图默认居左居下都会有一定距离的间隔，可以采用如下方式取消间隔，使布局区域填充整个Widget:



取消间隔


这种方式把整个布局填充区域间隔都设置为0，当然更简洁的方式是你可以直接采用“return UIEdgeInsetsZero;”方式.而关于Widget上布局处理则采用Masonry框架做的相对布局,简单快捷推荐.当然关于Masonry框架快速上手则不得不推荐阅读Masonry介绍与使用实践(快速上手Autolayout).

2.3 整个点击区域实现

如你所看当用户拉开Widget时，因为Widget是依赖于应用程序在分发时是跟应用程序一块打包的，希望点击Widget布局任何区域都能唤起主应用程序,常用的方式在整个View增加Tap事件订阅处理:



Tap事件


但这种方式会额外产生一个问题，如果Widget空白区域没有任何UI元素则无法触发该事件,那这里有一个小技巧可以解决改问题,可以整个Widget增加一个透明的ImageView:



设置透明度


初始化时注意把imageview透明度设置为0.01最小值，那么无论设置其背景色为什么值肉眼都是不可见的.然后使用Masonry框架布局来填充Widget整个背景如下：



填充整个背景


然后为imageview增加Tap事件订阅即可：



增加事件订阅


这样就能整个Widget区域可点击效果.另外针对通过Widget中唤起主应用程序方式目前只支持url scheme方式来实现.同时也是Widget向主应用程序反馈数据和交互的渠道之一.

2.4 定时更新机制

Widget自身更新机制当用户下拉通知中心(Notification Center)时立即更新数据，但我们仔细研究Widget用户使用场景时发现，如果用户锁屏时间过长，打开Widget后不做任何操作，这个时候针对一些即时类应用，类似我们天气中可能涉及到灾害预警它要求场景数据一旦产生就要实时展现给用户，这就需要我们基于Widget自身机制外还要处理这个场景下天气数据自动更新的问题.

这个时候我们需要构建一个定时更新的NSTimer：



初始化NSTimer


非常简单，在NSTimer固定更新间隔执行的方法调用就是更新数据方法，当然重点不在这里，而是触发和关闭这个NSTimer时机.按照Widget生命周期来说，如果用户是第一次下拉查看Widget其实就是执行整个ViewController生命周期调用过程，这个并没有什么问题，但是还是存在一个特殊情况.系统为了保证Widget上数据是及时更新的,默认会截取上次显示成功Widget的快照.这个快照会一直保存到新的数据或UI被更新才回被替换，那这就会带来一个问题,当你拖拽通知中心(Notification Center)下拉过于频繁时，Debug跟踪代码执行路径你会发现整个Widget生命周期执行过程和第一次下拉执行的路径发生了变化.

第一次下拉执行路径是viewDidLoad->viewWillAppear,而如果下拉过于频繁你就会发现代码执行路径直接只会执行viewWillAppear方法，这个就是系统默认保存上次快照而导致的执行路径上变化.这对我们选择NSTimer更新时机以及后面会提到的Widget横竖屏处理都会有影响.

那么很明显，为了保证这个定时更新机制能够无论用户什么情况下操作都能起作用，我们需要把NSTimer fire触发代码调用放到viewWillAppear方法中来.同理当Widget关闭后在viewDidDisappear方法取消NSTimer invalidate定时更新即可.

2.5 Widget横屏支持

关于Widget横屏支持在开发中耽误一点时间来解决这个问题,在iPhone 6 & Plus上已经横竖屏直接切换，Widget默认是竖屏，但如果你需求中横屏UI的布局和竖屏布局完全不同，这个时候你就需要判断当前Widget横竖屏状态来切换对应的布局.

当然一般思路我们都会按照端内处理横竖屏方式来处理Widget，如果你翻过官方的开发文档，你会发现在iOS 6.0版本之前UIViewController之间横竖屏切换，只需要设置shouldAutorotateToInterfaceOrientation函数即可.UIInterfaceOrientation是UIApplication.h头文件中定义的枚举类型，总共有四个方向.在shouldAutorotateToInterfaceOrientation方法中返回相应的结果即可，如果直接返回YES将支持所有方向.而在iOS
 6.0版本之后，UIViewController之间横竖屏切换需要多设置一个supportedInterfaceOrientations函数返回UIInterfaceOrientationMask枚举类型.除了设置shouldAutorotateToInterfaceOrientation之外,还要将supportedInterfaceOrientations返回的方向与shouldAutorotateToInterfaceOrientation保持一致，否则会在两个支持不同横竖屏ViewController中切换时，会出现竖屏变横屏，横屏变竖屏的情况.但问题是这种方式是否适用Widget横屏处理呢?

使用UIDeviceOrientationIsPortrait来判断：



判断横屏方法一


当你执行这段代码调试时你会发现，orientation方向的值始终都会是UIDeviceOrientationUnknown.如果你点开UIDeviceOrientation枚举你会看到.它包含了两个扁平方向UIDeviceOrientationFaceUp和UIDeviceOrientationFaceDown，其实它代表的意思屏幕朝上或朝下平躺两个方向的判断.所以当你设备平躺桌面时.即时你有时已经切换了横屏你会发现它会返回FaceUp或FaceDown，所以你当你调用UIDeviceOrientationIsPortrait方法时它返回值其实是没有意义的，因为设备目前方向在平躺下Faceup和FaceDown既不是横屏也不是竖屏.难道没有更好的方式嘛?

可以采用如下方式能够完美解决Widget横竖屏切换状态判断的问题:



Widget横竖屏状态判断


其实设置Widget显示高度时就会发现，高度在横竖屏状态切换是不会变化的，但宽度会随着横竖屏状态切换会发生变化，所以判断屏幕宽度这个思路是可取的.因为横竖屏UI布局不同，调用时机则可以选择在viewWillLayoutSubviews或viewDidLayoutSubviews方法中进行.因为这两个方法都是viewWillAppear方法是必然执行的，这也就自然规避Widget自身因为下拉快照保存机制导致代码执行路径变化导致布局更新的问题.

2.6 Widget国际化

在来说说这个Widget国际化，因为我们客户端自身已经支持三种不同语言,这就是导致Widget也是需要根据端内语言变化必须有国际化的支持.其实我们端内已经做了一套完整的国际化机制.Widget最好处理方式能够复用端内机制，而不需要单独开发支持.iOS 8 新引入的自制 framework 的方式来组织需要重用的代码，这样在链接 framework 后 app 和Widget就都能使用相同的代码. 包含Widget中数据请求和数据记忆其他能够复用的代码。

这也是我们一开始打算解决方式，但发现剥离这部分代码时间周期明显超过我们预期.所以在国际化处理上我们Widget独立做了一套国际化处理，它和端内在处理机制上并没有多大的不同：



Widget国际化处理


当然重点不再于它的实现，你可以发现我们Widget中国际化文本文件Locallizable.string命名加了一个"WG",这个问题是刚开始开发之初我们一直认为Widget作为端是独立于主应用程序的.所以当初理解为只有把这个文件命名为的“Locallizable.string”才是正常的能够被识别的，但我们调试时发现，Widget打包时会把这些国际化单独放到PlugIns文件下,这里给出一个简体中文全路径：


/private/var/mobile/Containers/Bundle/Application/61C637FF-B5BC-432A-ADD5-BA64EBFE98E8/MojiWeather.app/PlugIns/MojiWidget.appex/zh-Hans.lproj



根据这个路径你会发现文件时可以找到的，但调试时发现国际化取对应Key的值一直是取不到的，但我们任意非“Locallizable.string”时则是没有问题的，后来我们发现当我们打包在不同机型上测试这个问题时，如果“Locallizable.string”名称命名会导致调试时ok，而最终打包上会出现找不到对应key值得问题.这个原因到我写这篇blog一直没有找到具体的原因.所以我们给出解决方案是一定要和主应用程序“Locallizable.string”保持不同即可解决.

当然关于Widget中闪现的问题，因为我们Widget存在两个不同尺寸切换，导致这个问题很明显，处理方式自然是viewWillLoad方式中做好Widget高度在不同场景高度初始化就可以完美避免.这里就不做赘述.

如上只是我们解决Widget遇到一些大大小小的问题.解决问题方式虽然没有给出细节，但思路是有的.有不清楚可以文后评论@我即可..










App Extension Programming Guide: Today
 — Describes how to develop an app extension, which is an executable that provides functionality to other apps.
chenkai・ developer.apple.com
 →


iOS Human Interface Guidelines: App Extensions
 — Provides guidelines for designing the user interface of an iOS app.
chenkai・ developer.apple.com
 →


Pushing iOS
 — Here’s the stronghold and I’m the little bunny who can barely move around a sword going straight for it. If anyone sends me a picture of a bunny me that can’t move around a sword against a giant Apple stronghold castle… I’m putting it right here! Wind
chenkai・ jaymachalani.com
 →


ios - Get device current orientation (App Extension) - Stack Overflow
 — It gives me right orientation but still not get as device is LandscapeLeft or LandscapeRight as well as Portrait or PortraitUpsideDown.
chenkai・ stackoverflow.com
 →


ios - What is the best way to detect orientation in an app extension? - Stack Overflow
— What is the best way to detect a device's orientation in an application extension? I have had mixed results with solutions I've found on here:
chenkai・ stackoverflow.com
 →


ios - Detecting tap anywhere on widget? - Stack Overflow
 — I am trying to detect when a user taps anywhere within my Today Extension widget. Currently I have a tap gesture recognizer on the primary view which contains all the labels displayed within the widget. However, with this configuration, only taps on the
chenkai・ stackoverflow.com
 →


Why You Need to Develop a Widget for Your iOS (iPhone
 — One of the updates introduced with the launch of iOS 8 are long anticipated mobile widgets for the third-party apps for iPhone and iPad. Probably, the fact that Android devices have been hosting those little application components on their home screens fo
chenkai・ yalantis.com
 →

 推荐拓展阅读



版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        Swift 2.0学习笔记（Day5）——我所知道的标识符和关键字
﻿﻿Swift 2.0学习笔记（Day5）——我所知道的标识符和关键字 原创文章，欢迎转载。转载请注明：关东升的博客  好多计算机语言都有标识符和关键字，一直没有好好的总结，就是这样的用着，现在小小的整理一下Swift中的标识符和关键字。 什么是标识符呢？标识符就是给变量、常量、方法、函数、枚举、结构体、类、协议等由开发人员指定的名字。其实，构成标识符的字母是有一定规范的，Swift中命名规则是：区分大小写，Myname与myname是两个不同的标识符；标识符首字符可以以下划线（_）或者字母开始，但不能是数字；标识符中其他字符可以是下划线（_）、字母或数字。例如： userName、User_Name、_sys_val、身高等为合法的标识符，而2mail、room#和class为非法的标识符。 什么是关键字呢？关键字是类似于标识符的保留字符序列，由语言本身定义好的，不能挪作他用，除非用重音符号（`）将其括起来。Swift语言常见的关键字有以下4种。与声明有关的关键字：class、deinit、enum等。与语句有关的关键字：break、case、continue等。表达式和类型关键字：as、catch、dynamicType、false等。在特定上下文中使用的关键字：associativity、convenience、dynamic等。Swift中关键字是区分大小写的，所以class和Class是不同的，那么Class不是Swift的关键字。  欢迎关注关东升新浪微博@tony_关东升。关注智捷课堂微信公共平台，了解最新技术文章、图书、教程信息                 更多精品iOS、Cocos、移动设计课程请关注智捷课堂官方网站：http://www.zhijieketang.com 智捷课堂论坛网站：http://51work6.com/forum.php

版权声明：本文为博主原创文章，未经博主允许不得转载。

IOS高德地图开发


博客链接:www.goofyy.com/blog 
或者百度搜索 goofyy



玩了苹果原生地图，觉得IOS8的原生还是差了那么一点点，对比了一下腾讯的SDK和高德的SDK，还是觉得高德更碉些，第三方地图就先拿高德地图开刀了。
使用高德SDK，首先到高德官网注册一个开发者账号，获取开发者KEY。这些高德LBS开放平台都是有详细教程。小编编就不在这里赘余啦。首先是导入库和开发前简单设置。
高德官网下载高德开发的SDK导入。具体导入的库如下
1.引入地图库&搜索库

左侧目录中选中工程名，在 TARGETS->Build Phases-> Link Binary With Libaries 中点击“+”按钮，在弹出的窗口中点击“Add Other”按钮，选择解压后的 MAMapKit.framework 文件添加到工程中。

搜索库的添加方法同上。

2.引入地图库&搜索库

AMap.bundle资源文件中存储了定位、默认大头针标注视图等图片，可利用这些资源图片进行开发。

左侧目录中选中工程名，在右键菜单中选择Add Files to “工程名”…，从 MAMapKit.framework->Resources 文件夹中选择 AMap.bundle文件，并勾选“Copy items if needed”复选框，单击“Add”按钮，将资源文件添加到工程中。

3.引入系统库

左侧目录中选中工程名，在TARGETS->Build Settings-> Link Binary With Libaries中点击“+”按钮，在弹出的窗口中查找并选择所需的库（见下表），单击“Add”按钮，将库文件添加到工程中。

序号    框架       
1.	UIKit.framework	        2D、3D、Search
2.	Foundation.framework	2D、3D、Search
3.	CoreGraphics.framework	2D、3D、Search
4.	QuartzCore.framework	2D、3D
5.	OpenGLES.framework	3D
6.	CoreLocation.framework	2D、3D
7.	CoreTelephony.framework	2D、3D、Search
8.	SystemConfiguration.framework	2D、3D、Search
9.	libz.dylib	        2D、3D、Search
10.	libstdc++6.09.dylib	2D、3D、Search
11.	Security.framework	2D、3D
说明：

2D表示使用2D栅格地图需要的系统文件，3D表示使用3D矢量地图需要的系统文件、Search表示使用搜索库需要的系统文件。



SystemConfiguration.framework、CoreTelephonySecurity.framework、Security.framework 是为了统计app信息使用。
上面的内容来自高德LBS开发平台，(哈哈，都是重复内容，懒得自己写了，不重复造轮子)
建立桥接文件。创建oc的头文件。随便命名，然后左侧目录中选中工程名，在 TARGETS->Build Phases-> Swift Compiler - Code Generation -> Objective-C Briding Header 中输入桥接文件的路径。Command + b建立连接。 success后我们进入下一步小程序
高德地图显示

在Viewcontroller.swift文件里创建地图显示。


import UIKit

let APIKey = "ebcfb60e7224e45b7058a91cfcac023e"

class ViewController: UIViewController ,MAMapViewDelegate {

	
	override func viewDidLoad() {
        super.viewDidLoad()
		
         MAMapServices.sharedServices().apiKey = APIKey
        
        initMapView()
		
	}
	
	    func initMapView(){
        
         mapView = MAMapView(frame: UIScreen.mainScreen().bounds)
		 
        mapView!.delegate = self
        
        self.view.addSubview(mapView!)
		

}
这里遵循MAMapViewDelegate的代理协议,配置MAP的APIKEY为我们刚刚在高德官网申请的key，将地图的view加入到当前view，run。success。就可以看到高德地图，高德地图上帮我们自带了比例尺和指南针。是不是好简单。




逆地理编码 
所谓逆地理编码就是把经纬度转化为地理位置。


既然要获取地理的经纬度，那肯定用到定位CLLocation。还记得上一篇IOS原生地图的时候说过，IOS8把地图权限分成了两部分，根据使用情况，在Info.plist里面添加字段。


NSLocationWhenInUseUsageDescription  //用的时候获取位置

NSLocationAlwaysUsageDescription    //始终获取用户位置
逆地理编码的基本流程：


（1） 初始化主搜索对象AMapSearchAPI，并继承搜索协议 AMapSearchDelegate 。

（2） 构造 Request 对象，配置搜索参数。

（3） 通过主搜索对象以 Request 对象为参数，发起搜索。

（4） 实现搜索协议中对应的回调函数，通过解析 Response 对象获取搜索结果。
完整代码如下


import UIKit
 
let APIKey = "8a1383b14466a8dbf362f44357c496c0"
 
class ViewController: UIViewController ,MAMapViewDelegate, AMapSearchDelegate{
     
    var mapView:MAMapView?
    var search:AMapSearchAPI?
    var currentLocation:CLLocation?
 
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
         
        MAMapServices.sharedServices().apiKey = APIKey
         
        initMapView()
         
        initSearch()
    }
     
    func initMapView(){
         
        mapView = MAMapView(frame: self.view.bounds)
         
        mapView!.delegate = self
         
        self.view.addSubview(mapView!)
         
        let compassX = mapView?.compassOrigin.x
         
        let scaleX = mapView?.scaleOrigin.x
         
        //设置指南针和比例尺的位置
        mapView?.compassOrigin = CGPointMake(compassX!, 21)
 
        mapView?.scaleOrigin = CGPointMake(scaleX!, 21)
         
        // 开启定位
        mapView!.showsUserLocation = true
          
        // 设置跟随定位模式，将定位点设置成地图中心点
        mapView!.userTrackingMode = MAUserTrackingModeFollow
         
    }
     
    // 初始化 AMapSearchAPI
    func initSearch(){
        search = AMapSearchAPI(searchKey: APIKey, delegate: self); 
    }
     
    // 逆地理编码
    func reverseGeocoding(){
         
        let coordinate = currentLocation?.coordinate
 
        // 构造 AMapReGeocodeSearchRequest 对象，配置查询参数（中心点坐标）
        let regeo: AMapReGeocodeSearchRequest = AMapReGeocodeSearchRequest()
         
        regeo.location = AMapGeoPoint.locationWithLatitude(CGFloat(coordinate!.latitude), longitude: CGFloat(coordinate!.longitude))
         
        println("regeo :\(regeo)")
 
        // 进行逆地理编码查询
        self.search!.AMapReGoecodeSearch(regeo)
         
    }
     
    // 定位回调
    func mapView(mapView: MAMapView!, didUpdateUserLocation userLocation: MAUserLocation!, updatingLocation: Bool) {
        if updatingLocation {
            currentLocation = userLocation.location         
        }
    }
     
    // 点击Annoation回调
    func mapView(mapView: MAMapView!, didSelectAnnotationView view: MAAnnotationView!) {
        // 若点击的是定位标注，则执行逆地理编码
        if view.annotation.isKindOfClass(MAUserLocation){
            reverseGeocoding()
        }
    }
     
    // 逆地理编码回调
    func onReGeocodeSearchDone(request: AMapReGeocodeSearchRequest!, response: AMapReGeocodeSearchResponse!) {
        println("request :\(request)")
        println("response :\(response)")
         
        if (response.regeocode != nil) {
             
            var title = response.regeocode.addressComponent.city
             
            var length: Int{
                return countElements(title)
            }
             
            if (length == 0){
                title = response.regeocode.addressComponent.province
            }
            //给定位标注的title和subtitle赋值，在气泡中显示定位点的地址信息      
            mapView?.userLocation.title = title
            mapView?.userLocation.subtitle = response.regeocode.formattedAddress
        }
 
    }
}
到了这里一个高德SDK简单应用就完成了，下一篇。获取附近的兴趣点。


博客链接:www.goofyy.com/blog 
或者百度搜索 goofyy






版权声明：本文为博主原创文章，未经博主允许不得转载。

Android-ViewPager（PagerAdapter 实现）
1.回顾
  上篇学习了Fragment 的 使用和学习
2.重点
  （1）ViewPager 认识
  （2）将布局Layout 转为 View对象
  （3）PagerAdapter 实现
  （4）FragmentPagerAdapter 实现
  （5）FragmentStatePagerAdapter 实现
  （6）OnPageChangeListener 监听
3.ViewPager认识
    使视图 界面可以 滑动
 （1） PagerAdapter 数据源 List<View>

 （2） FragmentPagerAdapter  数据源  List<Fragment>  ：

        这种方式 将 fragment 全部加载到页面里了,操作的Activity 需要 继承 FragmentActivity

 （3） FragmentStatePagerAdapter  数据源 List<Fragment>
4.布局文件 转 View对象 
  （1）View.infalte() 
          在 Fragment 中使用过；比如

		View view1=View.inflate(this, R.layout.viewpager1,null);   

  （2）使用 getLatoutInflater()


	View lyInf=getLayoutInflater().from(this).inflate(R.layout.viewpager1,null);
	



5.PagerAdapter 实现 ViewPage
  5.1 效果图
                                                 

  5.2 Activity 布局文件实现
    外层是 ViewPager , 里层是 标题
 <android.support.v4.view.ViewPager
        android:id="@+id/main_viewpager"
        android:layout_marginTop="50dp"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        >
        
         <android.support.v4.view.PagerTabStrip
                        android:id="@+id/main_viewtabpager"
				        android:layout_width="wrap_content"
				        android:layout_height="wrap_content"
				        
				     >
         </android.support.v4.view.PagerTabStrip>
       
    
    </android.support.v4.view.ViewPager>

   5.3  新添ViewPager 布局文件

    在 Layout 文件夹下 ，新添加 四个 viewpager.xml （普通布局）布局：

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical" >

    <TextView
        android:id="@+id/tv_pager_one"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="第一个布局" />

    <Button
        android:id="@+id/btn_one_pager"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Fragment 加载ViewPager" />

</LinearLayout>



   5.4 PagerAdapter 实现

package com.example.Adapter;

import java.util.List;

import android.support.v4.view.PagerAdapter;
import android.view.View;
import android.view.ViewGroup;

public class MyPagerAdapter extends PagerAdapter {


	/*
	 * 使用 pagerAdapter  注意几点：
	 * 重写方法的时候是 含有 ViewGroup的方法 :
	 * 适合用在 使用 layout 布局实现
	 * instantiateItem(ViewGroup container, int position)
	 * destroyItem(ViewGroup container, int position, Object object)
	 * 
	 */
	private List<View> views;
	private List<String> titiles;
	
	public MyPagerAdapter(List<View> views,List<String> titles) {
		this.views=views;
		this.titiles=titles;
	}
	
	/**
	 * 返回 页卡 的数量
	 */
	@Override
	public int getCount() {
		// TODO Auto-generated method stub
		return views.size();
	}

	/**
	 *  判断 是 view 是否来自对象
	 */
	@Override
	public boolean isViewFromObject(View arg0, Object arg1) {
		// TODO Auto-generated method stub
		return arg0==arg1;
	}
	
	/**
	 * 实例化 一个 页卡 
	 */
     @Override
    public Object instantiateItem(ViewGroup container, int position) {
    	// 添加一个 页卡
    	 
    	 container.addView(views.get(position));
    	 
    	return views.get(position);
    }
	
	/**
	 * 销毁 一个 页卡
	 */
	@Override
	public void destroyItem(ViewGroup container, int position, Object object) {
		// 删除
		container.removeView(views.get(position));
	}

	/**
	 *  重写 标题的 方法
	 */
	@Override
	public CharSequence getPageTitle(int position) {
		// 给页面添加标题
		return titiles.get(position);
	}
	
}




    5.5  Activity 实现 
       （1） 控件初始化
       （2） 准备数据源
       （3）准备适配器
       （4）样式设置
       （5）设置适配器
       （6）ViewPager上的页面通过 view对象操作
       （7）例子：第一个页面上的按钮点击事件

	//页面数据源
	private List<View> views;
	
	//初始化页面
	private ViewPager main_viewpager;
	
	//添加 标题
	private PagerTabStrip main_viewtabpager;
	
	//标题数据源
	private List<String> titles;
	
	private Button btn_one_pager;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	  
		main_viewpager=(ViewPager) findViewById(R.id.main_viewpager);
		main_viewtabpager=(PagerTabStrip) findViewById(R.id.main_viewtabpager);
		
		//准备 标题数据源
		titles=new ArrayList<String>();
		titles.add("第一页面");
		titles.add("第二页面");
		titles.add("第三页面");
		titles.add("第四页面");
	
		
		//准备数据源
		views=new ArrayList<View>();
		View view1=View.inflate(this, R.layout.viewpager1,null);
		View view2=View.inflate(this, R.layout.viewpager2,null);
		View view3=View.inflate(this, R.layout.viewpager3,null);
		View view4=View.inflate(this,R.layout.viewpager4, null);
		views.add(view1);
		views.add(view2);
		views.add(view3);
		views.add(view4);


		//设置 标题样式
		main_viewtabpager.setBackgroundColor(Color.GREEN);
		main_viewtabpager.setDrawFullUnderline(false);
		main_viewtabpager.setTextColor(Color.RED);
		main_viewtabpager.setTabIndicatorColor(Color.BLACK);
		
		//创建 Adapter
		MyPagerAdapter pagerAdapter=new MyPagerAdapter(views,titles);
		
		//添加适配器
		main_viewpager.setAdapter(pagerAdapter);
		
		//通过View1来控制 viewPager上的控件，从而 来 操作
		btn_one_pager=(Button) view1.findViewById(R.id.btn_one_pager);
		btn_one_pager.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				// TODO Auto-generated method stub
				Toast.makeText(getApplicationContext(), "VerpagerTestActivity 执行了",Toast.LENGTH_SHORT).show();
				
			}
		});
		
		
	}
	


6.总结
   通过PagerAdapter 实现的 数据源是  List<View> ，而 操作 每个页面上的 控件 通过 每个 view对象 初始化控件 ，来操作；



版权声明：本文为博主原创文章，未经博主允许不得转载。

路径图形沿另一圆形或其他图形路径移动
路径图形沿另一圆形或其他图形路径移动





版权声明：本文为博主原创文章，未经博主允许不得转载。

Java 按照指定长度分割字符串（一种是纯英文字符串，一种是英汉混合的字符串）
最近在实现一个文稿导读功能时候用到字符串切割，简单说一下这个文稿导读，就是打开本地一个txt文件，展示在界面上，提供一个开始/暂停的button。开始，文本自动移动变红，速度自己可以控制，就是像歌词那样，一行一行的自动移动，变色的一行始终是展示的控件的中间。为什么用到字符串的切割呢？是因为不用分辨率和不同尺寸的屏幕显示字的个数是不一样的。在实现的时候我就想到根据展示控件（这里是自定义的TextView）的大小串来切割字符串的，以适应不同设备。在下一篇文章中实现这个“文稿导读”的功能，这一片文章先用来讲解切割字符串的方法；
从一个文本中取出来的字符串，可能是纯中文文本，也有可能是中英混合的。
纯中文文本的请情况下，使用一种比较容易理解的方式来实现：
	/**
	 * 按照指定长度切割字符串
	 * @param inputString	需要切割的源字符串
	 * @param length	指定的长度
	 * @return
	 */
	public static List<String> getDivLines(String inputString, int length) {
		List<String> divList = new ArrayList<>();
		int remainder = (inputString.length()) % length;
		// 一共要分割成几段
		int number = (int) Math.floor((inputString.length()) / length);
		for (int index = 0; index < number; index++) {
			String childStr = inputString.substring(index * length, (index + 1) * length);
			System.out.println(childStr);
			divList.add(childStr);
		}
		if (remainder > 0) {
			String cStr = inputString.substring(number * length, inputString.length());
			divList.add(cStr);
		}
		return divList;
	} 通用（中英混合或者纯中文，英文）的一种方式：
	/**
	 * 处理输入的字符串，将字符串分割成以byteLength为宽度的多行字符串。
	 * 根据需要，英文字符的空格长度为0.5，汉字的长度为2（GBK编码下，UTF-8下为3），数字英文字母宽度为1.05。
	 * @param inputString 输入字符串
	 * @param byteLength 以byteLength的长度进行分割（一行显示多宽）
	 * @return 处理过的字符串
	 */
	public static String getChangedString(String inputString, int byteLength) {
		String outputString = inputString;
		try {
			
			char[] chars = inputString.toCharArray();
			char[] workChars = new char[chars.length * 2];
			
			// i为工作数组的角标，length为工作过程中长度,stringLength为字符实际长度,j为输入字符角标
			int i = 0, stringLength = 0;
			float  length = 0;
			for (int j = 0; j < chars.length - 1; i++, j++) {
				
				// 如果源字符串中有换行符，此处要将工作过程中计算的长度清零
				if (chars[j] == '\n') {
					length = 0;
				}
				try {
					workChars[i] = chars[j];
					//对汉字字符进行处理
					if (new Character(chars[j]).toString().getBytes("GBK").length == 2 /*&& chars[j] != '”' && chars[j] != '“'*/) {
						length++;
						if (length >= byteLength) {
							if (chars[j + 1] != '\n') {
								i++;
								stringLength++;
								workChars[i] = '\n';
							}
							length = 0;
						}
					} else if (new Character(chars[j]).toString().getBytes("GBK").length == 1) {
						//对空格何应为字符和数字进行处理。
						if (chars[j] == ' ' ) {
							length -= 0.5;
						}else {
							length += 0.05;
						}
					}
				} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				stringLength++;
				length++;
				//长度超过给定的长度，插入\n
				if (length >= byteLength) {
					if (chars[j + 1] != '\n') {
						i++;
						stringLength++;
						workChars[i] = '\n';
					}
					length = 0;
				}
			}
			outputString = new String(workChars).substring(0, stringLength)/* .trim() */;
			System.out.println(outputString);
		} catch (Exception e) {
			// TODO: handle exception
			Log.e("TextViewHelper", e.toString());
		}
		return outputString;
	}
	
以上是我在自己项目中实际运用的，时间比较仓促，仅供自己来参考。读者在使用的时候可以根据自己的实际情况，选取适应自己的方式。
在解决这个问题的过程中，尝试着其他的一些方法，虽然没有实现，但是在解决问题的过程中感觉到，只要你想到的对字符串的操作，API里面基本都有，因为他们考虑到的很全面，对字符串的操作一般在文档中就有对应的API。多上网找资料，找不到就去在API中查找，问题总会有解决的方法。



版权声明：本文为博主原创文章，未经博主允许不得转载。

专访民生银行：CPOS平台如何从线下布局移动支付
专访民生银行：CPOS平台如何从线下布局移动支付打个小广告，欢迎各界英才加盟我行 呵呵摘要：民生银行用一年多时间打造了CPOS智能POS平台，支持所有支付方式，并计划从最擅长的线下切入移动支付。民生银行为什么要做这样事？如何从线下布局？CPOS未来还有哪些机会与风险？中午跟同事搜了一家只有五张桌的小餐馆，没想到最后居然也可以用支付宝结账。移动支付带来的便捷自不必赘述。互联网公司已做了多年的用户教育，并逐渐布局线下资源，搭建消费闭环。两大巨头从去年开始的线下实体店争夺战愈演愈烈。与此同时，业界有观点认为传统POS机的时代可能一去不复返，移动支付将代替刷卡。不过世事无绝对，银行也不是冥顽不灵的古董，他们已经开始有所行动，而且有着互联网公司所不具备的资源优势。为了了解CPOS平台的模式，以及如何从移动支付领域挖掘机会，我们采访了民生银行科技创新团队负责人王晴。 图：民生银行科技创新团队负责人王晴 民生银行的内部创新机制“银行业明显感受到了来自互联网的冲击，如何充分利用银行的自身优势并利用互联网思维和互联网技术去提升银行业务一直是我们探索和创新的方向。” 民生银行科技创新团队负责人王晴表示。王晴的团队隶属于民生银行总行科技开发部，主要负责民生银行平台级科技产品和创新型科技产品的研发。据王晴介绍，民生银行科技部有一套相对开放的内部创新机制，技术员工有机会获得所需的资金和资源去实践自己的创意。CPOS平台就是民生银行科技部孵化的成果之一。 图：CPOS样机（图源自CPOS官网）我们可以在 CPOS官网 看到这款产品的样机。据介绍，CPOS的核心是一个Android Pad，配备有磁条卡和IC卡的读卡器、热敏打印机、NFC、二维码扫描等外设；同时具有USB、COM、RJ11等多种接口；CPOS不需要电话线或者银行专线而是通过有线、Wi-Fi、3G等方式直接接入互联网。但这只是CPOS的形态之一。“CPOS并不是特指一款设备，而是一种设备的总和。我们并不设计或生产机具，我们只是制定机具规范，包括硬件质量规范、系统及应用规范等。规范是对全社会公开的，任何硬件制造商只要愿意都可以遵循民生的规范，并基于此设计和生产机具。只要是通过银行卡检测中心检测获得中国银联颁发的智能POS认证并通过民生银行检测符合民生银行的CPOS规范的机具都可以成为民生银行的CPOS”CPOS平台负责人王晴表示。这个模式有点像Qualcomm、Intel为ODM、OEM提供交钥匙方案。银行不可能自己开发生产硬件产品，而是将硬件规范提供给多年来一直为各大银行设计制造POS机的制造厂商。这些POS制造大厂也可以根据自己的判断基于这套规范设计制造不同形态的智能POS机，可能是大型桌面设备，也可能是小型手持设备，等等。除了硬件规范，CPOS开发团队还对原生Android操作系统进行了大量的裁剪和深度定制，并增加了CPOS所需的特有功能，消除了被root的可能性，并修补了大量原生Android存在的安全漏洞。只要具有Android App开发经验的程序员都能够轻松开发出基于CPOS的App，并通过API轻松完成对各种硬件的调用并整合银行卡支付的功能，并且同一个App在不同形态的CPOS上都能正常运行。 图：CPOS的UI设计然而让CPOS真正区别于传统POS和多媒体POS的，是CPOS具备一个开放平台和应用商店，就像Apple的App Store一样。第三方的软件公司或互联网公司通过简单的在线注册就可以成为CPOS平台的开发者，然后获取CPOS开发机并基于CPOS平台开发Ａpp。开发好的Ａpp在经过民生银行进行审核后即可上架到CPOS的应用商店中。部署了CPOS设备商户可通过CPOS的应用商店获取这些App。有人说银行卡就快消亡了，我们要进入无卡消费的时代了。王晴也同意这种可能性。但他认为，刷卡已经是人们习以为常的消费动作，而且抛开手续费和时尚的因素，刷卡的体验远比微信支付要简洁得多，银行卡不会轻易退出舞台，更何况有些地区才刚刚开始普及刷卡支付。不过无卡支付逐渐在一线城市成为更多尝鲜人群的选择，也是不争的事实。所以民生银行的做了一个很明智的选择：全部都支持。CPOS支持包括银行卡、闪付、微信、支付宝在内的几乎所有的支付方式，还可以受理商户自己发行的储值卡和各种购物卡。 图：CPOS的UI设计听到这里，自然产生了几个问题：民生银行为什么要做这样事？银行如何从线下布局移动支付？外界的POS机制造商和商户对CPOS是否存在需求？CPOS未来还有哪些风险？从线下逆流而上“我们注意到，现在各个领域的面向C端的互联网产品的竞争格局已经形成，很难打破。而我们不得不承认，在开发C端产品方面，银行无论是在基因上，技术上，效率上和场景研究的能力上跟互联网巨头相比都没有优势”王晴坦言，“但是同时我们也看到，在B端，尤其是实体商户，实际还处在一个相对蓝海的状态。而民生银行的小微业务在全国一向是做的最好的，我们覆盖300万小微商户，拥有一支庞大且优质的小微客户经理团队，对小微商户的需求和痛点有深刻的理解，这是我们的优势。所以我们希望能够扬长避短，从B端入手去打造一个互联网平台。”民生银行的这种模式与互联网公司截然不同。互联网公司的做法可以看做是以线上为起点，逐渐向线下延伸，民生银行的做法则是从相反的方向出发，而且在产品形态上他们的模式更重。王晴认为“轻模式和重模式是没有绝对好坏的，轻模式发展的快被颠覆起来也快，重模式发展慢，但是一旦模式成立，竞争壁垒也就自然铸就。重模式本身就是我们的基因，我们有那么多的分支机构和社区支行，以及地面服务团队，可以轻松搞定这些轻模式基因的公司听了就头痛的‘脏活累活’。更何况所有轻模式的产品都是以重模式的产品为基础设施的。如果没有智能手机，那些做App的互联网公司的发展又从何谈起呢？现在智能手机因为各种原因还无法满足商户的现实需要，导致商户无法获得高品质针对性的互联网服务，很多O2O场景无法闭环。需要有人站出来为商户和互联网公司提供一个比智能手机更好的获取和提供互联网服务的基础设施。我们愿意去做，而且就是现在。”站在“风口”上的CPOS做CPOS不是银行为了求变的“拍脑门”决策，更像是一种顺势而为的举动。首先移动支付是以手机为载体，使用的人越多，场景越广泛，传统POS机存在的必要性就越低。同时随着移动支付大举入侵线下，银行卡收单业务收费标准改革呼声越来越大，“拼费率”的市场竞争无法继续维系。POS制造商和POS机代理商也在寻求转机。“传统ＰＯＳ将会被智能ＰＯＳ所取代，并且要通过智能ＰＯＳ为商户提供更好的个性化的服务，这在ＰＯＳ机生产商和代理商那里是有共识的。因此我们现在推出CPOS平台与POS制造商和代理商是有合力的，POS制造商普遍愿意遵循我们的规范为我们定制CPOS，POS代理商也乐于与我们合作，帮我们推广CPOS”王晴表示。图：第三方软件开发商基于CPOS平台开发的商户App界面（数据为测试数据）机会与风险并存民生银行覆盖的小微商户涉及多个领域，利润较高的美容美发行业被作为试验田，在今年4月率先小范围部署了CPOS。王晴表示，“借助CPOS的开放平台，我们跟全国优秀的软件公司和互联网公司合作，不但为商户提供各种支付结算服务，还可以为商户提供包括进货、店铺经营、营销、工资代发、便民服务等各种服务。我们的目的不只是让商户用CPOS收钱，而是所有的经营活动都可以通过CPOS完成，还能帮商户获客引流。”如此看来，CPOS面向的不是取代商户收银台上的传统POS机，而是取代商户收银台上包括电脑在内的所有设备。王晴表示，“我们通过CPOS能够合法的掌握商户所有的经营数据，同时可以验证数据的真实性，然后基于这些数据我们就可以为商户提供定制化的金融服务，单从贷款的角度说，我们的授信成本就会极大的降低，风险控制能力又会极大地提升。”在问及CPOS的推广模式时，王晴表示，民生银行为商户提供CPOS是完全免费的，首批计划全国范围内至少免费部署10万台。当然，CPOS也需要面对来自内部和外部的挑战，比如银行自身业务、体制与行规，以及市场的不确定性。在经过近几个月的市场验证之后，民生银行将联合业内重量级合作伙伴以及投资机构和媒体召开CPOS开发者大会暨招商大会，从9月开始大会将在全国一线城市陆续举行。
iOS遍历数组相同值元素到另一数组中同一对象的子数组
saledGoodsArray数组中存储商品对象saledgoods，saledgoods有seatNo属性，将saledGoodsArray数组中saledgoods对象相同座位儿号的商品赋值给同一个人(personObject)的购买商品数组(purchasedGoodsArr)。
刚发现可以这样写，惭愧得紧！
  dataArray = [[NSMutableArray alloc] init];

    saledGoodsArray = [ShoppingCartDataCenter queryNoPayGoodsByFlightID:@"8815"];

    NSMutableDictionary *personObjectDics = [[NSMutableDictionary alloc] init];

    for (NSInteger i=0; i<saledGoodsArray.count; i++) {
        SaledGoods *saledgoods = [saledGoodsArray objectAtIndex:i];
        SCPersonObject * personObject = [personObjectDics objectForKey:[saledgoods seatNo]];
        if (!personObject) {
            personObject = [[SCPersonObject alloc] init];
            [[personObject purchasedGoodsArr] addObject:saledgoods];
            [personObjectDics setObject:personObject forKey:[saledgoods seatNo]];
        }else {
            [[personObject purchasedGoodsArr] addObject:saledgoods];
        }
    }

    for (SCPersonObject * personObject in [personObjectDics allValues]) {
        if ([personObject isKindOfClass:[SCPersonObject class]]) {
            [dataArray addObject:personObject];
        }
    }


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

cocos2dx 打包问题
Cocos2dx-3.4 打包成apx 
1. 要注意pro.android\jni\Android.mk

添加自己不是cocos2dx自己生成的ccp\ 
或者修改Android.mk
FILE_LIST := hellocpp/main.cpp  
FILE_LIST += $(wildcard $(LOCAL_PATH)/../../Classes/*.cpp)  LOCAL_SRC_FILES := $(FILE_LIST:$(LOCAL_PATH)/%=%)  
2. 要修改pro.android\src 

从如下路径copy过来

3. cocos2dx命名规则是 
必须是XXXX.XXXX.XXXX

4.虚拟机要勾上HOST USE GPU

5.或用其他虚拟机如 海马虚拟机

6.游戏过程中不黑屏的处理
//在src/org.coco2dx.cpp/AppActivity.java
public class AppActivity extends Cocos2dxActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
    }
}
7.AndroidManifest.xm中添加震动权限
  <uses-permission android:name="android.permission.VIBRATE" /> 
8.自动横向根据重力转变方向
android:screenOrientation="sensorLandscape"


            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

编程之类  数字号码《-》单词之间的转换
<pre name="code" class="cpp">/**
数字转换成单词，如1,0==》空格
2==》a或b或c
7==》p或q或r或s
*/


#include<iostream>
#include<vector>
using namespace std;
typedef struct NUM_WORD_
{
	int count;
	char word[4];
}NUM_WORD;
NUM_WORD GetWord(int num)
{
	NUM_WORD m_word;
	m_word.count=0;
    int i=0;
	switch(num)
	{
	case 0:
	case 1:
		m_word.count=1;
		m_word.word[0]=' ';
		break;
	case 2:
		m_word.count=3;
		for(i=0;i<3;i++)
			m_word.word[i]='a'+i;
		break;
	case 3:
		m_word.count=3;
		for(i=0;i<3;i++)
			m_word.word[i]='d'+i;
		break;
	case 4:
		m_word.count=3;
		for(i=0;i<3;i++)
			m_word.word[i]='g'+i;
		break;
	case 5:
		m_word.count=3;
		for(i=0;i<3;i++)
			m_word.word[i]='j'+i;
		break;
	case 6:
		m_word.count=3;
		for(i=0;i<3;i++)
			m_word.word[i]='m'+i;
		break;
	case 7:
		m_word.count=4;
		for(i=0;i<4;i++)
			m_word.word[i]='p'+i;
		break;
	case 8:
		m_word.count=3;
		for(i=0;i<3;i++)
			m_word.word[i]='t'+i;
		break;
	case 9:
		m_word.count=4;
		for(i=0;i<4;i++)
			m_word.word[i]='w'+i;
		break;
	}
	return m_word;
}
void GetValue(char*numStr,int pos,char* wordStr)
{
	
	if(pos>=strlen(numStr))
	{
		wordStr[pos]='\0';
		cout<<wordStr<<endl;
		return;
	}else{
        	NUM_WORD m1;
	        int num=(int)(numStr[pos]-'0');
 	        m1=GetWord(num);
	        int i=0;
	        for(i=0;i<m1.count;i++)
			{
		       wordStr[pos]=m1.word[i];
		       GetValue(numStr,pos+1,wordStr);
			}
	}
}
void Output(char*numStr)
{
	int pos=0;
	char*wordStr=new char[strlen(numStr)+1];
    
	GetValue(numStr,pos,wordStr);
   
	if(wordStr!=NULL)delete []wordStr;
}


int main()
{
	char*numStr="27";
    Output(numStr);
	return 0;
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

adb.exe 已停止工作 解决
http://pan.baidu.com/s/1eQfLGYY
用此链接下载的高人写的adb.exe

替换掉SDK  \sdk\platform-tools的adb.exe,即可。
引用自：http://bupt-roy.iteye.com/blog/1255109


使用以上的adb.exe之后发现真机连不上了，网上搜索才发现是adb.exe的版本太低
用cmd.exe命令行输入adb version 发现版本为：Android Debug Bridge version 1.0.26 
4.4的真机连不上，4.0以下可以
下载adb 1.0.31就可以下，下载地址：
http://download.csdn.net/download/peonycmd/6936291




版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS 多线程--基础

多线程：


在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。可以通过多种途径达到这个目的。


多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。


一、基本概念

1.进程


进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。


简单来说，进程是指在系统中正在运行的一个应用程序，每一个程序都是一个进程，并且进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。


2. 线程


线程，是程序执行流的最小单元线程是程序中一个单一的顺序控制流程。是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。


简单来说，1个进程要想执行任务，必须得有线程。

线程中任务的执行是串行的要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务也就是说，在同一时间内，1个线程只能执行1个任务由此可以理解线程是进程中的1条执行路径


3.多线程


多线程（multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。


原理：

同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
注意：多线程并发，并不是cpu在同一时刻同时执行多个任务，只是CPU调度足够快，造成的假象。

优点：

能适当提高程序的执行效率能适当提高资源利用率（CPU、内存利用率）

缺点：

1.开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能
2.线程越多，CPU在调度线程上的开销就越大


二、iOS开发中的应用

1.主线程


一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。


作用：

显示\刷新UI界面处理UI事件（比如点击事件、滚动事件、拖拽事件等）

注意：

刷新UI必须放在主线程别将比较耗时的操作放到主线程中耗时操作会卡住主线程，严重影响UI的流畅度

2.实现方案






版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS利用通知(NSNotification)进行传值


通知 是在跳转控制器之间常用的传值代理方式，除了代理模式，通知更方便、便捷，一个简单的Demo实现通知的跳转传值.
iOS通知传值的使用
输入所要发送的信息 ，同时将label的值通过button方法调用传递，
- (IBAction)buttonClick:(id)sender {
    //添加 字典，将label的值通过key值设置传递
    NSDictionary *dict =[[NSDictionary alloc] initWithObjectsAndKeys:self.textFieldOne.text,@"textOne",self.textFieldTwo.text,@"textTwo", nil];
    //创建通知
    NSNotification *notification =[NSNotification notificationWithName:@"tongzhi" object:nil userInfo:dict];
    //通过通知中心发送通知
    [[NSNotificationCenter defaultCenter] postNotification:notification];
    [self.navigationController popViewControllerAnimated:YES];
 
}
在发送通知后，在所要接收的控制器中注册通知监听者，将通知发送的信息接收
- (void)viewDidLoad {
    [super viewDidLoad];
    //注册通知
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(tongzhi:) name:@"tongzhi" object:nil];
 
}
- (void)tongzhi:(NSNotification *)text{
    NSLog(@"%@",text.userInfo[@"textOne"]);
        NSLog(@"－－－－－接收到通知------");
 
}
移除通知：removeObserver:和removeObserver:name:object:
其中，removeObserver:是删除通知中心保存的调度表一个观察者的所有入口，而removeObserver:name:object:是删除匹配了通知中心保存的调度表中观察者的一个入口。
这个比较简单，直接调用该方法就行。例如：
[[NSNotificationCenter defaultCenter] removeObserver:observer name:nil object:self];
注意参数notificationObserver为要删除的观察者，一定不能置为nil。



版权声明：本文为博主原创文章，未经博主允许不得转载。

Unity接入移动MM支付（Android）
移动没有用于Unity3D的移动MM支付SDK的接入，所以……
这样一来，你需要去官网下载IAP-SDK做成jar包供Unity调用：http://dev.10086.cn/iap/?action=down&areaid=1354082900
1、先要明确一点的是在Unity的Assets目录中你得有个Plugins/Android的目录，并且必须在Assets目录，否则无法将资源打包到PAK。此时，你可以尝试打一个apk的包，用压缩文件打开的目录结构是这样的：

为什么就这样了呢？我也想知道！这里记录一个路径，mac下找到Unity安装目录，右键Unity app 显示包内容：/Contents/PlaybackEngines/AndroidPlayer；Window下找到Unity安装目录：Unity\Editor\Data\PlaybackEngines\androidplayer。
2、那么我想你已经把SDK下载好了，我想你第一件事一定是先看它得接入文档咯，之后你得把它里面得Demo弄来测试一下吧？好我们生成了一个demo.apk，我用BetterZip打开是这样得：

注意红框中的内容，看到与Unity生成的APK（图一）有什么区别了吧？对，这些文件的缺失很可能就会导致让你抓狂的各种报错。比如什么什么“failed to find...”，或者官方的demo apk可以运行，而自己的apk老是报错的情况就要注意比较两者的差异了。最后我们再看看移动MM内购jar包：


看嘛，像这种移动MM内购支付SDK将资源放在了mmbilling的jar包当中了，导致Unity无法识别。所以我们要将这些必要的资源拷贝出来放在Plugins/Android对应的目录下面，一般的Plugins/Android都包含了如下目录：
a、assets
 资源目录，如上图的神马图标之类的资源；
b、bin/libs目录，由于不是做android开发的，傻傻分不清楚。说是用来放第三方jar包的，但是最后发现无论你将jar包放在bin目录，libs目录，甚至直接在Android根目录都可以。哎。。太没得节操了。最好将jar包放bin目录，资源（armeabi-v7a、x86）放libs目录。
c、res目录，又是拿来放资源的。。神马情况？让assets情何以堪。瞬间混乱了。不过我讲demo.apk中的res直接拷贝到Plugins/Android目录，让Unity打包是会报错的。。哎。。
d、AndroidManifest.xml这个文件你得放在Plugins/Android下吧。
好吧，至少我们把assets资源集成进来了吧。哦，对，还有就是libs目录里面得.so资源armeabi、x86等。看看吧：

我这里把demo.apk解包后的assets下面的所有资源都添加到Plugins/Android/assets目录，将libs里面得资源都照样添加到armeabi-v7a和x86目录了，这里直接将demo的armeabi目录下得东东添加到armeabi-v7a目录就好。当然我这里将所有得第三方jar包也放在libs目录了，如：mmbilling.3.1.7.jar，还有我自己写的jar包：


3、至于怎么接入，我想你至少要看看官方的android接入文档吧。详细接入流程：http://www.cnblogs.com/alongu3d/p/3627936.html
4、再一点，关于Unity与Android交互的。说实话真的不太懂。常规做法是这样得：
a、你得新建android项目，引入Unity的class.jar：/Contents/PlaybackEngines/AndroidPlayer/relase/bin
b、继承UnityPlayerActivity：

package com.vgame.plugins;

import android.os.Bundle;

import com.iap.cm.IAP_CM;
import com.unity3d.player.UnityPlayerActivity;

public class UnityActivity extends UnityPlayerActivity
{
	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);

		IAP_CM.onInit(this);
	}
}
Unity方面：


		using (AndroidJavaClass ac = new AndroidJavaClass ("com.unity3d.player.UnityPlayer"))
		{
			using (AndroidJavaObject ao = ac.GetStatic<AndroidJavaObject> ("currentActivity"))
			{
				ao.CallStatic ("init", "appid", "appkey", "Gameobject 接受消息的对象", "回调方法");
			}
		}
当然，你得在UnityActivity写上init方法并且是静态的。

可是，我不想这么干了，我不想继承UnityPlayerActivity，于是：

		using (AndroidJavaClass ac = new AndroidJavaClass ("com.iap.mm.IAPController"))
		{
			ac.CallStatic ("init", "appid", "appkey", "Gameobject 接受消息的对象", "回调方法");
		}
但是，很遗憾的是这样无法调用到init的，根本没反应。这是为什么呢？不知道。估计是using这活把ac给我回收了，好吧：


		AndroidJavaClass ac = new AndroidJavaClass ("com.iap.mm.IAPController");
		ac.CallStatic ("init", "appid", "appkey", "Gameobject 接受消息的对象", "回调方法");
成功了！当然你不要忘了将com.iap.mm.IAPController的工程打个jar包放在Plugins/Android/bin目录中哟！

5、至此，剩下的CopyrightDeclaration.xml、mmiap.xml、VERSION或者res里得文件要怎么打包进apk呢？
a、确保你已将demo里面得aseets和lib下面得文件都集成到Unity的Plugins/Android文件里面，打包生成apk，这里将你打包用到keystore保存到一个文件夹如：relase什么得，随便了，就是留着备用。
b、将apk后缀名改成zip,用压缩文件打开，我这里就用BetterZip了：


此时我们可以看到aseets和lib里面得资源已经打包到apk了。
c、将缺失的CopyrightDeclaration.xml、mmiap.xml、VERSION文件添加进来：


保存并将扩展名改回apk。这样得apk我想是无法安装到手机的，你说呢？所以有必要对apk重新签名，看这里：http://blog.csdn.net/h5q8n2e7/article/details/47837653如果你是window：http://blog.sina.com.cn/s/blog_13791f8000102v2ru.html
好啦！

版权声明：本文为博主原创文章，未经博主允许不得转载。

[置顶]
        Android学习笔记：Andorid网络请求框架Volley的使用（上）
   Volley框架是Google I/O 2013大会上发布的。Volley是Google针对Android平台上的网络通信库而诞生，该框架能使网络通信更快，更简单，更健壮。Volley的特点有：
Ⅰ:通信更简单更快捷
ll:Get,Post网络请求及网络图像进行高效异步处理
III:可以对多个网络请求进行优先级排序以级多级别取消操作
IV:网络请求缓存及与Activity生命周期进行联动，在Activity销毁的时候可以对网络请求进行取消操作，防止内存泄露。
 Volley的使用很简单：
1，下载Volley的jar包或是源代码，github地址：https://github.com/stormzhang/AndroidVolley
2，获取RequestQueue，一般我们是放到Application中进行初始化操作

3，实例化一个Request对象（StringRequest,JsonObjectRequest,JsonArrayRequest）

4，将Request加入RequestQueue即可。




首先学习的是最基础的StringRequest:

主页面布局文件：activity_main.xml


<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:layout_margin="10dp" >
    <Button
        android:id="@+id/get_btn"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:text="GET请求"
        android:textSize="16sp" 
        android:layout_marginTop="15dp"/>
    <Button
        android:id="@+id/post_btn"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:text="POST请求"
        android:textSize="16sp" />
</LinearLayout>


-------------请求操作------------------------

public class MainActivity extends Activity implements OnClickListener {
private Button getBtn, postBtn;


@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
getBtn = (Button) findViewById(R.id.get_btn);
postBtn = (Button) findViewById(R.id.post_btn);
getBtn.setOnClickListener(this);
postBtn.setOnClickListener(this);
}

@Override
public void onClick(View v) {
switch (v.getId()) {
case R.id.get_btn:// GET请求获取数据
getStringRequest();
break;
case R.id.post_btn:// POST请求获取数据
postStringequest();
break;
}
}


private void getStringRequest() {// 用GET方法使用字符串数据请求StringRequest
String url = "http://apis.juhe.cn/mobile/get?phone=134****4320&key=d6099881640aed5e0bacc058cfd4357b";//key值是在聚合数据上申请的api
StringRequest strRequest = new StringRequest(Method.GET, url, new Listener<String>() {
@Override
public void onResponse(String arg0) {// 请求成功
Toast.makeText(MainActivity.this, arg0, Toast.LENGTH_LONG).show();
}
}, new ErrorListener() {
@Override
public void onErrorResponse(VolleyError arg0) {// 请求失败
Toast.makeText(MainActivity.this, arg0.toString(), Toast.LENGTH_LONG).show();
}
});
strRequest.setTag("getLDM");
MyApplication.getRequestQueues().add(strRequest);
}

private void postStringequest() {// 用POST方法使用字符串数据请求StringRequest
String url = "http://apis.juhe.cn/mobile/get?";
StringRequest postRequest = new StringRequest(Method.POST, url, new Listener<String>() {
@Override
public void onResponse(String arg0) {
Toast.makeText(MainActivity.this, arg0, Toast.LENGTH_LONG).show();
}
}, new ErrorListener() {

@Override
public void onErrorResponse(VolleyError arg0) {

                      Toast.makeText(MainActivity.this, arg0.toString(), Toast.LENGTH_LONG).show();
}
}) {
@Override
protected Map<String, String> getParams() throws AuthFailureError {// getparams方法是Volley中使用POST请求数据时传递参数信息
Map<String, String> map = new HashMap<String, String>();
map.put("phone", "134****4320");
map.put("key", "d6099881640aed5e0bacc058cfd4357b");
return map;
}
};
postRequest.setTag("postLDM");
MyApplication.getRequestQueues().add(postRequest);
}
}






版权声明：本文为博主原创文章，未经博主允许不得转载。

Android中的SQLite的高级使用
SQLite在android实际开发中是基本上避免不了的，很多时候我们都会使用到他作为数据存储的一种手段。
比如，我们现在，一般打开app，不用有网络的一些操作，我们就可以给用户显示上次退出之前的最新的前二十条或者多少条数据，一些评论等等。我们就是可以使用SQLite来实现。思想是：每一次用户有刷新成功的操作，我们就保存本次刷新得到的前二十条（根据实际情况）数据，然后把相关数据保存本地，通过数据库去维护并且获取，这样子的用户体验就很好，因为不用打开APP需要有网络请求的数据成功之后才有东西显示出来。
我们本次聊聊的就是如何使用SQLite去保存数据。
首先需要了解一些关于SQLite的相关的东西，比如语法，它允许的字段类型等等（虽然SQlite是基本上可以说没有类型之分，但是还是需要了解的）
请看连接：http://blog.csdn.net/liweijie_chengxuyuan/article/details/47031163
 
其中最基本的增删吃、改差我这里就不提及了，跟大家分享一些比较高级一点的东西，比如拿出来的数据如何排序，怎么从一个地方拿从一个位置到另外一个位置的数据等等。这些我们都是可以使用得上的，比如，我们把某一类型的数据本地化了，使用SQLite保存，然后我们显示的时候，不可能一次性从本地获取完毕的是吧，所以呢，我们就是当用户下拉加载的时候，我们就去根据当前显示的list的数据的大小作为我们从数据库再拿数据的开始，然后一次再拿十五条数据（自己定），然后拿出来的数据需要按照一定的格式排好顺序这样。
下面是实例：
首先是建表，我这里建两个表，一个是Book，一个是Person，其中，Book的主键只有一个，使用自动生成的id作为主键，Person表的的主键是age+id(主要是为了测试)。
他的的创建表语句的使用时这样的：
数据库帮助类：，一般的数据库需要使用单利模式，因为很多时候数据库会有并发问题出现

package com.example.sqlite_demo.helper;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

public class MySqliteHelper extends SQLiteOpenHelper
{
	private static final String DB_NAME = "mydb";
	private static final int VERSION = 1;
	private static final String DROP = "DROP TABLE IF EXISTS ";
	public static final String BOOK_TABLE = "book";
	public static final String BOOK_PERSON = "person";

	private MySqliteHelper(Context context)
	{
		super(context, DB_NAME, null, VERSION);
		// TODO Auto-generated constructor stub
	}

	@Override
	public void onCreate(SQLiteDatabase db)
	{
		// TODO Auto-generated method stub
		db.execSQL(DROP + BOOK_TABLE);
		String CREATE_BOOK = "CREATE TABLE " + BOOK_TABLE + "( "
		    + "_id INTEGER PRIMARY KEY AUTOINCREMENT ,name TEXT, price INTEGER" + ")";
		db.execSQL(CREATE_BOOK);

		db.execSQL(DROP + BOOK_PERSON);
		String CREATE_PERSON = "CREATE TABLE " + BOOK_PERSON + " ("
		    + "name TEXT,age INTEGER,birthDay DATE,salary INTEGER,id INTEGER,PRIMARY KEY(age,id)" + ")";
		db.execSQL(CREATE_PERSON);
		Log.i("MySqliteHelper","创建表完成");
	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
	{
		// TODO Auto-generated method stub
		db.execSQL(DROP + BOOK_TABLE);
		db.execSQL(DROP + BOOK_PERSON);
		onCreate(db);
	}

	private static MySqliteHelper helper;

	/**
	 * 使用单例模式
	 * 
	 * @param context
	 * @return
	 */
	public static MySqliteHelper getInstance(Context context)
	{
		if (null == helper)
		{
			synchronized (MySqliteHelper.class)
			{
				if (null == helper)
				{
					helper = new MySqliteHelper(context);
				}
			}
		}

		return helper;
	}

}添加数据：
	// 增加
	public void addperson(Person per)
	{
		// 写入的时候需要确保是可以写进去的
		SQLiteDatabase db = mHelper.getWritableDatabase();
		db.execSQL("INSERT INTO " + MySqliteHelper.BOOK_PERSON + " values(?,?,?,?,?)", new Object[]
		{ per.getName(), per.getAge(), per.getBirthDay(), per.getSalary(), per.getId() });
	}

	// 增加
	public void addBook(Book b)
	{
		// 写入的时候需要确保是可以写进去的
		SQLiteDatabase db = mHelper.getWritableDatabase();
		db.execSQL("INSERT INTO " + MySqliteHelper.BOOK_TABLE +  "(name,price) values(?,?)", new Object[]
		{ b.getName(), b.getPrice() });
	}
这是TestSqlite，继承了AndroidTestCase的测试类中添加数据，注意，日期格式的那一栏的必须是像我那样，不能是“2015-1-1”之类的，然后，大家注意一下主键的问题，在Person表中，age+id在插入数据的时候是没有一个相同的，但是在Book表中，就可以有相同的数据，这就是主键的不同作用。

public void testAddDb() throws Exception
	{
		MySQLiteService service = new MySQLiteService(getContext());
		Person per = new Person("A", 22, "1993-04-20", 10, 1);
		Person per1 = new Person("B", 22, "1990-04-20", 109, 2);
		Person per2 = new Person("C", 22, "1996-04-20", 108, 3);
		Person per3 = new Person("D", 22, "1998-04-10", 107, 4);
		Person per4 = new Person("E", 22, "2000-04-20", 107, 5);
		Person per5 = new Person("F", 23, "2015-04-20", 104, 1);
		Person per6 = new Person("G", 24, "2014-04-20", 101, 1);
		Person per7 = new Person("H", 25, "2005-04-20", 100, 1);
		service.addperson(per);
		service.addperson(per1);
		service.addperson(per2);
		service.addperson(per3);
		service.addperson(per4);
		service.addperson(per5);
		service.addperson(per6);
		service.addperson(per7);

		Book b = new Book("1", 1);
		Book b1 = new Book("1", 1);
		Book b2 = new Book("2", 3);
		Book b3 = new Book("4", 1);
		Book b4 = new Book("5", 1);
		service.addBook(b);
		service.addBook(b);
		service.addBook(b1);
		service.addBook(b2);
		service.addBook(b3);
		service.addBook(b4);

	}
截图结果，对应两个表




关于删除更新那些操作大家可以看看我之前的blog，这里要介绍是高级一点的SQLite技能


按照我们需要的一些东西排序之后得到查找结果：比如，我需要按照生日的顺序，由小到大排序，就可以这样


	// 获取person，然后按出生日期排序
	public List<Person> getListPerson()
	{
		List<Person> mList = new ArrayList<Person>();
		SQLiteDatabase db = mHelper.getWritableDatabase();
		Cursor cursor = db.rawQuery("select * from " + MySqliteHelper.BOOK_PERSON + " ORDER BY "
		    + "birthDay" + " DESC", null);
		if (cursor.moveToFirst())
		{
			do
			{
				Person per = new Person();
				per.setAge(cursor.getInt(cursor.getColumnIndex("age")));
				per.setBirthDay(cursor.getString(cursor.getColumnIndex("birthDay")));
				per.setId(cursor.getInt(cursor.getColumnIndex("id")));
				per.setName(cursor.getString(cursor.getColumnIndex("name")));
				per.setSalary(cursor.getInt(cursor.getColumnIndex("salary")));
				mList.add(per);
			} while (cursor.moveToNext());
		}
		cursor.close();
		return mList;
	}
测试代码：
public void testOrderBy() throws Exception
	{
		MySQLiteService service = new MySQLiteService(getContext());
		List<Person> listPerson = service.getListPerson();
		for (Person per : listPerson)
		{
			Log.i(TAG, per.toString());
		}
	}
结果截图：

其中DESC是从大到小（日期的话是从进到远，向这里）ASC则是与DESC相反，这里不写实例



第二种需求：我们需要从我们的数据库查询数据，而不是全部查询，比如我一次需要查询二十条，假如数据库没有辣么多数据的时候，则是查找全部

首先，我们需要知道数据的、库有多少条数据
	//query count
	public int getPersonCount()
	{
		int count = 0;
		SQLiteDatabase db = mHelper.getWritableDatabase();
		Cursor cursor = db.rawQuery("select * from " + MySqliteHelper.BOOK_PERSON, null);
		count = cursor.getCount();
		cursor.close();
		return count;
	}
这样就可以获得了
现在，我们往数据库插入100条新数据

测试代码，需要保证的是age+id唯一：
	public void testAddDb() throws Exception
	{
		MySQLiteService service = new MySQLiteService(getContext());
		for (int i = 0; i < 100; i++)
		{
			Person per = new Person(i + "名字", i, "2015-08-30", i * 100, i);
			service.addperson(per);
		}
	}然后，这时候我们去获取数据，获取的数据的原则是，从哪一个位置开始，到哪一个位置结束
代码：
public List<Person> getListPersonByLimit(int start, int length)
	{
		List<Person> list = new ArrayList<Person>();
		SQLiteDatabase db = mHelper.getWritableDatabase();
		Cursor cursor = db.rawQuery(
		    "select * from " + MySqliteHelper.BOOK_PERSON + " limit " + String.valueOf(start) + ","
		        + String.valueOf(length), null);
		if (cursor.moveToFirst())
		{
			do
			{
				Person per = new Person();
				per.setAge(cursor.getInt(cursor.getColumnIndex("age")));
				per.setBirthDay(cursor.getString(cursor.getColumnIndex("birthDay")));
				per.setId(cursor.getInt(cursor.getColumnIndex("id")));
				per.setName(cursor.getString(cursor.getColumnIndex("name")));
				per.setSalary(cursor.getInt(cursor.getColumnIndex("salary")));
				list.add(per);
			} while (cursor.moveToNext());
		}
		cursor.close();
		return list;
	}
测试代码：
public void testLimit() throws Exception
	{
		MySQLiteService service = new MySQLiteService(getContext());
		Log.i(TAG, "数据库目前的长度大小" + service.getPersonCount());
		List<Person> listPerson = service.getListPersonByLimit(10, 19);
		Log.i(TAG, "获取的list的的长度大小" + listPerson.size());
		for (Person per : listPerson)
		{
			Log.i(TAG, per.toString());
		}
	}
截图结果：结果的意思就是从数据库的第十个开始去，去19条数据出来，假如没有19条数据，则取完


好了，终极的问题来了，就是假如，我需要查询从某一个位置开始的数据，差取20条，然后需要按照什么鬼排序，而且我查询的是条件是什么等等。
我们首先为了测试方便，就添加一些新的数据

public void testAddDb() throws Exception
	{
		MySQLiteService service = new MySQLiteService(getContext());
		for (int i = 0; i < 31; i++)
		{
			Person per;
			//保证日期格式正确
			if (i < 10)
			{
				per = new Person("liweijie", i, "2015-08-0" + i, i * 100, i + 300);
			} else
			{
				per = new Person("liweijie", i, "2015-08-" + i, i * 100, i + 300);
			}
			service.addperson(per);
		}
	}
现在，我们要获取二十条 名字叫liweijie的 ,id>300的，按照日期从近到远排列的一个list
代码实现：
	/**
	 * @param start
	 *          开始位置
	 * @param length
	 *          获取长度
	 * @param name
	 *          查询条件
	 * @param id
	 *          查询条件
	 * @param birthday
	 *          排序方式
	 * @return
	 */
	public List<Person> getPerson(int start, int length, String name, int id)
	{
		List<Person> list = new ArrayList<Person>();
		SQLiteDatabase db = mHelper.getWritableDatabase();
		Cursor cursor = db.rawQuery("select * from " + MySqliteHelper.BOOK_PERSON
		    + " where name = ? and id >=? ORDER BY birthDay DESC limit " + String.valueOf(start) + ","
		    + String.valueOf(length), new String[]
		{ name, String.valueOf(id) });
		if (cursor.moveToFirst())
		{
			do
			{
				Person per = new Person();
				per.setAge(cursor.getInt(cursor.getColumnIndex("age")));
				per.setBirthDay(cursor.getString(cursor.getColumnIndex("birthDay")));
				per.setId(cursor.getInt(cursor.getColumnIndex("id")));
				per.setName(cursor.getString(cursor.getColumnIndex("name")));
				per.setSalary(cursor.getInt(cursor.getColumnIndex("salary")));
				list.add(per);
			} while (cursor.moveToNext());
		}
		cursor.close();
		return list;
	}
测试daim:
public void testGetPerson() throws Exception
	{
		MySQLiteService service = new MySQLiteService(getContext());
		Log.i(TAG, "数据库目前的长度大小" + service.getPersonCount());
		List<Person> listPerson = service.getPerson(0, 20, "liweijie", 300);
		Log.i(TAG, "获取的list的的长度大小" + listPerson.size());
		for (Person per : listPerson)
		{
			Log.i(TAG, per.toString());
		}
	}

好了，写了一个下午，之后会在、继续跟大家分享






版权声明：本文为博主原创文章，未经博主允许不得转载。

Android布局特效（二）

public class MainActivity extends Activity {
AlphaAnimation animation_alpha;
RotateAnimation animation_rotate;
ScaleAnimation animation_scale;
TranslateAnimation animation_translate;
AnimationSet animationSet;
ImageView image;
DisplayMetrics displayMetrics;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
image=(ImageView)findViewById(R.id.imageview);
// image.setScaleType(ScaleType.FIT_XY);
initAnimation();
}
private void initAnimation() {
displayMetrics=new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);
//透明度控制动画效果 alpha
animation_alpha=new AlphaAnimation(0.1f,1.0f);
//第一个参数fromAlpha为 动画开始时候透明度
//第二个参数toAlpha为 动画结束时候透明度
animation_alpha.setRepeatCount(-1);//设置循环
animation_alpha.setDuration(5000);//设置时间持续时间为 5000毫秒

// 旋转效果rotate
animation_rotate = new RotateAnimation(0, -90,
RotateAnimation.RELATIVE_TO_PARENT, 0,
RotateAnimation.RELATIVE_TO_PARENT, 1);
 //第一个参数fromDegrees为动画起始时的旋转角度 //第二个参数toDegrees为动画旋转到的角度
 //第三个参数pivotXType为动画在X轴相对于物件位置类型 //第四个参数pivotXValue为动画相对于物件的X坐标的开始位置
 //第五个参数pivotXType为动画在Y轴相对于物件位置类型 //第六个参数pivotYValue为动画相对于物件的Y坐标的开始位置
// animation_rotate.setRepeatCount(-1);
animation_rotate.setDuration(3000);//设置时间持续时间为 5000毫秒

//尺寸伸缩动画效果 scale
animation_scale=new ScaleAnimation(0.1f,3.0f,0.1f,3.0f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
//第一个参数fromX为动画起始时 X坐标上的伸缩尺寸    
//第二个参数toX为动画结束时 X坐标上的伸缩尺寸     
//第三个参数fromY为动画起始时Y坐标上的伸缩尺寸    
//第四个参数toY为动画结束时Y坐标上的伸缩尺寸  
/*说明:
                   以上四种属性值    
     0.0表示收缩到没有 
     1.0表示正常无伸缩     
                  值小于1.0表示收缩  
                  值大于1.0表示放大
*/
//第五个参数pivotXType为动画在X轴相对于物件位置类型  
//第六个参数pivotXValue为动画相对于物件的X坐标的开始位置
//第七个参数pivotXType为动画在Y轴相对于物件位置类型   
//第八个参数pivotYValue为动画相对于物件的Y坐标的开始位置
animation_scale.setRepeatCount(-1);
animation_scale.setDuration(5000);//设置时间持续时间为 5000毫秒

//移动动画效果translate
animation_translate=new TranslateAnimation(0,-300,0,0);
//第一个参数fromXDelta为动画起始时 X坐标上的移动位置    
//第二个参数toXDelta为动画结束时 X坐标上的移动位置      
//第三个参数fromYDelta为动画起始时Y坐标上的移动位置 
//第三个参数toYDelta为动画结束时Y坐标上的移动位置 
// animation_translate.setRepeatCount(-1);//设置动画执行多少次，如果是-1的话就是一直重复
animation_translate.setDuration(3000);//设置时间持续时间为 5000毫秒

animationSet=new AnimationSet(true);

// animationSet.addAnimation(animation_alpha);//透明度
animationSet.addAnimation(animation_rotate);//旋转
// animationSet.addAnimation(animation_scale);//尺寸伸缩
// animationSet.addAnimation(animation_translate);//移动
image.startAnimation(animationSet);//开始播放
}
@Override
public boolean onCreateOptionsMenu(Menu menu) {
// Inflate the menu; this adds items to the action bar if it is present.
getMenuInflater().inflate(R.menu.main, menu);
return true;
}


}
    
        
版权声明：本文为博主原创文章，未经博主允许不得转载。

新浪微博之发现
您好。相信您对新浪微博界面有所了解。 
对此，我们需要对UITableView有所了解的。 下列我们通过一些代码来渐渐拓展我们的视野范围。




从界面可以看出上面是一个UINavigationBar和下面是一个UITabBar。至于这两部分,我会在后来把这小项目写上去。现在我们来了解下UITableView 的使用。
这是一个分组的列表 UITableViewStyleGroup 。

typedef NS_ENUM(NSInteger, UITableViewStyle) {
    UITableViewStylePlain,                  // regular table view
    UITableViewStyleGrouped                 // preferences style table view
};
我们需要对每一行的UITableViewCell进行布置。为了以后代码的维护行,我们需要对cell进行一定的封装。方便今后好维护代码。

首先我们需要创建两个简单的模型并继承NSObject ,一个是JHCommonGroup和JHCommonItem分别代表的所有对应的组和对应的行
里面拥有着自己的特有属性
JHCommonItem类：

@interface JHCommonItem : NSObject
/** 图标*/
@property(nonatomic,copy) NSString *icon;
/** 标题*/
@property(nonatomic,copy) NSString *title;
/** 子标题*/
@property(nonatomic,copy) NSString *subtitle;

+(instancetype)itemWithTitle:(NSString *)title icon:(NSString *)icon;
+(instancetype)itemWithTitle:(NSString *)title;
.m文件：


@implementation JHCommonItem
+(instancetype)itemWithTitle:(NSString *)title icon:(NSString *)icon
{
    JHCommonItem *item = [[JHCommonItem alloc] init];
    item.title = title;
    item.icon = icon;
    return item;
}
+(instancetype)itemWithTitle:(NSString *)title
{
    return [self itemWithTitle:title icon:nil];
}



JHCommonGroup类：

@interface JHCommonGroup : NSObject
/** 组头*/
@property (nonatomic,copy) NSString *header;
/** 组尾*/
@property (nonatomic,copy) NSString *footer;

/** 这组的所有行模型(数组中存放的都是JHCommonItem模型) */
@property (nonatomic,strong) NSArray *items;

+(instancetype)group;

另外我们还要创建一个JHCommonCell并继承UITableViewCell,如果需要在cell里面加入一些特殊的图标、文字需要调整其范围 -(void)layoutSubviews;

JHCommonCell类：

#import "JHCommonCell.h"
#include "JHCommonGroup.h"
#include "JHCommonItem.h"

@implementation JHCommonCell


+(instancetype)cellWithTableView:(UITableView *)tableView
{
    static NSString *ID = @"cell";
    JHCommonCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
    if (!cell) {
        cell = [[JHCommonCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:ID];
    }
    return cell;
}
- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    if (self) {
        // 设置标题的字体
        self.textLabel.font = [UIFont boldSystemFontOfSize:15];
        self.detailTextLabel.font = [UIFont systemFontOfSize:12];
    }
    return self;
}

-(void)layoutSubviews
{
    [super layoutSubviews];
    self.detailTextLabel.x = CGRectGetMaxX(self.textLabel.frame) +3;
}


-(void)setItem:(JHCommonItem *)item
{
    self.imageView.image = [UIImage imageNamed:item.icon];
    self.textLabel.text = item.title;
    self.detailTextLabel.text = item.subtitle;
}

@end



一些模型类定义好后，我们的工作还是需要放在控制器身上,由于我们定义了一个JHDiscoverViewController的控制器并继承至UITableViewController.所以内部已经帮我们设置好的代理和数据源方法(UITableViewDelegate,UITableViewDataSource), 还有还要了解@required和@optional的含义。

#import "JHDiscoverViewController.h"
#import "JHSearchBar.h"
#import "JHCommonCell.h"
#import "JHCommonItem.h"
#import "JHCommonGroup.h"

@interface JHDiscoverViewController ()
@property (nonatomic,strong) NSMutableArray *groups;

@end

@implementation JHDiscoverViewController

-(NSMutableArray *)groups
{
    if (_groups == nil) {
        self.groups = [NSMutableArray array];
    }
    return _groups;
}


- (id)init
{
    return [self initWithStyle:UITableViewStyleGrouped];
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.tableView.backgroundColor = JHColor(211, 211, 211);
    // 创建搜索框对象
    JHSearchBar *searchBar = [JHSearchBar searchBar];
    searchBar.width = 300;
    searchBar.height = 30;
    self.navigationItem.titleView = searchBar;
    
    // 初始化数据
    [self setupgroup];

}
-(void)setupgroup
{
    [self group0];
    [self group1];
    [self group2];
}
-(void)group0
{
    JHCommonGroup *group = [JHCommonGroup group];
    [self.groups addObject:group];
    JHCommonItem *hotStatus = [JHCommonItem itemWithTitle:@"热门微博" icon:@"hot_status"];
    hotStatus.subtitle = @"笑话，娱乐，神最右都搬到这啦";

    
    JHCommonItem *findPeople = [JHCommonItem itemWithTitle:@"找人" icon:@"find_people"];
    findPeople.subtitle = @"名人、有意思的人尽在这里";
    
    group.items = @[hotStatus, findPeople];
    
}
-(void)group1
{
    
    JHCommonGroup *group = [JHCommonGroup group];
    [self.groups addObject:group];
    
    // 2.设置组的所有行数据
    JHCommonItem *gameCenter = [JHCommonItem itemWithTitle:@"游戏中心" icon:@"game_center"];
    JHCommonItem *near = [JHCommonItem itemWithTitle:@"周边" icon:@"near"];
  
    JHCommonItem *app = [JHCommonItem itemWithTitle:@"应用" icon:@"app"];
    
    group.items = @[gameCenter, near, app];
}

-(void)group2
{
    JHCommonGroup *group = [JHCommonGroup group];
    [self.groups addObject:group];
    
    
    // 2.设置组的所有行数据
    JHCommonItem *video = [JHCommonItem itemWithTitle:@"视频" icon:@"video"];
    JHCommonItem *music = [JHCommonItem itemWithTitle:@"音乐" icon:@"music"];
    
    JHCommonItem *movie = [JHCommonItem itemWithTitle:@"电影" icon:@"movie"];

    JHCommonItem *cast = [JHCommonItem itemWithTitle:@"播客" icon:@"cast"];
    cast.subtitle = @"(10)";
    JHCommonItem *more = [JHCommonItem itemWithTitle:@"更多" icon:@"more"];
    
    group.items = @[video, music, movie, cast, more];
}


- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    return self.groups.count;
}

-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
     JHCommonGroup *group = self.groups[section];
     return group.items.count;
}


- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
{
    JHCommonCell *cell  = [JHCommonCell cellWithTableView:tableView];
    JHCommonGroup *group = self.groups[indexPath.section];
    //传递模型数据
    cell.item = group.items[indexPath.row];
    return cell;
}

这只是一个简单的界面，还可以再进行一个维护,如果您有什么自己的想法，请告诉我，再次感谢 !!




版权声明：本文为博主原创文章，未经博主允许不得转载。

Makefile容易犯错的语法（不懂这些完全没法做工程）
1.引言 
最近学习android的Build系统，接触最多的自然就是Makefile语法，发现很多容易出错的地方，不避开这些错误语法没法真正了解Makefile的内涵，下面就介绍遇到的一些让人困惑的语法错误
2.列举容易犯错的地方

ifeq条件判断

ifeq($(fro),no)
endif

多么简单的语法，但是执行会报错如下：
Makefile:2: *** missing separator.  Stop.
原因： 
ifeq和左括号’(‘之间是必须有空格的。

shell脚本的使用 
我们知道Makefile中是可以使用shell脚本的，但是具体要在哪里使用呢？答案是当且仅当在Command里面，什么事command？我们知道Makefile的主要规则如下：

target:pre
    command
上面所说的就是命令行command。 
下面举例说明一错误情况，加深对于本条内容的理解：
all:
        for dir in $(MODULES);do\
        (cd $${dir};$(MAKE) all); \
        done
        $(shell echo "xxx")

执行结果：
xxx
make: xxx: Command not found
make: *** [all] Error 127

原因：从错误提示来看，编译器将xxx看做了shell脚本，为什么会如此？要理解这个就需要了解Make内嵌函数的工作原理，其实说来也是很简单的，引用Makefile手册里面的话就是：GUN make的函数提供了处理文件名、变量、文本和命令的方法，可以再需要的地方调用函数来处理指定的文本，函数在调用它的地方被替换为它的处理结果，函数调用（引用)和变量引用的展开方式相同。
怎么样，明白了吧，函数会直接被原地展开的呀。举例来说，$(shell echo “xxx”)，shell函数的调用会被展开成：xxx,也就是，上面的Makefile代码其实被展开成这样：
all:
        for dir in $(MODULES);do\
        (cd $${dir};$(MAKE) all); \
        done
        xxx

这样编译器自然会提示找不到xxxshell命令喽！！
为了测试是否真的明白上面的描述，出个题目：
fro := no
ifeq ($(fro),no)
$(shell echo "xxx")
endif
MODULES = ant bee
all:
        for dir in $(MODULES);do\
        (cd $${dir};$(MAKE) all); \
        done
        $(shell echo "xxx")

这样子编译会通过么？那改成下面这样呢？
fro := no
ifeq ($(fro),no)
$(shell echo "xxx" >> test.mk)
endif
MODULES = ant bee
all:
        for dir in $(MODULES);do\
        (cd $${dir};$(MAKE) all); \
        done
        $(shell echo "xxx")

如果你理解了前面叙述的规则，自然会知道第一种情况是错误的，第二种情况是正确的。原因不再解释。
3.shell变量和Makefile变量
细心的读者在看上面代码的时候不知道是不是有疑问，为什么cd $$dir会有两个$符号呢？如果仅仅使用一个$符号会怎么样呢?下面来解答。
这条在网上有很多的介绍了，稍微说明一下，我们知道Makefile可以定义自己的变量，我们姑且成为Makefile变量，而且Makefile中可以使用shell脚本，如果shell脚本中又存在shell变量，编译器如果区分上面两种变量呢？看到这里你应该想到了，Makefile变量使用方式：(xxxx)，而shell变量的使用方式是：(xxxx)，而shell变量的使用方式是：$(xxxx)。
如果我们将上面的cd $$(dir)改为cd $(dir)，执行结果如下：
for dir in ant bee;do\
        (cd ;make all); \
        done

编译器展开变量的时候(dir)当做是Makefile变量，而Makefile中又没有定义这个变量，那么就是cd到空目录喽！！如果是cd(dir)当做是Makefile变量，而Makefile中又没有定义这个变量，那么就是cd 到空目录喽！！如果是cd $(dir)，编译器展开变量的时候就当做是shell变量，结果就是成功的。
4.Makefile执行流程（也是很重要的呀）
了解make如何解析makefile文件是非常重要的，GUN make的执行过程分为两个阶段：

读取所有的makefile文件，内建所有变量/函数，并建立目标和依赖之间的依赖关系
根据第一个阶段建立的依赖关系，决定重构哪些目标，并执行命令进行重建目标

了解make执行过程的两个阶段是非常重要的，它帮助我们更深入的了解执行过程中变量以及函数是如何被展开的。变量和函数的展开问题是书写Makefile时容易犯错和引起大家迷惑的地方，本节将对这些不同的结构的展开进行简单的总结（明确变量和函数的展开阶段，对正确使用变量非常有帮助）。
首先明确一个概念：在make执行的第一个阶段如果变量和函数被展开，那么称此展开是立即的，此时所有的变量和函数被展开在需要构建的结构链表的对应规则中，其它展开称为延后的，这些变量和函数延迟到某些规则需要使用时或make第二阶段展开。

条件语句的展开 
 -所有使用到条件语句在产生分支的地方，make会根据预设条件将正确的分支展开，就是说条件分支的展开是立即的，其中包括ifdef、ifeq、ifndef、ifneq所确定的分支命令。
规则的展开

IMMEDIATE : IMMEDIATE ; DEFERRED
DEFERRED
其中规则中的目标和依赖如果引用其他变量，则被立即展开。而命令中的引用会延迟展开。
有了前面的基础，下面引用make手册中的执行流程： 

下面举个例子，从侧面验证上面的论述：
fro := no
ifeq ($(fro),no)
$(info 'xxx')
endif
MODULES = ant bee
droid:
all:
        for dir in $(MODULES);do\
        (cd $${dir};$(MAKE) all); \
        done
droidcore:
        echo "come into droidcore"
droid:droidcore

$(info 'yyy')

$（info ‘yyy’)函数是被立即展开的，所以会先输出这两句，才开始构建目标。 
输出如下：
'xxx'
'yyy'
echo "come into droidcore"
come into droidcore

5.目标的重复定义 
从上面的代码我们发现droid被定义了两次，这是允许的

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

TextWatcher限制字数，避免栈溢出

TextWatcher介绍
TextWatcher有三个方法：


public void beforeTextChanged(CharSequence s, int start, int count, int after)
 start ：代表当前光标在第几个位置（编程语言中通常第一个是0），或者要从第几个位置开始插入
 after ：代表本次要插入几个位置
 count ：不明确


public void onTextChanged(CharSequence s, int start, int before, int count)
 start：代表当前光标在第几个位置，或者要从第几个位置开始插入
 count：代表本次要插入几个位置
 before：不明确


public void afterTextChanged(Editable s)


具体使用可以参考Demo







TextWatchr使用Demo

    private TextWatcher mTextWatcher2 = new TextWatcher() {
        private int editStart;
        private int editEnd;
        private CharSequence temp;
        private int end;
        // 之前总字数
        private int before;
        // 插入的位置（编程语言中初始都为0）
        private int insertCur;
        // 最大字数
        private int max = 10;
        public void afterTextChanged(Editable s) {
            editStart = inputText.getSelectionStart();
            editEnd = inputText.getSelectionEnd();
            System.out.println("kk after: editStart=" + editStart + ",editEnd=" + editEnd);
            if (temp.length() > 10) {
                // s.delete(editStart - 1, editEnd);
                int end2 = inputText.getSelectionEnd();
                System.out.println("kk delete end=" + end + ", end2=" + end2);
                int st = insertCur + max - before;
                int ed = editEnd;
                s.delete(st, ed);
                inputText.setTextKeepState(s);
            }
        }
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            before = inputText.getText().toString().length();
            System.out.println("kk beforeTextChanged count=" + count + ", start=" + start
                            + ", after=" + after);
        }
        public void onTextChanged(CharSequence s, int start, int before, int count) {
            temp = s;
            end = start + count - 1;
            insertCur = start;
            System.out.println("kk onTextChanged count=" + count + ", start=" + start + ", before="
                            + before);
        }
    };  



Demo分析：
一开始使用// s.delete(editStart - 1, editEnd); 这个方法去删除多余的字数，但是当输入字数较多时，会出现StackOverFlow异常。导致栈溢出。
因为// s.delete(editStart - 1, editEnd);是一个字一个字删除，每删除一个字又会重新进入这个类，当要删除字数较多时，就会造成app奔溃。


新的方法，采用一次删除的方式，  int st = insertCur + max - before;
  int ed = editEnd;  s.delete(st, ed);
Editable的删除方式为前闭后开区间，delete[st--ed). 
st为第一个删除的位置，表达式为：要插入的位置 +　最大字数　－　已有的字数。int st = insertCur + max - before;
ed为光标的位置。


比如，已有５个字符（abcde），在５的位置（0为第一个）插入８个字符（ABCDEFGH），最大长度为１０个字符：
abcdeABCDEFGH  
则删除[10，13)  其中10=５ +　１０　－５，13=光标的位置。


又比如，已有5个字符（abcde）,在3的位置（0为第一个）插入8个字符（ABCDEFGH）,最大长度为10个字符：
abcABCDEFGHde 
则删除[3+10-5,11).

版权声明：本文为博主原创文章，未经博主允许不得转载。

swift详解之十一------------协议、委托(代理)模式
协议、委托(代理)模式
注：本小节总结协议以及依靠协议实现委托，这将在以后经常被使用。是一个非常重要的模块

看下官方的定义：协议定义了一个蓝图 ， 规定了用来实现某一特定工作或者功能所必须的方法和属性，类、结构体、或者枚举类型都可以遵循协议， 并提供具体实现来完成协议定义的方法和功能 。 任意能够满足协议要求的类型都被成为遵循了这个协议
1、协议的语法
协议的关键字：protocol 
协议的语法：
protocol Pro1{
    //这里定义属性或者方法
}
要使一个类或者结构体遵循某个协议 ， Class1: Pro1 只需要冒号加上协议名称就可以了 。 这时候这个类就必须实现协议中的属性和方法 。（可选的可以不实现，后面会说）
2、 协议中对属性和方法的使用

对属性的使用 
如果一个协议中定义的变量是可读可写的 那么遵循这个协议的必须是可读可写 ，也不能是常量 ，如果协议是只读的 ， 实现者可以是只读 也可以是可读可写 
在协议中使用类型属性 总是使用static

protocol Pro1{
    var name:String{set get}  //可读可写
    var age:Int { get }  //只读属性
    static var status:Int {set get}   
}
//遵循协议
struct Struct1 : Pro1 {
    private var _name = ""
    var name:String   {
        set{
           _name = newValue
        }

        get{
            return _name
        }
    }
    var age = 18 //可以声明为可读可写的
    static  var status = 1  //类型方法。
}

class Class1: Pro1 {
    var name = "class"
    var age:Int{ return  19 } //也可以是只读
    static var status = 0
}
这里可以看到遵循者实现协议的集中方式，包括可读可写的和只读的。注释非常清晰，就不再赘述。

对方法的使用 
定义一些方法让但是不需要方法体 ， 让实现者去实现 。跟其他语言的接口差不多 。可以定义可变参数方法 ， 但是不支持默认参数方法 

在协议中你可以定义实例方法 ， 也可以定义类方法 ，其方法和属性定义差不多。
protocol MethodPro{
    func plus(a:Int , b:Int)->Int
    static func toUpper(str:String)->String
}

class MethodClass: MethodPro {

    func plus(a: Int, b: Int)->Int {
        return a + b
    }
    class func toUpper(str: String)->String {
        return str.uppercaseString
    }
}
很简单的例子说明下 ， 在协议中用static 在实现类里可以用static 或者 class

在协议中使用mutating 变异方法 。 

我们都知道，在结构体和枚举这种值类型的实例方法中 ， 不能对自己的变量进行操作 ， 如果一定要操作 ，就需要生命成变异方法 。 所在在协议中有时候也需要声明成变异方法让结构体或者媒体去实现 。（类实现的时候不需要加mutating）
protocol MulPro{
    mutating func toggle();
}


enum Tog:MulPro{
    case On , Off

    mutating func toggle() {
        switch self {
        case On:
            self = Off
        case Off:
            self = On
        }
    }
}

var t=Tog.Off
t.toggle()
print(t) //Tog.On
t.toggle()
print(t) //Tog.Off
注释很清楚就不用过多解释了 

协议中的构造器 

协议也可以要求自己的遵循者实现指定的构造器。 
所以在协议中也可以这么写，
protocol A{
    init(val:Int)
}
实现这个协议的必须有这样的构造器，可以是指定构造器或者便利构造器，都必须加上required 修饰符 ，这样 在所以继承这个类的子类也都必须实现这个构造器。(关于各种构造器的解释 看我以前的构造过程那个文章)
class B: A {
    required init(val:Int){

    }
}
注：如果类已经标记为final ，则不需要required修饰符 ，final类不能有子类
如果在协议中定义的是一个可失败构造器，那么在遵循者中必须实现可失败构造器 后者 非可失败
协议可以当做一个类型来时候 ， 调用调用协议的方法调用的是其实现类的方法
3、可选协议
有时候我们需要在协议中定义的方法 ， 有得遵循者需要实现 ， 有得不是必须去实现的。这时候就可以使用可选类型。
可选协议只能在含有 @objc 前缀的协议中生效，而且可选协议只能被类去实现 。 
@objc protocol Op{
    optional var name:String{set get}  //可选类型
    optional func play()
    var age:Int{get}
}
这个协议定义了一个可选属性和一个可选方法还有一个age属性 ， 在实现他得类中只有age是必须实现的 。其他两个都是可选的 。
4、委托(代理)模式
protocol SayHelloDelegate{
    func sayHello(name:String);
}

class ClassA {

    var delegate:SayHelloDelegate?
    var name = "lucy"
    func play(){
        delegate?.sayHello(name);
    }
}


class ClassB:SayHelloDelegate {
    var name="lily"
    func sayHello(name:String) {
        print("\(name) 请 \(self.name) 帮她 say Hello");
    }
}
我们这里定义了一个协议 ，有个很简单的方法，sayHello  ，在A中声明了这个协议变量 ，使用了其方法 ，但这个方法却交给B去实现 。这就是一个很简单的代理模式 
var ca = ClassA();
var cb = ClassB()
ca.delegate = cb
//B代理A去实现方法
ca.play(); //lucy 请 lily 帮她 say Hello
这是一个很简单的例子 ，但这个模式一会肯定会有很复杂的用法 
5、协议中添加扩展
扩展用extension 关键字 ，后面应该会加上这个的讲解 

对类扩展实现别的协议 

protocol HTMLFormat{
    func asHtml(str:String)->String
}

//可以对ClassB扩展实现协议
extension ClassB:HTMLFormat{
    func asHtml(str: String)->String {
        return "<html>\(str)</html>"
    }
}
这里我们让我们前面看得ClassB 再次实现这个协议 。然后他就一共实现了两个协议 ， 一个sayHello 一个 hmtl的 
var cb1 = ClassB();
cb1.asHtml("dog") //<html>dog</html>
cb1.sayHello("aaa") //aaa 请 lily 帮她 say Hello
这时候这两个方法就都可以用了 
当然我们的协议也是可以继承的 。这里就不再示例。

类专属协议

protocol   C : class{
    func say();
}

class D: C{
     func say(){
        print("hello word")
    }
}
看一看知道怎么回事就行了，就是在结构体和枚举里面不能用得协议

协议合成 


protocol N{

    var age:Int{set get}
}

class F:M,N {
    var name = "zhangsan"
    var age = 18
}
这里我们定义了两个协议 ，F 遵循了这两个协议 ，这时候 我们有个方法需要传入的参数类型是遵循了这两个协议的实例
func happy(mn:protocol<M,N>){
    print("\(mn.name) 今年 \(mn.age) 岁了，非常开心！！")
}

var f=F()
happy(f) //zhangsan 今年 18 岁了，非常开心！！
这里F是满足这两个协议的 

检查协议的一致性 

你可以使用 is as? as 来检测摸个实例是否遵循某个协议 
print(f is M)  //true
let c = f as M
print(c) //F
关于is ，as 等得用法 可以看上一节类型转换 

协议扩展 

extension M{
    func sayGoodBye(){
        print("good-bye")
    }
}
在扩展协议中提供默认实现 ，如果在遵循者中实现了此协议，则使用遵循者中的实现 

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

PullToRefreshListView进阶（五）----->上下刷新、上拉加载

依赖库：

先看服务端的代码（对象封装类和servlet类）
ShopInfo.java（get、set、构造器、toString方法省略）
private String name;
private String img;ShopListServlet.javapackage com.atguigu.dianpin_server.servlet;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.gson.Gson;

/**
 * 获取分页ShopList的json字符串
 */
public class ShopListServlet extends HttpServlet {
	private List<ShopInfo> infos;

	protected void doGet(HttpServletRequest request,
			HttpServletResponse response) throws ServletException, IOException {

		init();

		// 得到start和count的请求参数
		int start = Integer.parseInt(request.getParameter("start"));
		int count = Integer.parseInt(request.getParameter("count"));
		// 如果start太大, 就返回一个空串
		// 15 start=15
		if (start >= infos.size()) {
			response.getWriter().write("");
			return;
		}
		// 从集合中取当前请求页的数据集合
		List<ShopInfo> data = new ArrayList<ShopInfo>();

		// 11 start=10&count=5
		if (start + count > infos.size()) {
			count = infos.size() - start;
		}
		for (int i = 0; i < count; i++) {
			data.add(infos.get(start + i));
		}

		// 转换为json字符串
		String json = new Gson().toJson(data);

		// 写到客户端
		response.setContentType("text/json;charset=utf-8");
		response.getWriter().write(json);
		// [{"name":"商铺名称1", "img":"f1.jpg"},{"name":"商铺名称2", "img":"f12.jpg"}]
	}

	public void init() {

		if (infos == null) {
			infos = new ArrayList<ShopInfo>();
			// 得到/image的真实路径
			String imagesPath = getServletContext().getRealPath("/image");
			// 得到路径对象
			File dirFile = new File(imagesPath);
			// 得到所有图片file对象
			File[] files = dirFile.listFiles();
			// 遍历
			for (int i = 0; i < files.length; i++) {
				// 将图片信息封装为一个shopinfo对象, 并保存到集合中
				String imageName = files[i].getName();
				String name = "商铺名称 " + (i + 1);
				infos.add(new ShopInfo(name, imageName));
			}
		}
	}
}
--------------------------------------------分割线-------------------------------------------------------------------
看android代码
先贴出布局来
activity_main.xml
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent" >
    
    <com.handmark.pulltorefresh.library.PullToRefreshListView
        android:id="@+id/lv_main"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
    
    <ProgressBar
        android:id="@+id/pb_main"
        style="?android:attr/progressBarStyleLarge"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" 
        android:layout_gravity="center"/>

</FrameLayout>list_item.xml<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="100dp"
    android:orientation="horizontal"
    android:gravity="center_vertical">

    <com.android.volley.toolbox.NetworkImageView
        android:id="@+id/iv_img"
        android:layout_width="90dp"
        android:layout_height="90dp"/>

    <TextView
        android:id="@+id/tv_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="描述文本" 
        android:layout_marginLeft="20dp"
        android:textSize="20sp"/>
</LinearLayout>
listview_foot.xml<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal" 
    android:gravity="center"
    android:clickable="false"
    android:focusable="false">
    <ProgressBar
        android:id="@+id/pb_foot"
        style="?android:attr/progressBarStyle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"/>
    <TextView
        android:id="@+id/tv_foot"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="正在加载中..." />
</LinearLayout>
<!-- 
	1. 如果还有更多数据, 它就会显示
	2. 如果没有更多数据: 隐藏ProgressBar, 更新TextView的文本
 -->



ShopInfo.java（get、set、构造器、toString方法省略）
private String name;
private String img;
VolleyTool.java（框架的工具类）

package com.atguigu.day03_test;
import android.content.Context;
import android.graphics.Bitmap;
import android.support.v4.util.LruCache;
import com.android.volley.RequestQueue;
import com.android.volley.toolbox.ImageLoader;
import com.android.volley.toolbox.ImageLoader.ImageCache;
import com.android.volley.toolbox.Volley;

public class VolleyTool {
	//初始化请求队列、图片加载器
	private RequestQueue queue;
	private ImageLoader imageLoader;

	//私有静态实例
	private static VolleyTool instance;
	//私有构造方法
	private VolleyTool(Context context) {
		//创建请求队列
		queue = Volley.newRequestQueue(context);
		//创建图片加载器
		imageLoader = new ImageLoader(queue, new LruImageCache());
	}
	//公共、静态的方法
	public static VolleyTool getInstance(Context context) {
		if (instance == null) {
			instance = new VolleyTool(context);
		}
		return instance;
	}

	//得到请求队列
	public RequestQueue getQueue() {
		return queue;
	}
	//得到图片加载器
	public ImageLoader getImageLoader() {
		return imageLoader;
	}

	/**
	 * 使用LRU回收算法的缓存类
	 */
	class LruImageCache implements ImageCache {

		// 缓存容器
		private LruCache<String, Bitmap> cache;

		public LruImageCache() {
			// 计算缓存的最值
			int maxSize = (int) (Runtime.getRuntime().maxMemory() / 8);
			//创建缓存对象实例
			cache = new LruCache<String, Bitmap>(maxSize) {
				@Override
				protected int sizeOf(String key, Bitmap value) {
					// 返回bitmap占用的内存大小
					return value.getRowBytes() * value.getHeight();
				}
			};
		}

		// 从缓存中取图片对象
		@Override
		public Bitmap getBitmap(String url) {
			return cache.get(url);
		}

		// 将图片对象保存到缓存容器中
		@Override
		public void putBitmap(String url, Bitmap bitmap) {
			cache.put(url, bitmap);
		}

	}
}
MainActivity.javapackage com.atguigu.day03_test;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.Response;
import com.android.volley.Response.Listener;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.NetworkImageView;
import com.android.volley.toolbox.StringRequest;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.handmark.pulltorefresh.library.PullToRefreshBase;
import com.handmark.pulltorefresh.library.PullToRefreshListView;

public class MainActivity extends Activity {
	// 进度条
	private ProgressBar pb_main;
	// 请求队列
	RequestQueue requestQueue;

	// 显示存放服务端数据的listView
	private PullToRefreshListView lv_main;
	// 数据对象集合
	private List<ShopInfo> data = new ArrayList<ShopInfo>();
	// 适配器
	private MainAdapter adapter;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		// 定义的PullToRefreshListView需要转型
		lv_main = (PullToRefreshListView) findViewById(R.id.lv_main);
		// 下拉刷新的监听
		lv_main.setOnRefreshListener(new PullToRefreshBase.OnRefreshListener<ListView>() {
			@Override
			public void onRefresh(PullToRefreshBase<ListView> refreshView) {
				//定义一个标示，如果为true,代表下拉
				loadData(true);
			}
		});
		// 上拉加载的刷新
		lv_main.setOnLastItemVisibleListener(new PullToRefreshBase.OnLastItemVisibleListener() {
			@Override
			public void onLastItemVisible() {
				// pb_foot.isShown()说明数据没有加载完毕
				if (pb_foot.isShown()) {
					//定义一个标示，如果为false,代表上拉
					loadData(false);
				}
			}
		});
		// 创建进度条对象
		pb_main = (ProgressBar) findViewById(R.id.pb_main);
		// 得到请求队列
		requestQueue = VolleyTool.getInstance(getApplicationContext())
				.getQueue();

		// 添加一个footView(上拉松开加载)
		addFootView();

		// 初始化加载数据显示（false或者true均可）
		loadData(false);
	}

	/**
	 * 添加一个footView 1. 如果还有更多数据, 它就会显示 2. 如果没有更多数据: 隐藏ProgressBar, 更新TextView的文本
	 */
	private ProgressBar pb_foot;
	private TextView tv_foot;

	private void addFootView() {
		View footView = View.inflate(this, R.layout.listview_foot, null);
		pb_foot = (ProgressBar) footView.findViewById(R.id.pb_foot);
		tv_foot = (TextView) footView.findViewById(R.id.tv_foot);
		lv_main.getRefreshableView().addFooterView(footView);
	}

	/*
	 * 页面上下滑动，如果还没有加载完毕，就快速滑动过去
	 * 这样消耗内存 定义一个标记，标记的意思是--某次请求是否正在加载图片（默认没有加载，表明已经加载过）
	 */
	private boolean loading = false;

	private void loadData(final boolean reset) {

		/*
		 * 如果正在加载,直接结束，从新滑到的图片无需继续加载了
		 */
		if (loading)
			return;
		// 一旦方法执行，就将标记改成true，说明正在加载
		loading = true;

		// 计算start-如果加载第一页就是0，如果不是第一页就是data.size
		int start = reset ? 0 : data.size();
		// data.size()==10 -->start=10
		String url = "http://192.168.30.41:8090/dianpin_03/ShopListServlet?start="
				+ start + "&count=5";

		// 创建一个请求
		Request request = new StringRequest(url, new Listener<String>() {

			@Override
			public void onResponse(String response) {
				/*
				 * 从服务器得到数据，一旦该方法触发，说明某次请求已经加载完毕图片了 要将标记改为false,说明已经加载完毕，无需加载了
				 */
				loading = false;

				/*
				 * 即使加载完毕，如果继续往下拉的话，还会发送请求 这里需要判断服务器端返回null值的情况（查看服务端代码）
				 */
				if ("".equals(response)) {
					// 隐藏ProgressBar, 更新TextView的文本
					pb_foot.setVisibility(View.GONE);
					tv_foot.setText("已加载完部数据");
					// 将该方法直接返回，无需继续往下执行了
					return;
				}

				// 将服务器端的json数组解析为ShopInfo对象集合
				List<ShopInfo> newData = new Gson().fromJson(response,
						new TypeToken<List<ShopInfo>>() {
						}.getType());

				// 因为每次请求5个json对象，如果返回小于5说明已经加载完所有的数据了
				if (newData.size() < 5) {
					// 隐藏ProgressBar, 更新TextView的文本
					pb_foot.setVisibility(View.GONE);
					tv_foot.setText("已加载完部数据");
				}

				/*
				 * 第一次加载 lv_main.setAdapter(adapter);
				 * 说明只显示第一页的数据
				 */
				
				if (adapter == null) {
					data = newData;
					adapter = new MainAdapter();
					lv_main.setAdapter(adapter);
					pb_main.setVisibility(View.GONE);
				} else {
					if (reset) {
						// 如果适配器不为null,并且下拉刷新，需要清空数据，只加载第一页
						data.clear();
						// 显示加载更多
						pb_foot.setVisibility(View.VISIBLE);
						tv_foot.setText("下拉加载更多");
						lv_main.onRefreshComplete();
					}
					// 不是第一次加载，就需要将每次获取的数据放到data集合中
					data.addAll(newData);
					adapter.notifyDataSetChanged();
				}
			}
		}, new Response.ErrorListener() {
			@Override
			public void onErrorResponse(VolleyError error) {
				Toast.makeText(getApplicationContext(), "请求服务器异常", 0).show();
			}
		});
		// 将请求添加到队列中, 自动处理
		requestQueue.add(request);

	}

	/**
	 * 适配器代码
	 */
	class MainAdapter extends BaseAdapter {

		@Override
		public int getCount() {
			return data.size();
		}

		@Override
		public Object getItem(int position) {
			return data.get(position);
		}

		@Override
		public long getItemId(int position) {
			return 0;
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			ViewHolder holder = null;
			if (convertView == null) {
				holder = new ViewHolder();
				convertView = View.inflate(getApplicationContext(),
						R.layout.list_item, null);
				holder.imageView = (NetworkImageView) convertView
						.findViewById(R.id.iv_img);
				holder.textView = (TextView) convertView
						.findViewById(R.id.tv_name);
				convertView.setTag(holder);
			} else {
				holder = (ViewHolder) convertView.getTag();
			}

			ShopInfo shopInfo = data.get(position);
			holder.textView.setText(shopInfo.getName());

			// 设置未加载默认图片
			holder.imageView.setDefaultImageResId(R.drawable.default_icon);
			// 设置加载异常的图片
			holder.imageView.setErrorImageResId(R.drawable.error);
			// 动态加载图片
			String url = "http://192.168.30.41:8090/dianpin_03/image/"
					+ shopInfo.getImg();
			holder.imageView.setImageUrl(url,
					VolleyTool.getInstance(getApplicationContext())
							.getImageLoader());

			return convertView;
		}

		class ViewHolder {
			NetworkImageView imageView;
			TextView textView;
		}
	}
}









测量webView页面性能技术方案
测量webView页面性能（使用UiAutomator和性能监控工具）
背景：
俺双11会场测试的总指挥想要确认，在猫客的webview中填多少坑位合适，所以进行了如下操作并获取性能：
1，进入webview页面滑动到底部，然后再快速回到顶部， 
2，点击顶部的banner进入下级页面， 
3，页面深度3层，即重复1，2该操作3次。   
采用的技术
需求拆分为2部分，webview控制脚本和性能监控。
脚本 UiAutomator
因为猫客的自动化采用UiAutomator实现，已经提供了很多封装方法，修改起来比较快。   
缺点： UiAutomator 不能识别webview的元素，所以判断滑动到底部，滑动到顶部，点击顶部banner这几个操作难点需要突破。
性能数据采集
有3种方案： 
 1，猫客内嵌入了性能测试模块，打包时配置MONITOR_OPEN=true，然后让监控开启即可。不方便之处是不能实时显示
2，请参见 http://blog.csdn.net/kittyboy0001/article/details/47317855
3, 安装易测客户端或者其他第三方能够监控性能的app或者工具取数据
webview 控制脚本
进入webview
通过am start进入webview
am start -a android.intent.action.VIEW -d urixxxx
滑动操作
因为页面上没有支持 UiScrollable 元素，所以没法使用如下方式：   
        UiScrollable scrollable = new UiScrollable(new UiSelector().scrollable(true));
        if (scrollable.exists()) {
            boolean isScrolled = scrollable.scrollForward(maxSteps);
        }
采用土办法，但是更有效的：   
        ScreenWidth = mDevice.getDisplayWidth();
        ScreenHeight = mDevice.getDisplayHeight();

         public void swipeUp() {
            int startX = ScreenWidth/2;
            int endX = startX;
            int startY = ScreenHeight/2;
            int endY = ScreenHeight/4;
            mDevice.swipe(startX, startY, endX, endY, STEP_NUM);
        }
判断到达顶部和底部
因为取得不到webview的元素，所以采用了一个笨办法，截屏。在滑动操作前后保存截屏数据，当2次的内容相同，则认为滑动到头了。 
但是遇到一个问题，webview页面填的内容很多，滑动过程会出现卡顿。当在卡顿时滑动是不起作用的，因此前后2次截屏内容相同，都是卡住的页面，会导致判断错误。   
为了解决这个问题，最初采用了延长每次操作后的等待时间来解决，但是这样太浪费时间…
     public void scrollDown() {
        log("下拉");

        while(true){
            swipeUp();
            sleep(5000);
            if(isSame()) break; 
         }
     }
后来优化采用了判断3次是否相同来解决，效果不错
     public void scrollDown() {
        log("下拉");
        while(true){
            swipeUp();
            sleep(1000);
            if(isSame()){     // 进行截屏，判断两次截屏是否相同，
                sleep(1500);  // 如果相同，做滑动操作，然后重新判断
                swipeUp();    // 重复3次
                sleep(1500);  // 如果3次判断都是相同，则不是卡顿
                if(isSame()){ // 经验值，卡顿达不到这么长时间
                    swipeUp();
                    sleep(1500);
                    if(isSame()){ 
                        break;  
                    }
                }
            }
         }
     }
截屏和判断的程序如下：   
     public void takeScreenshot(String path){
         File pic = new File(path);
         boolean ret = mDevice.takeScreenshot(pic);
     }

     public boolean isSame(){
         String path = "/data/local/tmp/Screenshot.png";


         takeScreenshot(path);

         if(bmp0!=null)
         bmp1 = bmp0.copy(Bitmap.Config.ARGB_8888, true);;

         bmp0 = BitmapFactory.decodeFile(path);
         bmp0 = bmp0.copy(Bitmap.Config.ARGB_8888, true);

         if(bmp0!=null && bmp1!= null && bmp0.sameAs(bmp1))
             return true;

         return false;
     }
点击顶部 banner
还是因为取得不到webview的元素，所以采用了一个笨办法。因为banner 是webview上的第一个元素，所以先判断顶部工具条的高度，然后再加上页面布局元素的间隙的大小，就是banner 的位置。点击这个位置！
    public void clickBanner() {
         UiCollection colls = new UiCollection(new UiSelector().className("android.widget.LinearLayout"));
         try {
            UiObject topCat = colls.getChildByInstance(new UiSelector().className("android.widget.LinearLayout"),2);
            Rect rect = topCat.getBounds(); //获取顶部工具条的位置

            mDevice.click(ScreenWidth/2,rect.bottom + 30); //点击下面30像素中间位置
        } catch (UiObjectNotFoundException e) {
            e.printStackTrace();
        }
         mDevice.waitForIdle();     
    }
第一部分 OK了
取得性能数据
有3种方案： 
 1，猫客内嵌入了性能测试模块，打包时配置MONITOR_OPEN=true，然后让监控开启即可。不方便之处是不能实时显示成图表~
2，请参见http://blog.csdn.net/kittyboy0001/article/details/47317855 
3, 安装易测客户端 http://easytest.taobao.com
这里只对第一种方案做说明，剩下2种方案大家自己看。。。
（当然，我自己更喜欢用第2种方案，因为这个是我自己做的,哈哈哈）
性能监控方案一
在猫客的测试模块中嵌入了一个性能监控的服务，可以监控app运行时的各种参数，在业界有很多独立的app可以做这种动作，嵌入的好处是可以直接使用不用再独立安装。打包时配置MONITOR_OPEN=true 可以让该模块能够生效。   
通过如下命令启动服务   
    am startservice -a com.xxx.action.AUTOTEST --ei frequency 1 --es caseId 
    xxxCaseId  --es caseName xxxCaseName  --es reportIp xx.xx.xx.xx --ez socketMethod false --ei reportPort 80
监控结束时调用如下命令，将测试数据回传到服务器查看  
    am startservice -a com.xxx.action.SHUTDOWN
在我们的测试用例中封装了一个测试类PerformanceTest来负责这个动作。 
有想了解使用的请联系 XXX
done

            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        

版权声明：本文为博主原创文章，未经博主允许不得转载。

地理反编码的实现
一：效果
输入经纬度，可以得到相应的地名 

二：思路
跟地里编码差不多 
1.获取用户输入的经纬度 
2.根据用户输入的经纬度创建CLLocation对象 
3.根据CLLocation对象获取对应的地标信息
三：代码
<code class="hljs objectivec has-numbering"><span class="hljs-preprocessor">#import <span class="hljs-title">"ViewController.h"</span></span>
<span class="hljs-preprocessor">#import <span class="hljs-title"><CoreLocation/CoreLocation.h></span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span>
<span class="hljs-comment">/**
 *  地理编码对象
 */</span>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span> ,<span class="hljs-keyword">strong</span>) CLGeocoder *geocoder;

<span class="hljs-preprocessor">#pragma mark - 反地理编码</span>
- (<span class="hljs-keyword">IBAction</span>)reverseGeocode;

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> UITextField *longtitudeField;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> UITextField *latitudeField;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UILabel</span> *reverseDetailAddressLabel;

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>

- (<span class="hljs-keyword">void</span>)reverseGeocode
{
    <span class="hljs-comment">// 1.获取用户输入的经纬度</span>
    <span class="hljs-built_in">NSString</span> *longtitude = <span class="hljs-keyword">self</span><span class="hljs-variable">.longtitudeField</span><span class="hljs-variable">.text</span>;
    <span class="hljs-built_in">NSString</span> *latitude = <span class="hljs-keyword">self</span><span class="hljs-variable">.latitudeField</span><span class="hljs-variable">.text</span>;
    <span class="hljs-keyword">if</span> (longtitude<span class="hljs-variable">.length</span> == <span class="hljs-number">0</span> ||
        longtitude == <span class="hljs-literal">nil</span> ||
        latitude<span class="hljs-variable">.length</span> == <span class="hljs-number">0</span> ||
        latitude == <span class="hljs-literal">nil</span>) {
        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">"请输入经纬度"</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 2.根据用户输入的经纬度创建CLLocation对象</span>
    CLLocation *location = [[CLLocation alloc] initWithLatitude:[latitude doubleValue]  longitude:[longtitude doubleValue]];

    <span class="hljs-comment">// 3.根据CLLocation对象获取对应的地标信息</span>
    [<span class="hljs-keyword">self</span><span class="hljs-variable">.geocoder</span> reverseGeocodeLocation:location completionHandler:^(<span class="hljs-built_in">NSArray</span> *placemarks, <span class="hljs-built_in">NSError</span> *error) {

        <span class="hljs-keyword">for</span> (CLPlacemark *placemark in placemarks) {
            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">"%@ %@ %f %f"</span>, placemark<span class="hljs-variable">.name</span>, placemark<span class="hljs-variable">.addressDictionary</span>, placemark<span class="hljs-variable">.location</span><span class="hljs-variable">.coordinate</span><span class="hljs-variable">.latitude</span>, placemark<span class="hljs-variable">.location</span><span class="hljs-variable">.coordinate</span><span class="hljs-variable">.longitude</span>);
            <span class="hljs-keyword">self</span><span class="hljs-variable">.reverseDetailAddressLabel</span><span class="hljs-variable">.text</span> = placemark<span class="hljs-variable">.locality</span>;
        }
    }];
}

<span class="hljs-preprocessor">#pragma mark - 懒加载</span>
- (CLGeocoder *)geocoder
{
    <span class="hljs-keyword">if</span> (!_geocoder) {
        _geocoder = [[CLGeocoder alloc] init];
    }
    <span class="hljs-keyword">return</span> _geocoder;
}

<span class="hljs-keyword">@end</span></code>
四：知识扩充CLGeocoder
使用CLGeocoder可以完成“地理编码”和“反地理编码” 
地理编码：根据给定的地名，获得具体的位置信息（比如经纬度、地址的全称等） 
反地理编码：根据给定的经纬度，获得具体的位置信息
>地理编码方法
<code class="hljs erlang has-numbering"><span class="hljs-pp">- <span class="hljs-params">(void)</span>geocodeAddressString:<span class="hljs-params">(<span class="hljs-variable">NSString</span> *)</span>addressString completionHandler:<span class="hljs-params">(<span class="hljs-variable">CLGeocodeCompletionHandler</span>)</span>completionHandler;</span></code>
>反地理编码方法
<code class="hljs erlang has-numbering"><span class="hljs-pp">- <span class="hljs-params">(void)</span>reverseGeocodeLocation:<span class="hljs-params">(<span class="hljs-variable">CLLocation</span> *)</span>location completionHandler:<span class="hljs-params">(<span class="hljs-variable">CLGeocodeCompletionHandler</span>)</span>completionHandler;</span></code>
CLGeocodeCompletionHandler
当地理\反地理编码完成时，就会调用
<code class="hljs objectivec has-numbering">CLGeocodeCompletionHandler <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (^CLGeocodeCompletionHandler)(<span class="hljs-built_in">NSArray</span> *placemarks, <span class="hljs-built_in">NSError</span> *error);</code>
这个block传递2个参数 
error ：当编码出错时（比如编码不出具体的信息）有值 
placemarks ：里面装着CLPlacemark对象
CLPlacemark
CLPlacemark的字面意思是地标，封装详细的地址位置信息
地理位置
<code class="hljs objectivec has-numbering"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) CLLocation *location;</code>
区域
<code class="hljs objectivec has-numbering"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) CLRegion *region;</code>
详细的地址信息
<code class="hljs objectivec has-numbering"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSDictionary</span> *addressDictionary;</code>
地址名称
<code class="hljs objectivec has-numbering"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSString</span> *name;</code>
城市
<code class="hljs objectivec has-numbering"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSString</span> *locality;</code>
结构图





Git、GitHub使用操作流程图文攻略教程
详细教程 搜集的网站有：（超级详细）


GitHub 教程http://www.ihref.com/read-16514.html



git教程 http://www.ihref.com/read-16369.html



http://blog.csdn.net/vipzjyno1/article/details/22098621



一. Git介绍




分布式 : Git版本控制系统是一个分布式的系统, 是用来保存工程源代码历史状态的命令行工具;




保存点 : Git的保存点可以追踪源码中的文件, 并能得到某一个时间点上的整个工程项目额状态; 可以在该保存点将多人提交的源码合并, 也可以会退到某一个保存点上;




Git离线操作性 :Git可以离线进行代码提交, 因此它称得上是完全的分布式处理, Git所有的操作不需要在线进行; 这意味着Git的速度要比SVN等工具快得多,  因为SVN等工具需要在线时才能操作, 如果网络环境不好, 提交代码会变得非常缓慢; 




Git基于快照 : SVN等老式版本控制工具是将提交点保存成补丁文件, Git提交是将提交点指向提交时的项目快照, 提交的东西包含一些元数据(作者, 日期, GPG等);




Git的分支和合并 : 分支模型是Git最显著的特点, 因为这改变了开发者的开发模式, SVN等版本控制工具将每个分支都要放在不同的目录中, Git可以在同一个目录中切换不同的分支;

分支即时性 : 创建和切换分支几乎是同时进行的, 用户可以上传一部分分支, 另外一部分分支可以隐藏在本地, 不必将所有的分支都上传到GitHub中去;

分支灵活性 : 用户可以随时 创建 合并 删除分支, 多人实现不同的功能, 可以创建多个分支进行开发, 之后进行分支合并, 这种方式使开发变得快速, 简单, 安全;



二. Git通用客户端(msysgit)



1. 下载Git客户端




Git客户端下载地址 :https://code.google.com/p/msysgit/downloads/list 将地址复制到浏览器栏即可下载.

三 . GitHub 



GitHub 使用 git 分布式版本控制系统，而 git 最初是 Linus Torvalds 为帮助Linux开发而创造的，它针对的是 Linux 平台，因此 git 和 Windows 从来不是最好的朋友，因为它一点也不像 Windows。GitHub 发布了GitHub for Windows，为 Windows 平台开发者提供了一个易于使用的 Git 图形客户端。

GitHub for Windows 是一个 Metro 风格应用程序，集成了自包含版本的 Git，bash 命令行 shell，PowerShell 的 posh-git 扩展。GitHub 为 Windows 用户提供了一个基本的图形前端去处理大部分常用版本控制任务，可以创建版本库，向本地版本库递交补丁，在本地和远程版本库之间同步。微软也通过CodePlex向开发者提供 git 版本控制系统，而 GitHub 创造了一个更具有吸引力的 Windows 版本。

一：下载GitHub for Windows 2.0

下载地址：https://windows.github.com/


版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS开发网络篇—数据缓存


文顶顶


iOS开发网络篇—数据缓存
iOS开发网络篇—数据缓存
一、关于同一个URL的多次请求
　　有时候，对同一个URL请求多次，返回的数据可能都是一样的，比如服务器上的某张图片，无论下载多少次，返回的数据都是一样的。
　　
　　上面的情况会造成以下问题
（1）用户流量的浪费
（2）程序响应速度不够快
解决上面的问题，一般考虑对数据进行缓存。
 
 二、缓存
　　为了提高程序的响应速度，可以考虑使用缓存（内存缓存\硬盘缓存）
　　
　　第一次请求数据时，内存缓存中没有数据，硬盘缓存中没有数据。
缓存数据的过程
　　
当服务器返回数据时，需要做以下步骤
（1）使用服务器的数据（比如解析、显示）
（2）将服务器的数据缓存到硬盘（沙盒）
此时缓存的情况是：内存缓存中有数据，硬盘缓存中有数据。
再次请求数据分为两种情况：
（1）如果程序并没有被关闭，一直在运行
　　那么此时内存缓存中有数据，硬盘缓存中有数据。如果此时再次请求数据，直接使用内存缓存中的数据即可
（2）如果程序重新启动
　　那么此时内存缓存已经消失，没有数据，硬盘缓存依旧存在，还有数据。如果此时再次请求数据，需要读取内存中缓存的数据。
提示：从硬盘缓存中读取数据后，内存缓存中又有数据了
 
三、缓存的实现
1.说明：
由于GET请求一般用来查询数据，POST请求一般是发大量数据给服务器处理（变动性比较大）
因此一般只对GET请求进行缓存，而不对POST请求进行缓存
　　在iOS中，可以使用NSURLCache类缓存数据
　　iOS 5之前：只支持内存缓存。从iOS 5开始：同时支持内存缓存和硬盘缓存
 
2.NSURLCache
iOS中得缓存技术用到了NSURLCache类。
缓存原理：一个NSURLRequest对应一个NSCachedURLResponse
缓存技术：把缓存的数据都保存到数据库中。
 
3.NSURLCache的常见用法
（1）获得全局缓存对象（没必要手动创建）NSURLCache *cache = [NSURLCache sharedURLCache]; 
（2）设置内存缓存的最大容量（字节为单位，默认为512KB）- (void)setMemoryCapacity:(NSUInteger)memoryCapacity;
（3）设置硬盘缓存的最大容量（字节为单位，默认为10M）- (void)setDiskCapacity:(NSUInteger)diskCapacity;
（4）硬盘缓存的位置：沙盒/Library/Caches
（5）取得某个请求的缓存- (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request; 
（6）清除某个请求的缓存- (void)removeCachedResponseForRequest:(NSURLRequest *)request;
（7）清除所有的缓存- (void)removeAllCachedResponses;
 
4.缓存GET请求
　　要想对某个GET请求进行数据缓存，非常简单
　　NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
　　// 设置缓存策略
　　request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;
　　只要设置了缓存策略，系统会自动利用NSURLCache进行数据缓存
 
5.iOS对NSURLRequest提供了7种缓存策略：（实际上能用的只有4种）
NSURLRequestUseProtocolCachePolicy // 默认的缓存策略（取决于协议）
NSURLRequestReloadIgnoringLocalCacheData // 忽略缓存，重新请求
NSURLRequestReloadIgnoringLocalAndRemoteCacheData // 未实现
NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData // 忽略缓存，重新请求
NSURLRequestReturnCacheDataElseLoad// 有缓存就用缓存，没有缓存就重新请求
NSURLRequestReturnCacheDataDontLoad// 有缓存就用缓存，没有缓存就不发请求，当做请求出错处理（用于离线模式）
NSURLRequestReloadRevalidatingCacheData // 未实现
 
6.缓存的注意事项
缓存的设置需要根据具体的情况考虑，如果请求某个URL的返回数据：
　　（1）经常更新：不能用缓存！比如股票、彩票数据
　　（2）一成不变：果断用缓存
　　（3）偶尔更新：可以定期更改缓存策略 或者 清除缓存
提示：如果大量使用缓存，会越积越大，建议定期清除缓存
 
四、简单的代码示例

 1 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
 2 {
 3     // 1.创建请求
 4     NSURL *url = [NSURL URLWithString:@"http://127.0.0.1:8080/YYServer/video"];
 5     NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
 6     
 7     // 2.设置缓存策略(有缓存就用缓存，没有缓存就重新请求)
 8     request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;
 9     
10     // 3.发送请求
11     [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) {
12         if (data) {
13             NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:nil];
14             
15             NSLog(@"%@", dict);
16         }
17     }];
18 }
19 
20 /**
21  // 定期处理缓存
22  //    if (缓存没有达到7天) {
23  //        request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;
24  //    }
25  // 获得全局的缓存对象
26  NSURLCache *cache = [NSURLCache sharedURLCache];
27  //    if (缓存达到7天) {
28  //        [cache removeCachedResponseForRequest:request];
29  //    }
30  
31  // lastCacheDate = 2014-06-30 11:04:30
32  
33  NSCachedURLResponse *response = [cache cachedResponseForRequest:request];
34  if (response) {
35  NSLog(@"---这个请求已经存在缓存");
36  } else {
37  NSLog(@"---这个请求没有缓存");
38  }
39  */

版权声明：本文为博主原创文章，未经博主允许不得转载。

QT 学习遇到的问题记录2—qml 调用qt c++

1.使用 QDeclarativeEngine 参考【http://www.cnblogs.com/hicjiajia/archive/2012/01/30/2332266.html】，挺详细


结合 2.4 qml ，提示 "QtQuick" version 2.4 is not installed


好像只能使用Quick 1.0，暂定为已过时吧【不对的话，各位看客告诉我原因】
参考【http://forum.qt.io/topic/26782/module-qtquick-version-2-0-is-not-installed-using-qdeclarativeview-in-ui-form】




2.使用 QtQuick2ApplicationViewer ，用的Quick 2.0 ，参考
【http://blog.csdn.net/foruok/article/details/32698603】
没找到 QtQuick2ApplicationViewer 从哪来的，搜到
【http://www.devbean.net/2013/12/qt-study-road-2-qml-and-qtquick2/】
说是qt自动生成的，由于我一开始建的项目就是选得2.4，没有生成，那就算了先，看看有没有其他办法。毕竟多了一个这么多余的东西也怪奇怪的。




3.查看上面两种方式关键点就是setContextProperty让 C++ 对象和 qml 上下文联系起来。
从帮助中找到找到 QQmlContext 有这个方法，增加该方法调用后，可正常使用。
QQmlContext 从 QQmlApplicationEngine 上的 rootContext上获取。其他的暂时觉得和上面的方法应该没区别。


----
创建qt C++类的时候发现个以前不知道的玩意，Signals & Slots。和这次的问题没有关系，顺便了解了下， boost也有Signals 的支持，作用有点类似现在如.net 的委托，解决以前c++函数回调一些麻烦的问题。暂时不用先不玩了。


版权声明：本文为博主原创文章，未经博主允许不得转载。

iOS 如何更新APP
app更新的流程思想
得到当前版本号currentVersion，将currentVersion与最近的版本号latestVersion进行比较，若当前currentVersion较小，进行更新操作。


获取当前app的版本号：

NSString *currentVersion = [[[NSBundle
mainBundle] infoDictionary]
objectForKey:@"CFBundleShortVersionString"];
下面的分两种情况
1 更新提交AppStore中的App（不支持强制更新）
运用下面的链接发起一个post请求，获取AppStore中最新版本的详细信息（app的作者，连接，版本等）。

http://itunes.apple.com/lookup?id=应用程序的ID（应用程序ID是在apple上填写发布程序时生成的）
返回的JSon格式的数据，数据的格式可以参照苹果官方API中的Lookup
 Examples
http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html

将返回的JSon格式的数据通过http://www.bejson.com/jsonviewernew/网站进行解析
解析出来是一个NSDictionary，找到version对应的值，就是最新的版本号（然后你知道该怎么做了了吧！！！）
比较之后如果要更新，那么就通过以下方式打开AppStore中该应用应用程序的链接，用户就可以更新啦！

[[UIApplication
sharedApplication] openURL:[NSURL
URLWithString:appUrlString]];
appUrlString是多少呢？很简单，就在刚才解析出来的NSDictionary中，对应的key是trackViewUrl
 。


2 更新企业级的App（支持强制更新）
这个更新就比较随意了，因为后台什么都是自己写的。所谓我的地盘我做主，这里可以强制更新。
主要有两个接口：检查更新的接口，更新接口。
步骤跟更新更新提交到AppStore中的App一样，只不过接口是自己写的，然后你就随意吧。。。

版权声明：本文为博主原创文章，未经博主允许不得转载。

（一二五）手机网络状态的监听
对于一些需要与服务器进行长连接的App，需要对网络状态进行监控，当网络不佳时及时提醒用户，从而提高用户体验。通过苹果自带的框架和Reachability类可以实现网络状态改变的监听。
要实现网络监听，按照下面的步骤进行。
①导入SystemConfiguration框架。
②通过Xcode的帮助文档搜索Reachability，打开样例工程，将其中的Reachability类的代码拷贝到自己的工程，有两个文件，如下图所示。

③创建对象，保存对象，添加监听和启动监听。
注意reachabilityForInternetConnection才能用于wifi、3G、无网络三种状态。

注意监听的名称为kReachabilityChangedNotification。
- (void)viewDidLoad{
    
    [super viewDidLoad];
    Reachability *wifiReach = [Reachability reachabilityForInternetConnection];
    _wifiReach = wifiReach;
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkStateChange:) name:kReachabilityChangedNotification object:nil];
    [wifiReach startNotifier];
    
}④在监听的回调中拿到状态判断。
注意要实现三种网络状态，要用真机来调试。

- (void)networkStateChange:(NSNotification *)nof{
    
    switch (self.wifiReach.currentReachabilityStatus) {
        case ReachableViaWiFi:
            NSLog(@"wifi");
            break;
        case ReachableViaWWAN:
            NSLog(@"移动数据");
            break;
        case NotReachable:
            NSLog(@"无网络");
            break;
    }
    
}⑤在控制器销毁时，一定要记得移除监听。
- (void)dealloc{
    
    [self.wifiReach stopNotifier];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
    
}

版权声明：本文为博主原创文章，未经博主允许不得转载。

android——如何从一个activity中退出程序

软件一运行起来，先是一个主Activity显示一张图片。然后用startActivity(Intent intent)方法打开另一个Activity。我想在这个Activity中让用户按返回键后，不返回到前一个Activity，而是弹出一个对话框，提示软件是否关闭。

 

这里有两个问题：

       1.截取返回按键事件，屏蔽返回行为。只需要在程序里加入这段就好

 

@Override

    public boolean onKeyDown(int keyCode, KeyEvent event) {

        if(keyCode == KeyEvent.KEYCODE_BACK){

           //这里写你要在用户按下返回键同时执行的动作

                moveTaskToBack(false);            //核心代码：屏蔽返回行为

            return true;

        }

        return super.onKeyDown(keyCode, event);

    }

 

 

        2.不反回是实现了，但怎么来关闭程序呢？这个问题我用了一晚上才想到一个自己的方法，先是在网上找，什么system.exit、什么用Activity栈(什么标记Activity)、什么用restartProcess（还涉及到版本问题，什么2.2一下怎么了，2.3以上又要怎么弄）还要加什么permission，告诉你，用户最讨厌的就是一个他不熟悉的、不知名的软件，在安装的时候提示：该程序需要完全网路连接、该程序作为什么什么系统进程等等，用户最讨厌的往往就是这些红字。。。反正没一个方法成功了的，求人不如求己，想到了一个巧方法，并成功运用于自己软件，现在拿出来分享。

首先我们有两个Activity，分别叫A和B。打开软件，自动启动A，再跳转到B。问题是怎么在B中将A和B同时关闭。好的，解决方法来了：先在A的class中定义一个 private int flag=0;   再在A的onResume()方法中加入 

flag++;

if(flag>=2)

finish();

当软件开起来的时候，A被打开，现在flag是1;(因为一个Activity被创建的时候先是执行onCreate再执行onResume，所以这里的i在onResume中自增一次)。现在跳转到B(注意A不能finish()  要直接跳转，要不然B中的moveTaskToBack(false)不起作用的，一定要记住，不信自己试试，这就是Android变态之处，害我一晚上)。在B中调用finish()，Activity栈中B被弹走，只剩A，又执行A，这时，先从A的onResume开始执行，故i再次自增为2，满足条件，A也被finish()了，至此Acitivity栈为空，程序结束。（这段时间极短，屏幕上根本看不到A，效果就是从B直接关掉了整个程序）

版权声明：本文为博主原创文章，未经博主允许不得转载。

在Ubuntu QML应用中使用WebSocket建立TCP/IP连接
对于一些应用场景来说，TCP/IP连接是唯一的一种通讯的协议。对于我们的QML应用来说，我们可以使用WebSocket来建立一个双工的(full-duplex)的TCP/IP连接。在今天的例程中，我们将来介绍如何使用WebSocket来建立这种连接，并实现通信。


首先，我们得import我们需要的模块：

import Qt.WebSockets 1.0
然后，我们使用它:




import QtQuick 2.0
import Ubuntu.Components 1.1
import QtQuick.Layouts 1.1
import Qt.WebSockets 1.0

/*!
    \brief MainView with a Label and Button elements.
*/

MainView {
    // objectName for functional testing purposes (autopilot-qt5)
    objectName: "mainView"

    // Note! applicationName needs to match the "name" field of the click manifest
    applicationName: "websocket.liu-xiao-guo"

    /*
     This property enables the application to change orientation
     when the device is rotated. The default is false.
    */
    //automaticOrientation: true

    // Removes the old toolbar and enables new features of the new header.
    useDeprecatedToolbar: false

    width: units.gu(60)
    height: units.gu(85)

    function appendMessage(msg) {
        var length = output.length;
        output.insert(length, msg + "\r\n");
    }

    Page {
        id: page
        title: i18n.tr("websocket")

        WebSocket {
            id: socket
            url: input.text
            onTextMessageReceived: {
                console.log("something is received!");
                appendMessage("received: " + message);
            }

            onStatusChanged: if (socket.status == WebSocket.Error) {
                                 console.log("Error: " + socket.errorString)
                             } else if (socket.status == WebSocket.Open) {
                                 appendMessage("sending \"Hello world\"");
                                 socket.sendTextMessage("Hello World")
                             } else if (socket.status == WebSocket.Closed) {
                                 appendMessage("Socket closed");
                             }
            active: true
        }

        Column {
            anchors.fill: parent
            spacing: units.gu(1)

            RowLayout {
                id: top
                width: parent.width

                TextField {
                    id: input
                     Layout.minimumWidth: page.width *.7
                    text: "ws://echo.websocket.org"
                }

                Button {
                    id: get
                    text: "Get"
                    onClicked: {
                        socket.active = true
                        socket.sendTextMessage("Nice to meet you!")
                    }
                }
            }

            TextArea {
                id: output
                width: parent.width
                height: page.height - top.height - units.gu(1)
            }
        }
    }
}

在上面的代码中：




       WebSocket {
            id: socket
            url: input.text
            onTextMessageReceived: {
                console.log("something is received!");
                appendMessage("received: " + message);
            }

            onStatusChanged: if (socket.status == WebSocket.Error) {
                                 console.log("Error: " + socket.errorString)
                             } else if (socket.status == WebSocket.Open) {
                                 appendMessage("sending \"Hello world\"");
                                 socket.sendTextMessage("Hello World")
                             } else if (socket.status == WebSocket.Closed) {
                                 appendMessage("Socket closed");
                             }
            active: true
        }


我们从input.text中得到url。当active为真时，建立起Socket的连接。我们可以在onStatusChhanged中得到这个变化。当我们把active设为假时，安全套接字将被自动断开。在例程中，我们使用了一个公共的网站


ws://echo.websocket.org



每当我们向这个地址发送信息时，就会得到和发送信息一模一样的信息(是一个echo服务器）。我们可以通过onTextMessageReceived来得到这个信息。


运行我们的应用：






整个应用的源码在：git clone https://gitcafe.com/ubuntu/websocket.git

版权声明：本文为博主原创文章，未经博主允许不得转载。

Android三句代码使用沉浸式状态栏


用过android手机的人都知道android使用app的时候屏幕上方的状态栏都是黑色的，就算不是黑色的都与正在打开的app颜色不同。有一种灰常不搭调的感觉。~
今天无意中看了一下关于沉浸式状态栏的资料~~作为强迫症重度患者怎能错过？
下面就开始使用沉浸式状态栏之旅：
代码未上图先行：
沉浸式：


非沉浸式：


嗯~虽然第二张图比较模糊，但是也可以想象第一张比较好看(～￣▽￣)～。
那么接下来要说的就是如何实现第一张图的那样的效果：
首先要说明的是以下方法只适合android4.4或以上的系统
android4.4也就是api19~所以我们在res文件夹下新建一个values-v19,然后再新建一个style.xml文件。
在style上写以下代码：
指定style为noactionbar而且半透明


<resources xmlns:android="http://schemas.android.com/apk/res/android">
    <style name="AppBaseTheme" parent="android:Theme.Holo.Light.NoActionBar.TranslucentDecor" >
    </style>
</resources>


然后运行程序可以看到，状态栏与app顶部颜色是一致的，但是如果布局文件的顶部写有其它内容的话会发现布局文件上的内容会与状态栏上的内容重合~~这肯定是不允许的。
有没有方法解决呢？
在使用了沉浸式状态栏的布局文件上写上以下两句话：


  android:clipToPadding="true"
  android:fitsSystemWindows="true"
就可以解决这个问题了~

但是在某些情况下会发现写上这两句代码之后，状态栏颜色会是白色或者其它颜色~这是因为写上这两句代码的地方的颜色是与状态栏颜色是一样的。
也就是说如果有一个LinearLayout的背景色是红色，那么使用了沉浸式状态栏的情况下，在这个linearLayout写上以上两句代码之后状态栏也会变成红色。




可以看到实际上就三句代码~

 <style name="AppBaseTheme" parent="android:Theme.Holo.Light.NoActionBar.TranslucentDecor" > android:clipToPadding="true"
  android:fitsSystemWindows="true"

最后说一下：
每个app都有那么多的activity如果每个activity都写一次上面两句代码未免有点烦人，所以在某些情况下是可以“偷懒”的。比如很多app都是用toolbar或actionbar之类的。
那么状态栏的颜色就要与app上的这个bar的颜色一致。那么我们只需自己定义一个actionbar然后在布局上面写上以上两句代码那么在使用到这个自定义actionbar的activity自然那两句代码自然会生效啦！
以下就是例子：
首先是自定义actionbar的布局文件：

<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/rellay_action_bar"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@color/maincolor"
    android:clipToPadding="true"
     android:fitsSystemWindows="true"
   >
<RelativeLayout 
    android:layout_width="match_parent"
    android:layout_height="@dimen/top_navigation_height"
    >
     <ImageButton
        android:id="@+id/btn_action_bar_left"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:layout_alignParentLeft="true"
        android:layout_centerVertical="true"
        android:layout_marginLeft="10dp"
        android:background="@drawable/common_back_btn_bg_pressed"
        android:contentDescription="@null"
        android:padding="20dp"
        android:visibility="gone" />

    <TextView
        android:id="@+id/tv_action_bar_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:layout_centerInParent="true"
        android:layout_centerVertical="true"
        android:gravity="center"
        android:singleLine="true"
        android:textColor="#ffffff"
        android:textSize="20sp" />

    <ImageButton
        android:id="@+id/btn_action_bar_right"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:layout_alignParentRight="true"
        android:layout_centerVertical="true"
        android:layout_marginRight="10dp"
        android:contentDescription="@null"
        android:padding="20dp"
        android:visibility="gone" />
</RelativeLayout>
   

</RelativeLayout>
然后是使用这个自定义actionbar的布局：


<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:orientation="vertical"
    android:layout_height="wrap_content" >

    <com.javy.test.view.CustomActionBar
        android:id="@+id/action_bar_act_detail_intro"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" >
    </com.javy.test.view.CustomActionBar>
</LinearLayout>


就这样~~ok了





版权声明：本文为博主原创文章，未经博主允许不得转载。

Android-画廊实现 （Gallery , ImageSwitch）
1.回顾
   上篇学习 SrcollView 和 ViewFlipper 的实现 图片轮播效果


2.重点
   （1）Gallery 实现
   （2）ImageSwitch实现
   （3）Gallery 的 OnItemSelectedListener 实现
   （4）ImageSwitch 的 ViewFactory 实现
   （5）实现实例——Gallery实现缩略图，ImageSwitch实现 放大效果
3.实现
   3.1 说明
      Gallery 在 安卓4.0版本已经 过时了，建议使用 ScrollView水平视图实现或者 GridView实现；
  虽说过时了，但是 还是可以使用的，使用起来比较简单；
   3.2 效果图
                                                    

      还是挺不错的；
    3.3 布局实现
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context="${relativePackage}.${activityClass}" >

    <Gallery
        android:id="@+id/gallery1"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_weight="1.02" />

    <ImageSwitcher
        android:id="@+id/imgswitch"
        android:layout_width="match_parent"
        android:layout_height="400dp" >
    </ImageSwitcher>

</LinearLayout>
   3.4 适配器实现
      前面已经学过了 6 个 常用的适配器 ：SimapleAdapter , ArrayAdapter ,BaseAdapter , PagerAdapter , 
 FragmentPagerAdapter 和 FragmentStatePagerAdapter ;
     其中 BaseAdapter 十分的灵活 ，易于 扩展；在此使用 BaseAdapter ; 这里就不解释了；
package com.example.adpater;

import android.content.Context;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.Gallery;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;

public class ImageAdapter extends BaseAdapter{

	private int [] pics;
	private Context context;
	public ImageAdapter(int [] pics,Context context) {
		//初始化 数据源
		this.pics=pics;
		this.context=context;
	}
	
	@Override
	public int getCount() {
		// TODO Auto-generated method stub
		return Integer.MAX_VALUE;
	}

	@Override
	public Object getItem(int position) {
		// TODO Auto-generated method stub
		return pics[position];
	}

	@Override
	public long getItemId(int position) {
		// TODO Auto-generated method stub
		return position;
	}

	@Override
	public View getView(int position, View convertView, ViewGroup parent) {
		// Item 生成
		ImageView imageView=new ImageView(context);
		//设置资源
		imageView.setBackgroundResource(pics[position%pics.length]);
		//拉伸图片 
		imageView.setScaleType(ScaleType.FIT_XY);
		//设置大小
		imageView.setLayoutParams(new Gallery.LayoutParams(200,100));
		
		return imageView;
	}

}

   3.5 业务实现

   （1）初始化 Gallary 和 imageswitch 控件
   （2）准备数据源，在Drawable 中 粘贴 12张 图片，不要太大，否则报 内存溢出 错误
   （3）绑定适配器
   （4）设置Gallary OnItemSelectedListener  监听
   （5）为 ImageSwitch 实现ViewFactory 

package com.example.studydemo3;

import com.example.adpater.ImageAdapter;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.Gallery;
import android.widget.ImageSwitcher;
import android.widget.ImageView;
import android.widget.ImageView.ScaleType;
import android.widget.ViewSwitcher.ViewFactory;

public class MainActivity extends Activity {

	private Gallery gallery1;
	private ImageSwitcher imgswitch;

	// 准备数据源
	private int[] pics = { R.drawable.pic1, R.drawable.pic2, R.drawable.pic3,
			R.drawable.pic4, R.drawable.pic5, R.drawable.pic6, R.drawable.pic7,
			R.drawable.pic8, R.drawable.pic9, R.drawable.pic10, R.drawable.pic11,
			R.drawable.pic12};

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		gallery1 = (Gallery) findViewById(R.id.gallery1);
		imgswitch = (ImageSwitcher) findViewById(R.id.imgswitch);

		//绑定 适配器
		ImageAdapter imageAdapter=new ImageAdapter(pics, this);
		gallery1.setAdapter(imageAdapter);
		
		// 设置 viewFactory
		imgswitch.setFactory(new imgSwitchListener());

		// 设置监听事件
		gallery1.setOnItemSelectedListener(new galleryItemListener());

	}

	/**
	 * Gallery item 选择事件
	 * 
	 * @author yuan
	 *
	 */
	class galleryItemListener implements OnItemSelectedListener {

		@Override
		public void onItemSelected(AdapterView<?> parent, View view,
				int position, long id) {
			// 使用这个
           imgswitch.setBackgroundResource(pics[position%pics.length]);
		}

		@Override
		public void onNothingSelected(AdapterView<?> parent) {
			// 没有使用

		}

	}

	// ImageSwitch 图片生产工厂
	class imgSwitchListener implements ViewFactory {

		@Override
		public View makeView() {
			// 返回 image
			ImageView imageView = new ImageView(MainActivity.this);
			// 使图片保持 原始比例大小 ，且中 显示
			imageView.setScaleType(ScaleType.FIT_CENTER);

			return imageView;
		}

	}

}

4. demo下载
http://download.csdn.net/detail/lablenet/9046019






版权声明：本文为博主原创文章，未经博主允许不得转载。

微信公众平台开发【素材管理】获取临时素材
在上一讲的主要讲解了上传临时素材（传送门：《微信公众平台开发【素材管理】上传临时素材》），下面就讲讲如何获取此临时素材。此处的获取临时素材指公众号可以使用素材管理接口下载临时的多媒体文件，下面以下载图片为例。
接口开放权限：素材管理接口对所有认证的订阅号和服务号开放

调用格式及参数说明
http请求方式：GET，https调用（请注意，视频文件不支持https下载，调用该接口需http协议）
请求格式：https://api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&media_id=MEDIA_ID
参数说明：

参数			是否必须	说明
access_token	是	 	调用接口凭证
media_id	 	是	 	媒体文件ID

基于SAE实现的源代码
本教程使用的是SAE服务器，由于SAE不能实现本地文件上传和下载，而需要通过Storage来实现，所有代码中会使用一些SAE官方给出的相关函数。
saeImage.php（完整代码下载）

<?php
/** 
  * 作者：smalle 
  * 网址：http://blog.csdn.net/oldinaction 
  * 微信公众号：smallelife 
  */ 

define("AppID","你的AppID");
define("AppSecret", "你的AppSecret");

$media_id = '1wrAlWQg02Wc2-z5imqt9K4wzyrugukmMQFCh0tXmixRWKCOIe3Gh9YQa7WjJpeB';//上一讲中上传临时素材后返回的media_id
$domain = 'smalle';//SAE的Storage domain名称
$filename = 'newSmallelife.jpg';//设置保存在domain中的文件名

$ch = curl_init('https://api.weixin.qq.com/cgi-bin/media/get?access_token='.get_token().'&media_id='.$media_id) ;
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true) ; //curl_exec执行成功则返回执行结果
curl_setopt($ch, CURLOPT_BINARYTRANSFER, true) ; //在启用CURLOPT_RETURNTRANSFER的时候，返回原生的（Raw）输出。
$output = curl_exec($ch) ;
curl_close($ch);
//将数据写入Storage
$saes = new SaeStorage();//创建SaeStorage对象
$fileurl = $saes->write( $domain , $filename , $output );//将数据写入到Storage domain并返回存储在domain中此文件的url

echo $fileurl;//输出文件地址
echo "<img src='".$fileurl."'>";//显示此图片

//获取access_token
function get_token(){
	$url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=".AppID."&secret=".AppSecret;
	$data = json_decode(file_get_contents($url),true);
	if($data['access_token']){
		return $data['access_token'];
	}else{
		echo "Error";
		exit();
	}
}

?>效果预览：

在浏览器运行之后，你会在你的SAE管理后台的Storage相应的domain中查看到此文件，由此则对应的media_id素材被下载到了本地。由下图可以看出是上一讲中上传的临时素材，不信可以扫的试试哦。


基于常规服务器的源代码
downImage.php（完整代码下载）

<?php
/** 
  * 作者：smalle 
  * 网址：http://blog.csdn.net/oldinaction 
  * 微信公众号：smallelife 
  */

define("AppID","你的AppID");
define("AppSecret", "你的AppSecret");

$media_id = "1wrAlWQg02Wc2-z5imqt9K4wzyrugukmMQFCh0tXmixRWKCOIe3Gh9YQa7WjJpeB";
$url = "https://api.weixin.qq.com/cgi-bin/media/get?access_token=".get_token()."&media_id=".$media_id;
$arr = curl_file($url);
saveFile("newSmallelife.jpg",$arr);

//获取access_token
function get_token(){
	$url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=".AppID."&secret=".AppSecret;
	$data = json_decode(file_get_contents($url),true);
	if($data['access_token']){
		return $data['access_token'];
	}else{
		echo "Error";
		exit();
	}
}

//curl 获取文件数据
function curl_file($url){
	$ch = curl_init($url);
	curl_setopt($ch, CURLOPT_HEADER, 0);
	curl_setopt($ch, CURLOPT_NOBODY, 0);//只取body头
	curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);//curl_exec执行成功后返回执行的结果；不设置的话，curl_exec执行成功则返回true
	$output = curl_exec($ch);
	curl_close($ch);
	return $output;
}

//保存文件到本地
function saveFile($filename, $filecontent){
	$local_file = fopen($filename, 'w');
	if (false !== $local_file){//不恒等于（恒等于=== 就是false只能等于false，而不等于0）
		if (false !== fwrite($local_file, $filecontent)) {
			fclose($local_file);
		}
	}
}

?>






======================================================================


关注【Smalle】【微信公众号：smallelife】                           捐赠【Smalle】【微信公众号：smallelife】


关注就有豪礼相送哦，源码、工具、文档应有尽有
             你的扫码便是我前进的动力，扫码、扫码、扫码

======================================================================





                                     





版权声明：文章版权所有，未经允许请勿转载！

